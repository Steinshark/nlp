what color is your function i don't know about you but nothing gets me going in the morning like a good old-fashioned programming language rant okay okay okay okay okay guess who just turned off alerts this guy press the like button it stirs the blood to see someone skewer one of those blub languages the hell's a blood language okay i don't wanna i don't want to find out what a blood language is i can't do that i can't do that the plebians use muddling through their day with it between furative visits to stack overflow i think that's a reference to javascript javascript i love it meanwhile you and i only use the most enlightened of languages sizzle sharp chisel tools designed for manicured hands of expert crafts persons such as ourselves okay that's pretty funny of course as the author of said screed i run a risk the language i mock could be the one you like without realizing it i could have let the rabble into my blog pitchforks and torches at the ready and my foolhardy pamphlet could draw their ire it's true i'm going to cut the music because one time i ruined a recording because of it to protect myself from the heat of those flames and to avoid offending your possible delicate sensibilities instead i'll rant about the language i just made up a straw man whose sole purpose is to set a flame okay okay okay i know this seems pointless right trust me by the end you'll see whose face or faces have been painted on this straw noggin okay i'm kind of curious now now you got you got me tickled okay you got me tickled learning an entire new crappy language just for a blog is a tall order so let's say most let's see let's just say it's mostly similar to the one you and i already know we'll say it has syntax sort of like js curly braces and semicolons if wows etc the lingua franca of the programming grotto i'm picking up js not because that's what the post is about it's just that it's the language you statistically representation of the average reader are most likely to be able to grock viola foreign by the way this is a beautiful sentence okay if you don't love this if you aren't in love with what you just read you're crazy okay i'm not in love with your color scheme what what is this what is that what is what is this is this because i'm using dark readers am i screwing up your color here hold on goodness we're gonna keep it like this just because our let's see because our straw man is a modern shitty language we also have first class functions so you can make something like this filter night nice kerning bro hey bro nice kerning uh why why is this so effed up but this isn't what happened there what happened to this filter anyways filter blah blah blah blah blah blah blah nobody cares this is one of those higher order functions and like the name implies they are classy as all get out and super useful you're probably used to used to them for mucking around with collections but once you internalize the concept you start using them damn near everywhere is this a higher order function i don't think this is a higher order function right isn't a higher order function a function that returns a function or am i completely wrong on that isn't this just a function that uses functions like this itself isn't a higher order wouldn't you actually have something called filter that you pass in a predicate to and then returns a function that you can pass any collection to so if you use a function you're a higher order function i think you guys are wrong you're thinking of curing yes curing creates higher order functions if i just higher order dummy okay whatever i'm too stupid to understand this is let's say hi okay okay okay hold on before we continue on let's just settle the debate let's just settle the debate okay we're gonna just settle the debate right here right now new poll higher order function simply has to take in function must return function okay so that's 50 right which means that i'm 100 wrong okay cool cool hey cool this is one of those higher order functions and like the name implies they are classy as all get out and super useful you're probably used to to them for mucking around with collections but once you internalize the concepts start using them damn near everywhere by the way this is like the bane of my existence when you're debugging code where people are just like i i dude sometimes the debugging can be such a pain in the ass it can be very ass painting i i know you functional bros out there are just like currying as for you occurring as the lord's language well i'm not as smart as you it feels hard sometimes when you have a function that's curry taking in functions that are also occurred and you're trying to figure out who is the one that done [ __ ] up okay it's hard sometimes it's hard for us small brains okay a small tiny brains find that very hard okay a fun funk funk funk is a hard function to understand let's see maybe in your testing framework and apple it ain't no orange apple not to be an orange fax or would you need to parse some data tokens match token left bracket consume token right bracket hell yeah so to go let's see so so you go to town and write all sorts of awesome reusable libraries and applications passing around functions calling functions returning functions functapalooza absolutely this was netflix app at one point what color is your function except wait here's where our language gets screwed it has this one peculiar feature every function has a color and each function anonymous callback a regular named one is either red or blue instead of a single function keyword there are two blue function red function this is a blue function this is a red function there are no colorless functions in the language want to make a function gotta pick a color then's the rules and actually there are a couple more rules you have to follow too the way you can call a function depends on its color imagine blue call syntax and a red call syntax something like this okay so i i think we can i think we can clearly see where this is going blue being one of these being synchronous and one being async right i think i i believe i've heard this before i've again i've never really read into this so it just feels exciting when calling a function you need you need to use the call that corresponds to the color if you get it wrong call a red function with a blue after the parenthesis parenthesis or vice versa it does something bad dredge up some long forgotten nightmare from your childhood like a clown with the snakes for arms hiding under your bed that jumps out of your monitor and sucks out your i don't vitrius vitreous vitreous vitreous vitreous humor i i've never heard this term used in this way is this a version of vitriol but used as an adjective like a let's see like glass and an appearance or physical properties substance derive from something containing glass i don't get that your see-through humor i don't get it an annoying rule right oh and one more thing you can only call a red function from within another red function you can call a blue function from within a red one that is kosher okay but you can't go the other way around if you try to do this you're going to get a visit from the old spider mouth from nightclown good old class good old classic spider mouth this makes writing higher order functions like our filter example trick here we have to pick a color for it and that affects the colors of the functions we're allowed to pass it in or pass to it the obvious solution is to make filter red that way it can take either red or blue functions and call them but then we run into the next itchy spot in the hair hair shirt that is this language the hair shirt okay i also don't know this term can someone explain to me what a hair shirt is what a boring blog post this is incredible blog post this is a great great blog post red functions are more painful to call for now i won't precisely define painful but just imagine that program would have to jump through some kind of annoying hoops every time they call a red function maybe it's really verbose or maybe you can't do it inside certain kinds of statements maybe you can only call them on line numbers that are prime for those let's see a hair short is a bandana slash do-rag what i've never heard that term what matters is that you decide to make a function red everyone using your api will want to spit in your coffee or deposit some even less savory fluids in it oh vitreous humor is the fluid in your eye oh okay alas a sadistic language designers and we all know programming language designers are sadists don't we jabbed one final thorn in our side five some core library functions are red there are some functions built into the platform functions that we need to use that we are unable to write ourselves that only come in red at this point a reasonable person might think the language hates us that's actually pretty funny it's functional programming's fault you might be thinking that the problem here is that we're trying to use higher order functions it just stops flouncing flouncing around and all of that functional flippery and right normal blue collar first order functions like god intended we'd spare ourselves all the headaches well i mean in some sense if you can if you can thread you can do this right if you can run your own threads you can just always always blue right you can just always blue the son of a [ __ ] and we can call it a day if only let's see if we only call blue functions make our function blue otherwise it make it red as long as we never make functions that accept functions we don't have to worry about trying to be polymorphic over function color polychromatic or any nonsense like that but alas higher order functions are just one example this problem is pervasive anytime we want to break our program down into separate functions to get reused so for those that like i know i i like this okay because this you know i've never really been one to formalize a lot of my i just blew myself i've never been someone to formalize how i feel about things i just have like these road maps in my head about when do i make a function async or not and i always have this just just i just hate it because once i do it it spreads like you know it spreads everywhere and obviously this i assume this is just simply an explanation of async and that's all it is it's just like man there's times where you want to create something that's synchronous and then it has to be asynchronous and then it's just the worst because it gets stuck in these weird constructs of the language you know and it just it just makes it so annoying sometimes for example let's say we have a little nice blob of code that i don't know implements dykstra's algorithm over a graph representing how much your social network are crushing on each other i spent way too long trying to decide what result would even represent transitive undesirability what what later you end up needing to use this same blob of code somewhere else you do the natural thing and hoist it into a separate function you call it from the old place and your new code that uses it but what color should it be obviously you'll make it blue if you can but what if it uses some of those nasty red only core libraries well what if the new place you want to call it is blue you'll have to turn it red then you'll have to turn the function that calls it red no matter what you'll you'll have to think about some color constantly it will be the sand in your swimsuit on the beach vacation of development fact of course i i mean this is another reason i mean really what this is is speaking about like if you just drop the idea of what color is your function the thing the thing that's really hard and this is one thing that i find annoying about rust is that when you have a value that you have to lift it kind of starts spreading that value so like error handling once you have a function that needs air handling you have to lift the value or you use syntax and it just keeps on it keeps on going this thing and i can find it i i can definitely understand why people find it annoying because or else you have to start doing this like if else business and it doesn't quite work that well especially with the borrow checker just makes it a huge pain in the ass it can be very frustrating like i totally get this even beyond just async await right it's just like observables observables do the exact same thing it's an extremely extremely leaky interface that once you start using them it just goes everywhere and you can't help it because one function that has it the rest of the functions must have it of course i'm not really talking about color here am i it's just an allegory a literary trick the sn the snitches isn't about the stars on the bellies i don't even get that wait what it's about race what the hell are we talking about by now you have a inkling of what color actually represents if not here here's the big reveal red functions are asynchronous ones if you're programming in javascript on node.js every time you define a function that returns a value by invoking a callback you just made a red function look back at that list of rules and see how my metaphor stacks up synchronous function return values async ones do not instead they invoke callbacks yep synchronous functions give their result as a return value async functions give it by a callback you pass in this is before the time of standardized syntax of async await exact same thing is it it's a doctor who book okay well that i'm not a child i have i don't know okay i don't read doctor who because i'm not a baby okay and you know what i read to my kids a wheel of time okay i don't read them doctor who or whatever it is doctor whatever it is doctor who book that's not right either what the hell is it doctor soos as the dr seuss you mean not doctor who dr seuss yeah okay i was about to say doctor who wait a second that's a completely different doctor wheel of time hell yeah you can't call an async function from a synchronous one because you won't be able to determine the results until the async one completes later correct async functions don't compose in expressions because of the callbacks have different error handling and can't be used with try catch okay well some of this has changed but also not incorrect right so you can't chain async function still in javascript you have to do the little you have to go full lisp on it and be like because they chose prefix syntax so it's like await this thing parentheses to json await that thing get this value like right like it just it just grows notes hole stick is that the core libs are all asynchronous though they dial that back by started adding sync yep they did when people talk about callback hell they're talking about how annoying it is to have red functions in their language when the when they create 4089 libraries for doing asynchronous programming i don't think the author saw this one coming okay i don't think they saw that one coming where it was actually going to effectively 13x side in functions make you crazy yeah i get that i prefer my sayadar functions yeah should have should have should have saw that one coming should never put a language you should have put the ever-growing amount i mean he's very flowery with his language as it is he could have made a creative ever growing they're trying to cope at the library level with the problem that the language foisted upon them update nice hey nice comma hey nice comma bro i i promise the future is better people in node community have realized that callbacks are a pain for a long time and have looked around for solutions one technique that gets a bunch of people excited is promises which you may also know by their rapper name futures okay these are sort of jacked up rapper around callbacks and an air handler if you think of passing a callback an error back to a function as a concept a promise is basically a reification of that idea it's a first class object that represents asynchronous operation i jammed a bunch of fancy pl languages language in that paragraph so it probably sounds like a sweet deal but it's basically snake oil promises do make async code a little easier to write they can pose a bit better so rule four isn't quite so onerous but honestly it's like the difference between being punched in the gut versus being punched in the privates foreign statement oh my goodness i just love that technically less painful yes but i don't think anyone should get really thrilled about the value proposition oh this is this literally might be my favorite statement ever read like of all time you can't still use them with the you still can't use them with the exception handling or other control flow statements you can now you still can't call a function that returns a future from synchronous code well you can but if you do the person who later maintains your code will invent a time machine travel back in time to the moment you did this and stab you in the face with a number two pencil yep you still you're you've still divided your entire world into asynchronous and synchronous halves and all the misery that entails so even if your language features promises or futures its face looks an awful lot like one of those one of my straw men oh gosh i couldn't read that thing its face looks an awful light off a lot like one on my straw man okay goodness gracious yes even means dart the language i work on that's why i'm so excited about the team are experimenting with other concurrency models all right i love javascript oh you do you love javascript too okay cool that's neat c-sharp programmers are probably feeling pretty smug right now condition they've increasingly fallen prey to as the heisen the hilsenberg is that's what i don't even know how to say that word hillsborg and company have peeled sweet feature after sweet feature into the language in c sharp you can use a weight keyword to invoke an asynchronous function yeah let's this lets you this lets you make asynchronous calls just as easily you can synchronous ones with a tiny addition of a cute little keyword you can nest await calls and expressions you can use them in exception handling code okay so this is all done in javascript now obviously stuff stuff them into control flow go nuts make it rain await calls like they are dollars in the advance you got for your new rap album async await is nice which is why we're adding it to dart it makes it a lot easier to write asynchronous code you know but is coming it is but you still have to divide the world into those are async functions those async functions are easy to write but they're still async functions you've got you've still got two colors async await solves an annoying rule four they make red functions not much worse to call than blue ones but all of the other rules still apply synchronous functions return values yep sync functions let's see yep you need the colon async function you've got this wrapper object when you actually want t yep yep aside from the liberal garnish of a weight we did we did fix this c sharp's core library is actually older than i think so i guess i'll never have this problem yep i mean this is all true this is all very very true it is better i will i will take async await over a bear callbacks or futures any day of the week yep but we're lying to ourselves if we think all of our troubles are gone as soon as you start trying to write higher order functions and reuse code you're right back to realizing color is still there bleeding all over your code base yes this is very true as someone who has to do this i i really do hope i like async iterators those are pretty cool in in javascript they they tend to at least fix some of the issues because then you can do a little bit more but it still is kind of a pain in the ass ugh what language isn't colored so js dart c sharp python have this problem coffeescript and most other languages that compile to javascript to do too which is why dart inherited it i think even closure script has an issue though they've tried really hard to push against it in their core async stuff want to know which one doesn't java i know right how often do you say yeah java is the the one that really does it right but there you go in their defense they're actively trying to correct this oversight by moving futures in async io it's like a race to the bottom c-sharp also can avoid this problem too they've opted into having color before they added async await and all their task t stuff you could just use regular sync apis three more languages that don't have this problem go lua and ruby yeah any guess what they have in common threads and more precisely multiple independent call stacks that can be switched between it isn't strictly necessary for them to be operating system threads go routines go routines and go co-routines in lua and fibers and ruby are perfectly adequate yep yes yes go routines just make it super simple right you don't really have to think about anything and i think that that is really nice i actually really like this fact go does have the problem your functions that return channels well no channel i don't think that's really a problem right a channel is just a concept that doesn't have anything to do with with with threading or coloring i don't think they do at least i'd have to think about it but i'm pretty sure threads or channels are just a little bit different maybe you're right waiting on a channel is coloring no because you don't have to call anything differently that's the point is that when a function is red or blue there's specific syntax to calling that function that's different so you have async await or in a rust you have dot await or in whatever other crazy language you have some other operator right you have i'm sure there's one in zig that i just don't even know about but nonetheless you have some special syntax you have to apply to the situation a channel though you literally call it and return it no differencing to your function and it goes and it does its own thing and then comes back and you get the value back out right so it's like you don't have to do any sort of special syntaxing they just have a lift operator that freezes your current thread until it's done which i think is that's that's perfect right i think that's perfectly fine i think that's perfectly and completely acceptable as as it is so i don't think goes colored i'm pretty sure go is not a colored language the remembrance of the operations of the past the fundamental problem is how do you pick up where you left off when an operation completes you build something let's you build something up let's see oh my goodness you've built up some big call stack and then you call some i o operation for performance that operation uses the operating system's underlying asynchronous api you cannot wait for it to complete because you it won't you have to return all the way back to your languages event loop and give the os some time to spin before it will be done once operation completes you need to resume what you were doing the usual way a language remembers where it was is the call stack that tracks all the functions that are currently being invoked and where the instruction pointers is in each one yeah but let's see so this is just basic explanation of an event loop so that's why you can't that's why and that's why you can't like you can't do a function with a callback and then do a while loop right afterwards it will never get called it's because you have to return control to the event loop before anything can even kick off or do anything because that's just that's javascript i love it but to do async i o you have to unwind and discard the entire c call stack kind of a catch-22. you have to let's see you can do super fast i o you just can't do anything with the result every language that has async i o in its core or in this case js the browser's event loop copes with this in some way node with its of ever marching to the right callbacks stuff all those call frames enclosures yep that's all that happens that's all that happens each of those functions expressions closes over the surrounding context that moves the parameter like ice cream and caramel off the call stack and into the heap well no that's not true that's when it comes to this that's that's not what ever happens in javascript obviously with javascript it's always on the it's always in the heap i mean javascript is always heap always heap that's just all javascript does all the call stack into the heap when the outer function returns the call stack is trashed it's cool the data is still floating around the heap the problem is that you have to manually reify every damn one of these steps there's actually a name for this transformation continue it continuation passing style it was invented by a language hackers in the 70s as an intermediate representation to use in the internals of their compilers it's a really bizarre way to represent code that happens to make some compiler optimizations easier to do oh that's weird no one ever thought for let's see no no one ever for a second thought that a programmer would write actual code like that and then node came along and all of a sudden here we are pretending to be a compiler back ends where did we go wrong that's that's a pretty great statement no that promises and futures don't actually buy you anything either if you use them you know you're still hand creating giant piles of function literals and you're passing them to the dot then instead of to the asynchronous function itself yes this is true you're you're not you're not buying anything here awaiting is generated solution async away does help if you peel back the compiler skull and see what it's doing in there when it hits a weight you can see that it's actually doing the cps transform that's why you need to use a weight in c sharp it's a clue to the compiler to say break the function in half here everything after the await gets hoisted into a new function that the compiler synthesizes on your behalf yeah this is why async away didn't need any runtime support in.net framework the compiler compiles it away in a series of change closures that it actually that it can already handle interestingly closures themselves also don't need runtime support they get compiled into anonymous classes in c sharp the closures are really poor man's objects huh okay that's interesting that you didn't yeah you didn't need a run time for that that's cool that's cool that they had a single weight without a run time okay okay i didn't realize that when i built a compiler myself back in the day for mini pascal we effectively did this we could there was no because i built it for uh it was called il back in the day this was before llvm it was microsoft's intermediate language so it's like a language to represents all of its languages that it has to be compiled into this intermediate style that will then be compiled into the correct target and so we had to build a compiler for il and il didn't have closure so what did we have to do we had to generate a whole bunch of like these functions that you'd actually secretly pass a bunch of values to right and so we had to like create a bunch of it it was fun it was a cool project it really taught me a lot about some really weird things you might be wondering when am i going to bring up generators does your language have a yield keyword then it can do something very similar in fact i believe generators in async await are isomorphic i've got a bit of code floating around in some dark corner of my hard disk that implements a generator style game loop using only async await i'm not sure if i think that's a good idea oh wait where was i all right so with callbacks promises a single weight and generators are ultimately end up taking your asynchronous functions and sparing it out into a bunch of closures that live over in the heap yeah that's that's correct your function passes the outermost one into the runtime and when you the event loop or i o operation is done it invokes the function and you have to pick it up where you left it off but that means everything above you also has to return you still have to unwind the whole stack yep every single time that's the only way to progress things forward that's just how event loops work dog that's just how they work dog this is where the red function can only be called from red functions rule comes from you have to a closure you have to closer if i have the entire call stack all the way back to main or the event happen handler i know do you do you guys not know about this part how many in chat really like how many in chat is this completely like novel concept to that have just never really thought about this i think somebody literally just said observables for the win observables are literally this multiplied observables are just as red new to me really wow okay no idea anyways it is it observables aren't they don't buy you anything in fact they just they just buy you a more complicated version of this because now an observable isn't just a one-to-one operation it's actually a one-to-many operation that's like an entire new level of complication right when you have to handle the idea that your function could execute more than once or your return value could be more than once it's like a whole thing it is an entire it's an entire thing i enjoy piping go for it i'm too tired for this i'm gonna get the milk okay go go for it buddy all right where are you okay we are almost done here awesome okay reified reified call stacks but if you have let's see but if you have threads green or os level you don't need to do that you can just suspend the entire thread and hop straight back to the os or the event loop without having to return from all those functions yeah so this is exactly this is literally what i was saying you could just always be blue and just have threads right that just works go is a language that does this most beautifully in my opinion as soon as you do any i o operation it just parks the go routine and resumes the other ones that aren't blocked on aisle i actually do think goat does this the best go hands down just does this the best if that's why go i think is such a great language i just wish it had just such a small amount of effort into go i think could make it so good if we just had slightly if we could just come up with a convention that makes it easy to return errors if there errors right i know they're kind of working on it i know there's been discusses of it just do what zig did right try this function if it returns an error for as the first argument or the last argument however you want to define the convention then get the hell out of there return that error back up right just don't make us right if air does not equal nil right that's it go everything else about go is fantastic i like its simplicity i would love more generics obviously i want to make a go more complex all the time i'm not sure if that's good though i don't know if it's good that's my one problem with ghost that i want all these things but i'm not sure if i just recreate the mess i already have if you look at the i o operations in the standard library they seem synchronous in other words they just do the work and then return the results when they are done but that's not but it's not that they are synchronous in the sense that they would that it would mean in javascript other go code can run while one of these operations is pending it's that go has eliminated the distinction between synchronous and asynchronous code concurrency and go is a facet of how you choose to model your program and not the colors seared into each function in the standard library this means all the pain of the five rules i've mentioned above is completely and totally eliminated so the next time you start telling me about some hot new language and how it's awesome or how awesome its concurrency story is because it has asynchronous apis now you have to know why i started grinding my teeth because it means you're right back to functions and blue ones yep so rust certainly has this problem and i've definitely found this problem to be quite annoying in rust i actually find one thing that's even more annoying in rust is that since futures are pull if you don't add the dot await and you ignore say a warning it like doesn't execute at all and then you're like dude what where where am i why isn't this happening like that can be like i don't like hot i don't like hot promises or hot async code but at the same time i kind of like hot hotness right they're trying to solve the problem with keyword generics the thing which is in the proposal with the crazy syntax yes i know but is that any better i'm not sure if that's any better right are we written in regards to colorless the zig functions in that article i haven't i haven't done anything with i don't know enough zig asynchronously to have like a strong opinion or even any opinions our go routines running in parallel or just concurrently they're both they're parallel you can run them parallel parallel they're just green threads right so it depends on your like operating system and and the run time so if you have one core you can't really run it in parallel you know what i mean but you can get parallel x like so so here's a really simple test you can do to prove it just go create a map go create a bunch of go threads and have them or go routines and have them effectively just just have them effectively just all read and write to the same map you'll get a concurrent you'll get it like a data race issue really quickly right you'll get a data race super quick which means they're parallel they're not concurrent well they're also i mean anything that's parallel parallel i mean in a sense is also concurrent c sharp is experimenting with green threads now they're good hey i saw that i saw that red and blue functions green thread so what's the alpha channel nobody knows nobody knows what the alpha channel is but we're going to discover it one day and it's going to solve all of our problems and make programming beautiful again the name is the green threadogen