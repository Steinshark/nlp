recently on developer voices we took a look at the zig programming language and a few people got in touch to say well if you're interested in se like languages you should look at hair as well it's a language in the same space but it's got quite a different set of goals it has different ideas about memory management and types about metaprogramming and probably the most ambitious of its goals is to become a 100-year language a language you'll still be using in the 22nd century i can't even begin to imagine what programming will look like next century but drew dult our guest this week has plans to make sure hair is on the list and if 100 years sounds like too lofty a goal for you he makes the point that sometimes it's hard enough to get a 5-year-old project to compile might be quite refreshing to have a language that just guaranteed no breaking changes this decade so what are hair's answers to the problems of se what's drew's strategy for the long long long term and for bonus points we end up talking about aries which is the operating system that drew's been writing in hair to prove you can write an operating system in hair let's get stuck in i'm your host chris jenkins this is developer voices and today's voice is drew [music] deval [music] joining us today we have drew dev vault drew how are you oh i'm doing great how are you doing i'm very well i'm very well i'm looking forward to christmas it's that time of year around here likewise i just wrapped up my partner's presence and stuck them under the tree ah so they're probably hiding under the tree scratching at it with a fork right yeah well the cats certainly is perfect so the other thing that's keeping you busy apart from wrapping presents you you're one of those people that has a tremendous ambition here because we're going to talk about your programming language you're writing a programming language and an operating system at once right i am yeah that's you're either mad or a genius so we're going to spend the podcast finding out i'm not sure the two states of being are discernable from each other that's true it's generally in the results that you figure that out right but let's start with your language which is called hair and it's firmly in the sea tradition of languages right yeah more or less i'd say that what makes it not c why wasn't c good enough for you well you know c is very popular and it has a lot of staying power but it wasn't exactly designed to it just kind of accidentally ended up being a staple because it was attached to unix and it was capable of doing a lot of important things so i think what distinguishes here from c is 50 years worth of hindsight that c never had and so it's got a bunch of features which address shortcomings in se which is things like improved safety features improved era handling a dramatically improved standard library things like that okay well i mean that the thing that raises is 50 years of hindsight there's a heck of a lot to choose from oh yes and you could look at something like i don't know you could look at haskell and idris mhm for instance and they'd say our 50 years of hindsight says let's throw mathematics at it right what what do you learn from 50 years of hindsite well you know i would disagree with the haskill group on the basis that functional programmers tend to imagine an ivory tower where everything is made of pure math and i imagine the computer which is sitting in front of me and try to think about what it can do you have to excuse the jab at the functional programmers i do appreciate them no i i will neither i will neither defend nor be offended i want to know what you think of the world yeah yeah i mean so when i look at c i see a lot of things which are important and which some of them can be attributed to its successes some of them are better perceived as failings and i think you kind of see something in c which is like it came around from unix and unix was kind of designed for a certain purpose and in a certain time where you know you see these trends older operating systems where there's a little bit less thought in the design and a little bit more about what can we make work and at the time it was great and it made unix possible but you see a lot of these baggages surviving on and so some of the things we can learn from c is you know a broad broad applicability to many problems a really great sense of portability a nice standard in many implementations and access to low-level primitives which is all very important and we can also see things which we don't as much like so we see a lot of the baggage of unix and posic which is a little bit iier things like a global eror no is kind of like a an example of a weak decision and we've seen in the time since eror handling become understood to be much more important than it was understood then and so there's an opportunity there to revise that design with its importance in mind and with a more deliberate approach and so it's things like error handling and memory safety and some of the craft of the standard library which was evolved organically more so than it was designed yeah these are great opportunities to improve okay well let's tackle error error handling what's what what can you fix about that well the way it works in c is essentially they have a global variable called ao which from the outset was quickly determined to be a problem as soon as multithreading got involved and so now we have a pile of hacks to make that work but if you do anything that could that could fail like opening a socket or opening a file it will return often like with a a negative number to indicate that it failed or something and then it will set the error no value to something which describes the error from a global list of possible outcomes that affect everything that could fail and then the type system doesn't really do anything to to make sure that you're understanding the difference between an error case and a successful case so it's up to the programmer you know if they call f open and it fails they still get a file pointer in their variable it's just set to null and then if they keep using it without doing the extra work to check the error then they're in trouble and this is a very common failure of working with c and then if you have third party libraries outside of the standard library they might have their own error conditions and their own approach to error handling which doesn't exactly fit into what the c library is doing they can't really expand arono with additional domain specific errors for example and so everybody has to come up with creative solutions and none of them are make it actually easy to do good error handling in your program so what what have you done what's your solution well i think that there's a number of ways that people have approached error handling outside of c and the one that we favor is tagged unions and the idea of a tagged union is it's a kind of type which can store values of different types so a single value which is of the type tagged union can be one of several types and only one at a time so you could for example have a tagged union of an integer and a floating point number and it could store either of those but it only stores one at a time and it indicates in the value which one it is so it might say the tag is zero to indicate that the value is an integer or one to indicate its floating point number and we've created first class support for tagged unions they're kind of ad hoc so unlike zig or rust where you have to predefine them and they're kind of like a super % of unms in here they're ad hoc and what you do is you create a tag union of all the success cases and all the error cases and error cases are set aside special in the type system with a flag that says this is an error type and if you're handling a value which is a tad union that could include an error type there are some additional constraints imposed by the compiler on what you do with that value that basically forces you to do something about the error before you can use the value of the success case okay so have you got something where like your file open example it can return file not found or file not readable or file successfully opened and here is the handle yeah exactly so in c the fop calls return type is a file pointer and it can return either a valid file pointer or null and when it returns null it separately sets the error number to the the cause right whereas in ha our os open function which is a similar equivalent it returns either a valid file handle or it returns file not found or access denied and it encodes that information into the return types that the language can be aware of those different cases and tell the programmer they have to address these cases and they can address it either by explicitly testing for each case and adding different logics so you might want to do something differently on not found versus access to n or you can address it by passing the error further up the call stack and centralize your error handling somewhere else or you can use an error assertion which is just the bang operator which is an assertion where the programmer says i promise that i've done the math and i don't think that this error case is actually possible under these conditions so just assert it that it's not possible and give me the file handle directly only handle the sucess case but then the the programming language automatically checks your work it's an assertion so if that error actually does come to pass at runtime it'll terminate your program okay so you can optionally say i don't want the bookkeeping but it's okay for you to crash at runtime if i'm wrong exactly yeah yeah yeah do you still have nulls in the language we do have nulls but you can only use them through a pointer type which has the nullable flag set and again if you have a nullable pointer type using it requires extra work so you can't just directly to reference the pointer you have to check for null first okay and do you have exhaustiveness checking on that like yeah so you can make sure i check all the different cases if i need to i should clarify we have some exhausted testing we have switch statements for testing against values and match statements for testing against types and right now switch statements do have exhaustivity testing match statements the specification requires exhaustivity testing but we haven't actually implemented it in the compiler yet okay still a work in progress however we have implemented an assertion where if you get to the end of a match expression and none of the cases were matched will throw at a runtime assertion because that's not supposed to be possible okay cool how about my other big sticking point with c mistakes made yeah i don't think the macro system is terribly good in c i agree i don't think that's a controversial opinion what have you done with macros nothing we don't have them you threw them away yep there are some languages like rust which prefer like like semantic macros i think they're called where like your your macro execution phase of expanding the macro gets a copy of the a and can do smarter things with macros and i think that's significantly better than c but we have decided like as a goal we're kind of assuming metaprogramming generally and macros are a form of metaprogramming because we think that for a language where it values simplicity and transparency metaprogramming is kind of an anti- pattern for us and so instead we use codenation sometimes we have have tools that can interpret a dsl or can even rewrite a hair file and output generated code which fills some of the need where macros are currently used without actually having a macro system okay is the code generation like a tool built into hair or a separate thing that you would use somewhere in the middle so our standard library includes a hair parser so if you're writing a hair program you can import a parser for the hair programming language and get an as it also includes a type checker so you can run the type checker and make sure that is consistent with the semantics of the language and then you can also unpar the est using the standard library so if you could take an as and turn it into code so if you wanted to write a tool which did code generation or manipulated herir code in some way there are resources from the standard library to help you do that but there's not exactly like plug- andplay code transformation tool okay and is that like the the part that turns in your newly constructed or newly manipulated as back into code does it turn it back into string like a file that you write to the system or runable code that this program can now execute it just turns it back into a source code string and it does that by writing it to the file handle abstraction we have an abstraction where you can do it can be backed by a file handle opened on the system like unix or you can implement streams in user space so like you could unack the a into adesive stream into the network socket for some reason so it's flexible in that sense but not in the sense that it can produce machine code through this se okay what else about the you said about the standard library and that's novel having the language sort of built into the standard library what else have you added to the standard library we have all sorts of things we have basically everything you would get from a c standard library is is present so we have support for all of the unix stuff like groups and parsing etc password files we also have all the networking tcp udp dns we have a much better dns api than libc provides where you can like do arbitrary dns queries so we've kind of rethought those abstractions from c and then we've also added a bunch of other stuff we have a finite scope for the standard library but it's a bigger scope than live se and so we have things like hashing functions we have fv crc those kinds of hashes we also have a cryptography suite which supports a whole bunch of modern cryptography primitives that we've impl implemented ourselves we also have a fundraiser to audit our implementation by the way and we have a some other stuff like buffer io which is again the abstraction has been rethought from the c approach so that those primitives are available for you to use and more concrete manner so there's all kinds of stuff in the standard library i think it has a really good amount of batteries as it were especially compared to c but it's still finite in scope and then we also have the extended library which is a collection of libraries that exist outside of the standard library per se and they make different stability guarantees in the standard library but they're still under the perview of hair and they're considered important for the ecosystem so for example the http implementation is in the extended library right yeah that stability leads to another question what status is hair at is it production ready is it research project it's somewhere in the middle so we have this goal of becoming a quote 100-year programming language which is something that we're working towards so stability is one of the most important values of hair but we are not actually achieve that yet we want to get to the point where we release hero 1.0 and we say we will promise to forever support backwards and forwards compatibility from this day onwards which is a big goal and we're getting there but we're not there yet that said setting aside the overambitious goal of freezing the language forever which most programming languages don't take on i would say hera is somewhere close to the stability of other languages that don't have that goal it's still missing a number of things and we have some plans which could introduce large breaking changes like we're going to research linear types for example for memory safety yeah and those could could break your program and we also are still sometimes doing large refactorings in the standard library which break people's code but it's a language you can use to write serious projects today and many people are using to write serious projects today okay if you got an examples like what kind of things people using it for so the postmarket os project has some people specifically affiliated with the x sxo desktop solution for mobile phones which are using hair to build some some tools for mobile users and uis for mobile users integrated into their desktop environment i'm also using it to work on a a secret storage manager which is like a generalization of a password manager and that's stable and released and to some extent in general use people are working on build automation tools and ui toolkits and all kinds of things of that nature okay okay so let's zoom out because you've mentioned your 100-year language goal yeah and and this is something i find really interesting about hair you've got you're saying we've got 50 years of hindsight to learn from and we're aiming at still being the same language a hundred years from now yeah how on earth can you possibly look a hundred years ahead and predict what's going to be needed we can't and we're aware of that so something we've acknowledged is that hair 1.0 we'll we'll do 1.1 and 1.2 keep maintaining it and working on it but it will not be a 2.0 but her the language as it appears on the day that 1.0 is released is going to become a time capsule and we acknowledge that and we're happy to let other languages continue to develop and work on innovations and i think that's something that's very valuable for the ecosystem going into the future but this approach to stability is kind of a counterweight to what i think is a little bit more mainstream right now which is kind of reckless instability to be honest if if you for example try to find a binary that was built for linux three years ago and run it today you're probably not going to work and that's something we kind of want to correct for and so if you're writing software that you have want to have that kind of longevity i think hair is a solution that we want to be available for you and it's true that hair will become more ideologically obsolete over the next 100 years for sure but unlike a lot of languages which are going to keep with contemporary language design ideologies her is still going to work so i think that's an important difference you know i think a lot of languages as they look today those languages are going to keep evolving but software which is written today for those languages has to evolve alongside of them whereas hair we're hoping that all of the software which is made for hair will also have that longevity you built into it so you're saying if imagining you've released 1.0 and someone's written a large program in 1.0 yeah now we fast forward 50 years and i have to write a new hair compiler for a new architecture of chip architecture that's out there yeah but you think the program that was written today will still compile to that same spec 50 years from now i think so i mean we have some constraints around exactly how those guarantees work so so for example if this big program has components written in assembly obviously you'll have to port those to your new architecture but any program which is written against the standard library using portable code will still work the pitch that we give is on the day that hair 1.0 is released if you write a program in hair in 100 years time it will still compile for new systems but we also say if on the day that hair 1.0 releases you take the specification and you write a compiler based on that spe ification on day one in 100 years that compiler will compile contemporary code right okay that's the promise that so that instantly makes me think how on earth are you going to know when it's time to say this is version one i would be tempted to always put that off just a little bit longer while we are out the edge cases well basically we have a plan in mind we have a fairly fix a number of research targets that we want to evaluate before we consider the scope of the language complete and that includes things like the linear types example also another thing we want to research is alternative approaches to memory managers and we also have a handful of little design things that we're kind of playing with which similar cavat applies they're fixed in number for the most part that that list of smaller things still grows but we want it to grow forever but once we run out of these these predetermined design areas that we want to do research in that might change how the language works we're going to arrive at what we think should be her 1.0 and then we're going to begin a process that we call acceptance testing where we're going to create multiple teams within the hair programming team which is about 100 people today really we're going to create we're going to subdivide ourselves into teams based on areas of expertise and domains and we're going to run over the whole language with the fine tune co we're going to have areas as narrow as things like networking support or io and also things as broad as like linux support and these teams are going to evaluate the whole language on those terms and produce reports and make recommendations for things that need to be changed and this acceptance testing process is expected to take a few years and that's going to be the majority of the work that goes into hair for a while from the official team upstream as it were and once we have completed that process we're going to release 1.0 and that's still probably going to have mistakes there's going to be some stuff where in 20 years time we're going to be like really maybe we should have thought this differently but we're going to do our best and because this longevity is a goal i think that we have to be willing to compromise on not having imperfect for you know so you're saying there will be i'm thinking of the human an appendix there will be parts that maybe in hindsight weren't actually necessary yeah but but you're placing above that the guarantee that for the whole hundred years of the language there will be stability yeah there i mean the compromise is that the language will probably have an appendix for 100 years but it will also probably work for 100 years yeah yeah that's fair enough much like us humans yeah exactly yeah roughly although not all of us make it do 100 not all of us have an appendix either so there we go true okay okay so that you've you've mentioned this twice now linear types and i think we have to dig into that because that's the other mistake thing we thing we would do differently in hindsight about c is memory management yeah and garbage collection is one solution which has problems for system programming rust has another which is borrow cheing what's your solution to it so presently we have some featur features around memory safety which are more features and less of a comprehensive approach like a borrow checker or a garbage collection for example all of our slices we have slices as a first class feature arrays of slices indexing them is always bounce checked by the compiler and will terminate the program rather than do a buffer overflow we also have some features in the works where we have like working proof of concept but they're not done yet with respect to things like address sanitizers and so this kind of thing we're working on but it's less of a comprehensive model like like rust or go garbage clastic languages have and our answer to the comprehensive approach should we decide to to try that is to use linear types possibly and we might also research a borrow checker but i would say that we are satisfied with the degree of memory safety that is achieved by hair today which is not a comprehensive system but it's enough that i think you're not going to get nearly all the mistakes that you didn't and see which is a a statement that some rust advocates may become controversial but nevertheless regarding linear types which is this comprehensive solution we're researching it's not actually my domain it's being led by other hair maintainers but my my layman's understanding is that linear types is basically a system wherein a value of a linear type has to be used exactly once and you can if you use it zero times you get an error if you use it two times you get an error and so if you need to use a value multiple times you have to use it in a way which creates a copy of that linear type aspect kind of like an ssa form and if you free it that's using it so you can't use it after free and if you forget to free it like a memory leak you've use it zero times and that's also invalid so it kind of t checks for those kinds of aspects of your usage of values and i think it does provide a relatively comp apprehensive memory safety model but again that's not my area of research that's some other maintainers working on it can you i'm going to risk pushing you on that even though it's not your area of expertise then but can you can you explain how that would work in practice because i i i've dabbled a little bit in linear types but i think most people won't know why this is an interesting idea well again with the caveat that this is definitely not my area of expertise all i've done is read some of their emails about it but the like for example if you want to work with a file you open a file you write to the file you close the file and one of the possible errors that can occur under that condition is writing to the file after it's closed and so this is a kind of a generalization away from memory management this is other kinds of resource management that this technique applies to and if you open the file you do error handling which is separate but at the end you get a file handle and this file handle has a linear type which means that you must use it ex exactly once and if you pass it into the right function to wr to the file that's using it and so the the linear type value is then consumed and then in order to use it again for another right the the right function will essentially return a copy of the file which is a brand new value that you again have to use exactly once and if you pass it into the file closing function because you're done with it it's different from right and that it doesn't return a copy of the file handle it consumes it and then you don't have an opportunity to use it again and so through this approach of use exactly once types you can't forget to close the file and you can't write to it after you've closed it so it's like a kind of resource management that that adds these safety features through this kind of only use once approach yeah that makes some sense cu we do have this situation where we're managing different resources like network handles or or and we've got we've got solutions for managing generic resources like with for example and then we've got solutions for managing memory like russ boroch cheer but nobody's really trying to unify that i think some people are maybe trying i imagine the r type system might be able to accommodate this i'm not sure but yeah it's definitely something that i think we're appreciative of that this generalizes beyond memory management into general purpose resource management okay so how does that play out in language design if you're interested in adding that to hair but you're not doing it this presumably isn't a benevolent dictator for life model well there is a benevolent dictator for life and that's me but that means i try to be as benevolent as possible okay that's actually so my responsibility as the bdfl is explicitly outlined in doc bdfl dmd in the repository which elaborates on what that role actually means and then we have a separate document for maintainers but my bdfl approach is as hands-off as possible so i i want to be used as a tool that the community can utilize when my feedback is necessary so that includes for example being the financial steward of the project i'm responsible for all of the money as it were and that's something that other people don't have to think about they can just work on the code and then i'm also have you know the the vague role of providing the vision for the project and i also have the vague role of you know if there's a conflict in the community i'm the deao mediator of that conflict and if people can't agree then i the gna be asked for the final say but this is something that the community asks me to do because it's a tool that they can use when it's useful rather than an imposing dictatorship kind of thing and so i try to give as much autonomy and agency and authority to other contributors as possible so like there's you know bdfl is separate from maintainer there's i think four or five top level maintainers with responsibility over the entire project and they have the latitude to make a lot of decisions without my input and we also have an rfc process which is informal and op in so if you want to make a change to hair you don't need to make an rfc but if you feel like it's a larger change or requires some discussion you can opt into making an rfc or somebody can ask you to make an rfc where you can explain the purpose of your change and have that discussion and seek consensus before you do it and so i think the linear types research is an example which is still early and pre rfc but we have other large changes which go through that rfc process and if they acquire consensus you know there's no explicit approval is just read the room if the vibe is that people like the idea and think it's refined enough then go ahead and write the patches and if not keep talking about it so if you achieve that informal consensus through an rfc you're likely to get a large change to coin and you can go ahead and start writing the codes and making the change happen and you know do all the planning you need in the rfc discussion okay that sounds very very soft i mean compared to something like an apache project that's a very loose approach and yet you're managing a 100 programmers you say does it well managing you know there's that's the number of people who have commits right it sounds like you're less the benevolent dictator and more the benevolent midwife to this yeah maybe i mean you know anything any any responsibility that the bdfl traditionally has is annoying because of a busy guy and if another contributor is good at doing those kinds of things and wants to take it on board i'm thrilled about that so even like stuff like community management we have a conduct enforcement team which is not just me it's me and two other contributors who are trusted by the community and so bdfl is useful to have have reserving the last word as it were is something that can be definitely useful to the project but i think it's there because it's useful not because it's imposed and the project for the most part runs itself and we establish a culture of consensus and of people taking responsibility for the parts of the project that they're interested in and want to work on and then also giving them those responsibilities and rewarding their agency in that respect creates for a really healthy dynamic where things can get done in a way which is informal and rewarding for everybody which is important because they're all volunteers yeah yeah i can see that working very well for like language capabilities and individual areas of language design but how do you ensure that it keeps a cohesive hole as a language rather than becoming an archipelago of people's best ideas so there's a couple of ways you know we have for example a canonical style guide and everybody is required to adhere to the style guide and part of the consensus making process involves you know getting your api design approved by the consensus on the basis that is conformant with the design approach that we take everywhere else but also there's this really nice thing about hair which is that a lot of people have remarked about this the language is quite simple it seems to have exactly the right scope because you don't get enough rope to hang yourself with but you get enough rope to do what you need and the consequence of that is that a lot of the time if you're designing an api in hair for the standard library or for your own library or for anything it usually happens to be the case that the first api design you write is the right one and it's to the effect where there's like almost just the one way of writing hair code so if you have a problem there usually one way to solve it in hair especially in terms of api design and because of that there's not a lot of conflict about like design style and so on in the standard library because it all tends to converge towards the same self-consistent result okay if you're finding that in practice that's impressive yeah i'm very happy with that that's one of my one of my favorite traits of what we've accomplished here well maybe that speaks to the the typical user of hair if someone's i mean there's there's competition in this space for lowlevel systems languages yeah and without without saying anything about the competition directly okay like why would someone be drawn to hair more than say rust go zig or just see i think hair has a lot of advantages in that respect it's certainly has a lot of advantages over c and you know for example somebody with a c++ background might prefer something with a similar level of complexity or or tools that they can use and hair is really not for that it's for people who prefer the simplicity so people who who are using c and the they're not you know held hostage by c because of their job or their their their target use case or whatever they they like using c or they have stock b syndrome maybe those people i think at the target audience for c who value that simplicity and also it's just a really fun language to use i think the standard library provides a perfect number of batteries where a lot of stuff you want to do is going to be accommodated by the standard library and it's going to feel good to use we have really nice tooling so we have a command line documentation viewer which is super super pleasant to use as part of your daily workflow we have super fast build times you can actually bootstrap the entire tool chain including the back end and the front end from scratch running all of the test suites in less than five minutes and so it's fast it's simple it's easy to use it's fun to use i think that appeals to a lot of people in our community how many different architectures does it compile to presently three it supports x86 64 arm 64 and risk 564 i'm just wondering how if someone wanted to add a fourth to that how large a language does it turn out to be as an implementor so new architectures are supported through our backend which is called cube cube written by quinton carbono i think it's spelled qbe i've never actually said his name aloud so i really hope that i pronounced it right and it's a weird code bas i'll be honest with you it's a bit of a strange code bas it's a perfect tool for hair and it makes a lot of sense for a use case but getting into it we have a number of hair contributors who work inside of cube as well and it's definitely a different experience but adding support for a new architecture is not super difficult but almost all the work is going to end up there you have a little bit of work to port the hair standard library to an architecture and a couple of other places that might need to be updated but mainly you're going to be putting all of your effort into cube and risk five support actually came about about because we asked [music] michael forny a really smart guy to actually implement a risk five back in for cube so we could use it in hair and this took him like he's a really skilled programmer to be fair but it took him like less than six months and in the end like the risk five code is 2,000 lia code or something and so implementing a new architecture non-trivial but also not super hard okay yeah because it must happen if your vision comes fruition over the next 100 years there will be new architectures right yeah and we plan to port it to a few more cells we want to do power pc want we want to do some 32-bit targets 32-bit targets in particular are going to be a little bit more challenging that will require not only adding it to q but also doing some refactoring in our compiler 64-bit target should be pretty straightforward i think if you just add those to cube that's most of the work done and we also we we're going to target for the primary hair standard specification 32-bit and up for architectures that we support but we're also going to make a supplementary specification which loosens a lot of the rules to support 16 and 8 bit targets possibly without guarantees of portability between the two and for that purpose we might do some other fun ports like z80 or something okay so there's still hope of me getting hair on my commodore 64 yeah it could be in the future but you know you could also maybe forgive us for not prioritizing it yeah i think i will so one architecture i know you're going to be well not architecture what one target i know you're going to be compiling to is your other project if you're not busy enough already is a is your operating system yes i am writing an operating system in hair and it have support for running hair programs in user space before it has support for running seed programs in user space as i sort of hope so i mean it's tempting to talk about the life management issues when you're already busy enough but tell me about the os what what do you need what when you're already so busy why add writing and operating system to your work deack well i you know in a way working on this operating system is contributing to hair because one of the explicit design goals for hair from the start was we want to be able to write arting systems we want it to be useful for colonal development and we have to actually write an operating system in it to prove that we've accomplished that especially if we're going to freeze it for 100 years and then 20 years later we try to write an os and whoops actually it's not possible you know yeah but also like i said you know the hair project almost reads itself like i don't have to do a whole bunch of work because i endow everybody with responsibilities and agency over the project and i try to do this in all of my projects that have aerg of community i try to empower the community so it's not a huge drain on my personal resources and also i work full-time in free software i have my own software company and it's part of our mission to work on stuff like this so it's not like i'm doing this in the evenings and after i exhaust myself at a day job this is my job okay but yeah i'm also writing an operating system because it's really really fun how do you get to the point where it's fun how do you learn the basics enough to to get to because it's such a hugely scoped project i mean i wouldn't even know which side of the mountain start climbing i mean the first step is to to write enough codes that you can boot your pc up and it says hello world this is not too difficult as a matter of fact but you know i think that there's definitely writing an operating system is very ambitious but also quite possible if you're willing to put in the time and if you're able to put in the time which not everybody is but it definitely you know it shouldn't be your first programming project but i think somebody with like 5 to 10 years of experience programming especially syst programming is totally well equipped to try writing an operating system especially if they're comfortable like reading cpu architecture manuals and like the source material they're not going to rely so much on wikis or blog posts or whatever this kind of programmer would probably have success if they wanted to write nos okay so are you just doing it to to exercise hair or do you hope that you're os becomes i mean you are you can you see a future way you're the next line of tov volt i really don't think so i think is far too entrenched but i am designing it seriously because at least i want to use it and anybody else who has similar needs to me might also benefit from using it so it's general purpose and it is a serious project and maybe someday will be useful but like i'm not exactly setting like be the next linux as a goal because i don't think it makes sense to do that and it's also kind of outrageous true true i'm not even sure lonus well i'm certain lonus didn't see it becoming mainstream when he started it right it was just a hobby project yeah yeah it won't become big and serious like g new yeah yeah he did say that so but are you are you trying anything new with it or is it just you just want to learn to do that i am trying something new kind of but in the the same spirit of hair i'm to some extent stealing a lot of other ideas into one package but i think it's being done in a novel way so i'm mixing a lot of ideas that have never been mixed before and doing them in a way which has never been done before but it is still somewhat classic operating system design although i will say that the operating system design components that i am drawing from never really made it into the mainstream so it's drawing a lot of inspiration at the kernel level from an operating system called se4 which is a formerly verified operating system micr chronal and it's drawing a lot of inspiration at the users space level from plan n perhaps more so than unix but also doing some of its own stuff which is different and so it incorporates a lot of these ideas into something new and i think it's distinct from those ideas but also those are ideas that a lot of people really haven't been exposed to in the mainstream so it's going to seem really norful to a lot of people okay we'll teach us a few of them what what ideas do we not know about operating systems that we really should okay so for example from the4 inspiration the implementation of hair is is of of helios is the name of the kernel of the project the implementation of helios is quite unique and diverges substantially from4 but like the kernel user space api it also diverges significantly from4 but it's very clearly inspired by4 in terms of the kernel api design and the way that works is with capabilities so it uses capability based security where a capability is an object with which represents an unforgeable handle to some resource on the system and you know this is analogus to a file descriptor in linux so if you have a linux program which opens a file you get a file descriptor which is a handle it's just a number and it's backed in the kernel by all of the the memory associated with the file but if you have that file descriptor it's an unforgeable right to use that file so if you call fopen on a file which is open by root you get a file handle and then you for example will set uid to a nonroot user your program couldn't open it again but you already have the file handle and that's your right to use the file capabilities are much more general so everything in helios the kernel is represented as a capability and that includes things like memory so if you want to allocate memory you have to have a memory capability which establishes your right to use some memory but also everything else there's an idea called endpoints it's very important for a micr kernel to have a good inter process communication support so an endpoint allows you to exchange messages with another another process and if it's a driver for example it's running in user space and if you have a file open which is ultimately sored on a dis you have a capability for that file which is analogous to the file descriptor and when you write to it it sends a message to the file system driver the file system driver has a capability for the block device the file system is stored on then it forwards those rights to the block device the block device has a capability for the ports of the pci memory mappings that it needs to actually implement the device driver and so each process in the stack from the user space all the way down to device drivers is running in user space in a sandbox where it only has access to the resources resources it needs through capabilities so you're saying that that sort of implies that it's a very small kernel yes most most things are in user space and the main job of the the kernel is to manage ag who has the right kind of sandbox yes the kernel i think the helios kernel is about 10,000 lines of code and it's mostly feature complete at this point it's not done but it's close to feature complete in 10,000 lines of code and is responsible for enforcing capabilities by being the thing in route that does message exchange for ipc running in kernal space it's also responsible for anything the colonel is the only one that can do so for example managing memory maps and virtual address spaces owned by user space the actual configuring of those it provides apis for user space that has a memory map capability for example can ask the konel to do a memory mapping but actually doing that operation requires you to be in kernel space on x86 and so on so that ends up in the kernel but it has also the only other responsibility has is bootstrapping the system because it's the first thing that runs on boot so it does those three things and nothing else everything else is in us space right so this is getting around the problem where i can if i want to write i don't know a new device driver for linux i get i can i can accidentally or maliciously access an area of memory that i'm not allowed to and just muck around with it yeah like if you have a floppy disc driver on linux it's compiled into the whole kernel and it's running in ring zero with the rest of the kernel and if there's a bug in your floppy disc driver it can do anything it wants to compl completely compromise your system on aries your flist driver is running in the user space and only has capabilities for talking to the floppy dis device and the worst it could do if it had a bug is overwrite your floppy disc right yeah that seems like it' be very useful for security right oh yes inherently yeah i mean it's tempting to ask why the idea hasn't gone mainstream but i suspect the answer is because operating systems are huge and you can't change them very easily there is a number of microc coronals which have been built and to to some significant degrees of of support even seal4 this micronal which i drew a lot of inspiration from has a project called genode which provides a more or less complete posix environment on top of it but i think the really main reason why we don't see this so much in the mainstream is operating systems have a lot of inertia yeah yeah you can't just rearch linux and you can't come up with something that's linux is with a new architecture and expect people to install it tomorrow and you have to acknowledge the fact that a lot of the software that people are using today is not going to be portable to a new operating system especially because for example you could implement the linux cis call abi and some people have done this there's an emulator for it on bsd for example but at that point you're designing an operating system within the constraints that linux was designed under and you're kind of really constrainted your ability to innovate but if you don't do that then you lose access to a lot of contemporary software so it is definitely a challenge to try and get adoption for a new operating system which is part of why it's really an a on my goals okay fair enough what about concurrency is that is that a goal of your micro kernel i mean it's a thing that micr kernels have to do i guess because it facilitates multiprocessing it's i guess that's the fourth thing it does is it facilitates multi-processing so we have support for for threads and multi-threading and multiprocessing implemented in aries which is kind of a requirement for a modern kernel to work you could do like cooperative multitasking but it really doesn't make sense especially on a multicore system but that is present we we do implement threads or we implement tasks which is kind of a a generalization of both threads and processes and then we have user space uses tasks to implement threads and process processes but yes concurrency is supported by by the system within that 10,000 lines of code yeah yeah we don't have s&p support symmetric multiprocessing but we do have preemptive multitasking okay so if i wanted to learn how to write my own os would this be a good reference guide possibly it's very small and self-contained and is quite straightforward to follow where the code goes and see places where you could make changes there's also a great resource for getting started with operating system development it really doesn't take you all the way but it definitely gets you started which is the osdev wiki u and the osdev irc channel is also a great resource to talk to people who work on operating systems so anybody who's curious about learning an operating system or operating system techniques definitely the helos source code could be a great resource it definitely demonstrates how to do a lot of things very simply and then the os dead wiki for sure is a place you need to be depending on okay i'll link to those in the show notes cool and if someone's not feeling quite that ambitious but wants to tinker with this what state is aries in right now what can i run on it so it's still very much under development ahead of having like a useful user space but i do have a laptop with aries installed and it supports ext4 file systems and fat file systems and virtual file system a very basic virtual file system is there so you can mount them and you can set up a boot process which getes some where an early version of the shell is working and i've ported the ed text editor and it's at least good enough that i use ed to write a blog post about aries from aries on aries so you can definitely tin it with it i'm gonna i ported doom to it a long time ago and it doesn't work anymore but i'll fix the doom port so you can play doom with it if you want did you port doom before you ported an editor yes hero nice i might let you call me once you've got vim support i think that's my threshold okay vim is going to take a while okay especially because we don't intend to implement like a unix style tty that vi depends on oh okay but yeah you can you can mess with it and if you want to get involved in the project without having to necessarily commit to learning how to be an operating systems developer from scratch a great place to do that is write a driver because the driver is very constrainted you don't have to worry about booting the system or dealing with memory management lowlevel stuff so much you just declare in your driver manifest what resources you need from the system like pci memory mappings and things like that and then you write a normal program it goes to main and runs and you can use that to implement your your driver and that's a great target like the ps2 keyboard driver for example is like 800 lines of code max quality i have a friend who works on u emulation of the igga operating system and he would probably find this a lot of fun yeah i bet yeah yeah and and pulling back to something for up a bit more production ready hair is that something i could reasonably start to make production projects in you can you're definitely going to have to be aware that like you know subscribe to the hair announce and the hair users raing list where we tell people like we broke this module in the standard library to make it better here's how you update your code but people are using it already to make production ready stuff and it's there's a great tutorial on the website and there's a great community to help you learn how to use it definitely if you're interested in the project you can pick it up and write code today awesome i'll link to those in the show notes and i think it's time to get coding all right drew thanks very much for joining us yeah thank you so much for having me this was great thank you very much drew so all of that leads me with a new goal in life what i have to do is learn hair and then write a lisp compiler in hair purely so i can refer to the project as my hairbrain scheme before that pun sends you running for the hills please take a moment to like or rate this episode if you've enjoyed it share it with a friend subscribe notify follow all those good things because be back soon with another episode until then i've been your host chris jenkins this has been developer voices with drew deval thanks for [music] listening