will come and with that i think i see kevin is on linkedin too hello kevin welcome to the show and good evening and yeah thank you very much it's very much an honor to have you it's a great opportunity to talk about so many things but i obviously have created this format that other people ask the questions so i have the honor to introduce you kevin henny you are a well-known speaker and author and i expect they find it interesting to have someone on the show which is not just known for their c plus plus creations but it does definitely have that also in their vita like you are a boost author which some people might not know and their just has been an article on sdne and that made me wonder like you know what's your opinion on any today but maybe someone someone yeah so somebody wants to ask that i'm more than happy to ask because it's had a very long history and for that let me see if there's any questions in the hobilo q a tab so if you have any questions on how beetle post them to the gni tab i'll be watching out for that and if you want to ask a question in linkedin directly post it to the chat and i can just read it to kevin to start the show let's start with an easy question how's it going for you all right thank you very much for asking yeah yeah i i think things are mostly okay things are mostly good i found that the last couple of years the last three years have changed the balance of my work i seem to be doing a lot more remote work and that's kind of stayed but the kind of work that you can do sometimes is quite interesting in terms of running workshops the structure that i use is very different now i tend not to do i tend to spread it out over many weeks and people bring their problems on a weekly basis and things that we do so so yeah the shape of my work has mostly changed but yeah no there's uh it seems to be heading in new directions so we'll see what happens over the next few months so one thing you're very well known for on social media is a meme and i i thought that you know be a great starter to you know just what do you think of it how it got started yeah so as it's known as you know it and at kevlin henny it basically people will i mean originally twitter was where it kind of grew up but with the recent kind of balkanization of uh social media it now pops up you know i'm on mastodon i'm on threads a little bit i'm on blue sky and and so on it's people will send me they will at me error screens that they that they've spotted and i will typically retweet these and depending on the depending on the social media thing i will normally like it so that means if you go to twitter for example and look at all of my liked tweets they are all error screens there are thousands of them and this ultimately started because i started i think they first started with me taking screenshots of applications crashing and then we ended up with cameras in our phones and i would take photos in different locations and i wouldn't do anything with these i would just i wouldn't do anything much i would just sometimes include them in slides and talks or in workshops and training courses where i was making a point about the nature of software or the nature of a bug and sometimes you can see this i think one of my my earliest shots was powerpoint busy crashing but left me a little screen and it told me that there was a a pure virtual function had been called so immediately at that point you've got a number of possibilities first thing you know is that this is written in c plus plus the next thing you know is like one what circumstances can a pure virtual function be cool standard one of those is perhaps calling a pure virtual in a an abstract in an abstract class constructor or destructor and that that kind of error is very very common that can happen or it's a memory trampling error and something's got mem set to zero and this kind of thing so you see the nature of how the software is created you start seeing what it's made of and you start seeing as error modes and so on so i would show these to you know a few people in in talks and things like that and then people started sending them to me and then we hit the year of social media and people started just sharing them directly and particularly twitter people would ask me and i'm just simply you know retweet it then around 2016 somebody it was obviously happening enough that somebody said oh i was just going through the airport and i spotted a kevlin henny screen so suddenly my name got attached to it properly rather than just people you know a kevlin any screen and it kind of stuck oh kevin henny and so that name has appeared i don't know in urban dictionary it's appeared on the register and it's it's it does the rounds and so it's kind of fun you know it's it's interesting because you know it's interesting from one point of view my name is associated with failure i don't know how i feel about that but from another point of view it always gives me something to talk about when talking about the the way that we construct software and the way that software can fail it also has an interesting side effect i've noticed that for some of these you know particularly train stations whatever the country people will normally at the train company as well and often the social media person will respond and say oh i'm really sorry about this or which station was this we'll see if we can get it fixed so it does act as a public service in that sense so yeah yeah i think i'm i'm yeah i'm okay with it i think it's quite fun i think it can be educational i can i think it can also encourage us to think about the broader implications it's very easy when we write software to just focus on here it is in the code in my ide on my screen and that's my universe and it's very easy to forget that actually the universe in which the software will run is quite a separate thing and will affect people sometimes in amusing ways but sometimes in more devastating ways and you know we've had a number of examples of software failures recently that are interesting toyota ran out of disk space which shut down all of their factories so obviously there was a piece of software that didn't check disk space the whole of the air traffic control region over the uk was shut down for a few hours last week which caused days of chaos and absolutely millions if not billions of lost losses because basically some input data was not checked and a you know a thing that could not happen did happen and and therefore shut down the system so in that sense it was it was good that it didn't you know you didn't use garbage data to try and control the skies but actually what was interesting was how simple the failure was in some senses and it's a classic test case and that there are many more rational responses to it than shut the whole system down so we find that these little oversights there for us that's just like oh that's a bit of a shame well that's a bit awkward sometimes they amplify to be something far larger they are actually let me quickly put that in screen i had kevin honey today my hoster told me that my disk space is none of none glitch okay but i yeah so is that too much not enough or i don't know it's probably some javascript error i like that yeah i have another space of none and yeah but let's not get into a debate about floating point numbers so we continue with the next question there's a question last year at cppcon we heard about cpp2 last keynote by herbstutter and he has since then continued the work on that what can you say about this not a lot i can say a little bit about it we seem to be going through a phase where people are looking for almost a successor to c plus plus and there are different ways in which people have phrased this and i think that to be honest that many many years ago that inside c plus plus there was a small language trying to get out people have various at different times talked about subsetting but there's this idea that c plus is you know top five most popular languages but it's not easy and each successive standard does not make it easier although there's there's a lot you know the the people on the the folks who participate in the committee often have very different agendas there's certainly a willing desire to try and make things easier for people but the normal thing is that it's trying to make it easier by adding things and actually you make things easier by removing things as well otherwise you just have more to learn and people have become much more fascinated by the idea and perhaps because we live in an era of many languages there are there's an exploding number of languages by the idea of can i have c plus plus that's kind of gives me the power of it but perhaps not all the historical baggage you know sometimes the the gotchas the surprises come about from history and we also have increasing concerns about safety and c plus plus is although in many ways safer than c there are constructs that are as equally available they're unsafe and safe if you are a if you are a new developer to this this can be overwhelming the amount of stuff that you need to know and that you need to not do and the things you need to do can be overwhelming so i think a lot of people are looking and say well can i have all of the stuff the low level access the ability to do almost anything that i want but not necessarily with the language as it stands and you know we're seeing cpp things like cpp2 carbon and there are other things going on as well as in a correct different track the rise of rust as being in native languages with a focus on efficiency but also saying maybe we don't need all of the other things that can receive i would see that have come with c plus because at this point in time c plus plus is heading towards is heading towards its 50th birthday i mean it's strictly speaking it's heading towards its 45th birthday will come first i think that's next year i think brianna said it's 1970 78 79 is when he created the progenitor of what became that so but we're not far off half a century and a language picks up a lot of stuff in that time and i think sometimes people say well could we have something else and this notion that c plus is being in certain environments is being deprecated because of safety concerns we see the we see studies from microsoft and google talking about memory related errors and these questions of security issues it comes from things like buffer overruns attacks that come from those just simply can we make things a little bit simpler whilst embracing what we've learned so i can't give you anything specific on herb's design i've only looked at it very briefly i certainly haven't watched the the keynote but it is one of a number of things that it's kind of i'm i'm aware of that i think are moving in interesting directions and do seem to be influencing some of the things that people are talking about on the committee there's the first question which directly fits into our topic which on do you think there will be an rv break in the future i think that has to be because the the whole concept of what c plus plus the obvious thing c plus s grew from c c has a very simple conventional idea of what an abi looks like historically and so it's it's at a very it's at a very primitive level what is needed to but the thing is that c plus plus is not simply see with classes we've seen the problems with this in trying to get separate compilation for templates in the first time around c plus plus 98 the template model was not simply just a few generics in a simple fashion it actually changed model of language if you've ever tried to debug templates you will know that that is still not satisfactory in 2023 compared to and certainly error reporting because it still most compiler models or mental models people have operate off the idea that it's just a procedural language and errors happen in one place if there is a compilation area happening in one place now what's this got to do with abis well quite a lot because the whole thing is what do you need from the language the idea the original idea is if i have a syntax error in a traditional procedural language that syntax error is in one place there is only one thing that could possibly be happening if you're calling something you are calling a function in c plus you could be doing any number of things the language has built on top of this very rudimentary simple idea and what it needs and particularly when we start you know including a proper discussion of things like modules proper discussion of dynamic linking a proper discussion of some of the things that we want and one of those things when people say if we design this from scratch we designed it again we'd do it differently the gap between what is available now and what the language wants to be i mean c has not moved very far from its starting point in this i think we have to have some kind of breakage i think i think it has to be i think we have to have a you know for the various platforms of version one and a version two as simple as that or an idea of abi evolution but i i don't think i think the fact that abis are non-standard or rather are set by a particular historical precedent and don't mix well and can't evolve is going to stand in the way of a language that is supposed to be a systems language that's its origin it's a sister's language it's supposed to be portable and that used to just mean source code portability we don't live in that world anymore and so there has to be i think you know i don't think c plus is going to disappear overnight that's not going to happen but when people start saying we could do a better job at this level and they choose another language then that obviously will push it down a bit so i think there has to be that if it's going to be serious about being a systems language that people can use for what we mean by modern portability or modern architectures and avoiding the abi question is not helping c plus plus i do think we need to address that and there was a very interesting paper coming up this standard way to address that that you could define code blocks as interfaces and then basically say this code block is valid from either you could use a standard version like the scope plug is only valid for c plus 23 in account or you could like define your own versioning like if you're if you're like a library and you want to say this conversion two for version one and that that way you would be able to compile down the same code base into different versions and have like kind of everybody be happy and i think that yeah that would be very something interesting to have in the library i think i think that has to be the way of it because we've seen the language since the language has evolved the hardware architectures and operating systems we work on have evolved what we mean by modern software architecture has evolved but if the abi doesn't move that becomes ultimately a a bottleneck and a work you end up with an abi that is consistent workarounds yes i mean well yes that's it that's that's how it is it's not theoretical of what we're talking about it's this if if you're worried about like caching effects share new text on windows smaller than the nano new text because the normal new texter had in its original implementation and it's stuck in this api forever supporting windows xp and yes it could be a lot smaller on linux so this was gcc it's a lot smaller but on on windows the shared new text is in the memory footprint a lot smaller than the the standard new text and stuff like that as yeah so we end up being stuck with experiments of the past we prevented evolution and therefore prevented improvement even though everything else around it is improving the underlying platform could do better there are compilers that could if we broke that you could do everything better so i think perhaps a different way of answering the question is do you think there'll be an abi uh break in the future i think let's look at it from a different point of view it's like kind of yes but also i think we need to approach it philosophically i don't think breaking one and then moving to another is the answer we should learn the lesson of like oh it's always going to change that's the lesson it's always going to change how do we accommodate change and that idea of being able to target things differently i think is incredibly important because change is one of the few things that is normal yeah and we now know this is a thing we should accommodate that so there's a question which is i'm not sure i feel like familiar with a person and russ but someone else like you think a second attempt at epos which also has been like been an earlier paper for adding this to c plus plus or something similar might stand a greater chance of adoption how much would you go about that or how would you go about that not how much so i'm not as familiar with the rusting so i presume when we're talking epochs we are talking time okay so that's that's maybe also a fair disclaimer i as at least as far as i know maybe that's a good question to ask you are you part or have you been part of the standard committee yes yes i have yeah and normally i'm on it at the moment but i since the pandemic i have had slightly less involved i got re-involved during just before the pandemic or during the pandemic but i've kind of work has taken me down a different path so i have i don't fully know what is up with time i know that one things that if we are talking about time and you know this is about about abby's still so it is okay no in which case i can't feel meaningful opinion so apologies about that so let's move to the next question actually we're gonna change completely topic would there be any plan to curate and release the 97 things every c plus program i should know very good question as i have so yeah i did 97 things every programmer should know a number of years ago that and that series kind of grown we have everything from every nice seven things every engineering manager should know with trisha g from jetbrains i co-edited 97 things every java programmer should know and we did that at a point where o'reilly was very interested in getting back into the java market and we looked at what languages were of interest and we could drive this through and they the other candidates i had a few other candidates but they weren't as interested in c plus plus they weren't as interested in c sharp which are the the two other candidates i thought might be obvious after the success of 97 things java someone else did follow up and contacted me and say hey what about c plus one i said yeah i'd be absolutely up for that although i'd be very careful if i getting involved as an editor there's a certain amount of work in that but at that point and this would be two years ago maybe even three years ago o'reilly said no so i don't know if that's changed because the books have become more successful again they kind of restarted the series in 2019-2020 and that it has become more it has become more popular i would be very interested in it i'm partly interested in potentially you know somebody said they would they want me as an editor because i had experience with the two previous ones i would also be interested in that because i think there's certainly a lot to say but at the moment i'm not the person to drive it and i don't know if there are anybody else is trying to do it and if there is interest yet i think it would be from the c plus community but i don't know if there is interest from the publisher would you be able to publish this with a different company potentially i don't think it's i don't think it's i think i think they would be looking for i think it would not be so much a case of the subject as can you put a good case together for it and i think it could be done but if you start doing that with another company i i don't think there's any direct conflict intellectual property-wise although it might be a little bit confusing uh so i that might work against it rather than for it it's difficult tonight but if i woke up one morning and i said this is something i want to do i would normally i would knock on the door of o'reilly first of all because i've had the two previous ones done with them right there we are at debating other languages high question from linkedin how do you see the link penetration on the market as rust and other languages are on the right okay this is an interesting one because languages move slowly i did a i did it i had a look at a cup in a couple of talks last year i went through let me think i let's see i went through a listing of what were the top programming languages and i took three different surveys the tyobi one the red monk one and then ieee software had a survey and you know it's very informal and it says they all use different criteria and i wasn't interested in what is the perfect absolute because we there's a lot of different ways of asking that question but simply just looking at the languages and saying okay which of the languages that have ranked in the top 20 of any of these you know so i basically took all the top 20s merged it eliminated duplicates eliminate and and merge certain categories you know am i going to make a distinction between classic visual basic and visual basic no i'm not eliminate categories such as assembler because assembler is not a language it's a language class and yeah and go through and just basically tidy stuff up and then look and just look simply just a simple analysis which languages have appeared in any of the top tens not which is the tenth but which have appeared in any of the top tens but the other analysis that i did was go through them and say what decade was this language invented in what decade does this language come from and in the top 10 i if i recall from last year i have to do this one from memory in there were most of the languages were from the 1990s or before the languages of the 21st century barely made an impression on the top ten they're in the top 20 but even said you look at it and you go oh this is the past you know so rust is making an impression but it's hovering outside that top 10 mark something for some it's slightly something slightly out languages are a lot older than the software architectures and products that we use they they move much more slowly they they move at continental speeds you know python is often comes out number one that was that's that's a that's a baby of the 1990s you know it's a first official release was 1990. javascript is 1995-96 you know we have all of these various things and so c plus plus is i'm going to go with that as the 1980s i'm not going to talk about its pre-history supervisors top five and will remain so for a very long time but if there is a sudden uptake if microsoft fully for example fully got behind rust and started and we've seen rust is now appearing in the linux kernel if that becomes a particularly critical movement then we may see an effect on c plus at that point i think it's going to cause a little bit of shift in the next let's talk about short time scales in the next year or two very small shifts the next five years i think that's going to tell us something the next 10 years then we then then we know what has happened in this space the space of this whole space of abis of large companies that are responsible for platforms large companies and organizations that are responsible for platforms it's platform advocacy that normally will shift something this big we've seen that for example with swift objective c has just dropped like a stone okay the only people using objective c were people working on apple platforms swift is now kind of is now is now taking its place it's not a top 10 language but it has moved very fast for a very for a very short distance there's a lot of people doing mfc oh yeah yeah no that that's the thing is there's a huge install base that's why the stuff remains in that that's why it's not going to move but the are we going to end up is this is the question here is c plus plus becoming fortran or is it still playing with the is it still yeah that's the that's for msc that's my view in that sense with if you're working with nfc you are basically working with pre-standard c plus okay and there's a lot of that out there that constitutes a very lucky if you like there's a i think sometimes when we look at c plus plus we have to and particularly if we're interested in c plus plus and follow the things that the committee are doing or actively go to c plus conferences you may get the impression that everybody's using loads of cool stuff and is like up to date with c plus plus 20. no the number of people using anything c plus plus 11 onwards is less than the majority okay it is a minority of people use see anything post c plus plus 11 the dark matter of the c plus plus universe that actually shapes the employment a lot of the employment numbers and a lot of the numbers of code bases is this stuff that is a lot of is much much older so yeah that's not going to move fast that's why this stuff sticks around but the question is if if the new stuff doesn't get created in this that's that's why i say the one year five year ten year if the platforms throw support behind other languages as well and explicitly start favoring them then that's where the new stuff is going to shift and what you will find is that yeah the legacy won't go away the stuff we're producing today becomes the new legacy but then that starts drying up and it's slowly but surely moves out fortran is just outside the top 20 for example when it comes to programming languages but it's still in the top 30. so you know that's that becomes the c plus of the future potentially it depends so i can't predict the future but i do think there is increasing language language penetration when people start making concrete decisions and discussions about i'm going to do native code i am new to software development i've just graduated what should i be looking at there's a very strong incentive for people potentially to take up rust or other languages that are coming down the line in five years there's a strong incentive whether there's enough push behind that to really push people there's another question brianna said something i want to mention that context very interesting i think it was last year or for two or two years ago i think it was the armor we did last year with them and he is someone who who does not want to like you know it's often getting asked by opinions on other questions and and on languages and he's always and saying i'm i'm not answering the question like what i think about programming language x but he then continued on and said but what i can say is that those communities of those new languages are very self-selective because you only get the best people you only get the good programmers at the beginning but it takes a lot more to shift like the other 80 percent and russ might have the problem that a they they they are now getting big enough to not having the advantage of being small anymore those are basically some of the design issues they have they want to address there has been also some you know ongoing i don't want to like say issues but i saw like you know the generic code is based on macros and repressing that might not be going as well in a big community now as as it would be going with a small community and various other issues which which show up when when you grow into a certain size be it socially beard economically being the the all the other factors which do not play a role when you think about a programming language and being like fast on the or safe or secure and those things are coming along and plus that c plus plus has an active standardization yes i think that that is i think it's important to understand that there are these features yeah scale points in terms of community and wider reach but i think that the the way that languages are developed now c plus plus is definitely a language of the past people don't go to a standards committee and so you're going to develop a language that's very much what we find with something like the rust foundation is they're much more complete and they have a very they have a very particular culture and they are solving a full vertical slice problem what is c plus plus packaging is there a standard way to do that absolutely not in rust there is so that's the idea is if we look at all the new languages or the relatively new languages you see a very different model and they often have communities around them now although we i've used the term c plus community there isn't really such a thing there's a core c plus community that is basically it has the standard as its nucleus and has people around that i mean we you mentioned the boost library earlier on that was the boost libraries were set up by people from the standards committee and it's always had an intimate relationship with the standard but what you find is that much of the discussion is around the standard and that that can benefit it but the danger is to realize most people don't actually know anything about that i would say 95 of c plus developers aren't even close to being what we would call c plus plus community and that becomes a different dynamic so you know it's it's a luxury of size but it is also that issue it's like when you're trying to so the rust you know as anything gets bigger the front and the back move further apart and i think that the folks in in russia but the difference between the front and the back of c plus plus is off this screen you know there are people still programming in 1990 when it comes to c plus plus but there are also people who are just pushing the age of 23. we do actually have a question from linkedin like pointing in this direction like we see features at the c plus plus standard are duplicated at the next standard which i i do want to point that out that is not true because we introduced certification feature but we got very very careful with actually using it so you have to deprecated some things but as far as i'm aware the committee is not deprecating things which are in the language anymore that often yeah it doesn't happen there was kind of a little flurry there was initially there was a very kind of very con you know the language has gone through different phases it's very interesting what it's prepared to add what it's not prepared to add so in the 1990s we had this kind of idea if you do not add keywords oh we don't add keywords that was that and then oh let's add a few keywords just in time for 98 so in other words yeah let's do this one bull that was a b w charty of all the names we could have chosen what a terrible name i had a counter proposal called the long chart which was much more logical and then suddenly yeah let's throw all these other things in like static cast iron so suddenly there was a bit of keyword creation but it's still quite modest we were still recycling a lot of keywords and that was visible as we went into c plus 11 auto got recycled and a few other things but we've also seen lots of other keywords being added sometimes contextual override and so on getting rid of stuff a lot of stuff was deprecated and not removed and then just around 11 to i think probably 20 there was a real a lot of stuff did actually get removed library and when i say lot it's a relative amount but things got removed from the library there's got removed from the language got repurposed but i don't think there's much else that people are removing there is a deprecation so deprecation is a concept but i think it it's kind of holding back a little bit it's more library now than language but it's i think the rest of the question is why is there no clear architecture for c plus plus yes let's talk about that from another point of view is there is there a vision for it and i think people have tried there are you know i can see this on this on the standards reflector trying to basically say here's here's what we're going to focus on but because it's a very decentralized structure there's a the committee is lots of subcommittees lots of interest groups there isn't a single driving individual or concept of the c plus direction board that that drives that going back to how other languages have evolved they've grown from a very different source they have not grown in the way that c or c plus plus grew not the way fortune these are the classic languages that underwent standardization through an iso or other national route they other languages are taking a very different path they've either had a company at the center or some kind of open foundation or they have grown out of open source so their whole organization of people and what they are trying to do is very very different and because particularly the ones that have come out of open source software development they look like software development projects and what do you have on a software development project you have to have a vision you you so it's grown out of that and you build it c plus plus the c plus plus committee is not about implementing in the next reference compiler that's not a that doesn't exist whereas what we find is there is normally the standard reps so in other words c plus plus standardization is not run as a software project it's not run like that so it doesn't reflect that these others have grown out of that which is means they tend to have a much clearer vision of what direction they're going to take and what they're going to do whereas if we look at what gets added to c plus plus in each version it feels like lots of different parts each some of these are really good but they often feel a little bit incomplete there's not an overall so for example modules got added and the c plus library was not modularized okay why would you add a feature that you're not going to use well you you need to have that's kind of a chicken neck problem i potentially but that's the thing is there's an experienced thing the library actually is coming and i've i've heard that right ghostbusters will be actually a topic which people actually already start like using and speaking about but on the other thing the thing adization process is like right this is a standard it's a theoretical document and this stainless receipts you can choose from three different main chains where you want to eat this receipt right you you go there and they cook it up and you get the lasagna and every one of those has their own flavor and there's like people will say well i only go to to that branch and this is the best one and then there's you know other people also serving you standard c plus plus and their version and their compilers this gcc msvc and client being the main branches of of us and that's very unique to have multiple vendors and it is yeah they're part of the standardization process but the the result of the standard is the standardization process is not their compilers it's a document yeah yeah it's a document but importantly the let's go back to that vision let's look at let's look at that i'm going to call it the failure of modules i know that people are doing talks about it they were added in c plus 20. the number of people actually using them is minimal at this point we have minimal experience is the c plus standard library modularized well that's not going to happen for another three years so there's going to be a six-year gap between introducing a feature and actually using it in the standard itself there's a whole idea of dog fooding likewise concepts introduced the library was not standard there they were not used in the library now that's because these come from this is a perfect example of commerce law they're added some examples are called language feature the library people don't use it c plus plus is not so in other words c plus plus would probably have more of a coherent vision if it were its own consumer now when you look at how this we can look at other languages for example java when it added modules it did not add modules until it could modularize itself when it added streams to kind of like the ranges kind of equivalent actually they did not add they did not add all of that until they were able to integrate it fully in the library so in other words it was language and library and that again i'm going to go back to the idea of like this idea of the foundation or the community in terms of an open source community reflects a very different vision whereas c plus does operate as different subcommittees and different parts get added so we often find a core language thing that looks really cool but then it's not used in the language itself co-routines were added as kind of like ikea furniture and only recently they're at the basic bits and pieces being added that allow you to use them easily but they're still not integrated in the library so there is this problem of this problem of we we talk about oh we should have user experience well we can offer people actual experience by integrating it ourselves people don't want to try it out if it feels theoretical and i think that that is the issue the minute you start actually using something in the language or in the library that uses a feature in the language that is new of course you're going to follow on using that but if somebody just tells you hey there's a thing in the language it doesn't integrate with anything else that you're doing what is my incentive unless i'm really interested in just adopting that the majority of developers are not going to use it and that is a problem because there's a feedback cycle here it it means that we don't get the benefit of having perhaps that vision so yeah i think it's a really interesting question there's no easy fix to it because it's it's a path dependency it's a historical thing we're here because we're here because we were there because we were there before and these other languages and environments and cultures have grown very very differently on the other hand i i'm very happy that the reciproc standardization takes its time and you know having a feature available in six years that was considered fast at one point in standardization right when superfast 11 came out you expect to be the standard of the decade and not like for three years so yes i am i am very pleased that we're now operating on something a little bit closer to internet time i think that that feels a little more reasonable and it also allows it allows the committee to adjust because the original vision was they were going to be alternating you know the the three-year cycle was going to be an alternating cycle in other words after c plus 11 c plus plus 14 was going to be small 17 was going to be big 20 was going to be small 20. that they're they're kind of actually it's just like no it that doesn't make any sense we don't need that alternation so it's a steady flow so i think that that is certainly welcome but i think we can still do better and i think that might be more a matter of kind of you know changing the lines of communication within the community and say well if this feature is so useful in the core language why are the library people not using it that that split between core and library is a very long-standing one okay and now it was something completely different various interests and languages science and mathematics which four famous people living or dead would you invite to dinner and why oh okay that's a really good one okay so okay i'm gonna okay let's let's let's start with mathematics because uh let's start off with mathematics pierre de firma i would like to i would like to have dinner with him and really ask him what what did you actually write down when you wrote that thing in the margin and you said that you had this elegant proof what did you have in mind so that we could actually find out if the thousand pages of andrews wild's proof is necessary you know if if firmap didn't actually have deeper insight that we have been unable to recover or if you just made an error i think that would be interesting i think richard feynman the business richard fireman i would i would enjoy i would i really like to meet him obviously via a time machine i use a number of his quotes i found i find a lot of his thinking very fresh and inspirational i mean he's not a perfect individual but he has a very practical relationship to knowledge and yet he also draws on an immense amount of theory but he makes his his approach to science is engaging it is playful and but he's not superficial i think that i for me i think that would be absolutely fascinating in terms of i think in terms of language i think a really interesting one i'm going to pick somebody who's alive so link from a linguistics point of view noam chomsky who is who's still i i would like to i would like to talk to him but perhaps i would like to talk to a past version of him because he had some particular theories about language and you know i've i've read his stuff that gives us the whole idea of context free grammars regular expressions all this kind of stuff i think that would be really really interesting to really find out the other side of it where he's coming from because he presented it in a very academic way and he's certainly and he's got a lot he's got a lot on a lot of subjects to offer so i'd take him present or past but i think a past version of it could be quite interesting and i think i think i think we're also i'm gonna go for a computer scientist as my last one and barbara liskoff i followed her work for many years she's she's still alive but i followed her work for many years i've managed to accidentally avoid everywhere she's ever spoken she is perhaps a little old now to be traveling and doing talks but her contributions to distributed programming type you know our concept of types type systems modular systems paradigms language design all of this stuff i i think her work has been immense not just in the 1970s but the influence that it's had i i think that would be really you know it should be somebody to meet if i could possibly afford to but you know yeah great questions great question level okay let's ask you about testing regarding unit tests what is your take on writing mocks versus calling real code and unit tests there are some debatable with over mocking i heard right yeah i think we need to there's a lot going on here and i'll i'll take out the separate things to give you to give you a sort of a sensible answer the original vision of marx was to help you design interfaces that was the original idea most people don't are not aware of that and they don't use it like that they use mocks as oh my goodness i've got an external dependency i need to block it out or i've got some kind of slow dependency on the database i must mock it out that's how a lot of people think they think mox is a way of dealing with a dependency mass it's like no no the whole purpose of mocks was so you didn't have a dependency mass it was to cause you to design the idea of using the mop from a test driven perspective is you learn what interface you need you don't if somebody doesn't come along and say hey i've got this code you can use it and you use it you don't do that what you do is you say my application needs this functionality you're offering me this much functioning i don't need that much and it's not the right shape for my application so it's a good implementation but let me write the interface that i want so i might adapt it so what you're doing is you're inverting the dependency you're inverting the way you think about interfaces you take it from the consumer perspective i'm a piece of code i would like some facility what should that facility look like to make my code easy yeah so from that point of view i think mocking would be great and i wish more people would do it i would people i wish people would do that original philosophy of mock-driven design because our apis would be smaller our classes would be smaller everything will be smaller and much where you know the dependencies would be much better managed so that's my first the first point is yeah i wish people would do that the next thing is when it comes to but for me the most obvious boundaries when i talk about mocking and when i introduce mocking it is to do with the most you know when people are saying where do i define the scenes where i should or should not be mocking i tend to come back to a very simple definition and unit tests what do we mean by unit test and for me a unit test is something that is isolated from external dependencies and therefore put it another way a unit test the outcome of a unit test is based on the code of the test and the code that is being tested that's it if it passes it's because of this code if it fails it's because of this code okay that's it there's nothing else and that's a unit test what if i am testing with a file system well i can have perfectly correct code in a perfectly correct test but i might have the wrong permissions the files might be full hey well you know it's let's refer back to toyota i can have perfectly correct code and perfectly correct tests and my test and my test can fail in other words it's not showing me there's a problem with my code it's showing me there's a problem with the outside world what if i have code that seems to work in the presence of threads and then one day it doesn't work in the presence of threads the only reason it was working was actually broken all that time the only reason it appeared to work was because of something external to my code the scheduling policies of the operating system so basically if you're dealing with anything where the correctness of the outcome is not based on the code that you're looking at then that's not a unit test and that doesn't mean i'm not saying it's bad i'm just telling you it's not a unit test it's not fully isolatable so from my point of view is you want to get as much you know and sometimes we will then talk about these isolated aspects we will need to actively isolate them and there will be something we call what's on the other side of that well for testing purposes how do i how do i do it unless i use a mock okay so therefore i would be using it in that case i wouldn't be using the real code as a unit test i'd be using that as an integration test and i might but my integration has to be a lot simpler and also you know my unit tests can be a lot faster and my overall design a lot more loosely coupled a lot better separation of concerns so that's the way i approach this one what about the problem of overmocking the problem of over mocking tends to come from when we see a bunch of code and we say oh here is the code and in our head we think i can't change the code but i need to test it and maybe that's just in our head maybe it's actually a reality of the the choices that have been made that we have not made and cannot change at that point you end up with a code that's already a mess of dependencies and you do end up with over mocking because you have mocks returning box returning mocks it's very complicated if you were to design it with from the beginning you would say no no we don't need this tangle this one idea should become two it's two separate ideas separation of concerns which would lead to separation of dependencies and so on so yeah over mocking that's one source of over mocking the other sources where people start testing implementation details rather than interface details or semantic details and that's a very common thing because historically another term for mock or mock testing was endo testing we don't use that term anymore but it's testing from the inside it's like you're testing callbacks you're expecting certain things and that becomes very tightly coupled to an implementation if you change that then you've over specified it and you've broken it so these are so that's kind of where i sit on this i don't think it's a i don't think it's an easy decision it's not a one or a zero or black or a white but i do see a lot of tendencies that lead to over marking test with real code as long as within your control don't don't don't factor out testing can you know i've seen people actually sort of say i'm going to mock out the container that i'm using as my private representation no that is absolutely not the way to think about it that container is private it's private for a reason it's an implementation detail but your interaction with emitting events to something else that receives events that's an external detail that deserves to be marked so i hope that covers that covers quite a lot i'd only spent a few days talking about this but yeah hopefully that's giving you a reasonable idea and a reasonable answer yeah i think let's see it's a question on parallelism i'm not sure if it's like a specialty what do you think about c plus plus usability and connection with concurrency and parallelism in general or in comparisons other languages do you see any interesting features what should be definitely added yeah okay so i my background with this stuff it goes back a long way i'm not going to say i'm totally up to speed with everything that everybody's doing these days but i originally got a master's degree in parallel computer systems and one of the things that on that i i studied csp communicating sequential processes which was the basis for the occam language and the outcome language has channels which go sort of has a bit of a go at and i also studied my my thesis was on the actor model and these are very clean models of expressing concurrency constructs and by the way i'm just going to use concurrency generally to refer to anything where there is potentially simultaneous activity i'm not going to try and say the concurrency in parallelism are two different categories they're not they kind of depending on how you define they either overlap subset each other or whatever i'm going to use concurrency to refer to all of these i feel that c plus is not as usable as it could be it started there was a thing the first so we first got proper standard threads and c plus 11. that's a long time after people wanted a standard solution but as the standard was deferred it was kind of inevitable c plus plus has to have a threading model if it's to be a credible language that for systems programming you cannot say i am a systems programming language but i don't i can't talk at the level of the operating system threat then you're not a systems programming language okay so you have to have that level i'm not going to say you don't want it but the first thing we need to recognize with threads is that they are very raw they are a they are a primitive and yeah they are a threat you know yeah they really are you know here is a thread of control and oh here's locks good it's yeah this is i mentioned ikea furniture you know this is probably more ikea furniture in this sense it's like you have to build this you have to build up your own construct yourself in others before you can actually be producing useful code you've got to choose your paradigm and your your whole approach to threads people are not aware that this is a decision they can take so they often end up programming at the level of threads oh look i have a function here let me just launch it as a thread oh my goodness we're going to need to lock this and i'm gonna have to lock that and it's basically like trying to put out fires i have no idea what that outage was i've just checked everything i have no idea yes if you've got a nice screenshot of me just freezing yeah okay so so the the thing is this idea of building up primitives we could just say just like you know a jump state but a go-to is a primitive from a primitive you can build if statements while statements and all the rest of these other constructs and we would much rather use the built up things than have to rebuild it ourselves having programmed an assembler but also programmed in old fortran the idea of making my own while loop just has very little attraction but that doesn't stop people working at that level so a lot of people are working at the raw level which is not usable it's error prone unless you go at it with a clear abstraction and just adding threads is a recipe for recipe for a mess and it won't give you performance benefits necessarily so what you're kind of expecting the evolution of the language is that you rise through the levels unless your claim is we are a high level programming language just targeted to make all concurrency approaches easy or the main concurrency approach which is easy and to be very opinionated about it this is what arkham did the in arkham you only had channels there was nothing else you could do and you were it was very opinionated you could not share data between running processes if the data was mutable the only way you could share data with another running process running thread is by passing it through a channel and the compiler would stop you if you tried to do anything else it was a massively opinionated language but the thing is if your code compiled it properly rare c plus plus as a systems program language doesn't come from that tradition but it also doesn't hasn't really risen through the levels i remember at the time we were working on the memory model in the mid-2000s mid to late 2000s i kind of considered that to be a a level zero you've got to get the memory model right and then on top of that you can build the kind of primitive construct the go-to which is thread which is something we have we have a memory model yeah and we have that the next level what i called at the time level two is where you get people away from using that in other words these are available for you but then we have much where and we have a much more a much richer vocabulary we're kind of getting that a little bit but it's been a long time coming it was and i wanted it to be there in the beginning asynchronicity [music] of these constructs that basically mean you will not have people passing pointers to shared state between that has been very slow in coming and my original hope was that was all going to be present originally i even had a threading proposal in the mid-2000s which was future based and got took the idea of threads and said let's make this a function based concept and not the way that it is now it was much richer it was a higher level approach i mean i'd still make it even more high level but it was based on the idea of fully asynchronization execution pasting futures around with the possibility of doing channels and that is not the path that we have taken so i think from the c plus perspective c plus is very capable it allows us a lot of this access but it has not added at the higher level constructs at the right rate in a way that makes people's lives easier and so therefore i would say the higher level constructs that's what i would like to see i would like to basically have it so that people are not sitting there worrying about thread pools and stuff like that and basically saying i just need this executed you know asynchronously and here's the channels we're sharing and this is a long way beyond async as it stood proper continuation model all of this kind of stuff that would have made that would have made i think c plus plus a much a much more different language to program in from a a kind of concurrency perspective i'm i'm actually kind of happy that we didn't like try to synergize the c5 plus 11 perspective on this because we probably wouldn't have had the needed representation in the committee from other sources of concurrency was gpus etc yeah and that's a very yeah and i think you're right there because there's a whole load of other stuff there as well aiming exactly at that at having a framework which does concurrency and parallelism with algorithms and everything in the seedless possible world but which just not like says well it's it's threats of course but you can have of course another concurrency targets yeah the parallel a lot of the parallelism stuff again has come from a different route and you can look at you know you look at the parallels and stuff you look at the threading stuff the the parallel algorithms look very different they feel very different i don't think they're mutually exclusive but they're not they don't they don't spring from the same source but in terms of kind of like more classic mindy multiple instruction multiple data i did i i do wish it had been more opinionated i do wish there have been more high level stuff i would have gone for something based my personal preference is for futures and channels that's what you know that's the kind of way i tend to think and i found that's a very useful way of working and that could have been in there from the beginning but it wasn't and we are making up times slowly with that i remember at the time there are a lot of exciting ideas and possibilities i know i remember herbert had a whole load that would have been really cool for composition in other words really to try and think about this in terms of composability threads and mutexes on their own are not composable and this whole idea of being able to just bind things together in a very natural way with a fairly with a very high sense of comfort and safety that that's what we kind of that's what we should have threading is unnecessarily hard the way that we've got the the c legacy and the c plus legacy of how we think about threading has made it unnecessarily hard i feel indeed where we talked about gpus and parallel currency we have a question about like ai is there any effort on making c plus competitive for data processing and where it stays closely relevant on ai ml pipelines you know specifically aware of this i mean we normally tend to think of it from that point of view is that c plus plus forms part of the story in other words it's the it's the language of choice for number crunching in a lot of places and when thinking about it from that point of view then you know it's kind of there but in terms of anything else you know you know yeah i don't i don't really know that there's any kind of move move toward that i don't think that anybody is really kind of saying here is a standard way in which we should be creating frameworks in c plus plus that support the machine learning approach and looking at from that point of view to make it competitive i don't know i that's really more i think that's an open source question from that point of view and there's probably no shortage of things going on out there but normally the way that c plus is presented i think it's it's a different thing so we often see this we'll write the algorithms in c plus plus but we'll present it through python as being a classic the classic example tensorflow and that as opposed to yes our pipeline should naturally include c plus all the way through i don't think that's a thing i'm going to say i don't think that's a modern architecture i don't think that's the way people want to go a lot of this stuff will have a particular service structure and a front-end approach if you're going to build a whole system you're going to end up with a multi-language model anyway you won't glue a pipeline together using c plus plus that would not be the natural choice you'll likely to use other means so i i tend to feel it so are available on c plus plus okay so yeah these are these are all there but that and then there's the person interface and i think historically a lot of the usage came from scientific purposes first and other areas where python plays a role startups etc and so poisonous is ahead of that and it's probably like the language and you know some new language called mojo being introduced because yeah compatible so we'll see where this goes on the other hand ai is such a high that we don't know where it goes and what it does so i think that's a very important point because we yeah today's whatever is going on into the you know a large language model pipeline is going to look very different to you know that's not the whole of ai i mean it's it's the it's you know that's the chat gpt that's the headline that's the kind of the you know then there's a whole lot of other stuff we'll be talking about yeah generative ai in general this is a broader area that takes us into stable diffusion all the rest of it but that's not all of ai that's that's a whole lot more there you know and we find that it's a very diverse space so yeah i don't know where we would see i but i think c plus plus is often going to be part of the solution but i don't think it's going to bind and create the whole solution what is your advice regarding what all areas meet senior experience software engineers should learn and know other than programming language expertise yeah good question let's go back to this point that a number of a number of points a couple of points actually specifically yes and i've sort of sort of said yeah there's the language and then there's a thing outside there's the people outside there's a community there's there's the stuff there but i've also referred to ecosystems and the things around the languages so therefore it is understanding programming language expertise the programming language that you are working in if that the primary language is c plus plus and obviously having skills in that and improving your skills and that that's great but also what are the secondary languages that you use pay attention to those we have a real habit particularly in environments where we're not naturally using lots of languages to treat these secondary languages as somehow very secondary give them a bit of space you'll be surprised you know we mentioned python i i kind of turned up sometimes to c plus plus places i say okay what's everybody's second language hands go up it's python it's kind of everybody's favorite second language but only a few people really have grasped it and fully understood it and they'll probably write far better python code and even better c plus code i know one place back when see after c plus plus 11 was introduced that their goal was to send people on python courses so they would write better c plus 11. that idea is so even within the programming language space that idea of work was something else and get good at those other things that you think are the edge of what you do bring them into the center but again that's still not the whole picture beyond programming language expertise understand things about architecture we are very it's very easy to get drawn into the syntax and the current class you're working on or the current cluster of classes what about the bigger picture what about the nature of change with time code analytics things like that adam thornhill's book your code is a crime scene where you're really trying to understand the system how does the system of code behave over time in other words who works on it what things change together this is a far deeper approach you know it's it's the difference between looking out of your window and working out the weather and what you should wear when you go out the front door versus having a high level view of watching the weather patterns moving across your region of the country or the world and recognizing oh yeah it's all connected so a bigger architectural view i think and there's a lot to software architecture so i would definitely say that is an area particularly if you're if your job as a senior that is one of the things you want to offer people is not simply i know more stuff about the language but i also see where it fits and you're offering a larger view but in other cases that the learning can be kind of you know so and i can sort of say there's a lot of tooling kind of stuff and probably learns things that are outside your immediate programming language you're not using and not even as a secondary language go and have a look at it if it's different i think there's a lot to be there's a lot to be learned and enjoyed in doing this and the same for other tools and maybe you're excited by ai but you're not working in it sure that's fine go and work with it maybe you seem to think that ai is the whole universe and you are working in it well go and look at something that's not that you know go and look at something else to give you a different perspective but i think the thing that gives us the biggest perspective is the the learn bit i mean people always call them soft skills and there's a question of whether that is the right term it seems to downgrade them a bit but for me i'm it's the idea of building on that software architecture thing the behavior of people creates the system software doesn't come by magic it's the it's how people interact and you can kind of spot software that is created and you know there are development cultures and organizational cultures that are very good and encourage they create the right environment for that and then there are ones that don't and even though the engineers might be individually brilliant what comes out is problematic complex broken there's all kinds of different failure modes so i think i understand the people side a little bit more and certainly at the senior level the way that you do that is by doing coaching your senior work with somebody who's not you know don't assume that they're going to pick up all your knowledge by osmosis simply because you're in the room don't assume that they need to follow necessarily the same path as you give them shortcuts and they will also ask you questions that you will never have thought of because you have a historical if you're senior you have a historical way of learning and it's very tempting to teach other people according to your history whereas people coming into things now it's just like they don't need most of that but they may also see it from a different perspective they may ask a question that initially seems dumb but it's surprisingly hard to answer and gives you an insight so yeah it's it's very much that put yourself in a position where you are mentoring and coaching somebody else you will learn a huge amount and i think that's also like a similar perspective i give people asking for job interviews that even even if you're a beginner if if you're just starting to to you know you're five years in the industry you've learned c plus plus and programming in a different way you have skills and knowledge about systems which don't exist in the team you're hired for so naturally some of those skills could be really interesting to them because they're new and they don't they lack those skills because they don't have someone who has experiences that's like a whole different perspective which a new person brings into a team and so it's definitely important to you know not only like hone your skills which are needed for the job market but also like hone those skills you're interested in and what you learned and then that can be very interesting i also can be can be at first job i remember like asking the dumb question why we you know what be looking for a software that can validate if a link works or not and why we wouldn't just write our own crawler and all that software we you know it was able to do that was very expensive i was like why do we pay like more than like was like about about five figures or something and like going do we have budget for that it's like you know this is some simple java program it was back then to to you know pass on html get the links out call them again and then you know note that through and for for the department i worked in that was like a little miracle to to have someone right that wasn't two weeks to have a simple program which calls a page which is defined and then tests of every link on that page works yeah and that was the whole thing it was not like building a web crawler and getting all all the information out of the web no it was just other links on this page still working we have a portal and we would like to know to test it every night and you come in with different assumptions that's the key thing so there's a minor question so let's go for that do you think modules will really help on reducing compilation time for huge code basis they should because we're not having to re-parce all the code that's such a bottleneck so yes i do i think the challenge though the check the challenge is huge code bases are typically historical and legacy so the very target for modules the very the very systems that would benefit i mean we can see any language that actually has a separated module system and you know i i'm old enough to remember turbo pascal and one of the things that is absolutely miraculous about turbo pasta is how fast it compiles i remember using turbo pascal i don't think turbo c plus plus was pretty fast but turbo pascal was insanely fast because it had a separate module system it did not have to go through all the headers again and again now that was a long time ago and all that has happened since then is the c plus systems have put more and more in the header and got more and more complex and it's been a fight of hardware and a few compiler tricks to try and cause the speed up but you're ultimately fighting a losing battle in order to compile any source file i suddenly have to do all of this stuff and that leads to things like unity builds and all kinds of work around techniques that are effective but they are workaround techniques the problem is the huge code bases don't appear tomorrow i mean i'm you know so today is wednesday thursday will not suddenly see the creation of a new huge code base that takes time so the very target the very systems that would benefit most from modules are the ones that are old and are the least likely to adopt modules we have a paradox of adoption here because people are oh it's legacy we can't check it works we can't change it that'll cause all kinds of interference and problems and so on and potentially compatibility so therefore people play cautious and they won't modularize it so yeah i i do for a tech point of view yes they do from a social and economic point of view then there are different obstacles we're actually answering a different question well what's your recommended approach for writing unit tests for an existing code basis already tangled dependencies oh there's no one approach so foreign the i tend to think of code in that situation i i talk about it as being the art of the possible what is possible okay let's not worry about ideal cases let's work let's make that a destination but that's not where we're at at the moment what is possible if i we already have a culture of integration tests then my recommendation would be to continue working within that culture so that i can now then more safely refactor things so that i can then you know the next generation i am able to then introduce unit tests the benefit of that goes way better build times but also you're ending up with something that is cleaner you're ending up with something that is more modular different use of the word modular but more fine-grained that this thing that shouldn't depend on a file it should depend on data not where the data comes from i want to have that structured but maybe i'm not going to make that change if i feel the code already works give me an integration test that demonstrates that then i will change this code accordingly refactor it and now i can also write unit tests and probably move the bulk of the activity that goes on in the integration test into that and it will also execute faster okay so i still keep something of the integration test but because we're always hitting secondary storage it's going to be slower so in other words that would be one sim that would be one way if you're working with integration tests already work with the things that you've got you've already got a set up you've already got a culture with that look to make those better in other cases break the dependencies how do we do that in a fashion that is safe if we don't have enough tests this is what michael feathers called lean on the compiler there are some changes that you can make that if you get them wrong the compiler will tell you okay these are not changes in logic if i start refactoring logic and i don't have tests for it the compiler won't object but these are tests to do with type system this is like where we talk about renaming and moving splitting classes if i try and call a function on a class and it is not on that class the compiler's not going to go with it it's going to tell me in no uncertain terms so there's a class of refactorings that are about movement of code that if you get them wrong it's the compiler that will do the checking you're not actually changing the logic okay so in other words work along those that would be different for different languages but in c plus plus we have a sufficiently static and checked type system that you can actually find a lot of cases where you can do that and therefore you open up a seam and a possibility and say right now i can drive a unit test in there and allow myself to do other changes so that's kind of two approaches again another approach is that you start spoofing things so i make a slight distinction between mocking spoofing a lot of people don't by spoofing i mean is like i will substitute headers okay and i will say here for the tech you know here's the actual header that you're going to be using in production but i'm going to spoof this at the level i'm going to make sure that the path is changed for my test and i will pick up something that provides mocks or other kinds of test double as appropriate but i'm going to spoof that so that i haven't actually had to change the design or the dependency structure as it stands by you know it could be very creative sometimes doing that but you know that would be another technique you can also consider link time spoofing as well if you've got something that's binary compatible do they so you know there's these different techniques so as i say it's it's about the art of the possible you have to kind of come to the code base and say i have all of these possibilities of how i can work within it and i will see what fits this one maybe this technique pushes this far another technique pushes another way you treat it as a kind of more pincer style action you treat it as a long-term progression so yeah i think that that's a case of building up a kind of like a a kind of vocabulary of techniques to help you okay there's now two questions which i both want to read to you because they're basically almost the same thing but one is coming from like then the other one is from who below what do you think about the use and role of ai and code development especially in c plus plus and let me layer over linkedin how do you see the future of tools in ai extensions which do generate the code and also programmers in the very long okay yeah this is a this is an interesting topic and one that i i managed to find a quote from myself in a talk and i gave him poland in 2016 where i was asked a very similar question and obviously the the world in 2016 from the point of view of code based generative ai is very different to the world in 2023 at that point we were saying what might happen in the future well now we're in the future and my key observation was you've still got a job well done but you better be testing you need to get better at asking questions you need to get better at understanding what it is that you want you or your eye also needs to get better at being able to discriminate a good solution from a bad solution being able to generate code is wonderful at one level except when it doesn't work and you need to know that it doesn't work and what we're going to find is that a lot of people are going to use ai related tools so you can use a lot of you know generative ai to generate code and a lot of that code is going to be not quite right and they won't know it because they won't test in other words what we're going to find is that in future there will be the people that remember to test their code and already are good at testing but they're also good at specifying their problem and immediately recognizing if what they're getting is not quite right and then we're going to have a lot of people who are going to use this just like any other tool and they're not going to do that and they are going to create what we like to call legacy code because it's legacy code because you didn't write it it's written by somebody else it doesn't quite work or doesn't quite do what you need it to do but now you've got to fix it and you and this often happens sometime you know we we push the code into production but we didn't test and now next week i've got to fix a problem but i thought the code looked okay and the problem is we're already seeing this happening and we're seeing it happening in a number of cases i think one of my favorite ones is bertram meyer actually published an article earlier in the year where he talked about getting a solution from ai and to a very simple problem and he said it looks plausible in this but there's a there's a bug and then he chose another solution and he asked the question differently and it generated and he was satisfied with it there's only one problem it didn't work but he didn't test he just thought if it looks and feels right or it looks complicated enough that it's probably right we have this very funny filter to cut off you you probably have mixed feelings about generating unit tests versus ai which i've seen typically yeah yeah because because again i i tend to ask when i so i i had an interesting experience it wasn't with c plus plus early in the series i i did some stuff with kotlin but i'm not a kotlin programmer but i thought you know what i'll ask i'll ask chat gpt i've also since asked bard and gave me it gave me a much more working solution at that point but chat gpt asked its solution and it gave me something that was idiomatic kotlin and it was absolutely brilliant there's only one problem is it completely hallucinated the functions that i needed and then he eventually gave me a solution when i pointed this one out and that solution again looked plausible except for one thing it didn't produce the right answer fortunately i had tests to spot that it did all the mechanics it did all the movement you had the loops and all the rest of it but it didn't produce the right answer and then the next so in other words you need to consider when you look at it from the point of view of ai you need to consider there's a conversation it's not generating code for you it's not a straight through process it's not a formal transformation it's a conversation what about this what about that let me just check that for you okay that's not quite what i was after or i'll take what you got and then i'll adapt it but there's a human in the loop and there's tests in the loop now when we start saying let's generate unit tests for that it's like well tell me what you mean by that are you going to tell me that you're going to get something to generate you both the code and from the same words and specifications it's going to generate the say it's going to generate tests yeah good luck with that first of all it's not going to run them it's going to leave it to you because these are not running them that's an important thing they that's that's a solvable problem by the way they can do that and they can learn from that but at the moment that's not really that's not really what's happening but there has to be something in the loop that asks the question different way and there has to be something that applies judgment and goes oh wait a minute i understand the ambiguity of what i asked the problems with me or actually the problems with you you're hallucinating that's that's where the human is going to be important because otherwise we're going to be generating code that other people wrote we already have that problem so in other words that's we've already got that problem the idea of multiplying it and creating a huge legacy debt is a problem i'm perhaps a little more interested in seeing ai on the refactoring side take this code refactor it into something cleaner and then i already know what i'm expecting and i can write the tests against that and now we've got rid of the problem with legacy code but if the problem that we have is creative if we start using ai to create new legacy code i think and there's a lot of people that are doing that and have done that and will do that i think that's going to be a problem yeah it's fast it looks like you're getting results but what's going to distinguish the top programmers from the rest is those are the top programmers who know what they want and know how to get it and know there's a dialogue and they are going to potentially they're gonna get some really good stuff so i think it's going to widen the gap but in terms of software developers in terms of potentially the skills or capabilities that people adopt i've seen your experiment with scotland and yes it's really interesting that basically you know you get to to the point where you have code that you can put on a slide then most people in the audience will believe that kevin henny or you know anyone else could present this slide and people would read through it and say oh of course that's how you do it in kotlin and then well actually no that's completely hallucinated and i think there's a huge problem with which a lot of people need to start understanding that those systems are not truthful and do not have any idea of a wrong or true or false they have the i mean there's a bigger discussion here which i don't think we have the time for but there's there's understanding what is the nature of such software and that idea i think is going to be [music] i i think there are certain things that can be improved and will improve but there's also something else that is fundamentally missing that still requires a human in the loop and i think that is going to be you know you are left with the same problem how do i specify what i want okay that requires precision and that is sometimes people call that computational thinking it's not about the curly brackets it's about being able to say that i want this with this and being absolutely precise and then knowing what you've got that there is a skill in that space and if you don't have that you're constantly going to be chasing broken things you'll look very busy and in some ways you might even look productive but i i think that there is a there are going to be some issues for that i would also be interested in the role of ai from the point of view there was a question the question was phrased also by the way with specific specifically with spread to c plus plus let's go right back to where we started and also talking about cpp2 the complexity of c plus plus what you kind of want is a you know static analysis but at a at a richer level potentially it's that let me not just offer things to ai and say hey generate me this is i've got some c plus plus can you see anything wrong with this or you know what are the memory what potential memory issues here are all you know these kinds of things tell me about this from a security point of view let's turn this around and not think of it just as generator but as reviewer i think there's potential yeah okay oh yeah so i think there's a lot of things that it's very easy to fall into the generation idea as being of that's what we're going to get it's like actually no there's a number of issues with that not all of which are going to be problems forever there are but there are still a number of issues but maybe we're missing some of the point if maybe maybe there's a lot more that we can use something that has been trained on a vast body of code that could potentially offer us and again i want to go back to this idea of conversation it's a you know that that i do it's a dialogue if you start looking like that i think you're more likely to get good results all right and to kind of closer loop what are your views on any and its evolution from boost to the standard ah okay the only question yeah so annie has a long history a pre-standard history a pre-boost history and i it's i came across the term annie in a lot of this a lot kind of type theory papers and things in the 70s and 80s and then asn one abstract syntax notation for specifying what should be transferred in the protocol they all have a type called any and it's this kind of universal type that's not necessarily a root type and i was working on a system where we needed to have such a thing and i worked out you could do this generically the problem is we couldn't actually use the templates that we wanted to at the time but i worked out in that case okay how do i dumb it down to the types that we are likely to use the basic vocabulary types that we like you to use but the whole idea of having a universal type if you like a type safe void pointer but that's value based it was one of those things i was very interested in fact that old project i discovered afterwards they they started joking about the whole thing after i left is kevlin any you know it was it became known in the code base from that point of view but when boost started up it was one of those things that you know i i've i've contributed three things to boost two of which are about weakening the type system one of which is about strengthening it numeric cast lexical cast and any and annie made it into the standard and that was you know it it had undergone i introduced it originally the c plus report article you know over 20 years ago 25 years ago then i submitted it to boost adding a little more complexity so on but then i passed off the ownership of that to it to others and it's evolved there but it's actually kept it's it's kept its simplicity it was always intended to be it's got to be a simple type it can take absolutely anything it's not a it's not a a kind of constrained union type like variant so therefore you don't know its content you have to if you can just pass it around or you can ask what it is and get values out of it but you can't do anything that is any more sophisticated that it was never intended to be any more sophisticated than that so i'm actually surprised that over time it has become estate as consistent as it was now it was standardized it was included in c plus 17 the late beam and doors was primarily responsible for standard taking the original text and tightening it up and i just gave her a few comments and so on beaman did a really great job there but how do i feel about it i wish it had been different because by the time you got to c plus plus 17 . this type this type was nearly 20 years old and c plus plus had gone through a number of standards so i with hindsight i wish that see i wish it had been more consistent in its appearance in other words we could have changed certain things names and syntactic conventions and usage conventions i think that optional variant in any should have a lot more consistency and that's unfortunately because c plus plus doesn't have a kind of binding vision they were standardized as they were because they came they had a source you know boost in the case of variant and any and they were left very much as they were so they were still compatible with those old versions i actually think they should have been changed in a way that was not compatible that's the whole point of namespaces this so that they were more consistent with each other and they had reflected the standardization trends and idioms that have been acquired in that time so i still retain the i love the basic idea i would stick with that but i kind of like the way the variant and optional do things a little bit more these days and i kind of wish annie looked a bit more like that and i think there's one more question and then we're gonna close because it's already going on for a while i think this is the longest edition we have so far you you have some favorite feature introduced to a c plus 11. android like between 11 and 20 let's keep this one question you would like to highlight and like a lot that's a that's a really good question okay we're going to go for the easiest thing i'm going to say i'm just gonna say the compiler you know the comp having the compiler do all the stuff the compiler already knows you know it the compiler knows it but somehow we've got to feed the syntax it's just like oh my goodness you know it was all the machinery was there you know it's so many it it just the syntactic weight for those of you who've never worked in just straight c plus 98 you have no idea what that's like the sheer syntactic weight of of the language was huge and you know it's just being able to say a little more directly so yeah actually i'm going to go i'm going to be really simple on this one that actually changes the stuff that you write on the minute to minute basis stuff you'll feel yeah feel the stuff you're going to feel comfortable about you're more likely to embrace things that are a little more complex and not get lost in that you can see the code more clearly i yeah i i think that is the the simplest usage level change that transforms the appearance and the feel of the language do you do you agree with her that you should then always use auto oh no i don't no i'm not a i'm not a i'm not a an auto anywhere yeah there is a whole spectrum now i know herb is very much you know just just use it i i don't i don't agree with that and i don't think that is necessarily necessary and sometimes you can end up with great contortions with an auto over here and then an initializer that kind of is feels a little bit unnecessary that you're kind of forcing a lot of the type name stuff over onto the right hand side and and you're making a more complex expression elsewhere now i i definitely i i have a kind of a a kind of set of of rules that i would tend to follow in a number of cases for when i would use auto when i wouldn't okay so and this i guess it's gonna say this is going to be the whole session we have was really really awesome yeah thank you very much yes that's great stuff and thank you thank you kevin for being our guests and staying for something thank you yeah and thank you for your questions folks sorry if i didn't answer them to your satisfaction i know there are a couple of things there you know but the great questions so with that we're gonna end the session