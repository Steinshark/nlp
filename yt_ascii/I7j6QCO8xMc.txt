but let's get started this is just enough assembly for compiler explorer come on in just getting started my name is i am from norway and i work in a company called zivid where we make these cool robot eyes on the top here if my pointer worked there we go yeah so these are 3d cameras that serves as eyes for robots and we mostly do ziploc plus we do a few other languages as well but c plus plus is what i i mainly concern myself with and if any of this sounds interesting to you then feel free to have a chat at the conference or on twitter later or something i also run this website called cppquizes.org which is actually because quest site which you might enjoy and i'd hang out on twitter a bunch on these various accounts so yeah say hi on twitter if you like but we are here today to talk about compiler explorer and who has used compiler explorer yeah most people and who tends to understand all of the assembly outputs that it shows you yeah not me at least so that's why i made this talk compiler restore is a really nice website where you can paste your ceo receiver first or whatever on one side of the site and then on the other side it shows you the assembly code that the compiler made for you and why is that interesting why did it coming in why do you want to look at assembly code in 2022 and that's because you write your c or c plus plus or other high level languages you write that code for humans to read right and then the compiler has to turn that into some machine code stuff that runs on the cpu so if you want to know what the compiler did to your code then looking at that machine code is what you have to do and then for each machine instruction there is a corresponding assembly instruction so as assembly is just a nice way to read the stuff that the compiler did to your code yeah and then you can put in different compilers different compiler options and try like how does that affect stuff so if we have a look at the site here we can see that don't worry about the code this is just some random code i typed in here so we can see here to the left that we have a bunch of c or sql first that i just pasted in here and i selected gcc 12.2 here i can select msvc or clang or like different architectures and stuff and here i can put in some compiler options if i want and then i get to see all the assembly codes and that's the compiler generated and it's also a bit nice that i can like if i hover over some of the assembly stuff you can see it to the left that it highlights oh this is where these instructions came from and the other way around if i foreign these instructions that i can hover over here i can get some tool tips and it's quite convenient stuff and it this is not a lot of code but there's quite a lot of stuff going on over here with all this d word putters and pushing and moving and it's quite a lot of stuff over here and then my promise to you is that in 50 minutes we will understand all of that code not only what it does but also why it's there and that's not going to be because i'm going to go super fast i'm actually going to go pretty slowly from the very beginning to slides yeah please ask questions during the talk so when the code is up here we're looking at it you have any questions try to ask during the talk i'll you can just shout out and i'll just repeat the question because it's better to explain stuff while you're wondering about it and while we're looking at it and have the context but if you have more like i would also like to know about this other thing type of questions then please hold those to the end and today most of the slides are going to be this slide where toy emulator kind of thing so we're emulating a x8664 cpu so we're always going to see the cpu in the middle of the screen and the cpu has a bunch of registers so anytime you want to do something with any data really you have to get it into those registers and for each example i'm then going to visualize the registers that i use in this particular example so for the first example i'm going to use rdi and rsi which are just two arbitrary general purpose registers that we can use for stuff and for each example i'm i'm just setting the register to zero in the beginning that's just for convenience for the slides that doesn't happen in real life so here we can see rdi and rsi all containing zeros and these are 64-bit registers the talk is about x8664 so i'm displaying those in hex over here okay let's get some assembly code up so here is a complete assembly program and assembly is not necessarily easy but it's a very simple language it's just like one instruction one line and you start with instruction name and then every instruction has zero or more operands so for instance this first instruction is called move and it has two operands rdi and two and just like in cfl plus in assembly move doesn't mean move in assembly it happens to mean copy so move rdi 2 means to copy something and there are different syntaxes for assembly and the most popular one and the default one on compiler explorer is the intel syntax and in the intel syntax you kind of have to read backwards so move rdi 2 means to move the literal 2 into the register rdi and not move the register rdr into two whatever that would mean so let's yeah and i've also put up this a little debugger indicator thing this little orange line here next to the next instruction that i'm going to execute so we can like step through like this and see what happens so if we then do execute this first line move rdr2 we then just moved the value 2 into rdi here and we can do the same thing for move rsi4 let's put the value 4 into rsi and then we can add these two registers so i'm going to say add rdi rsi i'll add the two values in these registers together and get 2 plus 4 equals six and then we are used to in our higher level languages to say int result equals a plus b but there are only two operands here so in assembly you don't get to specify where to put a result it will just put it in the first operand so add rdi rsi is more similar to rdi plus equals rsi so if i add two and four i get 6 and i execute this instruction and it puts the value here in rdi because that was the first operand to add okay that's our first full assembly program any questions so far okay that was registers but we are going to need some memory as well right we you don't you can't just use these registers and make a full program you need to have some data in memory so i put up some memory here and i'm going to in all the examples i'm just going to be using the stack and on the stack you can push stuff you can pop stuff but you can also address the stack and you put things at this place at this place in this memory address and everything i say about memory addressing for the stack is also going to be valid for the heap and for global data and whatever so it's just easier to just use the stack on x86 the stack is growing downwards so we can see here on the top we have the address to the left so this will of course be a 64-bit unrest on x8664 but i'm just truncating it a bit it's about address b3 we have the byte 0 at address b2 we have the byte zero b1 we have to write zero and so and the stack then we'll have come from above and it's growing downwards like this there's also another register in this example coral called rsp and that's the stack pointer so that's pointing to the current top of the stack so whenever you push or pop something the current top of the stack is where we're going to push and pop to and from so we have rsp over here and i also put up this rsp indicator over here so you can see that well the rsp has now been zero that's the top of the stack so i'm pointing to it over here as well right so then we can do our next example which is just about pushing and popping some values onto the stack so first i want to put a bunch of bytes into a register so i do move again which copies value from somewhere to somewhere i'm gonna copy this rather long value into rdi just so that each byte has a different value so it's easier to see what goes where on the stack and then we get to push rdi and notice that we're not saying how much to push or where to push or anything we just say push this register and that's because it's a 64-bit register we know that we're going to have to push eight bytes where do we push it well the stack pointer is over here so we know that we're gonna then occupy these eight bytes here and the only question then really is what is going to end up over here at af what what will this what's the value of this point after i execute the next line so there's there's one right answer and then there's the plausible with wrong answer and all the other ones are impossible i would say so it has to be either fe or one zero and as it turns out it's fe that's because x86 is a little indian architecture so the least significant part goes on the lower address and the most significant part goes on the higher address and that's when why you get fe over here on the stack right then we can also pop from the stack and again i just say pop and where to pop so now it's going to see well rsp is down there at a8 so i'll pop from there i'm going to pop eight bytes it's because it's a 64-bit register so i'll pop eight bytes from here and the the stock stack pointer is moved up again so i don't have to move around the stack pointer manually that happens automatically when i push and pop but pushing and popping it only takes you so far we also want to be able to address memory so we want to say at this address i want something to happen so let's do that let's first get some bytes into some registers all of these threes into rsi all of these twos into our di and now we have the move instruction again which we've seen many times it's copying something it has two operands the last operand is rsi that's where i'm going to copy from and the first operand is where i'm going to copy into and i'm going to copy into keyword fitter rsp -8 whatever that means keyword stands for codeword so a byte that's eight bits then you have words which are 16 bits double words or 32 and quad words are 64 bits so code word putter means this is a pointer to a 64-bit value so we know that's it's a 64-bit value and we're talking about it's like a pointer this is an address that we're talking about here and then inside of the square brackets i can put any kind of tiny little arithmetic expression to compute the address that i'm interested in and let's say i want to put this value at the top of the stack i'm not going to use push i'm going to manually set it to that place in memory so i will then do rsp -8 so then this expression is going to do rsp minus 8 well that would be a8 and i will copy rsi into memory at that address if i do that you can see we got all these threes into memory and we also see that the stack pointer didn't move because i didn't push on the stack so the stack pointer is just where it was i just wrote some bytes somewhere in memory yeah and this is actually how a local variable looks like if you have like a long foo as a local variable in your function in c or c plus this is exactly how that looks like so we have our value here in memory and this assembly line here is also something you typically see when you have a local variable memory addressing can also be used in other instructions in addition to move you can use it for instance in add so if i do add rdi and then this keyword put your rsp -8 thing again i'm going to read the value from rsp -8 and the keyword picture is kind of the referencing that so we get the value rather than the address and then we add it to rdi so we take all of these threes from over here add them to all of these twos in rdi and we get a bunch of fives and as we saw before add stores the result in the first operand so we get a bunch of fives in rdi yep then we can read unwrites local variables and before we continue i want to mention registered sizes so originally when the 8086 processor came out like the first processor processor in the x86 architecture that was a 16-bit processor so then we had 16-bit registers called ax bx cxdx and so on but we also have these other names ah and al which just refers to to the two halves of ax so they have the high part and the lower part of ax but if you if you write here it's actually just one register called ax but these are just names for putting about in the lower or higher part of the ax register and then 386 came along with a 32-bit architecture we got the eax register it's still only the eix registers all the others are just like aliases for parts of it and then actually it is 864 came with 64-bit registers and now we only have the rax but you can use the names for the smaller parts of it and then quick quiz question how big is an int it depends yeah if you read the standard it's it has to be at least as big as a short but it doesn't really say but typically if you're on x864 if you're on linux and windows and yeah it's typically 32 bits so here are some typical sizes that you'll see in these registers you can put sign the runs on longs in the 64-bit ones so only runs on the int and the 32-bit short in the 16-bit and then so in the inside or just play in charge in these 8-bit ones so if ins are 32 bits let's redo the previous example just with 32 bits because ins is like probably my favorite data type i use it all the time so let's see how ins look so then things are a bit different i'm using esi and edi in the code here but i'm still visualizing the full register so if i copy this into here into esi you can see i only wrote the lower half of rsi and then i can put some twos into edi and now i can do the same thing again take the register and just write it somewhere in memory and this time it reads a little bit different it says d word for double word because code word is 64 bits double word is 32 bits so d word putter is a pointer to a 32-bit value and i'm also doing rsp -4 on the previous example i did -8 because i needed eight bytes for the 64 bits i just need four bytes for these 32 bits so if i run this it copies the trees from esi into memory here and again i can add i can do add whatever is at rsp -4 all of these threes we just wrote added to whatever is in edi all of these twos and again store the result in the first operand so edi then becomes all of the threes plus all of the twos are all of the fives and then we can read and write ins but reading and writing like single ins and longs and stuff that's that's not really enough we need some arrays as well and arrays also happened to be a good motivation to talk about some other things that are coming up shortly so let's do arrays next let's just start with putting some values into memory this time i'm using word putter for 16-bit values just to yeah for variation and to save some space so we put all these ones twos threes and fours at these addresses here so stack pointer minus eight minus six minus four minus two so i'll just run all those through and now we can see that over here we have all of these bytes that we just wrote and these are just eight bytes in memory somewhere so these don't have types assembly doesn't have types the cpu certainly doesn't have types these are just bytes right this could be eight individual bytes they could be like part of a mac address or an employee record or what have you but for our example we push them as for 16-bit value so logically we are going to treat them as for an array of four shorts but this could be an eight bytes really and now i happen to be interested in getting the fourth element of this array so i want to get this value here and the way i do that is to yeah first before i want to get that i want to have a pointer to the array because the way we deal with arrays in the unsupervised is basically you have a pointer to the first element every time you try to do something with an array it just turns into a pointer to the first element straight away right so we want to have a pointer to the beginning of the array and to do that i need to store the address somewhere so again the first element is set rsp -8 so we've seen the square bracket before that's how you compute an address so to take rsp minus eight so that's b0 minus eight equals a8 that's the address i want but this time i don't want to read the data there i don't do the move d would put or whatever thing i want to just keep the address i don't want to dereference it and the way i do that is with the instruction called load effective address so lea load effective address it's only going to compute that little expression i have here and then store that into rdi so i'm not de-referencing the value i'm just taking taking the arrest or if i execute that i now did rsp -8 i put that into rdi so you can see rdi is now pointing to the beginning of my array and then i have a pointer to my array and now i can get to the thing i started talking about a bit too early which is i really want to look at the fourth element of my array and how do i do that i have a pointer to the beginning and then i want the fourth element so i have to skip past three elements so i have to add three times the size of the element so i need to add six right i have a pointer to the beginning i had to have to add 6 to that address to get to the fourth two byte long value so i do that i do the move thing again rdi plus six that's the point of the address plus six bytes to get to the fourth element up here and i'll move that into ax because ax happens to be where i want to to have my result for this example so that's that's how we can get to to to memory but this is just like a regular memory access thing that we saw before and it's not really useful to be able to to have to hard code the offsets every time right when you want to index into an array you typically want to have an index so i have a pointer to the beginning of the array in rdi let's say i want to have the index in rsi so i'll put 0 into rsi so now my my index is zero i want to get at the first element of the array and what i can do then is i can take my pointer to the beginning which is in rdi and then i just add the index times the size of the element and the size of the element is 2 so i'll do rdi plus 0 times 2 so i just get rdi so this expression here then gets me the first element which lives here and if i execute it i got this once over here into this register but now i have parameterized the index i no longer have this hardcoded plus sixth thing so i can just do ink increment rsi just rsi plus plus plus my index thing and now rsi is one and then i can do exactly the same expression right this is a identical to the one two lines above i can just do base pointer plus index times the size of the elements and now i get if i execute that i get the twos into rax so now i have parameterized my this little line of assembly codes to be able to take an index and a base and this sounds like something you could use in a loop or a conditional so that's what we're going to get to next i should have picked a glass instead of a bottle right conditionals let's start with an if we want to implement an if that compares two numbers and if the first number is greater than the second number we want to store true very interesting program but let's let's just get some values into some registers we put three into rdi 2 into rsi and now we want to check is rdi bigger than rsi and we don't have if or switch or annualize that like super modern stuff in assembly but what we do have is we have compare and we have go to and since go to is considered great we can do everything we need here so the first thing we do is to compare we do compare our cmp compare compare rdi to rsi and if we execute that nothing really happens so what compared does it compares these numbers but we didn't even tell it like compare what like which comparison are you interested is it less equal or like what what do you what do you mean compare so what compared does it just compares these numbers in all the ways at the same time and stores away some some states in some flags that we can wait to check so on the next line we do check so we did a comparison and then we have jump greater jg so jump if greater is gonna then check these flags and say well if the comparison told us that the first operand was larger then we jump if not we don't jump and rdi was indeed larger than rsi so we do actually jump down to this label over here called dots greater which is just a label that we made up and when we've jumped down here we can then write one into rax because that's going to indicate true that yeah the first number was indeed larger yeah so we got one into rx if we do the exactly the same example but we do two and three instead of three and two so this time we put two into rdi and 3 into rsi instead of the other way around then we compare rdi and rsi so this time rdi has 2 rsi has three and we compare those and nothing happens because compare just sets on flags in the flags register and then again we do jump if crater this time the first operand was not larger than the second so we don't jump and when you don't jump what happens then there's no there are no blocks to you to jump to like you just don't jump you just fall through to the next line so when you just fall through to the next line well let me know the condition was false and then we store false in rax to indicate no it was not bigger and then there's one very important thing that we still have to do and that's yeah first to store defaults now we have to jump unconditionally jump to the end of the if thing because if we don't jump here we've just stored false if we don't unconditionally jump we'll just fall through down here and we're gonna also store through and that's wrong right so we just jump down to the label at the end of the if thing so this when you're used to see and simple personal stuff it's kind of the all the way around because we have kind of the the else block is kind of up here and the if block is kind of down here so it's sort of in the other way around than what we're used to so that's something you'll often see there are a bunch of ways to compare numbers or there's just one compare and then there's a bunch of things you can do later so compare what it actually does is just subtract the second operand from the first so if i do cmp up one up two it just does up one minus up two except if you did the actual sub instruction it would actually store the result then into op1 but that's not what you want it just subtracts this one from that one and doesn't store the results anywhere and when an expression like that is executed these flags get set so if op2 is larger than up one that means the result of the subtraction is negative so then the sine bit gets that if they're the same if you subtract the number from itself you get zero and then the zero bit gets set so that's just a bunch of bits like this that get set and then you can do all these conditional jumps later to see inspect these flags so jump equal well i will just check them if the zero bit got set so that's how j jump equal and jump not equal are implemented and yeah similar for then you have jump less less or equal jump if crater jump if greater or equal but yeah i'm not sure what happens with ad yes repeat the question thank you someone was asking if you just do add or subtract do you also set these advice if you subtract i think the flags get set if the ad gets there might be some some flags i'm not sure yes overflow yeah that's a good point if you if you add you could overflow so we've talked about comparison and jump less equal so you tell it like which comparison were you interested in but it's just comparing some 64-bit values like what do this mean like the same 64-bit bit pattern could mean like a very large unsigned number or a negative sign number so signedness like how you interpret these bytes is really important for whether one is larger than the other so all of these jump less and greater these are for signed integers and then if you want to compare it as if they were unsigned you have to use some other instructions and then less than equal those names were taken so then we have below and above for enzyme so if you want to do unsigned comparisons you do jump below below equal above above or equal yes okay if are done next up loops and loops are very very similar to ifs actually because we don't have if and switch we of course we don't have four do while and all that good stuff so we're gonna have to use our comparisons and conditional jumps again and now i want to implement this little c program here what the program does is it's a for loop where i iterate from one to three non-inclusive and i just increment with one every time and i've conveniently named my variables the same as my registers just to make it easier to to correlate and for each time around in my for loop i'll just add the counter thing rcx to rx so i'll just accumulate all of these rcx in rax pretty simple for loop and let's see how we implement that in assembly i first set my counter variable rcx21 and i set my accumulator my rax to zero and then i have a dot four that's just a label for the beginning of my for loop and the first thing i do when i do a for loop i want to check my condition do i actually want to start iterating even on the first round so i compare rcx to 3. and then the flags get set nothing else we can observe and then we do jump equal so if three or if rcx was in the three if we've arrived at three we have to jump out of the entire four things so that we're done but rcx is just one so we don't jump we just fall through to the next instruction and then we can do the ra x plus equals rcx thing and just add rcx to rax so one plus zero equals one and we get one in rax then we get to the plus plus rcx so we just increment rcx now we can jump back up to the beginning of the for loop are we three yet we're not so we just fall through we don't jump keep adding rcx to rax increment rcx to the bombardo counter jump back to the beginning of the for loop are we three yet yes this time rcx equals three so we're not supposed to go into the loop body so instead we do jump equal yes we were equal we jump to the end for label and then we have loops as well yes time for a real example on compiler explorer so i guess i should zoom this a bit so we have this fancy math function here called sum it's going to take two ins a and b them together and return the results very very exciting code and then as i said before i'm happen to be happen to be using gcc 12.2 and this is what gcc 12.2 generated for me for this code on the protection to switch to how do i do that yeah the question was can i switch to a right theme over here settings oh coloring site theme light how it is nice so at the end of the presentation i'm going to outsource some tips for compiler explorer but this is the best tip i've gotten so far right so this is the code that gcc generated and we can just copy that back into our slides so now this is assembly code that gcc wrote it is not my code this is gcc's code and it decided to use quite a bit of registers so i had to put some more registers here so we have rdi rsi rax rdx rsp and rbp yeah push rbp that's the first instruction in our sum function so we are about to start executing our function but before we can start executing i we have to figure out how to get the arguments we have the a and the b someone will have called us with some values as arguments that we need to get to and how do we do that and that's up to the calling convention so every system has a calling convention which tells you among other things how to get stuff into and out from functions and on linux where i wrote this talk we have the system v amd 64 calling convention microsoft has one that's very similar and it says well if you're gonna put pass a few n integers to a function just leave them in these very specific registers because that's a really fast way to do it so whoever called us here they apparently wanted to add two and three so they will have before calling the function they will have put two into rdi which is the first integer register and three into rsi which is the second integer argument register so before we are even called these values will have been put in the registers they're already available so we can just read them out from there the next thing or the first thing we don't do when we start executing our function is to push rbp and that's again due to the calling convention because the calling convention tells us well whoever was calling you they might have been using these registers for something right so you have to not destroy whatever was in these registers and it doesn't apply to all registers but rbp is one of the ones you're not allowed to overwrite so the first thing we do is just to push rbp onto the stack so that the last thing we do can be just pop it off again right so whatever value was in rbp when the caller called us well when we return back that value is still going to be there so if i execute that i will then push rbp onto the stack and i don't really know what the caller had in its rbp so i didn't put any values here but i've now pushed it onto the stack and we can see that the stack pointer has bumped since i pushed something on the stack the next thing we do is to copy rsp which is a stack pointer into rbp so we kind of make a backup of the stack pointer in rbp and we're not going to need it for this example but the reason we do that is when we're executing this function we could be pushing and popping and doing all sorts of stuff that makes the the stack pointer jump all over the place and if we want to do all of this relative addressing that we've seen before like rbp -4 and whatnot it's nice to have this stable pointer to the beginning of our stack frame so we take the stack pointer make a copy in rbp and the b is for the base pointers we have like a base pointer to the base of our stack frame so that no matter how much we do with the stack pointer we always have this stable pointer to the beginning of our stack frame okay then let's see how gcc wanted to implement this stuff well it got these values in these two registers so it's just a matter of adding those registers together but it's doing a few more things it's moving edi which is the first argument a and esi which is the second argument b there are some function it copies those into memory at rbp minus 4 and -8 so i'll run these two and then we can see that's our value 2 is here another value of three is here and that kind of seems a bit pointless but these are parameters so these are l values right so you have to be able to de-reference this and take their address and all that l value stuff so better put them in memory so that we can actually do that so now these are actual variables in memory that you can take the address off you can we cut them in your debugger and all that stuff next thing gcc decided to do is to then copy them back into some registers again i don't know why it just decided to well let's take them from memory back into some other registers so now finally we have our two and our three here in rx and rdx and finally we're gonna sum them together so add ax edx well then just three plus two equals five and then we said we had to restore the the base point area because whoever called us they were probably using the base pointer or something to better property of the stack and i'm a return and how do you return like we have this value five we need to return it somehow and again the calling convention tells us how to do it and the calling convention says if you just want to return a simple integer or a pointer or something simple like that just stick it in our our ax or eax for a 30-bit value and then the caller can just read that register to get the value but this add thing here it already put the result in eax so we don't really need to do anything the return value is already in the correct register and we can just return and then red just returns instruction to wherever it was before the function was called and that's a quite cumbersome way of adding two ins so yeah that's that's my he's asking exactly what i was going to say and that's what what happens if you do some optimization here it's a very good question and this looks a lot nicer right no memory access which is super slow not all of these instructions moving stuff back and forth so this is nicer it has just one single instruction to add stuff and then we return but l-e-a remember that one load effective address so why are we loading addresses we just we just want to add to ins that we got in some registers we don't need any addresses well lea is it's what it does in the square brackets is just maths right you can just like do some simple plus and minus stuff in here so well you can and and the things it's just everything is just bytes right so lea doesn't know if these are pointers or if there are data or whatever so lea can just so it can just actually sum stuff together and it has this nice property that you are allowed to tell it where to put the result so we get our two parameters in rdi and rsi that we add together but if we had added those the result would be in rdi and then we'd have to move it into eax with lea well we can just do everything in one operation and it doesn't care that this isn't an address really it just does the maths and is happy so that's a very and it's it's fast as well so yeah this is a very simple way to to do the some function and then i'll just go back to the slides just so we have the url correctly and now we have seen variables as in memory access arrays control flow with if and four and started looking a bit at functions so when they have all of this we can then finally get to the holy grail of programming paradigms which is of course procedural programming so let's do that and then i have to change the theme here again maybe i can refresh ah super fast nice and then there's a preview that doesn't go away all right okay so here's a slightly more advanced example very similar to the previous one so we used to have some in the previous example we took sum of a plus b this time we just make it a bit more advanced now now we're getting into like really hardcore math here we're going to take a and b sum them together and then times two so you're gonna double the result so it takes a and b the sometimes two takes a and b adds them together and then calls the times two function and the times 2 function just returns the whatever argument times two and then you see to the right this is the assembly code that gcc happened to make for us and then again we can bring all of that into our little emulator thing here and now i'm going to use a bit more stack so you remember the stack was growing downwards like this and then i simply just look at that drawing nicely yeah so the stack just wraps around it grows downwards like this and then it continues from up here and keeps scrolling down like this just to have space on the slides okay so we in the sum times 2 function it took two parameters a and b and the first thing it wants to do is to add those together before passing it to the times 2 function so it's very similar to the the previous one it pushes rbp so that we don't destroy rbp for our callers we can pop it restore it later next thing we do is to take a copy of the stack pointer into rbp so it just copies rsp into rbp so now both rbp and rsp are pointing to the top of the stack and this time that's nice because we are going to start messing around with the stack pointer we are going to subtract 16 from the stack pointer so this now it's nice that we have this table pointer to the beginning of our stack frame because then we can do all our address computations relative to that and then we have kind of a like limits for our stack frame so rbp this is where our stack frame starts rsp is where it ends so when you call another call another function that one can start using the stack from the stack pointer here yes and then again someone who ever called us they were again very interested in what happens with two and three so they put those two values into rdi and rsi the first two int registers and then i'll just skim through this gcc decided to do exactly like before copy those two values into memory over here and then copy them back into these registers so we have the two under three over here just as exactly as in the previous example and now we want to add this together and then pass that to the times 2 function so adding is just like before add eax edx it's going to add those two together so it takes two plus three equals five and store it in the first operand eax and then we have five over here and now it's our time to call another function so far we've only been called now we are calling someone and we have to fulfill the caller's responsibility in the calling convention so we have to take we're going to take this value 5 and call times two with it and then we need to put it into edi just like whoever call us put their value 2 into edi now we have to put our five into edi so we take the result from 2 plus 3 that we have here put it into edi like this and then we can call the times 2 function so when we call that then control then moves down here so we have an instruction pointer which i'm not including in these examples but it's kind of like the orange indicator here the instruction pointer is now pointing down here instead and the times 2 function does their usual preamble push rbp so we can restore it later take a backup of the stack pointer in rbp then it has gotten this value in edi and we want to have a proper l value that we can take the address over and everything so we'd better put it into memory and so let's put it back again into a register just like we've seen many times now and now we come to the times two function is supposed to multiply its parameter by two and gcc even on o0 figure out well mole is kind of slow so or probably that's why i did it so let's do add instead just add the thing to itself to multiply it by two so we add 5 plus 5 that's a so now we have a in r a x over here and then we have to return it so we have to get it into eax but it's already there so we don't have to copy it anywhere we can just pop rbp so now we can see that that was nice because now we now we get our rbp back when we get back to our function and return and then return just transfers control back up to where it came from so it just returns to the next instruction after the call instruction then we see one new instruction here that we haven't seen before but it's just a combination of two things so we have this leave instruction all it does is just like a shorthand to undo these two things so it will first use rvp to restore rsp and then it's going to pop rbp to restore those so i'll have like two clicks to do that one the first thing it does is it copies rbp into rsp so it resets rsp to point down here where it was pointing and then we pop rbp of the stack and then rsp jumps up again and then rsp and rbp have both been restored for whoever called us and now we're in the sum times 2 function which did a plus b pass that into the times 2 function so now we have to take the return value from that function and make it the return value of our function because we want to return that result to her whoever called us but well we just call the function and we know that the result from that function is going to be in eax and that's exactly where we need to put it to return from our function so we don't really need to do anything we can just call red to return to the color and again do you have a question about optimization but i think it would collapse quite a bit here yes it's going to collapse a bit is the comment and that is correct so if we first look at the times 2 function it does takes into i returns i times two so it's doing the lea trick again it then just adds the number to itself put it puts it into eix so it doesn't have to first add it and then move it into ax it uses the lea instruction and then just returns for the sometimes two function we get these two ins in edi and esi so we first have to add those together so it adds esi to edi so edi now holds the sum of them both and then you can see it just inlines the entire times two function so there's no function call down here it just inlines it and it can do that because it's in the same compilation unit so that's why it's able to inline everything so now this collapses down to a very nice short function yes yeah so rdi that's the name of the full six yeah okay i can the question was just what's the difference between edi and rdi rdi is the full register so that's the actual thing on the cpu if if there is even like an actual thing on the cpu anymore but anyway edi is the name for the 32-bit part of it so yeah so it's kind of it's like these are the names you'd expect you get this into edi and esi which are the lower parts of rdi and rsi and then lea where we'll be kind of abusing lea here we're tricking it into doing some maths for us lea only knows about addresses and all the addresses are 64-bit so lea expects to get 64-bit register so we just just give it the full register and then the top part is just going to be zeros and apparently we're then allowed to just write the lower half into the ax so yeah that's that example and then we can go back to our initial example and i'll use all of us hack here fantastic stuff remember i showed you this code in the beginning with like i'll just zoom out of it with all of this assembly stuff and i told you that in 50 minutes you would understand what all of it does and why it's there and i think we have achieved that so let's first look at this computer function so we have this computer function here this is just a random code so don't care too much about the implementation i'm going to go a bit quickly through it because we don't need to like deeply understand stuff i just want to like show you that you have already seen all of these things so the computer function takes an int a and an unsigned in b and then it has a for loop that just like counts down this b value until it's as long as it's larger than zero and just adds all of those to a and then we just return a so then we can look at the implementation in assembly here you can see i think i didn't mention it but it it annotates also like at the top here this is the stuff that came from the computer function so we push rbp so we don't destroy it for our caller take a copy of the stack pointer into the base pointer so we have something stable to address relative to then we have gotten our two ins in these two integer registers and we push those into memory somewhere so that they get there are actually actual l values real variables and then we get to the for loop so the first thing we do is to jump down to l2 jmp unconditional jump okay let's jump down here and yeah here we got a into rbp minus four and b into rbp -8 so -4 that's a minus 8 is b so when we're down here we're going to see are we going to jump into the for loop or not so we compare b which lives at rbp minus eight d word putter is the double word pointer thing we talked about earlier compared to zero if we are zero if you're if we're not zero jump if not equal then we jump here into the loop body and this this comparison thing might as well have been up here it doesn't really matter it's just how it's happened to end up then we do the thing before we saw before we take these two variables from memory a and b put it into these two registers add the registers together result goes here so now we have the result of this a plus equals b here that result is now in eax and then we need to move that back into memory because a actually lives here in memory at rbp -4 so we take the result of the addition and then update the real a in memory and now we do sub to subtract one from b so this is the b in memory we subtract one from that and we're back at the comparison so are we are we zero and whenever we get down to zero we don't jump if equal and let me just fall through to the next instruction and then we just have to return a well a is here at rbp minus four so we put it into eax the return register we pop the base pointer and return okay so we've seen over that before we know why it's there and then we have this color function and this color function is going to call the compute function so we're going to call the computer function with the two literals one and three and we call that i and if i is less than 10 we just return it if it's bigger than 10 we just return 10 we don't want to deal with these huge numbers like 11 and 12. so yeah let's see if we can understand the color as well so we push rbp yeah this one we see before we subtract 16 from rsp to set aside some stack for a place on the stack for for our stack frame then we have we're going to call a function with two literals so we put those into the first two arguments that the calling conventions has to use and we call the function we get the result from the computer function in the return value register eax we put it into memory so this is now where our our ins i lives that leaves that's minus four from the base pointer and then we have to check is it less than 10 so let's compare it to 9 apparently and jump if greater right so instead of jump if it's less than 10 we just jump if it's greater than mine so if it's greater then we want to it's done that's a really big number that we don't want to deal with so we just jump down here we put 10 into our return register if it's not greater we just fall through then we take the value of i here at this place in memory put it into the return value register and then we have to remember to do this unconditional jump so we jump over the other branch and we can leave and return to restore rbp and rsp and this is not interesting code in any way and it's not very advanced but it's hopefully enough fundamentals to how things work that it's a lot easier when you use this stuff and you google things and you probably have more of a fundamentals to understand what stack overflow tells you and a few tips you can hover over here as i said before you can like control or right click and jump to some assembly documentation which helps then you can google stuff of course it helps to make a local reproduction that's as simple as possible so your ide probably can help you to inline some stuff for you can copy and paste and delete things until you have a standalone reproduction compiler explorer also has libraries so if you want to use boost or fmt labor or i again or whatnot then you can just add those and you have them available in computer explorer sometimes it helps to use ins instead of complicated types unless you're interested in what happens to your actual type then that can be nice and don't try it on your full project right this is not like how does my program work it's like how what's the answer to this specific thing i wonder about so i think matt goldball team who made compiler store initially did it to figure out the new range based for loop when that came does it perform as well as the normal for loop and then it just looked at the assembly code and said well the assembly code is exactly identical so now i don't need to measure performance on all my targets and stuff i just i know it's it's going to be the same so we can do that or like is this templates going to inline well or yeah things like that yeah we have a couple of minutes left so oops any other tips from the audience except from the light team for presentations one thing you can execute the code i didn't show that but you can like take the box to execute the code which is really useful and you can side by side compilers so you can like compare gcc to clang to msvc or or it was not as pretty useful as well so i have a shortcut in my browser to open compile restore with gcc client and msvc next to each other which are the compilers i care about for my project yeah then i think that's it one minute left for questions if there's anything yeah question you'll get a microphone here so it looked like you have to kind of remember which variable goals in which yeah which place in the memory so is there a way to kind of replace that or show that in the in the assembly code so like like an address table maybe or do you know i'm oh you have the thing where you can you can it doesn't work that well for parameters but maybe the int eye thing here i'll scroll down a bit oh that's too much slowly back up there we go maybe you can see yeah i'm not aware of any like fundamental techniques to like visualize it for you but at least on compiler exporter when you highlight this line here you can kind of see here that this line is highlighted rbp -4 yeah i think that's the best i can can give you and yeah hopefully you don't have to write too much assembly yourself any other questions okay then thank you for coming so late and listening to me talk about assembly thanks [applause]