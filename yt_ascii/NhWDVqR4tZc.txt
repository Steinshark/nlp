we are talking about finite automata last time and we had a look at deterministic finite automata what are these good for i mean they are sort of fun to play this right but some people that really i mean they cannot do any sort of theory without seeing the practical applications so let's say a few words about this when you write a compiler or any sort of programming language there are some components like which are sort of lexical which we need lexical analysis for like what is what is a what is an identifier what's a number what's a comment and so on this is a low level structure and this is done via a regular expressions finite automata and so on so that's one of the things they're good for yeah another thing is actually a regular expressions which are we will see related to automata we will we haven't seen this yet they are useful to describe patterns in text if you want to write something like text processing well if you want to write an editor script yeah to do something using regular expressions and they are translated into into automata practical yeah so so another one is protocols communication protocols they're often described by finite automata it's it's a it's a good thing and then finite automata sort of the entry the rock so to say to to so form a description of of computation which which do playable in theory as well as in applications [laughter] okay yes so today as the last time we talked about deterministic finite automata and i i i i do a few and we played with them so i mean this is under so other video and you don't have to go through this again but i wanted to do it today is is another thing it's non-deterministic finite automata and what are they we'll see they look very similar to the dfas but they're basically magic machines whereas for a dfa you always are in a state and then you send some input you go to a different state for the nfas you you there is maybe a choice you maybe could go there or maybe here or you may be going nowhere yeah and and the magic is that an nfa it will always make the right choice yeah if there is a way that they could accept the word it will make this choice yeah so they're really magic machines right so we're going i mean if you get them right no no i mean yeah the magic okay yeah that but they're matching and always guessing right when they run right so so this is in general actually the case with non-deterministic automata i mean there are other kinds of non-deteristic automata like pushed on automata or turing machines they can be all non-deterministic and they're always the idea is they always do the right the right choices it's a bit magic right and you may ask what what are they good for again yeah because the dfa is clearly we can implement we can run but the nfa is there seem to be a bit there was a non-ded mystic automata seemed to be a bit sort of fancy in like you have to have enough magic to be able to to run them yeah the point is that they're actually first of all in the case of the nfas we will see we can translate them into dfa that's not always possible for other automatons not always possible but in this case we can actually translate them and the non-deterministic automaton there it sort of in between the most of abstract description of languages yeah into actually implementation so they're like a a thing in between so for example when we look at regular expressions we can translate them first into non-domestic finite automata and then next step into dfas but they're sort of in between so they're useful as in between us yeah so this example so we're looking at at a language of words over some alphabet so the alphabet is this time is zero one so if you're looking at sequences of zero one and the language i'm going to just describe as a language so that the penultimate symbol of of the verge of the string is one okay let's play the game that's that that save as a shown as a good alternative i've been practicing okay very good what about one zero is it in the language yes okay what about one zero zero no no okay very good what about zero one zero yes very good and what about one oh no no it's not exactly okay very good you i think i can hire you as an automaton or something you know okay so let's build okay how do i do this fold the door [applause] okay so let's build the automaton so as we have seen already the automaton they have little squiggles which are states well it's not i i call the state zero and i say it's my starting state so i put an arrow in and now i say no no i see a zero or one i stay in the state okay but now if i see a run i get sort of excited because maybe i'm going to win and then i have another state whatever comes here i go into this state and this is my final state okay so that's that's an nfa and why is an nfa okay so first of all we have when we interstate 0 and we see a one we could go here or we could go here right so that's a bit weird all right and then when we see a one okay with zero one we go here but then what happens here what happens if we see anything we there's no no transition so it's not a dfa yeah for two reasons so one reason in this case we have got two options and in this case we have no options but let's see whether we can we can run this automaton and you need a bit of investment to play with nfas yeah so how does this work so i'm i'm simulating an nfa by putting coins on the states remember that the dfa said it was my finger but here it gets a bit more complicated so let's say we want to do one zero see what happens so one zero we are here so we put a coin on the initial state or actually an nfa can have several initial states so we have to put all the coins and all the initial states this one is only one okay and now you see we see a one so so this one goes here but it also goes here so we are like in two states now right we are in state zero and state one at the same time like a superposition yes phantom right and now okay we have we have to add this and now we read the zero so what happens is zero and zero and we are finished and we have a coin in the final state so hence it's accepted okay let me do one one one okay which i didn't ask previously but i just accustomed to me that's a good example okay we start with this coin then we have a one so let me go here right and now we have another one so so yeah if this coin stays here this coin goes here and this coin goes here right so we are finished and we have a coin in the final state so it's accepted no surprises so do a negative one what about one zero zero one zero zero okay so you start the corner one so now we read the one so we go here now we read the zero zero zero and now we really noticeable this coin has nowhere to go so we lose it it's really a game of money you can lose money you can win money but you can lose stays where it is and we have no coin on the final state so it's not accepted so this is the final automaton and that's where we run them right with coins but the idea is that the current self-represent all the states we could be in now we can translate an nfa into a dfa okay so here's the idea is that we have a a dfa where the states are sets of states so for example what we start with is the state which has only the set zero so now if you have a coin in state zero what we do is we define a dfa which tracks the configuration of coins basically yeah so if we hit in state zero and we we see a zero then we still have just one coin and zero so that's this one here or if you see a one then we obviously have two coins so we have coin in zero and one so we go zero one okay so now let's say we're in zero one what happens if we see a zero what happens if you see a zero we stay here and we go here so we are after zero we are in zero two but let's dig in if you're in zero one and we see a one zero and if you see a one then this go here but because we have a loop here we go into 0 1 2 so if n zero one and we see a one and 0 1 2. you're not finished we have to to get transitions for these as well so what that's again we're on zero two and we see a zero what happens if you see a zero this one is lost but this one stays where it is so we are back to the state where we only have a coin in zero and what happens if you see a one so let's get let's reset we have zero two we see a one then this coin disappears and here we have two coins right so that that means if you see one i hope i didn't make a mistake here okay so here we have zero one so we have to see if we have three coins 012 and we see a zero what's happening this this is here this is lost so we are zero two so if you see zero you go to zero two okay now what happens if here zero one two and we have a one we lose this one and this all okay so we have to mark initial state so the state where we put the tokens and the coins or the initial states is this one and and then we have to mark the final states so final states are any state which contains a two where there's at least a token a token a coin on the two and this is in dfa right because we have one initial state and we have always exactly we know all what's happening because we know what happens to the coins and this is a famous construct it's called the power automaton and it shows i mean hopefully the idea is clear that we can translate any nfa into a dfa into dfas are easy to run okay now why is this called power automaton because the states here are sets of states so it's a power set and in this case it's quite harmless we start with three states we have four states but in in general it could be an exponential blow up because with three states we actually have eight possible states two to the three because there are eight possible subsets and there are lots of states which are not reachable which you don't have to don't have to draw so another four states which you don't have to draw because it can never be reached but in principle you can have automaton which grew up like this so it's doable but not always practical yeah exactly it's not feasible okay should we go to do some python hackery let's do it yeah okay so here we have the code from last time which was a code for dfas so we had a an init function printing function and a run function if you have some examples okay i'm going to do the the nf is in the same file because there's going to be some interaction between the two right you want to translate nf is to dfa is actually also divas to nfas which seems should be easy but still we have to do a bit of work okay so we define a class nfa is it that certain problems are only able to be done within nfa to start with and then you translate it or it's certainly much easier so if you for example you see i want to recognize a fixed string yeah then to do this to to constructed and dfa can be non-trivial because i mean if all the possible yeah yeah so it's much easier to to construct the nfa and principles you can translate it yeah especially as i say if you come from regular expressions then it's quite straightforward to construct for every regular expression in the nfa and then to the dfa but it's not so obvious how to construct directly a dfa and in terms of running this computationally not on a piece of paper with coins yes we're going to look at that yeah yeah so we look at it is it easier for the computer to do the dfi sure yeah much easier yeah okay exactly actually dfa has got a linear complexity whereas for an nfa it's first of all not clear i mean it turns out after translation it's it's also linear but okay the inner method for the dfa is very similar the difference is that for the initial state we don't have not one unless you state which we have a set of initial states and the transition function delta now becomes the transition relation because we don't know we don't always have function given the state and given an input we don't have one next state but we have a set of next states and this represents the relation right okay let me just continue a bit the printing function is called easy so nothing exciting but let me first do my example automaton okay so i call it n0 so what we have to say we have to give the set of states zero one two set of symbols which is 0 and 1. and now we give this transitional relation and that's a bit more interesting than before so we assign to any combination every combination of of of a state and an input a set of states so here for example the set of state 0 if if you're in in zero and we see a one then we could be in zero and one then we can only be in two and if we have one and one we can only be in two so first of all we haven't really described what happens for every combination so this is implicitly for the combinations we haven't covered it's the empty set and okay then we have here a set of initial states which is just zero and the set of final state which is two okay so what we now have to do is to define the run function for nfas and that's a bit more involved than for dfas we have to define a run function this was very easy in the case for the for the finite automata with just a little while loop going through the symbols and just use the data function to compute the next state but here okay we have to compute the set of states at each step and there's also the problems that sometimes we haven't defined the the answer and then it should be the empty set okay so what i'm doing here is i i have a function called do delta which constructs the the set of the the states looking up in this relation but if there is no set then it returns the empty set okay and the run function what it's doing it it starts with the set p as a current set of coins it's a set which is in the initial state and then we have this while loop as before but we have to compute the the set of new coins and what we do is we go through all the states which are in p in the moment apply this delta function and gets a new state and we take the union of all these so we take the union of all these possibilities and in the end we set p to be this this new state and when we have processed the whole world we say the intersection of p and the final state shouldn't be empty okay so let's type to to run this we have here this autumn 10 and 0. so n0 don't run what was our first example one zero which is yes and now we do one zero zero and it is no and what else all we want to do this string which is just a one which is also false okay test cases now we have these two classes nfa and dfa it's first of all every every dfa should be an nfa so how can we translate a dfa into an nfa so i'm going to write a conversion method for dfas called nfas to construct an in an nfa i have to construct this new delta function and basically it returns a singleton set for for any transition in in the in the delta function of the of cells the dfa and it also constructs the singleton set here okay for the for the initial states because there's only one so this translation is pretty easy so this using this function we can translate every dfa to an nfa by just turning all these single states into into singletons and that's just how it looks like in python but i'm going to leave the the other translation the power automation translation i'm leaving this as an exercise but i can provide the answer so here the idea is if we have an nfa we want to construct a corresponding dfa and there we have to do this power automated construction which i've just described by example so as i say that's left as an exercise to the reader but i can provide the answer if you get stuck and now let's try this one a b a bad state it's like kind of engineering type things this one is getting creating removing providing criticizing so like for some reason these types of words