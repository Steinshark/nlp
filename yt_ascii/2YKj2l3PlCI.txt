thank you thanks jens for inviting me and for everyone for showing up this is super exciting and i'm i'm really glad to get to to present this again and i can absolutely keep talking about this for as long as people want to stay i am going to try and keep it to about to about an hour for the main talk but i'm happy to go through more slides in a breakout room i'm happy to interact on twitter or wherever else there's lots of fun stuff to be learned here and like i've been learning a lot about this talk by putting it together and everything i'm gonna take out one of my headphones so i'm not yelling so much so yeah this is the talk i gave back at cppcon 2020 about five days ago four days ago and i had a lot of fun with this talk and so part of the goal this talk is to have a lot of fun kind of laughing at some obscurities in c plus plus but also to kind of see what we can learn from them see what we can learn about how like real production code should look and act and stuff based on these tricks so let's see if my slides are advancing there we go so goals some goals for this talk yeah like i said let's have some fun geeking out about how weird c plus plus is sometimes well that doesn't apply but it's probably been a long week for someone and sometimes you have to laugh to keep from crying let's learn something new about how c plus plus works by using it in a way that's so bizarre you really can't forget about it when it comes up in real code and these things do come up in real code like i would say 30 of these things that i've these tricks that i've tweeted i've seen in real code or seen the consequences of in real code or seen the fact that someone doesn't know how the underlying mechanism works come back to bite someone in real code and so that's an important thing to know sorry my cat is in my room and i did not realize my cat was in my room so this will be fun and yeah let's learn hopefully learn the right thing but also i kind of want to try and teach people how to learn and how to how to play with seepless plus in ways that kind of elucidate how dark corners of the language interact and that's a lot of what this whole cute tricks tweet series is about is is learning to to play around with c plus plus in ways that will learn something new that can then be applied to real code and yeah two c plus standard defects reports have been filed as a result of writing this talk so there's there are useful actual applications here some disclaimers don't use these tricks in real code if someone tries to cite this talk in a code review as like hey this is what you should do show them this slide and say like no daisy said don't use this in real code but use these things to help you understand code this is not a software engineering talk this is you know well-written code should be unsurprising and kind of the whole point of this talk is to to talk about some little code snippets that are surprising and because they're surprising they'll stick in your memory a little bit i definitely have a problem with my talks about getting too into the weeds but sorry this talk is all weeds and this talk is actually several mini talks and it's probably going to be part one of n as i said on the title slide i have about about 30 of these that i really like to expand out into kind of talk segment length pieces and i got through about five of them in this first talk so i plan to keep doing this at whatever venues will have me for as long as it's useful to people but i really enjoyed making this talk i really enjoyed giving this talk so i hope you will too anyway here we go let's jump into this this first trick i generally i mean i don't know how we're gonna do things online but i generally will try and stop and answer questions i think at the end of each kind of mini talk each one of the the tricks unless there's a good stopping point in the middle if people would like to interrupt or or have other thoughts in between that's totally fine too i may or may not see them i'm gonna like very intentionally go check over to the q a and check over to the chat in between each of the segments so let's jump into this this first segment this is the tweet i've left it in the talk so that if you're following along on the slides online i posted a link to the slides in the the chat so hopefully everyone should have some access to them but you should be able to pull up the tweet take a look at some of the discussion around it there's always some very interesting discussions around it either now or after the talk this one was surprisingly surprising to me how popular this was so this this is the trick in a nutshell is that you can iterate backwards through a parameter pack by folding over a right associative operator like assignment for instance and it turns out there's a little bit more to it than that but let's we'll get to that in a second it's not the actual associativity of the operator that's causing this to happen but you should see why i said that that's more or less correct it so what are we doing here i think this is the part that really caught people's attention is that this really compact piece of code does something so surprising i think people have a notion that terse and short pieces of code should do something obvious and the reality is that when you're writing readable code when you're writing maintainable code it's often things that are that are very much not terse that end up doing things that aren't that are obvious and things that are terse are often surprising so it's a good rule of thumb to think about it's as when you're writing code for production think about like am i is this too short right if this is too short it might be surprising and so that's not a good idea but in the case this case i was trying to be surprising and i think i succeeded so when you're doing some generic pro when you're doing generic programming you often find yourself in this situation where you have this parameter pack with the dots that basically means that you have one symbol representing multiple entities right in this example the one symbol t's lowercase ts represents one two hello three four worlds right so it's all one symbol and you need some way to do something with it that goes across those symbols right so in this example we kind of created this this inline lambda here that's just an easy way of doing something that we can see in this case it's just printing out the argument right all of these arguments can be used with the stream operator and so and nc out so we're just putting it out and then we return stood type identity avoid this is just an example of anything with a reasonable assignment operator will work here i mean i could have used yeah any number of things but stood type of identity avoid was a simple one to use and it is a new feature in seepless plus 20 that's lots of fun but is beside the point here so if you return something here that you know had a deleted assignment operator obviously this whole thing wouldn't work but since we have a well-behaved one here this this code generates backwards iteration and forwards iteration through the parameter pack and let's we're gonna go through that in a second as to why that is these are fold expressions i'm gonna go through what that is don't worry if you don't know what a fold expression is i'm gonna go through that too but that's the general trick i'm just trying to take my time going through this so that everyone has some time to absorb what's going on here i had some really interesting reactions to this one alistair meredith said that he wishes he'd figured it out for himself michael park terrifyingly enough says he's used this in actual code which i don't doubt is wrong michael carr park is a fantastic programmer it's just that it's a little bit terrifying that it's come to this someone else said this is absolute wishcraft which i hope by the end of these slides you will find out you won't feel that that's the case so here is the very simple version of what's going on here right we have this print one function and if we feed it an argument it prints it out and we're ignoring the return value in this particular case and that's that's completely fine if we use the comma operator here right so the comma operator is something you can overload in c plus this is an a non-overloaded version right this just takes and discards the result of the first expression and then returns the result of the second expression but we're ignoring this result of the second expression so it doesn't matter either right and the comma operator evaluates the first argument print one on hello and then evaluates the second argument print one on world and does it in that order and the assignment operator does the opposite it evaluates print one on world and then evaluates print one on hello and so there was some suspicion as to like why is this and one of the i think the best comments i got was sylvester hesp on twitter responded that operator associativity doesn't apply here since the fold expression is what's determining the associativity and creates parentheses which of course parentheses override associativity associativity is just another word for saying where do parentheses go by default if there's any question as to where they should go and yeah they're absolutely right they but c plus plus as a general rule people suppose deterministically evaluates right associative operators from right to left evaluates the arguments to write associative operators and we'll see where that was added to the standard and when that was out of the standard and how you can rely on that and sylvester also points out quite correctly that there is a right associative operator in the standard that doesn't devalue it from right to left and that's for very good reasons i think and that's the ternary operator so why were some experts at siblings bus somewhat confused by this behavior well so this this first statement in introduction says that except where otherwise noted evaluations of individual operands are unsequenced right so people some people commented with the fact that like are you sure you can rely on that i don't understand i'm surprised that this is actually deterministically happening are you sure you're just not running and you're not enough compilers or whatever and in fact it in preceptor 17 this would have been the case but we added some significant cleanup to this in cpl 17 where we specified that expressions separated by a comma so the comma arguments to the comma operator are always evaluated left to right and in the best staple tag in the entire standard expert.s we say that the right operand is sequence for the left operand in assignment in assignment expressions so this is evaluation of arguments the the assignment operator goes from right to left and so that kind of explains this previous slide here right is that the comma operator the evaluation of our sub expressions goes from left to right and and in the assignment operator evaluation inverse of expressions goes from right to left so how do fold expressions work so now i know not everyone is i should have done a poll beforehand or set up a poll to see who's familiar with fold expressions and who isn't but i honestly don't have a very good idea of that i use them all the time i think they're fantastic anytime i have a dot dot dot in my arguments i'm often reaching for a fold expression in some form but fold expressions basically work like this so if you put the dot dot dot on the right hand side like this can people see yes you can see highlighting that's good if you put the dot dot on the right hand side like this you'll get something that groups things with parentheses from right to left so this is called right associativity and it's enforced by the actual syntax of the fold expression itself so this this i created a a function here and a lambda here just as a way of you know generating some symbol that is part of a pack but these two are exactly equivalent right folding right on one two and three with print one is the same as writing it out like this right it's just that in a more generic context where you don't actually know the number of arguments it's it's more complicated right and the same thing this the opposite of that is left associativity and left associativity actually groups the parentheses on the left so you can remember dot that dot on the left means parentheses on the left and all four of these cases that you can see we've got got the same output and so we'll dive into exactly why that is in a second but in basic form right where it doesn't matter how what order we evaluate the assignment operator itself in as long as we're evaluating the arguments in the same order so in this case we're evaluating print one on three then we're evaluating print one on two then we evaluate this assignment operator then we evaluate print one on and then we evaluate this assignment operator but since our assignment operators aren't printing anything out we can't see the difference here right so going back over here we evaluate print one on three then we evaluate the left-hand side of this equal sign which is this parenthesize expression which causes us to evaluate print one on two and then print one on one and then this assignment operator and then this assignment operator but because we can't see the assignment operators we can't tell this difference the opposite is happening with the comma operator i'm not going to walk through those individually but you get the idea there let's actually add something here that does print in its assignment operator so we can actually see what's happening in this scenario so if we if we add this blabbermouth type which is what i call all of my types that i use to play around with these things because it's just hilarious and makes me laugh the we have something that just prints out what it's doing inside of the assignment operator and then like reassigns its data member to be like the result of assigning one thing to another right one thing to another and that way we can kind of see what's going on each time as this expression progresses right and so we created a robber mouth objects of you know three different letters here and and we see in the output here that in the right associative case we get print one of c and then print one of b and then we evaluate the assignment operator right because we're still evaluating the right hand side of this first right so then we evaluate the assignment operator doing assignment from c to b then we evaluate the left hand side right print one of a and then we evaluate the actual assignment operator right and since all we were seeing before was this this and this sylvester is right that the associativity itself doesn't doesn't matter but the associativity is a good mnemonic for remind remembering the order in which the standard evaluates the arguments to an operator so if we do the same thing the other way around you know we've got the dot on the left hand side we actually do see that the that the compiler evaluates this statement first print one on c then it tries to evaluate the left-hand side of this operator and that involves evaluating these parentheses which evaluates print one of b and then evaluates print one of a because those are the arguments to this assignment right and then it evaluates this assignment here assigning from b to a and then it evaluates this assignment here right so i that's the end of that little trick did people follow that is that you can go up to the chat and the q a created a poll do you understand fold expressions yes and sometimes and do you use fold expressions okay that's actually very interesting i would expect that that most people yeah don't actually get to use them very often in real code i'm i'm kind of feel pretty lucky to have had some fantastic opportunities in the past to work on very generic code and the standard library certainly uses them a lot but my feeling is that people use templates and real code way way way less than standard library implementers think they do and so i that that more or less lines up with my kind of more recent understanding yeah and do you so these are updating wonderful do you understand fold expressions i would have expected about 50 50 in a meeting like this and this is very interesting to find out i hope that people have a better understanding of fold expressions now and we're really just expanding the symbol that represents multiple entities into the multiple entities in some interesting way right yeah that's cool 20 people so 20 of us can hang out and have drinks and geek out over the fold expressions that we use in real code and the rest of you are welcome to join thank you jens that was actually quite helpful to have a poll in there are there any questions on this section that i can address before i move on to something completely different i'll give it i don't know how long i should give it before people do but i'm guessing that this means no we can always take i can always take questions at the end too or in the discussion at the end so i'll just go ahead and move on to this next one this next one was a lot of fun on twitter this past week because i posted it and first thing that that i mean i talked about it in my talk and the first thing that i got his feedback was was well i use that in my i use that in real code that's not too too cute and then the second thing i got as feedback was well the c plus plus standard doesn't actually guarantee that this should work which is not those aren't really two things that you hope to to two pieces of feedback that you hope to get alongside each other i think i hope after some discussion this week we've we've settled on the c plus well standard probably guarantees this should work but this is one of the things that we'll probably be filing a defect report that we need to clarify something in the standard on so anyway what's the trick itself if you the original trick that i posted here was if you want some block of code to execute exactly once in the lifetime of your program even the in the presence of threads you can put it in an immediately evaluated lambda with a potentially unused static local variable so i think a lot of people know this trick in the case where their static local variable has some initializer that's non-trivial but i think people often forget that like your static local variable can have a value that you don't care about if you're if the block of code you need to execute is doesn't return a value it returns void right this feels like it it shouldn't work but you can just make up a value and return it and that's what i do here so like if i if i had just wanted to static initialize i know this expression technically returns a value but most people don't think of that as returning a value so this is just like arbitrary code you wanted to evaluate you could you can stick that inside of this lambda right here that we're evaluating immediately i think that probably have highlights on this yeah so you can stick this block of code inside of this lambda that we're evaluating immediately that's what this open close parenthesis does right because it's a lambda that takes no arguments i can leave out the parentheses here and i can just immediately call it with no arguments right and this will get executed when this static variable is initialized now let's take a look at oh and here i'm running this to just show that it works with a very large number of threads in this case two because that was the number of threads that got bolt supported at the time and yeah so let's take a look at the the code generated by this and and see what's really going on here so i have this i've simplified my example even further just to make the the output so this is the in compiler explorer it's an excellent tool if you're not aware of it oh okay there's a q a yes funethon has a fantastic funethin.net has a fantastic resource on fold expressions thanks for pulling that up that's absolutely something that i should have mentioned in the talk i'll have to add it into a future version that's one of my favorite one of my favorite meta programming blog posts out there jonathan miller is an excellent blogger on sequels plus you should definitely read some of his posts okay so going back to this so running this through compile exp compiler explorer you can get the x86 output and we've we've made this a little bit simpler even still because like if i were to actually print out here there'd be a few more instructions generated that would make things a lot more complicated to read and i wanted this all to fit on the slide i feel like a fairer percentage of people can recognize plus equals one in a in an x86 code snippet it's right here spoiler alert and that that way we can like kind of get some idea of what the compiler is adding around this exclusive execution segment to make this conform to the requirements of the sequels plus standard so i've actually gotten feedback from a number of people in this and in a subsequent example that basically said well bar needs to be atomic this this absolutely needs to be atomic i don't understand what in the simplest standard would imply that bar you know has atomic behavior and and doesn't need to be atomic and hopefully we'll understand this by the end here there's there is one caveat to that that makes this a lot more complicated but yeah so let's walk through this so what is the compiler doing here this seems like it should be doing less than this and it's it's actually not it it has to load this guard variable guard variable for foo colon colon unused and then checks to see if it's non-zero checks to see if it's zero sorry if it is then it needs to try and run the actual initialization so it calls cxa guard acquire with the guard variable if the acquire was successful it jumps to label l14 and otherwise it just returns so let's look at the code inside of the the guard acquire here and there's our actual bar plus equals one right and then we are calling guard release with the guard variable right which also [music] you know guarantees this exclusive execution behavior there's some other lines here that are just manipulating the stack pointer which have to do with abi but that's that's basically what's going on here we have the compilers inserted essentially a mutex right or a single they call once flag something in between a mutex i call one's flag here right around this snippet of code that does the initialization of unused right even though the initialization even though bar is completely unrelated to the initialization of unused the standard isn't really opinionated on that right you said this is the code to initialize the boolean variable unused and the compiler just has to trust you on that and so that's that's what we're exploiting here in order to get this code to run exactly once wow i've already used 30 minutes all right this is hopefully this means that i'm you're getting a little bit more of a detailed view a little bit more of a slowed down view of this talk than i was able to give at cbp con let's talk about why this is happening so basically statement.4 which is actually i need to correct this this is actually statement.3 i got the wrong number in there but basically says dynamic initialization of a blocked variable with static storage duration or thread storage duration so blocks block variable is the c plus standard ease for local variable in this particular context ooh we can jump back and answer that question i don't understand the absolute jump i didn't either for a second this is just a tail call optimization peter so i didn't recognize that either if you actually run this through godbolt with clang instead of oh yeah here's the the clang version actually in this screenshot i this is the gcc version in this because i thought it was fit better into the slide but if you look at the the clang version here you actually see that it's annotated as tail call so hopefully that helps you understand that absolute jump there yeah no problem i was confused by that for a second too so i definitely had to go back and look at it all right so yeah dynamic in this initialization of a block variable the static storage duration is performed the first time control passes through its declaration well the interesting thing about this statement is that it doesn't say anything about happens before which is the the which is the language that we use to describe concurrency now so it says if a concurrent if control enters the declaration concurrently the concurrent execution shall wait for the completion of the initialization so that is an interesting statement in that it doesn't use very modern language about concurrency in the standard and you're going to see that that has caused quite a bit of confusion and i'm interested to see how it's resolved i can't imagine it's going to be resolved without changing this wording a little bit i also haven't gone and checked but i suspect that means that this wording is 3 c plus 11 wording we didn't have better way of saying happens before but the other interesting thing in this this snippet when i when i looked this up to make this slide was oh if initialization exits by throwing an exception the initialization is not complete so it'll be tried again the next time this gives me a really bad idea so i went to twitter and posted another bonus cute trick of the day we basically are using the same thing right this is the code from last time right this is our essentially the same code from last time we have this unused variable we have something executing and we're returning true but we're going to add something in here and that is we're going to catch a particular type of exception and we're going to initialize account variable to zero and every time we reach this spot in the code we're going to increment that count variable and if we're less than the times that we want to run we're going to throw this exception so we didn't finish the static initializer right that means that going back to our to this slide says you know exits by the ring inception will be tried again the next time right so we we're just making sure that the static initialization doesn't complete non-exceptionally and then if if we have done the right number of times we just return true and and the static initialization is complete and the next time it's reached things are okay so we can also use this principle to like build our own mutex which spoiler alert you should probably just use a mutex instead yes you can use this to build a thread safe singleton which is also an interesting application of this and that's kind of fun to play around with i'm not sure whether that's a good idea or not i mean some of these some of these tricks are borderline like not too cute i mean i think your definition of too cute has to depend on who's reading your code right and if someone if it's it's gonna be a trick that someone hasn't seen before then it's probably too cute because code is always written to be read right whether that person is you in several months or in most professional environments it's written to be read by dozens of people over the lifetime of the code base so i'm not gonna go to this is i think pretty unsurprising that if you were to just not increment the count and just always exit be an exception this would run exclusively i do want to get into this fun tweet that i got from dave abrams after looking at my talk where he says sadly i think this one has a data race and i was like oh that would be sad so i did quite a bit of code archaeology on this i went through long twitter discussions with a number of people who are experts and who wrote some of this code for the compilers and looks like this might be a bug in tsan this is the code snippet more or less that dave abrams sent me where he basically compiled with f sanitized equals thread up here in this i know you can't see it very well because it's small but it's just the f sanitized equals thread flag this works on both gcc and on clang and and tsan says oh there's a data race here read of size 4 on thread 6 at line 11 oh that's incrementing of the count and then that was used to say oh you know count should have been atomic here for this to work correctly but remember what we just learned right this block of code is guaranteed to execute exclusively this this code was is guaranteed to execute exclusively by the compiler right and so we shouldn't need to do anything atomic here right well there's some question there right because remember the the standard doesn't say anything about happens before so the compiler isn't necessarily required to establish happens before relationships between blocks of code executing this way it's just required to make them execute exclusively problem is that with my somewhat limited but i would think generally a little bit extensive knowledge of of how atomics work and how memory ordering works i can't think of a way where you could create exclusive execution without accidentally establishing a happens before relationship with the way that c plus plus exists today there are some proposals that have been made that would allow for asynchronous fencing or for location specific address-specific fencing that apply to certain architectures but haven't really been built out in c plus plus so i suspected this was a a bug and i took a deeper dive on the tsan implementation of these things so when t-san when when the compiler generates this exclusive snippet it goes if it exits via an exception it calls cxa guard abort which basically releases the guard without incrementing it and if it exits via normal value it calls cxagard release it's not specified to do this by the way this is just practically speaking how most implementations do this on top of linux and tsan shims these methods but surprisingly it's it's shimming them differently and i don't know why that is but in guard release it's actually shimming this as an atomic exchange with memory order release right here on line four whereas in guard abort it's shimming it with this memory order relaxed right and so it's it's actually there's also another bug here where it's it's waking up a few texts in the release case and it actually is just completely forgetting to do that in the abort case so that's very definitely looking g stand that needs to be fixed so if anyone wants to be you know have make an actual contrib contribution to tsan that's a fun little weekend project for you but let's look at what lib cxx actually does the underlying implementation when we're not running with the thread sanitizer we actually see that the release and abort code both do an exchange that has acquired release semantics technically speaking that could be relaxed release could just be released but it's even doing stronger than that i don't know that there would be any difference on any architecture that i can think of somebody can come up with an example that would be interesting but in terms of actual consequences in memory ordering i think this is pretty similar anyway the point is that the underlying actual implementation that you're going to be running on is in fact doing the right thing and doing a memory order release it's just that t stands wrapper to it is not attributing memory order release to cxa card abort and i think this is i think this is probably because the standard is the standard is underspecified in this area i talked to olivier about this briefly last night we went back and forth several times there was some confusion and eventually we came to the conclusion that oh yeah this looks like something has gone wrong here paper welcome so yeah if that's something that someone wants to write a paper on reach out to me reach out to someone else reach out to olivier we know exactly what the paper needs to say more or less it just has needs to be written so what should you do in real code wow i'm at 42 minutes already okay i'm just gonna i'm gonna keep going until i get through the same set of tricks that i went through in at cbp con if that's okay with people and if people get tired of that or if i get kicked off of this then i'll stop but i think this is interesting i'm really enjoying getting to go through these things a little bit less break next big speed than i had to go through them at cppcon to fit into the hour so i hope you all are enjoying this too so in real code we have something called stood call once that does a call once and you're going to see here in a second why some people think that the original trick that i showed is not necessarily too cute and it's because sit call once is a little bit heavier weight than you would think it actually does a call out to p thread once but it has the same semantics as the original code snippet and so if you really are in performance sensitive code and you really do care about the cost of running this thing that runs once in the entirety of your program you can consider using that trick honestly i would suspect that in most cases readability trumps performance and the performance difference is not substantial here but i would suspect that readability trump's performance and pretty much every common use of this this call once pattern so using stitch once instead once flag is is generally the recommended practice here but don't be too surprised if you see the original trick in real code all of the rest of this there are much better ways to do this in real code exiting via an exception in order to create a mutex effectively is is a terrible idea you should actually just use a mutex to effectively create a mutex because yeah use the the thing that's named what you mean not the thing that does what you mean and so here we've used the mutex we've used this did scope clock if you're in precipice 17 you can use this to block guard here but either will work and then we're calling the function and then the lock gets released when we exit the scope either by exception or by either by exception or by value and yeah this works exactly the same way not too surprising finally if you really need to execute something the first end times in real code you should probably rethink your life decisions but if you have finished rethinking your life decisions and you still need exactly that semantic you can do this with an atomic and a mutex together oh yeah i apologize to everyone who's still awake it is eight o'clock i started at eight o'clock in in in germany right so i will try and get in the rest of this talk without going over by more than 15 minutes or so so hopefully that doesn't make a big difference in your in your sleep time but if it does i apologize and i'm happy to talk through the slides are available i'm happy to talk through them on twitter i love talking about this stuff this kind of you know c plus plus education via playground is i think my new favorite way of communicating so i'm happy to communicate on twitter about all of these things anyway i'm gonna jump to trick number five because that's another one that kind of sits on its own tricks three and four kind of go together and and tricks three and four also if you end up having to drop off you know you're missing kind of one whole chunk of things that'll probably end up in some form and some other talk at some point so that might be a little bit better to skip to trick number five here i think this one's not actually too cute but that also depends on what your readers think and if your readers don't recognize deduction guides if your readers don't recognize class template argument deduction ctad then maybe this is too cute and you should just write up the whole thing but yeah so c plus plus 17 deduction guys make class template argument deduction easier than ever and to especially to do this rule of zero with aggregates so let's look at what's going on here we basically have this class template that's actually very generic right it's like this is like exactly stood pear with you know a few things missing right but like more or less a lot of you know there's a little bit of the infrastructure around it missing but right this is like an aggregate version of sid pair it's incredibly generic we can do a lot with it and that's all of the code it took to write it right and and we had to add this this this one little thing called the deduction guide i don't know how many of you work with those or have seen those in your daily life they were added in sql 17 to allow us to do class template argument deduction more efficiently right to deduce these t's and use more efficiently and help the compiler figure out how to do it right and so there are some some of these that get generated automatically particularly if you have a certain type of compile a certain type of constructor right if you have a constructor that takes a t and a u and your class template arguments are t and u then the compiler will automatically generate this deduction guide for you essentially and so anyway you can you can see how this gets used down here with this all we have to do is open and close curly braces we're not having to do any angle brackets here which will make certainly some people happy and these are all just deducing the type directly from this deduction guide so an innocent question wouldn't it be nice if we could just omit this deduction guide and so those of you who saw the cpp contact will know the joke here but who thinks we should add this to the standard i didn't i almost set up a poll for this ahead of time but i think that it's probably faster to just go go through this as it is because the joke is that well who thinks we should add you to the standard who thinks i'm adding leading asking leading questions about something that's already in the standard and turns out that this is actually already in the standard thanks to teamer doobler teamer i actually don't know temer's last name because no one else is named teamer but starts with the d i think um yeah somebody can tag his twitter in chat he was just sitting in the room at the talk so i could be like hey thanks teamer but timo wrote a paper that does this and means that for aggregates you that directly correspond between the the aggregate arguments to constructing the aggregate and the template parameters you don't need this deduction guide it automatically gets generated by the compiler and this does in fact work and this works fine as long as you have this this feature macro defined and it's it's higher than that if the compiler defines this feature macro and higher than that and so a full implementation of seepless plus 20 does actually have to implement this clang doesn't do that yet which is why i put this on the slide latest version of clang still hasn't implemented this yet so keep that in mind if you need to support clang or if you need to support pre-sequel plus 20 code then you don't actually get to do this team or audio thank you i knew something involving audio teamwork is great and there's a lot of things on his plate with respect to the committee so if you want to collaborate with him on a paper and do most of the work and then get his help with the final bits i'm sure he would really enjoy it it's a really nice guy so the original trick that i posted was this one where i basically did something a little bit more complicated than just directly deducing the template parameters from aggregate from the automatic deduction guide created by the aggregate and in this case instead i'm introducing the u here in the initializer list and saying that that u gets mapped to the u in foo which we then are mapping to the argument of stood vector inside here right so there's there's actually a fairly complicated thing going on but notice that the definition of our class has not gotten any more complicated really right so there's there's a lot of powerful things you can do with this trick so here's an interesting question and now we're gonna get towards the second or rather sequentially the first but the second in the talk a defect report would probably be filed against the standard as a result of preparing this talk what about designated initializers in sql suppose 20 we finally added designated initializers for aggregates to c plus plus given that c has had them since 1998 it's kind of surprising how long it took us to do that but i think it's good that we waited this long because we we took our time to really find out what it means for something to be an aggregate in c plus plus and apply the syntax directly that way there's also some things involving side effects that we needed to do in a very c plus plussy way that c doesn't do so we don't allow you for instance to put the put the designators out of order they have to be in the same order as they are in the class and that's because we don't want to confuse anybody with the side effects of the constructors happening in a different order than they're written in the code so in this case yeah one would expect that this should work and in gcc it does fails to compile and clang but clang doesn't set the deduction guides greater than 2019 seven so it's okay right oops no it turns out that we underspecified this in the standard and the standard does specify that designated initializers with ctad but without deduction guides should work fine this is in some of the wording that team are added is equals plus 20. there are it specifically states that if there are no deduction guides then the entries in the braced initializer list can be an initializer list or designated initializer list and dot dot it basically goes on to say c happens but basically if you look through that section it's over.match.class.deduct so you can see that this is part of overload handling right and even from the stable tag without reading the context in the standard and basically the ctab mechanism performs initialization and overload resolution on the set of deduction guides right both the implicitly generated ones both the implicitly generated ones and the ones written into the code and decides like which one is going to be used to determine the class template arguments and but the standard doesn't say what happens with overload resolution when there's designated initializers around and there's a really good reason for this because overload resolution is really really hard and we don't have any other instances where we would use designated initializers as arguments for overload resolution only in this particular case when we're constructing an aggregate so we forgot to say something in the standard and hopefully this will be clarified pretty soon should this work once we have once we clarify this probably not but that's ongoing work as of last week i think it's still ongoing and will probably be in the next standard so let's go i'm gonna jump into tricks three and four really quickly i think i have more or less if i'm gonna stay within my self-allocated time limit of 15 minutes over i have about 20 minutes and then we can have some excellent discussion out in the lobby about this anything remotely tangential to initialize your list is just a dumpster fire that is absolutely true this in particular is relating more to aggregates and to ctad an initializer list there just happens to be a stand-in for something that i was deducing directly and then propagating into tad the deduction guide but yes i totally agree initializer lists are a dumpster fire i agree that aggregate initialization is is much less of a dumpster fire since teamer started working on it in 2020 but still has force equals 20. he started working on it long before then in order for it to make seepless 20 but more or less yeah there's there's several dumpster fires going on here and i wish we could go back and fix them but we can't so let's talk about parameter packs for a second parameter packs we talked about a little bit earlier in the the fold example and eric niebler says that if we're doing any kind of kind of meta programming parameter parameter packs are the compile time data structure of choice as of c plus plus eleven c plus plus has language support for lists of types we would be foolish to use anything else and that's referring more or less to pre-c plus plus 11 meta programming which involved recursively instantiating templates in order to create lists of types for meta programming purposes sort of in a lisp style card cutter type approach now that we have a standard language feature for compile-time lists basically we'd be foolish to use anything else and i agree with with i agree with eric on that so let's talk about how we enumerate a parameter pack i have a comment here that indexing over enumerating or indexing into parameter packs are perhaps the tasks with the greatest discrepancy between how difficult they should be and how difficult they actually are sleepless 20 makes this substantially easier and i'm going to show you how here so this is probably the most important this this piece here this next piece here is what the rest of part of what the rest of the talk hinges on so i'm going to go through it very carefully and try to explain it a couple of times so if we often find ourselves in this situation where we have you know a single name args right that is representing multiple things right hello 42 world and 43 and they all have different types right in this case we're using the we're using c plus 20 uh terse concepts notation here right so this is actually a template even though we didn't use the keyword template it's just that these are unconstrained template parameters unconstrained anonymous template parameters right we don't have a name for the actual type we don't have a symbol that represents this pack the type of this pack in this context only the values we can get it through decal type if we want to but it turns out since we didn't need the type a symbol to represent the type in this pack i went ahead and used this terse syntax so that you'd learn something new hopefully from that and so we're in this example we're trying to call we're trying to write a function enumerate pack that takes a function takes a callback and a variatic set of arguments right and we're trying to call that function once with each argument in that pack right along with the index into that pack right so we should get a call of this with 0 and hello 1 and 42 2 in world right we're trying to do that generically here's how we do it this used to be a lot lot more complicated and now that we have this feature in sql s20 that allows us to explicitly name template parameters of lambdas this is a lot a lot more terse and it's this this is the key here right we basically need some way to create a parameter pack i'm going to try and say this twice does auto.pass arcs by value yes for production you would want to sit forward this stuff it's a little more complicated than that too because this be careful about this because this this ampersand capture messes with your your stood forwarding so perfect forwarding through a reference capture by reference is actually harder than you think it is and there's some surprising edge cases because you end up accidentally forwarding out of the data member of the lambda itself i intentionally left that off of this slide because it just makes a lot of noise for production you should yes definitely spend a few days rethinking your life decisions and if you still are set on needing to do this in production then yes you should stood forward and hide it away in code that no one ever has to read and don't get me wrong i'm not criticizing i've written this in production code like 10 times so i've you know had to use this before for sure with with perfect forwarding but yeah i left out perfect forwarding in all of these examples actually for simplicity so here we need to have a way to have a symbol that represents the indices of the pack in one symbol right we have something that represents the values in the pack of one as one symbol we need a way to represent the indices in the pack as one symbol and then the idea is that we should be able to expand both of those packs at the same time over a fold on the comma operator right remember we talked about folding over the comma operator earlier and how that evaluates left to right which is exactly what we want to do here right so it turns out if you have two packs two or more packs of the same length you can always expand them together over dot dot just in the same way that you would expand a single pack right and so we're going to use that to our advantage here and so what we need to do is we need to use this stood make index sequence right which makes an index sequence object it's technically an integer sequence object and index sequence is a type alias template for it but it works the same way index we're gonna it's going to make this index sequence object right here that has the parameter pack 0 1 2 dot up to size of arcs right so make index sequences specified as a helper template that basically does exactly what we asked for but we still need a way to associate a named symbol with that pack and to do that we need to deduce a template parameter from this from this function from this the parameters to this function right before c equals 20 we couldn't do that because we couldn't give explicit names to these things but now we can give a name to this parameter pack of indices that comes in as part of student and next six when we call this right so dangling in front of your eyes makes the code so obvious oh well i'm glad that this has helped with that honestly i hope that this makes this more obvious this to me was saves an enormous amount of jumping around code you used to have to put this in a separate function template and that caused a lot of jumping around in code that made template meta code like this very difficult to read i wouldn't even call this template code this is just like code that's generic over number of arguments right any code that's generic over the number of arguments it's just being generic it's not meta programming in my book but i have a pretty loose definition of template meta programming you know for my own purposes at least so anyway the point here is that we've we've generated a parameter pack we've generated a name for it right and we have those two names in the same scope and once we have two names in the same scope we can always expand over a a full expression or do anything else that we can do with the pack we can do with with two packs or in any number of packs right and so that's what we're doing here and that actually causes us to call the function with the indices and the arguments in a way that is bordering on readable if you see this but it's it's these two lines that you're going to see over and over again throughout the rest of the talk and i'm running up against my limit but i think i might still make it so you can do the same thing use the same trick to index into a parameter pack this is not the recommended way of indexing into the parameter pack if you want to read lui if you want to read way way way more detail on this and so one of my favorite blog posts on simples plus mana programming of all time louisiana has this fantastic post on the various ways of indexing into parameter packs and does some very solid benchmarking of what you should really do in production code and how fast it should be and yeah so that's that's this here but one thing we can do is if we're going through this same thing as before only this time we have a the user giving us a template parameter of the exact s spot that they want us to invoke the function with right instead of just calling the function with all the arguments we can just create a function here that says if i dx says equals equals i right then call f of args right and then we're just expanding that immediately evaluated lambda over the comma operator just like before [applause] and with some tweaks actually we can even reuse this function before we have to do something special that involves passing idxs as a explicit template argument rather than as a value argument because my contextual works in c plus but it's more or less the same concept right you can see how we got from that last slide to this slide i'm just using if constant spur and so once you have this once you have this kind of pair of lines and you know how this pair of lines works this the world is your oyster you the world is your oyster the world is your oyster and you can kind of you can do a lot of things a lot of a lot of meta programming and generic programming over count of arguments boils down to something like this we're going to see this in the next trick really quickly which i have five minutes for but this one is just so freaking cute that i couldn't leave it leave it out this comes courtesy of richard smith which if you don't know richard smith one of the the nicest people you'll ever meet and certainly like the highest niceness times c plus plus knowledge ratio of anyone you'll ever meet and that would probably be true regardless of how nice he is but he's just off the charts on that latter category i guess but he sent me back a trick a response to one of my other tricks and and included essentially this in it without even thinking of it as like anything special so we're in the same situation as we were before right where we have this dot dot dot we have this one symbol named args that represents a whole bunch of other things and we need some way to get at the last argument surprisingly that's difficult right getting at the first argument is really easy you can just give an explicit parameter and then a dot dot dot and that that will deduce the rest of it but you can't give a dot that thought and then an explicit parameter in d plus plus because because well i don't actually know i asked a bunch of people who were around when that decision was made the best answer i got was that there's some simplifications were made when we were doing seepless plus 11 because we weren't sure how hard it was going to be for compilers to do this but anyway we have basically our same little two lines here that we have from before except for this time we've done args minus one right so now we have two different packs that have different links and i'm gonna say show you something that's really interesting that you can do when you have packs of different lengths and still end up with an interesting result so here we have a c plus plus 20 concept right and it's kind of this non kind of this trivial concept where remember any simplest plus 20 concepts take the type that they're matching against as the first template parameter and then any other explicit parameters come after that right so this concept any just takes a a number and ignores it and returns true for any type right so we have any idxs auto dot dot and by the way if you want to see the perfect forwarding version of this richard has a tweet where he does it kind of trivially trivially off the top of his head without even having to think about it which involves a nasty nasty expression written inside of here and some other stuff i usually when i come across this and absolutely have to do perfect forwarding i'll be honest i just don't capture anything in either place and i just pass the parameter pack through forward through each level because i'm not smart enough to figure out how to perfect forward out of reference capture so that's a trick if you're interested in perfect forwarding here and i have three minutes so i'm going to try and go through how this works so remember we've been passed a pack with one less index right and we can actually once we have a name for a pack anywhere we can kind of use it in pretty much any place where we could use any other identifier right and one of those places is in defining constraints on a a parameter to a function right so if we have a lambda inside of the scope where we have this parameter pack we can use it to define the set of parameters so we know from from here that we're going to have size of args minus 1 different entries in idxs right so because this is not no longer a deduced parameter this is an explicit parameter right we are expanding out over this rather than deducing this pack and we happen to use dot dot in both cases actually if you ever read richard's code he's probably one of the only people who fully understands his distinction but he will when he is deducing versus expanding he will use a dot that is left aligned to the type name for expanding and right aligned to the parameter for deducing because those situations are actually distinct and we just happen to use the same syntax i think it's very funny i i've never done it myself and i'm honestly not always clear on what's going on even after years of doing this but what we're expanding here explicitly is idxs right we're saying there are n minus one parameters here so this is no longer a pattern and then the last parameter should be named last right and then we can just call the function and we have the world's funniest hello world program here so i thought that was really cute and really interesting use of of concepts and parameter packs yes you can use this to get any entry in a parameter pack just by going minus in here and then deducing a parameter pack at the end here i just wanted to keep this example simple why can't we have nice things while we're working on nicer things that's the gold the standard committee but this basically is what i was saying would be the easier way to do this right is we could just deduce the last parameter that doesn't work we hit core engine has a is a fork of clang that does do this and a proposal to add this to c plus and everyone i've asked from the committee is like well i don't see any fundamental reason why this can't be in the standard it's just that we wanted a single pass left to right version of this the first time through so that's all i've got for this talk let's go back to i don't even have a i don't even have a title page do i have i don't have a questions page but i have a title page i think i'm supposed to go you can say more but i think i'm supposed to go to a room for discussion afterwards is that right or questions directly so first if you have any questions to daisy right now maybe post them to the chat that we can see them always so thank you for your talk daisy that was awesome i enjoyed it very much and i think the audience also had a lot of fun i see the chat i kind of made sure that the room starts a little bit lighter so that opens during your talk i think like from like 20 on i can open the room and then people can go there and just talk and nerd out with everything you know with the slides and i think i'm gonna then end the recording now and awesome yay thank you for your talk thank you i appreciate it