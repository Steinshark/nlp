honestly the reality is i forget solid principles all the time what they all mean so let's look at the solid principles and then i'm going to explain why i'm triggered and i'm going to die on the inside okay here we go the solid principles are the five principles of object-oriented class design okay so i feel like i've already reached all the information i need to know okay because we all know that i don't do objectoriented or functional programming i do functional programming and object-oriented at the same time f poop everybody's favorite new it's honestly when it first came out it was so hot it's kind of cooled off a little bit since it came out not going to lie to you it's cooled off a little bit not nearly as steamy as it once was but we're working on it okay let's see these five principles help us understand the need for certain design patterns in software architecture and general so i believe that it is a topic that every developer should learn this article will teach you everything you need to know how let's see to know to apply solid principles to your projects we will start by taking a look into the history of this term good that's what i need then we are going to get into the nitty-gritty details and that's why or oh okay so this is why i have something called this i just makeup words i have makeup word itis the wise in the house of each principle by creating a class design and improving it step by step so grab a cup of coffee or tea and let's jump in the background the solid principles were first introduced by the famous computer scientist robert j martin aka uncle bob in his paper 2000 but the solid acronym was introduced later by michael feathers what a what a lovely name the name is michael feathers you wouldn't understand how silk my silk blouses are anyways uncle bob is also the author of best-selling books clean code and cleaned architecture and one of the participants in the agile alliance feather the name's feather michael feathers therefore it is not surprise it is not a surprise that all these concepts of clean coat object-oriented architecture and design patterns are somehow connected and complimentary to each other they all serve the same purpose to cre are to create understandable readable and testable code that many developers can collaboratively work on that's a good principle i mean honestly like this is a good north star i do agree like this is the north star you should have we should all have that right base paint dev thank you for that let's look at each of the each principle one by one following the solid acronym single responsibility principle the open close principle the lov substitution principle the interface segregation principle the dep dependency inversion principle solid i'm glad they didn't choose ar c because they could have chose ary right i mean it's right there it's right there right in the name all right anyways the single responsibility principle states that clashes should do one thing and therefore should have only one single reason to change or all ttts oh yeah it could just be a bunch of t's we could have had the 5t t5 t5 stack anybody who wants the t5 stack all right to state this principle more technically only one potential change database logic logic or logging logic and so on in the software specification should be able to affect the specification of the class this means that if a class is a data container like a book class or a student class and it has some feels regarding that entity it should only change if we change the data model i also assume this means like some of the logic around the data model like you can imagine you could imagine the following the single responsibility principle is important first of all because many different teams can work on the same project and edit the same class for different reasons this could lead to in incompatible modules so i always have kind of like i generally have like a kind of a problem if you will with this so let me just let me just open up this this this hot this hot mess that i have of a codebase so you'll notice this little guy right here now you're probably thinking that can't be that hard to do that right well actually to create this little square and to do this it takes a lot of it takes aot lot of effort to make this coloring work okay it actually took it it took an unusual amount of effort i must say not simple right but to make it done we broke it up into a couple different kind of if you will modules classes however you want to call them they're actually they are actually tables in lua so i have something that opens windows that creates a new display cache and new color set so in some sense i did kind of create the single principal kind of idea that this thing just does the displaying this thing just does the color setting right and so you kind of have to apply them one at a time right because if you if you try to update the display cach it actually wipes out the extended marks and therefore you actually de you actually like decolor that spot and so it makes sense this is a good way to do things you could have easily done this with rxjs yes absolutely window opening and creation is like its own set of just things right it's just a bunch of code around creating and opening and listing and attaching and closing windows and all that kind of fun stuff okay apparently i don't even have this as a i'm not even using this function oops but you get the idea right you get the idea and so it's like do i disagree with sol like single responsibility not really i'm just way more willing to be a little bit loosey goosey do you know what i mean so when i go back to app it opens up windows it closes windows it also takes in commands from the tcp pipe and determines what to do should we render should we partial render should we close should we open up a window and then alerts everybody else of commands we also alert people of renders after we get done on rendering or partial rendering so it's kind of like one of these things where i would argue that this isn't following the single principal logic right it's not very yeah it's not very solid because it's actually really doing two things right it's not only listening and processing commands from the tcp it also is interacting with the ui now we could make this we could pull that out we could do all that it just takes a lot more effort to do that so instead what i thought was a little bit nicer i i just simply oh my goodness i forgot i i i i i removed all my stuff i just created a quick little fake tcp thing that i could hand in that i could read a bunch of data from a file and then just pipe in what's in that file into a tcp thing and call that a day right for me that was nicer to test it just is it just is right and i could make it so that any single any single one of my outputs could be then piped into a file and i can just replay the experience from the server over and over again better experience i just don't think i don't think you always have to follow this principle i think there's sometimes that it makes a lot of sense and again i break it all the time i i literally break this all the time for the purpose of just making something easy very simple thing this display cache only does stuff about cash right it doesn't do anything until i do this right render into i actually now this is where i break the idea of single responsibility and now actually instead of just being the cash i'll actually have the cash do the most optimized render into the window like into vim this is totally breaking single responsibility here i'm okay with that like i'm actually i'm actually super happy about that it just it it is it makes life a thousand times easier to do this well yeah right so i'm happy sorry i had to remove those to those are from some debugging yesterday anyways so there you go that's kind of like my thoughts on these things which is again this is why i don't adhere to the the solid principle because i often find that in real good programming you have two choices choice number one solid is for programming you don't need it for scripting oh okay okay okay so so like so like g game engines are definitely i i get that yeah yeah yeah i mean i'm kind of script kiding this one out you know what i mean you're right the man's right today i learned scripting isn't programming today i learned making a cash rendering interface on the front of a real-time asky engine is just scripting i didn't know that i i mean i i honestly i had i had no idea personally but i mean i get it i kind of am i think i i think i fall more under the jackass category than even the script kitty category okay just mostly an anyway so this is my big problem with single responsibility is that you have two kind of trade-offs you get to make when you do this one you abstract and abstract and abstract and invert control really dependency inversion is kind of like this really falls into single responsibility principle you either have to like invert your dependencies or b you break some of these so that you can have locality of behavior and so i choose locality of behavior often more than i choose really nice programming and so this is a very good example right this my cash being going from a cash item into a rendering item just brought this locality of behavior really really close so i can do i can understand ex exactly what it does without like a ton of thought without a ton of hopping around and so i really really really really like that idea and sometimes i just feel like you have to do that same with the appen it this thing that's processing tcp commands probably don't need that but it's just it it creates such a tight locality of behavior that it just makes it really simple to kind of work with and so i think that you got to learn how to break that principle to get things done and the other the other side of it is that you just have to abstract right you either have to choose abstraction or potential or or you're going to have to do you have to choose either abstraction or locality behavior and sometimes locality behavior makes things harder to test they make them more brittle so you kind of have to know when to abstract when not to abstract and so it's kind of a fun it's it's it there that's why i hate giving like direct or required principles because anytime you do something like that you by necessity make things harder for people it's almost like you should tell people hey go out there and just build it and they will go out there and they'll do locality of behavior and they'll do abstraction and they'll go on both sides and they'll just have this really difficult time because the first time you build something you build just horseshit like you just build bad programming and that's okay that's like that's that's step one to becoming a good programmer is building bad programs so then what's the next thing you got to do you build it another one and another one and another one and you do that for like 10 years and you'll then slowly start developing kind of like a an intuition into when you're supposed to break things miami killed your voice yeah for those that don't know i was in react miami and i had to do like a live stream and talk to like lots of people and then then there was like parties and they kept making the music loud and i really i i hate loud music for that exact reason and so i lost my voice and i'm just it's starting to come back anyways so so single single responsibility principle i don't necessarily shoot for it it's not that i don't think it's bad i just don't i don't make it a requirement because if i do that i'm going to be i'm going to be by necessity abstracting my code further and further and further right because i would have like the best i'd say the best one would be this render in two i would need some way to emit out a new data class that represents a set of changes that need to be done and then i have to have something that takes those set of changes and applies it to the window right i'd have to like just add a little little bit more just add a little bit more logic but that's just one more place in which it's going to break one more place to be wrong one more place i'm going to need the test anyways common pitfalls and anti patterns in this section we'll look at some common mistakes that violate the single pr responsibility principle and we'll talk about some ways to fix them we'll look at code for a simple bookstore invoice program as an example okay we have string name blah blah blah so we have like we have a a little data class right we just have an object and now let's look at this is kind of a for me these are always a really i mean this is very java esque though writing of code right you can't just write an object you can't write an object you have to like write that kind of object this is a simple book class with some fields nothing fancy i'm not making fields private so you don't need to deal with getters and setters it' be crazy to do that now let's let's create the invoice class which will contain the logic for creating an invoice and calculating the total price all right we do in here we have a private book an invoice that's kind of wild that you have an invoice for a single book i'm just throwing that out there you know invoices sometimes have more than one thing on them we have book quantity oh it's just book in a quantity crazy what happen if you have more than one book anyways you have this discount rate taxes okay calculate total calculate total does all this stuff okay print invoice fantastic save to file let's go now this is what they're going to definitely be upset about this one is my guess here's some let's see here let's see is our invoice class it contains some fields about three methods calculate total print invoice save file you should give yourself a second to think about what is wrong with this class design before reading the next paragraph i actually think there's nothing wrong with this i mean this is probably not i'm not sure if this is how i would design it but this is good enough to me besides for the fact that you can only order one book and multiples of that one book little wild but besides for that i don't care about the rest of this indentation little poor yeah i'd argue that you probably you should get better indentation right let's see the first violation is the print invoice method which contains our printing logic remember how i talked about the whole remember render into you know what i mean which contains our printing logic the single responsibility states that our class should only have one single respon reason to change and that reason should be change in the invoice calculation for our class so this is where i just fundamentally disagree i don't think you need to do more than that i think it's just fine to have these kind of things on here like i i don't think you're buying or losing anything it just depends on the size and the complexity of what you're doing right like at some point you may not want that right and the problem is you can't you you lose this in these smaller examples but if this was producing html i'd probably want it produced elsewhere right i'd want it inside like a template because i'd want something in which i can kind of control from the outside absolutely but if i'm just making a two app would i change it up to have it printed right here very potential right very very potential right presumably you'd want to inject system out as an input like do see again but that's assuming that you want to that see this is the problem with one of the problems i have generally with with solid is that you should test everything right i have a general rule of thumb which is i test things i don't think i can get right on first try or are easily screwed up by somebody that doesn't have the like the understanding of it should you test calculate total that seems like a good place to be very easy simple love the new voice shut up very simple right i just wanted to be thor so i just figured i'd go out and hurt my voice very very simple to get this one wrong very simple for someone to come along and get it wrong anyways so okay we fix all these things because now what they want is invoice printer right you have to create a printer to invoice print which again may not be the worst idea because if you do this if you do if you do do this you can you can you know you can pass things around it can be useful depending on the depth of your program and so you kind of have to like determine how much do you wish to have now this now see i told you they pull out sa file to now this on the other hand now you're starting to get to the point where maybe maybe not not not sure right maybe you should have maybe you can make this completely different right maybe you want to save this as jesson and so you just want a jesson encoder i already hate it already the problem is is that anytime you want to see where something has changed you have to hop all over the place and that's like my big contention which is locality of behavior so for me to understand how this thing works i can almost understand how the whole thing works within a single screen right we can understand every part of what's going to happen in the interactions this on the other hand i have to go find this i have to go jump to it i have to go like because it's not going to be contained within the invoice it's going to be contained somewhere else i have to be able to look at this one and go find the exact same thing like i have to go look at it but isn't that limited to smallest systems that's if you have a it's not limited to the size of the system see that's the problem is that's one of those classic like oopsy daisies people make this is not a system level thing it's a variety level problem now if i have to print tu aoui print in vim and print to a file and print to just standard out with no tuy can we all agree that maybe we're going to want an abstraction on the print level yeah we would we would want we we would want an abstraction given to the print uh on that level if i need to create also html for an htm x endpoint yeah we're going to probably want some var differences between them but that's different right that's very very different then you you're going to have to use interfaces you're going to want some way to kind of abstract it out that's just different and that's okay but if you only need to do one kind of printing like why are you planning on more printings like until you can prove to me so i typically i like go's kind of go's argument of this which is you abstract when you realize the abstraction i think that that is the better one so in other words or or or they say it this way you abstract when you discover the abstraction you don't abstract before you start you you abstract when you need it like when it's time why ises that go specifically it's just it's just one of the montras of go right because go is such a simple language it kind of forces you to it kind of forces you to like think in very simple terms and so typically whenever you see people that write a lot of solid they start out with interfaces they start out with these these like these ideas whereas i i would say don't start off with interfaces go pure concrete until you need an interface all right open close principle this one requires that classes should be open for extension close to modification modification means that means changing the code of an existing class and extension means adding new functionality so what u this principle wants to say is we should be able to add new functionality without touching the existing code for the class this is because whatever whenever we modify the existing code we are taking risk of creating potential bugs well i mean adding new features you're also creating risks i'm not i'm not convinced that there's any less or more risk in that statement we should avoid touching the tested and reliable mostly production code if possible i mean but you add new code you you do have the exact same chance for bucks but how are you going to add new functionality without touching the class you may ask it is usually done with the help of interfaces and abstract classes see you reach for abstraction first in this more regression risk probably yeah but then you just have more new bug risk right like you're not changing the equation if i have to add if i have to add you know a chunk of code and this intersects some level of existing code right i'm not convinced that more intersection or less intersection makes this more or likely for bugs right like if i just have to add this if i going to write a bug i'm going to write a bug there's no there's no there's no avoiding that that idea all right let's say our boss comes in and says he wants invoices to be save to databases so we search them easily we think we think okay this is an easy peasy boss yeah again i probably wouldn't even save them to file honestly i wouldn't save these to file just to begin with because i think saving to file is i mean we be the point of doing this right you have to be able to ask yourself why you'd want to do this to me this is like a test harness code you'd want to pull out and you'd only want to be able to like load up a database from file really would you if you're using squeal light you can just have your database as a file and bada bing bada boom you already have a golden we don't call them bugs we call them unexpected features yeah fortnite rocket riding was an unexpected feature let's see so a lazy developer or let's see let's see so as the lazy but clever developer for the bookstore we see a design problem and decide to refactor the code to obey the principle save invoice invoice interface save there you go so you again i'm not actually i don't actually disagree with this idea that you have to go through and you have to make with this like this is fine this is this is literally just the this is so if you for those that are wondering this is literally just the strategy pattern right strategy pattern is pretty much in every single language in every single way and it's very very simple all you do is have an interface with concrete implementations right fantastic right we all use this in in one way or another right there you go bada bing bada boom beautiful beautiful now our persistence logic is it is easily extendable and if our boss asks us to add another database we have two different types of databases like my sill and mongodb we can easily do that true but then now you start getting into this thing right p persistence manager that takes in an invoice persistence and a book persistence and now you start having these like aggregations of super super classes and you have to ask yourself why why are you doing all this what's the purpose right what is the purpose of adding this much classes to do that the purpose is gillette the best a man can get yeah lascav substitution principle the lascav i've read this i always forget what this stands for states that the subclasses should be suitable or sub substitutable for their base classes this means that given that class b is a subass of class a we should be able to pass an object of class b to any method that expects an object of class a and any method that should not give so i i generally just think that inheritance inheritance makes things hard to think about the problem with this is that anytime you have the hammer of inheritance you often have it overused it's extremely difficult to use inheritance well and i typically find that i can't use it well i want to be able to use it well every time i use it i regret using it every time you have the hammer of inheritance you end up getting nailed like i i'm sure there's some really great things for inheritance and i know some people talk about some versions of game programming inheritance is often used and it's really really great i just can never seem to get there can we stop pretending that o is hard can we just stop pretending that o is hard no one's pretending that the base idea of o is hard it's that if you have a large implementation of oo can become quite the most annoying asp thing you've ever worked with because then you start getting into these huge problems with base class and extended classes and then you end up changing both of them to make things continue to work out forcing things work together is just a complete pain in the ass there are better ways to go about a problem and i actually have a really great example i'm just going to have to redo the example i'm going to have to think really hard about it but netflix skunk no it's not skunk works it's i knew a skunk works see i was i was saying the word skunk works i knew it was in there so great great example of something is is implementing this i've implemented this man do people want to implement things with objects with or with classes so much better to go flat objects and go with mutating mutating functions so so much better all right so anyways all right let's so lisov i'm not i'm just generally not a fan of lisof i find everything that lisof says to do is implying that you want a lot of inheritance and i just always find inheritance just no matter what ends up being just an emotionally painful experience you know what i mean because you every single time every single time every gosh dang single time right it's just it's just very painful this is going to be squares and rectangles which again this this example is entirely too simple of course oh squares and rectangles squares is just enforcing something right here right it just enforces that width and height are the same and then blah blah blah blah and that's that right okay super simple i get it you can do all that fantastic super super simple ex example and but that doesn't mean it's actually simple right it doesn't mean it's actually simple it doesn't actually become simple now i know that like some people are going to be like well have you used a java standard library like they have really great lists and all that yeah it's like okay but it's really not that okay when you start looking behind the things and you're just like wow this is this is not that great this really isn't great fake legs confirmed yeah i know fake legs confirmed we are actually going to name the podcast not hack and stash but no legs in stash but he didn't like the name okay interes interface segregation principle segregation means keeping things separate and the interface segregation principle is about separating the interfaces the principle states that many client specific interfaces are better than one general purpose interface this is actually a pretty good principle this is also in go which is keep your interfaces as thin as possible don't go don't like don't make it a lot right make it as small as possible right and so the bigger your interface is the more things that have to implement it the more specific your interface is which means the more the less useful your your things is so we're going to you know we can go through this right which is you could you could imagine that you could like capacity doesn't have to be related to some things right so that's like why io writer and io reader are so nice it's just a singular method and so implementing an io writer is really simple you don't have to worry about like closing you don't have to worry about all the other things that probably do go with like file handle operations or with tcp endpoints or with your own bespoke you know what's it called your own bespoken coding algorithm you don't have to worry about any of that because it's just like here's a really thin tiny interface just implement that so it's very very good so i agree with that one i typically agree with this one so not the eye of ins solid is pretty good i'm a classic eye enjoyer okay dependency inversion principle the dependency inversion principle state that our classes should depend upon interfaces or abstract classes instead of concrete classes and functions this is also fairish go typically in go you return structs you receive interfaces typical like that's considered like a pretty good rule of thumb and so this one is not necessarily bad the dependency in version principle states that clashes depend upon interfaces yeah again i think that you know return structs receive interfaces very very good when you return interfaces that's a rarity in go you know every time that i've done that i've never really voiced it that well as they do and go go but it's always been kind of this intuition that that always can be really really really annoying right it's good for testing exactly that's why interfaces are considered better is because you can easily just hand in something that adheres to the interface that's why something like structural typing can also be really nice just because you just you you you don't you can just implement the interface without like explicitly stating it so like java you have to say what you implement whereas in go you just implement and if you happen to structurally match you're good which i think is really nice if the ocp states the goal of o architecture the dip states the primary mechanism what's the ocp what's that one again which principle is ocp what's the o in solid i think it's the one i hated open clos principle yeah open close principle i hated that one that's like my least favorite one the two principles are indeed related and we have applied this pattern before while we were discussing the open close principle we want our classes to be open to extension so we have to reorganize our dependencies to depend on interfaces instead of concrete classes our persistence manager depends on invoice persistence instead of the classes that implement that interface the big problem with this is that you always know that an invoice persistence then the the persistence manager then needs to become abstract after a little bit of time because the persistence manager needs to be able to manage persistence a bunch of objects so then you literally have just three four layers of abstraction to save like three separate items you know that once they add a third one you have this entire experience of like okay well now we're getting too many little too many little you know properties we need like an array of these things so that we can abstract on it and they all need to do this and man it is just like it just keeps growing it's this ever growing abstraction which just takes much much longer for you to understand why something is i'm not even against abstraction when it's good conclusion in this article we started with the history of solid principles yes oh you're telling me what have we already learned okay no what's the conclusion tell me the conclusion you know what i am not a fan of saying what you're going to say say it saying what you said like i'm not a fan of that i think the conclusion should just be give give give me the meat and give it to me raw i want to thank you for taking the time to read this i suggest keep the principles when designing writing okay so here i think this should be the conclusion right here i suggest keeping these principles in mind while designing writing and refactoring your code so that your code will be much more clean extendable and testable i think that you also abstract for the idea of extension before you need extension at all and then guess what i think that you're a sad sad sad sad person okay so like my brain so just to be fair just to tell you where i'm going in my head so we've been designing this nice little game engine and i realized something okay i realized something very very important shall we say i can take a little game engine and the difference between say rendering it in neovim and rendering it just say in charm with ssh it's not that much right we can actually do that i'm just going to have to make a small front end that takes in an ssh connection and writes it out to the ssh string it's actually not that hard should i pre-art planning for that to happen no i'm not going to i'm going to write the thing and do the thing you know what i can also do i can also use htm x and serers side events right server events and actually get that thing where i actually open up a connection leave it open and send down events and i could have the exact same experience you'll be able to watch our tower defense game in the browser via htm x or i could even upgrade it from server events into websocket events not hard to do but that's all watchable and it's all doable with the little game engine we're building but here's the kicker i'm not trying to just immediately interface out fully knowing where i was going i i did not try to make it that abstract and i think that's good i think that's a good way to go i knew in abstraction might be needed but i did not start with the abstraction instead i started with the concrete nature of it and will move on why not because when you start abstracting you start making decisions for the what the problem should be not what the problem is what the problem should be and that is truly like one of the greatest evils of software and so i refuse to abstract to what i think i need i will instead build the thing i know i need then build the thing i think i know i need next and go what's the abstraction between these two things put them together and love it and be happy with it because guess what if you can make one really good one and then you can make a second one that's really good i guarantee you by the time you've made that one and two adding the third abstraction will not actually be all that hard because you're like we've done it we've made it i've already figured it out because i needed that renderer anyway so now i have this nice little rendering layer and now i'm really now i can write the renderer that works for html as much as it works for charm tues right the name is the primen