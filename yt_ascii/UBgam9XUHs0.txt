my guest this week is simon pton jones and i have to be kind of careful introducing this one cuz i could turn into a total fanboy simon is an absolute legend i've got such respect for him and he's been a huge inspiration for me as well as hundreds thousands of programmers he's been a researcher and groundbreaker in functional programming for decades he's been one of the key developers and shepherds possibly even midwives of hll which is one of my favorite languages and beyond what you might consider the niche of hasal i think you can feel his influence on any language that's been touched by functional programming trends in the past few years anything from java to python to f and beyond he's even and this is a kind of separate story but he's even had a big influence on excel programming so despite hascal seeming like a niche he might have affected more computer users than just about any lang language researcher ever in addition to all that all his computing work and wisdom he's also one of my all-time favorite conference speakers i saw him give a talk a few years back about a new technique for optimizing the compilation of let statements now in the hands of literally anyone else that would be the driest smallest topic you can imagine but he has such clarity for explaining things and such raw enthusiasm for programming i left that talk wanting to write a compiler just so i could optimize le bindings kid you not he's that infectious so i would have gladly had simon on the show to talk about anything that's on his mind but we narrowed it down to three big topics his past how do you build a language as large as hascal out of a very small set of core ideas what do you put in that core to make it a larger language once you've mastered that trick we get to his present what he's been doing for other languages simon's been working on verse over at epic games i thought verse was a highlevel scripting language for unreal engine for fortnite extensions but it might just be a trojan horse language for the idea of functional logic programming what's functional logic programming you ask simon's about to explain to us and as if his past and present work weren't enough he's also trying to influence all our futures he has been heavily involved in shifting the way we teach computing in this country in england and he wants to spread that influence far and wide so that children get taught the fundamentals of computing just like they're taught the fundamentals of maths and sciences was if all that weren't enough simon's also a thoroughly nice chap so let's get started i'm your host chris jenkins this is developer voices and today's voice is simon pton jones joining me today is simon payton jones simon how are you doing hi good to see you again it's good to have you here so i i was trying to think of how to introduce you and how to pull together all the threads of your career which is a big task you are i wanted to say you you are to functional programming what james brown was to soul you are in some sense the godfather of functional programming hardly there's plenty of other godfathers well yeah it's it's it's a large family but you're onwards and yeah yeah and indeed from alonzo church and on oh gosh you're going get all that way back yeah yeah wellit let's say you're standing on the shoulders of giants but you're one of the giants upon whom we now stand i was trying to pull together a thread that connects what you've done that we could start with and the one that jumped out at me was you've worked on hll obviously a huge contributor to hll you're currently working on verse you are a contributor or were to c minus minus and the thing that connects all three of those which is i think is fairly rare in programming language implement a is they are a large outer shell which is a lot of syntactic sugar for a very tightly defined core language is that fair to say that's true of verse and haskal i'm not sure it's so true of c minus minus designed as a kind of portable assembly language okay rather like rather like llvm has become but llvm become much larger see was intended to be but yes for the certainly for i mean it's it's a fairly common pattern to try to to design a a sort of a a a large user friendly language which desugar into some some kind of small elegant core you seem to have pushed that much further than most of the language implementations i know about so i guess the first question is why why do it that way well for me it's a um it's a testament to the expressiveness of the lambda calculus right so one of the things that always attracted me about functional programming is that it's a place where theory and practice come rather close together so you can build practical programming language that rests very directly on some intellectually robust and small and elegant foundations so in the case of the lda calculus it was always the the lambda calculus in in its in its essence is just a lambda a lambda term is just the a variable an application or lambda and what's amazing is that you can translate an enormous variety of programs into that indeed you could almost imagine two different foundations for computation this wasn't the way that it happen but when alonzo church and alan turing they were actually in the same university at princeton at the same time and alonzo church was defining the lambda calculus and touring was defining the touring machine and both of them are computationally complete that is to say if we want to say what can computers do fundamentally we say well that they're just touring machines if a during machine can do it a computer can do it and vice versa yeah but you can also say they're just lambda calculus machines right if a computer do it a lambda term can do it and in fact it was entirely nonobvious but in fact it turns out that touring machines and and lambda calculus are inter definable that is you can write a touring machine which will run any lambda term and you can write a lambda term that'll run run a touring machine right they're equally expressive good yeah so now then it didn't really happen like this but you can imagine that all of imperative programming is built on touring machines right was it a touring machine it it has this tape and it mutates you know mutates the tape it it reads and writes things on the tape the tape is like the store it's fundamentally a mutation machine what is the lambda calculus well at any moment you have a a term a lambda term and it simply and you rewrite it one step at a time just keep rewriting and you get some answer and this is a completely different model of computation that's and functional programming is built on the that purely functional model of computation imperative program is built on a more m mutation based touring machine style thing so it's almost as if two entire approaches to programming have grown up built on different foundations but that ultimately ultimately they're equally expressive so for me i've always loved the lambda calculus as a basis for computation and it turns out that you can translate well all sorts of languages including hll into this very small core and moreover the thing that i appeal to me particularly is that that's not just a theoretical idea it's a practical idea you can actually build a compiler that translates into this small core and moreover the the lambda calculus you know had a long history of development including typed lambda calculi and in particular a typed lambda calculus called system f and it turns out that it's not just most compilers typically most compilers in the world typically take a a language that might be statically typed and translates it to some kind of intermediate language and then optimizes that but the intermediate language is typically not statically typed but in ghc our compiler for hll we take the hll and its and all its glory and translate it into this core language system f which is statically typed so very unusually jhc is one of the very few production compilers i know that maintains a statically tight program from the front of the compiler right through to the code generator i'm not thought of it that way yeah and that's that's incident you might you might ask why bother to do that right well to do that because after all all that matters is that the source program is statically typed right and we reject it then but since the intermediate program is statically typed if the comp if there's a bug in the compiler a very common you know which is rather common i'm a compiler right then then what happens often is you get a type error in the intermediate code right so the compiler has a bug it optimizes program a into program b alas program b is type incorrect and when you run it it will crash yeah right so if you don't have a typed intermediate language what happens is you have a bug in your compiler you compile a program you try to run the program and it crashes you think why does it crash so you can know get gdb out and work out why it's crashes then say oh the code generator is generating the wrong code why is that oh because the intermediate program are you know some many levels of transformation back ah the optimizer introduced the bug the optimizer turned a type correct program into a type incorrect program which crashes now it's way better for the compiler to say uhoh i find that i have turned a type incorrect program into a sorry type correct program into a type incorrect program and report so that that reports the error immediately it happens rather than compiling it all the way to machine code running the machine code and then having to backtrack up to find the bug in the compiler yeah yeah okay that makes sense but there's there's this thing with like having this tightly defined core which actually if i'm right is fairly small i mean it's implementable reasonably if you've got the knowledge to do it yeah first of all i'm just thinking a lot of people come to this idea as being like llvm in that there's this lowlevel llvm is not as tightly defined but i'm just trying to get a sense of where something like ghc's core might appeal to language implementers and people interested in how languages are implemented when they seem to already have this popular thing called llvm well by the time you get to llvm you've already descended several layers of abstraction right compilers typically work at various levels of abstraction so if i've got a you know hasore program i might say to a programmer how do if i'm trying to explain how it runs i say well you've got this function call you can replace the call by the body of the function replacing the arguments of the function with the actual arguments that you passed in the call right now you just keep doing that and that's how the program executes of course that's not really how the program executes but really the program does you know machine transfers and pushes things on stacks and have things in registers and stores things in the heap and runs a garbage collector so but but nevertheless if you want to explain to a programmer how it runs you might think in this rewriting term rewriting way and indeed the optimizer works in this rewriting way as well but to get to lrvm which is a low-level imperative language you've now had to say oh i'm going to you know i'm going to allocate function you know closures for as yet unevaluated thks and they're going to consist of a poter to some code together with some free variables and those are going to be stored in the heat one at time and then when have so there's a lot of very low-level operations that mean that doing the optimizations you could do in a rewriting system at a higher level become essentially completely inaccessible by the time you get to the low level right so and this is this is not new right every compiler has this idea of we do some transformations and optimizations using the high level code and then we sort of move down to a low level closer to the machine and that at that point the high level optimizations become essentially inaccessible but new lower level optimizations like which register shall i put it in become accessible right they were not not expressible in the high level stuff so the lrvm stroke c minus minus part is really in ghc's back end right this the intermediate language this system a flight language that i was describing which ghc uses mostly that is the sort of the f the middle of ghc the long middle that does lots of functional programming kind of optimizations does that make sense they're very different purposes is what i mean it's not the one is better than the other it's just they're different so we're almost talking about a three layer lasagna of programming yeah yeah you take hcll you turn it into core you optimize then you turn it into l c minus minus or lvm and you optimize some more yeah right okay so what makes that middle layer the core or some kind of design sweet spot is it that it's got a solid theoretical backing or is it something else well you it's clear that you want to do some transformations at the high level when you still have the notion of you know first class functions and and doing beta reductions and so forth so you so you could imagine doing that on source haskal yeah but that wouldn't be much fun because s because source haskal has dozens and dozens and dozens of language constructs all of which are really syntactic sugar for some smaller thing right so it's much more economical to do a oneoff transformation that you know gets rid of 20 constructs in favor of one and then optimize the one rather than try to optimize the 20 right so so what you want is to have an intermediate language that is that retains all the high levelness that you need for the optimization right without any of the superficial syntactic sugar right that's what makes it the sweet spot i wonder if if i can ask the similar question the other direction then so if in a sense hascal boil away all the sugar yeah and you get down to this core but then you're saying the core of ghc is a very expressive language could it have been boiled up to a completely different looking language is there something about hasal that pops out of this core language or is the core a substrate on which many languages could be built oh no the core is a substrate on which many languages could be could be built you know that look quite unlike haskell really because it's really just just a statically typed lambda calculus the big thing is that the the thing that would make i mean like could you take ml for example and translate into core well let's see so uh mostly you could the thing is that that ghc's called is a lazy language it has called by name semantics and ml is called by value and there's quite a lot of research has been done about could you make a single intermediate language in the style of this core thing that was equally good for core by value and call by need languages no source languages you compile many many languages to them i think the answer is probably yes but the details are quite it's quite difficult to do a really good job of both at once and in practice you know they are haskell's core is skewed towards lazy evaluation though it can it spends a lot of effort on corbar value as well and similarly a compiler like the oaml compiler that the folks are jam stre to building which they have an intermediate language called i think f lambda they call it there they will be skewed towards call by value right so this starts to lead into your current research topic because i know you're working on another core for another language that has a third call semantics you you've been working on verse yeah which is neither lazy nor strict it's lenient is that lenient and also but also more even more significantly it's a functional logic language so we talked about imperative languages haven't we which is you mean do this and then do that things like c or java or fortran or c++ that's a whole it's a whole class of language then we got functional languages par of which hcll is a is a particularly what's the word pure example in the hascal hasc's default mode of computation is purely functional if you want to do side effects like input output or mutating variables you have to use the you know am monad so-call so that there's a type system that keeps side effecting computation separate from pure computations so whereas ml doesn't have ml is mostly functional but you can have side effect in computations as well without delineating them in the types so we got imperative programming functional programming both of which i mean imperative programming is the mainstream functional programming is the thing to which i have essentially devoted my professional life because i thought it was so cool when i first came across it when i was you know 21 or so and i became kind of addicted to it and i i didn't think about it like that at the time but essentially i've spent my professional life trying to to say how can we take the idea of purely functional programming and really make it go right knock down all the practical obstacles that make it hard to do in practice or running too slow or too awkward just sort of you know crush those obstacles one at a time and and so that's what i spent my t to haskell is a haskell is a the particular vehicle for that research endeavor if you like and and sure enough as it turns out i mean research endeavors don't often succeed in that kind of way but sure enough it turns out that haskal you know or on its own has been has become relatively you know successful as in it hasn't died out after 30 years which most most research languages don't last nearly that long but so functional programming as an enterprise has proved to be quite influential in the mainstream so languages like and i don't see sharp and python and so forth you can see and many other languages you can see absorbing functional language ideas now yeah yeah alongside these two right has been functional logic programming now that is a much smaller niche if you think functional programming is niche right i don't think it's niche it's a big niche but nevertheless it isn't the mainstream functional logic programming is much less popular i haven't even heard of it and i consider myself fairly well informed so yeah so what's functional logic programming well you've heard of logic programming like prologue right and there you have logical variables and unification is a sort of key concept when you're working with prologue and you can call you can make new logic available you can call functions passing them arguments that are sort of not yet completely filled in it's a very different approach to programming just as functional programming makes you rewire your brain logic programming makes you rewire your brain too yeah now functional logic programming has grew out of an attempt to say well logic programming is quite cool and functional programming is quite cool could we sort of somehow merge them so one way to think of it is this in hll you can say let x equal i don't know f of 17 in blah blah blah so that says x is a variable that denotes a value which is the result of f of 17 so we that so it does two things it brings x into scope and it tells you what its value is it doesn't tell you the answer of f17 it just say you tells you that to compute its value you compute f17 right right yeah now but nevertheless x x stands for just one value in its scope right x doesn't stand for three and then four yeah right like in if you say if you bring x into scope it's a mutable cell that you then assign to and maybe assign a different value later and a different value later so x is the name for a box whose value changes over time in hle x is a name for a value and only one value okay now in a functional logic language you split the let into two parts one is one brings x into scope just says there is an x right but says nothing about its value and then se separately to that you can have equations that get that explain something about the value of x so you can say you can say bring x into scope which in r verse calculus we say exists x right there is an x and then somewhere in the scope of that exists you could say x is a pair so now you've now you've you've given some extra information you said it's not it's not a number it's not a string it's definitely a pair but you might say and it's the first and second component of the pairs i'm not going to tell you they're just y and zed so you might say exists y and zed x equals the pair y comma zed so you've as it were refined the value of x a little bit okay yeah and then somewhere else you might say first of x equals three okay right and that's saying oh if you compute first of x which now we can since we know that x is pair right then then then and the first component remember was y then y must be three that's i mean that's a very unusual thing in itself because it almost feels like we're defining the something twice well it's not we're not we're only saying if we if we say we could say x equals x is the pair y z and elsewhere you said x equals 3 in that case the program would fail right if you give contradictory information about a one of these logical variables right you say exist x 3 fail right so deeply built into the idea of functional logic programming is the idea that a computation may fail that is return zero results and failure is not necessarily bad right failure is any more than false is bad or in hascal a function a function that returns a maybe value which is a maybe value is either just x or it's nothing so a lookup for example might return and maybe value so in high school if you do a lookup and it returns nothing the value nothing that's not wrong it's just that the look up didn't find you know the the key in the dictionary that's fine programming is like that that's you know that indeed that might be partly what you want to do so so in inverse and in functional logic pring failure is not like you know seg fault crash bad things happen yeah it's not a moral judgment it's just they correctly is no answer to that the correctly is no answer that's right in fact verse and indeed a very old language called icon did the same thing inverse there are no booleans instead you say if you say if e then you know then branch else else branch then the semantics is if we evaluate e and e fails we take the else branch right if there's no possible answer to e yes exactly yeah so that that's in just just like i say in haskell if you call the look up and then you can patent match on the result and if it's nothing you do this if it's just x you do that and inverse you can just say if the thing fails take this bunch otherwise take that bunch so failure is not it's not bad anyway so so in this functional logic programming paradigm you got deeply wired into the very fabric of computation is the idea that a computation may fail return zero results and in fact inv verse it can also return many results so that's a the the another crucial component of functional logic programming is choice so the expression one vertical bar two returns one and then two right so an expression can yield zero results we call that failure one result or maybe two results or maybe seven results so this sort of multiplicity of results is part of the core computation model of ver so as you can see it's very different to to ordinary functional programming yeah i i know someone is listening to this is going to be thinking this so i have to ask it in what way is this not just processing lists list it is it is a bit like making you know has call's list monan out into the fundamental monad of the language but and you could simulate verse by it wouldn't just be a list monad it would be a logic team monad for anybody who wants to go and look up the logic t library or something a bit like that because remember we got to do all this unification as well yeah that's the big difference so so a functional well well so one possibility would be to say well why don't we just do all this as a library well the answer is it would be it would be possible but inconvenient right programs would look cluttered yeah another way to ask the question is what is the core computational paradigm of this functional logic thing right could we as we were saying is we can distill hascal down into lambda calculus what would we distill verse into and this has been your your job recently right that is my job recently that's right so so if we're going to do this functional logic programming thing we better know what are you know what the the absolutely essential irreducible essence of functional logic programming is if we're if we're going to undertake this endeavor at all and we are so indeed we spent the last couple of years identifying what we've called the verse calculus there was a paper at icfp last year about it which indeed describes a little calculus it's it's bigger than the lambda calculus quite quite a bit bigger actually lambda calculus remember it's cor only has you know variables applications and lambdas that's incredibly sparse right verse has about you know eight so the the verse calculus has about eight constructs or something it's a bit bigger but we've also found a very nice way to then give it semantics in a similar style that we give the semantics of the lambda calculus how do we say what a lambda calculus program means we give it rewrite rules in particular beta reduction so in the verse calculus we give it we write rules two you i think you need to define beta reduction for those that don't know yes so so it's a bit difficult to do this without whiteboard but what is what is a what is a the own in when alonzo church first defined the lamb calculus he defined this incredibly tiny calculus which is just variables applications and lambdas and the only the only rewrite rule is if you have a lambda applied to an argument think about a function applied to an argument then what do you do you take the body of the of the function and you replace the call with the body having replace the bound variable with the actual argument so you sort of rewriting the function to be you're rewriting the function call yeah to have a copy of the function body yeah so if i have i don't know if i say one bat of x is x^2 + 1 then if i see one bat of three i can replace that with 3^2 + 1 if i see one bat of 77 i replace that with 77 s + 1 yeah right so each call is replaced by a copy of the body with the actual argument substituted for the formal parameter that is beta reduction that step of replacing the call by the copy of the body after substituting that's beta right and astonishingly that single thing is enough to define a computationally complete language that is a you know a a it's enough to define any any computation whatsoever in the you know in the two in complete sense it's amazing that that one rule is enough that that's punching massively above its weight it is amazing right it's you know just gobsmackingly brilliant that alonzo church right back in the you know late 1920s early 1930s was defining this calculus with with a single rule define something that was as expressive as a toing machine you know they're into expressive it's not too surprising that we figured out how useful that was from touring side building machines upwards but yeah but it's interesting that now time has rolled on and we've realized that you can go from the maths down to get it to exactly the same place yeah that's right i mean they realized they were inter you know they were each as expressive as the other they realized that very early on but the thing about touring machines is that real machines you know actual you know what what whatever it is you know x86 processors they look much more like touring machines yeah in which the memory is the tape that is mutated by the processor that is like the head of the touring machine so it's quite a close connection between the touring machine model of computation and what really happens in our microprocesses yeah yeah and the the sort of functional programming stuff has taken a bit longer to say well it's equally expressive but if we build a good compiler we can map it onto the same x86 processor yeah and that is the that actually is the step we were discussing earlier when we go from lambda calculus down to lrvm or c minus minus yeah okay so going back to this core which i really want to explore more boiling down we've got to go high level in a second but boiling down this functional logic programming language into verse core you've called it you've ended up with a batch of you say eight rules oh no that we have i think i forget the exact number do we have alas rather more than eight rules there's more like 20 or so i think i can look at the paper but the i was meaning the the number of syntactic constructs calculus only three or four we have more like sort of eight or 10 i think in the verse calculus okay but this core i mean does it the thing one thing i want to know is can you look at the two different cores and get a sense of what the final language is going to feel like to work with i does does it have is there functional logic zen the fun the tower of it buried in this core language oh there is i mean i think i think it's a core calculus is the sort of the essence of what computation means in that paradigm incidentally the lambda calculus is a subset of the verse calculus yeah oh is it yeah so every lambda term is a verse calculus term so it's just that verse calculus has you know a bit more that doesn't make it computationally more powerful but we know that the lambda calculus is computationally complete but it but it has these additional you know functional logic features built into its infrastructure and rewrite rules to support them but indeed i think when you stare at the rewrite rules if you look at the you look at the paper you'll get you will you will get you know some sense of you won't get a sense of what it's like to write you know programs in inversed in the large but i think you'll get a sense of what what what computation means and what what you can say in this little little language and what we're saying is i get the sense is a version of programming where that there's so imperative languages you define what needs to be done functional languages you define what is it feels like the verse you're going to be defining the shape of things as best you know them now and gradually building up a picture of the constraints around the answer yeah that's a bit like that and in some ways that's an even higher level right we we so that functional in functional program we say it's declarative what do we mean by declarative programming like it's what you were saying what is rather than you know how to compute it so you know crudely you might say imperative programming say how and in functional programming say what and we've you know rather sloppily said well that must be better right but but but in a functional logic language you're even higher level rather than saying how can i give an example if i say find me the x such that x s is is 22 then i'm asking you to find the square root of x right so that's a very high level thing right it's not a square root algorithm it's completely non-constructive right it simply tells you a property of the number you want yeah right but it's very expressive that's good right and and you you can see immediately what it does if i showed you a square root algorithm it would be hard to figure out what it does if i just say my spec is you know the x such that x squ is 22 then you say ah now i know what you're doing right so this kind of tell me the properties of the result way of describing what you want a computer to do because after all that's what programming is describe the properties of the result is a rather highlevel way to tell your computer what to do right as we've seen from this x squ thing now inverse you can say exists x x^2 = 22 and try to run that but it will get stuck right it's not it's not an illegal program but it but it's one that it's one that we can't we can't we're not going to succeed in executing right because the the property we've asked it to figure out out is too hard we've asked it to guess a square root algorithm right yeah yeah but if i say uh an x and y and zed such that x is the pair y z and and the first component of x is three and the second component of x is four then i've given you enough information very straightforwardly to solve those equations and say ah why must be three zed must be four and x must be the pair three four yeah right so the so so versus if if you like a bit on a higher level in in this sort of continuum of expressiveness than purely functional programming but not as high level as oh i can just ask you to do you know solve arit tre polinomial yeah or sol format's last problem yeah there is a danger that we're going to ask it to solve the mp complete problem for us right can you give it sales problem as the spec and expect the answers you just magically pop out and that's not going to happen yeah they l apart exactly yeah so what is what is from a questions this can answer conveniently point of view what is functional logic programming good for ah yes so that's that's a good question right so so then the the uh we got imperative programming we've got functional programm got functional logic programming i've always thought that you know since i was 20 i've thought well functional programming is just the right way to write programs right and it was very inspiring when john bachus when he got the touring award gave this lecture called can programming be liberated from the von norman style in which he was essentially saying he a famous person was saying look i have no truck with these imperative languages just go gangbusters on functional programming because it's a better way to do the job right in the t tk of telling a computer what you wanted to do functional programming is just better that is to say you're less lik to make mistakes you're you' be more productive and maybe our programs be who knows depends how hard we work on a compiler maybe our maybe our programs will run a little slower but maybe not much and maybe they'll be highly parallel who knows so but it's just a better way to do the job now functional logic programming maybe that's a better way to write programs right maybe it's just so i've argued that it's more expressive that to say it's more expressive and a higher level it doesn't necessarily mean that it's a better programming medium because it might be extremely obscure for example or hard to understand programs for some reason yeah so i think that the um tim sweeney my boss and the founder and chief executive of um epic epic games yeah firmly believes that functional logic programming is just the right way to write programs in the same way that i firmly believed you know age 20 that functional programing was just the right way to do things and i've you know placed my bets on that and tim is putting his money on functional logic programming at the moment i think there's a i think that's a the good thing about that is it means that verse takes a view right it is expressing a a a strongly held and well worked out view of what programming should be like so that's quite exciting for me as a programming language researcher is it do we know that it's going to be a better way to write programs even supposing programs run fast enough and so forth is it better way to write programs i don't know it could be but i think we'll get a lot of the only way we'll really find out is by trying it and that's what we're doing yeah so so tim is convinced i'm i think there's a a extremely interesting you know experiment to be done here and i'm prepared to be convinced but i'm not yet in the this is just definitely so much better camp yeah well that's fair cuz you are on the spectrum of language researcher to marketing person you're way over the first end of the spectrum right oh indeed yes yes that's right i'm you know my principal goal in all of this is sort of it's an intellectual adventure yeah but of course the intellectual adventures are dramatically informed by practical usage i'm strongly motivated by the fact that hundreds of thousands of people using use hll and i'm strongly motived by the fact that motivated by the fact that verse because it's going to be the programming language in which you enter the you know epics meta fortnite world and meterse there's a a kind of captive audience there yeah right of actually hundreds of millions of people who will start using verse and that's very motivating too because i want it to be a language that is you know just works for them and is and is you know smooth and and it you know it's just sort of obvious what it does whether we'll whether we'll succeed in doing all of those things we'll have to see but that's that's the aspiration and we do have a big user base yeah it's it's reminding me of objective c when apple decided that you had to write objective c to use ios it's like an entire world of programmers just popped up having to find out how useful and interesting this was and we're going to see the same with verse and unreal engine i ect i think so i mean you can at the moment you can program with unreal using c++ that has its own barrier to entry and you can also use a lang a visual language called blueprints which is you know it's a visual language in the sense that you draw boxes and arrows between them and the arrows can be data flow arcs or they can be control flow dependencies yeah but of course there's a there's somewhat a limit about about what sort of programs you can write in blue blueprints so then you have to descend to c++ and versus sort of filling the gap in the middle because there's enormous numbers of users i mean you've got 300 million people are you know floating about in the the sort of fortnite universe only a very very tiny minority of those will bite the c++ bullet yeah but we hope that a lot more of them will find verse a happy place to play yeah i can imagine a lot of people getting started with a visual language hitting the limit but not quite wanting to leap up the mountain to c++ yeah okay so let me let me ask this not asking you to bet on the marketing side but here you are an experienced language researcher being told okay we've got this language verse it's a functional logic language we would like you to boil this down something semantically rigorous what's it like to retrofit semantics to an exist language oh well it's quite entertaining actually but and it's entertaining because tim who is the progenitor of verse right the the unique single progenitor of verse he is fundamentally a geek right he ces cares primarily about beauty and elegance and you know a deep connection to mathematical logic and just doing it right he has incidentally a inly built a very successful company right so he's also a very good businessman yeah but i would say that his sort of you know genetic core is let's do this right so and he has been designing verse in his head for the last two decades oh really that just that he's been also yes a long time long time it's also he's been busy making epic successful as well so it's been a kind of you know evenings and weekends activity for him for ages and ages and so so my job is as it were to to figure out what verse is you know what this thing in his head is and it's full of interesting and original ideas and then try to make sense of it all now supposing we discovered it just doesn't make sense well we we haven't discovered that yet but i'm i'm i i firmly believe that if we could persuade tim that something really didn't make sense he would say oh japs we can't possibly do that you must have found that as you dive right into the very gut of it you find that actually this piece doesn't fit with this piece unless we amend the language then there must be inconsistencies that you only discover when you're trying to formalize something well we are formalizing from the the bottom up so you know we sort of starting with the you know the core calculus that's what this this paper is about but tim has been thinking about this long a long time so the the the the whole thing the whole enchilada including its type system and verification and transactional memory and side effects and classes and inheritance and so forth and backward compatibility the whole thing is jolly complicated yeah so i guess what i mean is once you formalize this calculus and you start building up that tower are you going to find you end up with something that kind of that doesn't quite look exactly like verse you going to say okay there's a new release of verse and we've got to change the semantics because i don't know so so far we haven't okay so far we haven't g across any ins superable obstacles as it were which i think is also also testament to tim's sort of single single-mindedness i'm reminded incidentally of rust here rust was a language that was designed with you know strong attention to sharing and borrowing and linearity and so forth and but it was designed it was very much didn't come out of a university and a sort of pointy-headed academic it came out came out of a sort of a desire to to do good practice so i was pretty sure that when somebody came to do the theory behind rust right they would find all sorts of holes in the type system right maybe not ones that occurred in practice very much but just that there would be you know uh holes in which which would allow you to write programs in rust that simply weren't correct you know that were disobeyed rust's what guarantees astonishingly that turned out not to be the case derek dreer and his colleagues have done a lot of stuff on the foundations of rust and actually didn't find any major you know theoretical inconsistencies that's amazing that means that the original designers had incredibly you know good intellectual not just taste but they actually got it right it's an amazing thing which is jolly complicated this business about linearity and sharing very difficult to get right it's it's a remarkable achievement i think do you have any theories on why that might be do you think it's just lightning struck they're just very hardworking and clever or do you think there's something about comp computers keeping us honest no i think they probably just well i computers do keep you honest but there's an awful lot of potential programs possible programs that you could write and many of them you know might have you know linearity flaws in them that were not really apparent or don't show up even when you run it so so no i don't think it i i think it's just they're extremely clever and had very very well educated intuitions that they sort of developed over time and so you must be claiming something similar for ver if you're going to formalize these things and finding their what i'm saying so so far as i say tim's tim's intuitions have proved remarkably you know one might disagree about matters of taste right so is it worth having this this piece of complexity in order to allow that kind of expressiveness you know you can make choices about that but what we haven't found is the thing is just a mess and doesn't hold together at all is just inconsistent in some way right yeah so and i think that is testament as i say to his single-mindedness and his sort of technical intuition okay well in that case let's talk about climbing this ladder a bit more because i i absolutely don't want to sit a test on this but i have read the verse core paper and enjoyed it and you hint that you're going to be climbing up into formalizing side effects and types yeah how's that work going oh well so let's talk about types because that's really the the next big thing so so versus typee system is very unusual so usually like in language like has school you have the world of terms and then separately have the world of types and types are you know a somewhat special language in particular you can statically reason about types so the type checker can say this program is well typed this program is not well typed now in verse a type is more like a contract in scheme so a type is actually just a function a function inverse actually and it's a function which either fails in the sense we've been discussing given an argument it either fails or let's say for now or it's the identity function so the int type is just the function that takes a value tests whether it's an int and if it is it returns it and if it isn't it fails make sense right yeah yeah so it's almost like a filter if you like yeah just but it but it fails if it isn't the type so let's see the type int comma int the type of pairs of ins is a function that takes an argument checks that it is a pair if not it fails then applies int to the first component and applies int to the second component remember apply to means check that it has that type because int is a function so so the pair int comma int is also a function is also a type which which does this thing so any so you can define the type say of pairs in which the second component is bigger than the first oh that's an unusual type that is it's just a function that takes an argument i you could write this function inverse right just a just a function takes an argument checks if it's a pair if it is a pair check the first component is an in check that the second component is in it and then check that the first component is bigger than the second and fail if not so it becomes very much that there's a unification there between type statements saying we constrain these values to these rules and logic functional logic programming in general saying we constrain these values to these rules there's there's less separation between those worlds yeah maybe but i i think it's i think in the typ connection i think is that a type is just a partial function partial in the sense that it can fail so do remember we said failure is deeply built into the fabric and we could make that you know done by some kind of list monad but then it'd be much more awkward to say and types do this so so here that's what a that's what a type does but now since a type is just you know since i can write new type new types are just new functions that i write as a user right so i don't write have a different language for defining new types new types are simply ordinary old verse function definitions but that means that the type checker has to understand well these ordinary old verse function definitions you've just written so the type checker has to be to run verse programs exactly the type checker has to be able to run verse program s yes and of course you might write something that is extremely hard to check right so it would not be difficult to write a program with a a contract you know or type that was sufficiently complicated that it was hard to be sure that the first argument was going to be bigger than the second right yeah like i don't know say you had a type that was true only of positive numbers and you said is x squ in that type well yes it is because we know that if i mean if x is an int we know that squares are always positive yeah but that's a property of numbers right so maybe the verify knows about that property of numbers but you can cook up some more difficult property of numbers the the the so you can see you'd rapidly get into arbitrary theorem proving yeah yeah right so instead of calling it type checking we call it verification okay and the idea is still going to be that just as the the purposes of type checker is to say it eliminates certain classes of bug so the slogan is well typed programs don't go wrong where going wrong means some particular class of errors like adding an integer to a booon right hascal means you can't that could never happen at runtime right yeah so if you imagine a runtime which manipulated integers and booleans are sort of tagged values so you could tell them apart at runtime and then your addition operation did a runtime test you would know that that runtime test would never fail yeah right and therefore you can emit all those one-time tests and indeed the tags that distinguish integers from booleans right yeah good now in ver verse is going to be like that in the sense that verified prrams don't go wrong right so if the verifier says thumbs up your program is verified then a certain class of errors cannot occur and the implementation could be corresponding more efficient but it's possible that the verifier might say i'm sorry i can't prove that your program verifies because it requires me knowing say that u x squ is always positive and i haven't been taught that yet so over time i expect the verse verifier to get more powerful more smarter right yeah as it's taught rules for more and more complex time exactly but there won't be unlike hascal there won't be a clean bright line between programs that can be verified and programs that can't yes right because it'll be a function of just how smart has the verifier become on any one day we might hope to characterize as precisely as possible where that boundary lies but it is a boundary that will move over time do you think that verifier will ever be user manipulatable in that you will write more rules for the verifier again in oh possibly yes i mean you want to be a bit careful because if the user adds a rule that is simply false then you know the program might crash yeah and it might crash in a truly horrible way right so like it might just simply be a seg fold yeah so you'd want to be a bit careful about allowing you but but if you if you essentially add some you know some new things to the verifier that says make this part of the trusted code base if this is wrong all bets are off then that's a pos imaginable possibility yeah yeah okay do you think i mean i'm thinking verse if if the verifier is just more verse functions yeah this leads into side effects i could in theory define a type which was the the type of all strings which are a valid username in my database yes that's right that might very have time or space and who knows so so i think for us types are going to be pure functions yeah so now we need an effect system right to ensure that to so that we can check that types are pure functions and indeed verse has an effect system [laughter] too so you can see why it gets complicated yeah yeah where are you on formalizing the effect system and are you taking a similar approach to hasc not similar approach to h because has uses these monad things right we don't want to you get selled up with monads and types so and because yes from a programmer convenience point of view just being able to say relying on sort of left to right sequencing for side effects is extremely convenient so and language is broadly classified to language like that force you to do you know do use use monads for anything side effy and that's a bit of a hair shirt but it's an excellent discipline in my humble opinion but but it's a it's a design choice and other possible design choices like verse to to make a not to make such a strong syntactic and type level distinction between side effect and computations and and not ones but instead have an effect system that says that the verifier will for any for any term it's going to be able to check whether it's pure and you can see fundamentally you know crudely put that's not very hard right is this expression pure well does it use any side effects directly and does it cause any call any functions that can use side effects yeah right so at its crudest level you can see there must be some kind of purity checker that isn't very hard yes right but to do a systematic job of an effective system is indeed quite a challenge and that's part of what we're up to at the moment yes i should say by the way that tim has an implementation of all of this embedded in you know his his c++ implementation the vers he's written in c++ a compiler he's been developing over the last 20 years and it's it's only five or 10,000 lines of c++ it's incredibly small he is a virtuoso c++ going but but i think he would be the first to admit that it's you know it makes an amazingly good stab at all of this but it is not you know tight and elegant and complete and definitely right in every particular so it's an excellent stab and it means that we have it's it's a way that he has been using to educate his intuitions to go back to your questions about computers keeping you honest i think building that has indeed educated his feedback throughout right but where as it were we're not building directly on that we're trying to use that as a source of inspiration to do this more foundational thing that we're talking about yeah and that presumably is going to occupy you for a good few years to come i think so though in some the the the the scary bit is that we are designing the airplane at the same moment as we're launching it into the sky right because there is a there is a verse that has been released as a product if you just you know google for verse language you know epic you'll rapidly get to it yeah it is a it doesn't have any of this functional logic stuff in it but it does have other things like classes inheritance and modules so it's a so it's a language that is already usable for building you know games and creative stuff in the sort of fortnite universe and programming gets unreal so it's already being us by thousands of people so we're doing this foundational thing on the side and then so we sort of launched one to mix metaphors we launched one rocket you know into orbit and now we're you know building some more elaborate and sophisticated thing we're going to launch into orbit then they're going to join up in the sky and hopefully we we will so so the scary bit is we need to do that quickly enough that you we can't go on for years and years and years doing this foundational stuff because you know the the the airplanes flying in the sky we want to we want to meet up sooner you know within a year or two rather than in 10 years so right yes i think working out all these technical details and writing papers about them will occupy us for several years but there is a pretty big urgency at the same time that i personally find a bit scary i can understand that and do you one last question then do you think that do you think that these ideas will be pinned particularly to verse or they juicy things that other language designers can pull out of this and steal oh well i mean the one of the whole purposes of writing the paper is to distill the essence right so of course any particular language implementation will be encrusted with particulars right hascal is no exception by the way it's an enormous language and with a lot of detail to it and you need to get to know it's ecosystem and cabal and stack and hls and on and on right so and vers will similarly be encrusted with lots of stuff but if we want to you know the purposes of of the purpose of sort of the research enterprise is to isolate the key ideas and distill them into a form that they can be digested by other other language designers and academics right right and so indeed it is my goal that our you know our first paper and hopefully subsequent papers about verse and the verse calculus will be influential well you know will be much more than just saying well this is how verse works right will but they will rather embody and and make precise a collection of ideas that may you know i hope who knows have be influential in their own right yeah yeah as a language research your your goal is to make the ideas bigger than any one language oh indeed yeah indeed i often when when talking to research students about writing papers i often say that you know that the the the the the least durable thing that we do is to build artifacts you know like compilers in my case the most durable thing we do is write papers right because those papers will be you know in in the best case will be read and will inform stuff decades later when you know when the the particular language implementation is dust i mean just look at the fact that we're still you know alonzo church's ideas we are talking about in the podcast today which is you know a hundred years since he was first thinking about them that's amazing yeah yeah when we go to a concert hall we listen to people reading mozart's papers he called them symphonies but they are you know his you know intellectually written down stuff and symphony orchestras read them of course there's a great deal of expressiveness and nuance of what they do but the fact is that mozar infected our brains with an idea that we still find rewarding yeah and i think the the you know the purpose of uh research papers in some ways is is to infect the brain of the reader with a an idea that is so persuasive and seductive and exciting and creative and interesting that they can then use it to inspire and build on new things that's the that's that's that's my hope yeah yeah we had we had a guest a couple of weeks ago who was hoping to build a version of that would last 100 years but i and i i i i certainly hope he succeeds but what i can definitely see as some of the ideas you've been percolating up still being discussed a 100 years from now and inspiring new languages yeah i think it's i think yes languages are surpr can programming languages actually are an example of something that can be surprisingly long lived like cobalt is still alive and well yeah but not in a good way i think right so you know it's not it's not cobalt is no longer a source of inspiring ideas just that we have so much code written in it we have to still you know run those compilers yeah so i suspect that if you know hcol is still around in 100 years it would be not in a good way right whereas i hope the ideas might be you know visibly embodied in some more wonderful thing that we have worked out by then yeah yeah you'd hope that the ideas there are fundamental enough that they'll outlive the programs and us right which actually leads me to the other big arm of your work which is passing the big ideas on to the next generation tell me about that yeah computing education super important and a bit and we i think we as a you know as a what's the word as a professional community we owe it to not to our discipline in particular to our children to be thoughtful about what are you know what should our children be learning about our discipline and in a in a way that would make them you know empowered citizens and ones who think it's just the most exciting thing since life bread which it is and let's not put up with an education that sort of substandard in that respect which is so so i think it's there's an endeavor that we should all be involved in in some way where would you go with that because i'm thinking of my own children's computer science education it's a bit of python a bit of squeak and too much excel and powerpoint yes well it's probably a bit better than it was right so when we started computing at school c the organization that is is sort of behind a lot of changes in the curriculum the the national curriculum said you should do ict information and communication technology it was very technology focused and that is it was all about artifacts and not about ideas to go back to that conversation right and and it was often no more than learn powerpoint and excel excel if you were lucky b would so then over the the next sort of five to eight years following about 2007 we managed to re reposition the uk's national curriculum to state explicitly that children should all children should learn the fundamentals of computer science in the same way that they learn the fundamentals of natural science so that reimagines computer science not as a narrow sort of rather vocational operational skill that's useful for operating computers but rather as a foundational discipline like maths or like physics that an elementary understanding of which is kind of essential for understanding the natural world that surrounds you and being a citizen in it who can you know have some agency right some ability to influence events some understanding of what's going on ability to make informed choices and to make well judged you know well judged decisions do you think there's a parallel i mean one of the big reasons we teach children science is not so they can use a buns and burner but so they can think critically yeah and but it's not just it it's a bit more than just think critically they also need a knowledge base if you knew nothing about heat combustion mass mass velocity nothing about any of that but you were very good at critical thinking right it's just your you know your logical processes were good but you had no knowledge that wouldn't wouldn't be any good right you need to have an elementary you know understanding of how to think logically yes the scientific method all that but you also need to know some science facts otherwise how can you possibly make informed choices about i don't know global warming or about whether it's safe to replace the you know to unscrew the the front of your electric light switch yeah so in the same way i think for i i think the sort of critical thinking and you know logical thinking absolutely part of computer science indeed computers are rather good at training you to think logically because they they are so non-judgmentally but absolutely brutally cruel about exposing flaws in your logic that program just doesn't work and it doesn't say oh i feel sorry for you today i'll make it work which is good when it's controlling the plane that's about to land you yes so but so i think just as you need to i think all children should learn some some elementary aspects of natural science i think they should learn elementary aspects of computer science so that they're in a position they have enough knowledge base as well as logical thinking and skills to make well-informed choices about the digital world that surrounds them so pressingly and intimately and practically for you is that influencing the curriculum at the national level yeah absolutely it is i mean as i say it's completely transformed before it said you should learn about digital technology now it says all children should learn the fundamental principles of computer science which is a huge challenge for schools if you're a primary teacher you might you might think computer sign i mean at the time it was put in the national curriculum you know we were not long past the time when people thought well computer science that's just a university course isn't it yeah and then suddenly we say oh no primary school children should have some elementary understanding in the same way that have you know their understanding of physics is not very deep or biology right but they but a primary school teacher sees themselves as you know part of their task is to give an elementary understanding of natural science and so so it's a big challenge there because we uh it's easy enough to say children should get an elementary understanding of the principles of computer science and should have practical experience of writing programs because that's that's like the lab work of the subject if you like it's yeah programming is to computer science as lab work is to physics you know it's really important yeah it's easy enough to say that but to turn it into a practical reality you've got to say well okay so specifically what should children learn at primary school and how should they learn it in what order should they learn the concept cepts and and all and then you know even once you got that all laid out you got then got to say and how can we train teachers to be good at doing that right same at secondary school seems like one of the hardest tasks yeah so so it is so the you know that ever since 200 this became part of the national curriculum which was in 2014 computing at school this sort of g gorilla movement in in partnership with the bcs the professional society for computing this country the british computer society charter institute for it been we've been working together to answer all of those questions and the government having changed the curriculum then waited five years but eventually they did hoay find some money actual money to build something called the national center for computing education which is a national teacher professional development organization aimed at upskilling teachers and generating the teaching resources and materials and curriculum sort of sequencing that we were discussing so that's amazing that was that started in 2018 i became its first chair oh wow it's all it's all and it's on its second iteration now and i hope that there will be a third impressive quite a lot has taken place in this country which is not to say job done and not at all to say job done because it's a big job right to we are far from the the the place in which every child gets a great computing education yeah but circling back to why the audience for this podcast might i would like to say might be interested but and i and i would i would like to say should be interested is that i think this task the one that i've just described about saying what should we teach exactly you know when and how and with what materials all of that is too important to and too just to leave to school teachers to make up for themselves or even from some even if government funded guango like the national center of community education i think we as a technical community should be involved as individuals and our companies should be kind of institutionally involved in trying to make computing education into just great across the whole country in every classroom okay so i would understand if i want to if i want to move verse forward in some way i would go and download it write some code in it or download the paper and try implementing it yeah how do i i have no idea how i would get involved in moving the education of children in computing forward in the way you're describing how would someone get started in that project yeah so the uh i can give you the first step is join cass right computing at school k it's many of the members of kaza teachers but there's also you know a third to a half our it professionals of one kind okay and then there are various sort of thematic interest groups there's one on ai and there's one on primary that you could join and so joining cm go to the c national conference just becoming better informed about it there probably a a cast local community a sort of physical getting together of teachers in your area so going to one of those would mean you face to face met with some actual live teachers who are grappling with this stuff because for me it's it's not so much about doing some grand national scale thing i think what we as individuals and even companies did to do is just get stuck in locally that means that means meeting teachers and not saying no i'm going to tell you what to do but getting along that alongside them and saying and see you've got a you know a a a a exciting but challenging job here right how could i help you yeah is there any way in which i could be helpful and there is a way in which i can help without necessarily being in a room of 30 children yeah for example you could be a there's a you might be a mentor to a teacher or possibly sometimes a mentor to a child particularly at the latest stages like a sixth form yeah yeah so c has a number of ways for professional to get involved in in this kind of thing i wish i could be i i wish it was oh you can become a stem ambassador what are stem ambassadors so that's you can just google for stem ambassador but basically means someone who's sort of on a you know a national register of people who are willing to help in some way and schools will when they looking for speakers will often look for stem ambassadors and also when you're a stem ambassador they will also do all the crb checks that mean that you are you know all the legal obligations are done so you can you can go to a school right in person yeah they have restrictions on that quite sensibly exactly yes so and all that is kind of done by being a by becoming a st ambassador so it's it's it's really hard to give you a crisp answer for how to get involved because education is complicated and schools are different but you you're you're saying you've got children and they're at a particular school you could do worse than find who is who is the head of computing in the school say could i come and talk to you about what you're doing and you know can we can we talk about you know is there any way in which i or perap perhaps by recruiting others to the task could be helpful and it might be anything from well just come and give a talk about what what you do in your life yeah because many children think that computing is all about you know spotty youths in in windowless basements staring at glowing screens right but actually it's a rich diverse creative discipline which people do lots of different things and you your your you know role as a podcaster is very different to the you know the spotty person in a bundus room writing weird weird cod right you're a professional communicator right so the computing is a very diverse profession so that's one one thing that a teacher could find helpful right because they want to give their if they say to their children look it's an interesting and diverse profession that go yeah yeah yeah right but when a person comes and can speak in a you know persuasive and articulate way about the richness of the subject and all the things you could do that's much more compelling yeah yeah yeah okay final question because this is an international podcast is are there do you know if there are equivalent organizations in say america oh yeah definitely all around the world so so just to say cass is uk trick but you can definitely join cass from anywhere right so i have quite a few international members so that's and that just means you have access to you know you can talk to other members of the community it's we call cast a community of practice right it's but think of it like here's here's a good model it's like an open source project right so right if you if you i don't know subscribe to the economist you pay them a subscription in exchange for a service if you join the ghc open source project you don't pay anything you bring the contributions that you have which you give for free and in exchange you get the you know richness of the community they there you get to you know get all of the free stuff that that group of people has produced right so it's not it's the one is a transactional exchange the other is more a shared community grassroots bottomup gift economy yes c is the gift economy model right very much it's not a subscription you pay to get a service you just become part of a community and then and of course that means you make of it what you can so going back to your international question so so people abroad who can you know can still join cass and and anywhere there will be a local version and well probably you if you're in particular country and you need help finding out who then i can probably help you because i've talked to people in lots of different countries at various times but in the america there's something called the computer science teachers association csta which is a sort of equivalent of cass a little bit more teacher centric than than casses but sort of equivalent of cass in the usa and i think in every country there would be this activists who are busy trying to do exactly what c is trying to do here cool okay i'll put links to all of that in the show notes and hopefully some listeners will get involved yeah that would be great i mean i think it i do think it's a it's exciting and rewarding because everybody cares about education right you could can't find a person on the planet who says well education who cares just doesn't matter right well maybe there are a few but not many right so and also for everybody listening to this podcast you probably think you know computer science programming this whole world this is just the most exciting thing that's why i've devoted my professional life to it happily it's well paid as well right so yeah so i just want to share that oh and you also have a strong idea of the you know the richness and depth and excitement of the discipline i want to share that with our young people so they don't get the wrong idea and so that they do have plenty of input and opportunities to you know find good on-ramps into computing as a you know so so that all of them end up well informed able to make good judgments and some of them end up particularly underrepresented groups like women find it you know find a a pathway into computing as a discipline because i think we need lots of people there and the better informed the better yeah absolutely and we need to help we need to help we can't just leave it to the education system to do they they've got the message they're trying hard but they're educators right they they need the subject they need subject expertise and that's us that's us yeah good okay ideas and education a perfect note to end on yeah great simon pton jones thank you very much for talking to us it's been a lot of fun thank you right simon thank you very much if you want to get involved in cass in the uk or csta over in the state there are links to those organizations in the show notes and if you're not in those countries but you know of a similar organization in your country please drop me a line i'll gladly add the links for wherever we can how do you drop me a line you look in the show notes my contact details you can find me on twitter linkedin masteron you can leave a comment if you're on youtube you can leave a like if you're on youtube rating if you're on one of the audio ones you can subscribe and rejoin us next week or you can share with a friend and share the love and knowledge what else is there to say i have started scratching out an evaluator for functional logic programming in pur script of all things i make no claims about how far i get but it's good brain food and i've been enjoying it so if you want to do something similar you'll find a link to simon's paper that explains it pretty well for an academic paper well from an academic paper in the show notes and that should give you plenty of brain food and if you want it plenty of homework until next week i've been your host chris jenkins this has been developer voices with simon pton jones thanks for listening