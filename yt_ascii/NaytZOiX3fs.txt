okay so i did see this tweet i saw this tweet right i saw this thing right here where it's just like you you don't use 10% of your brain do i use this and so bend is apparently a simple a simple language that allows you to write feels like python but also scales like like cuda need a sorting network just write a function vim sort. bend sorting network oh gosh come on let me see it need a fragment just write a function i wish i could pause this let's look at this for a second because this looks pretty cool all right so let's see def sort tree this this this and this rots i don't know what rots are hold on hold on hold on ds okay damn it it looks like python which means there's no type so i have no clue what the hell's going on here d is zero that must be depth which is the tree sorting network equals just rotate trees okay okay tree equals xy so that must be left and right so this is a binary tree left is sort depth minus one okay so we're starting from the bottom with x s is zero i don't know what s is where is s even used here oh s must be is used in this r in this rots right is d minus one okay i don't really i don't quite honestly to tell you the truth i don't really get it i don't i don't really get this function there's like a warp a down i i i don't know what we're doing here rotate so this must be a well-known algorithm that i just don't that i don't i know but i just don't get it okay well it sounds cool i just don't know how how would you parallelize this that's my question is how is this parallelized that's what i want to go find out and so let's see if this let's see if this thing does it because there is a fireship video which we'll look at here shortly but i want to know can i understand this from this perspective shaders are always just shaders have always just been magic to me there you go here's a bunch of math you do it on a per pixel basis right dude i i've never understand create a pixel tree why is everything a tree are pixels trees create a pixel tree bend d equals zero and i oh is bend where okay is that is that how you say hey this thing is going to be a color go okay i don't know what go does and it i think it has a a definition of go so we don't know what go does need a fast map reduce just write a function okay i i mean i love this idea by the way that you can just go lambda do this this one map red bam bam bam and you just go and it just does it and it it it makes it multi-threaded i just don't how does it do mutations cuz that original tree one does a tree sorting how does it do mutations i don't understand that interesting okay let's go back to let's let's go back to the github repo and because i mean honestly this feels like v you know what i mean this feels too good to be true i don't know if you've ever seen this but whenever i see this things it always just feels too good to be true so i just feel like it's a lie i'm sure that's just me being jaded right because here here's the thing that i don't understand is how did they make it so whoever made this language how did you make it so simple to be massively parallel with mutations especially when something like mojo is trying to do the same thing it's totally real okay it's totally real right like mojo's attempting to do the same thing a fearless parallelism i know i fear fear parallelism okay i fear it mojo is different though well i know mojo of course mojo is different but mojo is attempting to make python fast as well i know don't worry we like to look at the github thing okay it it makes it more fun to start with the github thing and like and and and read about it and and have an idea going into it you know what i mean so it must be things that run on the cudas right if you want to use the c runtime install the c compiler okay if you want to use the cuda runtime install the cuda toolkit all right all right then install both hvm 2 and bend with this one okay cargo nice okay nice rust mentioned rust mentioned then finally write some bend files okay uses the rust interpreter wait what wait what uses the c interpreter parallel uses the cuda interpreter massively parallel okay interesting interesting you can also compile bend standalone c cuda files into gen c and gen cuda for maximum performance but keep in mind our code gen is still in its infancy it's nowhere near as mature as so these nuts compilers like gcc and ghc interesting interesting interesting all right let's read about this parallel programming and bend to write a parallel program and bend all you have to do is nothing other than making it inherently sequential for example let's see cannot run in parallel because four depends on three which depends on two yes let's see can run in parallel and that can run in parallel are independent and it will per b's fundamental pledge everything that can run in parallel will run in parallel interesting okay okay let's look at the tree example there we go for a more complete example here's that tree thing which i just don't understand this file implements the batonic sorder with immutable tree rotations okay so there you go so it creates copies there you go that was see okay that was my question was the was the copy was the copy it is not the kind of algorithm you'd expect to run fast on gpus yet since it uses divide and conquer approach which is inherently parallel yep bend will run it in multi-threaded so the benchmarks 16,000 threads oh my goodness that's just just mindboggling these nuts that's a 50x a 57x speed up doing nothing no thread spawning no explicit management of locks mutases yes by the way they're called mutases which should be close they really should be called m mutil lisks okay because you think you like muisk and you know you just can't have one so you got to have like thousands of mutil lisks but then one effing threadlock ie whatever you call those raven bombs just destroys your entire your just entire fleet every single time that's called why it should be called the mutases this is why mutil lisks mutes same thing it's a trap learn python oh let's see what are your thoughts on mdd meme driven development shockingly htm x felt like meme driven development and it actually wasn't it turns out it was actually it was actually it's actually just real it's just real development i hate bench marks generally i dislike benchmarks because i don't know what any of these things mean but it's cool that it like i like relative benchmarks which i think is i think relative benchmarks are very interesting i think absolute benchmarks are stupid like i wouldn't go into this thinking i'm going to get something that's super fast what i can say is that doing nothing other than changing where you run it it just gets faster because relative makes a lot of sense cuz then i can i can compare this against this and be like yeah that's this shit's way faster though why would you do relative benchmarks relative benchmarks show that this like that long as you know long as they're comparing the output and proving that the output is sound that you get a massive speed up a practically 100x speed up by just swapping over into this right so that's really cool but a bend isn't limited to a specific paradigm like tenters or matrices any concurrent system from shaders to llang actor models can be emulated on bend for example to render images in real time we could simply allocate any immutable tree on each frame okay so i wonder i wonder what the gc is like i would like to see more on the gc and how what how that runs because that's i guess that's my big thing is how are they doing memory allocation it let's see it would actually work even okay so this is that that demo shader which is pretty interesting even let's see even involved algorithms parallelize well on bend longdistance communication is performed by global beta reduction as per the interaction calculus and synchronized correct corly and efficiently by hvm 2's atomic linker interesting okay it is very important to reinforce that while let's see that while ben does what it it was built to scale performance with cores up to 10,000 concurrent threads its single core performance is extremely subpar okay yeah this is the first version of the system and we haven't put much effort into the proper compiler yet that makes sense i think that's a good i think that's a great great approach by the way great approach right here you can expect the raw performance to substantially improve on every release as we work towards a proper cod gen including constellation of missing optimizations yeah meanwhile you can you can use the interpreters today to have a glimpse of the massively parallel programs look like from the lens of a pythonic highle language this is a super promising language if this is real i guess there's two things we could do one if if the person who is in the chat is in the chat we could get whoever the creator is to give us like if if they would like they could give us like a a a five minute explanation of how this is accomplished and all those things cuz it sounds like it's all immutable so it's all it it works via allocations like you can do anything that's parallelized via allocations if i'm not mistaken and are the allocations are they like r seed are they all stack allocations for that for like the tree sorder how does it work with heap allocations is it a is it a garbage collection i don't know pr i would literally never make my own language is it hoarding memory is it a bump allocator just let it go straight to the universe i do not know right there's like there's a lot of questions there that i think it it mentions rendering and shaders it does me it does that it does do that yes okay so this was really cool so let's just check out the fireship bend video okay nice nice yesterday the clouds opened up and a weird new programming language came down to earth with a promise of parallelism for alou who writeth code this is big if true because parallel computing is a superpower it allows a programmer to take a problem that could be solved in a week and instead solve it in seven days using seven different computers unfortunately running i mean that's typically how parallelism ends up happening parallelism is extremely hard that's why this language is so interesting is that it is crazy to think that there is something that could actually solve the parallelism problem right it is it is wild is always on point banger absolute banger meme right there code in parallel is like conducting a symphony one wrong note and the entire thing becomes a total disaster but luckily bend offers hope by making a bold promise everything that can run in parallel will run in parallel you don't need to know anything about cuda blocks locks mutexes or regex's to write algorithms that take advantage of all 24 of your cpu cores or even all 16,000 of your gpu cores you just write some highlevel python looking code and the rest is magic it is may 17th 2024 it feels untrue that's what i mean like because it just feels so amazing that that that this could possibly exist it feels untrue i i'm curious what the rules are and how how the rules are going to play i'm also curious why i guess i'm not too curious why it went with python style syntax it just makes sense right if you're going to make a language like this that you want to be massively parallelized and you want it to really i mean your your your target is going to be machine learningdata scientist and so it makes perfect sense that it exists that it exists in this python yeah i'm curious about the edge cases like what breaks parallelism and you're watching the code report when you write code in a language like python your code runs on a single thread that means only one thing can happen at a time it's like going to a kfc with only one employee who takes the order cleans the toilets and cooks the food in that order now on a modern cpu you might have a clock cycle around 4 ghz and if it's handling one instruction per cycle you're only able to perform 4 billion instructions per second now if four gibs is not enough you can modify your python code to take advantage of multiple threads but it adds a lot of complexity to your code and there you know the whole thread start thread joint thing this is just so difficult called you know i know this looks easy and every why is every single multi-threaded application example so simple but every multi-threaded actual application is so dang hard it's just it just feels it feels emotionally damaging every single time every single time you like but i remember i still to this day remember my very first four years into multi-threaded programming and it always felt so easy it's just like look you just do this you just do this and then you just join it at the end and i'm like ah that seems pretty simple that seems straightforward and then i actually do it and i go this wasn't straightforward at all and i don't know what's happening and now i have a synchronize everywhere in my java code you know it's just it's just it's just the worst it sounds like skill issues it is skill issues because it's effing hard i don't have the skills to pay the bills on threads okay and debugging is awful debugging is always awful there's all kinds of gotas like race conditions deadlocks thread starvation and i mean deadlocks are still completely available in in async a i the rust asyn a we because rust async a we is pull versus javascripts push you you run into deadlocks because you don't know what you're doing you know the worst part is is in like especially in rust if you have an error that you just simply want to ignore you do an under you just simply assign it to underscore the problem is is that as you're programming and then you change the api the api to a weight or to an async function and then you don't realize that your underscore assignment also will ignore async and it won't give you a warning and then you just explode you have no idea why and you're deadlocking for days and it's just like oh man oh man oh man that is just there just just just the worst it's just the worst for those that don't understand it it's the uh main rs right where you have something that looks like this what is it funk main me daddy and then you have something like what is it async fn fu that returns a result you know i don't know why not there we go and it does this and i don't even have an lsp so i don't even know why it's doing this right so we'll just go like this okay right there we go we return that and you do fu there we go so by doing this it's going to call it and it's going to just simply ignore the fact that this is a future and you have to you have to await it if you don't await a future it it don't work and so it's like that will just simply ignore it and so i've had so many times in my life where i was programming something realized i need to go to async because again every single time you're in the world of async you have this whole problem which i think we all know about this whole problem but just to make sure we all do we go to ryan winchester's profile and look at his pin tweet right here you have this whole problem where you have all of your functions come together one of them's async and now you got all of them async all of them become async immediately you forget you've done that you've ignored an error and boom you've now just ignored an async call and now your acing call never runs and then you're emotionally bruised every single time every single time oh my goodness i just hate it anyways it's happened once before that's why i actually never ignore errors now i like the the underscore assignment was a mistake i think it was genuinely a mistake in rust because it can lead you into this why don't you just have all your functions be acing shut up marcos red starvation and may even lead to conflicts with demons even if you do manage to get it working you might find that your cp just doesn't have enough juice at which point you look into using the thousands of cacor on your gpu but now you'll need to write some c++ code and likely blow your leg off in the process well what if there's a language that just knew how to run things in parallel by default that's the promise of bend imagine we have a computation that adds two completely random numbers together in python the interpreter you can tell he's a man of culture okay you can just see the man of culturing right here totally random numbers completely random culturally appropriate numbers together in python the interpreter is going to convert this into b code and then eventually run it on the python virtual machine pretty simple but in bend things are a little more complex the elements of the computation are structured into a graph which are called interaction combinators you can think of it as a big network of all the this guy writes askal you can just tell right away zero information about the person but from the github said the word calculus and i didn't see any integrals and then also here we see the word combinator again this hasal mentioned this is hascal mentioned for sure this is hasal mentioned pick pick is ben here big fan here thank you white papers mentioned white papers are happening as we speak computations that need to be done when two nodes run into each other the computation progresses by following a simple set of rules that rewrite the computation in a way that can be done in parallel okay so if you're tip to tip you becomeing infinity but if you're tipto tip fully colored in you become two lines but then if you're tip to tip but one's only full then you become definitely the infinity sign just poorly drawn i don't know what this means i don't know i this pattern until all computations are done it then merges the result back into whatever expression was returned from the function this concept of interaction combinators goes all the way back to the 1990s and is implemented in a runtime called the higher order virtual machine hbm is not meant to be used directly and that it is above your pay grade i must say that at this point in programming since i've never i've never been a big lambda calculus dork i i i just don't understand these concepts or even the vernacular behind it you know it's it's like that guy that doesn't have compiler experience and walks in and keeps calling everything a compiler when it's a transpiler but then when you actually get around people whose like job it is to write these things you know how vacular bothers them when you use it incorrectly for me i'm just like l to calculus what the [ __ ] is this right and they're like well you're not using the terms right you know and people understand like people will start being like ah you're you know i can tell you're new and you can tell i'm new because of that this ism is not meant to be used directly and that's why they build bend a highle language to interface with it and the language itself is implemented in rust you can tell right away that's why it's so good tax is very similar to python and we can write a hello world by defining a main function that returns a string now to execute this code we can pull up the terminal and use the ben run command by default this is going to that's single threaded rust interpreter correct yeah use the rust interpreter which will execute it sequentially just like any other boring language but now here's where things get interesting imagine we have an algorithm why aliens why aliens pre-at come on it's because i read the github this is why we read the github first okay because the next one is then if you build it with a c you get to run it on all of your little nodes and then if you build it with the cu the c the cudas you get to run it on all your cudas get interesting imagine we have an algorithm that needs to count a bunch of numbers and then add them together the first thing that might blow your mind is that bend does not have loops like we can't just do a for loop like we would in python instead then has something entirely different called a fold that works like a search and replace for data types and any algorithm that requires a loop can be replaced with a fold basically a fold allows you to consume recursive data types in parallel like a list or a tree but first we need to construct a recursive data type and for that we have the bend keyword which is like the opposite of fold now if that's a little too mindbending maybe check out my back catalog okay so i actually got lost in the sauce there for a second i'm not going to lie to you i feel like mark i feel like mark cuban right now and being like oh you said fold therefore i'm out and i'm not g and i'm not going to lie to you when i saw all those cans going might have got might have got a little distracted by the cans as opposed to what was actually happening okay so a fold i feel like i get a fold is just a function that produces out a fold is just reduced for the those that are just javascript kitties that's all it is fold is just simply reduce and this is like your seed value typically is the one right here and then you you you like go up it right it's just going over a list reducing it it's it's a i believe they use the term opposite thing the bend is a value that goes into a l i'm not see that's where i i i start losing it you can't use wrinkle brain vocabulary on twitch you really can't use wrinkle brain vocab can be replaced with a fold basically a fold allows you to consume recursive data types and parallel like a list a recursive data type yet just like a list it's something that you can walk across via recursion to get to get to the end of okay which means you could also use a tree you could also use a graph with a a dfs okay okay i think we're starting to see it confirmed pict was a mistake confirmed pick is a mistake list or a tree but first we need to construct a recursive data type and for that we have the bend keyword which is like the opposite of fold now if that's a little too mind-bending maybe check out my back catalog for recursion in 100 seconds but now let's see what this looks like from a performance standpoint when i try to run this algorithm on a single thread it takes forever like 10 minutes or more however i can run the same code without any modification whatsoever with the bend run c command when i do that it's now utilizing all 24 threads on my cpu and now it only takes about 30 seconds to run the computation that's a huge improvement but i think we can still do better because i'm a baller i have an nvidia rtx 490 and once again i can run this code without any modification on cuda with bend run- cuu and now this code only takes one and 1 half seconds to run and i'll just go ahead and drop the mic right there this has been the code report thanks for watching and i will see you in the next one very cool okay okay so this looks totally awesome and i absolutely think it's fantastic but i do want to say something okay i'm going to say something and i hope that you guys don't get upset at me everyone virtually in this chat will never use this language let me tell you why this is the case this is the case because this language is specifically designed for people that have what we refer to as an adult education in mathematics okay you most of you guys are a bunch of front end andies right in react like this isn't going to come to the front end and be useful like that this isn't going to come into your server and be just instantaneously useful on your server okay this is just going to be useful for people performing like linear algebra and all that stuff and they just want fast python they want loops that don't suck ass and that's called pandas or it's called c this whatever this is okay i don't use it either this isn't going to be useful for me either okay i it's it's absolutely super duper awesome and the speed and the glory of it is fantastic and the fact that you can use the term calculus and not use an integral at the exact same time makes it just mindblowing for me okay i don't get it but that here we are here we are doing these things and it just feels fantastic it feels amazing when you look at this language you think how could this not be the language we all use this is truly the lord's language it requires folds and bends and [ __ ] in reality that does not make any sense and yet here we are realizing that all we're going to be doing is writing simple stuff on the front end or the back end and it's just not going to be for you it's not for you it's not been for you it not it will not be for you in the future so just be okay with it okay instead learn rust learn go learn javascript learn o camel learn elixir learn swift and enjoy your day okay the name is i'm sorry but this is fantastic but at the exact same time you'll probably never use it again but by the way there will be people that do use it and they will love it and it'll be fantastic just not for your use case okay just probably use elixir or something like that