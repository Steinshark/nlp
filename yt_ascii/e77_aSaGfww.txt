okay i think we are online again so just go ahead with the agenda i think okay so i'm sorry for sorry for the inconvenience no no no no issues it's best at the beginning so now you hopefully see the agenda so we'll discuss why we need concepts what are they how you can use them as constraints how you can use them with functions with classes how to write your own concepts and then we will see some real life examples although well concepts are quite new so we are we don't have so many examples we don't have so many real best practices well we'll discuss about these a bit later so first thing first why do we need something like concepts and here i ask a question did you see that i moved forward i moved forward with the slides i keep an eye on the chat in the meanwhile so problem is that overloads they don't scale so let's say that we want to write a very simple function just for the sake of sake of the example so we can keep it keep it short we want to write a function that adds up two numbers well we might want to add that integers we might want to add up some doubles and we have to we have to write different overloads so you might have a lot of types to to support and what are you going to do i mean it's tedious to to write all of them and although like writing a lot usually it's not a real not a real bottleneck when you write the application still the verbosity is bad because it becomes difficult to maintain if you have to change the logic at one place well you have to change it most probably everywhere so obviously this is not a good solution and i haven't said anything new with that so you might think that okay then we can use templates and probably it's better because then you have to write one single implementation that's good you can add up your your integers you can add up whatever floating point you want but you will just accept everything without any constraints so in this example we add up two characters and what do you expect this to be i mean probably probably you know what it's going to be but it's possible that you expect something completely different it might be that you expect that instead of one character that is somehow were summed up from a and b would expect a string but then well it will be deceived because that's not the case you might have some potentially unexpected behavior and it's quite probably that's not what you wanted so it would be good if we could constrain somehow these these implementations and actually since c plus plus 11 we can forbid template specializations so let's say that you don't want to allow that strings could be added up so you say that the specialization with string is deleted well fair enough it will it will give you an error it works but it doesn't really scale so if we go back to the to the first example with the overloads it's pretty much the same problem here just from the other side there we had to write everything to be a load but here we have to delete everything that we don't want to allow and that's again tedious so you might say what about titrates and aesthetic assert well you could use static assert and [music] it it it works hopefully you will have even some better error messages i say hopefully because well we provide some part of the error message so hopefully we write something meaningful there and this is better than the previous solutions i think because we have less overhead we have everything at one place but still these requirements are are hidden because it's still in the body of of this template function it's not at the top well in this case it's at the top of the implementation but that might not be the case all the time and it's not easy to to reuse it in in a meaningful way so it's still not let's say not the best solution here well we could go into more details about how to use std enable if and svena but well we don't have the time for that and i mentioned in the beginning that we i meant this to be a more beginner friendly talk and svenay doesn't really match that requirement so the next step we arrive to the concepts which will pretty much save us in this situation because you can write your constraint sorry your concept in a quite concise and readable way we'll get back to the to the exact syntax later on so we can say that you have this concept number and it must be either an integral or a floating point now if you know which stb integral and std floating point are already concepts themselves so it's this is a combination of concepts i know this is not a good concept you might think that well we'll accept not only numbers i know bear with me it's for the sake of example for for the time being so you define this concept and you can put instead of the type nameless concept in the template parameter list so you you can already constrain [music] in a very readable way your accepted types so it is readable you see that it's easy to reuse because you can put concept even like this concept number either in even in a separate header and then you include it where you need it and well you just say that you need a number in your template it's very reusable so therefore it scales well and it makes your code much safer because it will be easier to to constrain what types you want to accept in your different templates we are going to see exactly how that works so we saw that what problems what's main problem concept souls and how they can help but and now let's see a bit more in detail what are they so c plus plus 20 has been a big release and there are many small and useful things in it but often we refer to it like okay it has four big building blocks you have the ranges and i think it was yesterday morning tina gave a very interesting talk on how you can you can rangify your your code then we have modules and i think that tonight with with gabriel we'll have a really interesting ask me anything session mostly about modules we have crew teams and finally we have concepts that's what we are talking about here so concepts are an extension for templates but maybe maybe extension is not even a good term i heard a talk from vienna where he said that well he was dreaming about concepts for for decades and he sees them more like a completion of templates rather than than an in extension way you can you can see them as compile time booleans to validate to validate template arguments and you might have seen this syntax where you say that the template type name t bool concept and then you have the name and the expression well if you saw this this is not the case anymore it was in the technical specification of concepts but when it got standardized the committee moved into another direction because well they agreed that bull can be omitted because if we all accept that it's always a compile-time boolean then we doesn't have to we we don't have to say that that concept is a boolean we just know it is and even in the core guidelines that is a bit still based on the technical specifications you will see names written in in camel case but with the with the standard the committee moved into another direction and if you have a look at the standard library you will see more the the snake case syntax so concepts you can you can use to constrain your template arguments you can constrain what kind of types you want to to accept and therefore you might say that the concept can be used as a constraint and we'll see that basically a concept is a set of requirements on on the public interface of the accepted types so concepts can appear at different positions you will will discuss each in detail for a time being i just want to show you these these different positions and i use a function template for that so it can come as we already saw in the template parameter list instead of the type name we can use it as a type constraint often we call it like a shortened notation you can use it in a requires close that that comes after the template parameter list you can use some constrained placeholder types in like abbreviated function templates that you will see we use it as a concept name auto i will detail why we need both the concept name and the auto and you also have the trailing requires close that comes after the cv qualifiers so now that we had a brief overview let's see four different ways to use concepts with functions i want to remind you that if you don't like if you disagree with this concept number because it's incomplete it's not let's say not correct i know bear with me we'll discuss how to fix it at the end but it's something short and easy to use for for the examples so we have this concept number and we say that we accept any integral or floating point numbers and first we are going to use the requires close so how does this look like you have the usual template type name t part and then we say we require that t this t parameter must model the concept number so it comes after the template parameter list and you can write here euro well whatever concept to to be satisfied but you can even combine concepts here you you don't have to use one single concept you can write their combinations so basically i just inlined the the body of the concept number and i put it there it works but you can put there are more things you can use tie trace you can use any boolean expression or basically any compile time will use with the with certain limitations that that we'll discuss and then the function calls are just as always but with a bit better error messages so this is a quite basic example i put it here green when we try to add two and three because it works and the the second one this red one it it doesn't compile because two and three dot fourteen they yeah they are different numbers and as they are different types and as the compiler tells us well these types are conflicting for the one single parameter t so it doesn't compile this might be a quite simple example for showing that error messages are quite readable more readable than before but later during the presentation you will see some other error messages and you will see how much detail the compiler gives you how it couldn't couldn't satisfy certain constraints of given concept then we move to the trailing requires close when the requires close comes after the cv qualifiers and apart from that it's the same as the normal requires close there is no big difference here but i have to mention it's a very true for the requires close and for the trailing requires close that this supports here is the combinations of of different concepts and constraints and multiple parameter types because in the previous example when we tried to add two so an integer and a double we saw that it didn't compile so if you want to make it compile with those numbers then you have to make sure that you have two template parameters which are of of different types but this is not new it's not introduced by the concepts but what is important that with the requires close and training requires close you can support that but with the constraint template parameter when when you put instead of the type name the concept name it's a bit different okay so you have no more requires closed that's why we also call it shorthand notation because it's simply shorter because we just simply replace the type name and you can still have the multiple parameters but you cannot have what you cannot have is the combination of concepts you cannot write here that well i accept any t that is either an integral or a floating point it is not possible you must use here a named concept and that's also the case for the abbreviated function templates so here you don't even have the template parameter list you simply write the concept name auto and you can use it for the return value as well that's something you can also constrain so no requires close no template parameter list it's very concise and you have to say concept name auto you have to write concept name i'll join the parameter list because otherwise you have no idea if if you expect there like whatever type or a concrete type you don't know if it's a function template or or a normal function that's why you have to use both the concept name and the auto and i refer to the core guidelines wherever it is possible wherever it makes sense so we should use in function templates whenever possible concepts because it documents or code already it documents what kind of types do we expect it makes it safer it makes it more maintainable and in this case unlike for the previous examples the parameter types can be different so before when we said like okay t must be a number and then you just use the t as a parameter type well for all the parameters you need the same types here they can be different in fact here you cannot really say that a and b must be of the same type and again here you cannot write an expression instead of the number a complex expression how do you choose among these four different ways because that's a lot so if you have a complex requirement and not in a named concept oh sorry then you choose requires for trailing requires where you can write completely what all your constraints if you have a simple requirement then use the abbreviated function templates that's what the core guidelines also suggest to us well if you have a simple requirement you want to keep it short and you want to control that the binded types of the parameters are the same so both for example both numbers should be an integer then you can go with the shorthand notation with the constrained template parameter you might ask well are these different or are they the same and i use cpp inside to look under the hood and they are pretty much the same so you see that ed requires close is the same as the add constrained template the the shorthand notation compiles to the same same code and when you use the trailing requires close it's almost the same for some reason we saw the requires the trailing requires close even after running the cpp inside but this doesn't make any difference to the code there is one expected difference though it's with the abbreviated function templates you see that here you have two template types whereas previously you had only one and you have two even even if they are the same because the number out to a and number of to be they have they are handled as two different template types so this is the only difference but this is something we expected now let's see how to use concepts with classes so we have a bit fewer syntactical choices because well abbreviated function templates are for function templates they wouldn't really make sense here and we can use the training requires close only in certain circumstances we'll see but when you want to to use a concept when you want to constrain your class itself as a whole well it doesn't really make sense there to use a trailing requires those well one it's impossible second why would you put it at the end of possibly a long class so what we have is the requires close you can see here that it's something that we can use pretty much the same way as for function templates it comes after the template parameter list so here we have our wrapped number class which has this template type t and we required that t must model the concept of a number so it's it's fairly simple and again here you can write any complex expression that you want you have also the constraint template parameters available for you so if you want to write something shorter something even more readable then you can omit the type name and instead of the type name you can you can put the concept that you want to model it's that's very very nice but here you cannot use complex constraints for that you must use the requires close and then we are going to use a bit the training requires course because you can overload your functions in in a template class by constraints so let's say you have this class mic number where we have a templated parameter t and here we provide two implementations two overloads if you like for the divide function one for integrals and one for floating points so this comes quite in handy when you want to to to specialize your template classes behavior based on some some type characteristics type traits and i have an example for for that it's a bit a bit longer [music] i hope this is this is still readable on your screens but here we have a simple concept car it requires that the type that models the car concept has a start engine and an open door methods and we have another concept which is based on the car concept in a in a sense that it uses it and it adds some additional requirements like if your car is convertible then it should have an open roof method and then we have this class template for the verification driver who wants to be able to cruise with his or her car and only if this type c which should be a car okay if it's also a convertible then you should be able to open the roof so then we have an suv which well it's not a convertible so it only has the open door and and the start engine functions and when you try to call open roof on this the 3d vacation driver here then we get a compilation error because well we have an invalid reference to this function open roof it's not part of location driver suv because it's convertible is not modeled by suv so now let's see how to write our concepts we're going to start with a simple concept probably with the simplest concept that you can imagine we call it any because it accepts any type because it's always evaluated to true so what did we do here we listed all the template parameters well in this case only one and then after the keyword concept we put a name meaningful name in this case it's any and then we list the requirements here we have none that's why we put only true there so what kind of requirements can we expressed because as you imagine we want to express more than simply true we can list our expectations on the public interface we can list our syntactic requirements but when you write good concepts and i think community still wants still tries to figure out what good concepts are because one we don't have the experience with them to it's hard to make a concept right at the first iteration you want to express also semantic requirements and that's something that the core guidelines already suggest us that we should avoid concepts without meaning full semantics so i put here another example where we have some let's say clear synthetic requirements but the semantics are not really there yet so still we tried to ride this concept car where we have an open door a closed door starts top engine we can accelerate we can break and then we have a tank well i didn't put here the implementation but you might imagine that the tank has a door so you can open it and close it well i never throw one but i imagine you can definitely start its engine and stop it you can accelerate and brake with it so when you want to make sure that the what we want to test whether a tank models a car or not well it will work it will model it but [music] we we can agree that this is not the best concept because a tank is not really a car so syntactics are important but semantics should be also important when you try to write a good concept what we can do is also to combine already defined concepts that's what we do in our concept number we try to combine integrals with floating points so we accept both integrals and floating points in the concept with the concept number and the core guidelines suggest that whenever it's possible we should use standard concepts it's pretty much the same logic i would say that for the standard algorithms goes because well these concepts are well taught through well at least much better than a concept that we would write right now they are well tested they are tested by the whole community and they are simply better just like most probably an algorithm will perform much better much reliable much more reliable than a row loop that you would write yourself so we can also combine obviously user-defined concepts just to mention and we can use them in any logical combination you see here a small asterisk i say any but well there are some things to to consider so what does combining concept mean concepts mean and what are those things that we have to consider so the end and or so conjunctions and disjunctions are definitely okay you can free to combine concepts you can combine boolean literals expressions you can use type traits you can use another requires expression within within a concept we'll see how to do that but you have to pay attention when you want to use negation with negations it becomes a bit tricky so what does the exclamation mark say to us so for boolean expressions you would expect that well whatever is in your expressions all the sub expressions should be well formed they [music] should compile they are compatible and well they might return false and that's how you can use their the negation but for concepts it's a bit different well you might expect a false but a false doesn't necessarily mean that it's evaluated as a boolean to false it might be your formed code and still the rest of the concept might still satisfy the whole expression what does this mean let's have a look at an example why the opposite of true is not necessarily false as we imagined as we thought about false before so here we have another template function foo and it has two parameters t and u and in or requires close what we say that either t should have a blah nested a type that is unsigned integral or you should have this blood that is inside integral and then okay we just have a class here where really has this unsigned intel with the name plus so we can satisfy the the requirement and we pass also 42 plain integer with this compile it compiles because whatever you put here in the requires close it doesn't have to be compilable so when you pass in my type well it does have a blah which is an outside integral and then we pass in 42 which we put here instead of the u but it doesn't have it doesn't have obviously at la so this wouldn't even compile yet these requirements are satisfied so we can expect let's say usual boolean false here it's possible if we cast explicitly to bool or with another way that i'm going to show so one way to require that both t and u should have a blah and one of them should be an integral is to cast this expression explicitly to buu as we discussed with with the people who joined the book fair for the c plus concepts book we discussed that this is quite let's say implicit you have to really understand this behavior you have to know what does disgust mean there it's not very readable so you have a bit more verbose but but more expressive way to tell this so we use requires expression within the requires close sometimes we call it as like a nested requires and we make sure that both t has this nested type la and u has domestic type la as well so we have a conjunction here we have an end so both should return true both should be true and then it should be also true that one of these should be unsigned integrals so i know usually we try to go with a shorter code but here i think it's really worth to write it a bit more verbose because what you have on the right side i think it's much more readable than what you have on the left side and now let's discuss how to find the most constrained constraint before we go back to write our own constraints so we have to say a few words on overload resolution it's always the most constrained candidate that is the best and a more constrained concept is based on another one like we saw with the car and the convertible the convertible was more constrained than the car because it was already using the car and it added some extra constraints and when you have multiple different overloads with the same priority then the compilation will fail will fail because of ambiguity and the compiler will always well automatically choose the right path based on the template parameter types characteristics so here once you see that we have an overload where we say that k should not be smart in the other one we say that k should be smart so this is not the way to go you should not write this and the the core guidelines also reminds us that we should avoid these complementary constraints because it makes our code more brittle so it's okay in fact it's not just okay it's better to have a generic overload and a constrained one you don't have to write the complement of it but it might happen that you have more than two overloads you have let's say three overloads or even more and then the compiler will choose the most appropriate one so here we write some constraints on the key on this class ignition so we have a generic one we have one where the key should be smart we have another one where the key should be also smart and personal and via subsumption rules the compiler will choose the the good one here we don't have the time to go into details into the subsumption rules if you want to read a good article in it i would i would recommend to you to go to andreas fertig's blog and and check his article on subsumption rules here i want to mention one interesting things that one interesting thing that negation again it's with the exclamation mark it can bring ambiguity and if you want to rely on the substantial rules because you have multiple overloads you cannot simply use the negation because the compiler tries to evaluate these expressions this requires expressions and it checks where from where one originates and well while it could deduce that this smart key is the same as this smart key but when it comes with the negation it takes the whole what you can find within the parenthesis it takes the whole as a new expression for the compiler the not smart key in the second overload and the not smart key in the third overload are something completely unrelated therefore it's ambiguous and this one wouldn't compile on the left but under if if you want to rely on this if you want to use such constraints you have to name your concepts you have to name the negated concepts and you could write your concept not smart well it would be its body would be really simple it would be what you have on the left side so it's not a smart key and then it can deduce that what you have in the second overload not smart key and in this in the third overload they originate from the same place therefore it can subsume them and it can decide which overload it should it should take if you are interested in more substantial rules go to that article i will check i will share the link later on so let's go back how to write those concepts how to write first some simple requirements on the interface so what i call this is wishful writing just write down in the body of the requires close what operations what function cause do you expect to compile what should be compilable and in the perimeter list of the requires closed like it would be a function parameter list you can just list all the types that you will need and if you have some parameters so we expect for this test concept that whatever type that satisfies it should have a method power that takes an integer as an exponent you have to list that okay we'll need an exponent that is an integer it's it's that simple it's really just visual writing there you can you can write some requirements on the return types we often refer to this as compound requirements and basically you can restrain you can constrain the return types with with two concepts that is shipped with the standard library one is to convert a bill two which takes two parameters from two and the other one is stood same as and then you can write your your concept in a way that between braces don't forget the braces you put what's going on you put the sorry i think i lost my my mouse so you put between the braces the the function call and then after an arrow you put your your constrained liter type so in this case you expect something that is convertible to an integer if you are familiar with the technical specifications for concepts that i think was released in 2016 if i'm not mistaken you could use the bear types there you could write simply as an integer but right now you have no bear type for you cannot write bear types anymore because of future generalizations you can express some type requirements so you can express that a certain nested type should exist something that we already saw with that la example you can say that the class template specialization should name it should name a type and they can do that also with alias template specialization so we are going to see some small examples for each for domestic types you can say that well you require that this t column where you type should be a type name don't forget the type name there and in the example you can see that this compiles with a vector because a vector does have the value type but it doesn't compile for the integer because it doesn't have any any member type so the deduced initializer doesn't satisfy the constraints that's the that's the error message you get i here shortened it a bit but it tells you that type name tt value type is invalid for an integer so for nested template specializations you can say something similar you can say that in this case we've write destruct other that has a requires close and it says that it's template parameter it must not be an integer and we just wrote test concept called type requirement which requires that other with t is instantiable so when you try to use it with a character it compiles fine because it's not an integer but with an integer it it doesn't compile because it tells you that other t is invalid because of the constraints are not satisfied and it tells you exactly which cons which constraint is not satisfied and with which types so as so we said in the beginning the error messages are quite quite good then we can write requirements on the alias template specializations as well here i couldn't really come up with a very meaningful example so i borrowed this from the cpp reference i can make sure that this [music] template here this template specialization earliest template specialization is is meaningful and what type models it well this is also possible but there are some more that you can you can model in a corner in a concept you can nest requires closes but it's often an over complication it's often just over complexifying things but sometimes it comes in handy so let's have this example we have a struct droid which has a clone function and well encoding it often happens that we just copy paste some code and probably that's what happened here too so we have our droid v2 but we forgot to update the return type for for the clone method then we have our clonable concept and there well we require that a cloneable type should have a clone function and we also require notice that we have an inner requires within the requires clause we require that the return type of this loanable.clone should be the same as the type of the clonable well this concept will catch the copy-paste error that we made if you have a look at the last line of of the main function you will see that clonable auto c2 with trade v2 it would not compile because this nested requirement that event has as a semester requirement is not satisfied with trade v2 it's it's really it's really a nice error message it's really it's really easy or work to to find to find bugs but that nested requirement again it's over complication of the things because we could have written simply that cloneable.clone should be should return the same type as the type of the clonable so often when you would use nested requires expression it's it's really not needed but in some cases it comes in handy so i just want to repeat the same example that i showed you earlier with that blah because with the with the black example on the left side you see that either you use a boolean cast to make sure that both t and u has an aesthetic pla but it's not really readable it's difficult to understand or you use some nested requires expressions within within this requires clause where you make sure that both t and u has the lights it's more readable so when you want to use my message is that when you want to use a nested requires think about it twice do you have an easier and more readable way to express it or is it actually the way which is more readable so let's go to some some examples real life examples that that we could use so we used or a number concept throughout the presentation but the problem with it well you can approach it from from different points of view it obviously it would not support like user-defined numeric types but if you just want to use the built-in types to build in numbers then this is not good as such because it accepts booleans and characters as well if you want to [music] add up characters well if you call it the characters it will add them up in one way or another or you can even add up booleans which probably you don't want and when you use the concept number it's semantics really it doesn't communicate that you ex you want to accept their characters and booleans so we can forbid the unwanted types no boos no characters which means that we keep our concept number as a basis of for the new concept and we had some new requirements so it shouldn't be the same as blue it shouldn't be the same as character whatever this is quite verbose but it does the job and most probably you will need it only once in your code base if you really want to constrain that your your templates cannot be called with with whatever that is not a number and you will see that with the error message you can easily see that if you call it let's say with two booleans then your constraint is not satisfied because you try to call it with two boos and the concept explicitly said that t the template type t should not be the same as a boolean and it's evaluated to false so compilation fails good so now our number concept works here and when it comes to utility functions in real life what happens well usually they just take any type they don't have any static assertions the template parameters are as bad as i used in this presentation for the sake of gravity usually just t u and so on and well in most cases there is no documentation so in our code base i found something like well not even like this because here or a template parameter is called like some business object but we had a similar function template so it encodes some stuff you have this template parameter but you don't know what it should be you don't know what it could be and then you have to dig deep into into the code and well you have to investigate it's it takes a long time and it definitely takes more time than it should so you can turn these poorly documented functions into self-documenting code if you don't use the naked tees so you use a good template parameter type names and if you don't use any more unconstrained type names because now you can specify concepts for all the template arguments and that's something the core guidelines advocates for so in our example we can we can define a new concept so let's say a business object with encodable stuff we well whatever the body here is not interesting so we what matters here is that we document what we expect from a type that could be passed in for our encode function and then we can use that concept in our in our encode abbreviated function template here and even if you don't want to name this concept because you will not use it only once but only once you can use it in the requires cause maybe in a nested requires close you can see it that we have requires twice after the other as andreas fertig said yesterday in his presentation it's often it's often a cold smell but sometimes it might make sense because it just means that you don't want to use a named concept and you have to you have to repeat the the the requires for that because you cannot use the parameter in an unnamed context otherwise and now again you have a utility function that is well documented because on at the top of the function at the signature level you you document exactly what kind of types do you expect what kind of types this function accepts so i think it's it's much better than writing a documentation because this one well it it's enforced at compile time i don't have the time to bring more examples i will share some some links after for another interesting one so let's jump to the conclusion the key takeaways here are the concepts they can help validate the template arguments at compile time and they provide a reusable and scalable way to constrain your template parameters and the standard library already gives dozens of generic concepts in fact it gives like about 50 concepts in three or four different headers like in the header concepts ranges and i think the iterators header there are plenty of ways to define your own concepts you can really model any constraint that that almost any constraint that you can imagine we saw the different ways to do that and i'd like also to share call to action with you so as soon as you switch to c plus plus 10 start using the concepts because it brings templates closer to to all the developers because it's so readable it's so easy to write and it makes your code safer use them for for your applications for your pet projects if you cannot use c plus plus 20 yet at work so you can already practice with with concepts and even if you don't have c plus plus 20 one thing that you can already practice is that you can already use good template parameter types you use no more naked keys and with c plus 20 you don't use naked type names either because you can constrain all the parameters thank you for attending that's for it i'm not sure if we have any time for questions but i'm ready to jump into the discussion room yeah thank you hello here you yearn you cannot hear me and i should be fine i think yeah i hope the others can hear me i think so because i think it was a problem on my side okay so we we are really running out of time because jens is giving a talk and it's in in five minutes and so please join shondor at the discussion table in the launch and i hope you you enjoy the next talk about meeting c plus plus update from jens and thanks again chando for the nice presentation thank you thank you everyone thank you erin thanks for the possibility