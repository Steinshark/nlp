i'm happy to be here and this time i'm not going to talk about ctre or any template magic ever so be prepared this is casual c plus plus so i'm anna i'm check national body in either c plus plus committee i'm also a reflection study group chair and i have also author of ctre you won't listen about it anything about it and also i'm a staff scientist at gen which is from avast and northern lifelock and code you are going to see in this presentation is c plus 23 mostly it's still slight there so it's not guaranteed it will work and there is a lot of things missing like parsing and dependencies you don't need to care about it and also everything is in namespace luna because i like the name and i'm using final quote or font it's awesome you should use it so don't be like surprised there is different sorry okay okay the premise of this talk is i need to update an object on tens of millions of our clients whenever i want and quickly in avast we had like tens of millions of clients and we need to push update to it when there is like a new thread detected we need to push to all kinds as fast as possible to make our clients secure so this is my premise so lightning updates what can you update or raise hand if you are caring about updating of your application in your work okay only okay and how do you do that oh what you are updating executable content state of the application like setting and the state of the application which you are updating should be immutable because it's something you are pushing to clients it's not something which users should change somehow and also it should be consistent and secure so you don't want any user to mess up with the content and also the state is obviously data structure everything is at a searcher some sort of dictionary or anything and the data structure can be represented as a file binary textual it contains your data because it's data structure and is the subject of your update system so whatever you're updating it's some sort of data structure even like executable file is a data structure so operating mechanism can be just replace everything just send email to your clients you need to download this and replace it okay it can be additional so your application or some script will download something and it will order something to like storage and it's just overlay it can be differential update you will applying patches and how many of you know ota over the air updates especially with mobile phones you want your application to be updated as fast as possible as often as possible to be secure and everything so we can say that state and plus one is just state and difference between these two status and difference is just a cell in a matrix so you can like represent different states of your application as a matrix and each cell is just different or you can express the update or the matrix as an update graph so your application is in state a or then you update into state b and c d e but usually you don't want your client to update between all versions slowly sometimes your client or turn your pc or only in once in month so you want to have like some shortcut in the graph like this like this like this or maybe even longer so how do you find path between a and e this obviously the shortest one because you see the graph it's easy because you just look at it and done but if it's between a and d you need to take two steps okay but if you don't know the graph you have only state your application is in or the old version b and you are supposed to update to latest one e how do you do that because you don't know the graph you cannot go forward from your previous state and just somehow find a about future updates because your application doesn't know the information because past cannot change you can only change something in future so you need to go backward you will download the latest update look backward to which a point in time it connects and then find the best best note and download it and from that find connection to your current state okay that's easy okay but how do you represent the link between states and we are slowly going into c plus but still not there yet you can call it as a file name with version number or name of the release or denote the node is abc and the link is a b b c and etc or it can be identified by its content it can be hash of it content like secure hash like not md1 obviously or md5 or sh1 no sh256 is okay n then it gives you nice property because in your mind you can say that's hash value of the content is a pointer to the content it's unique value for the content it's the content is immutable it cannot be changed so it's like persistent so you can actually it's called content addressable if you know the hash you can always get the content as also it gives you data immutability if you change your data it will get different hash and if you download broken file somehow you can check it and the content if it's changed it doesn't match your hash and it's it's wrong and it's really easy to catch because it's immutable it's persistent you just place it into cache and don't don't care and forget about it it's there forever kinda and also gives you tensitive trust so if you know hash of a and a points at b in its data and b is going to c by following downloading data you can actually trust to see especially if the a is somehow signed so let's have multiple states as a graph bce your application just names of your like versions let's say but actually in the graph you don't have these states of the application because it can be several hundred megabytes you have you have only metadata describing the state and the metadata can be only like 10 maybe 100 bytes long and they contain information about previous updates or state on the information like hash of your subject so you have a like data session like maybe vector or hashmap or whatever or three and you can calculate the hash of it so whenever you update you can actually check the content you updated to against metadata you are in and be at metadata contains also or can contain signature and actually links between our but it was a state are deltas it's always delta between like between c and e there is a delta c and e and also copy of metadata of c c because it stays small so that is like the dashed line between them and there is a snapshot some are like some states in the graph can contain a link to a snapshot which is serialized or subject you are updating but not every metadata or every state needs that needs them so let's say we will get there so if you have a snapshot b you you can unpack it and get subject b obviously and if you have subject b and apply delta between b and c and delta between c and e you can get subject e so if you unpack subject b apply delta delta you can get a subject e so there is no need if you're creating your updates for your application every few minutes you don't need to create snapshot of a whole state every few minutes because it's a lot of data you can do it only once a day so let's say there is update graph and we are in state c which means but we are updating to see an application is an empty state you don't know and you don't know anything we just got the metadata somehow so you need to find path to close a snapshot you will that is only one link so download delta you will by that you will get state b then you download data to state a and from state a you can actually download snapshot unpack it get subject a apply a delta get subject b get apply another delta get subject c and that's how you update from nothing to something okay and you need to model this graph and the algorithm with vocabulary types whenever you are modeling an algorithm you need to think about what what's your vocabulary so first nouns values hash i talk about hash we can represent hash a state array of bytes and hview is just span of bytes of certain size but it's just alias and i don't like using a generic type for something which has a meaning and in this thing in this called hash or hash view has the meaning and it should me it shouldn't be mixed with other arrays of bytes so let's create hash there are some constructors some friend operators for comparison some iterators for begin and so it's range cons iterations and it has should the same but it's based on span and etc etc it's a lot of code and you can get it wrong and i think the best code is the code you want right so what about using inheritance make hash of certain size to inherit from stud array you will get only function which is in array and you can just implement whatever is something special for your type you know your name is unit or create you mark it as a super type and then by using super super you will just bring all constructors of stud array forward so they are at the same level as your special constructor which is explicit because it's materializing something from hash view and it will just take ranges create initialize copy from the original from the view into itself and you are done you don't need any anything else you have comparison you have iteration everything span hash view is exactly the same you inherit from span also bring the constructors forward create explicitly explicit constructor from hash because it's cheap because it's just view and just take the original value and push it into spend constructor but span is not comparable thanks 25 years i can name so we need to implement our comparison so friend operator three-way and just use arranges lexicographical comparatory way and you are done same thing for equal equality okay and tech dash we can build forward or we can build get layers so we had a hash value so create we can create text hash which is not specified by length but but some some tag so we create hash takes constructor forward create new constructor from hash view of same tag same for hbo people just inherit from everything and then we can create a text for sh1 for sh 256 and now we have special hash value for sh1 sh256 and view for them and then they want to mix we can also create aliases so we don't need to use a really long type but here alias is okay so in your code if you have array and spanner you can always implicitly convert to spanner because it's a view same thing applies for hash value and hbo from hp value you can always create hash value hbo but not in opposite direction also take the attack value and text view work same you can always degrade take value to hash value because hash of certain size is superset of hash of its meaning but you cannot go up you cannot implicitly upgrade some random hash into sh1 because it's different meaning explicitly you can do that but it will be documented in your code estonia said strong types create strong code so yeah it's same error as last time we have another where another noon sorry metadata in our graph the small one contains hash of the subject it points to subject you are supposed to update to and also it contains color of the graph so you can actually distinct two different graphs of different colors so you want to mix them maybe we decide to create a totally unrelated graph so your clients needs to be able to detect it and then also there is a time point of utc time when the metadata was created it's important and then there is a list or vector of our links to deltas in past and also optional data can be snapshot a link to snapshot based on its hash okay and the metadata but these two members are naturalized contains its hash like they are identified by it and it's useful to have it and also it's useful to have full content of the metadata as standardized as a bytes people get down so data link is pointing to past to some time when a previous or metadata were created and also hashed of the object you can download and also this tends to close a snapshot it's number of jumps or number of bytes you need to download it doesn't doesn't matter and also comparisons so you can compare them by default because compiler can do that for you you just tell them yeah i want this comparable and yeah okay so delta it's really simple type it's just metadata of previews previous metadata previous state i'm using state and metadata as like interchangeable and also bytes of the patch itself i don't know what's the format of the patch i don't care and snapshot is just vector of bytes of something which then i will unpack somehow we will get there so we have metadata we have delta we have snapshot and now we have identifier which is just take the hash of our crypto function of choosing let's say sh1 and type of the object so it's like hash of the object and let's say extension or name of like metadata this is delta or something we can compare it only by type against type we can compare it and also we can serialize it with oh we can concatenative string view so we can actually prepend with like web server address from where you will be downloading the object so you can provide let's say in our case is abcdn.net slash and it will append and gives you string whatever you want to download with your favorite library type this is something special because every object in the graph until now was identified by its hash so it's immutable but sometimes you don't need you don't want everything immutable you have the graph and sometimes you want to mark something as the beta version and something as a stable version because you want to have different groups of users on different versions but every time you update it you need actually somehow mutate dls so if i update stable version to same version as beta because it was proven it's good there are no bugs you can let's go yeah i need to change the alias somehow so the alias is not stored under its name is stored under its name like maybe a latest dot alias or somewhere or it can be but it cannot be hash of the content because it will change so it's a hash of the name because everything is stored under its hash to make everything simple so it's just take them latest and hash it and you will get some bytes and that's that's your name and because there are different identifier gives you file or object type you can actually make your web server or cdn contactable delivery network a special cache rule for alias that it's not cache forever but only a few minutes okay now we got some bytes from we download from internet from the web server we need to digitalize some somehow into object but we don't know what what is it so we need to create something more special any object like set n a but only for our objects so it's a variant of metallica delta or snapshot alias is just copy of metadata so we will take constructors obviously and then there is like access that is like it's called i just forgot the name in c plus 23 you can actually access itself ourselves it's like special special supersport entity type and yeah and if the object is metadata it will give you pointer to the metadata it will give you the type pointing otherwise it will it will be no if the object itself is delta or snapshot it will give you what you need so and then we use protobuf i don't know what to use we can use json xml just please don't use yaml first thing you wrap like serialize you need to tell us what's the type and then our store values type is metadata page snapshot and if there is a signature that is that is that also okay we have nouns now here we have verbs verbs are function algorithms so we will take identifier and some data we just downloaded and we return any object how do how do you do that somehow we just realize it with protobuf or some library of your choosing and you will get a something more c plus plus c and if the type itself is metadata and contain metadata and every metadata needs needs to contain signature you will validate the metadata and return to client as any object with id and the metadata signature content and etc if it's a delta delta as i showed needs to contain metadata and the patch then you validate the del2 delta against metadata and patch and return to gland and if it's a snapshot you will do the same if there are a snapshot present and it's a type correct one otherwise you will throw exception it's invalid object okay so we got metadata we have identifier and span of byte the content of the metadata content of signature and content of the whole wrapper including signature and everything so if the id we ask for is not metadata or alias then you're obviously asking for something else you shouldn't be here 10. you can calculate hash of the content itself without signature just the content of the metadata and if id is metadata and hash is not matching against what you are asked for then your checksum is not matching it's wrong but if you ask for alias and we will get there actually yeah and then we will validate our signature which is special case for aliases because aliases can have different hash then we download that so we need to validate signature against trusted keys against our hash and signature otherwise it's problematic and we need to throw away and then we can be sure that our content is authentic and it's correct so we can decentralize the metadata itself and get the result and into result we store also the hash we calculated because it's same but it's not inside of the hash because it's hard to calculate hash of something which contains the hash and then we also gravity original bytes we just take the view and with the ranges to we materialize into vector of bytes and there is okay and then how do we evaluate delta we will take identifier span of metadata bytes petabytes and atom delta so if the type is not delta obviously wrong type and then we calculate a concatenate hash of the metadata and patch and if the hash doesn't match against what we ask for again exception and then we deserialize the metadata it's just protobuf again in protobuf and then i'll store a metadata hash into into metadata there is no signature that doesn't need to be any signature and then we return delta which is just previous metadata we got by industrialization and we materialize the patch itself from what we download and return it snapshot is the easiest one identifier content and if the identifier doesn't match then we calculate hash if the hash doesn't match and snapshot is just a bunch of bytes without meaning for now we are giving it meaning by with type so we have basic verbs and we have graph with represent objects and now we are going into c plus plus again and how do you represent the memory you have graph and you are in some certain state let's say in c so you actually own the subject c somehow it's some data structure so you actually somehow point at this from perspective of your computer it's just like this you have application which points at state and state points as subject subject is data structure and when you update the pointer just changed to different state and value state and subject is just released and then you update again you are in another state you release the old one how do you do that you create state type which is metarata you are in subject you are in everything is cons because nothing is limitable you will create it advance and you will never change it there are some functions to or yeah and it's shared pointer that's important it's a sharepoint error because you will be sharing the state with your application i will show you there are some function which will give you hash of current state which is hash of metadata you are in color of the current graph and timestamp of your current state you are in so why sharepoint term how many of you don't like using share pointer why sharepointer is awesome but share pointer of cons t is awesome because if you have sharepointer of something it's shared with multiple places or even worse multiple threads you can change it and it's just a take but shared pointer of quantity is value type it's a resource it's immutable and it can be shared freely and internally it's automatically the counter is atomic so you can share it between threads safely and also it cannot form a cycle you cannot create cycle of sharepoint of quantity so it will never leak based on immutable type so you don't need any locking to access it you can just read it it's safe and also it's safe memory if you are working with a large object because in update system you can work with few kilobytes also with a few hundred megabytes and you don't want to copy or move 100 megabytes so we have state and we are going forward to update mechanism so let's let's say your application is in state b you have some information about some previous state a and somehow your application is triggered to update into into state g yeah already do that so you download the metadata of g by by it you will get information about previous states directly connect us to gene like enf but how do you select now which like state or such a metadata you need to download you are going into past and you want to select the node which is the closest one by time to your note you already own because you need to like have one grantee in the graph that that is always part minus one to previous one the shortest one that needs to be there and that the algorithm is really really easy you will choose the closest node to to to note you are going to so in this case it's e because they are sorted by time it's not actually more really complex graph it's actually skip list if you have anything about it and now we will choose c because there is a timestamp and you cannot never actually cannot it's published from only one place so you will never create a two nodes which are publish in the same time so you can like count on that they are sorted by time and there are no collisions so you will choose c and from c you will find direct connection to state you are already in so you are connect and this is for graph we can we could choose different path there are multiple paths to get there but this this one is the most most efficient to find if you don't know the graph because you need to think about amount of data you are downloading so how do you select next about in graph you will get metadata that's metadata you just download and shared pointer of current state and the function will return identifier of next object to be downloaded so if you are in some state if it's not empty you need to check the color of the graph if the graph is different color it counts like you are in empty state you need to like for purposes of this function or algorithms you just mark your state as empty because you are doing actually a full update and you if you are still in same state just like saturday check you need to check that someone is not forcing you to downgrade because if someone is forcing to downgrade this algorithm won't work it's going only in one direction so if someone is forcing you to run great it's full update again but your metadata should contain snapshot hash or at least one delta link otherwise deep recognition of the graph is wrong and everything fulfill so if you are in empty state you are doing full updates and there are no delta to go so there must be obviously this upshot then you will return identifier of this snapshot to download because you you have it in your metadata but if you are doing only like partial update you will look at the delta links filter them with ranges i don't know if it's a great idea listening to this morning talk with from nico and you will choose only the eligible one and eligible one means that the timestamp is larger of the target link than your than your current state so you won't go behind behind your state and then you store them you return d lowest one and they are sorted by the timestamp and you will return hash of the closest note in the graph and its type of delta and you will return this to to the color but if there are no data links sorry yeah but if you are going to close the snapshot you will also look data links but you will sort them by what's going on here yeah by operator less and you will provide a projection or to distance to snapshot so it will be sorted by the distance to snapshot and not by the timestamp so we'll look for least amount of data you need to download or number of jumps whatever you like fill when we create the update and then you will return path to delta because you are doing full update in this case okay so path and objects part is just vector of any object that's the part in the graph so you can create function which will take identifier and it will give you any object it will be some magic function probably that will be some library like coral which will download it for you it's specific for a platform so you shouldn't care and then there is a function which will convert the object by based on an identifier and based on provided callable which will asynchronously fetch a vector of bytes and a it gives you a you will call it callable and we give you a protein in this case core task which will give you an object so and as in french is just the object must be invocable a bit identifier and it will give you something you can evade on a available so you will fetch bytes you will call the please download me this identifier this object is hash this extension from this web server whatever it will give you co routine you can evade on so you will evade on it until it's downloaded and then it will unwrap and validate the object and later on because this is just call routine it will give you object so it's a protein task returning any object it will download for you and unwrap it and or throw exception so download is just take identifier use use this and it will give you a task returning vector of all objects you needed to download or bytes in this case a vector of bytes sorry yeah a little bit forward it will give you a vector of bytes you download and that's something like you will integrate with google with ios or get a fetch content whatever so fetch path i'm in some current state which is by value it's copy of current state and i'm i having some target of my update hash or name if it's alias and i'm providing from outside as a user collable which will return a cool routine which will download vector of bytes and i will return tasks which will give user vector of objects from the graph so the path at the at start is empty and then i will use this small small lambda to like wrap everything together so i will take the callable provide it as callable or into convert or to object with id and return our task for any object as i showed on previous slide then if i'm in if i'm doing a non-partial update and my hash of my current state is same as target then i will return empty path because i don't need to update to anything because someone asked me to update to point i'm already in and then if not i need to convert 3 target it's a hash it's variant of hash or name into into identifier then i will call fetch object please download this for me i will wait for it and i will get the object from this function and then i can place it onto path which is first step on my path for the update and then there will be infinite cycle i will look at the last step of the path and if it's metadata and i'm in i'm doing full update and the metadata i download are my target state target node i will finish because i found a path to to where i want to go otherwise i will look which object i need to download next from the metadata i got and current state fetch the object they wait for it and place it a d vector of objects if it's a delta i will just unwrap it take the previous metadata from the delta and place on the part so i can do the previous part of the code and if it's a snapshot i will just return a part because snapshot means i actually do did it through update and in case the select next function here decide i need to do floor bay because it found out it's different color or something the current state will be changed to empty so it will switch to full update and it will find the path to snapshot okay so we have part and we have some state and state is just application of the path between two status the whatever on the graph so it's always state delta delta delta delta and metadata at the end because it's the path we got is actually in a reverse we went backward in time so we are going doing reverse from the right so by i'm using all of this i my application is in some state and there is a subject and i'm using sharepointer not shared pointer let's say a reference in here and i start the update i will copy the state i will download delta i will download another subject apply it and we'll get new subject and then i apply another one then when i'm finished i switch application to different state so until i'm finished and it can be even in multiple threads your application can be doing update safely and only when it's correct check everything then it's switched atomically so update to function takes a atomic share pointer of current state constate hash or name of target which is just variant the function a virtual return protein which is downloading for you and it gives you update result so we load automatically previous state because we have reference to it we fetch whole path between target and current state with the global we evade for it because we need to finish it then we will pipe it into fault right because we are doing it from right which is like something like accumulate about an energy world and fault right is doing from other side and normal accumulate and we use old state and apply something like update trades we will get there it's functor which will help us to apply something on our old states to get new state and when if the old state is small pointer or new state is same as old hash we just tell user it's you already updated to our latest version you don't need to do anything but otherwise we will store new state and tell user you are it's updated so updates trades it's just some structure we need to apply and some update rates which i will show you and trait is just some type it's not some type state is sharep pointer just to make it shorter to fit inside and if we get snapshots then there is operator off state and snapshot and such operation will just overwrite previous state and create shared or state from constate industrialize it and provide empty metadata because we don't have any metadata yet and it will give you new state based on the subject or snapshot which means you are doing full update and you just started if it's delta and you have some previous state you will take previous subject because there should be some take the patch bytes from delta cause trades which you provide for your data structure apply the patch give empty metadata because you still don't have any metadata and wrap it into sharep pointer and return it and if it's metadata you got which are always at the end of the right fault because you start the metadata you calculate hash of the previous subject or you are currently building and if it doesn't match but you are expected to have then there was some problem during update and you shoot through exceptional otherwise you will just take the previous subject and because this check pointer just can take it metadata you just got and provide new shared pointer of constate and you are finished you are updated so update rates look like look like this there is a function calculate hash of subject because you data structure can be vector of bytes vector of ends it can be a hashmap it can be dictionary so i don't know how you calculate hash of it it needs to be stable so you as a user of the library you need to provide it you will get hash then you can calculate difference when you are building it so you have two different subjects and a return vector of bytes because this is only place you in the code which needs to understand of the patch format which is specific for your data structure and then you need to provide function to apply different so we'll take previous subject some bytes of the patch and apply it and you will get new subject and that was also civilization support so you can actually take subject and serialize it or decentralize it and get subject so that's the internal of the library i'm getting light so when you are updating then there is a task in your application which needs the data you operating the subject so it reference it and then you finish the update we will do the update until you finish it suddenly your task which is maybe in different thread working is dangling which is ub and stable that's the reason i'm using share pointer because it will never dangle and you can meanwhile you can start another task which will get the latest data and then when it's finished the previous one then so you should always take someone like a handle sharepoint of some resources you are using and are release it when you are done if you are just using reference especially across the dress you are screwed so stream we are updating it's it's some it's some type you are writing it's like your type it's like your dictionary your configuration whatever and you provide update rates how to update it you hold the atomic sharepointer of automation pointer of current state and there is a function update to you provide provide target and function to download it and it will give you a success then there is also function get which will give you sharepointer of current state if there is a no state it's null pointer if there is no subject it will there's no pointer but if there is something it will give you share pointer to the subject and you you need to hold it as long as you need it and that is acceleration so it will take state current one so and you can store it to persistent storage so your application will remember what it downloaded so you don't need to do full update every time it's the same but you need to put in this case you provide this state so if the state is empty or exception but if there is a state it will always contain metadata with original bytes including this signature which is needed because you want to check it so you will take original bytes you will serialize the subject with update trades concaten item store them personalization is similar you will take bytes and if it's empty so you will you won't get any state or then you split somehow the metadata and the subject you will create path from them snapshot of the content you serialize and it will take the metadata and wrap it validate it and place it on path and then you just apply the path but from the left in this in this time so we'll take the empty state the path with two objects and apply the update rates and you you did full update when your application started from the persistent storage on your device then there is a constructor a new constructor or can take optional of the persistent storage if there is any and if there is any it will try to load it and that's the application and how it's used let's say you have stream of dictionary with some trades to update it you will download or you will load file from persistent storage provide function to download it with coral and if you are updated you will store it again so every time you update it you will store it for for so you can start again next time and then you will wait at the start of the application to finish the update every time you can have some scheduler which will do update every 10 minutes and then every time you do something you will just ask for a handle and do something with the handle so the essential part is that you have stream of some type and you provide some trades like in this case bsdf over bytes because it's just be as diff and when you do something video or subject you all you need to always ask for the handle and store it as a handle that's like one thing you should remember if you do any programming it's always to have a handle and use a ia release acquisition is initialization bsdf is vector and view bytes calculate hash you can calculate hash calculate difference you can apply the difference you can sterilize it with energies and the serialize it is just copy so at the start of the talk i said i need to update an object on tens of millions of clients quickly and whenever i want highlight i haven't tell you how i'm you're doing it i just show you this because the problem is now you just need to deliver hash value 32 bytes to all your clients and then they will do the update on on themselves so actually the problem is much simpler you just need to deliver information about the latest update so i showed you how you model algorithm into code verbs and nouns strong types makes your code really easy to reason about the code is really simple you can easily test it and everything and also simple modern c plus plus is fun and how do you use a such library you can obviously use the distribution a b signatures as we do you can synchronize configuration across clusters you can do ota content updating of any application maybe some game many more let's let's say there is like you have map a file system path and content of the files vector of bytes virtual file system and and you create a virtual file system trades so you have how you calculate hash of the file system is that you can calculate hash of all the objects and their names and you calculate the hash of the old dashes difference is similar you just calculate difference between existence of files and then over the files you check if it's additional removal update and if it's a update you calculate a difference between a bit bs div or something else and then you sterilize it compress it applying difference is similar you just analyze the patch check if it's valid and if it's not you will copy preview subject and apply all the changes and this is actually a good place or to have like copy on write if you have like really big files or really big types and if it's additional just other new file into virtual file system if it's removable you remove it if it's update you will apply dbs div and that's all and if it's a problem you will throw exception sterilization is just sterilize everything and compress it the stabilization is same obvious and that's how you make simple git thank you any question i hope there is at least one hi sound is not working okay okay good oh okay i'll still be doing it's scary yeah exactly good talk i had a question about the motivation that led you to write this thing in the first place like have you looked at other content and update delivery system did you find shortcomings or when you're updating tens of my dance clans you need to do it as efficiently as possible and ask quickly especially if you actually want to distribute iv signatures seconds matter 20 seconds means like maybe five million clients could get infected so you need to be really fast right and anything else you looked at i don't know if there are any existing like solutions of yet like multiple solutions historically i'm not sure if i can talk about them so what am i in use there was like different types of updates like overlays complete changes or patches and but most update system you you see in wild they are working on files you will update file and then you reload it but if you are doing it quite often like every two three minutes you don't want your like all clients even with slow computers to reload 100 megabyte file you want to do it as eventually as possible in memory if possible copy on right so it only small change of the data structure is changed and that's how and because also many update system focus on updating the files they are designing everything around files but i asked question what does it mean to update and if you want to update anything like data structure you need to like compartment oh sorry i cannot pronounce it or you can eat like distinct two things updating guys are also downloading and your data structure can be different it can be different for each component and you don't want to copy your code multiple times so you have templated code which will do all updating for you and you as a user i mean programmer of some component which needs to be updated only need to care of like placing one line of code there will be my data session start and this is how i get the handles to it and everything else is taken care for you okay i see no it's really good thank you okay you can find me here if you are shy to talk publicly or not do whatever you want thank you [applause]