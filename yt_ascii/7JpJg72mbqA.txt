there's an argument people make in programming all the time that all programming languages are basically the same you know you add a feature here you make a syntax change there but essentially all programming languages are the same thing now i have to say i disagree i think the differences are where things start to get really interesting but you have to concede there's a lot of overlap java and c have obvious similarities because of an obvious shared history if if you know pearl and teach you python i'd hope you'd like python but i wouldn't expect it to completely blow your mind in the great ven diagram of programming languages there's overlap of course there is and the question this week is how much overlap and how far can you push it i'm joined this week by martin johansson and he's created a language sl tool that's trying to exploit the overlap between languages and build a kind of bridge so you could write something in java and translate it into a similar language like c or a less similar language like php he's got 13 languages he can bridge between so far and it's a curious idea i think it needs digging into so let's get going hear what he's got to say i'm your host chris jenkins this is developer voices and today's voice is martin johansson [music] i'm joined today by martin johansson martin how are things things are fine thank you thanks for having me on pleasure pleasure while you're out there in the snow in oslo i believe yeah it's sow snowing heavily outside right now and it's quite beautiful it's a beautiful place oslo especially in the winter although it's perishing cold i'm not sure i could cope with living there yeah and it's it's at the end of a cold spell right now it was 20degrees celsi for a few weeks so that's very cold minus 20 yeah exactly minus 20 cel i don't normally think that side of the zero so the reason i've got you on is ambition i think you've been trying to solve a problem that i think everyone's tried to solve but the way you're doing it really interests me so let me put it this way everybody so many companies so many people have said that they can solve the reusable software problem and that's what you're kind of going at but from a new angle an angle i've not heard about before yeah exactly so so this problem has interested me for a long time and what started me out was that we know that we write these text files with code most often and and those don't change but what we see is that the co either the programs will stop working over time because we need up the software updates the os updates or a new language is trending and people are moving over to that language which require us to rewrite the code and i i i'm this was very interesting to me and i started in i started a serious project to investigate why this is and that's where i came up with a technology called prog space and the theory behind it should i just dig into what it is and what my give me your general approach and then we can dive into the details yeah so it is a programming language called prog space and there are related tooling that we can talk about later the approach i took when creating this language was very different from what others do instead of looking instead of trying to build a new language with strategies and mechanisms that that are new and that i thought was better than other languages i took in a sense the opposite approach i i i i looked at languages and saw what do we actually agree on and it started out as an experiment let's try to build a language with those things that those things that most people most developers agree is a good idea and we also see that when a a language designer creates a new language he will include these mechanisms in the language for some are we talking about we are talking about very basic stuff here like arrays functions structures a character data type a number data type a boolean data type okay so we can agree on pr before it all breaks down into flame wars exactly yeah exactly so what started out as an experiment where i picked up those mechanisms that those language constructs that were that people agree on i built it into a language and i started coding in it right and what i found out is that it was very strange to code on this language in the beginning and i've heard that from other people developed it as well that it is a bit weird in the beginning but then once you get into the flow something interesting happens you will see that you understand the language 100% now and you can just focus on the problem you're solving but that sounds like you've solved the problem by just creating another language yeah so one interesting thing about this language is that it is it does not have its own syntax or its own compiler what you actually do instead is that you write code in for example java but you write in a subset of the language using only certain mechanis using only certain language constructs so what you write is just plain java you canile it with java static analysis with java everything is java but then you can pass it through an analyser that's i have made a prog space analyser analyzer and it will tell you whether it is valid prog space or not right so prog space isn't its own language it's a subset of java it's a subset of many languages in fact at this at this point in time i have 13 languages that i have supported support for 13 yeah and actually you could choose any of these language languages to write brog space in at the current time i only have java as an input language but as an output language i have all the 13 languages so you're saying i can say i can write a subset of java and if it's a valid subset of java you can take that in and spit it back out as 13 languages exactly exactly and this includes also the test cases right so you will what is interesting here is that not only do you code the code itself you code the tests as well so not only can you spit out in a new language you can also automatically run the tests and see that the tests pass in all the languages so it's actually quite interesting to see this in in action where you will have a list of languages and will just pass pass pass pass going downwards and you' just made a change to java the java version of it okay let's hammer on this idea so the first if you're going from give me give me two or three of the languages so java did you say python is in there yeah c++ python visual basic i can bring up the whole list if you want no no it's okay it's just enough to get me started on the question javascript of course is an important one typescript javascript and typescript if you've got how how small a subset of the language are we talking how use how much common ground between those languages that you could usefully translate yeah so it's important to note that i did not choose the languages first and then selected the subset because there are languages outside that that i can translate to for example hll i cannot translate to h but but i can translate to those languages i mentioned and what was your question again sorry well i'm just i'm wondering what okay so let's put it this way you're saying there's enough common ground between java and python and c+ plus that you can translate automatically between them but not hasal so what's that boundary line where the common ground disappears right so i don't know exactly where the common ground disappears because what i did was to select those language those language constructs that seemed to be low in disagreement among developers right and then and and then i i selected these constructs based on what you need when you program as well right okay so therefore i ended up with this set of constructs that are very practical it's very easy to work with them but they they are also common among 13 there's actually a lot more but i've only worked with the top 13 languages okay when i did this can you give me an example of something you thought was common and sort of failed to pass that test good question yeah one one big one is the integer data type oh really that is actually that is actually a very interesting one because there is actually a lot of corner cases when it comes to integer math that makes it difficult and this was one of the more difficult parts when i started making the language but once i got into it and saw that we can we can use floating point numbers for most things and we actually do that when we write javascript there it's uncontroversial or it's probably controversial but but it's less less controversial it's not like you have a choice in yeah exactly exactly so but but what happens is that when you get into it and start coding you will see that you always know what will happen when you divide two numbers even for example in python if you divide by a negative number it behaves differently than if you divide by negative number in java so that's an example where they disagree right doesn't that mean that then you can't have division by negative numbers in your language but when you do floating point numbers it's not a problem because then people agree what you should watch it happen okay so then we then we've got to get into what the practical size of this subset is i mean if i'm writing if if hypothetically i took javascript as my source language that limits the specificity i can have in my target language of java so that's right so now we get into into an interesting thing because what i saw earlier on was that we can we can roughly divide our programming tasks into two categories one category i called computational and the other i there was no term for it so i invented a term called infrastructural but it basically means where you interact with hardware for example the screen a disk a keyboard a clock device whenever you interact with any of these devices i separated that out into a separate field and then i focus only what you can do with uh memory and your cpu running on a single thread because i also regard multi-threading as different interacting with different devices okay i can s so is this similar to the division between pure functions and side effect yes it's very related because when i started working on this what you can do with just the cpu and memory what you write is actually pure functions in my language you're allowed to change the input parameters so so i guess that doesn't fit the strict purity requirement but but but it is the case that the a function will always return the same output for the same input okay yeah and there is no global state either so so so it's always the case so the functions are pure in this sense that it will always return the same output for the same input okay so pure functions let me think of something that falls awkwardly outside of that see if i can challenge you on this here's something that some languages absolutely agree as fundamental and some agree as the opposite memory management how do you bridge the gap between a memory managed language like java and sorry and then and a manage it yourself language like c++ that's a very good question and what what i decided to do is to to have calls you have allocation calls where i use the native one so in java i use new but for deallocation what you do is that you create a function um with a special name called delete and in java it's empty nothing happens but when you translate it to c++ it will do an actual delete operation in c++ okay so it so the short answer is there is manual memory management but when you run it in a garbage collected language it will garbage collect okay and if i'm writing a from java a garbage collected language you are going to auto when you translate it to c++ you will take care of the manual memory management primitives exactly so you have in a sense when you write the code you have to do manual memory management but when you run it in a garbage collected language then you don't then then the garbage collector will take care of it okay cy but the but the purity of the language makes this a less of a difficult task actually so give me an example of something useful you can write in this subset what are what are the practical day-to-day limitations that imposes on you yeah so in this subset of the language you can write a lot of libraries related to doing computations and i'm we we haven't talked yet about a library of functions right libraries of the online library of functions we need to get into that yeah so i have an i have a large online library of of of code written in this way and there we can see what kind of libraries it is should i just have a glance at it and give you a few highlights yeah give me an example so a couple of good examples that i'm using in in a project i'm working on is um adjacent serializer and der serializer okay that's one example example global yeah another example is date libraries dealing with dates all kind of calculations with dates that that's actually a huge one yeah the hard part of that is not so much programming as the crazy rules the planet has exactly so here you can capture those rules in a language which you can then translate to all the languages you want right so that you can have the same date functionality okay so you are you saying that you've written a new date library or so you didn't go to an existing java date library and see if that was translatable exactly but i i did not of course invent all the algorithms i look up algorithms i take inspiration from open source projects that have an open license mind you i always make sure they have so so i i i i make i i i take existing libraries and i convert the code to br bace code which means removing a few language constructs here and there and actually some functions get get get more clear when i do this because i reduce the amount of features in language i use and sometimes this pops up interesting new questions about how the implementation works give me an example yeah a big example is error hting okay i think that's the major one i encounter many languages rely on exceptions as an error handling mechanism and in pr space you don't have exceptions other than a certain kind of exception where you overflow an array if you divide by zero there are certain hard exceptions but for ordinary control flow you don't have exceptions what do you have instead so what we have instead is you return if a function can fail because the input is invalid i return a bullion say saying that the function failed okay and that is always that is always very interesting because when i then start to look into the implementation i will see ah there are all these failure cases and what you'll see that many failure cases are not handled and then you will get this generic null pointer exception for example that's a very common one if you haven't thought about all the errors i will add additional checking and what you will get in the end is actually a library that either succeeds at what it's supposed to do or it fails with the status of false and i often also include an error message saying why it failed so my yep so if i'm writing some java in this does that mean i have to remove my exceptions or does it mean that you'll translate my exceptions into no you you actually you actually need to remove the exceptions that's true that's true and go over to this error handling by return value instead okay so it's i'm trying to get the idea of what it would be like as a java programmer to convert my code because it's not going to be entirely idiomatic java then no it's definitely not going to be idiomatic java that's for sure what's interesting actually is let's say you write some code in this and then you translate it to c++ it will not be idiomatic c++ either right actually you will get idiomatic prog space in java and in c++ the code will look very similar because one thing i haven't mentioned to you is that the translation isn't one way it's a one toone translation so that means that the code you wrote will look almost exactly the same in java in c++ or in typescript as the one you wrote so in some future i could take the java file spit out a c++ file repaz that spit out python file split out a visual basic file and go for lunch exactly exactly right so is is your hope here then that eventually i'm thinking probably companies that have a large number of different languages like netflix has lots of languages doesn't have any hope of roles those into a few are you hoping they would convert their core library say that's a good question one thing i one thing i hope to do is that as more and more libraries accumulate here i hope they will have longevity and what i hope is that over time since we do not have to rewrite the libraries in a new language if a new language comes along i'll write an output for that language so that it's fully supported and what i hope is that as the library grows we get a library that anyone in the world can reuse not only throughout the world but also over time so they can reuse it also in 50 years or 100 years so i hope that this even though the language itself might look a bit famili unfamiliar and be a bit controversial i think the longevity will prove itself in that we get more and more code that it's of higher and higher quality and that that will encourage reuse and enourage ur people to use it okay i can see that so is it fair to say your idea here is rather than trying to find a language to rule them all you're trying to find a style to rule them all in a sense yes yes or to at least harvest what we do agree on now so so it's a instead of creating another faction or another dialect i i try to do the opposite like this is the core in a sense the core on what we agree on let's see what we can do and what i found was that we can actually do a lot of coding in this language and it works very well okay there are two directions i want to take this in let's go into the library space first so you've been talking about prog space the language when you think about it are you are you really talking about prog space the spec or the set of capabilities or some internal representation so should i mention the library the online library yeah yeah yeah so i in in relation to building the language i also set up an online library and this is an immutable online library of code so when you publish a release version into this library it cannot change in the future so and and a library is known by its name it also has a name space which is and i have two nam spaces actually i have an organizational namespace where you put your organization for example n o company or come company this would be the organizational namespace but you can also have what i call on scientific namespace so if if you if you created a library for doing network let's say computation related to networking you would put that into the scientific namespace computer science networking and then addressing for example okay this is kind of a side question but which one do i then import yeah you can choose both at the moment i only have support for the organizational one but the scientific one will come very shortly okay and you can choose which to import so is that library is that storing java code oral representation it is storing the a the abstract syntax tree of what is valid pr bace cod right yeah right so we've got this is reminding me a bit of unison yeah yeah and unison is quite similar in this respect but unison recognizes functions by their hash here a library is known by its name space its name and its version okay so it's those three and then in addition you have a function name which identifies a function in that library okay so if i published if i attempted to publish a slightly different source tree to the same version number what would happen then you would get a message saying that that version already exists in the library okay okay and one important thing here is that you also you you bundle with this a file where you describe the dependencies of your library mh h and those dependencies if you publish a release version can only be released dependencies and this ensures that the libraries that are published are always going to stay there as they were and this this this whole database is actually available online so i've created this domain where you can go and then you can browse all the libraries all the versions all the functions you can see the source code in all the languages because i just have a drop down you select another language it will translate it immediately to that language okay so when i'm browsing the source code there is no source code you're generating my chosen flavor on the fly yes and interestingly what i can do is that not only can i do this can also generate an applet if you want or or a form where you can run the function there and then because you can translate into javascript exactly so you can run the function right there and then in your browser so when you if you upload code to this online repository that website will be generated immediately for that function you can also have private libraries but but then you that that's a separate part yeah my main focus here is the online open source mit license source code okay and then this will curiosity when i download a library to my local machine do i download the a and store that or do you translate it for me and i download my favorite language i could actually put a download link for the ac but right now i just have download links for each language and so for every library you can go download and you will get all the languages and different flavors of each language also different versions of a language and download the source code and you will get not only the source code of the library but also all the dependencies bundled into one so you've had to write an as pretty printer for all 13 languages that's exactly right there okay that must have taken some work in itself writing the libraries and doing the research was the hardest part writing the writing the language part of it was not that difficult so so okay okay so then we need to talk about what you called the infrastructure side of things cuz at the moment it sounds like it's going to work for just a set of pure libraries exactly so what i when i when i was happy with the part doing pure functions i started looking into how how should we deal with dealing with deal with devices of all different kinds and what i found was that i took inspiration from the capabilities view of like when you have capabilities in a function and let's say you want to interact with a with a disk then you will pass um a structure to your function called disk and then i created three operations on that dis read and write and also get the size of dis these functions are when you program in pr space pure so they are mocks of that of the disk so you program it in completely deterministically completely pure and you develop and you test and you see that everything is good now you're ready to deploy this interacting with an actual disk what you would do then is to to delete your the the library called disk which you have imported and replace it with for example a file disk handler that will do these operations on a file on your computer so then it will treat that file as a disk okay so you're enforcing i can't do side effects i have to program against an interface yeah exactly exactly and i've i've selected many devices but let's see i've selected six main devices that i that that covers most of the productive things you want to do give me the six give me the list yeah so there's a dis that is on yeah there's a dis and then there's a screen putting stuff on the screen okay a clock device audio device for outputting audio mhm and then there are two where i needed to invent a name because i there was no standard name for them and i ch chose to call one a processing unit which basically means a thread is memory it's a single thread memory and a cpu okay and then a processing unit control is what i call the the last one this is where you want to start or stop a thread okay so it's a bit like a thread pole in a sense yeah because the processing unit controller will have let's say six processing units you can control and you can ask any of them to stop or start or you can change the program that is running on them and this you would use to create a scheduler for example or if you wanted to split one thread into multiple threads to do it's a bit like supervisor then yeah yeah yeah missing from that list quite notably is network yeah this is a very good question because i have abstracted the idea of a network and combined it with the multitasking so when you write pro space code it's always running in a single thread mh and if you want to run two threads either on one computer or on two separate computer the only device you interact with is the processing unit device so you will pass a processing unit device to your function and then you have yeah you have a number of calls but basically if you're interacting with the this processing unit as a client you can send you can receive and you can also check if there's a message okay but you can also interact with this processing unit as a server and then you would have then i would have server receive and server sent and also there check if there's message available so if i spin out a local thread or i treat someone else's web server as a thread it looks the same exactly exactly it only depends on how what kind of driver you use for the processing unit on the same computer you could typically have a shared memory pool that would be the most efficient way to do multi- threading on a single computer but the the code would be exactly the same if you wanted to interact with another computer then you will then you would replace it with a network call typically a tcp call for example so does that does that get tricky when you're doing things like serialization how does that play out i'm uncertain what you mean because i mean most threads you're just sending data to directly sometimes you're even sharing a pointer in memory whereas now you've got to worry about writing btes to the network you've got to do more serialization work to make those calls yeah you're right so that that that's a fair drawback i think but but here you can here you can have a unified view of whether you work on a single computer or multiple computers so what's actually happening under the hood are you serializing every call whether it's local or remote so the calls you have against the processing unit is send an array of bytes and receive an array of bytes so it's up to the person who makes the okay code that decides how to serialize it but but there is actually a way to optimize code in pro space that we can talk about i don't know if you want to talk about that now or later let's go for it let's go for it okay so we we actually get a huge benefit from the fact that these functions are pure and that there's no global state this means that we can actually replace individual functions with a more efficient call so so if you wanted to pass the pointer directly you you could instead you could write you could write a more high level call and then replace that with a driver doing that actual call take me through that so before we dig into that maybe we can talk about file systems just to have a an example yeah that makes it most people think about the file system as interacting with a disk yeah but the fact is that in prog space if you wanted to interact with the file system it would be a processing unit okay and the reason is that a file system is actually a lot of logic that needs to be done in order to figure out how to talk to the actual dis yeah so if you had if you had a file system called call called read file for example that would be an api call to a program implementing a file system but you could actually if you wanted to replace the function read file with a more efficient one especially tuned for like linux or windows mhm and since you have since functions give the same output for this same inputs this would actually work it would be easy because why you can't in c for example or c++ you can't just replace a function because you don't know the effects of what it will do but here since you have this very limited very tight tightly focused language you can start to do these kind of things more naturally okay then why not unify why not unify discs as though they were threads as well because you just file system you send stuff to it you get stuff back from it that looks if you're going that abstract it looks a lot like a network call or a thread coe it does but a file system usually contains other things like a file name it contains access rights you can also get error cases like the dis is like there's no more specializing the error yeah so so it is consider larger interface a file interface okay so it could be a subset but you've just chosen to make that more fully featured yeah yeah okay okay i can see that so so yeah what what i find very nice about this is that you have a unified view of multiprocessing on a single computer and over many computers yeah so this means that it's it is quite natural now to create a distributed program running on many computers to what degree have you done that out in the wild i've done that i i started developing these libraries a year ago and they're expanding quite rapidly now so i now have a number of these kind of modules building blocks for this kind of distributed systems should i mention some of these building blocks yeah yeah yeah go for it they're nicely categorized into these scientific name spaces that i mentioned for you but let's see so we have a load balancer for example that is a program that where you take number of clients and a number of servers and it deals with the load balancing in between right and that can be applied either you want to load balance across servers or if you want to load balance locally on your computer or you want to load balance partially on your computer and partially on another computer it only depends on what what kind of processing unit drivers you set up when you run it so this becomes yeah i'd be able to expect to run a low balancer with a number of different servers behind it and one of them is running the code in python and the other one's running on a jvm and the other one's running on raw binary what's it elf yeah that would be natural to do here yeah yeah that was something that would be natural to do using the setup but the nice thing about this is that you can actually you can start work as an architect you can think of okay let's now consider what kind of modules i want in my system i i want i want to have like several discs and then i want to have a raid component that does the raid logic and then i want to have a cach so you put a cach module i also have that in the library a cache module a raid module and then i want to have my file system and then i want to have another layer of cach on top or you can just remove the caches and have a simple infrastructure so you can start doing this kind of architecture where you just select the components you want and build them and run them and because the interfaces here are so simple you can also run it on a bare metal server if you like and i've been working together with the bare metal os to to to get the drivers going for a bare metal deployment okay what states that in it's in a good state where we are working on the networking components that's the only part that is missing but interprocess communication dis access always kind of very natural on the bare metal environment but but you don't need to run this on a bare metal environment you can run it on linux and then you just use the linux drivers instead you use the linux driver for tcp communication the linux driver for dis access so this kind of working i this kind of architecture i've i've coined a term called no os right because you you're not dependent on any specific os to to build and run these components okay that means that you have very good control over what is happening so i've got a chance then of expecting to run some code on the jvm and on some embedded hardware and on aws lambdas potentially yeah that should possible yeah yeah okay we need to talk about how far along this project is is anyone using in production so i have not done a lot of marketing on this project this project has been going since 2018 i have been steadily building up so the language stabilized around 2019 and i started building i've built libraries over many years and then they last two years i finalized this capability model and i started building capability these kind of drivers and infrastructural components so like in the fall i i considered now now the project is pretty complete now i want to do some marketing and get this out there so i'm very early but i run this company here i'm in the office now which is a cloud provider company in norway m and we have been using this since about 2019 we have been using many of the components talk about in production okay for what kind of tasks for many kind of tasks i mentioned some of them earlier all kind of date calculations we have serialization using json and b 64 we are facing it in now as a static web server okay because we have all the components we need to do static web ser serving we'll be facing in load balancing shortly and we'll also be facing in kind of raid operations and stuff like that and we're also facing in database logic as well so it is slowly facing in many components database is that going to be written in prog space or is it exactly yeah we'll have libraries for different database operations the one setup at this point is a key value database okay but a relational database is also in the works if i wanted to talk to postgress for example what's going to happen there yeah so if you want to interact with a some kind of software that is not written in pr space what you would need is an adapter so you you would need an adapter that takes for example an an sql request as text and then passes it on it on to post so that's how you would actually interact with a system like that you would regard it as a processing unit inside prog space okay so i would then presumably need to manually write that adapter in every target language that's on me no i don't think you would need that maybe parts of it but but but the main parts of it you can do in pr space and then maybe a tiny part of it needs to be done in the particular language okay what about external libraries though so like if i'm writing in c i'm going to bind to the li postgress client can't remember the exact name that's not going to work in java land yeah exactly so this whole basic setup that i've been talking about only works if you're doing everything in pro based right yeah so so that is a limitation absolutely but but my my my hope is that the benefits of this language u means that we will get if we build certain components using this language we will get certain features and maybe some parts are outside but my hope is that we can get a database of libraries that are very solid that can be used in any language and if if you have some task that is not suited for that then sure go ahead one benefit here is that you can only you can import a prod based library into your project and it doesn't influence any other part of your system right because it's just more java or whatever language exactly exactly so it's very easy to reuse the components as they are in any project so if you want to use prace libraries in your project it doesn't limit the project it's just a java file that sits there and does its thing and you can do whatever you want with the rest of your project of course yeah but if i happen to want the same library in another language i'm using i can expect exactly the same behavior exactly exactly yeah yeah yeah so hopefully that is a huge benefit and if you want to write as i said infrastructural components as well and have that as a part of your system that works as well yeah but of course you're entirely this doesn't dictate how you do all your yeah so out of curiosity when you phase in your low balance at a production presumably your target language isn't going to be visual basic that's true that's true which one will you pick i i have a tendency to to run most of my stuff on java on the jvm but if i if i wanted to have more speed for example i would put it in c so some of the components are in c just to get that additional speed that would be really interesting to benchmark given that you're pretty confident it's exactly the same code yeah and we haven't talked about this yet but we but one hope i have with these libraries that is that they will gr they will improve in quality over time because what i try to do is to have libraries with a very a single thing that they do and then do it well and then i've created this process where i will hopefully evolve this library into a very robust and high quality component and my idea is that i start with creating a component then i put it into low importance production work to like check what the quality is right then i put it into more serious production workloads and when it's been there for us some time without giving any error any unexpected behavior any errors it works as it intends then i put it up on prog space.com on what i call a bug bounty program right i have seen this you've got the your most confident libraries you're putting your money where your mouth is yeah yeah so because when i written the library i see it work in production it has done so for some time now i put it up on my and say that you will get for example $200 $100 for finding a single bug in this library and and you might say that's a bit overconfident but i challenge anyone viewing this to go and see if they can find bugs you can actually run the code just in your browser there are links you can run you can try any input you want you can analyze the code with your favorite fusser and if you find the bug great because then we don't have that bug in production anymore so that would be absolutely fantastic and i that's absolutely worth the money and if if a bug isn't found over some time i will raise the reward okay so yeah that's just any bug for the library no matter how large or small yeah exactly as i say in the bug mounty program if you can find a valid input that gives unexpected outputs that's your award what if does that still count if i only find it in a corner case in visual basic no so the bug about the program exp to say that it has to be u yeah if you find a bug in specifically for visual basic that that's a more internal error in our pr space system so we don't have a bug bount yet for that but that that would be an interesting separate thing actually but as now it has to be when you run the code in in the core sense okay it it would have to be present in multiple languages right we have a bug in the library and not in the writer itself yeah that makes sense i could see it's kind of a next order of next order of magnitude abstraction to test the entire language translator rather than the library but but i think i think i think you made a very good point that if there is a bug in the writer that's also quite serious so so so that is something i actually could put up as a bug bounty as well that's good a separate bounty exactly exactly good idea okay so in that case if someone wants to get started trying this if i fancy kicking the tires on a java to visual basic to python translator where do i yeah so i have a website prog space.com and you can go there and you can download the tool it's called prog space you can run it on the command line because this is on online library where we have the code the tool interacts with the online library so therefore you need an account but the an account is free and as long as you just upload open source project to the library contribute with that everything is free you can and and if you want to use pr bace libraries in your system you can also use the pr space tool to import the dependencies and you can do that in any lang in all the languages we support and if there is if you have a language that would want to import the code in just let me know and i'll see if i can make a writer for that language okay so if i'm if i then go away and write some java and i decide i want to make it into python do i have to upload it to your library server and then redownload the python no because the tool has a has a command called convert okay and then it will convert the so i can run it all locally yeah yeah okay that that makes it very interesting for like little local experiments on language to language translation yeah yeah it does it does and you can also go on the on the online repost story and do the drop down menu and the this online library is also highly interactive with that you can click on a function and you will get go to that function and you can try trust that as well cool okay last question then what what's the most exotic language i can translate to good question let's see what the list is yeah maybe the most exotic language is vba vba yeah that a pretty exotic one but it's an interesting one actually because it's used in a lot of businesses yeah they they don't brag about it but it is actually out there i can see that being surprisingly popular to you can write vba without actually writing vba yeah so here you can hire you can set your developer to create a large library he can test it locally using his favorite java id and when he's happy with it he can upload it to library and download it as a vba library okay i could see that being a little niche corner of your user base one yeah but the question was what was the most exotic yeah yeah yeah i love that though because that's it is exotic but you're right it's still desperately used cool okay i i think i have to go away and play with this i'm going to give it a try and see see how far it goes in translating in being like a babel fish of programming languages martin thank you very much for talking to me yeah thanks for having me have a nice day thank you martin you know if i were martin's marketing department i'd say that last bit might be the best argument for adoption it's quite compelling tell people you can write the language you like but emit the language you don't we all have feelings that way don't we i don't know it's an idea that needs some battle testing though i would need to kick the tires before i formed an opinion let me know what you think in the comments if you think it's a good idea go and check out prog space.com link in the show notes as always if you think it's a bad idea you should probably go and check out the bug bounty because if you're right then that's free money and if martin's right it's a free education you're a winner either way right before you go and do that please take a moment for some feedback if you liked this episode click like or rate or whatever buttons your app has if you know someone else who might have liked it please hit the share button and send it to them and make sure you're subscribed because we'll be back with another episode next week of course until then i've been your host chris jenkins this has been developer voices with martin johansson thanks for listening