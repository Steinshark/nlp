if you're writing software there's a very good chance that you're in the habit of using a refactoring tool or a linter or a code formatter or maybe even a code searcher that's more advanced than just grapping there's actually a fair chance you've used all four of those tools very recently because they're all fundamentally useful tools no matter what language you use and they're also fundamentally operating in a similar way so you might ask how you might know consider seually it's not that hard what you do i think of it as a two-phase process what you do is you write a few regular expressions and then you write a few more regular expressions and then their weight and complexity drives you completely mad and you spend the rest of your life in an asylum gibbering and then phase two is your children grow up and they realize that was the wrong way to do it and they do it the right way by writing a proper code paer and the paer takes the text file and sends it into into a logical representation of the structure of the code which gets called an abstract syntax tree and then you look at that tree and either you rewrite the tree for refactoring you look through it for searching you critique it for linting or you just write it back out neatly for pretty printing that's the basic idea now we dig in properly cuz there are a lot of juicy details once you pop the lid off it i'm joined today by jonathan schneider and he's one of the authors of open rewrite which is an open-source refactoring and code analysis tool that actually handles a surprisingly large number of different languages and different file formats and works all those different tricks on them and jonathan's going to take us through how you really build a system for wrangling source code including all the thorny edge cases like languages that are sometimes whites space sensitive and developers that are manically whites space sensitive that comes up a lot too so let's get started i'm your host chris jenkins this is developer voices and today's voice is jonathan schneider my guest today is jonathan schneider jonathan how are you doing super well how are you i'm very well very well i am looking forward to going back to algorithm school with here absolutely always looking forward to going there excellent so i'm before we get into the guts of how open rewrite works i'd like to know how you find yourself in a world writing pares galore i assume and abstract syntrax tree manipulators and all that stuff where did you start yeah this this story began almost eight years ago i was working on engineering tools that at netflix and at the time netflix pretty small engineering team relative to the other sort of fang companies in the area but they had this special cultural t called freedom and responsibility which meant as a member of a central team you couldn't impose any constraints on what product engineers did so i find myself on engineering tools trying to help people move forward you know for their own benefit as well like that could be moving forward from one language version to another or we were trying to get off of an old loging library called blitz for j that we had written internally and we trying to move to slf forj so these these kind of you know migration activities that didn't affect just one product team but the whole company we trying to get folks to move along and spent quite a bit of time on reporting so just the act of like finding the issue surfacing it to the developers in a way that would kind of let them know there was something to be done and went you know honestly pretty pretty far in that we like you know would report some sort of defect in the build log made sure it was at the end of the bill log so it's the first thing they saw colorized the output of the bill log colorized jenkins output just kind of went all the way and it resulted in approximately zero action on the part of developer so we ask what would it take yeah for you to do this right and they they kind of answer sarcastically do it for me otherwise i've got something else to do they didn't need an external team coming to them with extra problems that's right that's right i can yeah i can sympathize with that i can also sympathize with the position where you've got you must have loads of different projects in loads of different languages with loads of different versions and no consistency that's right right that's ability culture guarantee that there was not a high degree of consistency between the code in one product team versus another okay so i know you didn't go be tempting to change that culture and have a bit more enforcement of rules i know that's not the road you went down give me your pragmatic road yeah i and i would say there was there were certain like attempts in that direction there was there was definitely the like maybe we should do a lot more unit testing here inside the company and these kinds of things just tended to not latch on inside of it so i think we started with something fairly small there was a open source project that still exists today called grent which was trying to just manipulate dependencies in great old groovy files which seems like a pretty hard general problem because gradal as a build system is expressed in groovy so that's a turn complete language and you know like in theory depending on how funky those files get that could be very nasty yeah it could be so that was a that was also greater lint was an as manipulation sort of sort of thing but the scope of the problem was very small so i think we we started with that just trying to manipulate or massage dependencies and other configuration in gradle files and then pretty quickly people started saying you know what if we could do this in the main source codee as well like outside of just the build files yeah so so how successful first was the gradal manipulator i mean how well did it work in the face of touring complete configuration files i think i think in it's it's great to be really really focused on how much you can achieve pragmatically and not theoretically here so you know 90% of the time people define independency in a very vanilla plain way sometimes they you know iterate over a list of something and you know map it to something else and somehow a dependency comes out of that but yeah if you just discard the exotic cases for a little bit and think you know can i solve the large part of the problem then we actually got pretty far with that and so you tackled java next is that how it evolved java next and so you know the the the the netflix microservice in ecosystem of the time was predominantly java with the exception of the the studio team which i think was right in ruby but it was more or less java across the board this is already pretty ambitious right because you must be writing a paa are you writing a paa for groovy and now writing a paa for java or you hooking into their paers definitely hooking into theirs so you know had some some pretty great tools around that already and and some prior art to kind of work with and and java of course the compiler itself is written in java i did not know that the parser is quite good as you can imagine inside of inside of the java compiler so rather than starting from thex we started from already a richer representation which was the compiler internal as okay so take me through this if i wanted to write a java syntax tree rewriter yeah would i do in general for any language there's there's sort of multiple steps you've got the source code is text and if you go back to your kind of cs class you know on compilers way way back when you have to take that text and tokenize it and turn it into an abstract syntax tree so there's technologies in the java ecosystem and and others like anto which is which are fantastic for describing grammars and and generating parsers off of those gramers but that's going to get you a syntax tree so that's going to turn just the text of the code into that tree of of syntax nodes but say you're looking at a method invocation like i'm looking at a a call to the method add on a list right i will have some syntax node which is which is a method invocation node where the name the simple name of the method is add but from just looking at the syntax it's not apparent that the receiver type of that method call is list okay so you just see the word add i don't know if that's list. add i don't know if that's set. add i don't know if it's headers do add so you got the syntax tree and it's already lost type information is that what you're saying it's it's almost like it hasn't yet gotten type information so you're you're starting from the source as text oh right we haven't run it through the the first step is to produce that syntax tree yeah yeah of course okay so a compiler second phase or the second step is to take that syntax tree and now go and start solving for types so it's you know that's its responsibility is to go and i see this this method ad i need to figure out which ad it is and you know and and so that can be a very complicated process as you can imagine it's you know it's looking up imports it's looking at what's on the class path it's trying to uniquely solve for what ad is in this situation yeah yeah and fun new stuff fun recent stuff like type inference along the way absolutely absolutely yeah yeah got generics involved you've got so that can be a really complicated process so when i started working on open rewrite rather than starting from an antar like parer i thought it's best to start from the rich parser available which is the compiler and so open re writes java we call this lossless semantic tree is mapped from the internal compiler as oh you right you've just introduced two new terms we need to break down there so lossless semantic tree what's that and why do i care yeah absolutely so lossless semantic trier lst is is the sytax the syntax tree like we were describing plus all that type attribution information the the solved types for you know what ad is where ad is coming from plus there's one other thing which is we have to go back to the original source code and go find all the white space and comments and things of that sort because that stuff is usually discarded very very early on in the production of the abstract andn tex tre so all that kind of white space gets bolted onto this lossless semantic tree as well because you want to be able to spit out a new version of a file that has all the same white space and syntax but a new method or a new absolutely aru variable name and that's why we can't use the compiler internal as directly because though they really have different purposes the compiler internal est is an intermediate representation on the way to producing bite code and of course the whit space and things of that sort are not relevant to the bite code but they're highly relevant to to actually printing back out as text of source code and and producing it a diff so that's i can see that i would have do they not hold on to some of that for the sake of error messages yeah generally no you know most parsers will will just kind of throw away whites space as they're tokenizing the the the source code so you know it may as part of that tokenization it may trip over a particular token and fail right there and know where it was but but yeah it's it tends to be discarded very early on and even defining in the grammar as something to be just thr away yeah yeah i suppose maybe they're just holding on to line number and column number so they can go back to the source code and show you that yeah so you're saying you've hooked into java's paa and then it does the like type resolutions that's you you hook in there grab that and then go back to the source code and chew in white space and stuff it's like as we're so we wind up implementing a visitor over the internal compiler est where we're going down all the compiler internal types and mapping them one at a time over to open rewrite lst model elements that correspond to each one of those and while we're doing that we're kind of like we have like a position in the source code that we're advancing as we go and so that you know we can always see what the prefix or white space on an element really is is this like saying okay the next token i'm expecting must be an ad so give me all the white space until we find an ad or explode that's exactly right yeah and so if the parser is done perfectly you never have a miss match of expectations but that really is never say never that's right that's right that's it takes a few iterations to get to that point yeah okay so h how much have we got the sense of all the data you've added to this lst lossless semantic tree almost but then there's one other thing and and that's there's this concept we call markers which marker is just kind of a bare interface that doesn't have any contract to it but markers are just kind of like a bag of data that we can hang on any level of the lossless semantic tree in the very earliest forms we only imagin markers as something that we would hang at the very top level and so markers are things where we hold information like you know what was the java version used what what were all the types on the class path available at the time this was compiled whether or not they're used inside the file okay were the transitive dependencies of you know this project at the time that it was compiled and how were those transitive dependencies computed what was influencing those version selections and so forth and all that you could do something like you could add some new code that uses a ray list and you'd know whether you need to add the import statement that's right and whether it will work okay yeah or we can have conditional recipes where we'll say i'm trying to get you know like a very verbose statement to a simpler one and you know if google guav is on the class path i'll do this if apache commons is on the class path i'll do that or yeah you know so that you can you know produce a change that's that introduces as few additional new dependencies as possible yeah yeah that makes sense and probably sticks with the conventions of the project at large that's right that's right yeah and in that concept that that concept is you know make the change look idiomatically consistent in the context of each project that the change is being applied to okay that makes me wonder i'll i'll keep going in order but like an abstract syntax tree my mind is forking down different roads we can go but let's stay on this for a bit so if you you've got this lossless semantic tree your next step i assume is to transform it into a different lossless semantic tree of what you want the the code to be that's right that's absolutely right which is going to involve you've got a tree of java classes and you're rewriting that tree that's right yeah so every change is really just a change on the tree in some way or another right take me through an example yeah absolutely so you you've got a we i give this example all the time of like changing the every iner literal to you know 42 because 42 is the answer to life universe and everything and so you know you in that case you would in this recipe you would implement you know a visitor visitor you can think of as like an event driven mechanism where you can intercept just literals and you don't care what's surrounding that literal is that literal a you know an assignment to a field in a class or is it an assignment to a local local variable or is it part of a list array or i mean list like you know where is it defined you can just intercept just the literal and you know each lsp element has data elements on it so in the case of a literal it's got a value and it's got a value source on and so you would take that literal and you would say with value and you change it to something else in the case of open rewrite we have you know this pattern this these p this pattern called wither these wither methods that the lst model elements themselves are all immutable value objects and so when you call with on one of the data elements you're actually constructing a new literal object and returning that new literal from the visit literal method and that new object winds up getting it basically bubbles all the way back up to the top so if you create a new literal whatever is contained in gets a new thing created and new thing created all the way up the up the line we check at every level whether the thing that's been returned below me is the same reference as what i started with and if it isn't then a new reference gets created so that by the time we get back all the bubble all the way back up to the top level compilation unit the top level lst element we can just do a simple referential equality check on that compilation unit to see whether a change has been made somewhere down tree yeah it's reminding me a lot of git when you change a file down in the tree the hash bubbles up to the top yeah we keep using the same tricks and compus that's right that's that's right okay i'm gonna have to push you on a more complic complicated example that's for a literal yeah let's say i want to do something that involves a sub tree like i'm i found a faster way to add two strings together so i want to replace all these string plus string with some function called on those two strings yeah absolutely yeah so we have two forms of visitors one we call like so there'll be a java visitor which is designed to accept only java lst elements it kind of filters it at the top and then you have this set of visit methods visit literal visit binary visit method impation all the way down and there's a special form of that visitor called the iso visit iso kind of roughly stands for isomorphic in this case in the case of that literal thing we were talking about i would implement a java iso visitor because i'm getting a literal in and i'm always returning a literal right in this case i'm just changing the value on it in this scenario i'm getting taken in a binary and i'm returning a method invocation so there's nothing so as long as it's just a regular joba visitor i can always just completely construct a different type that than the one that was given to me originally okay and i have access to walk down my little sub tree to find out what's going on and manipulate that yeah so you would intercept the binary you're looking for string concatenation binaries and whenever you find one of a certain characteristic you just return a method ification instead yeah okay that makes sense what about context can i go up the tree and find out where i'm being called what i'm being called within yeah absolutely the the visitor has a concept called a cursor which just maintains a stack of all the elements that have gotten you to this point and cursors themselves the cursors are actually created and discarded as you go up and down the tree they've got a message passing mechanism on them as well so as you're kind of like working your way down the tree you can put messages on a cursor element and then you might wind up eight levels further down and you could say look up and get me the nearest message or put a message up you know somewhere higher up so that when return returns to the or control returns to that higher level object i have data that's been supplied to me from you know somewhere below right okay yeah that makes makes sense so and i'm is it the case that i'm always writing these rewrite rules in java code that has been i think you're going to see very shortly as we're we're just about to land the ruby implementation that the we kind of think of like two phases of of of language adding new languages one that we're able to write a refactoring recipe in java to transform that language because the core frameworks written in java but then the second phase is that you're able to write a recipe in the target language that you're trying to manipulate and how we're going to achieve that is very different depending on the language in the case of ruby we've got j ruby right so it's very trivial actually to write the ruby program a ruby recipe and execute it on the you know the sort of like general you infrastructure yeah for other languages until recently this was a much harder proposition yeah cuz i'm thinking let me try and pick a good example terraform i know you can rewrite terraform for is that something where you're hooking into the terraform paa and what prospect have you got of rewriting those in non java absolutely in the case of terraform we did actually write an an our grammar for terraform and b base it off of that now notice in terraform there's no type attribution there's no type solving so for things like xml json those sort of things we tend to start with those parer grammars like anar style param and build from there yeah most of those sort of config file things probably i'm guessing isn't that hard to write a paa it really depends and in the case of terraform terraform was actually much harder than it appears on the surface because there's a lot of accidental i think grammatical ambiguity to that language that made it almost impossible to write an an for grammar for it i think we were able to do it i think it goes to show like you know friends don't let friends write new languages right unless you're really really experienced language engineer which i think mitchell was not you shouldn't be doing this it's it's very difficult to write grammatically unambiguous languages yeah yeah i can believe that and i i think there's i think particularly in the devops world there's a t tendy to build start with a config file and keep adding features until you accidentally find it touring complete right absolutely i i still remember the proof of xslt turn completeness from way back when why does that not surprise me at all a shock at the time when i first saw that proof that's for sure but that that really has influenced my thinking ever since yeah yeah it's makes you wonder what cheering completeness actually means to us right i mean is it is it a measure of power or a measure of danger sometimes well from the language insurance perspective i see it as danger yeah definitely perceive it as danger you must have particular feelings about yamal then it it there's an interesting point here with yaml which is that these one of the surprising things as we develop new languages as we thought we were going to be working completely on completely different models for each language like different lst models but when i remember when we started looking at javascript and and building up rewrite javascript we found that there was like 90 plus percent similarity on between the structure of the lst model of javascript as as java and so in a way that's not surprising they're both broadly c family languages so there's a lot of you know a common history to them even though they look very different in source code so when we went to im meant that javascript the lst model actually extends from j which is the kind of root java model which meant that there was some there's some reuse actually between these languages as well the change method name recipe written for java actually works automatically in javascript really yeah and so that it's commonly thought that yaml is just json in another form there is actually no shar between the two even though conceptually they're very similar yl is quite quite different really structurally okay so javas now hang on because i can believe that javascript and java are roughly similar especially as javascript was explicitly trying to java in many ways because of popularity at the time but do you not get i mean like javascript has some really weird itner cases about coercion and the meaning of white space and that stuff absolutely and so you know coer like the way that the languages treat their types doesn't necessarily relate to the structure of their syntax so the syntax tree the syntax the model elements are very very similar the same you know on that same we call these grammar islands of self similar languages on that same grammar island with java and javascript are groovy and cotlin not surprising jvm languages although cotlin looks very different from java so maybe that is surprising the c is on that same grammar island python is on the same grammar island believe it or not ruby is on that same grammar island and ruby is one that surprises me there is python cu i would have thought what being like wh space sensitive wh space limited blocks would change things it only changes things in that there's less freedom to choose alternative white space formatting i think is really what it comes down to okay then let's move on to the third stage of this because once you've got a new abstra abstract syntax tree you need to print it out that's whole extra boatload of work yeah the printer itself is actually a visitor so it's a visitor that just accumulates information to a you know some some sort of string builder or a pender as it's walking down the tree so that's definitely part of any language implementation we tend to develop the printer and the parser simultaneously that makes sense and so we'll we'll build a whole suite of unit tests that represent all the syntactic variation that we can disc discover and the success criteria is that we're able to take a text a piece of text that represents that example of syntax parts it into that lst and then print it back out losslessly we call that parts to print idempotence that like you start from just sort code we should end with that same source code yeah so your success criteria is having done an enormous amount of work you achieve nothing that's right but in a very interesting place to build from that's absolutely right so you know when i was first writing the java parser the the the goal was to take the entire 20,000 netflix microservices or whatever it was and and prove parts to print idempotence 100% of those how long did that take to get to that point i i would say it took about four months for that initial implementation that seems a lot faster than i would have expected there is and that speaks i think to the quality in this case of the the internal compiler as it really is a a work of art i mean i think depending on the the language the internal compiler ests are well there are various qualities depending on the language depending on the implementation but the the java really an amazing piece of work and engineering okay some some people are going to think me mean for asking this but i can't resist have you tackled php and how's that i haven't even looked at php no i'm curious though i i hear ruby's syntax is famously spicy that must be challenge enough it's very spicy i i'm pretty confident you could not define an gr or any sort of formal grammar for ruby i think it's it's there's a lot of accidental complexity in ruby can you give me an example yeah i i think there's this example of a ternary expression where you could say if assume there's no spaces here 1 equals equals x question mark that's that tary kind of conditional and then you could say you know the true statement like so oneals equals x mark a colon b that will fail to compile but if you write xals equals one question mark a col b that will succeed at compiling so the only difference here is 1al x versus xal 1 i'm just inverted that at the at the beginning and that's because question mark can be both a it can be part of an identifier so it ruby can't tell whether that's part of a method name or if it's a tary operator so if the x is next to the question mark it could be either and it's yes that's one then one question mark isn't a valid identifier so it's so there's things like that that are really how could you teach a grammar or a parer to to to really recognize the distinction between those two things yeah yeah that's okay that doesn't seem like fun but you must hit that kind of problem on the way out as well because you've got to be careful not to create rewrite rules that can produce that kind of output i think that's true and and yeah i wouldn't say that the the lst model prohibits you from creating a change that would ultimately result in a compilation error but rather like we and this goes back to the pragmatic thing like how often would it be that i would be happ to do a change method name where the method name you know that that would result in this kind of scenario it's it's not going to be super common yeah okay so you're content in those cases to just say well get get check out and rewrite the file back that way that's right yeah yeah that's fair what about and this is one of those topics that's kind of unnecessarily controversial in my opinion but it is controversial you're writing out some new code i mean you you can do identity transformations but you're writing out some new code and you want to keep it in the same wh space style as the original code absolutely yeah and so one of the things we do with that if we go back to the what how we were defining lst how we keep all the white space of the original code we have a whole series of heris where we derive what the prevailing style that project is you know based on the white space that we can observe in it so is it using tabs is he using spaces how is it doing continuation indenting versus indenting so do i do two indentations to the to the left such as like when we use like fluent method builders or is it just one that can be language specific continuation indenting and cotlin is less common in 2024 than it is in java yeah some some of these rules about what should be continuation indented versus not are themselves i think not really well specified and are subject to probably ide bugs over many years where you know something that should have been continuation indented was only indented or vice versa but because but then that rule sticks because to change it to fix that bug would cause you know autof formatting a file to change format and so there's this tendency for these intentional or unintentional rules around indentation to stick over over the long term and discovering all that very complicated but at any rate we there's a there tends there's a utility inside of the visitor called auto format where you can call autof format just on a sub that you're modifying or you could call auto format on the whole file and so whenever you're inserting new blocks of code you tend to call auto format on just that sub tree that you're inserting and it massages it to look consistent with the context of the code around it oh okay so i don't have to worry about whit space until right at the end of the piece of syntax i'm about to return this problem actually goes beyond just whites space to also include other forms of style like import formatting should i use wild card imports like a star wild card import or not how many types need to be in a pack for me to use a wild card import versus not is there a different number of types in static imports versus non-stack imports to use a wild card or not and so that is also something that we're deriving as we're looking at the at the existing code and so you may get to a situation where you just remove an import you remove one type because you've changed it to something else is that type covered by a wild card import now and by removing the last reference to that type in the file are there now only you know n minus one wild card imports remaining and therefore i should unfold the wild card into a series of name type imports and so that stuff is also kind of rolled up into what it means to add and remove imports at the framework level and i can i can see that you get paid people mad at you if you don't do this yeah people get really really hot about these things that's right how are you actually doing that are you just sort of heuristically tracking for patterns or something absolutely so and that's all it's a it's it's a algorithm that you can run that you can implement as a visitor itself you can look at all the body of code after you've parsed it into lsts and calculate we basically you know count occurrences of different kinds of styles and then try to decide on what the predominant style was so could you write a rule that said go through my code base find the most popular style of implementation that we tend to use and make the entire code base use that universally absolutely yeah so auto format itself is a recipe that has all of the individual options so you could derive what the predominant style is and then use that as input to running the auto format recipe to right make that way and that's not something people start with actually which is to just go through and you know add some level of consistency before they do anything else why can i see someone running this you know as soon as jeff leaves the company going over it to rewrite all jeff's code because jeff was rubbish at that stuff i know yeah we didn't have the tell him until he left that's right i i tend to i think personally i tend to avoid this kind of this this kind of like conflict by just blaming someone else like i'll just say like we use whatever the ide default is no question that's the easiest way to onboard new employees especially if you're working in an open source project you don't have to have a contributors. markdown or something where you know you style or that style just it should be if i component with a a popular ide it should do work and i don't always love the default styles but i've long since wanted to just accept it yeah me too i i generally don't love the default styles but i love not arguing about it at all too and that's worth more to me that's right yeah i like languages these days that ship with an official code format that has no options and no flags it certainly makes it a lot easier when that's cas but but you don't get that luxury you have to live in a world where that isn't the case right that's right and you know it's it's there is you goang is one of those right the goang is one of those it has g fump as part of it it's kind of core core technology stack and you know that's i think that is representative of google culture right which is much more control oriented that like you know monor repo you know google java format or gone you know like one style to rule them all there are some good things about that you know you kind of refactor more quickly but it also has consequences it has consequences on like there's a higher degree of like a code review and like so you know in some ways things don't move as fast but there's a you know a lower degree of variability in that code base as well yeah i think you have to choose your battles which which which metrics are worth having flexibility over and which might you just delegate to a computer and not worry about anymore that's that's very true yeah that's very true okay well why don't we get in a little bit as we're veering there anyway get back into user space a bit and talk about like as a user of a rewrite tool like open rewrite like what kind of things can it do for me we've talked about reformatting and how hard is it for me to extend it with my own inhouse special roles yeah and so there's what can it do for me i think i think there's this is this system of of refactoring as i'm describing this is a rule-based refactoring system this is very much a an encapsulation play or a belief in encapsulation that if that if i provide a base recipe like change method name that it will be quicker to write common api changes on top of that bas and if and and a recognition that i think that the the the third party and open source ecosystem upon we which we rely is itself subject to a lot of encapsulation so i think about like spring boot for example you really common java framework spring boot has its own spring boot code but it's also built on top of spring framework which is in turn built on top of all you know hundreds of thousands of other open source projects and so you know if you take one of those like the unit testing framework junit you know spring testing is based on junit so if i solve the problem of moving from junit four to 5 if i could encapsulate that as a recipe then it becomes easier for me to write a recipe that moves from say spring boot two to spring boot 3 it really requires a level of participation up and down the language stack from the lowest level library all the way to the you know the big frameworks to unlock my ability as a user of one of those frameworks to move more quickly between versions so you really are going to that level of ambition where you'd replace the whole version of a framework and all its sub dependencies absolutely i think i think my view of the world or the world i want to see is that framework authors are responsible when they make breaking changes for providing the recipe that fixes their downstream consumer in other words kind of you break it you fix it right now the unit economics of this change are really backwards i used to work for the spring team if i make a breaking change that impacts you know 20 million developers downstream of me or should i have taken the time at the time that i made the change to also provide the recipe yeah why i think it's very very very important that such a technology be like permissively open source because only if the technology is truly apache licensed or something that's very permissive that allows others to build commercial products on top of it can we expect the community to really participate in riding you know res p yeah and then we might hit the dream where languages are a bit less afraid to deprecate old craft from the earlier versions that just as a whole world were able to kind of move more quickly towards the outcome we wanted you we're not kind of dragged down by the technical data of of 10 years ago you know yeah one of the blockers to that i would have thought will be the predominant like you can write you can write transformations for different languages and you support you support quite a lot of note and rewrite but you're kind of pushed to writing those rewrite rules in java and and that's why it's very important i think that we do the two-phase language support that you're able to write recipes in the language that you're trying to transform and so the the first example you'll see of that is is with ruby coming out here where you can write a ruby recipe to transform ruby it's very important i think to to provide a native recipe authorship experience in the language you're trying to transform and do you think that will tend to be the job of the open rewrite maintainers or do you think it will eventually be something that language maintainers themselves support i i think if i create chris lang can i then would i then be expected to write a chris lang paer and printer and visitor it's a good question i think you know even below the language level at the framework level i think what i want to see maybe i believe a little bit in competition here that i'm thinking of like we mentioned spring but there's there's there's also competitors to spring in the java ecosystem the red hat has corkus oracle has micronaut those are competing for market share with spring or developer mind share like what should i build my application in yeah and if say and so as you know kind of call out i think oracle for the last couple years has on every breaking change in micronaut has provided a recipe that fixes that that breaking change so micronaut was really leading the way on that experience of i you can move easily between major versions of micronaut that should be a reason why i consider micronaut as a developer over spring yeah and you know if i opt out of that as a framework author then you know that's it's just one of the decision points that i'm making as a as a user ah yeah so you're saying it as a competitive competitive advantage if you do choose to get involved absolutely and now imagine from a vendor's perspective suppose i'm trying to i'm starting a new application monitoring platform you know and i'm trying to compete with data dog i know that i have to go through and replace data dog specific um you know like vendor locking sort of like source code with mine if i provide those recipes then i expand in my customer base much more quickly than i would have otherwise yeah yeah and when one of your competitors goes bust the first person to write those rules or get the lion share of the people looking for a replacement right how i mean this is possibly pushing it too far but how ambitious do you think you could get if someone said i've got this ruby on rail site and i'd like to migrate it to d jango on python do you think you'd ever get that far or is that pushing the boat too far i my tendency is to think it's too far but then again like i change over time in this too so broadly i say there's creative activity and software development and then there's really mechanical activity and while it's hard to precisely define what what's what we know we feel it when it's mechanical i used to for a long time i i watched you know baseball in the united states of st louis watch st louis cardinals and they have 162 games a year and i used to reserve maintenance activity for cardinals baseball games because baseball isn't quite interesting enough to consume my attention but neither is mechanical activity in coast so i would do the same do them at the same time kind of like and you know but so you know would do you consider a rails to jango migration to be creative or mechanical sometimes it can be more mechanical than we expect at the beginning yeah yeah i suppose if you're using the vanilla stuff rather than some particular funky i bet libraries i bet different libraries is where you fall down it it it'll all just be a matter of diminishing return right at what where is that point of diminishing return for me yeah at what point do you would you be better off just doing it creatively rather than trying to come with a rule that can do it mechanically that's right yeah i can see that okay so if we're getting into the land of multiple languages does the game change when you start to try and apply this tool to whole projects or even whole company's worth of projects explain what you mean by that i'm just thinking so if you wanted to call open rewrite on google or facebook's monor repo now you're dealing with a vast number of languages and a vast code base can you scale to that kind of size are you keeping the keeping the size of the code base small and focused i think so scale is certainly one of the the points of like where as a company mad we've we've taken this lst this lossless semantic tree which in the open source tools we're producing in memory and we've taken this extra step to figure out what it means to serialize into dis which itself is pretty tough a problem because these trees are actually cyclic in nature especially the the type attribut and information yeah yeah there's a lot of work to do in cutting cycles and then reconstituting them as cycles on the other end and you know this this sort of work but once you have a lst on dis that's the sort of like you know fundamental block upon which you can build a horizontally scalable system to operate on hundreds of millions of lines of code and so i think when you're running an open reate recipe on one repo the cost and time is dominated by the parsing not the recipe running i can believe that yeah and so you can still achieve a great degree of value you parse you run a recipe you made the change great move on on but then when you want to do that for the other 10,000 repositories you wind up sort of burying that cost more and more if the recipe is really really well battle tested think of like the java a to7 recipe at this point yeah it's still arguably okay to bear that cost that like parsing cost once no matter how many projects you have and so when when we heard adam ssky the aws ceo get up on stage and say that amazon migrated a thousand java applications from java 8 to 17 in its own code base in two days he was doing that with open source but they were able to do that because that recipe is so well battle tested if you you were developing a new recipe that was you know making some you would want to be able to iterate on it you know many times over again yeah yeah and in that case that the cost of parsing really really really adds up and and starts to be an impediment so what do you do do you attach your lst to the hash of the source file or something that's yeah that's definitely absolutely so you know we the goal would be clone dozens or hundreds or thousands of projects build the lst and keep that as an artifact as you know both permanently in the artifact store and you know locally on you know where where you're where you've got these repositories clos and then you can do a recursive operation on a whole directory structure you know running a recipe on every repository route that's found in that directory structure those kinds of experiences where you want to be able to operate on a large code base okay what about something less invasive like i'm assuming i can use the same system for code linting where i don't want to change anything i be warned of patterns absolutely yeah so it's this is a discovery i think remember we talked about markers a while back and we were originally using markers to put information about like what java version what dependencies existed those kinds of things on the lst but because a marker can exist anywhere mad's co-founder olage a couple years ago you know kind of pioneered the idea of like what if we just used a special kind of marker to indicate where where something was found as like a search result and so we do have an interface called search result which is an extension of marker and a refactoring recipe rather than making a change to the lst model can just add a search result marker to any lst element and then we have a choice of how to render that search result marker when we go to print out the lst so we could print it as a little comment with an arrow point a particular place or you can you know there's you can render it any way that you want to sort of actualize it in the source code but that unlocked a search capability so curiously search wound up being a special case of transformation oh yeah yeah i can see that which is not what we expected at the beginning dly quite sophisticated search because you've got the type information there too exactly so one of the really interesting examples is find uses of deprecated methods where we're able to look at every method inv vacation in a source a body of source code and tell whether that indication is deprecated at the time that it was compiled there's nothing in the source code itself that would indicate to you that something's deprecated you know it's it's something that's and levels up the type attribution information yeah yeah okay that makes sense so we started to take that one step further and this was so the marker search result marker was the first kind of like foray and a search the second foray was was to that recipes can now define what's called data tables and this is an open source as well and data tables are just column or data like it's a colum or format like you know if you were just to emit a table what would the column names be and what what are the data elements on them and then a recipe as it's going through its normal visitor it's it's like working through the code base it can insert rows of that column structure into a table and then at the end of the recipe we can just actualize that table in an excel file or csv or whatever column or output that we want to achieve and then if we do that across hundreds of repositories we're actually collecting data across you know potentially the entire code base so we use this to do things like find sensitive api endpoints that that that produce pii whether or not that pii is visible at the the top level return or it's buried somewhere in the model object that you're returning find vulnerable dependencies find usages of particular apis and one of the columns in the case of fine methods in the fine methods data table is the actual code snippet of the method call so if you're doing an impact analysis i'm thinking of changing this api you can start by just finding all the usages of the api and you quickly get an excel a all the like variations of the way that api is used across a comp yeah or there's been a security warning on some method in some dependent library do we use it do we use it anywhere important yeah that's right yeah that's quite cool okay so i should probably for time i should push on to my two last questions which is the first one is if i let me think of an outof band language g i'm going to pick the language gle and i decide i would love to have this capability for gleam should i take inspiration from you and hook into the paer and write my own lossless tree and a printer which sounds like a bunch of work but not desperately or or should i just try and support gleam in in open rewrite which you think would be the path of least resistance i i think that there are some there's some common support and open reite that would help you make progress the this question i think partially depends on whether you know how hard to interop between the open re sort of like java based infrastructure and you know gleams compiler really is right in this in this way we were i was actually pretty concerned for a while how are we going to support a language like c which there's not really an obvious way to run c code on java i can run ruby code on java easily i can run python code to some extent javascript ruby and j python yeah but c what am i gonna do and i think lately there's been some really amazing work there's a project out there called chery the it's d libo or d y li ibso dibo chickory on github and chory basically enables any wasm compatible binary to run on jbm oh okay and so that's unlocked a world of opportunity i think for c for c++ for swift for those languages to for us to build parsers so we would build a parser in swift but then we could and potentially even build a recipe in swift but then that can execute inside the context of the sort of open reite recipe schedu so that i think is what we're going to see here in you know in 2024 as we expand into c and that'll provide the kind of like template that other use as well yeah there's a use case for wm i wouldn't have foreen when they announced the project me too i've been kind of like you know deriding it as like you know corba 2 for for years and i might have to keep my words on this well it's good to be humbled occasionally by the world okay so if i don't want to go to all that work i am going to get myself a jvm and download open rewrite where where should i start with it yeah absolutely so on github the organization is open rewrite and there's a bunch of different repositories inside of that open rewrite rewrite is where most of the you know the stable language parsers are but you know there's we have modules like recipe modules rewrite spring rewrite logging frameworks etc that are that are community maintained for various applications okay cool and so i'm i'm not actually i'm pretty sure i'm not going to go to this amount of work i will just leave you as a final unsettle hint it is possible to call hascal code from java is it really yeah yeah company i worked for worked on a bridging project for it i think you can go in both directions if memory serves what is that project called oh i will have to find it and send it to you and put it in the show notes okay very good yeah curious to see so in case you're tempted down the line to add high school support cool right i think i should go and at least try and lint some code if not rewrite it entirely so jonathan thank you very much for joining us yeah thank you was p thank you jonathan and i have to correct that last thing i said there i double checked there are actually two libraries one for calling hascal from java and one for the other way around link to both in the show notes if you want them along with the more relevant and pressing link to open rewrite if you want to give that a try it has got support for an impressive list of different file types and languages and when you think about the amount of work that takes i think it's worth checking if one of your languages or files is in that list it might well have a place in your toolbox before you go and do that if you've enjoyed this episode please let us know give it a like if you've liked it share it with someone if you know someone who might enjoy it and make sure you're subscribed cuz we'll be back next week with another interesting voice in the world of software development until then i've have been your host chris jenkins this has been developer voices with jonathan schneider thanks for listening