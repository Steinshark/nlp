so thank you jens and welcome everyone to this first evening talk a software design talk about type eurasia now you might be here for three different reasons you might be here because there's no other talk in parallel still you're in the right spot you might be here because you've never heard about type eurasia or because you've heard about it but don't know what is hiding behind that then you're definitely in the right spot or you might be here because you actually know type erasure and you're wondering what is different about this talk and you're right there is actually a couple of talks about type erasure already however all of these talks have mostly one thing in common they very very quickly jump into the implementation details and basically never leave this place for that reason they might actually skip a couple of very interesting properties of this technique and this is now what i do to tonight i will talk about the design properties of type erasure and so this indeed will be a software design talk so i will not show a lot of very specific implementation details i will not do a lot of no except i will not show forwarding and r value references and jason ben if you see this i will not use a lot of context for either it will be entirely about software design indeed now before i get started allow me to very quickly introduce myself jensen's already said i'm klaus but i'm pretty much aware that many people cannot pronounce my last name so i'm very happy if you just call me klaus and i'm just happy that you talk to me at all so i'm just close and i'm actually working as a c plus bus trainer consultant and in that job i very much like to talk about software design because i personally consider this to be a very very important topic and that will actually be the first part a couple of slides about what is the challenge of software design after that i will not immediately jump into type erasure and how this sounds disappointing but i actually want to build this up i first want to talk a little bit about how we can solve problems naively and you'll be super disappointed after that then we'll actually try to solve this better in a classic way by means of design patterns and after that so approximately 20 to perhaps 25 minutes will actually jump into typo asia but by that time you have a very good understanding what we're actually looking for so the challenge of software design why do i feel this is such an important topic such a basic topic and essentially it's about the general problem that all of us face now all of our software developers the problem that we actually have to deal with daily and that problem is change yes the one constant and software development change your change is not a problem in itself it's actually the truth in industry that software must be adaptable to frequent changes it is expected that things change and as a cycle mark this is actually the reason why software is called software it is supposed to change it is supposed to easily adapt to any kind of requirements change yet of course you are aware that it might not be that way no actually software sometimes does not feel easy to change on a country sometimes you pick something that sounds easy but two weeks later you realize that actually this was quite a difficult task there is something that makes our life so much harder and that's the thing that is actually the pain of a software development the thing that we are always haunted by dependencies and of course i'm not talking about the necessary dependencies at some point things need to work together at some points there is natural intuitive dependencies but i'm talking about the artificial dependencies those things that really make things so much harder that makes change so much harder and so much more difficult and that is exactly what we want to change this is exactly what we want to minimize just to give you one idea how bad this actually is a quote by ken beck kind of the inventor of tdd dependency is the key problem in software development at all scales so indeed this is the problem that you have to face on a daily basis change is the motivating the driving force but dependency is the real problem and so let's take a look at how dependencies build up and let's introduce a toy problem and let's try to solve it a little naively by simply using inheritance and the toy problem for this evening is shapes yeah okay i know this is already where some people move to the other talk that doesn't happen in parallel but still a lot of people are not disappointed oh such a boring topic i agree it's kind of simple but perhaps this is exactly why i've chosen this problem it is simple i will show a technique that you've potentially not seen before and so a simple problem actually might help to wrap your mind around all of the details and just to express it in the words of my co-organizer of the munich user group i'm tired of this example but i don't know any better one yes of course we would like to have something better but it's a nice teaching example and so i'll stick to this one so i start with a shape hierarchy we start with a base class called shape which comes with a draw function and of course this now needs to be implemented in many different kinds of shapes so for illustration i'm using circles and squares but please imagine that there's many more ellipses rectangles ovals you name it circle and square implement draw which from a design perspective is already something that is questionable because if you truly want to draw you might actually reach out for graphics library that graphics library say opengl 3dx anything might now actually introduce quite a heavy dependency on circle that is something that is of course pretty undesirable a circle should not be a heavyweight construct that depends on the graphics library of course it should be lightweight having said that an obvious solution is to use inheritance one more like one more layer in this inheritance hierarchy so let's just do not introduce draw in circle but let's have an opengl circle that idea also gives us the ability to actually use different libraries easily like the metal circle using a metal library instead of opengl now you can imagine that as many more implementations different kinds of draw implementations pretty nice and of course it happens on the square side just as well opengl square and metal square this might work for some time but it probably becomes a little hard to maintain as soon as we introduce another function say serialize so we want to turn this shape into a byte pattern and of course later retrieve it from file or database and deserialize it again and create recreate the shape that we've actually stored now how do we implement this serialize well it's the same problem again of course we don't want to do this in circle or square this would create dependencies how do we do that how do we use little endian or big endian so there's a solution inheritance we could just introduce another layer in this hierarchy and introduce something like the opengl little indian square or the opengl big ndn square that is where i implement serialize very nice and of course in metal square we do the same which however already starts to look complicated on one inside but also feel wrong because i know implement serialize twice right perhaps another approach helps and also probably because this hierarchy starts to become pretty deep now this is already four levels perhaps you should just keep it flat and just implement all of the necessary variations in that form so a circle just gets a open g little indian circle and an opengl big ending circle and so on all the variations but also this does not really help with duplication now the draw function is implemented twice so every version of draw and also of course every version of serialized it doesn't feel right it doesn't feel good so if indeed we use inheritance naively to solve a problem this pretty quickly leads to code that we just don't feel is good there's many derived classes and let's be honest with pretty ridiculous names now that this was only two functions imagine the names of four functions not a lot of fun now we have a pretty deep inheritance hierarchy quickly now after just two functions we had a level depth of four is truly quickly close to something that we cannot really manage anymore not even understand anymore there's a lot of duplication also this is what i tried to point out it's not really clear where we should put the one implementation and it's definitely hard to add any other function we don't want to even think about adding a third function that would create a total mess already and so maintenance is definitely not a lot of fun i would actually rate this as pretty hard so what do we do well to quote the pragmatic programmers andrew hunt and david thomas inheritance is rarely the answer what you should do is we should delegate to services has a trump's essay and so we reach for the right kind of solution we reach for a design pattern the classic solution the classic solution to actually solve this kind of dependency problem this kind of complexity issue and the sign pattern that i'm now reaching for is coming from this book the book that most of you have seen before design patterns elements of reusable object oriented software that is the so called genga 4 book ganger 4 because of the four authors and it is the origin of 23 of the most commonly used design patterns just as a as a reminder general reminder what is a design pattern a design pattern is something that has a name and that name expresses some intent you want to distinguish detangle you want to decouple software entities in a very specific way you have an idea how things evolve and this is why you choose a specific kind of pattern that is what the name and the intent contain almost all of the design patterns aim at reducing dependencies there's actually at least two in this book that i don't really count as design patterns this is another talk however they usually aim at reducing dependencies and they for that reason provide some sort of abstraction something that and allows you to actually separate concerns and last but not least a design pattern has proven to work over the years so it's not something that falls falls from the sky and suddenly works now it definitely has to prove that it works in many code bases now this book is a collection not something that these four people invented now i'm choosing one of the most famous design patterns from this book the so-called strategy design pattern now i don't assume that all of you are totally familiar with strategy so here is a short reminder on the left hand side we have the circle class the circle class that we've seen before in this hierarchy and indeed this is now representative of any concrete shape could be square to it could be triangle could be rectangle it's a concrete shape it's not a base class in this class we have the straw function which as we said before creates some kind of dependency something that we would like to extract we have realized that we would like to have many implementations of draw and so we should not have it inside the class we should extract it and this is now what we do by means of the strategy design pattern we introduce another hierarchy and instead of direct inheritance circle now owns the strategy so it has a relationship we might now have a pointer to a strategy this class is now the abstraction of how to draw a circle so there's a draw circle function that we can now implement in various ways that is a an application or now in adherence to the so-called single responsibility principle we extract the thing that changes the variation point but that we actually gain all of these advantages we can now implement an opengl strategy a metal strategy a 3dx strategy anything we like and we actually don't have to draw we can also just do something for testing a test strategy that is something that we can now pass from the outside we call this dependence injection so from the outside we give the circle the thing that it should use to to draw itself and so it's circle doesn't depend on that anymore they've broken that dependency and as last remark we kind of now also fulfill the so-called open close principle because we can now implement any kind of strategy easily without having to modify an existing code once this in place we are free to add whatever we want very good now just as a as a side note okay so i might now have this idea that it's always about inheritance etc no no the strategy design pattern is not limited to object unit programming definitely not and it's also not limited to dynamic polymorphism and last but not least it's also not the language specific idiom the standard library itself is actually full of examples of the strategy design pattern but all totally without inheritance with our base classes static polymorphism so for instance you know that from a lot of the standard algorithms like accumulate so i can accumulate numbers and i specify how i want to accumulate that little plus here is actually a strategy a compile time strategy you specify from the outside by means of dependent section injection how does accumulate should work or standard vector yes a second template argument is actually a strategy you specify from the outside how allocation should work that's a strategy and of course this is true for all containers and some containers actually have more than one strategy now another set has even three the hash the key equal and the allocator all of this are customization points you can specify the behavior from the outside strategy and of course unipointer also a unique pointer takes a deleter that is a strategy so the standard library is full of strategy it's one of the most used design patterns and it definitely always helps so let's apply that to our toy example to the drawing shapes example now i start with a gl color that little piece of code is now supposed to represent some dependency on opengl it's an example so it's it's small it's something that is not very specific but please imagine that this could of course be something much bigger it represents this dependency only all right now we have this shape based class and i said initially that we would like to draw and would like to serialize both of this is pure virtual functions so all the classes that implement that need to implement draw and serialize now before i implement anything else i introduce a draw circle strategy that's a long name true but that is now the abstraction of drawing a circle in a very specific way so this draw function takes a circle potentially many more arguments it indeed can be a couple more and that of course again needs to be implemented by deriving classes that is now the class that the circle uses in the constructor for instance or alternatively by means of setters i pass draw strategy now i could do this by means of a unique corner and i could say so here's circle this is your dependency this is how you draw yourself please remember it so you own it we move the strategy into our data member so we own a strategy and whenever somebody calls draw by means of some arguments of course we simply forward this request to our drawing strategy so we call it straw we pass ourselves all the arguments that are necessary and we can draw ourselves nice so we now have no dependency on opengl anymore no dependency on any graphics library we are given this dependency from the outside really useful indeed so circle is not depending anymore okay notes yeah there's no dependencies on no specific dependencies on any graphics library of course the same happens for squares and all the other shapes so we have a draw square strategy also and note indeed it is two classes it needs to be two classes else we have accidentally coupled all of these kinds of shapes together so i have a draw square strategy that provides a draw function for squares and that is what square now works with it's the same thing in the constructor i get such a strategy i move it into my data memory so i take ownership and whenever somebody calls straw i'll just use that in order to do whatever i'm supposed to do however i'm supposed to draw myself now with this in in in place i cannot finally introduce any kind of strategy so opengl strategy for circles we can have the opengl square strategy all of these now truly use opengl so here this is the representative they may have an opengl color whatever that class now is highly depending on opengl on that specific graphics library not circles not squares they are totally oblivious of that dependency and of course at some point i put all of this together and that happens now in the main function and i might have a vector of unique pointers of shape i create an empty vector and i put all of these things inside so i create a circle i pass the radius 2 and i create an openc opengl circle strategy give it a color that's the second argument the strategy i do this for square two and for another circle and i might draw all the shapes in that vector nice indeed we have actually managed our dependencies very good indeed that is i would say a first true solution to the problem let's take a look at the design as i said the thing that is most important to me what we have in this situation is actually three levels of design in the highest level which is considered to be the one that is most stable the one with the lowest dependencies we introduce this shape-based class that allows us to on another shape let's call it the middle middle level to introduce different kinds of shapes like circle and that on that same level i introduced the according to strategies draw a circle strategy of course it requires knowledge about this circle but that class in itself allows me to on yet another level the lowest level the level where i expect most dependencies the code that also changes most often on that level i can now actually implement any kind of strategy so i have properly separated concerns i have an architecture i have something that can actually maintain for a long time absolutely great super amazing you're much much more happy than the this naive solution that we did in the beginning alex does actually a good job we have extracted the implementation details essentially the single responsibility principle we have created the opportunity for easy extension so we satisfy the open close principle with regard to both the different types and different draw implementations and we have properly separated interfaces we have two strategies one for circle one for square and of course one for for all the other shapes and we've definitely now dealt with the duplication there's one place where we have the implementation for drawing circles one place for dealing with squares etc etc proper design and also we have definitely limited the depth of the inheritance hierarchy big win from my perspective so maintenance is much easier now definitely much better than before great but i can imagine that you're still not happy c plus plus programmers tend to be pretty easily unhappy and that is potentially because you're thinking about performance and yes in c plus this is one of the first arguments and i agree there is a couple of things that actually have a very negative impact on performance first we've just introduced a second indirection so we have the point of the shape but that shape now contains a pointer to some strategy in order to draw a shape we have to call two virtual functions that may become expensive especially for simple operations drawing is probably a little more expensive but there's other things that for these things it might be too expensive we also we have seen that in the main function called a lot of make unique now make unique all over of course make unique is great but of course in this situation it means that we are doing many many tiny allocations many allocations that essentially just result in a lot of pointers a lot of indirections and so yes that is of course the reason why i use unique pointers automatic memory management but still it's not nice would be so much nicer if he could just get rid of all of that then designers back again i've shown that draw stuff i've not really talked about serializing anymore of course we have to do the same and exactly the same for serialize as well which means that we suddenly have two pointers and more base classes more inheritance more a virtual function more pointers it's just more of all the things that we do not particularly like and okay we may have to manage the lifetime explicitly which is done by unique pointer that is true but that doesn't automatically make it more than c plus plus not not really throwing a couple of unique pointers at a solution doesn't make it modern it still feels old it is old it is the old the 90s solution i said there's a lot of hierarchies indeed now think about the serialized stuff also and still something that i personally feel is a design issue circles squares and all the other shapes still know exactly about all the operations that we can run on them like draw serialize and potentially many more yes we have extracted implementation details but we have not really extracted the knowledge about these affordances to use the terminology of arthur dwyer we still know about all of these details and that actually creates all of this unnecessary overhead how much nicer would it be if he could ex completely extract this knowledge how much better it would be for us if a circle would just be a circle and everything else is just plugged in in a different way and how much more modern would it be if it would use a value-based solution not something based on pointers but really values that can be copied that can be moved that actually provides a much easier way of dealing with things so and this is now finally that the point where we actually start to use type erasure we have now seen that this whole stuff works but it doesn't make us happy so let's rethink that one of the first talks you might have seen or heard about type erasure is this one inheritance is the base class of evil a classic it's just approximately 20 minutes long but this is a talk where in in a very very quick way jean-parent actually shows how typerasia can work because that was one of the first talks a lot of people believe that this is where type erasure was invented but i have actually found a paper from the year 2000 and i believe that is the paper where the very first time this technique was described and it was what was described by kevin henney so i truth be told believe kathleen is actually the inventor of this type of ratio technique so take a look at valued conversion it's truly an eye opener very well written and it for the first time in 2000 describes stood any now just because the term type ratio might be something that you've heard differently before what is type ratio and especially what it is not so type ratio is not a void pointer now avoid pointer is a void pointer this is not a technique this is not a design it's it's appointed to node type it's also not pointer to base that's what we call a base inheritance relationship that's not type erasure and for me personally most importantly type ratio is not a variant stood variant is also a design technique kind of but it is a design technique that is 100 orthogonal to the thing that we are doing right now so standard variant is something you use if you want to add operations easily not types what we are after is adding types easily not operations so it's exactly orthogonal so it's definitely not a variant what i'm now using so if you use that term before for these three things please stop this makes sense type ratio is first a templated constructor that you will see is super important and that definitely makes it so powerful second it's a completely non-virtual interface we are now creating around creating something that is dynamic polarism but indeed we will not have openly any virtual function and it is a mixture of three design patterns a design pattern called external polymorphism the bridge design pattern and the prototype design pattern so let's take a look at how exactly this technique works and again i get started by my representative of some dependency so again a representative for opengl the opengl gl color so again it's just representative but that thing must not appear in the things that cannot depend on opengl that must again appear at some place where we can actually deal with that second is a circle class and yes that's it that is the circle class for the rest of this example and note there's no base class there is no virtual function there is no draw function there's no serialized function there's no pointers that is there's nothing it's just a very basic circle it's a circle that i could show on let's say day three of a beginner's training very very straightforward indeed it just represents a generative primitive no dependencies whatsoever and exactly the same is true for square no base class no virtual functions no dependency of on any operation on any affordance very simple so no once again no base class they don't know each other they're totally independent totally unrelated they don't know about the operation and they definitely do not depend on any implementation detail how then do you ask can we actually abstract from these and how do we add the knowledge about drawing etc well that is something that we package differently we package this into these two structs and yes it struck to this point don't worry in a couple of minutes this will not worry anymore i have a struct called shape concept which is designed as a base class and i have a struct sheet model which is actually implemented as a class template and it publicly derives from the shape concept shape concept is an abstraction but the shape model is a wrapper for a real geometry some geometric shape like a circle or a square and the shape model just stores one of these right it's given one of these things in the constructor and it will store that circle squares ovals etc in the base class we now introduce our operations again it's draw and it's serialized it is the things that we need it's the things that we want to do on on any kind of shape and obviously if shape model inherits from shape concept it needs to implement these two virtual functions so we implement serialize we implement draw the implementation however does not contain the details we simply forward to the implementation and this is now the place where you explicitly specify what are the requirements on the given types what do i need so for instance i now require a free serialized function for a circle and a square on whatever i put inside i require free function that of course couples definitely much much less than a member function would do so three functions the same for draw i require a free draw function something that is implemented somewhere but well i get something that i can use on circles squares etc so that is now the specific definition of requirements this slide essentially now of course what you're asking is where do these dependencies go like opengl where do these implementation details hide well before we actually had this in the deriving classes of our shape or our strategy now draw a strategy now this here the shape model might be the right place to put it and i can adapt this if i want to i could introduce something like a strategy as well a draw strategy i could pass a draw strategy i could store that and i could call that whenever it is required that thing might not contain all the things we need like colors textures opengl specific stuff that is the thing that we where all the dependencies go so i however have complete freedom to decide how this should look like i am in charge this is not something that the circle implements this is something that is external external indeed and so this is the so-called external polymorphism design pattern a very very interesting and i believe a very powerful design pattern indeed now design but it is not one of these 23 classic gang of four design patterns that is a design pattern that has been introduced two years after in 1996 by chris cleland douglas schmidt and timothy harrison these three actually introduced something that allows us to deal with polymorphism slightly differently so here's the intent allow c plus classes unrelated by inheritance and or having no virtual methods to be treated polymorphically which is exactly what what we need for circles and squares there is no virtual function in there they're not polymorphic these unrelated classes can be treated in a common manner by software that uses them so we externalize the hierarchy we don't immediately and directly implement in a polymorphism part we externalize this circles are not polymorphic but we use them polymorphically and that actually turns out to be an absolutely amazing and super powerful design pattern indeed from my personal point of view perhaps the most important side pattern from today's perspective interestingly it's not that well known but amazingly powerful so this external and design pattern allows any object even integers to be treated polymorphically it extracts implementation details and quite a bit you've seen that circles actually don't know anything about drawing still we can draw them it removes dependencies to all operations any affordance and it also creates the opportunity for very easy extension you can very easily add triangles and ovals and all other kinds of types and you can also very easily switch between different kinds of drawing you've seen the draw strategy here allows you to do virtually anything you can put this together like like in a lego game all right so that is a very good start but of course we now need to continue i just said that we expect three functions and so eventually we need to provide them i provide serialize and draw off a circle and i provide these two functions for square as well that is now the functions that we need because that is what we defined as a requirement in this external problem of some design pattern and of course there can be many implementations of these functions many indeed there can be an opengl implementation a metal implementation a 3dx implementation you name it that doesn't have to be one implementation you can choose between them by including a different file by linking a different file and you have the ability because of that strategy you also decide that on runtime kind of so super powerful indeed now we can also draw again a vector of of shapes in this case it's shape concepts and that is what i now use in the main function which admittedly looks a little more difficult so in order to make our life easier i now have to use this type alias shapes for vectors of unique pointers of shape concept now our base class then i provide a strategy actually by means of a lambda just to show that i have all the options on the table this is where i set a color some color the opengl color whatever we have and this is what i now call draw ah here's the circle i pass a color open gel color whatever all right then i have an empty vector and i slowly but steadily introduce shapes so i make a shape model of a circle and draw draw strategy i pass the circle and the strategy i do the same for a square and a second circle and then i can indeed draw all of them three nicely drawn shapes that should already be pretty fascinating indeed i know it's not beautiful yet we'll go there but circles indeed are totally independent of drawing i supply the draw extra but at the same time i don't have to implement that code in in a lot of inheritance ways i can simply pass that at that point very very easily very conveniently at this point i decide how i would like to draw my thing nice nice indeed it's very very strong decoupling it's totally loose coupling circles are totally oblivious of drawing and yet i can supply it with anything i want very nice indeed however again c blaster's deliverers are very hard to satisfy and the use is not nice not really not nice it's it's pretty convoluted we again have a lot of make uniques a lot of pointers and the fact that we have now these this this artificial shape model class still doesn't make us particularly happy so let's improve that and let's move towards what we call type erasure because we just have used one design pattern yet in order to make this true modern c plus plus in order to properly wrap that we now do the thing that how he would expect we wrap this properly inside a class called shape and shape concept and shape model now move into the private section of that class now your relief that suddenly this track is not public anymore it is indeed not private and now we don't care about the fact that it's destruct anymore it's now a private implementation detail of that shape now what does that shape do with these two things well in the public section of that class i now introduce a templated constructor a templated constructor that takes any kind of geometry a circle square rectangle whatever and some any type of draw strategy that can be a lambda yeah noted it's not a point of the base it's any type that you can use in a specific way that constructor thanks to template argument deduction can easily create the right kind of shape model so we say new shape model we use the gm shape we use the draw strategy we create the right kind of model that shape model however again is a concept and so we now internally store this in form of a unique pointer to ship concept and we give it a name that may sound familiar pimple so this constructor now creates kind of a bridge that constructor at the point it is instantiated creates exactly the right kind of model it brings all of the dependencies together you don't have to do that the compiler will do that for you it's a template after all and it will create the right kind of model that i can store in an abstract fashion that actually here is now the bridge design pattern and now we have erased types we actually at this point inside the shape don't remember anymore what we have what you got okay could have been a circle could have been a square i don't remember all i know is i have this shape concept that's it so we have erased the type inside this this class all right so thanks to bridge we now indeed have one foot in the door to actually have at the real type we have this abstraction with all the virtual functions but we don't know it directly anymore hence the name all right now of course that type that shape type should have the same interface that i also expect on my circles squares etc yeah so on the gmail check shapes so i do not introduce member functions theorize and draw but i introduce three functions i do that in a fashion that may be unfamiliar i do this by means of nested friend declarations kind of hidden friends so i introduce a free serialize and the free draw function into the surrounding inject them into the surrounding namespace still this is not something super complicated it just resembles the interface that i expect anyway but these functions now are responsible to actually trigger the effect this draw function for instance on the given shape that would access the pimple so my data member on that pimple it would call draw the abstract virtual function would pass all the necessary arguments and so that function would not draw the real thing the circle the square whatever so by means of that function we triggered the polymorphic behavior and once again it's not the circle that is polymorphic we've added this polymorphism by means of this the surrounding thing all right we are almost done we're almost done and it already starts to resemble a pretty pretty interesting implementation indeed however you also have to deal with the special member functions now the destructor by the way that is trivial we own a unique pointer that one is default the move operations are also default they are simple because we own a unipar the copy operations are the ones that pose a little bit of a problem if you want to copy one of these shapes then all we have in our hands is a pointer to base an abstraction and well it's called type ratio for reason as i explained before we don't know what we have so we cannot easily create a copy of that and of course we do not want to artificially we don't want to copy the pointer we really want a deep copy after all it's value semantics so we need one more thing we need one more thing to actually make this work we need another design pattern and that is the prototype design pattern so you might actually know that it is easy to recognize if you do see a clone function in the base class in this shape concept i introduced clone which returns a unique pointership concept so a pointer to base it's pure virtual again and it needs to be implemented in the derived class in the derived class however i have a very good idea what i need to do i need to copy myself so i use my own copy constructor i copy myself again i say make unique i return the copy of to myself as a pointer to base and there it is the copy the abstract copy the prototype design pattern essentially implements virtual copy so please don't use copy constructor definitely also not the copy assignment operator for that purpose use prototype so clone is not a keyword but super attached to this particular design pattern it kind of acts like a keyword all right with that we now indeed have everything tied together we have a value type called shape that can be copied that can be moved and that represents an abstract kind of shape with everything it needs it knows about drawing and of course also about serialization everything's in there that means that we can again draw all shapes but now that function already looks simpler you have no pointers anymore we have a vector of shape yeah we have vector of values and so if we go through all these values we can simply draw them by means of the interface we've now decided on draw shape pretty amazing beautiful and still it's doing exactly the same thing and the main function i believe you admit is so much nicer so much more beautiful than the one that we've seen before again we have a typical is called shapes for a vector of shape we again have some way to draw something all night okay but this time we simply create very easily circles with the according draw strategy a square and another circle and of course you can pick different strategies this is for the sake of shortness sake of simplicity so we create different kinds of shapes very very naturally and intuitively yes we have to provide a dependency at this point but still very easy very readable and almost natural so we have a vector of shapes called shapes so what do we push back or place back in that vector well let's circle intuitively for anyone this is a shape yeah naturally it should fit into that shapes thing and a square too it's a shape from a language perspective it's already absolutely beautiful so value semantics is the modern aspect of of c plus plus in this case definitely all right now the design analysis why is this so much stronger from a decoupling point of view if you now take a look at a numeral diagram again again we have three levels we didn't change anything from that property or from that perspective but we of course adapted the players the shape abstraction is now the class that i've explained for a couple of minutes now that is now this type erasure class the one with a templated constructor and one with a shape concept and the shape model nested classes and a pimple this is on the highest level that is the abstraction that is again just the set of requirements that i have to deliver but i don't have to deliver these directly in circle or square no these classes actually still don't know anything about their operations no dependencies whatsoever i now provide this on the lowest level possible by means of the actual implementation this draw will now bring together the requirement from here and the according type circle or this draw function of course the square of course it's a slight simplification because there's one key player that it don't show yet and that is the code that is generated by the compiler the compiler generates our shape model for a specific given shape let this be circle or square that class the bridge the injected code is of course the one that adapts that brings and binds all of these things together but again it's generated code it's not something that you have to write the compiler will take care of creating the right thing for you and this is why it's destroyed such a strong decoupling it's actually truly amazing how strong the decoupling is it's so loose coupling that some people feel it's it's too loose coupling it is very strong decoupling and so i give the word to eric nebla he actually twittered about typo asia a couple of months ago so in 2020 and yet the following to say if i could go back in time and had the power to change c plus plus rather than adding virtual functions i would add language support for tiberature and concepts define a single type concept ultimately generated type erasing wrapper for it and perhaps you have now an idea why you said that and i by the way totally agree with eric i agree that this would be so much better so much stronger so much more natural however we're not there yet of course and i totally agree with you if you say yes the technique is nice but i have to write so much code well we can all hope that eventually we will move in that direction and that the compile will generate something for us take away all the spoiler blade code for us and and create what we actually ask it to create more automatically than today all right so you've done an amazing job by now we've used typewriter to extract implementation details again to create the opportunity for easy extension yes and you have still perfectly separated interfaces it's such a loose coupling it's so extensible at this point that it's hard to imagine how it could be even better and of course we have also again dealt with duplication quite nicely what we've now achieved is that we have removed all dependencies to operations very very nice indeed before we removed all inheritance hierarchies public hierarchies of course there is one but you officially don't know about it officially there is no inheritance anymore you don't have to inherit yourself from anything there is hardly any pointers perhaps even no pointers left and there's no manual dynamic allocations left you don't have to use make unique for hundreds and thousands of tiny little things nope that may be handled internally and of course we don't have to explicitly manage lifetime management anymore or deal with lifetime management anymore that is done by the wrapper class that is already taken care of nice we make our lives easier and that's the last point and i know this is now the controversial aspect we've actually improved performance and potentially quite a bit the obvious thing is that there is only one virtual function not two like in the strategy design pattern there is only one that is obvious already however everything else is of course now kind of another talk still there's one idea that i would like to give you right away just because it's so easy to imagine we have already always used make unique inside the shape which is was my design choice it was simple to explain the technique but of course now that it's a class you have all the options to do whatever you want to so we could actually provide a storage policy for shape and tell the shape how it should acquire memory by means of new by means of using a static buffer perhaps by means of hybrid approach small things stored inside else it's allocated you have now all the options on the table storage policy and yes that is a strategy of course there's other talks on typewriter that talk about this performance aspect so especially so there is a talk by secline for instance there's a talk by arthur dwyer especially the talks by cybrant and basically all the talks by eduardo madrid they deal with performance so if that is something that you're not interested in about implementation details and how to how to vary things then this is just the right talks for you now the this the successor talks hopefully i could just make clear why this technique is an amazing addition to your code base so still can i can you save all the trouble writing this yourself you can there's a couple of libraries like sue dyno and also boost type ratio that actually deal with hyperasia in a nicer way you don't have to write that much code take a look perhaps this is what you like what you like and else you still can of course implement this yourself as a summary hyperagent is a templated constructor that creates this bridge automatically plus a completely non-virtual interface types no longer have to be polymorphic we treat them polymorphically very nicely and it is a combination of external polarification bridge and prototype these three design patterns and i believe it's definitely one of the most interesting design patterns today i believe this is something that it could pretty much apply to every inheritance hierarchy you have and by that gain decoupling that is the one thing we're looking for and therefore i feel it's so interesting so type ratio is definitely significantly reducing dependencies enables you to use value semantics which is the modern aspect here it definitely improves performance if done properly and it improves readability and current comprehensibility my opinion may be something that is subjective but i hope you agree it eases maintenance and for all of these reasons for all of these good reasons in other program languages that is the default choice for using providing dynamic polynomials c plus plus is not there yet but hopefully we will be eventually now you hopefully do realize that talking about design is pretty interesting and there is so much more now this was a glimpse on the surface now yens or meeting c plus is a company and i have agreed to that and so there is also a couple of training classes on design patterns perhaps you're interested now we do this couple of times here the next thing will be in february mid of february in case you're interested and of course typewriter will be part of that training too okay then thank you very much for the attention and i'm definitely very happy to take a couple of questions yes thank you very much for the talk that was interesting and wow i knew the clothes would deliver but that's that's really interesting code so we have two more minutes and i'm okay if we go like a little bit of overtime because it's an expression just pick the questions you feel are most so to the audience if you want to upload questions that helps me choose because there is not a lot of upvotes in the questions so more upvotes helps me choosing there is of of course you know the obligatory question first what are the performance implications on compile time so i didn't explicitly measure but using the technique for me didn't reveal any problems and i believe the reason is that there is not a lot more to do what you need is this templated constructor that of course need to be generated and of course you need a specific model if you have a lot of variations of course there's a lot of models that may be kind of bad indeed but generally you don't do a lot more if you would do this manually you might have many more code much more code you might have many more base classes you may have many more hierarchies i believe this actually saves you trouble but i have to admit i never benchmarked because i never found this to be a problem at all so compile time okay definitely okay okay by the way i'm speaking about my code i'm not speaking about boost typo ratio for instance that is much more template heavy that may be different yeah that could be the case what would you say are the pros cons between the version you should you've shown us today and a hypothetical version that uses stdne to do the type erasure and the switch with any cost so stood any is implemented by means of type asia which means if you wrap typerace around type erasure you have twice the runtime effort that actually was something that was published at some point that you have some function pointers that do this anycast and as a member you store any i don't like that idea at all because i feel this is a bazooka approach to something that's much more simple so wrapping type erasure in a typerace approach feels like missing the point i feel the code i've shown is simple enough that you can write this for a couple of things you don't need this this additional simplification which definitely draws in rgdi exceptions dynamic memory and the anycast is maybe a dynamic cast also well not not not such a great idea from my point of view yes there is a very good question i am often haunted by the type of by typewriter it is nightmare to search for a single specific operation for a class circle in a complex and large code base especially if you are not sure about the exact name of it is there a solution for that the lack of centralized interface can backfire of course you decide in in type ratio you have decoupled so you decide what you actually expect you can if you want to also put things into a circle you can expect a member function of course that usually creates dependencies that is exactly what you want to solve usually the problem is that your ide might not point out that the operation is available as a free function so i don't think it's a design issue it's more like an a tool issue so if you use c line for instance c line also shows you what is available in form of free functions if you want to i believe that visual studio by now has the same um thing it may be more of a tooling issue than it is a design issue but i definitely get the point maybe a maybe you find a compromise between the two extremes is there any aspect of cpr first 20 that will improve this approach there's definitely something that he can do concepts help so i've basically stripped this to the very basic points i've not checked specifically that the type that i get this geom type is truly a geometric type that is something that concepts can do the error message tend to be nicer you tend to probably constrain all of these template functions that is a very reasonable thing indeed again i kept the code simple but i believe this actually is not a lot of overhead now the concept could be a couple of lines so four five lines for this example and i could use this in one or two places in the class that would be a very reasonable addition yes okay then i'd say we are doing the applause for klaus thank you very much for giving this great talk i see there's still a bunch of questions which have not been as popular but probably want to be asked i think you might be able to answer them with with typing but also i think you wanted to go to the launch so yes you want to have any questions or probably debate with class about this there is the launch and if you would like to have this a bit more extensive and more on also on patterns then there is a course which i put in the chat and you can find when you go to this talk that's neat okay thank you yes yes and i'll see you in the in the launch okay then i'm going to stop stream and that's doing it now