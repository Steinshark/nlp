we're over here arguing about code coverage and somebody gives us a 4day old one why reaching 100% code coverage must not be your testing goal with examples in c okay obviously first big mistake is c got him got him easy destroyed get wrecked i i'm i'm fully in agreeance with this statement but i'm willing to be wrong and i do mean that i am fully willing to be wrong here all right table of contents for an article come on just a second if you're here and you're a software engineer did you know about in domain and networking cost do this thing in this blog something configured adsense i'm not really sure okay code coverage is a valuable metric in software development especially when it comes to testing it provides insights into how much of your code base is exercised by your test suite however we must recognize that code coverage alone should not be the ultimate goal of your strategy it has some known limitations okay okay okay 100% code coverage does not guarantee your code to be bug free yes we all we all know this you can't you can't test you can't just write hard code to test your way out of things this article will explore why code coverage matters it's limitations and how to balance achieving high coverage and effective testing we'll use c to de demonstrate the code coverage and how you can and how you can cheat the results okay what is code coverage code coverage measures the percent of code lines branches and or statements executed during a test it helps answer questions like how much of my code is tested are there any untested paths or dead code which parts of the application need additional test coverage in c tools like c cob do coverage and visual studios built-in coverage analysis provide code coverage reports you may be tempted to think that higher the coverage the better the quality of your tests however we will soon demonstrate why this assumption is misleading okay okay okay okay hold on let's hey let the man cook everybody why test it's not expected go you know you got to really lean into that oh i like this in my opinion the bottom line as you can enforce thinking through something with policy gates i don't think you can force somebody to become a good tester by saying that they need 100% coverage i think you'll get a bunch of lazy tests that get there gatekeeping okay thank you bry i appreciate that testing for  saying it out loud put my foot down now all right clearly if you write valuable test the code coverage is a great ally a high value of code coverage helps you with risk mitigation high coverage code reduces the risk of undiscovered defects if a piece of code isn't covered it will likely contain bugs okay i don't agree with that statement just in general i do not think that you can say either or because most the code you write is happy path code and most the codes you write or and most the code that's tested is happy path code and those are the easiest ones to get right it's all the other parts of it code is destined to evolve over time if you ensure that most of your code coverage is covered by tests whenever you'll add some more code you'll discover which parts of the existing system are impacted by your changes if you update the production code and no test failed it might be a bad sign you probably need to cover your code you are modifying with enough tests i don't know if i actually agree with the statement either again if you update your code and no test fail i don't see how that's bad or good i think more like this if a piece of code isn't covered then you can't be sure it doesn't contain a bug okay but then i would give you the opposite a axim if a code is covered you can't be sure it contains a bug like i i don't i don't think you can like that that's what i'm saying i think the difficulty here is that there is these statements these statements mean nothing in the sense like this this statement means literally nothing the sky is blue when it's not orange you're like yeah sure but it's orange sometimes also you know when the sun's like setting and stuff it's kind of getting a little orangey and you're like well yeah but we're talking about the blue and you're like okay cool what are you saying i don't get it 100% code coverage is still useful to find dead code how you covered 100% of your code how do you know it's dead like like isn't it the opposite is it what you're saying the literal opposite if your test test 100% of your interface all of your code should run no that's that's not 100% coverage is not coverage of interfaces it's coverage of code it's in fact the opposite if you have 100% code coverage you're certainly not getting a good insight into dead code all right guidance let's see code coverage ensures that critical parts of your application are tested thoroughly also not true good test focus on the functional aspects of code what rather than the technical aspects how i'd have to think about that statement more i'm not really sure i understand it a good test suite is safety net against regressions this is fine i think this is true this last statement is very very true if you have a known bug and you ensure that you put stuff in it does mean that you will probably not make that bug again right now you may make it in new in in an extravagant way but it's unlikely you will create the same oopsy daisy more than once again this goes back to the exact same thing that i've talked about chat is dumb where i test the things i don't like i don't know i can get correct first try like window spec ensuring that i can create a window do all the stuff and close a window i know i could probably add some more tests and different stuff with a you know specification all this kind of stuff but i wasn't i could not do all this once and test it was extremely difficult actually doing going through the process of testing and un testing required me to close down vim or clear out the lu cash rebr bring everything back in re-execute a script seeing if the results were correct instead i could just write something that can just tell me those things very very quick that just feels easier this was even harder to get right right doing a caching mechanism ensuring that from a string i could actually build out the correct display from a string i could not get this right first try this was ex this was an extremely difficult piece of code code to get right first try as you can see very easy to goof this up especially with one-based indexing one-based indexing the death of all programmers by the way i found it to be very difficult to reason about so this makes perfect sense why you'd want to run over this right like why you'd want to test this because i don't think i could ever get this right in one try at all ever for any reason right and it's just so much faster to have a function i can run and test it over and over again so yeah i'm happy about that i've covered regressions now i won't goof up messing that up lua y one y one lua code coverage highlights areas that need more attention it guides developers in writing additional tests where necessary again i mean that that that assumes this axim is true and that the inverse isn't right there's a lot of assumptions made in there the limitations of code coverage while code coverage is valuable it has limitations false sense of security achieving 100% code coverage doesn't guarantee bug free software it's possible to have well- covered code that contains a subtle defects this is especially true when mocking dependencies oh boy every time you mock you have just stated that you understand the verse for that mock and you will be able to represents all of its behaviors properly mocking is particularly egregious when when discovering problems i can't tell you how many things i have discovered in production or in code where the mock makes a false assumption about production so not only do you have a test that tests something that no longer exists in production but it also guards you from getting the actual answer correct mocks are literally the devil they're the the devil for what it's worth we add about we added 100% coverage to get our devs to actually write any tests along with their pr otherwise they just wait till it breaks before writing another test i'm actually not necessarily opposed to that surprisingly easy to keep your coverage over 80% in short when someone complains about 100% code coverage thing we explain that it's a culture thing to try to get devs to be good citizens so here so here's the question i think you need to ask yourself why aren't test wr why are devs not writing tests my assumption is that whatever the environment is makes it hard to write tests to test specific things cu you can't tell me that no devs writing code that's not difficult that they can't get right in the first try so if they can have an iteration cycle that's directly better than trying to run the entire program then there's your problem i mean that's another reason why i write test is because guess what it is a thousand times easier testing this in a test than it is trying to test it while running it and so whenever you get into this part where people aren't writing tests i often think the environment to write tests is more difficult to test and run than the thing itself yeah the en is often the problem in reality the reality is writing testable code is hard and most devs is new this is also very very true a lot of people don't know how to write testable code that is a very fair statement you're using a logical fallacy so are you the existence of bad tests is not an argument against 100% code coverage of course the tests have to be effective as well when safety is by far the top priority example in software for airplanes or x-ray machines remember i i don't see why you shouldn't have 100% test coverage i guarantee you you could have had 100% test coverage and still had that x-ray machine problem but you're doing like the literal exact opposite problem 100% code coverage does not mean the software is safe either right and so it's just like my argument is that we should make good tests for things that are very valuable we should not make tests for the sake of making a test i don't think x-ray machines are simple i never said that i would most certainly have never said that i just don't think that you can make those statements right thek 25 mentioned let's go yeah exactly for those that don't know there's a couple people that died because of this race condition effectively that happened while the arm was moving if you reset a value the value wasn't accepted despite the ui still showing it and guess what pretty much guaranteed that a unit test would have definitely thought that that was fine let risk determine the testing conditions when it comes to any of these other things i would much rather see tiger style i'd much rather see tons of asserts negative space and a ton of simulation testing on these things right i would much rather see that because you're going to because you could use code coverage from your simulation testing and you could say we are testing 100% of the code with simulation testing and at least that's way more believable at least at that point i'm like okay now we actually have real things what it does mean by testable code testable code is really really simple let's pretend i have a function fu and inside function fu by the way this is lua so just deal with it inside function fu i go to the go to the server for some data right and then i do some things to ah things to data right right in here this is very hard code to test this is very hard code to test you have to have something that you could override say go to the server you have to dependency inject at like a at like a a level right you know it's much nicer fu data this is very easy to test because this on the other hand i can just make up the different shapes i need that i think are well tested or difficult to produce and i can test that really simple it's i mean that's really that's how you write testable code right it's it's it's like as simple as that test me daddy okay anyways they focus on lines not behavior code coverage doesn't consider the quality of test it guarantees that the line that the test covers all possible scenarios it touches all possible lines doesn't cover all possible scenarios some code paths execution handling rare conditions are too complex to cover high coverage doesn't necessarily mean thorough testing facts okay practical reasons why code coverage percentage can be misleading for the sake of this article i've created a dummy. net api project with the typical three layers controller service and repository it contains contains a controller with two end points okay so we got one endpoint un universal weather forecasting controller we got low hp g we innumerable weather forecast weather service by locations to list weather get my min planet weather min planet whatever universal stuff weather service another one of these i don't really know this pattern i don't know what i'm looking at i innumerable weather by locations argument out of argument exception throw if less than this weird way to throw exceptions but whatever do this i really hate when people program logic like this into a function throw if less than or equal you know it's like way cooler just if location is less than or equal to zero throw out of range exception you know how much nicer it is to just have that can we just all agree that this type of stuff is just just why have one more level of indirection why can we just stop can we just stop and then right afterwards doing this mr safety safety you toss in a non squirly brace if statement you're being an evil individual okay you can't do that you can't do that we can't actually that's crazy evil okay this is way more terrifying this is way more terrifying than anything else anyways okay do a bunch of crap more of this stuff blah blah blah blah okay fantastic finally the service calls the repository admitted for brevity just a bunch of items of in memory lists then i created an nunit test project to generate some unit test okay let's see what the unit tests are all right so we got some setup we got some tear downs oh we got some mocks oh you're done effed up you're done effed up already this class covers two cases both related to the forecast by location method of service case one the location exists in the repository this method must return the related information okay this is what we expect here's the new clay thing we do this we tell it to hey you get these functions right here do this guy right here now we got it okay great you've tested that your mock is fantastic your mock real nice real nice mock there case two the location does not exist in the repository and the method should throw location not found exception do a little bit of this one null get a little location assert catch this okay fantastic all right when i run the code coverage report i see the following results line covered 16% branches covered 25% fantastic test coverage 16% of lines 25% in branches shown in the chart above delving into the details of the weather service class we can see that we have reached 100% code coverage of forecast by location method i hope you don't test that anymore look at that you got 100% coverage we got 100% coverage you don't need to test that right right i think everybody can see the bug right can everyone see the can everyone see the bug they haven't tested this thing right here right they haven't tested if your argument is out of is if if it's out of range can't see the screen well too bad i don't think i can relase zoom in it's an image argument out of exception it's it's it's this line up here it's this one every single time you run by this code of course you run this line now what you don't see is that underneath the hood this function has not covered code so then you end up testing the function to make sure that that function works correctly so you'll notice that you get a 100% code coverage you have you can test that this thing throws properly and you test that this function works and 100% code coverage but you actually haven't tested to see if this function throws when you hit there you actually haven't tested the the the most important case of this function which is the rare event all right let's do this this is fant this is this is a very good example by the way let's review the code on your question blah blah only tests covered by two cases location exists location does not exist however there are no test to cover the following question the location is less than zero the location is exactly zero the repository throws an exception right now that exception is not handled the location does not exist but it has no weather forecast info or the location does exist but it has no weather forecast info is this a valid result or should we have thrown another uh custom exception so we have 100% code coverage for this method yet we have plenty of uncovered cases you can cheat the result by adding pointless tests yes so this is where the 100% gets so dangerous is that you create tests to increase the code coverage but you're not testing the thing right so if i tested the exception throw if less than zero i don't actually test it in my real function i just test it in the synthetic way and then i get this really weird sounds like bad unit testing practices it actually no you know what it sounds like it sounds like every unit testing practices of all time it's just what it is sad padding it's so dangerous this is why i don't like 100% code coverage is this exact same reason is that you end up writing you it hides to you the real reason what things are not being tested to demonstrate it we can create a single test method to reach 100% c coverage with the repository without even knowing what it actually does totally useless test get location byid planet jupiter equal one one equals to one nice nailed it here we are we've reached 53% total code coverage by adding a single test does it provide any value society fantastic you can cheat by excluding p parts of the code in c there's a handy attribute you can apply to methods and classes exclude from code coverage while this attribute can be useful for classes you cannot test it can be it can be used to inflate the code coverage percentage by applying classes and methods you don't want to test maybe because you are lazy h that's actually pretty funny that you can do that i don't even know i didn't even actually know one would argue that it's better than nothing and i'd say that one argument was shitty let's go let's go 100% we're destroying it boys i never said i know you didn't say that i i know you didn't say that but still people are getting this idea there's people that argue that 100% is good i i'd say 100% means nothing that's what i say 100% code coverage means nothing if you say i have a project with 90% code coverage 60% code coverage and 100% code coverage which one has the best coverage i would say i don't know that's what i would say i would say i have literally no clue which one contains the least amount of bugs i could say the one was zero % probably contains more bugs than one with some percent 0% i can at least say the likelihood of bugs is higher you have even run your happy paths but everything else i don't know i think most stems from management not de well there's risk factors too like people have talked about like medical equipment like what do you do with medical equipment do you do 100% test coverage pro probably i i i honestly i think for not getting sued you probably do that what's the correct percent what's the correct percentage you do on medical equipment or self-driving cars that's where things get really tricky and i'm totally on that i'm totally on that team where it's just like what's the proper amount i don't know the problem is is that i want good test coverage as we saw high code coverage is not enough it's a good starting point but it must not be the final goal we can indeed focus our efforts in different areas testing quality prioritize writing meaningful tests again this is is it's meaningless i mean for the average product not talking let's not talk about the specialty cases i think the best way the best way to have a well-running project is to have is to have tests easier to write and run to test your project than to run your project itself and i think as long as you can always have tests that drive any difficult feature i think you'll have simply a better you'll have a better experience that's the only way i think it could be done focus on edge cases boundaries values all this yep agree with that exploratory testing manual testing complement automated testing ooh yes exploratory testing uncovers issues that automate tests might miss it's true it's that's called production by the way manual testing is called production and canaries okay you log and you find out why things change okay that's called production instead of just measuring coverage consider mutation testing introduced artificial defects and check to see if the test catch them negative space programming finally my suggestion is to focus on integration test rather than on unit tests this testing strategy is called testing diamond yeah that's where is it isn't it testing pyramid i don't know about the diamond i'm not sure about this whole diamond business anyways this was actually really good i like i mean i i mean i like i loved the the thing he showed by the way this was fantastic i loved the example testing the reverse funnel i do like integration testing but they're also can be very difficult setting up your project in integration testing has to be in the culture and thought of first it's so hard to go back and try to make integration testing work i think 100% becomes popular if it lets you have the false sense of security and you don't have to review tests to actually make them meaningful fairly diamond because you have more integration tests i guess wasn't that like supposed to be like the i thought it was always this right is that you have like the tip is unit and then you have this whole people give different names and honestly these names mean different things to different people you know you have functional tests i'm pretty sure most people cannot even tell you the difference between a functional test and an integration test or end to end where is end to end in this is functional right here and then end to end or is integration end to end how do most people feel about it right most i i i think that this whole part of the triangle most people don't have very good definitions for and then at the end of the day illuminati a jen