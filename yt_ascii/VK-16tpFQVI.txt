is different so today we are in fact not in berlin as you can see i'm giving the stroke from home i'm in london because of everything that's going on in the world right now but i think considering that with cheapest 20 we actually got really lucky because we actually did have a simple committee meeting in prague in february this year and that's a picture of everyone who was there i'm i'm somewhere in that picture so if you want to play west wally then you can try to find me and actually at that meeting we finished the technical work on t 20. and that was just a few weeks before the who declared a worldwide pandemic and everything started to shut down and i say this was pretty good timing right because we we just finished the technical work until it was sanji before this whole thing started and since then cbs 20 has taken all the bureaucratic hurdles to be approved and so now we're basically just waiting for it to be formally published on the iso website which hopefully should happen in a few weeks and yeah so basically cbs 20 is done which is great you saw in the previous picture that the superstars committee has actually grown in size quite significantly since the 90s and so has the c plus plus standard document so here's a graph showing how many pages there are in the different versions of the sequester standard document and you can see css 98 had 700 something pages and cpus 20 now has about'00. and from the number of pages it's not immediately obvious which of the c plus plus standard version were the most significant in terms of impact on the cps system and what i mean by significant is not just you know adding cool new features that you might choose to use but actually fundamentally changing the way you write c plus plus code the way changing the way we think about c plus plus code and i think the last such release that accomplished that before simple sus20 was c 11 and let's remember why let's remember how we had to write code before c plus plus 11. so let's say we have a two-dimensional like a vector of vectors because we still don't have a good two-dimensional array type in a standard library so let's have let's say we have a vector of vectors and before c before six does 11 if you wanted to iterate over this thing you have to spell out the iterator type right because we didn't have auto so and they could be like arbitrarily long really and arbitrarily ugly to spell and then if you wanted to sort this this vector you know we had still sword and all the other stl algorithms but we didn't have lambdas so we would in order to create a custom sorter custom comparator you would have to actually write out like a new class right and pass that in and then finally whenever we have we had nested templates like that we actually had to put in an extra white space in between the pairs of closing angle brackets because the lexa would always treat two angle brackets as a right shift operator right and finally we couldn't even initialize a vector like that because we didn't have we didn't have list initialization so in order to initialize the vector we had to either write a bunch of pushback so we had some horrible boost macros to accomplish that and some of you might remember that and it was all really quite painful and since superstars 11 we do have ultra we do have range based four we do have lambdas and we do have all these things so we can write the code like that right which looks a lot more familiar to us and a lot more clean and a lot more readable and so the addition of all these features has very significantly changed the way everyone writes c plus plus code today if you look again at this graph it looks like c plus 20 didn't actually add as many pages as c plus 11 did right in fact actually see 17 added a few more pages to the standard than superstar 20 did so it seems that superstar 20 isn't more significant that simple 17 was but it turns out that counting pages is actually very deceptive 20 actually added a lot more material than it seems because well first of all for seepless 20 we had to change the paper size of the actual standard document from us letter to a4 because of new iso requirements and that made cps20 shorter by several hundred pages right so actually the increase is a lot bigger than than what it seems in terms of content content and also most of the new pages in cprs 17 actually they are kind of due to new library features that came from boost things like file system any variant optional which take up a lot of pages but don't really give us anything new that really wasn't there before at all we did add a few language features things like structured bindings things like class template argument deduction which i've you know done a few talks about in the past but i would argue that those things like have mostly syntactic sugar that let you write things a bit differently a bit more conveniently that you already could do but cps20 really changes the language much more fundamentally it changes the way we think about code it changes our mental model of what a function is what a template is how do we design a library how do we organize package and compile a c plus plus program right and it kind of touches all of these all of these areas and that's why i think c plus plus 20 is actually the most significant update of c plus plus in all its history and in this talk i want to explain why i think that is so last year at this conference in berlin i actually gave a talk about cpr sus 20 i gave a talk about a lot of the small features that rnc does 20. but the reason c plus 20 is so significant is not because of any of these features that i was talking about last year it is because of the big features and those specifically some of them some of some of you call them the big four are core jeans concepts ranges and modules and in this talk i really want to drill down and talk about those and let's start with quarantines because proteins are really really cool but before we can talk about coroutines we have to talk about functions what is a function what is our mental model of a function essentially a function the way to think about this is it's a chunk of code which has a name you can call it you can pass up maybe some parameters which now isn't really important it has some local variables right and then it executes some code and then it can return some a value so that's basically our mental model of a function turns out that idea of a function or a subroutine as it used to be called has been around since the 50s so that's really nothing new and so let's look at what we can do with those functions let's say we have a function f and then what we do is we want to call it and then it's going to return a value and then we're going to print that value right so let's say the function returns zero and then obviously it's going to return zero then we're gonna print zero right so this is kind of you know pretty much you know not very surprising there is this concept of a pure function which basically gives you the same output every time so that if you call f three times you're going to print zero three times and this is probably not really interesting but what if you want this function to return different values every time and that makes it a bit more interesting so let's say you want to generate a sequence so instead of printing 0 0 0 you want to print 0 1 2 3 let's say how can we achieve that so obviously the simplest thing that we can do is we can just write a loop right just in the main function just write a loop that just prints those values but that's kind of not how you design code right because you want to separate generating the sequence from printing it right those are two different things you want to separate them and how can we achieve that well we can create a container that's holding the sequence right so then we generated the sequence and then we can print the contents of that container in a separate step so we have separated generation from printing but now we have this container and that's holding the whole sequence right so we have to initialize it maybe like this using list initialization or maybe we can fill the vector using a loop or since we don't like row loops you can fill the vector using an algorithm there is actually an algorithm in the stl that generates the sequence and we'll talk about algorithms later but the downside of this kind of procedural approach is that now you need to store the whole sequence in memory right so and if you want to print all numbers from zero to one billion then that is probably not a great approach because maybe you can't create and hold the memory effect that's that big so what you want to do instead is you want to generate the sequence lazily right you want to generate a new number on demand as we print it because that's much more efficient way of doing this but we still want to separate generation of the sequence from printing how can we do that like think about that for a second and maybe what we need is we need to go back to the idea of of using a function but how do we now implement f like how do you implement f such a way that the first time around to print zero the second time you call it the prince1 etc etc okay so if you think about this there is you know one simple way you could do this which is you could you know make the counter a static variable which will then kind of persist but that will work that will print the sequence but now you just introduce global state right and that is not a great thing to do so how do we solve this without introducing global state and now well the most straightforward way it seems is to create a class right so now we have this my generator class that you wrote which is going to be generated generating the sequence and now we keep this counter as a member variable and now we have this call operator which returns the current value and then increments the counter right and instead main you know create an object of this type so we create an instance so it's not global state anymore so it solves that problem and now we call that object to generate more numbers and that's basically object-oriented programming right but so we all know this we've all been doing this you know probably for decades but i would argue that for a task like generating a sequence this is kind of the wrong approach right because think about what we have to do here we need to create a type we need to decide what member variables that type should have we need to decide whether it should be private or public what api does this class have you know what public member functions are we going to introduce what class and variance does this class have you know we we think in objects right and for a task like you know generating a sequence of numbers that's way too complicated that's the wrong way to think about this code so okay there's there's one way we can make this a little bit simpler since c plus 11 we have lambdas so we could write this as a lambda you know so it would look like this it's shorter but it is still exactly the same object as before right this is just the same as on the last slide except with a bit of syntactic sugar on top right so we still have to explicitly create this object and we have to explicitly create the state and form of this member variable which now goes into this init capture the i equals zero but it turns out actually we don't need to do this we don't need to think in objects at all let's go back to functions a function like this already has state it's just the local stack variables right this is state so we can use this we just need to expand our mental model a little bit of what a function is so let's imagine a function that has some local variables like every other function like this x here and then it's executing some code but now it can yield an in intermediate value so it can yield a value like the x for example and that will return control to the call side but now the next time you call f it's not going to start from the top but instead it's going to be still where it was after the yield so it's just going to jump back to where it was and it still remembers all these local variables and now it just keeps going until the next yield and then it keeps going until the next yield and the third time you call it and the story repeats or until you know it reaches a return statement at the end and then it's finished and that is basically what a coroutine is supporting has been around have been around for almost as long as as functions and as walter brown actually pointed out to me just a few days ago melvin conway actually coined the term coroutine in 1958 and there were things in in the 50s which arguably you could say are coroutines like for example interestingly fortran's print statement with the format thing that it has is arguably like a quarantine anyway conway then published his explanation of what the quarantine is in 1963 which is this paper here and by the way that's the same conway that coined conway's law but it's not the same convey who invented conway's game of life but anyway so cory jeans have been around since forever and so after six decades essentially we see people finally caught up with everyone else so i think that's great so we have coroutines now in the language and if you think about the previous slide and now how to apply it in this code to generate the sequence once can if you understand this idea of a protein it seems intuitive that this code should look something like this right so we have this quotient at the top now f which now the counter is just a local variable and now we have a loop which increments the counter and yields the current value right so it yields zero and the next time you call it it's just going to jump back into the body of that loop and yield one and then it will yield two and so on and so forth so if you call f multiple times you kind of just keep incrementing the counter and yielding the new value and that's super simple so it can just go on like this indefinitely and and you don't have to like store the whole sequence you just create the numbers on demand unfortunately this is c so things are not quite as simple actually this code will not compile because of truth reasons so the first reason is that actually instead of the keyword yields like in most other programming languages we have a keyword called core yield because of reasons so i'm not going to talk about that now if your future asks me about that later but yeah so that those keywords have this co-underscore prefix and now the more interesting thing is that in cheapest plus you don't actually directly return this end you have to return a generator from the score routine and then you have to call the generator in main to get the new values right so you have this extra step and that's because c plus is not lying to you it's telling you what actually happens and what actually happens is that a quartering doesn't actually return an end it returns an object which through the quarity api will eventually give you an end and the way to think about this is that according essentially a generator factory so you call it to get a generator and then the generator will give you the values 0 1 to 3 the stuff that you want and this extra step is there because there are a bunch of choices how exactly this generator object should work and zip lets you make those choices right so that's why c plus plus makes this generator object explicit and gives you the option to implement it yourself and exposes the whole underlying machinery which is the coding api and that's what you need to use in order to implement that generator so you can implement it in the way you want so it will have the behavior you want and this might be quite confusing so i know it was very confusing for me first time i had to wrap my head around this so let's take this apart we have your user code right that's the code that's calling the quarantine getting a generator g from the quarten f and then using g to get our numbers and print them so g here is a local variable right so it's it's allocated on the stack and g contains a bunch of stuff so first of all we somehow need to get our in from somewhere right so that we can print it so g the generator has this thing called the promise type and that's the first thing that will be instantiated if you create this gene and that's essentially the box where the query puts the int into and the user type gets it from think of it a little bit like a stood optional of int right it's a reusable box that can hold a single in value and that's essentially the communication channel right so everyone needs a reference to that the core team will generate the int and put it into the box the generator would take it out of the box and return it to your user code the other thing that's part of the generator is this thing called stood coordinating handle that's an object and that's a kind of a magic standard library type and what it really is is it's a pointer to according frame now what's according frame think about a normal function that thing that has a thing called a stack frame right so that is basically an internal data structure so that the machine needs to know so it knows how to call a function right and that's how every function works under the under the hood and for a normal function the stack frame contains basically the local variables the parameters and an address where to return to basically like an address so that's where it's going to put the return value into and for a function the lifetime of the stack frame as the name says is tied to the stack right so when a function returns then all the local variables get destroyed now for a quarity and it's pretty much the same thing except the quotient frame contains i mean it also contains all the local variables and how to call it but the difference now is that this state can persist right so when a quotient yields that state is still there and and the local variables are still there so that means that the difference is that the query now has a lifetime which is independent from the stack so that's why you need this pointer to it so we can manage the lifetime of that of that quotient frame which now will be on the heap another way to think about this is think again about this lamina so this init capture here is a little bit like the quarten frame quote-unquote for this lambda because it has all of its local variables and basically later so it creates this like state right it creates the local variable which in this case is just the i the integer and later you can enter that state again whenever you want because it's stored as a member variable just by calling the lambda so the quarantine and that kind of happens implicitly right so you don't write out like a member function it's just the compiler does that for you under the hood and the query really is just an extension of that the the extension actually is that it does that but it also has multiple entry points and multiple suspension points right but it still has only one quoting frame that persists and it persists all the time just like it does with this lambda so you can think of this lambda video as a very simple core routine except that the lambda has to be entered from the top and it will run and then it cannot be resumed it will like enter from the top again next time and the quarten in that sense is more powerful because you can enter it from the middle and you can leave it in the middle and the other difference is that this coordinating frame for the lambda which is just this integer there we know how big it is right because you wrote it it contains just one integer which is like four bytes or something so the compiler knows that so it can put that into the onto the stack but the coordinate frame in general the compiler doesn't know at compile time how big the coding frame has to be so it has to dynamically allocate it on the heap and now we understand what the 14 handle is it's basically a type erased pointer to that dynamic object right so it's like you know other in a way it's a little bit like other type erased objects like stub function which is also kind of like a handle to a type erased object so that's the query and that's according frame and then the generator really is just this user-facing object that groups these two parts of the state together and then forwards the coding api to the user code and again important according frame is on the heap but the generator is on the stack so when g goes out of scope at the end of your user code function then the quotient frame should be destroyed and that heat memory will be deallocated so again it's a little bit like like the function in that sense and now really the last piece of the puzzle is the actual quarantine which is this red thing on the right and that basically constructs the coordinating frame and then runs the code inside the coroutine body which is the code that you wrote and the important thing about that is that the discordant object itself that's generated by the compiler so the compiler has to has to do that because then the compiler can optimize it and that is subject to optimizations which are very interesting there are actually two important optimizations here the first one is that actually the compiler will go ahead and turn this code into the right on the right that you wrote and it will turn it into some complicated state machine to make this whole re-entrance behavior kind of more efficient but you don't have to worry about that right so that all just happens under the hood and your code on the right still looks really nice and the other optimization is that in general as you said the coding frame will be allocated in the heap but sometimes the compiler can optimize that way and then if it kind of can see through the lifetime of the quotient frame and if it can prove if it stops existing by the end of the function and the coding handle never escapes then it can actually collapse everything and put it onto the stack and so that is a really important optimization because that gets rid potentially of a dynamic memory allocation and then de-allocation and so because of these optimizations that can happen efficient quarantines have to be a language feature so they cannot just be a library feature but that's actually really nice because the zebra stars code you wrote is nice and clean the binary code you get is very lightweight very efficient you can use that on a bare metal machine because it doesn't rely on threads or the operating system or anything like that it's like super low level and it's nice and clean and fast and these are pretty much all the bits you need and that's where you get in c plus plus 20. there is only one kind of annoying thing about this in cpr 20 is that turns out that instead of sus 20 the standard library doesn't actually provide a generator type and a promise type because the committee didn't finish that bit in time the good news is they are coming in 23 so there is this paper this proposal by lewis baker and canton chabot which proposes us the generator and you know this is a very uh everyone looks forward to this proposal going in so it's going to come in 0.23 but until then you kind of unfortunately have to implement this generator yourself and part of the generator is a promise type and so you have to implement that yourself too or much better idea just use a third-party library like lewis baker's cbp coral library which is what i would recommend but when i was actually first had to deal with this quartering stuff i kind of got curious i was like yes i mean we should just use a library but how does this work so then i actually decided to actually try and implement these generation promise type myself just for this very very simple case of generating a sequence kind of in order to understand how it all works and i have to admit it was surprisingly painful it took me all day it worked in the end i'm just going to quickly show you what that looks like so this is what the promise type looks like or at least you know my implementation of it and so this so it's templated on the on the actual value which you know in the case we saw before will be in but you know i just templated this to make it more generic and you see that current value now is this box where the interval live right so that's actually that's actually where the in value is going to be stored in this current value member of the promised time and so the quarantine is going to talk to this object in order to write that in there and so all of these other functions like initial suspend final suspend etc that you have to implement are basically answers to those questions that the coaching is going to ask you about how they reentrant behavior should exactly works when it yields when it suspends et cetera and there's some some choices you can you can make here so and that will basically those choices will govern the behavior of the protein body but this is kind of like very deep stuff for this for this basic example i just went with like the default basically which you know i still have to type it out but more interesting is this here which is the yield value function which you have to implement and that's the chord inside of that communication channel so the core team will call that function to actually when when you say yield x so it's going to call that function to put the x into that box and i'm taking that value here by const reference you can probably also take it by move you again have lots of choices here but anyway this works and then we have the actual generator and that's the object talking to the user code and that's some limitation of the generator so now you see here you have the scoring handle which is this compiler generated magic type which which is this type erased point through the actual quarantine which the compiler generates under the hood and basically essentially the rest of this is a bunch of constructors and basically managing the lifetime of that coating handle right and then the only other interesting bit here really is this so of course the promise type here that we just saw and then this and that's the user side of that communication channel so that call operator that's the operation that the user code is calling to get zero one two three so that's the thing that actually returns the int like takes it off the box and returns it to your code right and again you can maybe move it out of the function here i'm returning it by value you have all of these choices so basically don't try this at home like i really cannot stress this enough there's like a lot of subtlety here there are a lot of choices to be made and i just about managed to write this like very simple generator for this very simple case of just generating zero one two three but i'm certainly not able to implement a generator for some more complicated use case and so really just use a library where people who you know have sort this through have implemented this for us but you know now we have this kind of generator and when you do this you get this user code right and that's really nice that's really clean that's really efficient and that's how we can use them and it actually becomes even more interesting when you have multiple coordinates because let's say you're implementing a front end for some programming language right so you need to read characters from a file then you need alexa to turn them into tokens and then you need a parser which takes those tokens and build builds an ast right so what you can do is you can either first read the whole file then lex the whole thing and then pass the whole thing and then you have a bunch of classes which have interfaces and members to do all these things or you do it with courage which do it lazily and cooperatively and so that's really nice because then you know whenever the parser needs a token it calls the lexico routine which just yields the next token right so it's just the lexus in the middle of lexington and it's just going to heal the next token and then the the parser can keep going and then whenever the alexa needs another character it's just going to call the the reader which is in the middle of reading the file so she's going to yield the next character to you so it's really interesting because it's a completely different way of designing this right so you have this like cooperative like different courteous handing over different work to each other in the just like at the time when it's needed and so that's really interesting and i guess he gets even more interesting when this happens on different threads because now we have basically cooperating sorry cooperative multitasking instead of preemptive multitasking right and that and like doing it that way avoids another problem with multi-threaded code which is commonly known as call back how and i work in audio audio technology where we know this all too well we have like an audio processing thread and we have to generate and consume like audio buffers like so we have all these callbacks going on this is kind of the traditional way of designing this and you use objects for the stuff right so typically you have an object which then registers a callback to another object and then they call them back on a different thread which is like a different thing there and and this kind of logic is kind of scattered across all these different places you can't really debug that it's really painful to work with this kind of code and and quarantines make this kind of stuff a lot simpler so we can we have already seen coroutines that can yield and resume turns out they can actually do a third thing and that third thing is exactly the thing we need here and that's called a weight and that's how basically you get quarantines to cooperate in with each other in this in this very interesting way let's say we have a quote in f1 and another coordinate too and now we have this third key word here which is cool weight by the way as soon as you write any of these three keywords called yield co return and kuwait that's how the compiler knows that your functions are quarantined so there's no other syntactic marker for it so the fact the functions the query and basically is implementation detail depends on whether you use any of these keywords inside the body and that's really quite important so from that it follows that we can only co-weight on a chorogen from another choroidin so anyway when you write cold weight f2 what happens is that f1 suspends just like it did before with yield and it returns control to the call side of f1 but the trick is that now when f2 later yields it's going to resume f1 from that point from that core weight and that's really interesting because f2 actually could be running from a different thread right so what you effectively get here is you get this thing where where basically the way to think about this is that when you write cool weight f2 what actually happens there is that you're registering a callback with f2 and then you re return your yield and then the rest of the function body of f1 is essentially that callback right and so using this pattern is really nice because you don't actually have to write out those callbacks as like separate functions so your code ends up much cleaner so and and the logic is together in one place and this whole communication channel by callbacks is just completely abstracted away and the only caveat here is that you see i wrote async generator here instead of generator so if you have multiple threads going on you you kind of need a fundamentally different promise type because you need to synchronize access to this like shared value the the kind of box to avoid race conditions so you probably need to use locks and stuff like that or maybe if it's an inch you can use an atomic and that's really really important so the quartens themselves they don't do that for you they don't care about threads and actually let me stress that again quartens have nothing to do with threads okay so if your generator type is asynchronous and thread safe then but you have to actually do that or use use a library that does that and then you can call your coroutines from different threads and then it will just work and that's really cool and i really can't wait for this to become like a popular widespread technique because it's not just for kind of audio stuff it's also like imagine networking code where typically you also have this like callback and you're being called back on a different thread kind of thing which i imagine a lot of you are writing code like that and this is going to make it a lot simpler all right so we talked for quite a while about core teens we do have a few more features left to talk about so the next really cool one is concept so let's talk about concepts but before we can talk about concepts we have to talk about functions so here's a function this is a function that takes an integer and determines whether that integer is a power of two that's a very useful function in order for example we need this all the time and that's really clever way of implementing that which is using basically bit operations to determine whether exactly one bit is set and because that's the way it works it really should work for any integer type right so how but you don't want to just write this for an in so how do you make this work for any integer type i mean you can write out all the 12 overloads which is going to look like this that's not great but hey you're writing class plus so we have templates right so we can template it on any type and and now we can use it with any integer type right so that's what we do but now we have a problem because what happens if someone decides to use that with a floating point number like a double here we're calling a power of two with this 0.25 double value and now you get this vb error message saying invalid operands to binary expression and then as the user you know you just see template entering t okay why doesn't it work and then basically what happens is that the compiler tries to instantiate that template with the double and then it runs into an expression that basically doesn't work for a double which is just like bitwise and there and so then it it basically gives you a compiler error inside the body at that point saying like that that you know operand that doesn't work for for a double but then what the user needs to they need to actually go inside the implementation find the error figure out what's going wrong there and and that's really that's really messy the user shouldn't be looking at like somewhere inside the guts of the function body to figure out why it didn't compile right and this is actually a relatively easy error message but you know if you have more complicated stuff these error messages can get a lot longer and if you ever use boost you know exactly what i'm talking about how do we prevent this from happening well we have a modern tip so we can write aesthetic assad saying this is only for integer types right so that's good that's much better now we get a much better error message so we kind of solved that problem but let's say we actually want this to work for floating point as well right because 0.25 actually also is a power of two right it's two to the to the minus minus second so we kind of want this to work and there's actually a a clever way of implementing this for floats and doubles as well which looks like this so basically we can take the floating point number and decompose it into mantissa and exponent which is what stood frexp does so if you've never heard about fraction before now you have but that kind of sucks because if you write it like that you get this error message saying redefinition a function template is power of two because even though you said you know the one is for integrals the other is a floating point you did that did the function body with the static assert but the the signature of the functions is the same so you basically redefine the same function two times which doesn't work and in c plus plus 17 really the only way to get out of this really unfortunate situation is using svena and enable if and i'm sure you know some of you have experience with this stuff let's let's see if we remember how to do this okay so we need to like enable if one for integers and the other one for floats so we have this this enable if thing where do we put it right so we can put it into the return type like this that kind of sucks because now we don't see the return type anymore the actual return type so we can put it into the parameter list which is not great either because now we kind of don't really see what the parameters this function takes because it kind of obscures the parameter list so my favorite method actually is to put this into the template argument list i think that's the most readable variation of this because it doesn't mess up the function signature unfortunately this doesn't work because turns out that in t plus plus default to template arguments are not part of the function signature so we get the same error again that it's a redefinition of the same function with the same function signature so what you actually have to do is well turns out that what i just said is not true for non-tag template parameters so you can make this a non-type template parameter so you can make this an int like this and that will compile and that's what i've been using for quite a while but then my friend garsh parasaman actually told me recently that that's not good because ins can actually legitimately occur as non-type template parameters so someone could actually put an actual value in there and that would break this mechanism so instead of using this we should use a void star non-type template parameter and that's the best way to do this okay so this is ridiculous right it's impossible to use this like no one no one is going to remember all of the stuff how do we even like teach this or remember this like i certainly cannot do that so the good news in c plus plus 20 is that we don't have to use this ever again because you can just write a constraint like this this is what we get from concepts right so you can just say requires integral requires floating point and these still intricate floating point are now actually standard library concept which you just get in the standard library so you can just use them like that that's really nice of course this is c so there's actually three different ways to write this so this is the long form there is also a shorter form where instead of saying template mt requires you actually just use the concept name instead of the keyboard template so you say template integral t and then there's this a really short form where you actually don't write a template the template head at all but instead you just write it as if it were a non-template just a function but then you say concept name auto and just in the parameter list and and basically you see that it's a template by this like concept auto syntax but it looks just like a mostly just like a normal function with a parameter list and we also see why it makes sense to have these different syntaxes actually it's because they're for different use cases so in the first case with the integer we can write the short syntax in the second case we kind of have to name this type in the body because we are we are instantiating this mantissa thing there so that's when we use the longer form which actually gives a name to this type with the t right so so it makes sense to have these different syntaxes but the point here is that concepts makes cname much much easier and that's going to fundamentally change the way you write templates but that is still just scratching the surface you can do so much more with concepts so first of all you can combine them so you know if you want to have an arithmetic concept which actually is not in the standard library but might be useful you can just say okay a type that's arithmetic is just an integer type or a floating point type right so you can make a concept out of combining two other concepts and then you can also combine them with and let's say you have for some reason you have a concept of any kind of number but it has to be like not bigger than eight bytes because i don't know because you're doing some low-level stuff where like you only have to you have to make sure that you're working with numbers that are fitting into you know some kind of like small amount of memory or something it doesn't matter so here's your kind of small number concept where you're saying well it's any automatic concept and also the size of of that type has to be not bigger than eight bytes and actually you see that you can not only combine contacts with concepts with or an and but you can also combine concepts with just any compile-time boolean expression like the size of which isn't the concept and you just can't kind of combine them like that and now we can write a function template that takes exactly the types that it can handle right this f here and if you then like for example violate this this contract then you get really nice error messages right so if you pass a double and that's okay if you pass a long double in which has a size of bigger than eight on most platforms you get this really meaningful error message saying you know error no matching function can be ignored because long double doesn't satisfy that concept you know because that constraint is not satisfied so you get these like really really nice error messages and it gets even better than that so you also have this thing called requires clauses where you can basically just directly write in code what the requirement is so let's say we you know want to implement something like hashmap and you want to template that on any type that is hashable and if you want to define what hashable means well you say well hashable is you know any any class for which you can instantiate to the hash and then if you call that's that has it's gonna return something that's convertible to a size t it's going to return you some integer like hash value right and you can have directly express that requirement to the interface of of that class in code and that's your concept and then any type that basically satisfies this interface will will satisfy the concept and will work with your hashmap and that's really cool because previously you basically had two ways to express like what the what you know what interface this t is supposed to be you know supposed to have in order to work with the template so either you could use like not not use templates at all you could use like a base class like hashable and you can inherit from that base class this is what you know languages like java are doing or if you use templates then the only thing you could do is basically just kind of document those requirements in the docs right you can just say well if you want to use this template then you need to implement this and that but now you can actually write those requirements directly in c plus code instead and that fundamentally changes how we design libraries so earlier you had to think okay what classes do i need when i'm making a new library is it going to use templates is it going to use inheritance and virtual functions now the first question is when you're designing the library what concepts do we need to define right and then everything kind of falls out from that and and that lets you write much more flexible libraries and much more powerful libraries and much more expressive libraries and once you start using concepts you can't really go back anymore and and actually some libraries are just outright impossible to implement without content and and the best example for that actually are ranges so let's talk about ranges for a bit let's start with kind of the most basic level let's say we have struct users and users have names and ages basically and then we want to sort those users by age right so we have sort we pass in this begin and end iterator pair and and the custom sort operator which sorts them by age as a lambda and that's how we do things but obviously always passing in these begin and end the iterator pairs to all these algorithms that's quite repetitive so what a lot of code bases do is they just introduce their own overloads for all these stl algorithms which instead of begin and end they just take one one argument which is templated and that can be anything that has a beginning and an end and i know that the code base that i'm currently working on has this upsell has this as well like i'm sure many of you work in with code bases that have these like extra overloads just for convenience basically and just to get rid of this like begin and end kind of boilerplate and the good news is that rangers give us that right so now we have those overloads in the standard library we can just pass in the vector directly but the cool thing is that that's not just an overload it's actually constrained with concepts right so if you try to pass in something that's not actually sortable that doesn't work with that particular algorithm you actually now get really nice really meaningful error messages and then you have another feature here called projections which makes this use case specifically much much nicer even so you can write it like that so it turns out you don't actually need the lambda anymore at all because these stl algorithms like sword they now take a range they take in this case a comparison operator and then they also take a projection so you don't need that lambda anymore you you just give it the projection as prediction you can just give it a pointer to member to this age member right and that's just an end and that's it and then for the second argument you can just use the stood less just that's going to work with an in the compiler knows how to compare ins and that's really cool that's it that's all you have to do here you don't even have to write lambda anymore and that's really cool so let's look at the declaration of ranges sort so you see in the last line it takes these three parameters like a range a comparator and a projection and then you see it's a template which is templated on those things and it has a requires clause in there which says well basically the range needs to be sortable and that's of course a concept so let's look at how the concept sortable is defined well something is sortable if it's permutable and there's a strict reordering right makes sense now these are also concepts so let's look at the permutable concept in terms something is commutable if it has a forward iterator and it's indirectly movable storable and it's indirectly swappable and it's basically like this all the way down and this whole library is just written with these concepts and just imagine for a second what this would look like in c plus 17 if you had to like emulate this with stood enable if that would be ridiculous right like there are a handful of people in the world who have actually have done stuff like this with like enable if and then macros are on them and stuff like that and they can only begin to imagine how painful that was but nobody will have to do this ever again with concepts it's kind of it's just code you can't read it right so that's really nice let's go back to let's go back to our users here let's do something a little bit more complicated so we have these users let's say we have a vector of users and let's make this a const vector so maybe so we have a range that we actually cannot modify in place and that's kind of to simulate a scenario where maybe that's actually not a vector you know maybe we are reading the users from the disk or maybe reading them from the network like one by one right so it's like a range that we cannot modify something like that and now what you want to do is you want to remove all the users that are under 80 years old and then print the age of all the remaining users and let's try to write this with traditional stl algorithms right so we have this lambda which is saying okay are you underage so we filter them out using copy if and then we transform that range to basically print print the age of those remaining users and that's like c plus plus 98 or c plus 17 also code i mean obviously yeah we have this lambda there so it is more than c that's possible it's pre c plus plus 20 code and it kind of seems that in order to write this a bit more compact what we need here is kind of a transform if algorithm but that doesn't exist in the stl because why because you know if you had to write transform if you'd also have to write generative and fill it and all of these other permutations so you would have like an explosion of that and this is just not the way to go so how do we combine stl algorithms and it turns out that without ranges we kind of have to combine them eagerly in this kind of procedural style so it means that you have to do the loop twice right copy if it's going to do a loop over the data and transform is going to do another loop of data and also we need to actually copy the data like from the from the original vector into this like other vector so that we can store the the filtered users the intermediate result and we can actually hold that in memory that's not ideal and what ranges allows us to do is actually to combine that lazily right in a functional style and and that's going to look like that so that's how you write it with ranges so we have these ranges now instead of suspending which are called views and all they do really is they wrap other ranges right and and they give you like a modified a modified range which is kind of wraps the other range and you can easily combine those those views with this pipe operator and the important thing is here that they're lazy right so this code in the green box is actually not going to evaluate anything it's actually not looking for the data it's not touching the data it's just it's just a new range which is like these like nested views and the other thing that's really important here like why can we do this because now instead of working with iterator pairs like being in an end you're actually working with a single parameter which is which is a range and you can return one single parameter from a function so that allows us to kind of thread us through this chain of function calls and and that's a very useful way to think about ranges like what they actually are kind of fundamentally is they're an interface to write stl algorithms in this functional style where you can kind of combine things in this way that we had to write procedurally before and you can you can copy this range like that and and if you want to actually print this now so because the the whole expression before that actually doesn't do anything so if you want to actually print that you can do it like that without with a call to copy and that will then actually loop through the data and evaluate everything right but the important thing is that it will loop through the data only once and now if you're like chaining these views like that you actually end up never writing any loops at all so remember when you know sean parent said seven years ago no raw loops and now in cpr 20 you really don't need to write loops anymore but of course you know because result itself is also a range so it does have a begin and end so if you really want to you can use it with the loop old style it's going to work you can put this whole thing you know in a range-based forum for example and because it hasn't begun an end it will just work and so filter and transform are just two examples there are many many many more views in c plus 20. here's another example we have yota which is another view which you know is the range's version of the yota algorithm and if you know what the yota algorithm does you can guess what this does it prints zero one two three four five and the cool thing about this c plus plus 20 version of yota is that you could print as many numbers as you want and you don't need any extra memory for that because you never have to store the whole sequence in memory because it's just lazy and that's another way to achieve what we did before with quarantines and actually in fact it's pretty cool because remember when we were talking about quartens they were saying that we're going to get a generator and c plus plus 23 for coroutines so that's the generators actually also going to be a range so in this kind of in a really interesting and weird way they are kind of two sides of the same coin here right which i think is really really cool i don't have time to talk more about ranges and the different algorithms that there are but i can highly recommend you this talk i mean there are other talks as well but this is my favorite so far talk by tristan brindle giving an overview of the standard ranges which is one hour talk from last year's cppcon which is basically going to give you an overview of everything you need to know so i highly recommend you check out this talk to dive a little bit deeper we have one more big feature to talk about in cpr20 which are modules and of course i saved the best for for the end but actually before we can talk about modules let's talk about headers that's the stuff that we know that's the word that we live in right now so remember the generator thing that you wrote earlier for corinthians let's put this into a header right because it feels like this is a template it's like a generic thing you might want to reuse it in different parts of the project so we're going to put it in the header and remember that like math like power of two thing that we used earlier that might be very useful in different parts of our project as well so let's put that into a header as well right and now maybe we have a cpp file somewhere which is going to use both of those headers and then we have another cpp file there which is also going to use both of those headers master h and generated.h so that's that you know the typical scenario and hash include basically what it does as you as you probably know is the preprocessor is going to just take that code and just copy paste it into that file right and that's going to be your translation unit so it's just really stupidly you know takes the code from this other file and just copy paste it into into the file we're including stuff and so when you include the same headers and multiple station units the compiler is going to repeat that process it's going to like you know put that code into all these different tp files and so when you then compile them the compiler has to basically in every one of them parse and compile all this header code right so encoding stuff for tpp it's going to browse and compile everything in math.h and generate that h and other stuff.tpp it's going to do the same thing over again and over again if you include those headers like in 20 different files the compiler will have to parse and compile the same code over and over again 20 times so on the one hand that's really great because then all the translation units are independent from each other and then that's very easy to parallelize but on the other hand that's really bad because that's really slow and you're wasting a lot of resources and actually that grows non-linearly with the amount of files so that's really bad it doesn't scale and now if it's literally the same headers and they're included in the same order then you can cache it there's tools like c cache but it's just enough to flip the order of like two of them like this and now it's different code right so now because it's just copy pasting it's gonna paste it in this order or in that order and then those differentiation units have different code and the compiler again has to pause and compile it multiple times and there's more fun all right so there's more fun stuff headers can have cycles right so you can have these dependencies between headers because the preprocessor is not going to prevent you from doing that it's just copy-pasting code so you have to kind of write primer once or include gods and sometimes you forget to do that or you mess up and you include things cyclically anyway and then you get these weird errors and you spend two hours basically looking for the place where a certain head is getting included and it's really messy and then we have macros as well so for example if you define a macro above your includes then that macro can leak inside the header it can change anything in there for example if you define any bug well that can change the layout of some class inside generator that h right so then if you link those two cpp files together you will have two different different definitions of the same class so that's an odr variation and that's like undefined behavior except it's actually worse because it's undefined behavior on the linker level essentially in the standard we call this ifndr it'll form no diagnostic required which basically means you have no idea what program you get you but it's probably not going to be the program you wanted it's probably going to crash or do something really weird you're not going to see any compiler warnings or linker warnings or anything so this is very very fun to debug and of course macros can not only leak into headers that they can also leak out like for example you define a macro in generated with h and that can leak out of that header leak into the headers that you define below or leak into the cp file that includes it and the other problem with headers is that they don't support really any form of encapsulation right so that's the other thing so if you implementing this thing and like let's say you have a helper struct here which it's just an implementation detail but you have no way of hiding this in the header right if you're writing standard library code you can prefix it with double underscores because then other users are not supposed to use that because that's ub but most libraries are not the standard library they're just other libraries and so then people do this namespace detail stuff which is essentially just a convention which doesn't actually prevent anyone from going in there and i also see people use anonymous namespace and headers so please never do that ever because if you use anonymous namespaces and headers then actually everything will end up in one gigantic big anonymous namespace and then it just all explodes so don't don't do that please and modules are really solving all of this right so now we can put our generator into a module and the only things that are visible there are the things that you export so you write export struct generator and that's going to be visible to the user of the module struct helper you didn't write export so by default it's just private essentially it's just hidden and macros cannot get into the module macros cannot be exported out of the module cycles between modules are forbidden so this module is completely self-contained as well which means that you have to parse and compile it only once when you do that actually the compiler will turn this module into this bmi file which stands for binary module interface which is a bit confusing because you might think that a bmi is a binary file like an object file like dot o or something like that that's not the case binary here just means not text so it's like an alternative representation of the code which is kind of optimized for fast lookup of all the definitions in the modules so the compiler can compile stuff faster so it's going to be some kind of data structure like a tree it's specific to the compiler it also contains the version of the compiler all the flags that you set even like which warnings that you set so this bmi file is really not portable you should not distribute this ever it's just an implementation detail of your build system essentially let me say that again if you give this bmi file to other people they will have a very bad time so please don't do that that's an intermediate step in compilation essentially but now you can actually use your module like that right so you can write import generator import math the order of imports doesn't matter anymore and that's really nice so like i want to close this section by saying that modules are a massive feature there's many more details there's many more additional levels and ways to organize your code that i can't really cover here because we don't have time for that but i really recommend you watch this talk by bryce elliston levelback called modules are coming where he goes into all the gory details don't watch the cbv conversion which is just one hour watch the core cpp version which is actually one and a half hours where he covers more ground and that really dives deep so i recommend you check this out but basically the summary is that modules solve all these problems with headers right and they also completely change the compilation model and the way you organize the different components of your cpl stuff project so the only snag is that the seat of the standard library itself is actually not modularized yet but we're going to add that in cpr23 and that's really the only feature that that fundamentally changes the architecture of your program that changes how we package our libraries how we how we you know package everything like classes functions it's a huge ecosystem change it actually is like a pathway to like moving on from header only libraries as a convenient distribution mechanism we can make package managers easier so it's a huge ecosystem change and i think it's going to improve things a lot it's probably going to take time to be adopted but i'm really looking forward to that all right i'm almost at the end of my talk i hope i can get one more minute to just show like the last couple slides with our yes one minute okay thank you long awaited fixes and i'm just gonna mention one particular one which is this one let's say you have a vector and you want to remove all the odd numbers right very simple task how do we do this well i'm sure i'm sure some of you know it's this thing the eraser moves thing and that's probably the only thing in the standard library which i hate even more than instead enable it because everyone who's learning c stumbles upon this right so everyone writes vector arrays in the loop raising elements one by one so you have to explain why this is slow you have to explain this weird idiom and how this works and then remove that and actually remove anything it just moves things around and then erase essentially like crops the range and a lot of people think that remove is moving unwanted stuff to the end which is actually not what's going on it actually moves the element that you want to keep to the beginning oh writing the unwanted ones and i myself actually didn't know that until this year when i when i read like a blog post from ben dean about how remove if actually works so this is horrible and the good news is in c plus 20 we never have to write this again because we just have the still erase which just takes a vector and does the job right so we can forget about the razer move and never speak about it again and that's great and i mentioned this as an example but c bus does 20 has a lot of stuff like this where it just removes a lot of these obstacles and that makes superstars easier to teach and easier to learn and it makes everyday cps passcode like this much easier to read and that in itself but also will also significantly change the way we are going to be writing code thank you