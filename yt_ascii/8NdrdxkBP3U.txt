hey guys what's going on and welcome back to another low level learning tutorial today we're gonna go over arc64 or arm64 assembly and by the end of this you should be able to write a hello world program so let's dive into it if you haven't already seen my other video on arm assembly go ahead and check that out i'll put it in the description we go over this slide a little more in depth but basically writing assembly which is the layer below the high level language in a form that is not yet understandable by the computer and we put that assembly into an assembler that puts it to machine code that the computer can then execute so like i said before today we're going to go over arc64 arc64 is the 64-bit version of the arm architecture because of that it's still a risk instruction set it's a reduced instruction set compiler which basically just means that it has you know fewer instructions than your typical like intel yep and it's a it's a 64-bit architecture which means that it is 64-bit addressable meaning it can address a 64-bit wide space and in this case the instructions are also 64-bits normally the biggest change that you'll notice between this and arm 32 is that the registers are now referred to as x0 and x30 so you can actually address the registers two ways so you can look at them as x0 for example that will get you the 64-bit register you can also refer to x0 as w0 which gets the 32-bit lower half of that same register so right here and then if i say r0 at all you can still call the registers r0r1 r2 and that's just a you know a reference to x0 for that example the architecture is still bit addressable which means that you can address a single byte in memory you don't have to address an entire word like mips for example and similarly to how arm 32 had thumb mode and arm mode this architecture has 64-bit mode and 32-bit mode and both of those modes have a user in supervisor mode similar to arm right arm 32 64-bit arm is the same way to do an assembly instruction you have your operator you have your destination and you have your source so for example to move the value 4 into x0 the instruction is move into x0 the decimal or the hexadecimal value for right pretty straightforward and then similar to the previous tutorial right to do anything you know our process the user mode area needs to request a service from the kernel and the way we do this is using a system call which in arc64 is this instruction it's service zero or system service zero and then when that instruction gets ran the kernel takes action the action that it performs the syscall number is stored into x8 and x0 through four to determine how we do it very similar to how rm32 did system calls so let's pull open our vm here we go to some of the answers that i have already written boom boom all right so here's our vm we're doing a little bit of work in this so if you haven't already go ahead and make sure you install not pseudo wireshark sudo it's gcc7 arc so if you type that in i already have this you should install this and then also sudo apt-install kimu right so similar to the previous tutorial i'm using an intel architecture vm but i'm able to test my code using kimu kimu is the emulator suite that allows you to run cross-compiled code in a not cross-compiled environment it's pretty cool cool so let's write some assembly right i think like last time step one we should figure out how to implement the exit system call okay cool how do we do that we need to first identify what the system call number is for exit right because all because exit was system call 1 in arm 32 does not mean it's system call 1 and arm 64 right that if they change the kernel at all if they change the binary abi right the way that the binary talks to the kernel that system call number could change so we've got to look it up in a table and the way we do that is by if you go to google you type in rf64 syscall table chromium just like last time provides really good documents on the system call table for arm 64. cool so we have arm64 they are a little different the more standard like posix compliant system calls are handled in the like 64 to 90 range it's kind of weird right so you have like right here we'll find exit is system call 93 or ox 5d okay great so let's extract this number so how do we set up a system call right so what did i say before the system call number gets put into x8 so move into x8 the value of x5d and then what are the arguments to our system call well the error code right what it returns and that goes into x0 great so we'll put that into we'll return ox41 and then how do we invoke the kernel how do we ask it for help we say service zero boom so we're gonna write that and just like last time the way we're gonna compile this is we're gonna first call the assembler right so it's gonna be arc linux new as we're going to assemble our file which is a001.asm for me it could be anything for you guys and we're going to output an object file cool no compiler or no assembler errors rather and and the object file is the intermediate elf it's not executable in its current format because it's not fully compiled into an elf it just contains symbol information and code information that we we care about the way we get it to the final executable format because we invoke gcc on it and we say we want to compile our object file and output an executable okay we're gonna get this error at first and that's because we're trying to compile it against lib c we don't want to do that so we say no standard lib and for the purposes of this tutorial we're also going to say check static because there's issues with the arc 64 build environment on ubuntu16 so great no no compiler errors after we add those two flags and then to test our code we do kimu arc64 our code awesome and if we did this correctly we should get the error code for one or 65 as the output and we do cool all right so now we've written some basic assembly let's get to that hello world right so just like last time we have to define a label called message again and the message is type ascii and it's hello world new line awesome so we've added that and then we need to set up our system call we need to add one right because right here we have a exit system call to get us out of the program the out of the program now we need to do a right system call to put data to the screen so what are the arguments for right let's see so right is system call 64 and it takes argument r or x0 as fd so the descriptor we're going to write to remember in linux we have file descriptor standard in out in zero as zero one and two sorry standard in out error as file descriptor zero one and two so after you'll be set to one the standard out file descriptor that represents the data that goes to the screen x1 will be a pointer to the buffer we're writing and x2 will contain the length of that buffer great so let's do that move x8 the system call number which i said was 64. x0 is the file descriptor so it's going to be 1 which is standard out x1 okay so this is where it gets a little different right we're dealing with memory operations so instead of move we need to load into x1 so we're loading into x1 the address what the equal sign does of the message label okay and then finally move into x2 the length of the thing we're writing so what is it it's going to be 5 10 11 12 13. and then we invoke a system call cool so what are we doing here we are setting up the system call number telling it to write to standard out loading the address of our message into x1 the pointer to our buffer and setting 13 as the length of our buffer writing it to the screen and then getting out of the program safely all right let's try it out symbol compile run it great so we ran our little world guys i hope you learned something if you did please drop a comment and give me some ideas what you want to learn next time thanks for watching i hope you tune in again bye