so we started out i think last time talking about this this grid games language as an example of of a modeling language that one might use in the model driven engineering approach to building software and so what i think i wanted to do today is talk a little bit about how that language was built how how i've built that language how built the infrastructure behind it and a couple of other things that one can do with it no that one has it before we look at some of the code bits etc i thought i'd give a sort of really rough overview of what in the model driven engineering world we think of as a language because we think when we think of a language when we think of a modeling language and modeling approach we always think about three main things which are the abstract syntax the concrete syntax on the semantics the abstract syntax in many ways is what holds everything together okay so this is the set of concepts that we can actually talk about in our language and the relationships between those concepts okay and then on top of that we will build one or possibly multiple concrete indexes and a concrete syntax is about how do i interact with the language what does it look like how do i write things down in the language what do i do to edit models in my language it's how do i store them on disk etc that's all concrete syntax how do i interact with those models that's in there and the import one important thing and we'll see that a little bit in a moment is that there can be more than one for the same modeling language so far we've only talked about what the models look like we've described data structures okay we've described a structured way of writing things down but we haven't said anything about what these things mean at all and that's really really important a computer is done it just looks at this and goes this is data it and unless we tell it anything more about it it won't know how to interpret that data what to do with that data and that's where this third thing comes in which is the semantics which we talk about as well where you say for this abstract syntax here is what it means if you use these concepts and you instantiate them to say something and write something out down then here is how we're going to interpret this and there's different ways in which we can't give abstract semantics to our languages what we're going to see in in in our grid games language or we've used there is we've used an approach called code generation which is very similar to compilers in in sort of typical programming languages for example so let's have a look a little bit at our grid games language and how we've built these various bits for that language so here i've got again my good games language with the with the minesweeper example on my computer and you can see it's a textual language in the first instance right i'm writing down text in various structures we've got these sort of keywords here that are sort of color coded already and then we've got varies whereas words etc and symbols that we're using to writing down our specification so that's an element of it the concrete syntax already is that it's a textual language in the first instance that allows us to to interact with our model through writing text editing text and looking at that text okay the way we define textual language is typically is through a grammar and the grammar is essentially a set of rules that say that that gives us patterns that we can that we can sort of instantiate in our text okay and so what we've done here for example is we've written down a grammar grammar rule here at the very top that says for our grid game for any grid game model it will always start with the word game then we will give the name of that game that we're specifying then we're going to have an opening curly brace eventually we're going to have a closing curly brace at some point and in between that we'll have various other things that we can specify we can specify these these state cells actions initializations fields and options and each of these refers to another rule here so for example here the states refers to this global cell states back rule so if i go to that it tells me what this definition of states in in sort of the overall document looks like okay and so that's something that starts with the keyword states and so if i go back to our minesweeper game definition we'll find that here so here is something that starts with the keyword states and then has the name of these states and have some parameters and then has the actual states inside and that's exactly an instantiation of this global sales dates back rule here in case it starts with state dates as a name possibly has some parameters curly braces and then a set of states and an indication of what the start state was now technology that i've used here specifically for building a language is something called x text there are a number of other similar tools out there and importantly now there are also tools that allow you to build languages where the editing and infrastructure etc exists in on the web and runs in your web browser and it off for protection languages they're very similar to this right and what they do is you define this grammar which kind of defines your concrete syntax but indicates actually where the abstract syntax concepts are as well and from this you generate a lot of the code infrastructure so you will see here on the left in my code browser you'll see a lot of code in there and most of that code actually is generated more or less directly from this grammar one thing that perhaps particularly interesting to look at is this class diagram here so this diagram here that's the abstract syntax of our language and i've sort of started cleaning up the layout a little bit so that we can look at this a little bit but i haven't done the whole thing but let's maybe just look at some of the key bits here so we get a bit of a feeling for what abstract syntax looks like okay abstract syntax for for any language out there is fundamentally a set of concepts which are represented as glass classes or as boxes in this diagram they may have attributes which is where we can put data in there that specifies the specific information we want to to capture about this concept and then there are relationships between those concepts and relationships are represented in our abstract syntax diagram here as edges between the boxes okay and so we'll see here that we've got this grid game concept which represents a game as a whole i'll have some information about the name and then it has this these edges here to these various things that can be contained inside a grid game so for example we can have zero to star which means an arbitrary number of cell specifications and each cell specification again has a name and then contains various things inside of it or we can have this global cell state spec thing that we saw earlier so we can have again zero stars so any number of those and these then contain cell states further down and so on and so forth okay so this all gets generated from our grammar but importantly the other way around if i look at my minesweeper specification here that actually gets passed into a set of objects that are instances of those classes under half those connections between them that we've just seen in that class diagram and that's what allows me to then do more with my model okay i can use that set of objects to do this validation for example that we saw last time where we were able to see oh okay this particular state is never reached or i can use it to specify the semantics of my language for for example by writing a code generator so for example here is a bit of code that generates the classes that implement individual cells so what does that do it has a grid game here and it goes through all the cells and for each cell it generates a file where it puts in the code for that class and if we go there we see what the what it does is actually it generates some text which i've written in here and you can see that with the gray backing and in various places it is now just hard-coded text but it puts in text that it copies out from the model right so it'll go into those of into those interconnected objects and it'll navigate through the edges and between the various objects to find the information that it needs right so for example here it goes i'm going to go into my cell going to the members i find all of those that are variable specifications and for each one of them i'm going to generate what essentially is a java field declaration and so on and so forth it's a really this becomes taking the information in that set of objects and turning it into text and the tricky thing here of course then is always to work out what's the right code to generate and how do i generate code that's ideally reasonably readable but also isn't totally cumbersome and sub-optimal and doesn't perform well etc some of you've asked about why do i have to go to all of this effort right why why do i have to do all of this why can't i just write a library and the answer is you can okay so a lot of what we've seen is if you look at this class diagram for example right this looks a lot like just standard object oriented programming and you could do that directly in kept okay in fact there is something that people have called internal domain specific languages that does exactly that they write libraries that where the functions are written so that it reads like a language okay so it's it's sort of halfway there right if we look at our grid game language here we might end up then writing something like where we say a new game and we provide the parameter minesweeper dot and then we'd start putting in all the additional information so we might have a function field easy that then again lets us add with a dot lets us add additional information such as the width and so on you can see you know we can write a library that allows us to do this and it reads like like like a language and that sometimes is the right thing to do right especially if people are using your language are people who are ready programmers and who want to make use of all the extra features that the the host programming language gives them then this may be exactly the right thing to do but if the users of your language aren't actually programmers then this is perhaps not so helpful to them but also doing this means you are still constrained to what your host programming language can do and so things like our check for for reachability yes you can implement this in here but you can actually only run the check when you run your program whereas with the standalone language that we had we could run the chag statically and get feedback as we were editing this specification rather than having to run it and then see oh i made a mistake okay and again it's horses for courses right in different contexts you will want different things the these sort of more internal languages may be easier to build maybe quicker to build they mean people who are already familiar with these tools don't have to learn new tools and then that may be the right thing to do in other contexts very much it isn't the right thing to do one thing that becomes really difficult if you have a library is this thing with supporting multiple concrete syntaxes that i sort of indicated here briefly one thing we might want to do for example is we're talking about state machines here a lot right so a very natural way of looking at a state machine is actually visually because we have a separate language it becomes really easy to specify a second concrete syntax for that language and i've done this here i've created a diagrammatic concrete syntax here with a tool called sirius that that allows us to to build these graphical syntaxes really easily and really declaratively and what i've done is that this is a diagram of the state machine that's defined in this model over here already and they're they're linked together okay so if for example i go in here and i add this additional transition into my tech in my textual model then you'll see that that appears over here in the diagrammatic model as well and if i again remove remove this here then it disappears there as well okay and in fact i can do the other way or do it the other way around as well where i edit things that can added things in the diagrammatic side of things and they get reflected over into the textual model okay because actually they're both the same model it's both the same abstract syntax representation they're just being edited through different concrete syntaxes okay and that's something that's essentially impossible to do when you have a library but becomes possible when you have your own language and that means you can then provide different stakeholders in say a larger software development project with different perspectives on your model that are captured in a notation that's familiar to them that's usable to them and that makes it easy for them to contribute their expertise to the overall project people have asked about what's the what's the cost of this and when where so and therefore why would i do it right first off yes it is being used in industry and is used fairly widely in fact quite a lot of people use it without being aware that they use it right if you've ever written a kubernetes script essentially you're doing this if you've ever used react essentially you're doing this but there are places where people do it sort of more explicitly a lot of sort of the systems engineering world is moving increasingly towards what they call model-based systems engineering which is a lot of this there's a lot of building models building these structured representations of large and complex systems and they're all various moving parts in order to be able to stay in control of all of that complexity so where you have large and complex problems it becomes worthwhile the effort of building this additional infrastructure another area where it becomes worthwhile the effort is where you're going to build similar systems again and again but there's some complexity to the differences between those different institutions okay and there i think comes into play what we sort of call the cost benefit curve i think of md which you can sort of imagine like this if you had a diagram here whereas or if we have sort of time and an effort and we want to sort of sketch out how that develops over time then if you have a regular project where you don't use mde your effort would probably be you know something like this it would largely stay at one level and give or take but obviously there's variations over time if you have an mde project and in particular you have one where you have this situation where where you'll be building similar systems again and again over time then your cost benefit curve looks probably a bit more like this and again you know i've drawn it as a clean line but it it'll wobble so you'll have this bit at the beginning here where you invest fairly heavily into building the languages and the code generators and evaluators but then over time that effort and cost actually more ties amortizes as you're building more of these systems as you're benefiting more from the additional analysis capabilities that you're getting and so on and so over time your effort will pro will probably actually end up being lower than if you'd not done it but you know you've got to be aware that there is this initial cost of building the infrastructure the way you do this is you click on one of these cells and it then tells you whether there is a mine there or not and if there wasn't a mine then all is fine and as in this example here you might see a little number that tells you let's just write a very silly little python program so i can write this function let me make a little bit of a bigger font size for you