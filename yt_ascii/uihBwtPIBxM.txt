an image filter is something that takes an image proaches it in some way and outputs an image in response so last time we talked about kernel convolution and i did gaussian blur and mean blur as a couple of examples of a sort of thing you can convey over an image today we're going to talk a little bit about a different type of kernel convolution that is the edge detection   the process will be using in this video is still kernel convolution like we used in the last video so if you haven't seen that video you might want to go back just to sort of make sure you absolutely know what's going on edge detection is simply a case of trying to find the regions in an image where we have a sharp change in intensity or a sharp change in color a high value indicates a steep change and a low value indicates a shallow change a very common operator for doing this is a sobel operator what it is is an approximation to a derivative of an image so there's its separate in the y and the x directions so if we look at the x direction then the gradient of an image in the x direction is equal to this operator here this is our kernel 3 by 3 which is nice and small, so it's quite quick so we have minus numbers on the left hand side and positive numbers on the right hand side and we're sort of preserving a little bit the center pixels because we've got these two values here which is slightly higher waited for these ones? so what we're doing here essentially is trying to find out the amount of difference between this region of our image and this region of our image here by simply taking one away from the other so we'll pass this just like before will pass this over every pixel of our image and it will give us a response for this location here bearing in mind of pixels around it so because you've got zero down the middle it's not going to do anything up and down it's just looking yet to see if there is a if you like a vertical line with that view yeah this is symmetrical if vertically okay, so it's not going to do anything to do with edges but orientated horizontally in the image, so if you've got a bit of image say, but looks a bit like this let's draw a bit of image. these are my pixels they will not all the same size in the last video we use an image that had 50 in these values and a hundred over here so it was an edge right if this is our image right here is an edge fairly obviously we can see that, but a computer can't, so if we put our sobel operator here then what we essentially doing is doing 100 times 1 plus 100 x 2 plus 100 1 plus 50 x minus 1 plus 50 x minus 2 plus 50 x minus one and get gives us an output of 200 which is reasonable ok and you can imagine if all of these values [are] the same, so if they were all 50 throughout then you just get 0 so this will provide a big response where one side is bright or dark of any other side and yes? it's orientated light- left or left [is] right, but we'll get rid of that later at the actual direction and we'll just so so the if you like the sign of the output it doesn't matter no for this. it doesn't ok now this is only half the battle right so we've only calculated the x direction we want to calculate the y direction you know people already managed to guess what the kernel for this is so g of y?   ok and it's minus 1 minus 2 minus 1 1 to 100 there we go ok so exactly the same but you have all tension ok so this will produce a response of 0 on this edge because this row is the same as this rope so big in a cancel each other out in normal photographs this is never going to come up. there's going to be something going on right? it's that's interesting which direction it is we don't know the output of either of these filters? individually could be negative if one side is much bigger than the other ok so what we're going to get if we put tourneys into an image. let's imagine we stretch those negative and positive values to between or 255 and just out put it into a grayscale image then what we'll have is an image of it's mostly gray with black on one side of each edge and white on the other side depending on the orientation of the edge and the same for the y but what we really want to do is take both of those values and turn them into one how big is this edge? so when you say about the black and the white that's because you get in a plus and a minus. yes yes so if you take if you take let's say a value of minus 1 to plus 1 and you scale if naught to 255 and all the minus values are going to be the blacks and all the positive values of in a bid the whites up above 128 so at the moment what we have is a set of values that represents how strong our gradient is vertically in how strong it is horizontally and what we really want is the total of those things? ok so just like with a stand and kind of hypotenuse of a triangle we can basically square both these values add them together and square root it and that will give you the general magnitude so i'll write that down and then remove more sending so we've got a value of a gradient in the x-direction and we've got a value of the gradient in the [y] [direction] and the total gradient the magnitude of a gradient is given by the square root of g x squared plus g y squared ok you'll see but what this does by squaring a man n square routine and we also remove a sign have you got an eye on the spot on numberphile? is this is this why we're doing equation though? what don't put me on there because my maths is it looks good at but it falls down quick so you can see is from if we're squaring them at square rooting them then that removes the sign? so this magnitude is now positive all the time ok and a value of zero will be an absolutely consistent color so this is this is a function to get rid of the sign and show the time yeah and now if the gradient in the x direction is big but a gradient in the y direction is small, you'll get to moderately large gradient if the gradient both directions is big you'll get a pretty large gradient and so it will basically be how big is the edge at this location? ok and it will be a black and white image if we scale it up another interesting thing is because we know the signed gradient in the x and the y directions we can calculate the angle of the of the edge as well so the orientation of the edge is given by inverse tan arc tan of gui over g x so essentially if you take the gradient result from your gy and a great result from of gx you divide them and then you calculate the inverse tan of that it will give you a value in radians or degrees that says what orientation in the image is that particular pixel and that can be really useful for finding structures or finding objects and things like that it's unusual for so bell if ever to be run on color ok this is a grayscale operator so obviously you'll need to convert your image. if it's in color to greyscale first so that we're talking just about change in intensity also sobel is very very it's not with her could you run it on color out of interest? you could will it give you a wacky output it would get well you'd have three values of edge detection for the different color channels on what? entire short that would mean so but yes, you're suppose you could i don't tend to so the other thing is that so bills very it's been be noisy. okay. we're using a small kernel and images change a lot so you're going to see a [lot] of edges where it's not actually really an edge in our sense of the word another thing would be if you had a camera with a fairly high iso settings you had a lot of grainy noise that's going to produce the thought of low-level edge over everything which is not all we want so it's very common to use a gaussian blur first over sober , before sobel edge detector just to get rid of the low the high frequency stuff and keep the low frequency big walls that we're looking for you would do color to greyscale conversion, then you would use a gaussian filter to blow it a small one not too big and then you would use a sober edge detector and that will produce your nice black and white image where big white bright edges and dark everything else written some quite cool code which has got loads of comments in so everyone who? even if you don't code, you should better follow it along there'll be people who complain this in c-sharp. i don't care about those people okay, if you want we can record a nice why i see sharp rocks, rant, and you can provide no mushy