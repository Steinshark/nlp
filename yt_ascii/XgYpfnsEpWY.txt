discussion on parallelism i'm not sure about turkey especially what do you think about c plus plus usability and connection with concurrency and parallelism in general or in comparison with other languages do you see any interesting features what should be definitely added yeah okay so i my background with this stuff goes back a long way i'm not going to say i'm totally up to speed with everything that everybody's doing these days but i originally got a master's degree in parallel computer systems and one of the things that on that i i studied csp communicating sequential processes which was the basis for the occam language and the open language has channels which go sort of has a bit of a go at and i also studied my my thesis was on the actor model and these are very clean models of expressing concurrency constructs and by the way i'm just going to use concurrency generally to refer to anything where there is potentially simultaneous activity i'm not going to try and say that concurrency in parallelism are two different categories they're not they're kind of depending on how you define they either overlap subset each other or whatever i'm going to use concurrency to refer to all of these i feel that c plus is not as usable as it could be it started there was a thing the first so we first got proper standard threads in c plus 11. that's a long time after people wanted a standard solution but as the standard was deferred it was kind of inevitable c plus plus has to have a threading model if it's to be a credible language that for systems programming you cannot say i am a systems programming language but i don't i can't talk at the level of the operating system threat then you're not a system as programming language okay so you have to have that level i'm not going to say you don't want it but the first thing we need to recognize with threads is that they are very raw they are a they are a primitive and yeah they are a threat you know yeah they really are you know here is a thread of control and oh here's locks good it's you know this is i i mentioned ikea furniture you know this is probably more ikea furniture in this sense it's like you have to build this you have to build up your own construct yourself in others before you can actually be producing useful code you've got to choose your paradigm and your your whole approach to threads people are not aware that this is a decision they can take so they often end up programming at the level of threads oh look i have a function here let me just launch it as a thread oh my goodness we're going to need to lock this and i'm gonna have to lock that and it's basically like trying to put out fires yes kevin is frozen or is me frozen not sure let me see yeah kevin drop now out of the studio too i have no idea what that outage was i've just checked everything i have no idea yes if you've got a nice screenshot of me just freezing yeah okay so so the the thing is this idea of building up primitives we could just say just like you know a jump state but a go-to is a primitive from a primitive you can build if statements while statements and all the rest of these other constructs and we would much rather use the built up things than have to rebuild it ourselves having programmed an assembler but also programmed in old fortran the idea of making my own while loop just has very little attraction but that doesn't stop people working at that level so a lot of people are working at the raw level which is not usable it's error-prone unless you go at it with a clear abstraction and just adding threads is a recipe for recipe for a mess and it won't give you performance benefits necessarily so what you're kind of expecting the evolution of the language is that you rise through the levels unless your claim is we are a high level programming language just targeted to make all concurrency approaches easy or the main concurrency approach which is easy and to be very opinionated about it this is what arkham did that in occam you only had channels there was nothing else you could do and you were it was very opinionated you could not share data between running processes if the data was mutable the only way you could share data with another running process running thread is by passing it through a channel and the compiler would stop you if you're trying to do anything else it was a massively opinionated language but the thing is if your code compiled it properly rare c plus plus as a systems program language doesn't come from that tradition but it also doesn't hasn't really risen through the levels i remember at the time we were working on the memory model in the mid-2000s mid to late 2000s i kind of considered that to be a a level zero you've got to get the memory model right and then on top of that you can build the kind of primitive construct the go-to which is thread which is something we have we have a memory model yeah and we have that the next level what i called at the time level two is where you get people away from using that in other words these are available for you but then we have much where and we have a much more a much richer vocabulary we're kind of getting that a little bit but it's been a long time coming it was and i wanted it to be there in the beginning asynchronicity [music] of these constructs that basically mean you will not have people passing pointers to shared state between that has been very slow in coming and my original hope was that was all going to be present originally i even had a threading proposal you know in the mid-2000s which was future based and got took the idea of threads and said let's make this a function based concept and not the way that it is now it was much richer it was a higher level approach i mean i'd still make it even more high level but it was based on the idea of fully asynchronous execution pasting futures around with a possibility of doing channels and that is not the path that we have taken so i think from the c plus perspective c plus is very capable it allows us a lot of this access but it has not added at the higher level constructs at the right rate in a way that makes people's lives easier and so therefore i would say the higher level constructs that's what i would like to see i would like to basically have it so that people are not sitting there worrying about thread pulls and stuff like that and basically saying i just need this executed you know asynchronously and here's the channels we're sharing and this is a long way beyond async as it stood proper continuation model all of this kind of stuff that would have made that would have made i think c plus plus a much a much more different language to program in from a a kind of concurrency perspective i'm i'm actually kind of happy that we didn't like try to synergize the c plus 11 perspective on this because we probably wouldn't have had the needed representation in the committee from other sources of concurrency was gpus etc yeah and that's a very yeah and i think you're right there because there's a whole load of other stuff there as well right i mean exactly at that at having a framework which does concurrency and parallelism with algorithms and everything in the seedless past world but which just not like says well it's that's that's threats of course but you can have of course another concurrency targets yeah the parent a lot of the parallelism stuff again has come from a different route and you can look at you know you look at the parallels and stuff you look at the threading stuff the the parallel algorithms look very different they feel very different i don't think they're mutually exclusive but they're not they don't they don't spring from the same source but in terms of kind of like more classic mindy multiple instruction multiple data i did i i do wish it had been more opinionated i do wish there had been more high level stuff i would have gone for something based on my personal preference is for futures and channels that's what you know that's kind of way i tend to think and i found that's a very useful way of working and that could have been in there from the beginning but it wasn't and we are making up times slowly with that i remember at the time there are a lot of exciting ideas and possibilities i know i remember herb had a whole load that would have been really cool for composition in other words really to try and think about this in terms of composability threads and mutexes on their own are not composable and this whole idea of being able to just bind things together in a very natural way with a fairly with a very high sense of comfort and safety that that's what we kind of that's what we should have threading is unnecessarily hard the way that we've got the the c legacy and the c plus legacy of how we think about threading has made it unnecessarily hard i feel indeed um