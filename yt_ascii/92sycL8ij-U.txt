we're going to talk about git and this is to do with version control protecting your code working as a team but these are all things that involve using something called git which is about storing your your code safely somewhere so we should start by thinking with what is git for because there's a range of things that could be used for companies use git to manage code across loads of people you can use git for as like a remote storage to keep it safe so it's not on your laptop which we'll talk about you can use it for versions of your software but really in all of those cases what i see get as being for us for protection it protects your code from yourself from other versions messing up or from other people messing up your good code when they're collaborating with you so really get is a way to protect code and make it safe and you should be using it for yourself you should be using it when you work with others and you should be using it on projects that matter or just on anything when you might want to go back to something i've heard of github and obviously loads of people will be shouting at the screen right now of course github github but is there a difference between git and github well so github is a online server like set of repositories where you can store your git projects remotely so that's a great github is a great example a website where you can basically choose to push your code remotely so it's not on your computer so it's safe but there's other ones as well there's like git lab is another one which you can use and companies can also set up internal servers with instances of git lab for example and that means that you can have one just within your company where you push to a different computer in your company you could even if you wanted to have your own git lab server somewhere else on a different computer in your house so github is just one of the companies providing git as a service yeah i feel like they're sort of saying we're a hub of git projects you know we're like a place where you can store it but you they also provide lots of other features which could be handy so those features typically the ones that help teams to collaborate so they've spent a long time adding features around git as a storage protocol basically to encourage teams to use it the other thing some people might have heard of is something like svn which is another type of system which is storing versions of your code but we're going to basically not talk about those differences here they're basically doing the same thing different ways slightly but we're really talking about how do you use git to protect yourself rather than exactly how git works yeah we should start by thinking about using git for yourself when you want to use git to look after your own code to make sure you don't accidentally break your code because i'm sure loads of you like me have got to a point where you've been working on a project for a while and suddenly nothing works and you didn't spot exactly when you broke everything but you've made quite a few changes since you last knew that it did work so anybody that is carefully looking after that code is going to be thinking okay every time i do something good make something work i'm going to store it as a period of time in my git repository so i can always roll back to it that's like the main function where you can use git for yourself you're like protecting previous working stages of your code that you can always go back to sort of save as you go sort of thing yeah save as you go virgin history is really useful but to get there you have to do a few things so for a start we're presuming you're working in like a folder on your computer and that folder is like a just a normal file storage and you've got some files in there and git is doing nothing with that until you ask it to start doing something and then when you want it to do something you say okay git init which basically and this initializes git in that folder presume you've got git installed on your computer already which you know most linux based systems have and then what that does is it creates a little hidden folder so you could do this by showing the contents of your folder including hidden files which is ls minus a on a mac for example on a linux machine and that will show you there is a new folder now in your folder which is called dot git and it's all hidden there doing a series of jobs that you don't know that's happening it's kind of i see it's like a magic folder that is looking after all your code for you and you could go into a whole video at some point where you look into how that dot git folder works but it's essentially storing histories of everything you're doing in that folder from now on but it's not quite ready at that point you then have to do something else where you say okay i've got some files here i want to tell git to manage them so what you do then is a git add and then the name of the file that you want to put in and then from that point gets like okay i know about that file now from now on i will always look at it and i will track its status i won't do anything unless you tell me to but i know it's there so you could mean what you can have is some files that git never knows about never looks at and some files that git is in charge of and that's really handy for example if you need to have like your own personal access token to a server you have that something that git doesn't manage only stays on your computer and then your other people working on that same project have their own ones that get never managed but then you ask it only to manage the files that you think are important i always consider git being like the sort of robot that is managing your files on the side keeping records of them updating them if you ask it to it's basically your your little servant robots keeping version of your file safe when you ask it to so then what you have is this special area that git knows about an area that doesn't know about and then a stage in between which is the staged area which we're going to also talk about so maybe it's handy to look at the the example folder i've got here on the ipad so this is if we expect that the white area on the ipad is a folder and when you do git init what happens is it creates basically three sections of that folder is the way i look at it a section that it does not care about which will be here on the left so let's say call this normal and then a git area that gets in charge off so i'll put this over here is the get area gets air is bigger is that just so you can draw yeah more space me to store stuff in this demo and then there's a staged area so we'll call this staged so what happens is when you first create a file i create a file in there and make my files green just represent as a box and i'll call that version one at this point git doesn't know anything about that because you haven't told it about it so to get to know about it all you have to do is type in git add file one or the green file what that does is it says okay from now on i'll put this in an area that git knows about at least it's begun to see about it's not in git's history yet but get knows about it there if i had another file git wouldn't know anything about that and i could play with get as much as i want and get whatever touch it so you have to do this git add and then file name to make it start to play with it so then when you've got maybe a couple of files in there and you want get to store that as a point in time what you then say is git commit and if you do that what i'll do is i'll take all the files that are in the staged area which is all of these now and it will put that into its history or start to put into its history what it will first do is say please can you type in a message to describe this point in history so that will pop up an editor which you can configure to whichever editor you want but it will pop up that editor and it will you just type in essentially a message that represents the current state and there's all sorts of advice on what that should be companies have policies on what that message should be for every state that you decide to save but for yourself it could be whatever you find helpful but then when you save that message it then moves everything over into the history and then puts the message as like a little label up here and then gives it like a special idea hash code reference essentially for that point in time so the files you see because that's the most recent one and the files you see in your folder are going to look at those files there but you can start to make changes so then what you can do is you can say i want to add to the second file this is where it starts to get complicated so i want to make an update to file two and you're working on that on this area which has not not been told to you by git yet get sort of knows it's there let's do point one there we go okay so then to get get to store that for you you have to say okay i've made a change to a file and these are files i want to store in the next history point so you then say git ads and it will take this and put it back into the staging area because you said i want to add this to the next point in history that i'm going to store and so now when you say git commit it's going to commit again the things that are in the staged area so then you type in git commit says okay do you want you need to add a message to that again so it pops up the editor you add a message and then once you've added that and closed it it then moves that into the next version of history so how this looks is you'll have this here you'll have another message you put in there like that and you've now got two stages of history inside kit so what this means is you can actually access any of those stages in history again if you want to so there's a few interesting things you can do but if you ever want to see what your history is you can first type in git log and that shows you and we've got a separate view for this that shows you a kind of history of all the things that you've done so you can go back to any of those times in the past so what you need to do is you need to take a list of those messages is it yeah so these this is like a list history of the stages that you've saved messages so these are the messages i put in like hello for the very first one made a new change for the second one and then new file so you're basically asking for one of those stages in history back so what you can always do and it will warn you if you do this but you can do it if you need to you can say git check out and then the code that you got for this special item in history that kind of hash reference and what it'll do is it will take that point in history and bring it back to being the current files that you see and then you could read from there what did i do where was i you potentially take some copies of files if you want to store them somewhere else and then you can go back to the current point in history by checking out the code of the most recent one instead so what that's doing is it's changing the files that are in your folder so your folder no longer is like a view of your current files your folder is now a view of files in a state of history which might be the most recent state but it could be any states in this history is it literally like get this kind of pasting those into your normal view so you can see them but it saves all the rest of it yeah one really fun exercise actually is to make a file save it to the git history using git commit make a file add it to the gesture make a file add to the git history and then just have a view of that folder open on your screen and then in the terminal check out each of the stages of history and you'll see it just adding the files and taking them away and adding the files and taking them away and that's a really kind of clear way to see that you are switching between stages of history and your view of your folder is always a view of a stage of history that git is managing and you're just choosing which state of history you want to view one of the problems with checking out previous old versions of your history is that you can't really work on those and switch back very easily so one thing they always recommend is you can create something called a git branch now to make this confusing you're turning your history which was linear until this point into a history that has a branching point that you can switch between which maybe we don't need to worry too much about but you can essentially say so the first thing you do is you type in git branch and that will list all the branches you currently have and that will probably just be until you've done something complicated that would probably just be the master branch which is the one that everyone works on by default because they haven't made a policy for anything else companies don't let you tend to do that but most people are just working their own projects on the master but say you wanted to get a copy from your history but not disrupt your master branch what you can say is get branch give it a branch name like when it used to work it could be the name you know whatever you want it to be and then you can and then give it the code of that point in history the hash code from that point of history and then what it will do is it create a branch from that point in history to the side that's called when it used to work and then you can get check out when it used to work and that will switch you to the point of when it used to work now all your files will show what's on that branch which is a point in time when it used to work but you can just switch branch back to your master so this is kind of an easier safer way to go back to a point in history and see where things work just by putting that point of history into a branch so that's all well and good if i'm trying to manage what i'm doing but i'm i'm guess this gets used across organizations with multiple people and things does it yeah so that's kind of challenging and one of the things git will do which we can talk about in another video in the future is it will always tell you when you've edited code that someone else has edited and so this is a really handy feature protects code from other people or protects you know you from damaging other people's code that works because sometimes you're working something you make some changes and then you think that's going to be great and then you would you know commit them to the project but really what you've done is broken something else that someone else has done or some someone else has edited the same file on the same day and you both commit at the end of the day and it's going to start you know conflicting so git will always say hold on a second you know there are multiple changes here and if it can do it then it will just merge them you know if you've changed one file sometimes it's changed another file git will just you know put them both in to say hey everything everything was fine you know no conflicts there but if you both edit the same file it will say okay before i will let you put this in you really need to tell me the correct way to merge this because it's it needs human intelligence to merge it safely so it will say here's the bits you made here's the bit someone else made delete one or the other or merge them whenever you do and it will only accept it once you've kind of merged those bits and removed any metadata ads to it so it's really clever at protecting you and saying you can't do that until until you check out what happens and one of my favorite exercises with students is to make all five of them try and edit the same file on the same day during the lab and that's when they get to learn this kind of a process of of working together and understanding other people's code changes and how you're going to affect them how you can use github is is to have like all you know gitlab i shouldn't prioritize one company but you can basically use those remote servers to protect your codes in case someone steals your computer or in case you spill water on a computer or in case you delete the entire folder which if you did you would delete the folder and all the contents and the git robot that was managing that code you know it would just all be gone so in case of loss what people do is they like to get push that code to a remote server so there's a few different ways of setting up one thing you can do is you can go to these websites you can create a new project and give it a name and that's all fine and then it will give you an address and so what you then type on your computer is you if you're in your folder with all the files on it you so you type in get remote add a name which most people just use origin and then the address that you just got from that website and what you're saying to them is okay hey git robot there is now some space online that i want you to use and every time i type in git push i want you to push all the changes to that remote location and it will then store it safely up there and that's great that means you can if you if you do lose your computer or say you go to visit a friend or your family and then someone message you saying oh no something's really broken you can always just go on to any computer that has git right and then say git clone that project and it will take a copy of the product down to that new computer and then you can edit the files save them git push and push them back up there and then when you get home back to your normal computer you can say okay git pull and it will pull down the latest version onto your computer and update everything so that means you can work on any computer any folder in your computer you know whatever you want you can always just get the latest version from the server work on that code and then push it back to the server and you always have a safe safe version away from you in the future i mean then we could talk about in another video how teams are all pushing and pulling to these remote servers and that remote server is being the place that all the code comes together for the company or the team or the projects which you can get back to your computer and now you've got a message from this first hop go again set the time to lift two it decrements to one deck again and now now you've got a similar problem on the original ethernet back when you had a shared physical piece of wine