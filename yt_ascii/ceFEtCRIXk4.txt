so just a short introduction about me because some i guess i know most of you already but there is some confusion with regards to kdab kde and stuff and just want to make sure that you know that kdab or kab is a company and kde which this shirt is hailing from is the largest c++ open source project in the world so so a lot of people came to me and said thank you for working on kd which is awesome to hear unfortunately it's a little bit depressing because i kind of feel like an impostor because i'm i'm not as active anymore inside of k so it's kind of like living on the old fame that some existed at some point and i don't want to take the kudos from the people who deserve it today so i would say if you want to thank anybody about kd just contact the whole kd community and say thank you so apart from that i guess you know that i wrote a random book that nobody read i'm also a trained although it it it has been translated into a lot of languages so i have a huge huge potential audience potential apart from that obviously as almost everybody here i'm also a trainer consultant i am kind of inactive in the working group 21 etc etc so this is my 10th year speaking at meeting c++ and i feel old i feel really old and worse for there so i found one of my favorite albums and i wanted to show it on the screen so too old to rock and roll too young to die so this is kind of how i feel at the moment my first talk at mt c++ was called monid in chains and to be honest i've never expected it to be accepted at a conference and it was the most involved one so the most difficult to follow and kind of it went down heill from there every talk was i heard that there are not bad talks but they were simpler and simpler and today's talk will be the simplest of all for two reasons first everybody is tired including me i'm kind of in a jet leg mode and this as a keynote needs to be let's say for a wider set set of people than what i usually am for i usually aim for for people who have been in c++ for a lot of time and they might have their own opinions on stuff and they want to learn just a specific topic today we are going to be a little bit more broad and a little bit more shallow but i still hope it will be useful now apart from this fitting my my mental state it's also a band that belongs to an let's say a type of rock called prog rock or progressive rock so what is a prog rock prog rock is a broad u genre of rock music the style was an emergence of psychedelic bands who abandon standard pop traditions in favor of instrumentation and compositional techniques more frequently associated with jazz folk or classical music and if you remember the name of the talk the talk is called prog c++ so what is prog c++ prog c++ is a broad genre of c++ code the style was an emergence of psychedelic developers who abandon standard cid classes for something really strange like generic functional or value based object oriented coding pri practices now i've specifically written value based object-oriented coding practices because we are not java okay and as usual i don't want to break traditions in my 10th 10th year so i always start all the presentations with one of my favorite quotes by not really by phil vad make your code readable pretend the next person who looks at your code is a psychopath and they know where you live now for a full disclaimer i did hear phil wadler say this sentence but i'm 100% sure that he's not the author of it he he just repeated it so i'm not lying by saying this is phil wers but originally who knows who who wrote it maybe a random person from the internet and the second part of the disclaimer obviously if you notice some errors in the code on the slides it's to be expected this is slideware this is not meant to be a production code i'm going to use undor t suffixes for let's say user types and i'm going to assume that using sd string literals is all only presentes because it's nice to write strings with quote quote s so let's start with the first small topic if you are following the standardization committee you have seen that there was a meeting in vanna which i guess many people including myself ignored because who can reach vanna from a normal part of the world but they missed a huge opportunity the opportunity was to organize the meeting in something that's called a constant obviously i'm mispronouncing the name of the of the city a little bit north from vna but i'm doing so intentionally constant is one of the most important things in c++ so i'm proposing whoever organizes those things for the next meetup to be in the constant in romania so let's start with constants this is something that we often write if because we have been thought that const by default is a good thing so let's create a person that is going to be an immutable person called martha jones who knows where the name martha jones is from doctor who one of the better periods of doctor who so if you see her name u just think of doctor who now usually this is fine unless we need to make some customization to the object and let's say we trying to assign a new value to some member variable inside of the person and we just say bad hash equals something now we've lost the most important thing that we had in the previous slide and that's the con keyword so we kind of destroyed the idea okay we need to be cons by default just because we need to tinker a single thing and in the whole function afterwards people can just mutate martha as much as they want and people are not mutable so one of the common idioms in a lot of languages so not only c++ is to create to use a lambda that is evaluated immediately and you just create a lambda you call it and from the lambda you return an object inside of the lambda you can manipulate mutate the object as much as you want but once you return from the lambda it's assigned to a const variable and you cannot mutate the object anymore is this fine should be okay now just imagine that you don't really need martha for every single dr her episode you just want to have martha when you actually need her you don't want to pull her out of her i don't know what what the actors called that little house where they prepare so you can just replace the auto with the super new keyword in c++ called lazy and when you replace it with lazy the rest of the code doesn't need to change in essence as soon as mara is actually needed then this lambda will be called and you'll get mara obviously there are a lot of confused faces this is a huge lie we don't have a lazy keyword inside of c++ but fortunately enough new newer versions of c++ allow us to define things that will end up in code like this looking like they were just normal keywords lazy is nothing more than a normal class template which accepts a function as its template parameter so the fact that we don't need to write lazy off something that's the class template class cad look up the what is abbreviation for see the class template argument deduction okay and so if we pass it to lambda it will automatically be used the type of the lambda to deduce the type name of fn now inside of the of this object called lazy in order to be let's say good citizens like all things in the standard library we should define what the value inside of this lazy thing is going to be so we are defining a nested type called value type just like std vector just like std optional and all those other nice classes or class templates and we just we need to implement a way so that the first time we need martha we initialize her and every other time we just reference the old one so kind of like singleton but we can have multiple of these lazy values for the same internal type so we need to obviously to store the function itself and in order to be let's say thread safe if you need that for implementation of lazy we can just use the on flag and if it didn't initialize anything yet we'll have an empty optional otherwise we'll have ma inside of the optional now when we try to convert the lazy value into proper value for example through the cast operator or conversion operator we can just say call once and this will be thread safe way that guarantees that martha will be instantiated only once however many threads are accessing the the same object and after we managed to do that we just return the reference to martha so whenever we talk about const objects they have two phases regardless of the the way that we use to construct them so the first phase is we are building the value during the buildup the object doesn't need to be con the first let's say rational why we are allowed to change that object while we are building the object nobody else sees it it's just our object when we finish building the object then we can give it out to the world and we are giving the object to the world as a const one okay and then obviously since nobody saw it before as far as the world is concerned the world just sees the final product and the final cost object and then obviously using the value is the using the const const object so just like we have almost always auto we also have almost always const you should define things by default as const con unless there are some issues so the first thing that you don't want to define as const are member variables the reason for that is that you're going to disable move semantics so move operations like assignment and the move construction then you don't want to make local variables that you're going to return from the function as cons because on if the return value optimization doesn't happen then it cannot be moved from from your function into the color and the last one if you have a variable that you want to pass in to something else so for example you have an object you no longer you don't want to use it afterwards you just want it to move to somebody else you cannot make it const as well and i don't really like having rules that say but i want to have rules that say always do this this so can we make something that will behave like a con but still be move enabled without changing the compiler and changing the standard just like we did the lazy object we can create a new rapper and obviously we cannot use the keyword const but we can invent a wrong called immutable inside of immutable we're going to have a member variable and as we said we don't make member variables const so we are following the rules that we've seen before then we create copy operations we create move operations equals default equals default equals default we don't need to do anything special here the only thing that needs to be special we can define the accessors and all the accessors need to return const objects so const references or con pointers okay so even if the internal variable is not const you can use it only as a const from the outside world fair enough now the only situation where i would say it would be perfectly fine if you removed the const is if this immutable object was a temporary so our value reference and not an l value reference so which means that make everything con except variables that you want to give away so if you have a temporary object we are never going to look at it inside of it ever again whoever uses that object can just pull out the value that object will never be looked at again so as far as the world is concerned it it hasn't changed and you pulled out a value that afterwards you can convert to const so we can we have created a nice repper that we can now by default use everywhere that we want so the almost always const can just be switched to always immutable so for member variables declare immutable of sd string instead of con string it will have the same semantics without having the move operations disabled for local variables that you want to return again by default return value optimization will happen if if it doesn't happen because of some conversion some complicated code inside of the function then the result will be moved into the coler which again doesn't work for const but it will work for immutable and the same thing if we have a local variable that we want to move to somebody else again we wouldn't be able to create it const but we can create it to be immutable and the cool thing is that well we cannot write con per person something we need to write con auto person something for immutable c++ is even nicer and we can just say immutable person instead of auto immutable person or something like that so in some situations we even get a little bit of a better syntax questions so far if not we can move on so we we have extended the language to have two new keywords one keyword is lazy and the other keyword is immutable and they're kind of used in a similar way immutable needs just added parentheses to cola lambda because it accepts a value and not a function and lazy just accepts the function now obviously if you don't care about immutable functions you could say if con xer if it's a function then call it if it's not a function but a value then create immutable of that value so that you could also remove the parenthesis at the end so one of the things that i would like you to remember from this talk is that it's fine to implement things that go against the language when the language is insufficient or wrong for your use case or domain if you remember the keynote from the last year nico had huge problems because views from the rangers library are shallow const and a lot of people from the standards committee think it's fine because it's the way that references kind of behave in c++ they're not deep cons they're shallow cons so it's a let's say a valid excuse for the range for the views to be const views but still allow you to change the objects that are below now if we follow followed that the c++ behaves like this so in the standard library we don't want to do anything against that we wouldn't haveed invoke which says okay language doesn't allow us to call member functions with the parentheses so we are going to add something in the standard that circumvents that we wouldn't have unique pointers because somebody could say that new and delete exist in the language and unique pointer doesn't behave like new and delete but that's not the point the point of the library is to create something that is safer especially if you see that the language is lacking in in a specific place so immutable fixes one issue of con so it's perfectly fine to create something like that now the next section is something that as i said i'm growing old and people when they grow old they kind of get annoyed by everything so i guess half of the audience understands what i'm talking about right so when you're young you're energetic you get a code review and you're like happy okay this can be better this can be better and when you get old it's just get off my loan right so if somebody makes a mistake that you hate seeing after 10 years of meeting c++ for example you will get annoyed and this is one of the idioms that everybody knows about that is documented in lots and lots of books and wiki pages and whatnot and everybody does a custom thing that is unrelated to what i'm going to talk about and i really really hate when i see a custom implementation of the following thing so we've had the assignment operator in in a few slides before but and it was completely fine to say equals default because we just had a single variable inside of that type now for persons they usually have me more than one me member variable so for example a name and a surname and if we want to update the name and the surname of a specific person and exception happens in the let's say in between the assigning the name and the surname we'll get half of an update which is not a good thing and i i assume that everybody agrees so if we get an exception between two member variables being updated we'll get an object that is half updated and half not if you want to be on the safe side you should either have a fully updated object and no exception or the old version of the object and the exception and the idiom here that again many people ignore is will be called copy and swap but this is still not it you create a new person you initialize the values that you want it inside and you just swap it with the current person quite a trivial idea and again most of the people don't want to use it for some reason now in the we obviously need swaps for all of our objects if we want to use swaps so there are several different ways to define swaps but let's go for the old school one as a friend function so friend void swap left and right how can we swap two two things we can just say sd tie to put all the member variables inside of tople of references for the one object and for the other and call std swap because obviously topples support swapping and this is not obvious this is just from recent c++ standards this wouldn't work in c++ 11 if i remember correctly but since we are in the future then this is perfectly fine code now you've probably seen std tie used for operator less than and similar ones it's quite useful for swaps as well so in order to create the full edum called copy and swap this is something that always should happen inside of the assignment operator and this is the only valid way to implement the assignment operator what we are doing here is we are creating a temporary copy of the original object that we want to assign to the to this if an exception occurs it will occur at that stage if the exception occurred we just going to exit from this operator the memory will be freed and the object will be unchanged if this thing succeeded so no exception was thrown then we call swap swap is always no except if you implement it correctly so it will just flip the temporary object and us and we will become what the temporary object was when we exit the function the old values from us will be destroyed and we will have the new values inside and this is perfectly exception safe code so proper safety either i have updated fully so a transaction or i haven't updated at all the mve version similar as the previous one just with one std move edit so in just in the case if my moving on the stage didn't communicate what happens clearly enough if you want to assign this circle to the object with a square we are creating a copy of the circle we are swapping and in the end we have just remained in in ourselves we have the new value so the circle now there is one little detail what is the prerequisite of the copy and swap to work you cannot have references as member variables this is one of the most annoying things that i've seen in past few years is that even if people know about copy and swap and start implementing things with copy and swap because it's safe but they kind of want to optimize a few parts and create references directly to some data that will be used often what will happen if in the copy and swap pedum if you create a reference like this first creating a copy will mean we are creating a temporary object that references something from the original one okay the next step is a swap now swap on references doesn't swap the pointers it swaps the values so even if you have created a copy you're referencing the original object you're not changing the pointers inside you're going to change your reference the value that your reference points to with the value that this reference points to so you kind of end up with essentially a double swap for for for a few things but you usually you end up with undefined behavior so member variables should never be references it's better to create them to be even rle pointers than to create references if you really like references then you can use sd reference rapper so member variables if you want to be good people who create values you should always have values to be member variables inside of your types then your type will be somewhat of a value type so additional thing that i think that copy and swap is useful useful for is that the idea behind it is not only tied to the assignment operators swapping is everywhere in our industry so if you work with graphics the first thing that you're going to learn is about double buffering what is double buffering i'm showing you something then i'm drawing drawing drawing drawing drawing you don't see what i'm drawing and then when i'm finished when i have the finished object i just swap these two okay a similar thing if you have one thread that collects some data collect some data at some point it wants to pass the data on and it's not a contigous process so it's not this thread is producing and this one is consuming but but it should happen from time to time that all the collected data should just be transferred somewhere else then swaps are again a little bit of your friend so one of the examples where obviously we as c++ developers don't care about garbage collection but a situation where this is quite quite often used is the mark and sweep algorithm for garbage collection so what does markin speep do it goes through from the root of object through all the objects that can be visited sets of flag this is live this is live this is live and then at the end it goes through all the object that forever allocated and collect those that should be deleted okay so the first step is mark and after that we just go through all the objects if the object is marked then just reset the flag if the object is not marked then it's it's garbage so it should be delet deleted but deletion is often expensive and you don't want to for the mark and sweep to work you kind of need to stop the world in order to process everything and then when the garbage collection finishes you continue the world you don't want to do deletions during your main application so the the main event loop you're going to slow down the application so often instead of calling delete you just want to schedule it for later or to schedule it for to be executed on a separate thread so instead of having delete we can just say garbage push back for this subject then when this finishes we can continue the normal execution of the program the program can execute without any issues even if you haven't deleted all the garbage yet now the thing that we can do is again just swap create an empty garbage colle collection swap these two now we are going to have an empty garbage collection and we have given the full garbage can to somebody else and we can just continue working and the only thing that needs to be synchronized in this case for a multi-threaded garbage collection is the swap so the idea of a swap even if you don't often use it in our code it's a really really powerful thing just imagine you're magician and you do some trickery and we are all obviously magicians in when we write write code so remember swap if you like sd rotate because of shan parent then you should like swap because of somebody else okay so the next one really important thing states we had this quote already so at my first meeting c++ scott meyers showed one of my favorite landmarks of berlin which i'm not going to mention today because it's not that popular anymore and this meeting c++ kevin showed one of my favorites quot favorite quotes from john kack so a large fraction of flaws in software development are due to programmers not fully understanding the possible states their code may execute in now we are all learned to fear the undefined behavior in the compiler when we do something oh it's undefined behavior the compiler can do whatever it wants but it's the same for our programs if our program can get into an invalid state which is a state that you haven't accounted for in advance your program is in undefined behavior your program can be abused to do many many evil things so just like undefined behavior inside of the compiler is an issue illegal state is the undefined behavior of your software so if you manage to push your software into an invalid state you should watch for patricia patricia's talks on security vulnerabilities that just needed a little nudge for your program to have let's say one variable wrong so how we do we deal with states in c++ we create classes we create a lot of things inside and as miller said when you create a class or a structure it's kind of a nice bag to put things in and as a new developer comes in they will put even more things in and you just get a huge huge chunk of state with some variables tightly bound some completely independent etc and after a while because we are all serious developers we are defensive developers we are going to add us asserts inside of our functions so if you're implementing a web browser and we are implementing a web page and we have a function called render obviously we're going to assert that dom the document object model thingy is not an all pointer fair enough it's good to put a sech everywhere or throw exceptions now when we've rendered the page we want to execute the javascript so execute event loop every li ui library has an event loop so javascript as well inside of that we also want to assert that dom is not an all pointer and in order to execute javascript i guess a web page should be fully loaded so we are going to assert also that we are not currently in the loading phase then we are going obviously we need to load a page so if you want to load a page the document object model needs to be null because we shouldn't have loaded anything before we shouldn't be in the loading process at the moment and we should not have already established a connection to to the web page that you want to load so we have created several member functions for our type and then we said okay this member function doesn't work in these cases this member function doesn't work in this cases etc is that a single type then if you disabled half of the functions in some of the states should have should that be in the same type obviously not if you have a cat you're not going to say okay this cat can jump if it's orange it can drink milk if it's orange if it's blue it can i don't know walk or lie on its back and if it if it has wings it can fly if it has wings it's oby bird so it's not the same type as a cat and the same thing goes for all of these things and this is something that we commonly write myself included a lot of projects will end up with huge objects that you just disable some functions in some situations apart from that obviously you can easily get into invalid states if you have that many asserts in your code it means that your type the type that you design allows you to be in completely invalid states so instead obviously we should use something like we should create different types so we need initial initial let's say object which will just contain the url we should have the loading one which will just contain connection and the document object model and once we've loaded we just need to have done all the member functions that we've created so far will just end up being member functions of these three objects and this is no longer something that is runtime checked this is now compile time checked if i have loaded then i can execute javascript and obviously we just need to put everything inside of a variant for this to work i guess you have seen how to visit variants quite a few times during your lifetime so i'm going to skip this one and skip this one unless somebody sees a potential issue in the code maybe not really this code but the code that can become after this one evolves a little bit what are we doing here so if we're in the loading state we are switching the state to load it or whatever does anybody see something that could lead to undefined behavior compiler undefined behavior yeah sorry okay i didn't yeah get if is going to yeah sure sure sure okay okay so syntactically wrong but let's damn yeah slideware this is an arrow but it's it's a small font so you didn't see it okay that's a good comment so in the previous one we have a dangling reference in this one we have a dangling pointer what's the reason we have the current let's say a square inside of our variant we are creating a reference or a pointer to that square and we are changing what is what is inside so we have a reference to the old object or a point to the old object obviously this code that was in the slides apart from the syntactical problem problems with rendering is perfectly fine because we are not using those references we are not using those pointers so we are not going to reach undefined behavior but in the future somebody could just extend this handler and add something that is going to use the reference or a pointer so instead we need to fix the issue if we want to be future proof completely then we going to get get again swap so we have the old states somewhere then we create a page t which is a new page it can be copied it can be just an empty object and then we generate a new state when this new state is generated we still haven't removed the old object from the current state so all the references all the pointers are still valid and once we get out of the overloaded std visit or the if u get if after that we just call swap and only at that point we are going to get the switch once all the pointers and references are out of the scope so for example with the get if we would just say new page equals loaded t and after we exit after all the references and pointers are out of the scope then we do the swap and we are fine so again swap is a really cool and simple algorithm now sometimes you don't want to update the state so maybe this is not generic enough if we don't want to update the state then we don't want the new page to actually contain anything so we want the new page to be empty how can we create a new page that is empty and we can check whether it's empty or not optional optional so if you want to have this optional of updating the state you just create optional new page and if you actually put something inside then do the swap otherwise just ignore and this idom is now perfectly safe you cannot reach any undefined behavior inside now if we talked about variance obviously we need to talk about expected but i'm not going to repeat the talk from the previous year i'm just going to remind you what expected is so again kevn mentioned n minus ones for special values etc in order to communicate an error we can obviously use whatever we want in c++ the new and the cool thing is the expected so the expected is a class that can can contain a value or it can contain an information about the error that happened and the reason why the value is not present and it has some really really cool and useful member functions for which if you want to to look at them i don't usually reference myself but the my talk from the previous here was amazing so you should probably go check out that one instead of anybody else's talks and yeah people did talk about expected but not as good as i did thank you okay so the thing that i mentioned back then is that if you like the semantics of exceptions but you like expected because you're not allowed to use exceptions inside of embedded environments obviously you can abuse core routines to to kind of simulate the same thing so if anything that you coate on returns and error you just drop out of the current function and return that error otherwise you're free to use that value so in the first line we say as string input is called weight of get input if get input returned an error the whole function exits just like with exceptions and if the input was properly generated then this sd string input will have a proper value and we just move on to the second line now again this is again cool and nice and everything else and some people even proposed something similar but a little bit more powerful well some people herb suter for inclusion to the standard called commonly referred to as herb herb setion or something like that but all of these things share as far as i'm concerned one flow even this one if you want an implementation for co on something like expected you can check antoine's u really nice blog post u you have a qr code for for the direct link for to that one so again to abuse kavin's analogy from a few days ago while we are making lunch we make mess this mess is not a problem as far as c++ is concerned we have d structors so all the mes that we create while making lunch will automatically dis disappear because of the constructor the issue that c++ has is with when you get a lunch burnt so you're making rice and it gets a little bit sticky on the bottom and a little bit darker than the rice usually should be what does the c++ do okay throw an exception and which means essentially forget about making the lunch destroy the kitchen and move on and this is not the way to handle errors just imagine anything that you tried in your life and you failed on on the first time okay i i i'm off that's not something that we should well we we do often but it's not healthy so usually we try to find a fix in the situation with the rice obviously take a clean pot pour all the rice that is not burned into the clean pot and continue making lunch no need to destroy the apartment and obviously after we found the fix then just continue process so the choosing of the fix is not on the algorithm that is been called the algorithm can offer you approaches do you want to stop making lunch do you want to use a clean pot do you want to use the burnt rice for tea again maa or you want to do something else with the burnt r and then when you decide you tell the algorithm okay continue with this choice apply slide this is not something that is possible with exceptions nor with coate nor with any of of the previous ones but again this is completely normal interaction between humans and this is my gorgeous attempt at drawing humans obviously i didn't go to an art to art school but let's say this kindle looks close enough so if you know the the song from the sword in the stone again who knows the song and the cartoon or who knows the cartoon yeah only old people so for the young ones please google this it's one of the nicer disney songs from from the old era so it's two and fro stop and go that's what makes the world go around and if i remember correctly the authors of the song are wisman brothers and just like cavn says that shakespeare created memory management and so on wisman brothers created coroutines so we have two cortines we go to and throw and each of the coroutine just stops and goes stops and goes and that's what make the your program go around so when we want to communicate between those those two people we would just create either classes or again variants of different messages that can be communicated to and fro so for example if you're parsing so no longer cooking rice we can have a number parsing error we can invalid type error on one hand side and for the fix you can have use zero instead of whatever you passed or skip the current line just for an example usually you will have a little bit more elaborate things with variants of different types so this picture that we've had just forget the sticky figures and think of functions these functions would be called coroutines and you have seen this picture just with functions a dozen times on previous conferences that talked about coroutines so a communication between two entities so if you want to say what a message is we would say a message is either an error message so the one direction or fix message which goes into in the other direction now we can create we can say a result of our cor routine is going to be either the result so the value we have part some passed something success successfully or it can be a message containing an error so we can just say okay result is going to be expected of result and message t pointer we'll see why it's a pointer a little bit afterwards and then we can just create our par of function not as something that returns expected but it returns generator of these expected what does this mean this means that the same function can return us an error multiple times just like a normal person and whenever you hear a new error that occurred you can say okay try this new error okay try this new error try this if all of those fixes succeeded you're going to end up with a result if you find an error that is not rec recoverable then you can just say okay by this time i really give up i cannot parse this file okay so we are going to create a message which will be essentially communication channel between the coroutine and the caller and any time that we find an error we're just going to co yield an unexpected value and with an error inside obviously i intentionally implemented everything without creating custom types just by using std generator so that you see what so that i don't hide anything as a magician does obviously if you were to implement something like this i would advise you to hide all of these ugly things like std unexpected std address oft message into a dedicated object so don't use the generator directly but let's say create a wrapper on top of generator which provides you with all of these now in the situation on the color side we have call eight pars the first time that we don't get a result we are going to propose a new fix the second time we don't get a result but in error we going to propose a new fix so we have a v true and in the situation where we got a proper result and not an error we're just going to exit out of the v loop because we have success successfully passed the whole file so coroutines while we usually talk about them in the terms of asynchronous tasks and y other can be quite useful even for much more nuanced error handling than exceptions allow us than anything that c++ already has allowed us ever in history obviously i'm lying but i'm trying to sell you something any questions so far something online yeah i'm looking into the online questions so regarding the usage of aert coming from an embedded software background i'm told by many experts the search should be avoided and embedded systems a quick google search now i see funny there is a contradicting suggestions use do not use on a depends what are your thoughts about asserts and embedded okay so i hate asserts as much as the next guy and use them as much as the next guy i completely agree and that's one of the reasons why i i think that the code that we started with before the variant stuff is full of codes smell as soon as we have that many asserts we have designed our types in a wrong way so i would completely agree with the comment that that that person had okay and i would say this is irregardless of whether it's embedded or not obviously for embedded you have killed a dozen people in an airplane for for a desktop you kind of forgot to save a file different different problems but the same cause anything else and el yeah one simple question why are you passing a pointer instead of using the return from the coy yield yeah i kind of kind of wanted to to skip that to skip around that so we need to have the communication mechanism and in order not to talk about how cortines work for i don't know 10 10 time on all the conferences i've used the most what's the expression rope and stick solution that i could could imagine so cortines can communicate in an official way between the color and the col but if even if you don't know a single thing about coroutines we can simulate that by creating a variable on the stack and just passing that variable to and fro from the color to the col now again it's a little bit of a risk to pass a pointer to something on that that looks like it's on the stack but this is in a cortin frame which will exist as long as we are co yielding co yielding co yielding from the result so it's still memory safe even if it doesn't really appear to be so y one more question for the problem you mentioned for object construction how about default initializing the member variable in line in the class and so every person object is different not sure i get the point yeah neither am i [laughter] so i would welcome an email or something like that i i will gladly gladly respond actually there's another embedded question can we use the co- routines and expected embedded with a with an allocator inside the promise so we don't use he allocations there are a lot of talks about coroutines and that question appears every once in a while a lot of things can be achieved can be used and embedded with a little bit of hardship but again that would be a little bit of a huge digression for this st but i would again send me an email i'll cadly point you to some of the people who exactly talked about the same the same ideas before sure all right let's carry on okay okay so again if you hate this syntax just wrap it inside of a type if you even hate the local variable message then invest several days into understanding how cor routines work again from the past year there were really nice talks two of them i'm not going to mention phil nash because last year i i mentioned the other guy and i don't know whether ph got offended or not so i'm going to mention him this time so phil also had a really great talk about cortines in the previous meeting c++ so check out both of those and you'll kind of get some vague idea that you don't want to deal with cortines but use the already implemented things like std generator okay so as far as the errors go once we really have a value so not an error we can just say co yield the final result so the main point of this ideum would be so it allows you to continue in the process u in in the presence of errors but it's you can still bail out if you reach something that you cannot handle now the penultimate small section we are going a little bit down down the hill the cortin stuff is usually a little bit more let's say annoying so we are going back to the simpler simpler topics if you didn't see regularly visited talk by victor victor you should again when it becomes available he explains in let's say mathem medical level of details what values are regular is etc and it's well worth watching u as far as i'm concerned i'm not going to use any mathematical definitions of values just use let's say your better judgment until you watch victor talk so the the only thing that i would like to differentiate is between values and variables we usually say value type we usually say value semantics that's not the type of a value is a thing the value typism reference and value semantics are not an entity of values or references it's about assignment so a value is something that the variable refers to a value is number 42 a value is a name martha jones value is not something that you can change to 43 you can change the variable to be 43 and it will point to a different value okay so when people say values when when i at least try to say values i'm usually referring to some const object that is somewhere in the memory if you're allowed to change that object it's no longer the same value okay so if i asked you we have a unique pointer of con something is that a value let's say so whatever that pointer contains currently will point to something that is const so whenever you use it you're just going to see the same value if you have a shared pointer of con something again the same story goes it's a single value nobody in their same mind would probably say that unique pointer is a value type right it's a type that references something but this is a really important distinction one of the notes that i'm usually annoyed with when people talk about multi-threading is that we have that notion that as soon as sharing something then we need a mutex and a good comment from this talk by shivam was that if something is constant even if strictly speaking it will end up with false sharing blah blah blah blah we don't have the problems of that false sharing because no synchronization will ever happen because no data can be changed if you have immutable data then even if it's shared you don't need any mutex so if we have a values and we share values between multi thre multiple threads it's perfectly safe if we have variables that we are sharing across multiple threads variables that can change the value inside that's a problem but we are so accustomed to change all the objects that we have that it's a common thing to say as soon as you have shared resources you need mutexes you need synchronization so just remember if you have mutable shar resources that's the only situation where you need synchronization that was a little bit of a diversion so for values let's say we should have these operations obviously not we don't need copying always we don't need moving always but if we wanted to be let's say good people we should allow several different variables to hold the value of 42 okay so copies should be let's say most mostly provided and obviously it always should be a valid value if something is 42 it's a valid value you cannot have an integer that is not an integer if you want something that can be an integer but can be empty then obviously it's not an integer it's optional of in and then in that situation empty optional is a valid value okay so let's a little bit move on we don't consider really a unique pointer to something to be a value and i said that anytime that we want to be good people and create value types whatever those are we should create only member variables which are value types and in most of our minds this is not going to fit the bill so instead what's the what are the issues with the with having let's say a pimple that's a unique pointer the pimple how many people know about the pimple idium cool so implementing something like this allows you to have first invalid states the pimple pointer can be a n pointer which is not a valid state for the pimpl adum you have shallow con so you get again you annoy nikos after that you don't have copying because you have a unique pointer inside and another thing you're allowed to change what the pointer points to which again is not the pimple idum pimple should just be something that is on the heap which is always tied to my current object and then you end up with adding a few things so on the construction you're going to create an instance for this pointer to pointer which means that you need to patch all the constructors in your class to to initialize the mp pool the second thing how can be solved so the the con propagation instead of allowing your let's say people who implement the rest of the class instead of allowing them to access assess the pimple directly you provide member functions that depending on whether they are con qualified or not they return a const reference to the pimple or they return a mutable reference to the pimple and now you have created something that is kind of like the experimental propagate const so you kind of disallowed the default behavior c++ that const is shallow you have implemented the proper thing if i'm con then everything that i depend on is con for the copy construction obviously again make unique you are calling the copy constructor of the page private t which should always for pin plus be a final class so no inheritance no slicing is going to happen here and obviously the assignment operator you're going to implement with the copy and swap operator now again a small d digression i love those if you have a shed pointer to con private t and we want to create a copy and change the value we have something that is called copy and right how many people are experienced with copy on right not in file systems okay so copy and right is an excellent idea it works awesomely well in file systems and it works abysmally bad in c++ and most languages and usually they're not really needed for us for example in cute library all the classes are let's say collection classes are copy and right and then you have some strange rules saying well if you try to use this with a range based for loop it's going to be slow because it copies the call whole collection but i'm just reading the collection yeah but i don't know that you're creating an iterator to something and you will be able to change it the fact that you are not going to change it nah it's it's not important i'm going to copy the whole collection but that's really not needed in c++ we have a common thing in c++ if somebody pass us a constra to something and we need a copy to change it just copy it you don't need some smart class implementation to think about when you want to this to be copied or not just explicitly say okay i want a copy i don't want the original so in the situation where we have the the shed pointer to a const object that's a perfectly fine perfectly safe thing to have in your program multi-threaded no locking because it's a shared const resource if you want to create create something new out of it you don't want to create a smart api that works like copy on right you just need a a single function that will take that const object transform it into something that you need and then return it a shared pointer to the const new object so in a page so again a web page which is internally just a const thing you can just create transform member function like s the optional has like s expected has internally it's a const then you transform that internal value to create a new version of a page and again multi-thread safe completely safe because we don't have any mutations that are shared across the threads now to get back on the pimple thing we have created a few different things just to fix the issue of the unique pointer with pimples now those issues don't exist only with pimples anytime that you need a pointer inside of your as a member variable and we said we want values unique pointer is going to be bad for you so instead instead of every time implementing all the patches that we've had for for the unique pointer just create a new class template that can be called heap value or value pointer or whatever you want and when you want to create a new instance of this object it will behave as an object on the stack but it will be allocated on the hip model some smaller let's say syntax changes and this should be fairly trival to implement so a constructor that just calls make unique the only note that i want to make here is that the clause needs to disable if you have just one argument and it's the same type as heap value then you should disable this constructor so not to infringe on the copy operations accessors the same as before so const in the if they're con qualified and non- con if they're not and obviously you need to implement swap copy and move operations and the only thing that this requires is the that you don't have inheritance so you should probably insert static assert is final inside of the implementation of heap value if you do want to have inheritance and stru hierarchies etc then you should again go back in time and watch claus's talk on type erasure again really really detailed explanation of type erasure which made me delete let's say 10 10 slides from my presentation because when i saw that he covered everything in much more detail i said like okay kill kill kill kill kill until until i ended up with essentially zero type erasion so that's the reason why for example the shed pointer to con felt a little bit out of place because it was a little bit later in the slides and if you don't want to watch any of the talks you just want already pre-made solutions lon has a really cool library called dino it has a little bit awkward syntax but it's quite quite useful and it allows you to have typ erased objects that have full value semantics like claus talked about any questions for the sections so far again online yes i think we have a question on expected again so expected has and then or else and transform and transform error and montic operations aren't those better than using co routines okay good question i do like those member functions and i would say they are better than coroutines with uglier syntax because you need to pass lambdas and lambdas in c++ are really really verose so if you chain and then transform or else etc you will get with a huge chunk of random characters angly brackets and all of those brackets with cortines you get a syntax that looks more like normal c++ code just with additional keyword inside but again i would refer most of the questions for s expected to the previous years's talk by somebody here so if there are no more questions actually i would there's a cute question i have which is related to copy and right mhm i've been reading line wise into an sd string which is utf8 and then i have to convert that to you to to cute string from utf8 and i figured out that like cute does not set up to reuse a buffer in a q string so calling from utf8 always allocates and gets a new string object will it be possible like to reuse an allocation inside a copy wr object when you only have like one reference in it i would say so yeah usually if you have ref count and the reference count is one and somebody let's say you move to somebody else it's like a unique pointer nobody will access it anymore you can do whatever you want inside okay okay and the last one the most important topic in in the c++ today is the safety and obviously we are not going to solve the safety issues of c++ today but at least i'm i'll try to do some things that might improve the safety of u let's say future programs in the world now most of this talk was about idioms so whe whether those idioms are from functional programming or not functional programming so the progue c++ theom is important for for a few reasons and the first thing is that when you see code like this you know kind of what it does you know what a four person persons is and if you use the person inside of the loop that's the idiomatic way of using the range based for loop if you use persons directly inside of the for loop that goes through through all the persons then you're most likely doing something strange if it's a con access then and let's say we just going to close our eyes and ignore it but if you're changing the person's while traversing over the collection that's a huge no no and obviously not idiomatic code the same thing goes for non range based for a loop so index one again if we just have index something and until it size we increment the index and the tic way to use to use it inside is of index perfectly fine same if you access the index in a const way it is also idiomatic otherwise if you didn't need the value of the index you would use the range based for loop so this is also idiomatic again if you try to use persons outside of persons of index it's not the tic way to use the range bas this index based for loop the same thing goes for the std transform we have result resize because we want to convert all the strings inside of the words collection into integers so we first resize the current vector to be able to fit everything inside all the results and just call transform from one collection to the other collection and use the parse integer function for it and all of these are id idiomatic pieces of code that are not really inside of some higher order function some algorithm etc we have the algorithm to transform here but the resize part is not a part of the transform what are the idioms for the first thing is that when somebody when you are trying to solve something and you have a lot of idioms in your head most of the time it will make you make it easier for you to solve the problem it's kind of like the the pattern oriented software architectures or whatever if you know a lot of patterns and you have a problem you can often fit the problem you have inside of a pattern the same goes with idioms if you know a lot of idioms you will be you will more easily solve something that you want to implement the second thing if you wrote your code in idiomatic c++ or whatever language you're using whoever reads your code will immediately because it's an idiom and they know all the idioms that you do they will see that idiom and they will know what that idiom does they will not be confused by the resize here but the one thing that is usually an afterthought in all of this is safety now as far as the safety is concerned i'm not going to go into defining safety if you want different definitions of safety just check jfs as safety and security the future of c++ from cp nowor he spends a lot of time and it's a it's a really a brilliant presentation because he recognizes that safety is not only memory safety but it's a more advanced concept the reason why i don't want to define safety is that we are all going to differ in thinking what safety is so for example in some languages that i'm not going to mention bounce checking is what provides safety for me bond checking that throws exceptions is not safety there was a research for not from c++ because we never catch exceptions but in java where you are forced to c catch exception so you need if you call a function that is declared i'm throwing this exception you need to catch it somewhere the research was they investigated a lot of a lot of open source code for the libraries they discovered that 40% of all catches are either empty or just logging for normal applications it went up to 90% so throwing exceptions and then ignoring them it's not safety obviously the language is safe it's not your undefined behavior etc your code is in undefined behavior you ignored an error so this dot at on a vector or whatever rust calls it or some other let's say emerging languages for to replace c++ they're not solutions for for the issues they're hiding one issue with just providing okay the user is to blame it's no longer the fault of the language now the user is at fault which is cool ob obviously it's better that the users are to blame than than the language developers but it doesn't really change any effect it doesn't make the code any safer now in the idiom that we've had before bound checking in this idum is not needed the unsafe operation here is index based access of a vector this is mathematically provable that this index is never out of bounds why do i need if i iterate through this a million times do i really need it to go if if this is greater than zero if this is less than size no it's provable that this index is a valid inbounds index for this array now obviously you can get into issues you can get a segmentation fault in this place but not because of this code something might access persons and change the persons and then you're out of bounds but it's not the the fault of this code it's the fault of you first for sharing persons between two threads without any mutexes without any locking and it's essentially the fault of that other code which is changing the persons the same thing goes here usually when we have a destination iterator we are never allowed to say again we need back inserter because it needs to be sure that we that it adds item by item and if you just say dot begin it means okay i'm sure that i have enough space i have enough elements inside of this collection to store all the results so again this is an unsafe operation in this cod snpp it in this cium it's perfectly mathematically provable that it cannot go bad if you use transform it means that the resulting collection have will have the same amount of elements as the source one and we have resized the resulting collection to the same size as the source one in the line above again mathematically provable edom that this is perfectly safe code just like this one without any performance penalties that that we use this not even that we don't have any performance penalties but this will be much faster than if you used back inserter at least for vector of fints or other simple types in the implementation of the lazy type that we've had the only unsafe operation that we could have is the d reference of the optional if the optional is empty this would be undefined behavior can the optional be empty at this stage again no the call one call1 guarantees us that m data will be assigned the result of std invoke so again provable that this is completely safe code without any runtime checks the same goes with with the heap value we are dealing with pointers with dynamic allocation etc but we have provided an api that is completely value based it's just that the value is stored somewhere else obviously it would be a little bit more difficult to to prove all of the attributes for this one than for the previous solutions but again this is easily provable that this will behave as any other value inside of your code now let's see one one more edom that will emerge who has any issues with this code okay so we all know that obviously we should not have loock and do unlock we should replace it with something like lock guard of or unique lock fair enough who thinks that discode is not safe why so new are really fundamentally really hard to get it right okay okay the second answer i liked better so the first one is let's say more philosophical one mutes are really hard to get right and that that one is true as well so if we use this mutex here and forget to to use it in another place then the fact that we have a log guard here doesn't really fix anything but again it's it wouldn't be a problem of this function but it would be a problem of a function that accesses the same locked data from without before locking but the second one deadlocks do you do you see a deadlock that can just occur because of this code obviously with three dots being anything in the world recursion there was recently an article that or maybe a paper for the standard i don't really remember that we shouldn't have standardized mutex we should always use recursive mutexes and that would be a completely fine fix for this deadlock but again recursive mutexes might not be as fast may blah blah blah can we find a better solution so we can use a recursive mutex at all by default or the second option the zen one the action through inaction don't do any locking at all does a function need to lock something because it wants to change it if for example if i work alone in in a room do i need to announce that i'm going i'm i no to the kitchen i wanted to say something else but i remember that i'm recorded we have a small kitchen and i want to go into the kitchen i say okay i'm going into the kitchen and then nobody goes into no if i'm alone at home obviously i don't need to to lock the kitchen right so the function that inherently locks is a function that you expect okay this will be used only in multi-threaded environment for a non- multi-threaded environment it will just be let's say a a waste waste of cpu cycles so a function that doesn't look at all but somebody from the outside coordinates what should be locked or not would work in both situations so for example again if i'm alone in in an apartment and i'm going to the to the kitchen i just go to the kitchen otherwise if there are multiple people we just put somebody on the door saying okay somebody is already in you need a key in order to open the kitchen and until i get the key back from that person i cannot give it to you so what we can do is create let's say a private mutex and a private class that will be called a unique key or what whatever you want to call it then you have a member function called take key so the key cannot be forged by anybody else but this class because it's a private type so you cannot fake the key if you want to get the key if you want to call the function do something you need a key so if you want to enter the kitchen you need the key which means that you need to acquire that key from the refer beforehand and then once you have the key you can go through all the member functions that require that key do we have the recursion problem here none of these functions re do any locking the lock happens when you take the key then the function can recursively call itself call itself and just pass the unique key on to the recursive calls and when it exits you just return the key back now the cool thing about this is that unlike the previous cdms where we had like i i said mathematically provable in this situation this is compiler provable in order to call a function you have that key compiler will'll say just say you cannot this cannot be compiled otherwise so you have compiled time proving of a small let's say theorem which is kind of cool if you can make your let's say idioms to look like this obviously you should always just one last d digression to wake you all up i recently went to japan and we went to a buddhist temple in tokyo near that fish market thingy and the main hall was closed because of some barrial ceremony or something like that and we went into the second or third hall so the prayer room obviously i'm i'm not really a buddhist so i was a little bit out of place there but it was really nice and while we were walking out my better half saw a pamphlet and obviously those pamphlets were meant for tourists to take and take home right but she is a strickler for rules and we were also in japan which is a country that loves rules so she took the pamphlet to a lady that work at a desk and signaled okay can i take this obviously the lady didn't speak any english and she was like smiling she was really really nice then she just jumped up we were a little bit surprised that at that point instead of just nodding somebody stands up and she started walking and we were like okay we just ask can we take this pamphlet home and she did like this and okay we need to follow her and the situation was like in the the meaning of life the last scenes from monty pyon so that waiter takes you through all the england's countries etc and she was going and going and we were following and we were following then she started moving the barriers do not cross opens the door we go through do not cross up and we go we have no idea what's going on and at some point obviously she's still smiling and we are smiling obviously although really confused and at some point she takes us to this small statue of a bll and we were like okay now what so okay it's a nice statue and at some point she pointed to the pamphlet the pamphlet had a picture of the bull on and obviously she understood us that we want to see the bull and she was so so so kind in flipflops and everything else to take us through the whole closed building because of the burial or whatever to see the bull and we were so confused that we didn't even take a picture of the bull this is from tokyo views the only thing that that my better half managed to do is to pet the ball and that was it so really really really strange story but it it was amazing and the bull is is really nice now that they see it on the picture now the reason why i mentioning this is that obviously we were talking about idioms and stuff if you're developing your own idioms please make them correct if you see something because somebody in your team didn't understand the language so they had a language barrier with c++ and think that this is meant to be atomic h because it works and they make it an idiom and then it goes around the world as an idiom no all the idioms that you create should be either backed by standards standard or the mathematics or something else you need to prove all of your idioms in order to use them safely and properly so the benefits of developing everything vi idioms obviously safety what terror safety means to you for each of the idms you would prove the type of safety that you want if you find a bug and you see this is an undefined behavior somewhere you know it's not in the idiomatic code so you're just going to remove all of those things and triage the bugs to to find a place where you didn't use the diomatic code and obviously easier to prove correctness because if we had a doz idioms for c++ or hundreds and hundreds you would already have some mathematical proofs for each of them and then proving the correctness of the code would be easier obviously not easy mathematics is never easy but easier to some extent the downsides obviously if you're allowed just to write idiomatic code it's kind of like development under trying to to carry the the pyramids of giza on on your back a lot more bureaucracy if you want to do something custom you would need to first invent an idiom that covers that prove that etc and the last but not the least if you have a huge code base which is obviously not going to be 100% idiomatic you would need to rewrite most of it in order to just use the idioms now the good thing is that you would be able to rewrite parts by parts and not like porting to a different language where you would need to rewrite the whole project or create ffi etc so it's not that big of a downside compared to some of the alternatives so for the guidelines because every talk should have some kind of guidelines or a summary if you follow the tdd as again talked about by phil you you should also add id which is idiom driven development if you find a bug in your code don't just fix the bug think of an edm which will for which will stop you from making the same bug ever again again not an easy task if you can create a generic function or generic class out of an idium please do so if you can create an idium innovation that it's provable by the compiler like the locking thing is obviously do so for other ids like for example resize plus transform write static analysis tools that will check whether the code is covered by an edm or not okay and that's it for me [applause] thank you any questions the online world asks in the unique key example shouldn't take key return a reference rather than a copy or is it just a case of slideware where basically your code is just you know not production r yeah probably although it can be it's not that important so it in this case it should be a value because inside of that is the proper lock guard it depends on how you implement the same thing but in this case i would say this is not slight where this was actually correct okay so you're you're returning a copy on purpose so it's not a copy it's essentially we don't have an instance of this thing anywhere inside of the class this will create the lock guard on top of the mutex like we normally do and it will just wrap it inside of a secret type which will be inside of the key so it will be a move or let's say return value optimized result and not a copy okay yeah thank you for talk you're on the right slide are you aware of the copper spice lip guarded library have you played with it i've heard about it there actually when i remember it correctly implementing different version of that for different use cases so but h the same i really haven't checked the library i know that they're doing some let's say interesting things with regards to proper c+ plus but i've never had an opportunity to work with the library and i wasn't curious enough to invest my personal time into it lip guarded is basically a separate library and that only concerns about this so it's only implementing the guard part send me email with please hi thanks a lot for the talk my question is about the copy and swap edm is the recommendation to always do assignments through the edm or what's that the recommendation basically and if yes what about the performance penalties you might incur in some some cases okay so i like the question it's not a clear answer if if you prefer safety to performance i would say always if you have situations where you want to allow yourself to have invalid states it's fine but then make guards that those invalid states don't somehow trickle down and destroy your program so i would say by default i would use copy and swap if i detect some performance penalties in the care in the places where i care about then i would maybe think about how to optimize stuff and not go the other way around okay wouldn't you argue that if you have to write a custom assignment operator in the first place it let's say requires its own well consider ation and see how it should we implement rather than going for a generic way i i wouldn't say so in essence all the customization should go inside of the copy constructor and move constructor and the swap is then again generic okay thank you in essence from from his personal history every time that i've seen somebody implement a custom assignment operator it led to bugs so again maybe it's the get of my laan thing but i would rather have the code that i don't spend hours debugging because i'm expecting something correct in the most trivial function in a class okay thank you hi thanks for the talk very nice just wanted to have a comment on this slide actually about the takey approach like i personally don't like it at all so i wanted to ask what was the reon for proposing something like this rather than just some refactoring and following simple guidelines like public function should then call other public functions so if you have the recursive case just put it in a private function you take the look on the public one and you're good to go right so i just wanted to get a bit the motivation behind this short answer this is compiler checked and whether something ends up being recursive or not after years of development is a huge investment to analyze all the cold pass in in the code so that you can do that let's say topological sort mm so i would say again for me compile time something is always better than something else okay okay fair hey cool talk a bunch of those ems do require like whoever is using them to write a bunch of code that is not provided by the standard library right so so i mean this example is one of them you had the e value and then there was something about like polymorphic dynamic typing and things like that do you feel like this is the kind of thing that we should add to the standard or maybe more like there should be a support library so every code base doesn't have to rewrite it or make its own copy it's not a lot of code but it's still a thing you can get wrong i agree i would say just like the overloaded lambdas i would love to see something like that in the standard i would say on the other hand a lot of people don't really have the time patience and anything similar to that to invest into pushing something into the standard so i would probably like the middle approach a common library that everybody likes and uses to be the solution unfortunately you get that into the xkc the situation of everybody creating their own library which will be the one so so whatever happens i'm completely fine as you said this is quite short cod set of code snippets just like overload it is so it's not that difficult for everybody just to copy paste into util do hpp or stuff. hpp in there yeah of course well first and foremost i want to say thank you for the really great keynote that was very nice i i i do wonder like you know if you like to see yourself or other people popularize the term progressive c++ i don't know in ence the reason for the term so i was always jealous for jonathan bk's fluent c++ and some of the people had really nice names for let's say their websites and i spent years developing and market research and everything else for what should i call my website and at some point i call it called it high c++ or something like that so kind of close to let's say hippie movement rather than progressive rock movement so this occurred to me let's say a few months ago and i said okay i'm going to use this so as far as the term is concerned i didn't take a trademark if somebody wants to use it feel free so to do so but i wouldn't say please go go around and popularize okay the next question i would like to have is like where do you see or like is it like idiomatic to contemporary c++ keynote we had last year okay contemporary c++ i like for a general c++ thing the idea specifically for progressive was that again i'm usually connected and people think of me as the functional programming guy but you want to break that m kind of i did i don't want to i never wanted to take the function programming and push every single thing inside of c++ it was more or i'm working on something and i see something that i could improve and it happened that some of the edms were from fp and then people started commenting on yeah but don't do you hate object orient no why why should i if i'm i don't know functional programming aici why should i hate anything else i think that all of those paradigms have something to offer even combined and that's the reason why i ended up with pro progressive c++ okay let me see if there's any more questions you're on the right slide thanks for the great keynote so funny how only this t slide gets talked about anyway you said this code can't be misused if i stood you correctly and i took that took that as a challeng challenge so no the the thing is i've used a very similar approach in our software and it turns out i didn't think correctly or i wasn't aware of this issue so it turned out to have a bug the real issue why this got reexamined was that there was a compiler error with c++ 20 or something anyway the unique key being private doesn't mean you can't instantiate it if you're outside it just means you can't refer to it by name and so with de type you can get the type and then inen but anyway you can you can argue that this is like defined private public so intentional abuse but there's another thing i think that could could happen by accident and i think this is if you have two objects of this class and you take the key from one and then invoke a method on the other and the solution i took was to use a unique lock even though i don't need some of the features because it allows you to get the mutex pointer and then write an assertion that you actually that the lock is actually for the right mutex sure that's a great point so for the first for for the first one obviously yeah in c++ there just in like any law there are holds that we can go through to do things that were weren't meant to so yeah deal type of result of to take key and construct that for the second one obviously true if you want to have multiple instances of this object then you would need to have some kind of an idea as well whether it's a pointer to the mutex or something else i agree thanks i think that brings us to the last question so you're not on the right slide but you don't need to switch do you recommend using copy and swap instead of the compiler generated assignment it's kind of connected to one of the previous ones if you if you primarily care about safety i would say yes if you don't care about exceptions then no okay thanks then to add to that if you prefer even more safety always l value qualify your assignment operators so you cannot assign to a temporary sure well and with that i yeah well final words are yours thank you for the keynote thank you for inviting [applause] me