so today, i thought we talk about generative adversarial networks because they're really cool, and they've they can do a lot of really cool things people have used them for all kinds of things things like you know you draw a sketch of a shoe and it will render you an actual picture of a shoe or a handbag they're fairly low-resolution right now, but it's very impressive the way that they can produce real quite good-looking images you could make a neural network that's a classifier right you give it lots and lots of pictures of cats and lots and lots of pictures of dogs and you say you know you present it with a picture of a cat and it says it outputs a number. let's say between zero and one and zero represents cats and one represents dogs and so you give it a cat and it puts out one and you say no that's not right should be zero and you keep training it until eventually it can tell the difference right? so somewhere inside that network it's... it must have formed some model of what cats are and what dogs are, at least as far as images of images of them are concerned but that model really... you can only really use it to classify things you can't say "ok draw me a new cat picture", "draw me a cat picture i haven't seen before" it doesn't know how to do that so quite often you want a model that can generate new samples you have so you give it a bunch of samples from a particular distribution, and you want it to give you more samples which are also from that same distribution, so it has to learn the underlying structure of what you've given it. and that's kind of tricky, actually. there's a lot of... well there's a lot of challenges involved in that. well, let's be honest i don't think as a human you can find that tricky you know if... if i know what a cat looks like but, uh, being not the greatest artist in the world i'm not sure that i could draw you a decent cat. so, you know, that this is not confined to just computing is it? this... yeah, that's true. that's really true. but if you take let's do like a really simple example of a generative model say you you give your network one thing it looks like this. and then you give it another one you're like these are your training samples looks like this you give it another one that looks like this, and then... what are those dots in the systems? instances of something on two dimensions? yeah, i mean right now, it's literally just data. we just... it doesn't matter what it is just some... yeah, these are these are data points and so these are the things you're giving it, and then it will learn you can train it. it will learn a model, and the model it might learn is something like this, right? it's figured out that these dots all lie along a path, and if its model was always to draw a line then it could learn by adjusting the parameters of that line it would move the line around until it found a line that was a good fit, and generally gave you a good prediction. but then if you were to ask this model: "okay, now make me a new one" unless you did something clever, what you get is probably this, because that is on average the closest to any of these, because any of these dots you don't know if they're going to be above or below or, you know, to the left or the right. there's no pattern there. it's kind of random. so the best place you can go that will minimize your error, is to go just right on the line every time. but anybody looking at this will say: "well, that's fake" that's not a plausible example of something from this distribution, even though for a lot of the like, error functions, that people use when training networks this would perform best, so it's this interesting situation where there's not just one right answer. you know, generally speaking the way that neuron networks work is: you're training them towards a specific you have a label or you have a you have an output a target output and you get penalty the further away you are from that output, whereas in in a in an application like this there's effect... there's basically an infinite number of perfectly valid outputs here but, so, to generate this what you actually need is to take this model and then apply some randomness, you say: "they're all within, you know, they occur randomly and they're normally distributed around this line with this standard deviation" or whatever. but a lot of models would have a hard time actually picking one of all of the possibilities and they would have this tendency to kind of smooth things out and go for the average, whereas we actually just want "just pick me one doesn't matter". so that's part of the problem of generating. adversarial training is is help is a way of training not just networks, actually, a way of training machine learning systems. which involves focusing on the system's weaknesses. so, if you are learning... let's say you're teaching your network to recognize handwritten digits. the normal way you would do that you have your big training sample of labeled samples you've got an array of pixels that looks like a three and then it's labeled with three and so on. and the normal way that you would train a network with this is you would just present all of them pretty much at random. you'd present as many ones as two as threes and just keep throwing examples at it "what's this?", you know, "yes, you got that right", "no. you've got that wrong, it should really be this". and keep doing that and the system will eventually learn but if you were actually teaching a person to recognize the numbers, if you were teaching a child you wouldn't do that, like, if you'd been teaching them for a while, presenting them and you know, getting the response and correcting them and so on, and you noticed that they can do... you know... with 2 3 4 5 6 8 & 9 they're getting like 70 80 percent you know, accuracy recognition rate. but 1 & 7 it's like 50/50, because any time they get a 1 or a 7 they just guess because they can't tell the difference between them. if you noticed that you wouldn't keep training those other numbers, right? you would stop and say: "well, you know what? we're just gonna focus on 1 & 7 because this is an issue for you". "i'm gonna keep showing you ones and 7s and correcting you until the error rate on ones and 7s comes down to the error rate that you're getting on your other numbers". you're focusing the training on the area where the student is failing and there's kinda of a balance there when you're teaching humans because if you keep relentlessly focusing on their weaknesses and making them do stuff they can't do all the time they will just become super discouraged and give up. but neural networks don't have feelings yet, so that's really not an issue. you can just continually hammer on the weak points find whatever they're having trouble with and focus on that. and so, that behavior, and i think some people have had teachers where it feels like this, it feels like an adversary, right? it feels like they want you to fail. so in fact you can make them an actual adversary. if you have some process which is genuinely doing its best to make the network give as high an error as possible that will produce this effect where if it spots any weakness it will focus on that and thereby force the learner to learn to not have that weakness anymore. like one form of adversarial training people sometimes do is if you have a game playing program you make it play itself a lot of times because all the time. they are trying to look for weaknesses in their opponent and exploit those weaknesses and when they do that they're forced to then improve or fix those weaknesses in themselves because their opponent is exploiting those weaknesses, so every time the every time the system finds a strategy that is extremely good against this opponent the the opponent, who's also them, has to learn a way of dealing with that strategy. and so on and so on. so, as the system gets better it forces itself to get better because it's continuously having to learn how to play a better and better opponent it's quite elegant, you know. this is where we get to generative adversarial. networks. let's say you've got a network you want to... let's say you want cat pictures you know, you want to be able to give it a bunch of pictures of cats and have it spit out a new picture of a cat that you've never seen before that looks exactly like a cat the way that the generative adversarial network works is it's this architecture where you actually have two networks one of the networks is the discriminator how's my spelling? yeah, like that the discriminator network is a classifier right it's a straightforward classifier you give it an image and it outputs a number between 0 & 1 and your training that in standard supervised learning way then you have a generator and the generator is... usually a convolutional neural network, although actually both of these can be other processes but people tend to use in your networks for this. and the generator, you give it some random noise, and that's the random, that's where it gets its source of randomness, so that it can give multiple answers to the same question effectively. you give it some random noise and it generates an image from that noise and the idea is it's supposed to look like a cat so the way that we do this with a generative adversarial network is it's this architecture whereby you have two networks playing a game effectively it's a competitive game. it's adversarial between them and in fact it's a very similar to the games we talked about in the  alpha go video. it's a min/max game because these two networks are fighting over one number one of them wants the number to be high one of them wants the number to be low. and what that number actually is is the error rate of the discriminator? so the discriminator wants a low error rate the generator wants a high error rate the discriminators job is to look at an image which could have come from the original data set or it could have come from the generator and its job is to say yes. this is a real image or no. this is a fake any outputs a number between 0 & 1 like 1 for its real and 0 for its fake for example and the generator gets fed as its input. just some random noise and it then generates an image from that and it's reward you know it's training is pretty much the inverse of what the discriminator says for that image so if it produces an image which the discriminator can immediately tell this fake? it gets a negative reward you know it's a that's it's trained not to do that if it manages to produce an image that the discriminator can't tell is fake then that's really good so you train them in a inner cycle effectively you you give the discriminator a real image get its output, then you generate a fake image and get the discriminator that and then you give it a real so the discriminator gets alternating real image fake image real image fake image usually i mean there are things you can do where you train them at different rates and whatever but by default they're generally to get any help with this at all, or is it purely yes, so if you this is this is like part of what makes this especially clever actually the generator does get help because if you set up the networks right you can use the gradient of the discriminator to train the generator so when i know you done back propagation before about how neural networks are trained its gradient descent right and in fact we talked about this in like 2014 sure if you were a you're a blind person climbing a mountain or you're it's really foggy, and you're climbing a mountain you can only see directly what's underneath your own feet? you can still climb that mountain if you just follow the gradient you just look directly under me which way is the you know which way is the ground sloping? this is what we did the hill climb algorithm exactly yeah, sometimes people call it hill climbing sometimes people call it gradient descent it's the same metaphor upside down effectively if we're climbing up or we're climbing down you're training them by gradient descent, which means that you're not just you're not just able to say yes, that's good. no. that's bad you're actually able to say and you should adjust yours you should adjust your weights in this direction so that you'll move down the gradient right so generally you're trying to move down the gradient of error for the network if you're like if you're training if your training the thing to just recognize cats and dogs you're just moving it you're moving it down the gradient towards the correct label whereas in this case the generator is being moved sort of up the gradient for the discriminators error so it can find out not just you did well you did badly but here's how to tweak your weights so that you will so that the discriminator would have been more wrong so so that you can confuse the discriminator more so you can think of this whole thing? an analogy people sometimes use is like a a forger and an expert investigator person right at the beginning, you know let's assume there's one forger in there's one investigator and all of the art buyers of the world are idiots at the beginning the the level of the the quality of the forgeries is going to be quite low right the guy just go get some paint, and he he then he just writes you know picasso on it and he can sell it for a lot of money and the investigator comes along and says yeah i do i don't know that's right or maybe it is. i'm not sure i haven't really figured it out and then as time goes on the investigator who's the discriminator will? start to spot certain things that are different between the things that the forger produces and real paintings and then they'll start to be able to reliably spot. oh, this is a fake you know this uses the wrong type of paint or whatever so it's fake and once that happens the forger is forced to get better right you can't sell his fakes anymore he has to find that kind of paint so he goes and you know digs up egyptian mummies or whatever to get the legit paint and now he can forge again and now of the discriminator the investigator is fooled and they have to find a new thing that distinguishes the real from the fakes and so on and so on in a cycle they force each other to improve and it's the same thing here so at the beginning the generator is making just random noise basically because it's it's it's getting random noisy and it's doing something to it who knows what and it spits out an image and the discriminator goes that looks nothing like a cat you know and then eventually because the discriminator is also not very smart at the beginning right and and they just they both get better and better the generator gets better at producing cat looking things and the discriminator gets better and better at identifying them until eventually in principle if you run this for long enough theoretically you end up with a situation where the generator is creating images that look exactly indistinguishable from images from the real data set and the discriminator if it's given a real image, or a fake image always outputs 0.5 5050 i don't know could be either these things are literally indistinguishable, then you pretty much can throw away the discriminator and you've got a generator, which you give random noise to and it outputs brand-new indistinguishable images of cats there's another cool thing about this which is every every time we ask the generator to generate new image we're giving it some random data, right we give it just this vector of random numbers which you can think of as being a randomly selected point in a space because you know if you give it if you give it ten random numbers you know between zero and one or whatever that is effectively a point in a 10 dimensional space and the thing that's cool is that as the generator learns it's forced to you if the generator is effectively making a mapping from that space into cat pictures this is called the lateness base by the way generally any two nearby points in that latent space will when you put them through the generator produce similar cabbages you know similar pictures in general which means sort of as you move around if you sort of take that point and smoothly move it around the latent space you get a smooth lea varying picture of a cat and so the directions you can move in the space actually end up corresponding to something that we as humans might consider meaningful about cats so there's one you know there's one direction, and it's not necessarily one dimension of the space or whatever but and it's not necessarily linear or a straight line or anything but there will be a direction in that space which corresponds to how big the cat is in the frame for example or another dimension will be the color of the cat or? whatever so that's really cool, because it means that by intuitively you think the fact that the generator can reliably produce a very large number of images of cats means it must have some like understanding understanding of what cats are right or at least what images of cats are and it's nice to see that it has actually structured its latent space in this way that it's by looking at a huge number of pictures of cats it has actually extracted some of the structure of cat pictures in general in a way, which is meaningful when you look at it? so and that means you can do some really cool things, so one example was they trained annette one of these systems on a really large database of just face photographs and so it could generate arbitrarily large number of well as largest the input space a number of different faces and so they found that actually by doing basic arithmetic like just adding and subtracting vectors on the latent space would actually produce meaningful changes in the image if you took a bunch of latent vectors, which when you give them to the generator produce pictures of men and a bunch of them that produce pictures of women and average those you get a point in your latent space which corresponds to a picture of a man or a picture of a woman which is not one of your input points, but it's sort of representative and then you could do the same thing and say oh, i only want give me the average point of all of the things that correspond to pictures of men wearing sunglasses right and then if you take your sunglass vector, you're you're men wearing sunglasses vector subtract the man vector and add the woman vector you get a point in your space and if you run that through the generator you get a woman wearing sunglasses right so doing doing basic vector arithmetic in your input space actually is? meaningful in terms of images in a way that humans would recognize, which means that? there's there's a sense in which the generator really does have an understanding of wearing sunglasses or not or being a man or being a woman which is kind of an impressive result all the way along but it's not a truly random thing because if i know the key and i can start want to generate the same yeah i'm so i mean that's about unfortunate is the problem with cryptography is that we couldn't ever use truly random because we wouldn't be able to decrypt it again we have our message bits, which are you know naught 1 1 naught something different? and we xor these together one bit at a time, and that's how we encrypt