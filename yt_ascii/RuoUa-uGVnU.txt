let's do this one why no build system this is actually something i'm very interested in so when i i used to work a lot on chrome dev tools and one of the big things about chrome dev tools is that there was no build system effective there was no transpilation stage there's only literally catting some files in a certain order to deliver a singular artifact i thought hopefully i'm gonna like this right there's no way i'm gonna have a good time with this it's j it's just javascript gross like i only use it typescript i surprisingly found it pretty dang okay right the amount of time the amount of concentration and things that go on when you don't have a separate build system is really nice right it's really really nice i genuinely liked it yeah i built a lot of things for chrome dev tools for netflix right i've overridden it helped communicate with it built-in css selectors for rectangles we draw on the screen did some other things voice voice to text stuff just building in all the chrome dev stuff like read because we just we you know we have v8 in in the television and so it's like well we got to build out the chrome developer or the chrome debugger protocol the cdp right so i've helped on some of that it was a lot of fun it was neat it was good times netflix by the way all right so why does the htmx not have a build step a reoccurring question from some htmx contributors is why hmx isn't written in typescript or for that matter why html lacks any build step at all the full html source is a single 3500 line javascript file okay if you want to contribute it to htmx you do so by modifying the htmx file the same file that gets sent to the browser in production give or take minification and compression this feels completely backwards can we all agree this feels like a literal backwards world right this feels backwards it feels backwards why though i do not speak for the hdmax project but i've made a few non-trivial contributions to it and i have been a vocal advocate for retaining this no build step every time the issue has arisen from my perspective here's why htmx does not have a build step right once run forever okay okay let them cook hey let him cook also hdmax is still like the greatest ui library i've ever used the best reason to write a library in plain javascript is that it lasts forever this is arguably javascript's single most underrated feature while i'm sure there are some corner cases javascript from 1999 that ran a netscape navigator that will that will run unaltered alongside modern code and google chrome downloaded yesterday that is true for a few programming environments it's certainly not true for python or java or c which have all had versioning mechanisms where opting for new feature language features will force you off some deprecated apis of course most people's experience with javascript is that it ages like milk reopening a node repository after three months you'll find that your project is mirried in a flurry of security warnings backward incompatible library upgrades and a front-end framework whose culture peak was the exact moment you started the project and is now widely considered detected as someone who's lived through classes higher ordered components the beginning of functional components use effect should component update as someone who's been through a lot of just react changes this emotionally hits in a place in which is painful and tender okay it's still tender to this day i'm still tender okay tender okay tender moments tenderly who's the blame for this situation remember that time they decided we're going to run use effect twice in debugging and debug mode i'm still tender like again once again i'm now tender i'm just i'm thinking of all the things that have emotionally caused me problems throughout my entire lifetime and this is one of them who's to blame for this situation is for someone else to decide but in any case you can eliminate this entire problem class by not having any dependencies beyond javascript runtime okay that's actually a pretty fair statement i i agree with what's being said a popular way to write javascript today is to compile it from typescript which i use frequently as an example because typescript is probably the best reason to use a build system i'd agree i'd agree that typescript is probably the best reason to do it the obviously using the lsp is incredible right it just works way way better than anything else but you also have to i guess you do have you do have js docs these days that's been something i really want to invest more time into is figuring out a good set of like lewis snips for a little code snippets and and js doc stuff and see can i create something that i can just run in node always that just works you know what i mean they use a htmx dts instead of okay okay that's also kind of an interesting approach i you know every single time i use dts it always ends up being a pain in the ass at some point there's something i do wrong some build system that just does not work anyways whatever whatever slow down typescript does not run natively in the web browser so typescript code is not protected by ecmas fanatical devotion to backwards compatibility like any dependency new major typescript versions are not guaranteed to be backwards compatible with the previous ones they might be but if they aren't then you need to do maintenance if you want to use modern development tool chain maintenance is a cost paid for with labor an open source code bases are the projects that can least afford to pay it it's a great statement right here this is a great this is a great statement right here opting not to use a build step drastically minimizes the labor required to keep htmx up to date this experience has been borne out by intercooler.js the predecessor to hdmx which is maintained indefinitely with as i understand very little effort when hmx1o was released typescript was at version 4-1 with intercooler released typescript was pre 1.0 with code written in those typescript versions compile unmodified in today's typescript compiler version 5 1 at the time of this writing maybe maybe not but hmx is written in javascript with no dependency so it'll run unmodified for as long as web browsers remain relevant let the browser vendors do the hard work for you this is an extremely compelling case so there is something i i do want to say something about all of this it's good you know something that i've really struggled with as somebody who's had to developed a few tools inside of netflix is that there's kind of like these three stages that you have you have like a nice build system that can kind of keep things running live updating all that and it works pretty good and that's very very nice and you build it you run it you're using the compiled version as source maps and everything is great and so i like that i'm happy about it sometimes i use ts node or swc to run like a quick version when i don't want to do any building or anything and just run the thing itself also really really nice but at the end of the day you deliver some sort of executable and that thing goes and it runs and you get these errors in which are the minified code and source maps are a lot more confusing to include when it comes to executables and all that and it just becomes this it just becomes really annoying like there is something about this everything they're saying for a sufficiently small tool that i could almost find myself liking like for me to actually commit to doing a three thousand four thousand line file feels emotionally painful but there's also part of me that there's other pain in the asses that do exist right and so if you have good navigation is it better it could be it very well could be i guess i'd have to rethink about a way to do something like harpoon right in-file markers would become increasingly important we'll see i'd have to really think about this i just don't know yet i don't know it it feels very contrarian to my opinions on software but i do want to be real for a second just because something feels contrarian doesn't mean it's worse or better documents symbols yeah but i don't want to have to i don't like fuzzy finding every time i want to go somewhere i i like things that are a little bit better than that right i like to be able to have like a marker that sticks with the function that moves but there's this idea that when something is different than what is considered like modern or good it's therefore bad or if it's considered outside of what you're really used to it's considered non-dx but often you know there's this there's this experience where when you try something new like a good example is just getting good at vim right getting good at vim it makes no sense why you should ever want to use this right it doesn't make any sense at all to enjoy vim from just like a purely outside looking never had any experience in it but once you use it you realize by going contrary to what is natural which is to use a mouse which is to navigate and you know you don't have a keyboard centric thing it's very unnatural to think that way it's much more obvious to go i want to click here i want to edit here i want to click here i want to edit here right like that kind of experience is a much more natural and obvious way you'd want to edit a file and so by undoing that you actually get huge gains and so as all things natural the best you know how often should you re-evaluate what you think is best i don't know you know because right it's it's very hard for me to go against the typescript experience just because of how good a lot of things are with it and how many times my bacon gets saved but is there better alternatives like you said there's a dts file inside the htmx thing that makes it pretty much work maybe maybe that's the experience i'm looking for is the javascript dtx kind of you know in between maybe it is js docs maybe there's something that just makes life a lot better i don't know yet right like i i do need to invest in this more i need to build a real project using a jsdoc but i've just been honestly i've just been too afraid to commit to it with work just because it's a lot of work when you need to undo something you know what i mean yeah it is true that the typescript developer experience dx is better than the javascript developer experience in many respects it is not true that typescript dx is better in every respect and the tendency of software engineers to view progress as a teleology of capability rather than the choices with trade-offs sometimes blinds them to the cost paid for the ds aspects like they like i feel like maybe i'm just such a boomer at heart and that's the way that's the reason why i love htmx maybe that's why maybe that's why maybe i'm just too much of a boomer for instance a small trade-off you make for using typescript is that compiling it takes time and you have to wait for it to recompile to test a change usually this cost is negligible and well worth paying but it is a but it is nonetheless a cost this is true a more significant cost for using typescript is that code running in the browser is not the code you wrote which makes the browser developer tools harder to use when you use typescript code throws an exception you have to figure out the stacked trace with javascript line numbers and javascript function signatures and so forth maps to typescript code you wrote you can you know you can use maps but i've i've not 100 had a great experience with maps and i think everybody can agree to that maps work most the time but there's time when maps don't work and they're super annoying and then yes then you also have like webpack which webpack has an entire other ecosystem going on there that can also be kind of a pain in the ass when your javascript code throws an exception you can click straight through to the source code read the thing you wrote set a breakpoint the debugger this is tremendous dx for many younger web developers who have never worked this way can be a revelatory experience i've had some issues at times in which can be a huge annoyance right build step advocates point out that typescript can generate sword there's me i'm making the argument for you which tells your browser what typescript corresponds to what javascript and that's true but now you have another thing to keep track of the typescript you wrote the javascript it generated the source map that connects those two the hot reloading development server you're now depending dependent on will keep these things up to date for your local host but what about your staging server what about it in production what about it in ci bugs that appear in these environments will be harder to track down because you've lost a lot of information about where they come from unless if you have to build an entire system around it to keep track of builds and the maps and be able to actually have something that can go between them betwixt them we've built things like this at netflix to be able to translate these things on the fly by looking up source maps blah blah blah blah these are all solvable problems but they are problems you've created they are a cost this is a good point people don't consider this as like a thing the hdmax webpack i've used webpack the problem with vite the problem with vita is say you want to make an extreme you want to make a single compilation item right you want to make a single bundle of typescript the problem is what does vite use as its entry point in index.html what happen if you don't want an index.html what happened if you that's not what you need i find that to be one of those i i've looked a few times and i couldn't find anything that's like just build me a file that's named the same every single time i just want the thing i want bundle.js just make it happen vite is all web it kind of like it's not really the thing you want you know what i mean right has a library mode yes yeah i just haven't figured out the library mode and i just needed something within like three seconds and so i just went and did a quick little thing i've used roll up a bunch roll up seems like a very great library experience because it has all the things you need being able to interact and all that and it's pretty fast i i end up using roll up quite a bit the hmx dx is very simple your browser loads a single file which in every environment is the exact same file you wrote the trade-off required to maintain that experience are real but they are trade-offs that make sense for this project i think that's true i think that if you can say that your project is limited in size and scope which 3000 lines is not a big project it's a pretty small project overall you know what i mean enforce clarity modulization is one of the honking great ideas of software modules make it possible to solve incredibly complex problems by breaking down the code into well-contained substructures that solve smaller problems modules are really useful sometimes however you want to solve simple problems or at least relatively simple problems in those cases it can be helpful not to use the building blocks of more complex software lest you emulate their complexity without creating with without creating commiserate commiserate value commiserate value i don't know what that word means what the heck commensurate commensurate corresponding and size or degree in portion it's too sophisticated for me this is not grug commensurate i kept saying commezery commiserate a commensurate value this is not grub written okay this is not for my grub my grub brain okay new word unlocked i know i have a new word it feels really exciting i'm going to use it again commensurate at its core htmx solves a relatively simple problem it adds a handful of attributes to html that makes it easier to replace dom elements using the declare declarative character of hypertext requiring that htmx remain in a single file again around 3 500 lines of code and forces a degree of intention to on the library there is a real pressure when working on the html source to justify the addition of new code a pressure which maintains an equilibrium of relative simplicity huh i never really thought about that but yeah i could imagine that as you have a larger file the pushback on adding features and new things is heavy right like why would you want to expand that it's kind of an interesting little little observation i'm not saying it's good i'm just saying it's an interesting observation while the dx costs are obvious there is also surprising dx benefits if you search a function name in the source value instantly find every invocation of that function yep so you don't necessarily have to have an lsp to find everything that has to do with it this also mitigates the need for more advanced code inspection the lack of places for functionality to hide makes working on hdmx a lot more approachable far far more complex projects use aspects of this approach as well squeal light compiles from a single file source amalgamation though they use separate files for development they're not crazy which makes hacking on it significantly easier you could never build the linux kernel this way but hdmax is not the linux kernel fair costs like any technological decision technology decision choosing a to forego a build step has advantages and disadvantages it's important to analogy acknowledge those trade-offs so that you can make an informed decision and revisit that decision if some of the benefits or costs no longer apply which is the advantage of writing plain javascript in mind let's consider some of those pain points introduced i'm very curious if they can really give me something good that makes it compelling to do this because right now i'm having a hard time saying like i like the things you've said so far but it's not compelling enough for me to do a single file for some small projects that are less than a thousand lines of code right it's not compelling enough for me yet though i do start every project in a single file and usually grow to like 400 lines before i go i hate this and i break it off into many little ones maybe i just don't have a good workflow for single files maybe i just haven't thought about that enough you know what i mean i don't know typescript is a strict superset of javascript and our let's see and some of the features it adds are very useful typescript has types which makes your ide better at suggesting code and pointing out where you might have used methods incorrectly the tools for automatically renaming and refactoring code are much more reliable for typescript than they are for javascript the htmx code does have to be written in javascript though because browsers run javascript and as long as javascript is dynamically typed the trade-offs required to get true static typing in the htmx source code are not worth it hdmax users can still have the advantage of typed apis declared with dot tts files okay well that's nice like that is one thing that's really interesting users get all the benefits of types implementers get none of the benefits but i still i still think doc files are a real win here it seems like doc files are the real win here because doc files do work with ts server and you have generics and doc files they are they're stripped out on minification so it kind of seems like there is like a real win here with j stock future versions of htmx might use doc i swear this is not pre-read to get some of the same guarantees without the build step other libraries like svelte has been trending in this direction as well in part due to the debugging friction that typescript files introduce i agree we read this and i completely agree with rich on it no es6 because htmx maintains support for internet explorer 11 and because it does not have a build step on every let's see every line of hmx has to be written in ie11 compatible javascript which means no es6 i wonder if they'll drop that because that seems like you could get a much smaller artifact avoiding es5 right and oddities of internet explorer 11. maybe there is something there maybe a suggestion maybe i'd throw this out to the htmx people maybe just maybe there's a way you could figure out how to have a build system specifically for ie 11 versus ie12 or whatever edge htmx2 will drop by 11. awesome i like to hear that yeah i know to see the problem is banks and stuff like that they're very far behind and so you can't just make these decisions i know people look at that trivially and say oh why would you ever do that the problem is not you it's other people right when people like me say that javascript is pretty good now they're usually referring to the language features that are introduced with es6 like async await anonymous functions that must be a that must be a missed a typo it's not anonymous functions you must be saying lambda functions and function a functional array methods like map and 4-h none of which can be used in hmx source code while this is incredibly annoying and practice is not a huge impediment to the lack of some nice language features doesn't prevent you from writing code with functional paradigms would it be nice not to write some custom for each method of course but until all the browsers targeted by htmx support es6 it's not hard to supplement es5 with the fewer helper functions yeah this is true if you are used to es6 you'll automatically write better es5 that's fine ie support is going to be dropped in hmx2 at which point es6 will be allowed in the source code that will probably dramatically reduce the size no modules in court this point is obvious but it's well worth restating the aspect source would be a lot tidier if we could split it into modules there are other factors that affect code quality besides tidiness but to the extent that htmx source is is high quality is not because it is tidy this makes doing certain things with hmx very difficult the ideal morph algorithm might be included in htmx2 core but it's also maintained as a separate package so that people can use dom morphing algorithm without using htmx i don't know this one i don't know the ideal morph algorithm if the core could include multiple files one could easily accomplish this with any number of mirroring schemes such as git sub modules oof i always have i do every time i swear git sub modules are the greatest idea and the worst idea same time but the source but the chorus a single file so the idiomorph code will have to live there as well okay okay i really don't know how i feel yet about everything it's just that this is a very compelling thought so far for me right this essay it might be better titled why hmx doesn't have a build step right now as previously mentioned circumstances change and these trade-offs can be revisited at any time one issue we're exploring at the moment has to do with releases when hmx cuts a release it uses a few different shell commands to populate the disk directory with minified and compressed versions of htmx.js patents are welcome to point out this is obviously that this is obviously and in some sense a build step patents showing their pet entry in the future we might expand that script to auto generate the universal module definition or we might have a new distribution needs that require an even more involved setup who knows yep one of the core values of hmx is that it gives you the choice in a web development ecosystem that has the last decade been dominated by an increasingly complex javascript stack once you no longer have an enormous code base of front-end javascript there is far less pressure to adopt javascript on the back end this is observation like i want you to take a moment and think about this very very it's a very very subtle point but it's a very very true point right i i will tell you that now that i've built a couple small applications with htmx i have genuinely enjoyed the experience and i think that there's a lot of places i think there's most applications could use htmx more than they could use anything else and it has nothing to do with i don't want to write front-end code it has everything that has to do with i want to manage state in a sensible insane manner you can write back-ends in python go and even node.js and it doesn't matter to htmx every mainstream language has mature solutions for formatting html this is a principle of hypermedia on whatever you'd like howl i like that principle writing javascript with no build process is one of the options available to you once you no longer require an xjs or sveldkit to manage your spiraling complexity of a spa frameworks that choice makes sense for html htmx development today and may make no sense for for your app too i like it i like it this is this is a very cool take icy cold right it's just like it may make sense for us it may not make sense for you so maybe you don't want to adopt this but overall here we're at here are here we are right i like this is front end the html stuff it is spell kit's pretty simple i'd agree with that it's not that i don't want front-end code it's i don't want to write stupid front-end code yeah yeah i get that as well but i think the truest part of this is has everything to do with complexity of state management and the solutions around it people don't realize exactly how much effort they put into state management using any of these applications there's there's just thousands of lines devoted to libraries to attempt to make state management easier where you put all of your business logic in a series of functions and that's how you get stuff out just so it can be clean inside of a render function it's like you have to recreate because no matter what you do at the end of the day you have to recreate and duplicate logic all over the place a good example of this is like a delete button how do you know a user should be able to delete say a certain post while the simplified way is that the server says okay i'm going to do a search i'm going to check for ownership when i find ownership i'm going to send down a can delete variable or a you know boolean value then the front end is going to have an if can delete i will then add this button now just just remember that is a duplication of logic because the back end has to go can the user delete yes they can here's your signal for it the front end goes can you delete yes you can here's your signal for it they're doing the same logic they're just doing it in two different places representing it in two different views and so there's a lot of complexity around that and so it's just something to think about oh no it's just something i think about a lot of are we really doing the right thing and i feel like hmx is a very refreshing view on it modern front-end code continuously duplicates a lot of stuff for no real reason it makes a lot more sense just to render the view as a template i do actually agree with this and that's what makes htmx is so appealing is that you can do a lot of that really quick i hate how react moves in favor of writing more business logic and components squeal components is garbage yeah i've been meaning to catch a live stream dig the youtube content and also land it in software from a similar trajectory my man the name is i do like hdmx a gen