so computer files done quite a bit on recursion but so far we haven't talked about the idea of tail recursion which is a simple trick for making recursive programs more efficient and really it's something that every programmer should know about so that's what we're going to look at today tail recursion so as we often do with these things we're going to start off with a simple example and the example that we're going to look at is the factorial function so what the factorial function does is it takes a number like four and it's simply going to multiply all the numbers from four down to one so we'll do four times three times two times one which hopefully equals 24. and this is a classic example of a function that you can define recursively with two cases so we have a simple base case which says the factorial of one is going to be one because if you multiply the numbers from one down to one there's really nothing to do you just simply return the number 1 straight away and then we have a recursive case which says if you have any other positive number n what you're going to do is you'll take the number n and you'll multiply it by the factorial of n minus 1. so it's recursive because we're defining the factorial function in terms of itself we're saying the factorial of a number n like 4 is going to be n times the factorial of its predecessor so it's a recursive function that's defined in terms of itself let's make sure we all understand how this function is actually operating with a simple example and we'll find it's actually very inefficient and this is where tail recursion is going to come in to help us to make this function more efficient so let's look at our simple example so we do factorial of 4 and we simply go to our definition and that tells us that factorial of 4 is going to be 4 times the factorial of its predecessor which is 3. and then we think well what do we do now well we're simply going to take the factorial of 3 and we're going to expand that as well so we copied down what we had before we've got four times and then we've got factorial of three and i'm going to use brackets here to make the structure or the grouping explicit because that's going to be quite important so we're doing factorial of 3 which is 3 times the factorial of its predecessor which is two and then we simply do the same again we unwind the recursion one more time we copied down everything we had before we have four times three and then we get in brackets two times the factorial of 1. and now we've finally reached the point where the recursion is going to stop we've got factorial of 1 here and by definition that was just 1. and then finally now we can start to actually perform the multiplications so we do 2 times one so i'm not going to skip any steps here and then we do the 3 times 2 to get 6 and then finally we do the 4 times 6 to get 24. you can see by kind of expanding the definition here that we've been able to see that the factorial of 4 is 24 using our simple recursive definition but unfortunately this definition is actually quite inefficient and it's inefficient in terms of the amount of memory it uses and you can see this just by looking at the structure of what i've written down here we start off with factorial of four which is small and then we get a bigger expression here and a bigger expression here and a bigger expression here and this is because we're unwinding the recursion and we need to unwind or apply all the recursion before we can actually get to the point where we do any of the multiplications and then we can do the multiplications and things shrink down again at the end and it's got kind of a triangular shape you start off with a small term at the top or a small expression and as you go down the expression is getting bigger and bigger until you finally reach the end of the recursion and then you can start doing the multiplies and it all shrinks down to the end so it's like a triangular shape so this kind of shows us with a simple example that this is potentially inefficient in terms of how much memory it uses and you can imagine for example if you calculated the factorial of a large number like a million you'd have to build up this very large intermediate expression counting down from a million down to one building up all the multiplications in the middle before you actually get to the end and you can start collapsing this whole thing down so this function works it has the correct behavior but it's not satisfactory because it uses too much memory so we can fix this using the idea of what's called tail recursion so what i'm going to show you now is how to redefine this function in a way which gives the same answer as before but is actually much more efficient and we'll see afterwards that this is what's called tail recursion so i'm going to redefine the factorial function and i'm going to use a little helper function which i'm going to call go now this is often the name that people use for these things and go is going to take two parameters or two inputs the first one will be the number we're trying to calculate the factorial of that's just n and the second parameter is going to be what's called an accumulator and this is just a simple value that we're going to use to build up our running multiplication as we go along rather than waiting until the end and then doing all the multiplications backwards we'll do the multiplications as we go along and we'll use this extra argument to accumulate all of those values for us so how does the go function itself actually get defined well there's two cases for this just like we have two cases for the factorial function so the first case says if you're trying to calculate the factorial of one then you don't return the value one anymore you can just return your accumulated value and if you're trying to calculate the factorial of some number n and you've got an accumulated value a what you're going to do is call the go function you'll decrement the value so 4 will become three for example and then the trick here is that you're going to take your accumulator value and you're going to multiply it by n so we've got a simple recursive definition here very similar to the way the factorial function works but we're going to see that this actually gives us a much more efficient definition so let's look at the same example as before we're going to look at factorial of 4 and see whether this is more efficient or not and actually check whether it gives us the same result as well so we're going to call go and we'll have four and then we'll have our initial accumulator value being one and what do we do well we just go to the definition and it says we subtract one from the first parameter and then we're going to multiply the 1 by the 4. so if we work out the details of that very simple we're just going to get 3 and 4. now we just simply repeat the process we say what is go of 3 and 4 well we call the go function again and we decrement the first parameter and then we multiply the two parameters so in this case we multiply the three and the four so we get 12. and then we go one more time we go we decrement the first parameter so we get 1 and then we multiply the 2 and the 12 and we get 24. now we're finally down at the base case so we can stop and we simply give back the result 24. what you see here is that you get the same result as we had before factorial of 4 is 24 but now it's much more efficient in terms of memory and we can see this simply by looking at the structure of what we have here we have go applied to four and one then go applied to three and four and so on and so on so the term here or the expression that we're manipulating is simply a function applied to two inputs that just uses a very tiny amount of memory we don't need to use enormous amounts of memory to build up a large intermediate expression which then we collapse down at the end we're just using constant amounts of memory as we go along and this is achieved because the go function is what's called tail recursive let's have a look at the definition of the go function in particular let's look at the right hand side of the recursive case so the right hand side tells us how to calculate go of n a and if we think about how this is actually evaluated we would first of all subtract one from n then we would multiply a and n together to give our new accumulator value and then finally the last thing that we do is do the recursion so this is the idea of tail recursion when you make a single recursive call and the very last thing you do is make that recursive call so there's nothing to do afterwards actually this is what's making this definition more efficient than our previous one because we don't need to remember anything after we make the recursive call to the go function and this is in contrast to our original definition of the factorial function if we look at this definition and we think well how does this right hand side here in the recursive case get evaluated well what we would do is we'd first of all subtract one from n then we'd call the factorial function and once that had returned we need to remember that we still need to do the multiply so it's not tail recursive because the last thing that we do is not applying the recursive definition after the recursive call we still need to remember to multiply by n and that's the source of our inefficiency here so that's one example of tail recursion let me show you another example of tail recursion and what we're going to look at is what's called the fibonacci sequence which is a very famous sequence of numbers in computer science and mathematics so the fibonacci sequence begins in a very simple way we simply have zero and one these are going to end up being the base cases for our definition and then the fibonacci sequence proceeds by simply adding together the two previous values so you add the zero and one to give one you have the one and the one to give two you have the 1 and the 2 to give 3 and then hopefully i don't mess it up and the sequence proceeds off to infinity so this is the fibonacci sequence how do we define this as a recursive definition and there's a very simple way to do this but the very simple way is actually going to be very inefficient but we can make it efficient using tail recursion so let me show you the inefficient way first of all so we can define a function which is going to take a number as an input n and then it's going to give us back the nth fibonacci number starting from zero because computer scientists always count from zero so the base case for the definition if you want the zeroth fibonacci number that's the first thing in the sequence that's zero if you want the first fibonacci number counting from zero that's the second thing in the sequence so that's going to be one and then if you want the nth fibonacci number you take the two preceding ones and you add them together so fib of n is fib of n minus one plus fib of n minus two so that's a nice simple recursive definition but unfortunately it's horrendously inefficient for example if you tried just calculating fibonacci of 50 even using quite a fast machine even after a few minutes it won't have terminated it's going to take an awfully long time to do that and there's a number of problems with the definition it uses double recursion here we're making two recursive calls so that potentially could be a source of inefficiency we're also not using tier recursion because once the two recursive calls finish we still need to remember that we need to add the two resulting numbers together and actually there's another source of inefficiency here if you think about it this is recomputing the same fibonacci numbers all of the time so let's see how we can use the idea of tail recursion to make this recursive definition more efficient or actually extremely efficient so let's rewrite it and we use the same kind of trick as we did before so we're redefining the fibonacci function and it takes a number n and we're going to call a helper function called go and it's going to take n as its first parameter and this time it's not going to take an accumulator as a as its second input it's going to take a pair of numbers and the pair of numbers we're going to take are simply the current fibonacci number and the next one so initially we're going to have 0 and 1 because those are the two first fibonacci numbers and then as we move along we're going to kind of shift that little window on the fibonacci sequence along so initially it'll be 0 1 then 1 1 1 2 and so on so i'm going to be shifting that little window along so this is what the go function is going to do for us so there's three cases here so we could go with zero we could go with one and we have a pair a b or we could go with n and we have a pair a b so we can think how do we define the three cases so the two base cases are very simple if i want the 0th fibonacci number i've already got it it's simply a if i want the first one it's simply b and then if i want the nth one all i'm going to do is call the go function decrement the first parameter so the four will become three and then i take my little window a b and i'm going to move it along one so if a is the current fibonacci number and b is the next and i want to move along one step then b will now be the current fibonacci number and a plus b will be the next one so this is the idea of just moving along a step so a simple example with that would be if i take the pair 2 3 and move it along the 3 will move into the first position and we add the two numbers together and we get five so that's kind of moving one step along in the fibonacci sequence so here is my definition for the go function and notice that it's tail recursive it makes a single recursive call and it's the last thing that we do so in particular we think how does the right hand side here actually get executed well we'd subtract one from n then we'd form this pair b and a plus b and then the very last thing we do is we make a single recursive call okay there's no more double recursion anymore so let's just check that this actually works correctly and that it is actually more efficient so let's try calculating the fourth fibonacci number using this and see what happens so we apply the go function four is the first parameter and we take zero and one as the current and next fibonacci numbers and then we just unwind the recursive definition so the four is going to decrement become three and then we move our little window along one so one is going to become the current fibonacci number and we add the zero and one to get the next one so we get one one then we continue so we go we decrement the three to get two the second one becomes the first component of the pair here and then we add the one and the one to get two then we continue so the two is now going to move over we're shifting along one the two becomes the first thing we add the one and the two and we get three and then finally we reach one of our base cases and that will be the second component of the pair which is three and we can just double check that that's correct if we go back to the fibonacci sequence and we're looking for the fourth fibonacci number counting from zero so there's zero one two three four so we find that three is the correct answer here the point here is that because the go function is tail recursive we get this result extremely efficiently if you look at the structure of what we have over here it's very simple we just simply have a function applied to two numbers or three numbers really four zero and one same here same here and same here so we don't have a computation or an expression which is growing and shrinking it uses constant memory here and it can run extremely fast because of that so that's all for today it's just been a quick introduction to the idea of tail recursion and the idea is basically you can sometimes make recursive functions more efficient by making recursion the last thing that you do and it's a simple trick which really every programmer should know you know if you set up something do you have to do it manually or no that's that's a very good question so i've shown how to do it manually but actually there are systems some compilers will do aspects of this for you and there's various different tricks that people can use there's tons of research papers written about this kind of stuff and there's some success with this but it's not a kind of