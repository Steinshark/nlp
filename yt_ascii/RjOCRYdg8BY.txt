if you look back at the car park video you'll see it's very handy everything's cut and dry every possible combination of twenties tens and fives will work get us to 25 deliver a ticket if we turn to what we were talking about briefly at the end of that video something like i'm in a program language and i want to declare and identify a name for my integers i want to call mine did you shawn and dave or even k9 i said last time well they're fine but if you want arbitrary length variable names how do you say i don't know whether it's going to be three letters long five letters long or even 60 letters long maybe the compiler has an external limit anyway but in general how can we keep going round without knowing how many and the answer of course is recursion i'm now going to draw you a finite state automaton diagram for a programming identifier yeah and those of you from electronics engineering department you can say yes we've known about these for years they're just state machines so here comes a state machine for identifiers you have to have a starting point we had in the car park and we have to have one here now and then what i'm going to do is to say well in order to get started on a programming language identifier the rule is you must start with a letter not a digit and i just didn't denote any letter for the moment by l this state here which i'm calling the tail piece of the identifier is to take care of the fact eventually that identifies could just be a single letter it's perfectly possible to say in i semicolon it's just a single letter identifier so we've got to allow for that it can be just one letter long or it can be a letter followed by any mix of letters and digits in any order but eventually there has to be an end marker and of course typically in the c programming language the end marker is semicolon okay how do we do that any mixture of letters and digit stuff well here's something new inside this tailpiece state i am saying you can go back into yourself by accepting more letters down at the bottom i can say accept a digit i'll call any digit just d at the moment so can you see what's happening here you go in you must have an initial letter but once you're in the t state you can come back into yourself and that is recursion but as you go back and come back into yourself you must accept a letter or you must find a digit on the input stream eventually the party's got to end you can't keep recurring forever no good at all you will crash you will run out of memory so eventually there's got to be a way out of all this morass and what i'm going to do just so i can link up with what noam chomsky did the great gnome really liked to think of everything as a legal sentence and called it s we mentioned this already that you know in car park language a legal sentence is 10 10 5 because it adds up to 25 and so on but to get into this final state which sometimes is called the finished state sometimes equal is called the accept state then i need to see an e and an e is a valid end marker and i'm saying that in for the subset of the c programming language we're doing here the end marker will be a semicolon i might later on extend that a bit because if i do some awk examples i want to be able to accept new line as being an end marker as well but for the moment let's say yes it's semicolon so that's it then that is a state machine the factor that's new in it is the ability to do recursion for as long as you want until you finally bottle out the whole thing and take the end mark and say that's the end of my declaration okay well what emerged from all of this stuff about state machines and from chomsky's work in the mid to late 50s for every machine you can draw like this and this is a machine interpretation of identifiers there's always a grammatical alternative and the more if you like mathematical theoretician you are the more you like rather abstruse so-called top-down ways of thinking about things so chomsky's notation let me just start you off on this for this we'll say look my goal is a sentence but what seems to be the case is that to get to sentence i've got to take first of all an l and then that gets me into a t state okay chomsky notation you can read the arrow as being is defined as a sentence is defined as an l any letter followed by what i'll call a tail or a tail piece of the identifier l and t fine well what let's just do one example of what a t can be a t look let's take this one can be further defined as yet another letter followed by another t now look what's happening here for the first time a rule for t is developing of another visit into a t on its right hand side this is technically called right recursive and the chomsky will say you can be right recursive if you want to do it the other way around perversely and do t becomes t l that's okay that's still within the chomsky rules it can be purely right recursive or purely left recording i'll make it right recursive it's a bit more intuitive to me and just in case you think well this is going to go on forever and i can imagine a t becoming a d t and you're taking digits forever what's the thing that gets you out of all this in the end and the answer is well look back at the automaton diagram and say ah in the end you take the escape route you take a t is defined as being an e that's one of the options but what about e then ah well here's a classic example then of something that doesn't lead on to another rule it leads in tree terms to a leaf of the tree a terminal symbol that goes nowhere else and the one i'm hoping is there is just a semicolon of course you've spotted that the picture is completed refer back to automaton again there's also a right recursive option to say yes accept any digit and go back into t so you go back into yourself again but equally you can now write at the bottom here and it's in the handout we will do all of this in a linked handout so do read the info block of this video find out where the handout is download it read it you'll find in this complete thing i've also said a letter can be anything from a to z or capital a capital z a digit can be anything from naught to nine that's the way you finish off that grammar this encourages you to think as computer scientists say top down you start with the purity of the abstraction of a sentence and then you develop the detail below it automata really i tried to show you the whole picture you can for me from an automaton gets a rather it's a bit top down but you can always get more of an idea of how all this is built up in sequential steps going through it there's nothing very magic then now it's just emphasizing what i said at the start to every machine picture of a circle in the hierarchy there is a corresponding grammatical expression of it it's just as we'll go out through that johnson hierarchy the machine interpretations become more complicated and more involving this magic thing called memory as an ancillary to what state is your machine in down here in type three where we are at the moment all we're saying is all you get is your states and yes you've got to model those correctly but you don't need ancillary memory for any purpose later on we'll find that we do the hierarchy where as you go inside you make less and less demands on what you need and if you look we can even eliminate cast shadows which would be cast by direct sunlight