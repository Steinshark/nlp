do we only use about 10% of our brains so a common idea and a really enticing one as well this idea that we have the vast majority of our mental capacity locked away somewhere just waiting for us to work out how to tap into it unfortunately it's not true in fact there have been a number of studies and experiments designed specifically to prove or disprove this idea and it's been largely debunked now which is a shame but are there ways that we can make more effective use of the brains that we do have for specific tasks for specific things and the answer to that one is hell yes and it's something i've been really interested in for quite a number of years now in fact the the first conference talk i ever did on a stage much like this nearly 20 years ago was about just that topic it was called organic programming and it was just basically a collection of of mind hacks productivity hacks things borrowed from psychology and nlp just in a big sort of grab bag of productivity techniques and i'm still interested in that interestingly in the meantime some of those ideas have moved from a little bit more niche to maybe a bit more mainstream so i haven't felt the need to talk about them so much in recent years but in that same period of time i've also been really interested in something else and that's test driven development or tdd in fact that was one of the main reasons that i originally wrote the the test framework catch now catch 2 was to do better tdd and for some years now i've been doing tdd training as well and in the last couple of years it's occurred to me more and more that when you bring these two things together you actually get something that's a bit more than the sum of their parts that it's not just that you can be more productive at using tdd but you could be much more productive they sort of multiply together and i've been really thinking about why that is and i think i finally got to the point that i can present that as a talk and that is this talk it's the psychological underpinnings of how to get the best out of tdd and perhaps also you can think of it as the tdd underpinings of how to get the best out of psychology well we'll see about that one so i'm really interested in in giving this talk and seeing what people's reaction is whether it's just me before we get stuck into that i should probably introduce myself so i'm phil nash i'm a developer advocate at sonar you can see our logo up there we do static analysis tools in fact our our tagline is that we help you to clean code not just to write clean code but to clean code so it's it's all about yeah clean code code quality fits right into what we're talking about but we're not really going to be talking from a static analysis perspective today so i won't say any more about it now do feel free to come up and talk to me about it after or later in the week if you want to find out more about that you can reach me on x forly twitter or masteron at these addresses and i will show this slide again at the end if you want to to follow me there the other thing that will be on the final slide will be a link to a single page that has all of the references for further reading further watching because we're going to touch on a lot of deep subjects we're only going to scratch the surface of if you want to do more background reading then watch out for that link and that we get you started on where to follow up so let's get started on our material and i want to get right back to the fundamentals of testing and and ask some questions so why do we write tests and in fact want to go back even further than that like starting with the why but let's go even before that and say do we write tests at all not everyone writes tests at all i'm not going to ask that question of the room but i do have some questions i do want to ask who here regularly writes tests for their code in their you know regular development cycle not necessarily all of all of the code and not necessarily before the tests sorry before the code but it's just a regular part of your development habit who who here does that so it's probably about 2third of the room i'd say at a glance all right who's currently working on a h base that has at least 90% code coverage if you can measure that or at least finger in the air much fewer okay what about this one then so who thinks they should probably write more tests i think i think that's most people certainly more than the first group most of us think we should be writing more tests so why do we not in fact let's bring that why back in but but pose that question why do we not write tests or just to include everyone why do we not write enough tests if you think we should be writing more but we're not what's stopping us is it too hard do we not know how to do it is there something else getting in the way do we not see the value in it all sorts of questions we could ask i think it's valuable to ask those questions and not just put it aside so i'm going to put up some possible reasons some of these may resonate with you i think these are probably the most common ones plenty more that may apply to you it's not exhaustive so maybe you think the writing text test is extra work and you've written the code you've seen that it works somehow we'll put aside whether you consider that a test but talking about automated tests that you then write that's no extra work good you know it works why should i do extra work related to that it must slow you down you got to do this extra work and by some estimations you should be writing at least as much test code as production code you may have heard that may be surprising to some people so if you're going to write double the amount of code that's got to take longer it's got to slow you down i don't have time for that or maybe it just distracts from what you're doing i've got this interesting problem i want to solve i don't want to be distracted by having to write test for it that takes a different mindset don't want to be distracted or maybe they're just boring yeah i'm not interested in writing test that's not what motivates me okay well i'm not making any judgments just yet about whether these are valid or not we will come back to them you could probably guess where i'll i'll land on them but let's go back to our question why do we write tests and now well we said we're going to talk about the psychology of tdd and this is really the philosophy of tdd why do we write tests i'm going to put a few a few suggestions up perhaps start with the most obvious one of course we wr test to catch bugs whether we catch them before we've written them or not it's another question but yeah catching bugs is a big part of it it's important it's not the only thing though so what else how about this one to encode our expectations maybe you don't think about this so much but when you're writing a test especially if you're writing it before the code really you're thinking well what do i expect this code to do you have to think about that first once you know what it is then you can write it down encode as a test you've encoded your expectation and now you don't have to worry about that anymore because the test is there telling you whether or not you've met that expectation you can think about other things this turns out to be quite pivotal and we're going to come back to this later but maybe it's not one you thought of so maybe a more obvious one again to catch regressions sometimes we we find a a bug in production or manual testing and think oh i don't have a test for that so you write a test first that reproduces the issue you fix the bug and you leave the test in because now it's a regression test and make sure that bug never comes back again but we can call them regression tests if there was never a bug there to start with just having a large body of tests that we can run against all the code after any change you make we can tell if we've broken anything that we'd written before that's a different form of regression so regression testing is is really important as well what about this one writing tests as documentation for some people this seems obvious and for others you think what's it got to do with documentation but your tests are showing how to use your code where the boundaries are how to use it properly of course the flip side is sometimes you write tests that probing at these edge cases you don't actually want people to be using we just want to make sure that they're well tested so you do need to clearly mark which is which so that that is one caveat but the advantage of this is it solves one of the biggest problems of developer documentation is that it's always getting out of sync and nobody wants to maintain it but your tests are tested against the code so if they get out of syn the tests will break so they're automatically kept in the syn so it's a really valuable form of testing and you should lean into that if you if you can so these are a few reasons just to give you a taster now so i do tdd training fairly often and every time i do it i have a a flip chart session where i ask this question why did we write tests and get all the all the suggestions from people and there's always one or two surprises and i'm building my list up over time so i'm not going to show you all of them but here's a here's a few more i'm not going to go through one by one but quite a few additional benefits we get from testing now don't know if you notice the that's not going to work there we go on the right hand side there slightly different shade everything on the right hand side those benefits we only really get if we're doing tdd the ones on the left we get from just general testing so it's another reason that it's worth looking at td not just testing as i say there's many more dozens more that i've got in a in a list somewhere so is it just an exercise of weighing up these benefits against these downsides you know how how can you even measure that no wonder we find ourselves thinking ah it's not really worth writing this test if we're having to do that mental calculus but what if i was to say to you that instead of test being extra work they would help you to avoid rework such that in the long run you've actually done less work overall and instead of slowing you down they can actually speed you up and instead of distracting you from what you're doing they can keep you focused on what matters the most and if instead of being boring they're actually fun all right a lot of claims i'm going to need to back up and we're going to come back to this at the end to see how we got on these are my claims right big question of course is how are we going to do that how are we going to achieve meet those claims now we're going to get into into the psychology of tdd and before we really get stuck into this i want to just emphasize one fundamental principle of all of this it's going to underpin everything and it's really more sort of neuroscience than than psychology itself and i think so important it deserves a little video to run in the background while i tell you about it that we're probably familiar with the fact that our brains are basically just big association machines just a network of connections and and everything is based on links between neurons and and pathways between neurons it's those connections that make everything work sort of underpins everything else not just our memories that we might be used to thinking of this way but our behaviors our mindsets what mental resources we can bring to a problem our emotions our moods they're all underneath they're just pathways through our neural network in our brains if we keep this in mind a lot of the other things we're going to talk about are going to make a lot more sense so let's get into that a little bit because i want to talk about three areas that are in this sort of area between psychology and neuroscience one is habit forming because to really take advantage of something like tdd you need to get into the habit of doing it and often that's the first stumbling block you might have bought into all of the benefits but you just can't seem to do it dayto day we can look at that the second i'm calling dopamine triggers and this sort of plays into the habit forming but it's also a big subject in its own right there are parts of the tdd cycle that really play nicely into this we'll talk about that separately and then we're going to talk about externalizing your brain this is what's going to help us to focus on things while not losing sight of the big picture so before we get into those three areas i want to take a little tour for a bit of a technical part of this i talk about a tale of two cycles now this is partly an excuse to put up a photo of my sons although this is nearly 10 years ago now they're a little bit bigger and so are their bikes but yes they are twins but there's two cycles that i want to talk about and the first one is the tdd cycle so if you've looked at tdd before or even if you you haven't you've probably seen something like this sometimes called the red green refactor cycle because of the the three main areas up there the three main components they're usually colored certainly red and green and then not always the amber or orange for refactoring but i like to do it that way to complete the the traffic light metaphor and an apologies if you do have trouble distinguishing colors it's not really necessary to understand this it's just an extra metaphor but that's where the the red green refactor comes from i put an extra step in there the are we done step and we'll see why that's important to separate out a bit later but let's just have a little tour around the tddd cycle just to get familiar with it because not everyone's necessarily on the same page with this so we start by writing a failing test so that green box at the top and i've emphasized the word start we got a separate point in from there because we have to start here otherwise we're not doing td if we don't start by writing a test it's not tdd and if that test is not failing it's not tdd that doesn't mean that if you write a test that passes it's not useful but it has to be intentional so there are many cases where you write a test you expect it to pass and it does and that's great that's not part of the tdd cycle but it's still valuable it's worth recognizing the difference so you have to see that failing test we'll talk a little bit about a bit later the test itself doesn't necessarily have to be an asser in a test framework could be a compiler error could be other things just needs to be some way that you can see whether the expectation is met automatically now once we've got that failing test only then do we move on to writing the code that will make that test pass the green step now i've written here write just the code to make the test pass it's an important distinction in two ways first of all we want to we want the simplest possible sort of values and we always start with things like empty strings zeros null pointers empty optionals start with those things and then build up to more complex things because it will help you to make sure that as you generalize your code under test it will sort of generalize progressively from simpler to more complex that's quite important we'll maybe touch on that in a bit the other way that we want to write only just the code to make the test pass is we're not concerned here with clean code well factored code or the design principles that we know we want to include in our our code base but we're not doing it right here we're just doing the the easiest thing that's going to work the simplest thing that's going to work because we have a separate step the refactor step which is where we do all the cleanup now the nice thing about separating these these two well there a few nice things but one of them is during the green stage we're not generally touching other parts of the c-base we're less likely to break anything else we might do that in the refactor step because to refactor we may change other parts of the cod base the other big advantage we'll talk about a little bit later so refactoring is when you have to bring your design principles which means you have to know what the design principles are that's beyond the scope of this particular talk you might want to speak to cl down here at the front about some of those just just to set him up once you've done your refactoring you can move on to say actually are we done do we have any other tests that we need to write if you can't think of another failing test to write that's important then you're done and sometimes that might be surprising let's have a a little demo to see how this actually works in real code now because it's not the main part of my talk and it does take a bit of time i do more of a reconstructed demo in slides but i try to give it a bit of a live feel so we'll see how it goes so the demo want to give is a little programming exercise that i call leftpad so you may remember the javascript library of the same name that became famous a few years ago because the author pulled it from npm and then half the internet stopped working because it turned out they all transitively depended on it and one of the the things we talked about at the time was why does half the internet depend on such a small simple library that you could easily write yourself well let's see how easy it is to write ourselves and do it in c++ so will we use catch of course why not now if you've used catch before you know all you need to do is just include the header there's a little bit more to it you do need another file that says hashify catch config main before the header and that will include all the implementation depending on which version you're using so i'm going to side step that for the moment as soon that's all done stick this header in a file actually that's what we need to get started we can run that and it will tell us quite helpfully that no tests run might seem a bit pointless but actually this is still valuable we know we've got our infrastructure up and running we know what our starting point is it's meeting expectations okay well we can add a test case that's what they look like and catch no nothing in there at the moment but we get some different feedback now it's telling us one test case ran it passed or at least it didn't fail subtle distinction there were no assur now sometimes having an empty test case is actually can be a problem maybe not not expected so it might be useful to have a better warning about that so if you run catch with w no assur it will actually make that fail no asss in test case now we got some red this is a failure that we expected we can actually use this to to start our tdd cycle we can just put the simplest thing in there that's going to make that pass we're now back at green right it's the little things this might seem pointless and to be fair this one i don't usually do in practice but it's a useful useful experiment just to see how far you can take this cuz notice these don't actually take that long seconds to go through these so you're not actually wasting that much time but the rewards do come let's carry on let's actually write a real assersion now so we're doing tdd so we're going to write the code before sorry write the test before we write the code to make it pass so we're calling a function called left pad we're going to give it a string a a padded length and then compare that against a result now remember the rule we start with the simplest values so we got an empty string zero padded length but of course it doesn't compile because we haven't wr leftpad yet so that's our next failure compiler is not working we don't even need to compile it if you're using a modern ide when now you tend to use seine it will highlight that missing function in red for me that's enough for me that's my my red my failing test i just need to write the simplest code to make that pass so here's a left pad function takes a string view a size returns a a string so i'm returning the empty string because that rle about using the simplest possible values applies on the implementation side as well but now there's a problem because now this is effectively a new test we got we're going to get the compile test to work this is the first time with the runtime test and it passes but we need to start with a failing test just so happens that in this case empty string was what we expected so to do this by the book we need to be a little bit creative we're going to need to change either the test or the code under test so that this fails just so that we can change it back and see it work which one do you change you could do either but i i prefer to think that the test is actually correct as it is whereas the code under test is still under iterative development so i'm going to change that just return x and now we see the failure we're starting to get some richer feedback here we can see the values involved we can see the x there we know this is all working that's good this is useful feedback and now we know that if we change that back we know that it's that change that made this pass how often have you been chasing something down for hours days maybe longer because what you thought you were testing wasn't doing this by the book really helps you to prevent that a lot of the time so often well i expected that to to pass but actually didn't or expected it to fail but it didn't so it is useful not as the pointless as it seems all right let's take it up a notch i'll add another test this time with a a string so i'm only going to introduce a string and not a pad length and i'm going to keep that string as short as possible because we want to increment that complexity as tightly as possible of course that fails because we're still returning a hard-coded empty string we got our failure simplest thing to make that pass will be to return the string we pass in we have to convert it now it passes but we haven't looked at the pad length yet so now let's write a test with a non-zero pad length but i'm now going to keep the string zero keeping things as simple as possible so with a pad length of one we expect just a single whit space character of course that fails so now we need an if statement you can see how we're getting progressively it's not just more code but it's more complexity of code we've moved from hardcoded constant to a variable to a conditional and that's the progression we'd like to see if if you don't do that you actually start to run into problems where you have to implement a load of things at once so that's the reason we we try to do that so if at the the minimum padded length is less than the string length we can do what we were doing before just return the input string otherwise right now we're on a new branch so we're got to go back to the simplest possible thing the hard-coded string passes the test forces us to write another test so that we can we can generalize so pad length of two we now need two spaces of course that's failing so there is a constructor for stood string that takes a character and a number of repetitions for that character that we want to use here and if you like me this is how you would write it which unfortunately is wrong so that fails because actually the arguments see the way around but it still compiles the test cau it so that's great because that could have taken a longer too to find if it was very deep in something all right so now we've got the number of repetitions correctly next test to write we're going to combine a non-empty string and a non-zero pad length that's greater than the length of the string that fails because our else clause we're only returning whit space still what we actually need to do is add the input string and reduce the pad length by the size of that string and now it passes and now we're getting much more general in fact i struggle to think of more tests that i can write at this point that are going to fail which means as far as tdd is concerned i'm basically done except what step will we missed refactoring step we haven't really looked at that yet and it's okay to go a few iterations before you consider the refactoring step as long as you do that deliberately it's if you forget to do it at all you run into problems so what can we refactor here well first of all the test case is also subject to refactoring and if you've 've done much testing before especially with tdd you've probably heard of the single assert rule where you only have one assert per test case i like to call it the single logical assert rule it can be multiple assertions as long as they're all asserting basically the same state or the same property so in this case i'd probably group these into a few a few different sections in catch or test cases within a fixure in another framework i'm not that here because i don't have enough screen space so i'll leave it for the moment as an exercise i want to concentrate on the the code what come factor there there's a few directions you could take it in i want to start with the in the else clause the first string the the length min then minus str. length it's not so obvious what that means so i going to pull that out do an extract variable refactoring that's the pad length so the pad length is mn minus the length of the string okay so pure refactoring it hasn't changed behavior it's only the structure of the code so all the tests are still green this is how it works now having done that it's clearer to me that i can say well we got two conversions of our string view to a string we're returning be nice if we can combine that somehow the only difference is that we're adding that string if pad len was zero that would be a zero string so it' be the same as the first case i wonder if there's a way that we can we can combine those into one well here's my first attempt you stood max to to say well if it's more than zero we'll use the difference between the the sizes otherwise we'll just use zero and then we can use that with the stood string the the padded string zero string and our input string and unfortunately it doesn't work in fact we get an exception and if you haven't spotted yet what the problem is i think half of the room have and half haven't probably then you might need to debug this and it's interesting when you do tdd you actually debug a lot less but you still have to debug sometimes cases like this it wasn't expected but it really helps you because now you've got the exact file and line number of the test failed you can put a break point there and start stepping in and you'll soon see what the problem is and in this case it's because our our two lengths that we're subtracting they're both unsigned so if if you subtract a larger unsign number from a smaller one you're going to get a really big number and then try to allocate a string that size so that's what's blowing up so a way to fix that is to use st max of int that's all you need to do but i'm changing the signature as well to be m length as an in i think that's just a more honest interface so make that change as well and that is enough to make it back to grain so we've been out to reduce our implementation down to two lines if you like you could take it further and just inline that make it all one line depends on your your style or you could consider that maybe this is not the the best performance you're you got this redundant string in there you got string conversions going on maybe one take it by by stood string in the first place and return it as an r value reference lots of things you could do we're not going to go any further now point is all your tests are covering you they're now acting as regression tests so gives us a lot of freedom a lot of deliberation from worrying about oh i can make this test but it's a bit risky i might break something doesn't matter you can just revert back to your previous state anytime and you're never more than a few seconds away from green is the principle so that's been a really quick example of how tdd works lots of questions unanswered i know but this not the main focus of this particular talk but i just wanted to give you a feel for how it works some of these things we're going to refer back to so we looked at the tdd cycle red greener ref factor we've seen how that works in practice we even saw that are you done step we didn't actually get that many tests at the end if in fact i i just skip over one point when we realize we're we're done with the tdd tests it doesn't mean that there's not other tests that we couldn't we could write and i probably would probe around at the the boundaries a little bit more either side of things where the behavior changes but beyond that you're just sort of poking at random numbers and there's better ways to do that i would normally reach for property based testing or in catch you can use generat to approximate the same thing other frameworks may have something similar anything where you're instead of looking at specific examples that you need to know up front you need to thought of you get the framework to generate the values and then you just say what properties should always hold and it's a bit of a shift in thinking so i'm not going to go into too much detail now i've done other talks on it look at property based testing if you haven't looked at it before and in fact i've done another talk with that example where i talk about property based testing so i think there's a link at the end to that one but it means that your td tests are actually maybe less than you might expect because you got that are you done step in there so that was our first cycle the second cycle now we're going to change gears and get into the psychology so this is the habit forming cycle or the habit loop you may have seen something like this before and that's fine it can be revisioned but we're also then going to look at how this applies in the context of tdd and that might be new so how does this work well the reason this is so important in the first place just taking a step back forget tdd for a minute this is actually a a genuine life hack if you've never looked at this before because it turns out because of that that association mechanism we talked about these pathways through the brain that become habits get so well entrenched so quickly that to a first approximation it's almost impossible to break them and you probably can think of many experiences that bear that out things that should be easy to change but they're not so the way you change habits is not by breaking them but by replacing them you need to build a new habit that is stronger and the key to that is identifying these components because what we usually think of as a habit is actually just the behavior that's the thing that you do you also need to identify the q or the trigger which is the event or contact or environment that starts off the process in your brain something that triggers what sometimes call a routine here i'm calling a behavior and it does that because at some point in the past you've been seeking a reward consciously or subconsciously doesn't matter because as animals and now we get more to the neuroscience we are driven by the the pleasure pain principle you've probably heard of that as well so we we're driven away from pain and towards pleasure naturally at a sort of an instinctive level even if cognitively we're trying to go the different direction it gets tricky so because of that there's some reward that we're trying to move towards and if we've done that in a context enough times it doesn't take many times then whatever behavior got got us there now that becomes the link the queue or the trigger is linked to the behavior because it wants to get to the reward and once you've established that link you don't need the reward anymore so you might find it's not even present that makes it really hard to track down what the reward was because if you can find out what it was you stand a much better chance of replacing it with something new either the same reward the equivalent or a bigger reward even better because you want to set up a new a new trigger for the queue to get you to this new reward that's how we do it now the trouble is because the the pleasure pain principle is a much lower level subconscious level almost it doesn't respond to to long-term goals so in our case with tdd thinking about the long-term benefits of a nice well factored codebase low defect rates able to easily change it all whatever benefits you want to bring to it they're all longterm that's not going to motivate you here that's not going to form a new habit and this is one of the the biggest problems just in general with with habit building is we we think about long-term benefits but they don't motivate they don't drive the habit loop so what rewards can we get well here's my first stab at a tdd habit loop so when you want to write some code the behavior we want is that if i write it with a test first ideally but at all would be good then the reward i'm looking for is that i get immediate positive feedback might seem like a little thing that's okay doesn't ne necessarily take much it just needs to be something that gives you a response a positive response and because of the way we do tdd we're going around these cycles often in seconds which means we could do hundreds thousands of these in a single session we are repeating this loop over and over again so a little thing can add up in a moment we're going to see if we can take it to the next level as well but this is a good start so when we looked at the the tdd example a moment ago we saw that every time we we made a change the the tests were r and then we change the code and they went green and it's like this this positive positive feedback think yes everything's everything's working correctly all right let's let's see if we can take this further oh before we do that i should also say we mentioned a moment ago we don't actually need the reward after a while and the consequence of that is it's once you've established a habit it's hard not to follow it which means for us if we can establish this td habit it will become hard to write code without doing it with tddd which may or may not be what you want bear that in mind so let's let's take it to the next level with dopamine triggers so we're all familiar with dopamine i'm sure wikipedia has this to say in popular culture and media don't dopamine is often portrayed as the main chemical of pleasure we talked a moment ago about the pain pleasure principle so we can see how this fits in you know we we want to move towards the pleasure so we can see how dopamine fits in but there's something a bit off here look at that phrasing in popular culture and media dopamine is often portrayed as does that mean that it's not the main chemical of pleasure there's a bit of nuance if we carry on reading it says but the current opinion in pharmacology olog is that dopamine instead confers motivational salience now what does that mean this actually really interesting so the motivational part we should be easy to understand but one thing to note is motivation has the same root as the word motion excuse me so it's all part of that moving towards something either physically or metaphorically moving towards pleasure and it's case so we're going to understand that bit what does salience mean well if you don't that word is not familiar you probably be familiar with the word salient like the salient facts they're the important or relevant facts so what what does it mean when you put this together what it turns out what this means is that you are motivated to establish the important facts or the important things going on in your environment excuse me you've probably heard of the experiment with the wellt trained monkeys who pull a lever to get a treat and if they get the treat every time they pull the lever they're really excited to start with they just lose interest a bit after a while they know well if i want the treat i'll pull the lever right they' they've established the pattern they understand it they know it yeah so what they don't really get any further motivation and they don't show signs of high levels of dopamine but if you only get the treat 50% of the time at random they stay motivated and dopamine levels are really high put it in this context what they're doing is they're still trying to find the pattern the dopamine is raising their awareness so they can be on the lookout for the salient facts that are going to help them to establish the pattern so they can keep getting that reward what this means is any case where you may get the reward w some or most of the time but not all of the time you get high levels of dopamine which increase your ability to learn they prime you for learning so how does this all fit in well let's look at some some things that i've identified as as dopamine triggers in tdd we talked about seeing a test pass i' actually go further and say that seeing a test go from red to green is even better because you've seen that it fails and now it's passing precisely because of what you just did there's a stronger connection there and if you do see something in green this is why i recommend using some sort of test framework or test runner that will show you things in green it's an even stronger association then there's the the race to green the the green step where you're actually free to just sort of hack a code and get things to work and not worry about clean code so it's actually quite liberating and fun or you may be more more motivated to clean up code in which case the refactor step can be really fun in fact they can both be fun and they can both trigger dopamine because all of these things may not always work as you expected so you're constantly thinking does this work ah yes it does does this work oh it didn't this time why and now you're primed for learning for analy ing and working out what it was that went wrong because of the dopamine so it plays two roles one to help you stay motivated and establish that habit but also to be able to be more aware of the code and learn from your mistakes then you would have been otherwise i think this is one of the key things now i think we're running a little bit short so i'm going to rush ahead a little bit and talk about the third main area extern internalizing your brain so it's a slight change of topic and if we go back to sort of evolutionarily speaking our brains are what we call open loop mechanisms which means they work best with other brains not just in isolation we can survive in isolation to a point but we we start to deteriorate and we thrive with other people and some people's personality may be more strongly correlated with that than others but the principle is there just in the way we we operate as humans this open loop principle so you know many minds can be greater than again the sum of their parts but it doesn't just work with other people we discovered long ago that we can actually use other ways of noting down what we're thinking so that we can free ourselves up to think about other things knowing that we're not going to lose sight of the big picture we can come back to it and then we developed more advanced ways of doing that like mind mapping the whole word mind map comes from mapping your mind onto paper for exactly this purpose to free our mind up from other irrelevant details from what you're focusing on so you can focus on it and of course in the digital age we can use computers for the same sort of thing whether that's just for note taking or mind mapping but also turns out tdd fits right in here as well here's why so we talked about the three main components of tdd the red green and refactor stages now each of those stages you play a different role and you have a different mindset for each of those roles so the first stage stage the red stage you're thinking more about user experience not necessarily from a ui perspective but more from the user of your code caller of your function whoever is using your class thinking of it from the other side rather than the implementation details we also thinking about high level design how that fits in and what the actual requirements are to the point that you may be thinking is this something we actually need or do i need to get clarification on from some business expert or whatever it is you're not worried about the implementation details you're just thinking at that level and you know we play these roles all of these roles at different times moving between them seamlessly can be hard but when you pass to the green stage you automatically flip into this sort of race to green hacker sort of mindset where you're thinking about implementation and we've encoded the requirements in the test we don't don't have to worry about that anymore which means we are liberated from having to take on that role and that's what helps us to move in we get both the trigger to move the switch of task and the ability to let go or thinking about requirements because it's encoded in the test we can completely immerse ourselves in implementation and similarly moving to the refactor step now we're thinking about lowlevel design clean code principles well factored code not having to worry about raar implementation because we we were all green not having to think about requirements the tests are covering all of those as well so it's another subtle shift and this is why i put the r we done step in here as well because when we go to the r we done step we're actually going back over to that requirements mindset m portion and we have a place where we can cleanly cut across back to requirements thinking and it's there we make the decision what's next because often we can make the decision what's next while we're in that implementers frame of mind and we end up gold plating a solution that wasn't really necessary this helps to prevent that this mindset shifting doesn't come straight away takes a little bit of practice with the tdd cycle you need to be competent at that before you start to notice this shift in mindset and shifting role and shift in what mental resources you bring to those given problems because they are different and this really really helps you to quickly move between them remember we can go around the whole loop in seconds we like playing three different roles in that time so that's how oh and the the other part to this is as we mentioned with the writing a failing test encoding the test you can think of that like a mental save point right i've done all my thinking at this level externalized it to the code now i can move on to the the next one that's how we externalize our brain so that's the three areas that we looked at habit forming and how to build a new good habit for for tdd leaning into dopamine triggers to help with the habits but also for their own benefit and to help you have fun with the code and externalizing your brain so that you can actually focus on the different parts as you need them so let's now see how we're doing with this list so i think the bottom two i think are fairly obvious that well if you follow everything i've been talking about code writing tests first should be fun especially if you're lean into your dopamine triggers and you you do the the race de green and the refactoring freed up from the other responsibilities that really brings out the fun en coding keeping you focused on what matters what we were just talking about by focusing just on what we're doing at any particular time and locking in everything else into the code so we don't have that point like that cartoon with the the person debugging something in his head he's got all the parts there and someone comes along random comment and it's all gone no it's all in the code in a form that you can readily get back to i'll often leave a failing test on a friday night soone come back in in the morning i think ah i've just got to make that test pass gets you back into the right mindset so we can take those off if you buy into everything i said which is not a given what about the other two it's still more work you still got to to write you know as much test code as the production code that's got a slow you down isn't it especially doing all those iterations where you're writing code you know you're going to change it's got to be a waste of time well you probably heard of left shifting now trace the term back to this 2001 article in dr do's journal shift left testing but the idea behind it goes back much further and i think my first encounter with it would have been in this book code complete who's read code complete so it used to be if you ask that question in the '90s about half the room would have put their hands up used to be the go-to book there was a second edition in 2004 so it has been updated but yeah it's not quite as relevant as it used to be but a lot of it is still really relevant and this is the first time i saw a graph like this so this is from the u the first edition it's been slightly updated the idea is you got the different points of the software development life cycle from analysis or requirements govering through architecture and design implementation there's always a test stage at the end even if you are doing testing earlier and finally maintenance and the idea is that the more on the right hand side of the graph you go the more expensive it is to fix a defect not just expensive in in financial cost which is really what this graph was talking about but also in time in general which means the earlier you fix a defect the less it's going to cost you in time and money so moving things back to developer testing as much as possible which is really what this was talking about will save a lot moving it to before you write the code is even saves you even more because you don't put the bugs in in the first place but some of those issues are actually going to be in the design so of course pushing it even further to the left into the design and analysis stages is clearly even more valuable and tdd even helps with that in a number of ways one when you're in that analysis mindset you're much more likely to question requirements rather than just blindly implementing them because you're freed up to to think about them you may go and have a conversation with a business expert another is that the principles of tdd don't just apply at that level and in fact bdd behavior driven development is much more about having those conversations up front with domain experts before you start writing any code while you're still establishing their requirements putting it into a structure very similar to what we're talking about with tdd but earlier so all of these things all combine to save you time by avoiding lots of rework before we take that last one off i want to ask one more question which is why do cars have brakes now i usually ask this when i'm doing td training and then i get responses from the audience and of course they know it's a bit of a trick question so they're trying to see what the trick is but the the the obvious answer would be so you can stop or slow down of course the answer i'm looking for is so you can go faster because how fast would you drive your car if it didn't have any brakes but it's the same with tests well tests will stop your code your test code at least running if if they if they fail if they didn't do that then you wouldn't be able to go as fast when you're writing code because you wouldn't take the same risks they give you the confidence to make big changes knowing that the test w will catch you if they if you break anything so you can actually go faster by having tests which i think tis off all of the boxes we avoid rework by catching issues earlier or preventing them in the first place speed you up by giving you the confidence to make design level changes keep you focused on what matters as we said because we can externalize our brain and we can have fun doing it all so that brings us to the end there's the the link that i was telling you about level of ind direction.com refs rewire html so i'll leave that up there if you want to take a photo for for more reading but that is the end of the talk so thank you very much and i think we even have time for some questions if there are any yeah i noticed you use the require macro in your in your test example wouldn't it be better to use the check macc macro so you don't fail the entire test case you want the test to continue running right so the i used to require macro when i was doing the the catch tests and in in catch you can do require will abort immediately if it fails whereas check does the same thing but it will carry on so it will report the failure but also run subsequent assertions i go backwards and forwards on which one my default should be if you follow the single assert rule then all of your assert should be on the basically the same logical state and that sort of favors doing checks because then you want to find all the different dimensions that could have failed in but sometimes you you know one test sort of has to follow on from another you want to say well if this thing was null you know then then don't carry on and do this other thing there's other ways to do that as well so i do maybe lean more towards check these days than required but it's it's a philosophical question i haven't quite got to the bottom of yet thank you thanks all right so we have an online question even while td or also bdd is training i feel sometimes the most difficult part to migrate to search is to get buy in from both the team and the business as people few change do you have any philosophical or psychological advice to deal with this i think to keep with the fame here but my best advice there would be to infect other people with the idea that this is going should be fun maybe sort of set up sessions outside of your normal project where you like play games or do exercises to to establish that part and then when people buy into the fact that this is actually fun and productive well then of course why wouldn't you you try that elsewhere but it's a still an open question that every situation is different and it's not easy but i think if you get to the point that you're experiencing these things yourself it's much easier easier to then convey that to somebody else yeah yeah i was just wondering now you were talking about yeah test driven development and you're writing codes from scratch and adding test for that while you're developing but often times at work i i find myself trying to add functionality to existing code but there are no tests so i want to start writing unit test for for code it has been there for a long time but often yeah i find it hard to write requ requirements for code for which there are no clear requirements so how do you do you have any tips and tricks on how to start there so we have we have three minutes left and when i do my two-day tdd training i devote about one two-thirds of one day for that question yeah the short answer is it's it's hard this the slightly longer answer is there are techniques that can help but that's where it's becomes out of scope for right now but at the very least look into approval tests if you've not done already they're a really great way to lock in what the current behavior is without having lots of unit tests so that you can iterate towards the place where more of the code is is properly tested but see some m talks for more all right thanks you're welcome i have a question going back to your example when you said one thing which i found interesting and maybe i misunderstood you but you said you write one test then implement functionality then write run test and you don't write multiple tests and implement a functionality and day yeah okay i i didn't misunderstand you there because i don't understand why would you you do this and the thinking is basically what you said you want to free up your mental capacity and when you implement a function you already know multiple things you we want to do you know edge cases and stuff why not write all those as tests and then implement them all at once or multiple at once not all necessary so there's nothing wrong with thinking ahead and thinking i need all these things tested and maybe you want to write those all out at once one of the problems with that is that your design may subtly shift as you're going so tdd doesn't prevent upfront design but you have to be more agile about it and it may not end up exactly way you thought you would and that means you may have just spent a load of time writing these tests and you have to rewrite them all that that that may be fine at the very least i would probably comment out all of the tests except the one i'm currently working on because you want to just just see the failure for the current test for the current thing you're working on and then uncomment the next one uncomment the next one so you might want to do that but in general your writing these tests tease out the design that you already have had in mind to make sure that every aspect of it is locked in with a test so you have this dance between the the test code and the production code sort of you know each thing sort of forcing the other's hand to inch towards that design and it's it's a little bit harder to plan that out but there might be certain sort of milestones along the way that you do want to make sure you don't forget so that that would be fine okay does that answer your question yeah yeah kind of thank you just quick one so what if we break the test itself so you know so should the break should the the the test be kind of a golden the golden row that we start from writing the test so that we do not break the test themselves if we do some kind of free factoring let's say we change the the whole architecture you know the design we put in in the in the implementation that would of of course affect the test themselves so that's is that so if i understand the question correctly you're saying is yet what what happens if you break break a test not because the codee's at fault but because the design has changed or it wasn't quite what you thought is that yeah is that fair yeah because what we've been doing we've been going progressively right so we we do we start from the test and then based on that we go with the implementation right all right so there's usually two reasons that that would happen one is that the the requirements have actually changed if the requirements have changed or your design for the requirements have changed then you have to deal with that you know the tests are now testing the wrong requirements but more commonly it happens because you've been testing implementation details rather than the public interface that maps to the design and and there's there's reasons you might legitimately do that particularly if you're using tdd you tend to sort of build things from the bottom up before you actually meet the high level requirements and they can change without the high level requirements changing you just have to be aware that that's what you're doing and be prepared to potentially throw tests away or rewrite them if that's the case but try to avoid times when you are relying on implementation level tests solely because they become very brittle and you're much more likely to to break them without actually changing the the top level behavior so progression here is really the key progression so we cannot by any mean have two independent teams for example working on you know the testing side and and the implementation it has to be always going step by step like that so maybe that's another question would it be possible to have independent teams working on both sides with the tdd concept i think that's getting into a a bigger topic than we probably have time for now so maybe we pick this up afterwards but thanks for the question and thanks everyone for [music] [applause] listening