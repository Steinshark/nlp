uh hi everybody if you have any questions during the talk feel free to post them in the chat it's not going to let's say annoy me i'll follow the chat on hoping so feel free to ask questions now before we start i just want to warn you that the first part of the talk it will kind of look like i'm talking about something completely useless but bury me till the end because at the end we can see the power of the members through a looking glass for people who don't know who i am i'm a senior software engineer at kdab and i've also written a short book about functional programming in c plus plus which is available in several different languages so let's start most of the software development is about composition and i want to start with one person that i mentioned quite often in my previous talks and it's not dennis ritchie it's the guy on the left called doug mckilray now obviously everybody will recognize dennis in this picture but doug for some reason is not as famous as dennis's if you don't recall the name just remember this part of the code that i've shown at all different civil sports conferences and remember the story about calculating were the frequencies that donald knuth implemented in a dozen several dozen pages in pascal and then doug mchilroy gave a critique of the original implementation just by providing a six line implementation of of the same problem now this is something that is really astonishing even if this solution is a little bit slower than than the original one etc but doug was i would say a genius who created the idea of what unix program should be should be like so he wrote the rules make each program do one thing well and that one program's output should be piped to the next program as as an input and this is the philosophy that lived in unix for a long long time and as we've seen in the previous example it's quite a useful thing to have so write small programs and make them composable and this is the same with normal software design you're just not going to have separate programs but the idea of let's say most social design ideologies are to separate a huge program into small chunks that can be composed in some way a recent tweet from tony van earth although i'd say most of the people wouldn't really agree with this one but it's it's an amazing food for thought nine times out of ten a for loop should either be the only code in a function or the only code in the loop should be a function or both so the idea of this is again separating code into small chunks with each chunk doing one thing really well and then composing it in different ways in this case composing all the different functions with a for loop in z plus plus we don't really have function composition we can apply several functions to a value so we can do something like call to string on something and then use the result of that and pass it to a function called write but we can't really write a composition off right and tostring now on online we have we can find a dozen different implementations of a function that composes two functions for c plus plus and one of the simplest ones would be this compose function so we accept f and g and create a lambda that accepts arguments any number of arguments and perfectly forwards them to f g of something and now when we want which we can just use compose of two functions and we are going to get a new function that is the composition of the previous ones now this is not the core language this is something that we need to implement on the library level and this is a strange thing to me to to notice most of the languages talk about composing objects or composing functions etc but outside of functional programming languages like haskell or lisp barely any language in the mainstream on the top 10 list supports any kind of composition with its syntax most of the compositions are done by the users or by developers manually so let's move on to members for normal functions we've seen that we can call them f of something of g of something and we can compose them by creating a function that like we've seen before with members we can't do something like this so we cannot have a point to a member function and call it as if it were a normal function we can't do something calling column to string and then pass it an argument and this is something that should have been supported by the core language but since it's never got into the core language the library working group was a little bit let's say naughty and they decided to add something in the library space that will allow us to write something like this and daniella mentions that today in the evolution working group there has been talk about this and i definitely want to hear everything about it after this talk so the library working group decided to to treat member pointers just as normal functions so when you think about it any pointed to a member function accepts an implicit argument this and returns a value so why shouldn't we treat it as a function and they invented something called vested invoke it's a little bit uglier syntax than using normal call operator but still we can now have the same syntax for normal functions for any function object any callable so we can use this for member pointers to functions or to objects so if we wanted to write a more generic compose function we could just replace the normal call call syntax with std invokes when can we use pointers to member functions we can use them in ranges accumulate so for example if we have a list of apartments and we want to accumulate all the monthly payments which is a member of the apartment we can just use ranges to accumulate everything and use the member the member function as a projection so mind that this is not used for the folding or the accumulation function but it's the last argument of accumulate so the projection if we didn't have the same setup if we had apartments and inside of the apartments we have a tenant and that tenant has a member called monthly payment we could compose with our new compose function we can compose accessor or getter for tenant and the getter for monthly payment inside of the tenant but what about pointers to member objects they also can be seen as normal functions so if you pass in an instance of something t you get an sdd string so you get the value of that member but that's the not the only thing that we can see our pointers to member object cells we can also see them as something like setters so a function that accepts an object an instance of something t a new value for that member and it gives us an updated version of something t so for normal members or member values or member objects whatever you call them we can see them as a pair of functions one function is a getter and the other function is the setter so let's try to make an abstraction over this idea of this pair of getters and setters and unite them into a single thing just like ranges are a united iterator and a sentinel maybe we can achieve something really cool by uniting getters and setters now setters are not really that great for composition so we are going to change this a little bit just like ranges are not by pairs of iterators we are not going to use the obvious solution here to say getters and setters but getters and auditors what is the difference an updater is not something that will take an instance plus a new value it will take an instance of an object and a function that updates a value so a function that accepts the old value and gives us a new one so the idea is when we have an updater we have an old object we take the value of a member that we are looking at and apply this function to it it will give us a new value and we are going to return an object with that updated value so when we want to implement something like this obviously we are going to create a generic class there are a dozen different ways to implement this i decided to create something called type typed property the idea is that i want all the tags to be known at compile time so these are this is not going to support any let's say generic properties but all the types needs to be known in advance so that we can do some static asserts etc so that we avoid long long compilation errors so object and value will be metadata about the class so not something that can be used at compile time in template meta programs and you're going to have two members which will be mvu so the view function or getter and m update which will be the update function for view it's quite trivial to implement we just need to sdd invoke and view an object and it will get us the value for the update quite a similar thing we get the object and the updating function what we we are going to do so i have a question from is this going to be how to map classes to functional programming i'm not going to answer that at this point but kinda and obviously victor's answer is also spot on at least to some extent now to get back to to this slide for the update function we are accepting a reference to object if you are asking yourself by a reference to an object and then doing a sdd move on said object you can watch my previous talk at meetings eposvox online from the last year on linear types and move only type design so the idea here is to avoid all the performance penalties of always returning new versions of objects so to avoid any copies and similar things so what we're going to do we just need to invoke and update and on object and update function so this object member function is as trivial as the view member function was the set function which will be the classic on the traditional setter is a little bit more complex but still quite trivial to implement instead of passing a new function to the updater we're just going to create a function that ignores its argument and returns a predefined value so when this is invoked what will happen the old object we will extract the old value from it ignore that value and this lambda will return whatever value is set so it just ignores the previous value in order to support to make this a function object we can also create call operators on it if somebody passes a single argument to this property it's going to be treated as a view and if you have two arguments it will be either an update function or it will be a setter depending on the type of the second argument so i'm going to skip this slide it's just some meta type trickery to extract for a pointer to a member whether it is a member variable it's going to extract the parent object so the object that pointer belongs to and the type of the member variable so that we can use it inside of a constructor function for the property type property for creating a typed property consider this function like make pair or anything else something that you can call without the need to specify the types for the type property template clause what this this function does since members can be seen as normal views it's not going to do anything for the getter or for the view function it will just pass in member as the get function but for the setter function since so for the update we don't really have the update function directly from the member so we need to construct one we said that pointers the members behave like normal setters and we need to convert a normal setter to an updater function and again it's not anything it's not really complex you're just accessing a reference to that member and then invoking the updater function on it and that's mostly it so this is the first step we have created an abstraction over something that looks like getters and setters obviously this is this was the example only for pointers to member values but we can also create this similar functions for normal getters and setters so member functions i'll leave that to you to implement the question is now since we've been talking about composition how can we compose these things so we need to define what what to view will a compose composition of two type properties be and what in the update function will do for the view it should be fairly trivial so just as a legend we have a big object called outer inside its member will be called inner and we have a value which is a member of that inner object so view function over the outer object is a function that gives us an instance of an inner object and the same goes for the next one view function of inner object will give us an instance of that value so composing these two is quite trivial we just need to match the codomain of one function and the domain of the second one so when we compose we are going to get an odd let's say a new function that takes an outer and gives us the value for the updater it's a little bit more complex so we have an updater function that converts one value to another and we need to construct a function that takes an instance of the outer object and convert just update a nested value inside of it for the update function what we can do we can call the updater on the inner and we can convert that into a lambda so instead just like we had originally done we did the compose function for any arbitrary two functions in c plus plus we can do the same here instead of applying this to a specific value and to a specific instance of inner we can just convert those two into a function or let's say to lift it into a completely new function so we can create a function that will update one inner into the other and then we can use that function the same principle to update the outer object into you'll use that to update the value inside of an outer object so doubly wrapped value as for the implementation just like we said we are creating an auto update function which will be a lambda that accepts an inner object and then applies the updater for the inner object on that value that we've passed and then this function has exact same signature that we need to pass as the updater for the outer object so what we got now we have a function that returns us a value given the outer object so the big object and we have an updater for values inside of a bigger object from this point on we can even ignore that the inner object exists in essence this is kind of like if we had a direct pointer to a member for the value because we've composed two different pointers from the outer class and from the inner class so from this point on when we have this composition we can just forget that the inner object even exists so let's see a few examples of how this can be used so we have a monthly which will be a composition of extracting the tenant from an object and then extracting monthly payment from the template as for the greater than greater than or shift right operator obviously you can use any operators that you like shift operators are quite useful for this because we can switch the order if we wanted for example to have f of g of something and convert to g of f of something just by flipping to each side the shifting is performed and then we call accumulate apartments initial zero we use std plus for the folding function and as before we use this monthly thing as the projection on all the apartments because as a landlord we don't really care about tenants or anybody else we just care about the monthly sum that we're going to earn if we realize at some point that we don't earn enough money then we can just create new apartment and use the same monthly thing say std move all department so push all departments to to the updater and provide a function that will increase the rent for 20 and this is let's say the crux of type properties something a single object that can add to both times push something and get a value now there is nothing here that would convince you to actually use this yet apart from that it's cool and yeah it might be really efficiently used to confuse all your co-workers but if we kind of move that to another level you'll see that this can really really be useful so far we've seen composition on functions and we've seen composition on properties but we can compose all of those in a little bit different ways usually when we talk about function composition we have functions that need to satisfy the mathematical rules so the first function's codomain needs to be the same as the domain of the second function but let's see whether these functions are composable if you have partial functions so functions that return option of something these functions are not mathematically composable but if you've seen any of my previous talks you know that this is composable just with a different definition of composition if you remember monads if you remember clearly composition these two functions can be composed just not in a normal way if you have vectors the same story applies here if you want to compose two different functions that take normal values and return vectors we essentially just need to do transform and join and this is something that we can do if not if not with anything else we can use eric's range e3 for implementing something like this obviously we are not going to have really vectors here but any types any type of ranges but i'll write vectors from now on to denote any collection in sql plus any linear connection collection sorry so if we expand our definition of composition we can switch from this example where we have a building with apartments we have apartment with a single tenant and a single tenant that has a monthly payment and we have the code that just composes these three typed properties and we can switch to a situation where each apartment can have multiple tenants and each of those tenants pay the landlord a certain fee and because we are a nice landlord we can allow them even to have several monthly payments for example a weekly payment or something like that so each talent can have again a vector of monthly payments and our accumulate code didn't really change the only change that we have is that we added plurals in the variable names so just by redefining what composition means in the case of a type property that has a vector or any other kind of ranges as its type we can reuse the old once written code for something completely new [music] if we wanted to for example buy a jet ski and we realized that we need to raise the rent we can just create a new expensive building and apply payments to the old building and increase everything by 20 again so let's present this graphically if we have a building so this big rectangle is a building inside of it we have several apartments inside each apartment we have one of them all more tenants and each of the tenants has at least one monthly payment when we apply the apartments we are just going to select all the apartments in a building if you compose that with tenants you're going to access all the tenants and at this point we don't really care about apartments anymore in essence now we just have a range of tenants collected from all the apartments in our building the next step passed that through monthly payments and now we again get the exact thing that landlord wants so a list of all the payments that we have inside of something and just like before we can accumulate all them and see how much we earn months and we can calculate and update how much more expensive the rent needs to be for us to buy a jet ski [music] now the question is can we move this even further instead of having monads like optional or vector or something like that what would happen if we just use functions that gives us view that give us futures again in the same way these functions are not mathematically composable but if you use magnetic composition or twice like composition we can compose them as well so the same code that we've shared before we can have futures of apartments futures of tenants futures of doubles and when we compose all of those we can get a future of all the payments inside of our building and obviously if accumulate supporting futures then this would be abnormal accumulate or something which would return a future double but since accumulation doesn't really support futures at least at this point we need to implement our own and the implementation could be quite trivial with coroutines just use the normal accumulate and sprinkle coal evade cultivate on all the values that you are accessing so this idea seems to be quite easily expanded now i started this by saying that it's quite annoying to see something that is not supported by the core language and it's kind of common thing to hear in simplest plus we don't have variance as a core language feature we have it as a library feature we don't have pattern matching as the core language feature we have it to some extent as something that we can create overloaded land does and similar things and this is another of those of those things that are just not supported by the core language the cool thing about something not being supported by the core language is that it forces you to implement it in the library and when something is a library thing you can do whatever you want with it so as long as you're as you can create something that that works reasonably well and has a reasonably good syntax you can redefine composition you can redefine what accumulate means you can redefine whatever you want and the code that you've written once for normal values can start working for reactive streams or anything else another good thing is that this kind of eases up refactoring if you decide to refer to your class so that several members that you have inside of it should be moved to another type and that that type should be a member of a variable inside of the previous class you don't really need to change any of the colors you just need to redefine the type property to be a composition of the two accessories instead of being a direct pointer to a member variable this can also be quite easily expanded to filtering to optional values to have different accessories for vectors as whole or vectors as we've seen as a range of values etc etc and one thing that can be quite cool is that if you want to allow your customers to let's say write code but you don't really want to allow them to write c plus plus proper you can create things like these and put it inside of a gui that will look essentially like the diagrams that we've already seen and when people start composing those they will have the graphical representation of all the things that their current query is going to affect [music] and before i end as victor mentioned this is something that in let's say in literature you can find on the names of lenses i didn't want to mention the name lenses before the end of the talk because i find one of the biggest hurdles for functional programming in for normal developers is all the jargon that people have so i'm going to continue calling these properties because we all know what properties are and this is it i'm open for questions