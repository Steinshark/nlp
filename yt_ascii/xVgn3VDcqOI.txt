uh good afternoon everybody and welcome to my talk c++ common knowledge my name is david zesi and yeah and that's about it so you're going to hear about common knowledge items that i think might be important might be not i think they're important why this talk you know i have a hobby and this hobby is quite uncommon now nowadays i'm reading books and i especially like reading very old programming books like for example this one something that tells you about how the c++ came to being or this one a bit more advanced about the c++ object model or or actually this one there is a book with the exact title somebody already had this idea before those book used to be quite common right so in the past years you would go to a blog to to read about what's happening in the world but there used to be times where you could read those books and that's how you would get your knowledge about everything the last book here is actually targeted at roughly intermediate audience but i wouldn't say so there are very advanced items there there are very beginners items there it's a mix of everything but it's something about you know something you should all know about but sometimes we are not aware of it and and especially if you're coming from different programming languages or if you're not touching some part of the language sometimes you might not be aware of it of some of those i kind of decided to make a talk like this but it's a bit different one so i'm not going to talk about the same stuff that are in the book and especially i'm going to modernize it a bit so there are different items totally different there around 100 there no time here right to cover 100 items much less and i have a very short program to show you what's going on this program is really full of bugs it's like the most buggy one i i think i've written ever it fits on less than a4 and on two slides this is one of the classes there it's a very prominent class it's a based class for other classes just has two data members and a very curiously looking conversion operator there is another one there because obviously the first one converts to the named object so you must have a named object somewhere well that's the name object something to admire right just the name inside and a equality comparator so operator for comparing itself with another named object and just because you know i i know how to program i added for a good measure also a free function comparison operator that compares to object that piggy backs on the first one so it's a canonical implementation right you just call another comparision operator nothing wrong here you most likely have seen wars i mean people write desktop applications in javascript right so this is not that bad it's all this work is not done for nothing there is something that uses named collection base that's a named hip it in from it and it's a hip data structure so something that makes it easy to pick up the biggest or the smallest number this actually keeps track of the smallest and the biggest value so it allocates or actually it has some data members for it data max data mean arrays dynamically allocated a proper destructor a proper constructor that constructs everything and of course it follows the rule of five so it also has a copy assignment copy constructor move assignment move constructor everything that you want and then i'm using those two classes or actually three classes in together together mostly i'm going to use the named hep and that's not much of a usage i assume there is a function that needs a collection passing by a unique pointer very modern right so you can hint polymorphism coming up because i'm passing by a pointer and i'm using the base class name in the pointer and there there is a hip being created a copy of a hip being created also all unique pointers very nicely and then i want to pass actually my copy to the function and because i'm a careful programmer and don't trust myself i will first compare if those two are equal if it's okay i call the function needs a collection surprisingly this code compiles it compiles it builds at least if you're compiling with c++ 20 or maybe 23 even i think i you need it for one feature and it builds without any errors there are not that many warnings also triggered and you might miss them not very important warnings clank and gcc show you two warnings msvc shows one and that's all the program unfortunately i think crashes or runs forever or something like this despite not you know being compiled and despite being very short if you apply your common knowledge and common sense to what you've done or what i've done there are more than 10 violations very big violations of things you shouldn't be doing at all whatsoever and you know if you're a bit familiar with c++ and about what c++ is about you should have picked up all of them or not all of them is maybe too much but at least five of them there are more than 10 and in particular what i've been doing is not initializing data members cause triggering undefined behavior multiple times allowing implicit conversions which is not that great right confusing assignment with initialization violating one definition rule a little not that much totally neglecting aay ii and exception safety leaking memory i was leaking memory believe me or not i was doing it i was totally ignoring cons roles triggering infinite recursion on the way that's there on the slide slicing objects and making name lop look up cry totally cry so let's try to fix those and fixing is fixing is quite easy i'm just going to walk through in total 12 different items that are not intended to be read now that there are why they are mingled which will help us fix the program and we're going to go from the simp simp rules to the most i wouldn't say difficult because we are still somewhere in the beginner's intermediate level of c++ but things that will help us figure out what's going wrong what's wrong and hopefully will help you figuring out these kind of errors if not in your code then sometimes maybe if checking beginner's code which you are reviewing when you hire new colleagues for example the first one a very common one uninitialized means indeterminate right we all know it in c++ you have to initialize everything because the compiler is not so nice i was actually triggering undefined behavior not like this but i was triggering it in a similar way you see the named collection base is doing something totally awful it has two data members that's great but it also has a constructor it's a user provided constructor it doesn't do anything right it doesn't initialize anything and that's already like code smell because it means that the name will be properly initialized the compiler will call the default constructor for the standard string but unfortunately the size will stay uninitialized its value is indeterminate reading it is undefined behavior formally you know if you get rid of this ugly constructor everything will be fine now our cloud becomes an aggregate uh and because we have braces when we initialize the ncb everything is good no problems whatsoever if you skip the braces again undefined behavior that's something that might be surprising but that's how aggregates are initialized the lesson keep the braces around somewhere and the best way of of course or the best place to put the braces is directly in the class with the so-called inclass member initializers right if you do it if you even put some initial initialization there you're good to go there is no undefined behavior triggered whatsoever whatever you do so it's a better way of doing things let's do it item number two declaration order is initialization order a very very very common error especially if you are beginning with c++ i've done it also i committed the same crime on the slides and i i think the crime is now pretty obvious when you look at it right so what i intended to do is of course to have three data members data mean data max and the capacity that's my declaration order and i was hoping for that different initialization order like in my constructor i first initialize capacity and then i'm using the capacity to allocate to arrays unfortunately that's not what happens right declaration order is initialization order especially when it comes to classes or only when it comes to classes actually when it comes to everything right so in whatever ordered i declared the members in my class in the same order they will be initialized it doesn't matter what you write the compiler is smarter than you which pretty much means that at the stage when i'm initializing data mean and data max those two are actually the capacity has an indeterminate value i'm reading something value that doesn't exist i know nothing b will most likely happen right because very likely there is a zero there if you are lucky but it could be that you're alloca allocating a couple of gigabytes and that might not go that well your hard this dis most likely won't get formatted contrary to what people tell you about undefined behavior right so don't worry about it nevertheless it's bad a simple fix put your data members in the right order h and then everything is fine which brings us almost to the next item right this is fixed we are done or not to the next item to the application of the first item when we initialize data members why even initialize them in the constructor when the initializer is fixed to 16 in this case just put it there in the initializer list directly in the list of the members and you are done this will be fine whatever you do now unless of course you mix the order the next one assignment is not initialization two things that are very often mixed right and people especially coming from different languages tend to put assignment when where the initialization should happen we have even special syntax for initialization nowadays the carly braces right right sometimes it looks very ugly but in the constructors it doesn't what you've seen on the slide on the first slide or on the second sl was the first second slide let's say was something like this and it's still there what i'm doing here is of course my named hip is inheriting from the named collection base so obviously is must initialize the data members of the named collection base right so it has to initial initialize the names and the size and for the simplicity i'm just initializing the name here i'm doing it in the body of the constructor but that's not really the place to do it right that's that's actually the body should be totally empty like most of the ca cases maybe some logging statement something like this those of you who've been programming a lot know that all the initialization happens in a different place particularly here so even even if you don't mention anything there even if you don't initialize your members or your base classes in the member initializer list the compiler will do it for you it will just sneaky call the default constructor for a class or in our case it will initialize the aggregate the named collection base by calling it yeah there is no default constructor for an aggregate but let's say default constructor right that's a bit wasteful we are first initializing and then overwriting those values again in the body of the constructor so first for example the constructor of the standard string will trigger in the default constructor and then we are you know overwriting this value why do it at all if the compiler can do it we can also do it just put it there where it belongs to using the aggregate initialization syntax this has the benefit that the size will be initialized to zero also without explicitly mention in it and we are kind of good to go so assignment is not initialization item number four implicit conversions are almost almost always evil you shouldn't do them i've done it twice on the slides on the slides with the program the first one was quite obvious and it didn't trigger any nasty behavior actually so i have a con constructor the named hep which takes a standard string is the so-called converting constructor right it converts from one type to another and it does it i mean there is no harm you might think and i agree you can write you know silly code like this there is no harm in it it's just to confuse your beginning colleagues maybe it will compile just fine doesn't make any sense but you can do it where the harm really comes into to play is situations like this imagine you have like a function crunch the numbers intensively something you are likely to see in many code bases and it takes a named hip of double by constant reference well now you can call this function with something like this one little two little or know one medium and one big number it will compile just fine right it doesn't make any sense whatsoever might be just a practical joke it's a good joke i would say even won't do anything because this hip is empty that you are passing to the function but nevertheless it shouldn't happen disable it just don't allow something that stupid sometimes converting constructors makes sense but here absolutely not why would you convert from a string into the hip make this constructor explicit and you're done the conversion becomes impossible at least implicit conversion there is another case of this of the same thing and that's this one look at it i'm comparing two hips or actually i comparing two pointers to the named collection base and that's quite weird because if you remember then know the named hep cannot be compared there was no comparison for it the named collection base actually also cannot be compared but it has this operator inside that converts it implicitly to the named object and the named object can be compared right we had the operator equality comparison implemented so named objects can be con compared and just because of this this whole chain of events we now can compare to named collection based or or for that matter even the named hips doesn't make much sense right i i mean most likely two hips are not equal when their names are the same that's that's not really the case disable it disable it by marking something like this explicit i'm saying it should be explicit but you will be seeing it again without the explicit when we are talking about a different item item number five everything needs to be defined just once it's about the one definition rule something that scares people and it should because it's it's very very difficult lingo in my opinion but the concept is very simple my code i mean looks good now right i already applied at least two different refactoring to it to to fix many problems but it's still not really as it should be specifically i have a magic number there at least in this version of code and this magic number shouldn't be there i should name this constant i i should name this number somehow so it's easy to track so so it's easy to reason about it so let's put it outside and that's actually what also i had in the beginning slides it was put outside now the problem with this is that such a piece of code usually leaves in a header right and you already can smell the disaster coming when you include this file multiple times this is something like a named hip looks like something that's going to be used a lot around our code base so imagine this scenario a very simple scenario we have the named hep with the definition of a variable there in the global scope and we have two different source file the number cruncher where the function crunch numbers intensity comes from and the stat sprinter both of them include the header both of them are compiled produce object files and then the linker comes in and the linker says no the linker will tell you that you have a multiple definition of the same object esecially it will complain about the k cup being defined twice at least it's usually a very ugly error it starts with ld and that's how you recognize it if you are on linux so and then you have to start looking where it is there a rule in c++ that says that everything needs to be defined once and only once it in any of that or not among all the translations units that are put together by the linker so if you have multiple translation units and in this case we do have you know source files are usually known as translation units and the same name def is defined twice in different translation units you are cooked the rule only applies to variables and functions nothing much more and things that are not in line so you can mark it in line like for example or your members of a class are automatically marked in line and you don't have this problem this is not in line solutions very easy either make it like a con expert something or a static something and the problem is solved like it's not a variable anymore or make it in line nowadays we have this pleasure of applying inline to var to to the variables it has a very curious effect the linker now will accept multiple definitions of the same symbol but you have to promise that they're the same the linker doesn't check it you can make very nice practical jokes with it so but you shouldn't and if we are actually talking about it why just not put it you know inside the class it's by default now in line whether it's conex per static or not and the problem is solved anyway item number six only fully constructed objects benefit from a aii so resource acquisition is initialization the very ugly you know name not ugly but something that's very hard to explain right to people for something very simple can you spot the problem here i mean i'm pretty sure you can some of you can spot the problem here and the problem is i'm actually having two resources and i'm allocating those resources let's simplify this class a little so those are my resources right remove everything that's not needed and now we have just two dynamic arrays and let's have the happy scenario we are calling the construct ror it in the process of calling the constructor the data min is allocated on the hip everything goes fine and now the data marx is yeah it's not allocated we get the st alloc error something very unlikely to happen but generally speaking you know errors do happen in the construction not stog maybe but something else on the other hand you might be on an embedded system resource limited system and stog will happen now the big question is what happens now we just allocated a resource right we just allocated a piece of memory on the hip we have to free it but we have an exception in the constructor so the million dollar question is does this delete ever get called right and the answer is no this delete won't ever be called because there is a rule and that's actually what ra is about that the destructor is is guaranteed to be called for every fully constructed object this is r ai distilled to to to the basics now what is a fully constructed object right because that's another question a fully constructed object is an object for which at least one constructor fully finished this is not the case in our i mean in our scenario you might try to be smart i also tried to be smart many times before i knew better and do things like very exotic things like like this one like function try block the things exist you can rob the whole function in a tr catch block also the constructor and hope this will work right no it won't it won't because first of all it's illegal to refer to any data members in the catch block of the constructor you just cannot do it it's undefined behavior like plain blank and secondly even if you could i mean yeah what's the value of data max now assuming that data marks through i mean it's indeterminate right you don't know it might be null if you're lucky it might be something else so you might call delete on a pointer that's not really pointing to something for data max so it's dangerous even to do it you don't want to do it and anyway you will get the exception because the exception will be rethrown by the run time what's the solution to the problem well the solution is actually quite easy if you look at it and apply the rules that the destructor is called for every fully constructed object you might come up with something like this let's make a default constructor that does absolutely nothing it will actually use the default initializers that initialize data min and data marx to n pointers and let's delegate the job to it in our real constructor and this will magically work actually this works because you know the default constructor will not throw it does nothing and once it's called the object is fully constructed you benefit from the destructor and the destructor will do its job because only the objects that allocated something will be non null but it's ugly and you shouldn't do it because for example it breaks rule that i said be that i mentioned before that in initialization is not assignment i am now doing exactly this right so you shouldn't be doing it and if you look very closely at it you might realize after some time that actually if you get rid of one of those data members like this you don't need any special handling anymore right because if data mean allocates everything is good now the destructure is called and you are good to go if it doesn't allocate well who cares the destructor doesn't have to be called also we don't care this might lead you to another item that what r ai really means is one class one resource especially one class one dynamic resource this is what ai stands for and with this one you might come up with something like this right but now we are in this ugly situation that we lost a data piece so of course we abstract away directly and create a type like dynamic memory that keeps around just an array and the size of this array which pretty much is a kind of a vector right but okay and then put it in our class instead of what we had before quickly realizing we don't need any destructor whatsoever because everything is taken care of automatically by the by the runtime now and if we are at least with c++ 11 we quickly should realize that this is what unique pointer is for right ored vector for and not your manual memory management which brings us to a totally different item item number eight member functions have an extra disc parameter or an extra dis argument passed to them it's a very found item that really goes into the object model of c++ and how things happen in c++ that helps you understanding how more advanced feature works like deducing this that has been kind of there in the language now right and you can use it we're coming back to the base to the name object because this is where really a lot of bad things are happening right this named object overrides or sorry overloads the inequality comparison so the operator not equals to with another named object and you might think that when the compiler say sees such a function what it does it kind of looks at it like this but this is not true what the compiler truly sees is more something like what we see on the slide so there is a function operator not equal to that takes two parameters instead of one and the first one is the implicitly injected or implicitly yeah injected is a good word here pointer to the current instance named this and that's pretty much all it's there it's always there if you don't believe me go to the assembly look at what the assembly is generated it's always there unless it's optimized away of course because sometimes it is optimized away but it is there this pointer exists why does it matter why is it important well it's important because i am making very grave mistakes partially because i don't understand how this relationship works i have a member function and as i mentioned before there is also a free function which piggybacks on the member function it's a canonical implementation yeah that's how you should do it actually you have you should have one function one should call the other ne negating that the other that that's how it's done and then imagine of course after inlining it because you know that things like this should be inlined that i'm creating two named object and comparing them against each other if alice is equal to bob great our chain call looks like this first we compare those two then obviously because it's equal equals then we call the free member sorry free function operator which in turn because it's internally calls not equal to will go here right i mean that's what we are hoping for unfortunately that's not really what happens right depending on which compiler you are on which language version you are you are either not compiling this code at all or you are getting an infinite region here and i think the first solution is much better actually it's much better to have a compilation error than just get getting stuck somewhere without any clear reason why the infinite recursion well look at this what i'm doing there is comparing in the implementation of the equals equals operator i am comparing to think so we already know that what the compiler truly does is something like this it calls the member function or it tries to call the member function it seeks to call the member function that's implemented inside the named object and it rewrites it to match the parameters into something like operator not equal to address of a comma b so it's trying to match the parameters right remember that there is the first implicit argument to this operator is the pointer then it comes up with the types for those and what it comes up with is that the address of a is a pointer to the const named object and b is just reference to the const named object right and it's con in both cases because we qualify both a and b with const so there are con objects there is no other way and unfortunately this doesn't match our operator our operator is not const the first implicit pointer is not const so the compiler will say no i'm not going to call your member function and since i am on c++ 20 i'm going to apply a very cool rewriting rules that i am able to apply nowadays what are the rewriting rules basically since c++ 20 whenever a compiler says equals equals or not equals to and it cannot find a matching function it is allowed to rewrite the expression into the opposite expression and and negate it so basically it cannot find not equals to here so it is allowed to rewrite the expression into something like this great we have a full match right now we know what's been called and that's why the infinite recursion we are calling ourselves infinitely in the loop and actually that's one of the warnings that gcc and and clank trigger the other one was the mismatch in the ordering of the constructor and the declaration of the arguments of the members but this one is something that clank and gc will warn you about and you might scratch your head then very often because you don't see the recursion but it's there be careful about it how to fix it well you just have to understand the second role of of playing with this that con member functions have cones this parameter right this is what we have right this is what the compiler now sees when it looks at the not equals to operator this is what we want to have very easy things to achieve just put the con keyword after the member function and you're done this function does qualify that sorry this con does qualify the this pointer it's it's really confusing with this all the time i know but nevertheless this is what truly gets qualified the this pointer that's implicitly passed to the member function and now everything is okay our chain call is as it should be so we are calling from the bottom one to the inline operator equals equals and this one in turns will call the last one the inequality comparison and everything goes as expected is there something we can fix about this code i mean now that we know about the rewriting rules and we are anyway compiling for c++ 20 i think there is plenty of opportunities to fix this code like if you know that the compiler anyway synthesizes the other one why would you write two of them like one is enough the compiler will make the other one anyway so let's do it and with that one let's introduce another a bit more advanced item and especially i think if you are in writing sometimes codes that's used by somebody else that should be known to you otherwise you might be surprised about it or might not know about it freed hidden friends are here to help you so as i already said it doesn't make much sense to write both comparison operators it's or equality comparator operators it's just enough to have one of them because the compiler will make or create the other one so far so good right and for the sake of the argument let's say that this code works because it should work now and it compiles but this still works because for some reasons and sometimes you have those reasons we couldn't make the conversion from the named collection base to the named object explicit so you still get implicit conver version and you still can compare to objects of the named collection base and we know it shouldn't right it's it's a bad thing what are your options there there is an option and the option actually is in the title of the slide it's a hidden friend it's a not so well-known idiom but it's a very good idiom it's for hiding functions from the lookup so if you don't want a certain function to be automattic to be found by the lookup when the compiler tries to find a match for your call specifically if you only want it to be found where your at least one of the arguments totally matches the argument or the parameter in your function just move those function wait inside the object that it's you know no concerns in this case our bull operator can be moved into the named object and it won't work obviously because now it has three arguments and it should have only two it has three because there is an implicit this so you make it a friend function and declare it or define it directly inside the class a function a friend function that's defined in place is called a hidden friend it has very special magic properties it won't be found or used for that matter if at least one of the arguments that you try to call this function with doesn't explicitly match the one that you list there so if it's i cannot point oh i can point no i cannot point i can point if it's not the named object right in our case it's not the named collection base is not a named object so it won't be found anymore this comparison operator by the lookup it's impossible it's hidden this function is now only found okay doesn't matter let's not talk about it so this won't work h and that's great right as it should be it shouldn't compile and if we are already talking about it then and about hidden friends and about how to declare functions how to declare or define operators comparison operators and so on and we are in the modern language why not just go a step further and do something like this right just default it declare it as a friend and it's going to do everything you want it's still a hidden friend but now you have all the other comparisons synthesized for you out of the box so you don't have to do anything else so that was a hidden friend idom a very powerful things from for hiding your functions from the lookup the next one polymorphic classes need virtual destructors that's where i leaked memory you didn't most likely see it but i did leak memory a lot in the first slides i have something like this or actually i didn't have something like this it will come but let's look at those couple of examples what do they have in common i'm creating like a pointer a unique pointer the to the named collection base and initializing with a named hip or i'm doing something different like i'm doing creating again an object on the hip of the type named hip and assigning it to the base pointer base class pointer and deleting then or doing something like this it's a bit more hidden now i'm creating again an object on the hep named hip on the hip that that's unintentional and then i'm calling a function with it the function that takes a pointer to the named collection base all of this have something in common right you expect somewhere at the end of the lifetime when the named hip is not needed anymore that there will be a delete call on the pointer and and it will be of course the unique pointer will do it for you and for the middle example we just did it explicitly so we expect something like this to happen and what we want it to do is of course to call the d structure of the named hip and then the operate operator delete to free the memory deallocate the memory but that's not really what happens right that's not what happens because we made a huge mistake and i was actually quite surprised that neither compiler warned about it because they sometimes do warn about it this time it didn't this is our named hep right it doesn't have a destructor because it doesn't need it great this is our named collection base it doesn't have a destructor because it doesn't need it h except it does it does because we intended to use it in polymorphic code a code where the child class will be referred through the base class pointer and what's even worse destroyed through it so what truly happens because we don't have a virtual destructor here defined is then when the delete ptr is called the destructor of the named collection base is invoked and not of of the named hip this is not what we want right because it means that we are totally leaking memory shouldn't happen is there a fix of course there is a fix and it's a very easy fix just put the virtual destructor there default it and you're done it becomes a class that can be used po polymorphically and whatever we do with it now it's going to be good it's going to work as it should so so this was kind of a of an example when things can go wrong with dealing with inheritance right a basic example which you're not likely to do unless your code base is very big and unless you know your compiler doesn't warn you about it like it didn't me the next one is in a similar spirit so we are going to talk about object slicing or about copying child classes or derived classes when referring to them through the base class not a pointer but just through the base class and this is something that you know it's in my opinion it's sometimes very easy to see like for example on this slide in this four lines of code i'm slicing an object and in particular i'm slicing the named hip and by slicing i'm mean that i created a hip a named hip that owns two different arrays and then i make a copy of it but i'm only making a copy of a piece of the hip so i'm only making a copy of the hip that belongs also to the named collection base i totally neglect the hepp part let's say it's not really visible here right because it's kind of hidden in this you know make unique named collection base everywhere do reference but what really happens inside is that the constructor of the named collection base will be called and the reference to the hip will be passed to it which is totally legal right and the name collection base will be created without the hip part it's more obvious when you do something like that so when you just have a function that takes like in this case a named collection ba based by copy you can already see that there is a copy being made it's clear the consequences are always the same right so the consequences are always the same basically we are doing what's called object slicing which means that we are not copying the whole object but only a part of it in this case we are copying the name and the size and that's all that might come as a surprise later on when you will try for example to do some casting of this hep of this copy of the hip that you made nasty crashes no compiler wars about it really and that's said an easy fix of course like for that one i mean okay it's not an easy fix it's an ugly fix but the fix exists just pick up the right class when making a copy when using unique pointers much easier fix when you're are passing to functions instead of passing by copy just pass by reference like maybe a con reference and you will be good no harm will be ever done right no object slicing and with that one we actually reached the end of the list of all the 12 knowledge items those are there all mistakes were truly made on the first two three slides i managed to do all of them luckily try it for yourself if you want see if you don't believe me are there any questions so thank you very [applause] much i don't know i have one i'm just going to ask a question from from the the online audience so this is a a question from peter f neisen in issue number 10 when do we have to explicitly define equal equals if we ask for the rocket operator or sorry spaceship operator i didn't understand the question now you can repeat it of course but that that's me it's not it's not okay let me ask it it it slowly in is issue number 10 yeah when do we have to explicitly define the equal equals operator if we ask for the spaceship operator i presume we have the spaceship operator and he wants to know is there any case when you can also define the equal equals i wouldn't say so why would you do it then i mean i mean if you have the spacep operator it covers all the bases so if it was the question of course so now you don't need to do it anymore i don't think so unless you want to confuse some people right i i mean you you might do it i think you might do it because it's it's you might hide for example the spaceship using the hidden front and explicitly define the equals equals outside so it's visible to the name look up right so so you can distinguish between the operators but yeah is it a good design then i don't know i i doubt it yeah so my question is also about the equal equals operators stuff i can't remember which slide it was at the kind of start of the speech but you said that the compiler could convert like decide to convert from not or in in equals operator to the quality operator instead do you know what i'm talking about right now yes of course that's kind of scary to me and i wanted to know do you know of any more of these like implicit conversions or whatever you're supposed to call them that's the rule that's been introduced just i don't remember in c++ 20 or 23 it always happens a compiler is allowed to rewrite one comparison into another when one is lacking that that's all do you know of any other operators or other other special functions that behave this way no no luckily not i don't think it's scary i mean maybe like the less than operator could be converted to like larger than or equals to remember that you can always explicitly disable other things right if you don't want the conversion to happen just no you cannot disable it delete yeah you could delete it yeah just delete the other one but that doesn't doesn't doesn't help you here that's kind of scary to me but thank you so you cannot delete it no i was hoping the same but no you cannot because then you delete yourself i mean you have to delete that one to disable this this is what it's rewritten to right so it's rewritten into the same operator so how do you delete this particular use case i i could imagine that there is a way to do it but i don't i don't want to do it okay i have a question about item number five are you aware of any best practices regarding the adding the inline to your con expression variables because adding the inline will make it more consistent because everybody sees the same address of your global constant but on the other hand these types of constants i don't want anyone to access the address anyway so i often find myself struggling should i add the inline shouldn't i because it always suggest suggests not what i want to do because i don't want you to access the address but if you do i would want it to be consistent i understand your question i think but inline has a very specific reason i mean reason for existence now in c++ light inline means literally allow multiple def definitions or red definitions as you say there will be only one object created at the end but that's part of the linker job right but if you declare it inline but if i don't declare the con expression variable inline it will have internal linkage and it will be fine in terms of the one definition rule but everyone will see a different address and yes that's weird and but i don't want them to access the interest anyway so so to r on that then just do it make it in line okay if you don't want them okay or it and another comment if you explicitly define the spacit operator and don't default it you have to explicitly default the equals operator to make it available that was maybe the first question thank you and that's really funny because i didn't have to do it and it compiled it compiled because you ex you defaulted the the spaceship operator but if you have to implement it in terms of understand maybe delegate to okay i have a i have a further comment from perer online and i think he might be agreeing with our previous now i understand the question to to clarify he says you do not get the equal equals operator for free in some situations even if you ask for the spaceship operator so that's okay and i have another question from somebody online roman asks you were talking about memory allocation issues are there any techniques to handle bad alex i think crash the program i mean if you're out of memory that's the end of life of your program anyway right unless you can switch to a different allocator or something like this i mean that's that's what i've been taught always so it's a disastrous situation right when you're out of memory so your options are very limited at this at that moment unless you are on some heterogenous system and you don't care you have multiple memories or different allocators maybe or you don't know or you maybe had a very bad allocator that just one had kiloby and yeah okay i seem to remember writing code decades ago which would at startup would allocate would would reserve 2k or something like that and then if it got a bad alec it would the allocate the normal allocator would switch to using that 2k for the last get me out of here cleanly so we we sometimes tell beginners to try it nowadays to especially on linux to just allocate as much as possible it's an endless story you can allocate allocate and allocate you know and it's never stops it's a virtual memory so are there any more questions if not thank you very much for attending the talk and for the questions and see you around