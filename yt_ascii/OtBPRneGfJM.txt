and we get started with the next talk for meeting c++ 2023 right now we will have vladimir veski talk about dependency injection patterns efficiency and usability really interesting topic please take it away vladimir thank you very much yans thank you and thank you very much for being here my name is vladimir vishki i would like to offer this talk that is called dependent in injection patterns efficiency and usability material from the stock was originally prepared to be a part of test driven development of embedded and system level software presentation for accu this year it did not fit there because of the time frame liation so it was extracted and reworked extended to become a separate talk u it's still influenced by testing topic and offers some overview of the basics of dependency injection techniques that are available in c++ and reviews it from the usability including testability and efficiency perspective i think the most of the talk is so belongs to back to basics level but there will be also some advanced parts as well so why dependency injection is important yes so we are following some design principles and practices when we are designing our software yes so those or we are encouraged to follow those design principles in practices those principles in practice can be decomposition decoupling some something like single responsibility principle separation of concerns and the overlap there is that following different motivation and different criterias we split some functionality into smaller parts and dependency injection is important because it allows to reassemble those reduced units into more complex parts of software dependenc injection state principle states that the units they should not be dependent on concrete types but they should be dependent on some abstractions and those design principles they are important because if we follow them yes so we can achieve some minimalist items that is easier to implement and modify we have some items with clear requirements and interfaces we can reuse those units or items so we if we decouple the so we can reassemble them into another system or if we decouple them from the platform we we then can reuse them on another platform so this enables pability also testability decoupled components they generally require simple tests and they can be developed independently in test driven test driven environment using test driven development yes so if we focus on testability the mock testing it's fundamentally based on decoupling and dependency injection principles so we provide more implementation of dependencies that perform some test specific actions or have some test specific behavior and this we are doing for testing of our implementation yeah so the composition would prevent this that makes the decomposition crucial and the testability it is really well connected with portability and reusability because we are developing some component in the testing environment and then we port it into production environment and re use it there to reason about applicability of different dependency injection techniques in different areas where c++ is used we need to probably review some specific specifics of those areas here are some examples we can have some low latency applications those applications they are designed for maximum runtime efficiency and typically have some hot paths or some part of the application that is the most performance critical one and the layout there is on this hot path is typically aes static so that means that it is known as compil we also have some embedded applications those applications are typical they they can be limited in some in resources so they can require some optimization for ation size also it is possible that the computational power of the platform will not be there will be no abudance of this computational power i would say and still there will be necessity to achieve some runtime efficiency there program structure there is also typical aesthetic so the we also have some user applications of that are quite often built using some objectoriented frameworks so we can have some ui frameworks remote procedure calls frameworks some database accesses those also those application can be designed to have some dynamic plug-in architecture we also have some software that can be built on top of the system apis and provide some extra services for upper layer applications we can call some platform software and they are typically based on those system apis like posix windows or some board sdks and embedded so to reason about the applicability of dependence injection techniques we will consider those u the requirements from those domains that we just kind of reviewed for example for us it's important if the dependency injection would introduce some runtime dependent injection technique will introduce some runtime or size overhead if it will be applicable for runtime injection plus we also are interested if the dependence injection tech technique can be suitable for mock testing if it will really enhance the testability and also of course what is important is general usability and what is the boiler plate overhead so is it really require how much code is needed to really enable some dependent injection based on some technique from efficiency point of view of course it is important to mention that of course runtime characteristic they will depend on platform and generated code and the generated code it would depend on target architecture compiler program structure optimization features etc so we will review the code generation patterns we'll observe them to reason about and runtime impact of some design decisions and for this we will review code generated for x86 64 architecture mostly by big three compilers yes so by gcc clank and microsoft visual c compilers for with different optimization options so we will build generate code with optimization for execution speed this is 03 for gcc clank and o2 for microsoft compiler and we also we'll also see what code will be generated if we use the optimization for the executable size so os for the clank and gcc and one for the microsoft visual c we will use tri code samples that will be enough so the trival code samples of basically single translation units where all dependent and dependent and dependency code they will be located in really in one single translation unit this would be enough for the purpose of this presentation we will look at the overhead like in direction extra cod that will that will be generated and of course this relative overhead it can be unnoticeable for some types of applications on the other side it can be very critical in some other settings and of course u i just wanted to mention and this is important to highlight that evaluation of design decisions of course as with any other decisions that are involving performance considerations yes so those decisions they should be evaluated and the tradeoff that should be done they should be evaluated based on measurements in project specific environment yes so now about the dependencies in c++ programs yes so what are the dependencies what we can be dependent on so typically if we apply the composition we can so some functionality then can be placed in classes typically some functionality with the state and so we can be dependent on the object of this objects of this those classes or some functionality can they also be placed in standalone functions typically without the state yes so we can also be dependent on some functions and dependency injection techniques that are available in c++ language they are in on on language level are the inheritance based rent and polymorphism polymorphic function rappers we also have inherited from c the function pointers that are still can be used and also we have static work compil and polymorphism yes so let's first start with inheritance based runtime polymorphism technically it is based on the principle that the client code should be dependent on class with virtual functions then concrete implementation u is injected so the class that implements those virtual functions and this is a well documented practice why because it overlaps with objectoriented design uses the same language features and u aler i would say that here it is reviewed from slightly different perspective u as more like a decoupling technique than actually object oriented design feature yes so how the code that uses this technique would look like yes so in best case the dependency is specified using so called interface this is not a language feature yes so interface but i mean that this is a class that only has pure viral function so there is no implementation in the class it just specifies the contract and the dependent code just accepts the this interface in my case it does this by reference because it clearly specifies that the dependency is needed for the function yes and also the interface can also be declared in a way that it can also specify what kind of ownership is then implied for example here the interface has the protected destructor that prevents the destruction of the inherited injected object from using this interface so this clearly so this first of all it prevents and also specifies that so prevents the destruction plus it specifies that the ownership is not passed into the function yes so the ownership is still controlled by the client code the dependency implementation it then needs to inherit from the interface and provide the implementation of the virtual functions so here we have some basic implementation that just forwards the data so in our example s i did not specify this we have some backend and this back end has an output method and here we have the file output that just forwards the data into the file if we would like to slightly modify this implementation for example would like this file to be passed as a reference from somewhere as from outside or just use a different stream we will need to have another implementation or use some templates but anyway we will need to have a different assotiation of the dependency implementation if we will need to have some dum implementation that will be doing nothing like just will not perform any output we'll need to have another type as well and if we need to forward a standalone function we will then also need to have it wrapped into another type yes so here we have another implementation that just forwards the call to the standalone function like here so unfortunately this would be required from testability perspective this is also well documented practice because it is typical for object oriented design as well so we have we can implement the mock object the mock class and then we can inject it instead of our production implementation setting up some expectations and specifying the behavior that is specific for the test let's have a look at what our at what code will be generated if we use this dependenc injection technique to for this purpose i'm using as i already mentioned very simple sample so i will have some interface and a simple implementation that will be just we'll have two methods and it will just forward the calls to some c functions this would be done to to use those c functions as a markers within the generated code that will be immediately visible and the code just in so the one interface method that is called interface method will be just calling this c function that alone c function and multiplying the result by 1,000 and another interface method that is called like is really called another interface method will be just calling another function and just forwarding the parameter to it so the argument to it and the client code that will be using this dependency it will have the following logic so it will call the interface method and then depending on the if the flag is set it will call it will either return the returned value if it if the flag is set to true or we'll call the second interface method interesting detail here i will be always specifying flag to be true so making this code unreachable so we this will be used as also a marker of the level of optimization of the client code as well so if this code will not be present then we can see that this code was optimized away and to enable the dependent injection using this technique yes we create the instance of our dependency and just make the call passing this dependency into our function i have multiple calles here to affect the compiler decision for inlining okay so the code that will be generated for this trivial sample with optimization for speed will look like this for gcc and clank the cod is optimized so we see that this do something function was in lined the cs were d virtualized and non-reachable paths are removed there is no calls that are unreachable here in the runtime at the same time if we look at the code that is generated by msvc we will see that it emits the instructions that correspond to indirect function calls yes so that we it is not uh it is it it it did not optimize those dynamic features away if we look at the code that will be generated by gcc but for the optimization for the executable size we'll also notice that the inlining is not happening here anymore and the function body remains at as it is so having those calls and has the underlaying so has the code that corresponds to the underlaying implementation of this virtual code so we have indirect calls here as well at the same time if we change the platform and build the code for arm platform with the same gcc compiler and also optimization for executable size we will see that it will optimize those virtual calls way if we add the a bit a couple of more calls to one of the interface methods we will see that clank for optimization for runtime efficiency will also start emitting some indirect calls what does it show so it illustrates my initial statement about the fact that the compiler so and the the way what code will be generated it really is affected by multiple different factors and this should be definitely considered another question would be i'm mentioning here this in direction is it a problem at all and the answer is it depends because so this inir calls they can introduce performance penalty in case of target mispredictions this can be mitigated by advanced hardware if so depending on the predictability of target and the predictability of execution flows so if generally speaking if the calls are always coming to the same location then it will be predictable but if hardware has this functionality plus overall number of operations to really implement those ind direction so this dynamic features of uh the of those virtual calls it will it is those number of those operations is greater than the number of operations that are needed to perform just a direct call plus those operations they include those multiple memory accesses in form of the this point of chasing kind of multiple consecutive memory accesses and of course real life impact would depend on project parameters and requirements but it's important to understand what is happening under the hood of the if some techniques are used also one more detail is that the if the dependency and dependent code are located in different translation units then also most likely the ind direction will be emitted for example here this gcc with the optimization for speed it still implements those indirect calls so some virtual function calls and this can be optimized by link time optimization if those dependencies are can be resolved during link time this is an important feature that also should not be neglected yes so here we see that those indirect calls they were substituted by direct calls during the link time okay so to summarize inheritance-based runtime polymorphism advantages so we see that yes so it works for runtime injection that is suitable for various cases where we need a dynamic configuration or when we need to use some dynamic levers and plugins we also can achieve a separation of compilation units so the whole and all and isolation of implementation details yes so we can have the whole definition and declaration everything to be sealed in the source file and only the interface can be exposed this this is an advantage of course yeah so on the other side of course those this technique also has limitations yes so the new types they should be introduced to implement various behavior and those virtual method resolution if it is not optimized way it introduces xra executable cod and indirect calls next technique that is available for us we have also polymorphic function wrappers so this is based on type erasure and the standard supporting facility that enables this and standard is st function there are also some alternatives including non allocating alternatives so for example estl fix function or sg14 place function those they do not need to allocate on the heap for captal list so that makes it suitable for in the environments where the hip location can be sy critical generally the cod that would be dependent u on the polymorphic fr repa so would look like that so it accepts this the object rep object and can call it using cooperator and the call operator will have the signature that is specified here as template arguments the client code can then has a lot of flexible ways of specifying the dependency implementation for example it can be just simplified it can be just specified using lambda expression lambda function there can be for example here some file object is captured and then some output is forwarded to that so this is the alternatives for our process data implementation that we had before in the previous section we here we're just forward to the file we do not need to create some other types we can specify just another lambda function if we just want to have the file created here in the body of the lambda function locally yeah so we can also just forward the standalone function here or write the simple lambda expression just to specify that no operation should be done yes so this is really convenient because there is no necessity to introduce new types inherit from anything so there can be just simple implementation that is injected this really pro provides a really loose coupling between dependent and dependency a dependent called inde dependency the for this this technique is phrased also important to mention that it works very well for as a some form of substitution of a single method interfaces for example we can have a function like store records that require some format for record or write of record and this would be probably some single method interfaces but we can just provide a simple function so our function repper that will store the implementation of this functionality similar thing with some ip address resolver that can be just injected into some function that implements connection to host also can be used to implement some c function like here in the l configuration there is a necessity to u to create some plugins based on the name and we can just in inject this functionality into the l configuration file for testability it's quite convenient way because we can just simply regardless of what is injected in production code here we can just u inject so forward the calls to some mock object that we can capture for the tests for the examples of the test code i'm using u i'm using the g g gas g mo framework or we can just just forward the mock object by reference if it has the implementation of the cooperator so offer it will still need to to forward the call because we cannot mock just the call operator but generally it is convenient because regardless of what we injected including also standalone functions we still can check that the calls were correct yes just injecting the mock object and from efficiency point of view let's look at the code that will be generated for this technique we are using here again our do something function that has the same logic we call one fun one rapper object then in case of the if the flag is not set we can call another one and those are the two reppers that are injected and we inject the same logic that we had before so we just have a repper that multiplies the result of some standalone c function and we inject some c function directly because we are not anyhow altering its result or we just need to forward the argument to and if we look at the c that is generated this is the c that is generated by gcc for runtime efficiency optimization we see that there is a massive overhead here the a lot of cod is generated and there is in direction here there is there are also some checks because the because the object should throw if it does not hold the function if it's empty we also have u some resolution of what is really stored there because so we have here the u typ raure implementation so we see that yeah there is a clear tradeoff between usability and some performance here interesting detail that clank actually has a feature it can optimize this away so it really optimizes well those rppers especially st function it also can optimize away the the alternatives like estl e stl function fixed function but with std function really performs the so works very well but this is where the injected type is really known during the compile time so again in a in a very simple trivial case but unfortunately yeah this is the unique feature a microsoft compiler will produce something similar to what gcc gcc generated so some overview yes so some some summary polymorphic function reppers they definitely have advantages yes so so we do not need to introduce new types their dependency can simply be adapted using lambda expressions translation units they can be separated as well because because the the type that is stored in the function is erased so that means that it also can be impl can be hidden and only the function can be then just provided to the client code so the the reper can be provided to to the client code and it's of course applicable for runtime injection so it can be injected on runtime and we can also inject standalone functions without necessity to rep it so okay still we saw that it has some limitations yes so it introduced runtime overhead we saw that there are some indirect calls plus some extra logic it is unlikely to be optimized there are some exceptions but yes this is still a quite a unique feature and we need one reper object for interface method yes so if the interfaces are more complex and in some cases they are so it might might be not well scalable okay so function pointers is the next technique and of runtime technique that is available in c++ programs this is based so this is a technique that is available since c language is inherited from c but it is still used especially in the areas where c++ needs to interact with c code the idea is that the pointers to functions are just passed to dependent code it is very widely used in embedded and lowlevel software and it enables polymorphism in c programs so how does it look like so the to use this technique we typically pass either a single function pointer or we can aggregate several function pointers in the structure like here and then we just pass it into the function so this is of the technique that is really can be seen a lot in c cold c++ version can be slightly modified and modernized so we can have this left to right function pointers declarations using this add pointer tls but the kind of usage will look the same yes so we can pass these set of so not the set but just actual disaggregation table of containing those function pointers and then we just call them indirectly what is quite important unfortunately this is quite rare the case but the those aggregated function pointers they also can be associated with some context and this context it can be just passed in form of void pointer to the dependent code and dependent code then can call the the functions just passing this context into those functions this could provide possibility to really associate some data with the function calls and significantly enhance interoperability between c++ and c code because this can then the call can then be associated with some object and if the c and c++ code are cool designed to work together then this is the implementation so design design detail that shouldn't be neglected it really simplifies interoperability okay let's look at what code is generated for for functions for function pointers we can have the so our sample code is again the same we are using the standalone c functions we also have this rapper to alter the result of the function call here and we are just assigning those so we are initializing this function pointers within the structure using this repper here for yeah instead of just a a direct call because we need to multiply the result by 1,000 and here we are using c++ 20 feature designated initializers so they are now available unfortunately only starting from c++ 20 but of course it makes cod more readable and actually safer yes so that we really specify proper u that we initialize proper fields here and then we make multiple calls again and we can see that even or for yeah we provide the function pointers here so we yeah we can see that it is well handled by the compilers all of the compilers they eliminated the ind directions the so and also all eliminated this unreachable c so they optimize the client code well yes some of the compilers also optimized the mathematical expression here we had multiple additions there and it takes out the multiplication then so just producing more efficient mathematical expression unfortunately if we start experimenting with different parameters we will have same effects that we saw for the inheritance based rent and polymorphism for example here if we built by gcc for with optimization for executable we again see that the do something function will not be unlined and the body of the function will contain those indirect calls to the function so and the reper function that was inlined in our previous example now is not in lined anymore so there is a so again we see that yes the underlaying implementation and this is like an explicit ind direction because we are using the function pointers here it can then this this implementation can just stay in the code depending on how compiler is optimizing this and this is again a simple very a simple trivial cod sample where everything is visible for compiler on compile time single translation unit okay the advantages yes of the function pointers technique so we it works for c code it can be used for standalone functions and and can be used for runtime injection as well yes so this is those are the u the primary advantages on the other hand it they introduce indir co overhead if not optimized away yes u that can this overhead can this ind direction can prevent compile optimization further compiler optimization and also function pointer they are not associated with an object if not designed to accept this context yes so that means that if we need to from these functions we need to have we need to associate some data with those function calls for example some state we will need to use single ts including we will including test scenarios where we will need to have some single ton mocks this is not very very good yeah okay so generally the technique seems to be applicable for interaction with cold but unlikely to be really useful in the c++ programs where other options are available okay so now a couple words in general about optimizations for the runtime polymorphism and for different options that involve this front and polymorphism that we mentioned before so we can see that optimizations those like remove of in direction in lining they're not guaranteed yeah so they are features of the tooling and sometimes they can happen or not and we saw the different cases where these optimization is actually was impossible did not happen if dependencies can be resolved only at runtime then of course then we will have the in direction because this is how this dynamic binding is implemented if dependencies can be resolved in link time then lto is pos if is possible if it is available and should not be neglected if dependencies and dependent code allocated in a single translation units the way in the way that we use in our examples this can provide a maximum level of visibility for compiler and enable the maximum level of optimization possibilities but generally it defies the dynamic features of those techniques and also defies a source code isolation so as a summary for runtime polymorphism i just wanted to mention that still the usage of those techniques is inevitable for some types of applications because they support the really runtime dependency injection they really can provide high level of dependency asola we can hide the implementation details split the translation units hide the dependencies in source code we can but they can introduce the runtime and size overhead even for programs with static structure we saw that we have some application types that have static structure that primarily have static structure at the same time they prioritize performance alternative for runtime dependent injection techniques can be something that is not based on the ind direction but still has the limitations but that can be acceptable for the types of application where performance is more important the alternative that is definitely should be mentioned is a static or compound and polymorphism the idea behind it is that the dependent code has to be generic yes so it should be either function or clust blate and that dependency type is specified as a template argument and dependency and dependent code just need to be compatible that means that template parameter substitution should not fail as a simple example here we have our process data function where now it's called generic process data and it is template now a function template now and it accepts something generally speaking yeah that can be called passing the data as parameter then the use cases for this type of injection can look visually very similar to what we had with polymorphic function reppers yeah so here we also can specify the some lambda expression so we can inject some closures we can also inject the standalone functions we can inject the we can yeah simply have the same lambda functions that we used before the difference here is that that those are all different instantiations of the function template so those are all different instances of the function that are called here having different dependency types from performance point of view and the generated code here u let's do another experiment so here we again have the same layout of the client code of the dependent code we have two functions and we pass those functions in one case we pass this again this rapper in another case we pass the function directly and the generated code will look so will be optimized yes so we can see that again all free compilers for optimization for runtime runtime efficiency for runtime speed will optimize this well yes so again u eliminate in direction again unfort for if we use the change the optimization parameters like here gcc for size we can notice that the we will again see similar layout as we saw when we used the function pointers we'll see some ind direction and this is happening because actually we injected the function pointers so we here pass the function pointers into our function template and this affected of course the generated cod because the dependency type would be really like a like a a function pointer so that means we the call was not in lined and the function pointers st just stayed the same way as they were kind of provided into the tempate so here the functions are injected it is visible from the from the that were deduced by the compiler so alternatively if instead of passing the function and of directly we can rep the calls to the function into lambda expressions and lambda functions and inject the corresponding closure objects and in this case if we just do it like this we the code that will be generated will not contain any indirection because there was none in the source code there were no indirection because the function pes were not involved only direct calls were performed in the call operators of the closures that were generated so here we see that the code is optimized yes so that the dependent function is in lined the wrapper still still is not inlined but there are no indirect calls this is an detail because it is also kind of highlights the feature that if we are using this different types of static polymorphism then the type of dependency can also affect the generated code okay so we were talking about generic function but we also can have of course so about the function template we can also have class template here we just need to provide the so there should be a template parameters that would correspond to the dependency types s and they should be then injected in this case by reference estd reference repper might be required here if we need to provide some copy or and assignment operations otherwise it will not work instead of multiple dependencies one single class that implements this api provides this functionality can be injected yes so here we combine two different methods and just made some dependency type we require that the dependency type just implement both of them yes so something like this and we also can have our interface is be adjusted depending on some declarations within the dependency type so for example here the return type will dependent on the nested value type declaration from dependency type if we to our if we implement the forwarding constructor to our dependent class that would be just forwarding the dependency dependencies based on the value category of the of the provided dependency yes and then also supplement the declaration with the template argument deduction guide that would link the parameters of the forwarding constructed to the parameters of the class template we can enable possibility that the dependency can be then injected using left or left value or a value references and it can be then either shared by reference or just owned by the dependent class so the use case for this in our simple model will look like this there will be possibility to either pass the parameter by l value reference or just by our value reference here in case of temporary or we can use move here the example of the application of this technique i will provide in the next section but a couple of more details here so of course if we use this approach then we will need to use this remove reference here because we if the type can be deduced as a reference then we need to remove it to get access to the ne nested declaration and before that we discussed that we have we have u we need to have the dependency type be compatible with the dependent code this is not very descriptive c++ 20 offers option to really specify that within the code so we can use concepts to describe the dependency type for example here we generally require that the our dependency type has the methods called some function and another function and that they are related in the way that the type that so that the return type of the first method should be accepted as a parameter by the second method yes and this is will then allow to verify the dependency without instantiation of dependent code it will also be more descriptive because it really specifies some form of the contract it then will provide better diagnostics because the constraint this constraints verification diagnostics is generally better than the one that is provided when the template instantiation fails so and it will allow independent development of dependent of the dependency code it will not require the so the presence of the dependent code to really verify to to verify conformance to the contract and then this concept generally can be used everywhere where we specify the template parameter constraining it's just contra constraining it okay now short example how these techniques techniques can be combined this compile time techniques let's look at these class that is the synchronized deck that is generally some form of adapter that uses some container as a backend storage and provides some synchronized r safe access to it so here we have like p we have push method that needs to lock some synchronization primitive that is also the type of which is also specified as a tempate parameter and we need to develop this logic and also we need to verify and test it so here the backend type is spef and the synchronization primitive type they are constrained using concepts so we those concepts they can be specified like this for mtic or for everything that behaves like mtic we can use a concept called locable there is so this would correspond to the lockable named requirement so there is no concept like this in a standard library so far but we can implement one everything that can be locked and then loock is corresponds to the named requirement lockable and we can also specify concept that is called st st st stack like accessible this is will require perents of the methods that will allow efficient implementation of the stack so we require that the stor that the container that will be used as back end has those methods so in this case is slightly more complex but in we need push back probably p back but we are here limiting only what we need in this example everything that would correspond to the lockable concept will be compatible with these standard facilities like scop lock or unique lock here we use one and we need to take this lo before we actually access the container the proper contract we can verify just in the unit test environment by providing some mock implementation of vector and mutex so here we have the mo that have the push back method for vector and lock and lock for for the mutex and if we implement the same technique that we mentioned before that we have the forwarding constructor and deduction guide so here the types and so the types of the to the arguments of the constructor will then specify and define the arguments of the whole class template so we can then just if this is implemented then we can just instantiate our adapter using the types and using the object our mock objects that will be then injected instead of real production dependen so here we constructed passing those references to the sm objects and then they are then become arguments of the synchronized tech class temp plate so having this we can then just simply specify our expectation that the calls to lock push back and unlock is happening in sequence then we trigger our api function of synchronized tech and we need to and if everything is correct then we can pass the test the potential issue that can be found here for example if we have this temporary lock we forget to if we forget to give a name to it then it will exist only on this line so that means that lock and unlock will be happening before the push back is happening so we can verify the contract and as we have also default parameters for so default types for to parameters and also we have default constructor we can still create our synchronized stack just providing the value type that we want to store here and then the default types will be used in another case it will be vector and just a sub mutex if we would like to adapt already existing objects then we also can use it similar in a way similar to our vector to similar to the way how we did this with the mock objects before okay so last detail that i wanted to mention we saw that we are quite limited in the way how we can how we can inject the standalone functions as dependencies or for it sometimes it is necessary because they can implement some logic that can be that that first of all should be sometimes should be substituted by some mocks for testability in some cases it just really should be a should be dependent on the some environment and for example on the platform so we can inject the platform dependent api for example and we saw that we can do this using the function pointers we can do this using the polymorphic fashion wrappers but those are those runtime techniques that can introduce the in directions we saw before yeah so alternative to this is to wrap those sks into some into the some into methods of some objects that we can inject instead so we see s an example where we just wra it into the closure co operator yes so using the lambda function another way is just yes to try to attach those standalone functions and wrap them into the methods of some stru that we can then also inject in the class of function template in this case we forward those calls to the c function or another function this can be generalized to avoid some potential defects in the forwarding of arguments or or in the forwarding of return value so generally we can u use the perfect forwarding here just to simply forward everything that will be f everything that will be passed for the class method to the standalone function this can also be then just wrapped in some mro definition here so this would allow some form of attaching of the standalone functions to the to some class here we are using our macro and this would be expanded to something like this and this also enables the testability so if we have some code that is dependent on some api attaching those to to the to an object and injecting the mock instead head of the real implementation that really forwards to the production api can then be used to test the dependent code so with still there is no polymorphism u like runtime polymorphism involved here there are no function pointers involved here the cod remains suitable for fur the compiler optimization okay so couple of couple of words as a summary for static polymorphism so we see that the indirect calls they can be avoided it provides really good potential for u in linning and further optimizations so and it can be used to substitute dependencies on concrete types so we do not need to be dependent on some interfaces like on the on the on the function with on the classes with virtual functions we also do not involve type rasia somehow here so we can just have already implemented concrete types and we can just inject them they just should follow some contract but limitations are also quite obvious yes so the dependent code it has to be generic the dependency injection is only happening on compile time so it's static su only for suitable for static code only the dependent code and depend tendencies they also have to be in a single translation unit yes so this can increase compilation time this also like a separation of source code is maybe not the best in that case but it supports compile optimization because it provides a good visibility for compiler yes if we look at the compile time injection from test driven development perspective then we can notice that it enables some form of top down design design approach yeah when we have some form of the dependency inversion so we can define the interfaces using the concepts yeah so in some way yes so that means that the code for dependency can be then so the code the dependent code can then be developed independently and the concept will specify the contract for for dependencies yeah so and also apart from top down approach it also enables bottom up approach when we already have some components that we would like to use u in some code and instead of using those existing components we can start building our code using some mock implementations to verify the logic that we are developing without being dependent on these concrete types and then in production environment we then can inject those so this was demonstrated by our examples with the vector on mutex and we can really achieve some decomposition without runtime overhead so if we need to have some decomposition for to increase the stability without sacrificing the runtime efficiency this can be achieved using compile time or static polymorphism so short summary yes so runtime techniques they are suitable for dynamic program structure because of this yeah the way how it is implemented there can be some extra code and the direction that can be unacceptable for performance critical areas this should be considered we have their dependency on compil optimization capabilities so generally if compilers can remove this and direction viralize calls if they're out link optimization is available static of polymorphism it does not involve any ind directional virtual calls it is unlikely to inhibit compile optimization so but it's suitable for static program parts only short the summary for performance considerations yes so it is important to reiterate again that the design decisions they are always should be based on measurement in the specific settings where the cod will be really running behavior of tooling can be different yes so the tooling that is used in the project it should always be considered in a concrete project yes so the of course runtime and size overhead it depends on compiled optimization so the proper options they always should they should be used the proper compiler options yes and compile er optimization can be inhibited by ind direction that what we saw those compile time solutions they do not introduc in direction if we not explicitly in if we are not exp injecting the function pointers yes so we need to be careful here but generally the compile injection is not based on a direction and it is unlikely to block this compile optim the compile optimization effort and yes compile we can say that compound and polymorphism is preferred for decomposition of the functionality on some application hot path i mentioned at the beginning so there was another talk test driven development of embedded and system level software for which some of this material was prepared it is more focused on test driven development of course and it has more details from test driven development perspective so if there is interest for that then please also refer to it that's all from my side thank you very much for attention and if you have any questions let's discuss them thank you for your talk this was really nice to hear about dependency inse sections and the various patterns for it and c code and comparisons very interesting if you have any questions that you didn't get answered during the talk i want to generally talk to vladimir he'll be available on the louch and this is kind of the last talk for today at the conference so you know take your time and vladimir will be in the launch for the next 20 30 minutes if you thank you very much go there for your talk and with that i'm going to end this live stream