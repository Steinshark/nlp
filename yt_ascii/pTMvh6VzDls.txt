previously you've done a video about garbage collection we need resources for our programs to run but if we hang on to those resources for too long that's a problem because no one else can use them and eventually we run out of memory garbage collection before which is one way of solving that problem the difficulty with it as was kind of mentioned in that video was that that in itself takes memory and cpu time to run which isn't great because if you're trying to really run something fast you want to reduce the amount of resources you're using as much as possible so what we're going to talk about today is a concept called raii resource acquisition is initialization and specifically we're going to talk about how a language called rust has built that into its language in order to do the most it possibly can to stop the programmer making mistakes with memory it's not a niche language but it's probably not as well known as maybe some others so we could show a brief hello world if you want if i just make a new file here hello.rs we'll start with the main function so there's a bit of sea like then is it a little bit sea like yeah it definitely wants to borrow from that general type of c java that general syntax so if i just print hello world here and close it there so you can see that the basic structure of it is going to look very familiar we use fn to declare a function instead of starting with a return type if i wanted to return something that would come after the function name but the basic syntax of it doesn't look too different the first place where it starts to look a little bit different from languages like c c plus plus is the way we declare variables instead of putting the type first then the variable name then the value we use this keyword let with a variable name then i'm going to specify the type so we're going to have an i32 and let's give it the value 10. so the syntax is a little bit different compared to what you're used to in c and java nothing too different so far the first interesting bit comes in this is the very first bit where rust starts to try and stop you from making mistakes is the fact that if you want to be allowed to change a variable you have to explicitly tell it you want to do that there's a distinction between a normal variable and one that you're allowed to mutate if i want to mutate a variable i have to explicitly say let mute and let's have y i 32 is 20. some other languages do this as well like kotlin you've got a difference between vowels and vars i mean typescript you have let for a mutable variable and const for one that you can't change a few other languages picking this up as well but that's the first place where rust is going to start trying to help you avoid making mistakes if you want to change a variable you have to explicitly let it change the variable and that's going to help guarantee that your variables have got the values you think they have i'm going to go over to c plus plus first because it's going to be easier to demonstrate particularly to people who haven't seen rust before and then we'll switch over to showing how rust has embedded that in the language c plus plus you have to do it yourself rust it's pretty much built in the basic idea of raii i've never i don't know if the i don't know if there's an established way of shortening that like you could you could say i or ray or rye you know what i'm going to call it rey if that's wrong doubtless i'll find out in the comments so the basic idea of r-a-i-i is that when you construct an object you allocate the memory you need for that object at the time you create it and then you make sure it's destroyed when the object is destroyed the idea being then that the lifetime of the memory you request is tied to the lifetime of the object that's using it means you don't have to worry about freeing it elsewhere it means you don't have to worry about allocating it elsewhere when i create my objects i allocate my memory when i destroy my objects my memory gets freed for me it's a load off my mind as a programmer it means i have much less to worry about dangling memory so if i do a brief example in c plus let's have a class called bob and bob is going to hold on to some integers for me so it creates a class variable called n which is a pointer to some integers now we'll have the constructor which is what we're going to call to initialize bob and we're going to pass the number of integers i want bob to hold as an argument and then we can say this n equals new ins x okay so i'm saying that when i create a new bob i'm going to allocate enough memory to hold x integers in c that would be a call to malloc c plus plus has a a keyword to do that so it makes it slightly nicer to program but it's pretty much doing the same thing underneath then in my d structure which is something that c has a destructor is a function that gets called whenever the variable gets freed or it goes out of scope and in my destructor i am going to delete this n and finish my class so what we've just done there as soon as i create a bob i'm going to allocate enough memory to store all of bob's numbers and when bob goes out of scope or bob gets deleted bob releases all of the memory he was using to hold his numbers and that's really great because it means that i don't have to keep track anymore of bob's memory i don't have to remember that bob's holding on to a load of integers soon as bob goes out of scope bob drops his memory produce the chance for memory leaks that's awesome the one obviously slight drawback is that i still have to implement that myself i still have to write that myself so it still puts some of the work on me as a programmer to remember to make sure i've done that properly it doesn't save me the problem it just means i'm only doing it in one place and just sometimes people cut corners with that i don't know if people will cut corners but it's definitely possible where maybe bob's holding a lot of different kinds of memory for different things if i just forget if i miss one of those in the process or this works great so long as absolutely every class uses this pattern if i forget to do that for something and i just use a plain old pointer somewhere then memory leaks can still happen it it sort of if done properly it makes it much harder to get memory leaks but it's still contingent on me as a programmer doing my job properly and implementing it properly mistakes can still happen right one of the biggest actually is that this stops one of the problems with memory management it stops the problem of memory leak which is where i forget to free something it doesn't solve the problem of what you call a dangling pointer which is where i try and access memory after it's been deleted this doesn't stop that so if i add a method to bob that's going to be int pointer get n and get in is just going to return that pointer to the memory that bob's holding right maybe i want to use that somewhere else then in my main function let's have ins main i'm going to make a new bob it's going to hold five numbers then i'm going to have a int pointer that i'm going to call x's that's going to have b get n then i'm going to delete bob and for good measure printf the first number in x's and i should probably include the right header as well to make that compile so what we've just done is we've created a bob bob allocated his memory we then got a ref got a pointer to that memory so that i can do something else with it then i deleted bob and bob was very good bob uses ray and deletes his memory problem is i've still got another pointer to that memory when i try and print out the first element of that memory it might work it might not this is a very simple example i've not done anything else to the memory in between so this will probably work if this was a more complicated program someone else might have used that memory and then at best i'm going to get garbage at worst i might crash right so rey solves one of the problems with memory managements but it doesn't fix any of the others i've still got to be thinking carefully about is my memory still in use am i still allowed to use it that's where russ comes in and that's where rust tries to hold your hand a bit and stop you from making these kinds of mistakes so let's write a simple bit of rust that's hopefully going to showcase these same sorts of things and then i'll explain some of the concepts behind how it's working firstly russ doesn't have classes as such he just uses struts that's probably not too important but let's have a struct called bob and bob is going to have n is we use a vector of i 32s so same as the c plus plus version bob is going to hang on to some number of numbers for me it's got a vector and then when i make bob when i create a new bob let's just say we're going to return a bob where n is a new vector so i'm making a bob and when bob is made he's going to allocate some memory on the heat for me to store his numbers and that's pretty much all i have to do to make sure that bob's memory always remains valid the way this works every variable in rust has something called an owner right every piece of memory has what's called an owner and the owner as you imagine from the name the owner is the person who has control of that memory every bit of memory has exactly one owner and like we just talked about with ray as soon as the owner gets deleted goes out of scope or whatever all the memory that the the owner owns gets destroyed okay so there's our ray principle and that's just baked into the language right if i now write a main function for my rust program here let's have let's n equal bob new then i will end the function there i mean this is a main function so i mean the program is finished at this point so everything gets freed but you know what let's call this funk one and let's then call func one from a different main function just to make the case there we go we'll do it like that so n was created inside func one which is our new bob bob allocates memory for his numbers once func one returns our variable n has gone out of scope so n gets deleted the memory that bob was holding gets deleted at the same time fine that's ray this all hinges on maintaining this property of one bit of memory having one owner okay we need to make sure that that stays true because the moment a bit of memory has two owners the whole system collapses right and that's when we can end up if we go back to the c plus for a moment bob had a pointer to that block of memory that we called n and then i also got a second pointer to the same block of memory our variable b owned that data our variable x is also owned that data and that's where the problem came in so rust needs to stop us from doing that there's a few way concepts that we want to talk about that rust uses okay the first thing we need to talk about is moving let's go back to funk one n is my new bob and maybe i want to get a second variable that refers to bob okay so i'm going to say let m equal n i'm allowed to do that m is a new variable i'm going to assign it to the same thing as n okay that might look like m and n are now looking at the same memory but the first thing that rust is doing behind the scenes it's done what's called a move because we're only allowed one owner to a piece of data i sort of made a copy of it quite the opposite it is absolutely not made a copy because that would mean well you can get a copy but what it's done in this case m is now the owner okay and n not allowed to use anymore if i was to try now and do something with n the compiler would tell me that i can't use n because the data has been moved out of it okay it's guaranteeing that at any time there's only one owner for the data and that applies to function calls as well if i'm going to write let's write funk 2 and that's going to take an argument of type bob and we're just going to print line bob dot n and we'll have the first elements of that in our funk one say let's we'll call func to with our bob variable in other languages when you pass something as an argument to a function either it's going to make a copy of it or it's going to give that function a reference to it but this isn't quite what we want either we're going to end up with a duplicated version of the data or we've got two owners with a function same thing applies our bob gets moved into the function so now my b variable that i defined in the function owns that bob and in funk one if i try and do something with n try and do the same thing i was doing in funk 2 the compiler will warn me can't do that n has been moved so there's the first step where we're guaranteeing that our memory stays safe so that's great right one owner at a time that makes sure that when my variable goes out of scope when the owner goes out of scope and gets deleted i know for a fact no one else is using it there are no dangling references to that data perfect problem is sometimes i do want to keep using my data after i've moved it right maybe funk 2 does something to n but then i still want to keep using n so that's when the second part of this comes in which is this business of borrowing in rust in rust you you have this idea where you don't take ownership of the data but you say just for a moment i'd like to do something with it i'm not going to take ownership of it it's still your data but i just want permission to look at it or maybe tweak it for a bit and i'm going to give it back to you and that's what we use borrowing for and the way we do that in rust is through a syntax called referencing so i'm going to edit funk 2 now so that instead of taking ownership of my bob it's just going to borrow bob for a moment and then give it back the way we represent that in rust we just stick an ampersand in front of the type and that says that funk 2 gains a reference to a bob it doesn't take ownership of the bob and then i put an ampersand operator in front of the n as well in funk one and that says don't pass n into funk 2 pass a reference to n into funk two so now funk 2 has borrowed bob it can do whatever it wants with bob but then when the function returns funk 1 still has ownership of bob because funk 2 just borrowed him he didn't take him up take control of him completely and then if i was to compile this funk one now it would compile absolutely fine no issues so between this moving and borrowing we make sure we've got our ray principles sort of baked into the language and we make sure we don't have any dangling references so presumably if something's borrowed like any good library book you need to give it back at the end is that how it works yes exactly so the borrow gets given back at the same time as it would be deleted so at the end of funk 2 funk 2 does its thing it's done and that kind of gets given back it's slightly different though this is the last thing we'll talk about [music] because i introduced at the very start the idea that rust has a difference between if you want something to be mutable you have to explicitly say so right and that plays into referencing as well because you just talked about library books if i borrow a library book eventually i've got to give it back that's all you get fined or you get fines which in the which in this case i guess the compiler would just refuse to compile i guess the analogy is slightly different because so long as i'm not modifying the thing i've borrowed multiple different functions could borrow the same value okay if i introduce a function called func3 a bit like them being able to read it but not to write to it exactly yeah yeah if i just borrow like normal i can read the data so here i'm going to print line i'll prints the second element of n now i mean everyone's going to tell me i haven't put anything in n yet so technically this wouldn't work but you get the point funk three so instead of passing a reference directly let's have n1 is a reference to n and two is a reference to n and then i could call func to with n1 c3 with n2 andreas going to be happily fine with that because neither n1 nor n2 is trying to modify n they can both borrow it and it's absolutely fine what russ doesn't let you get away with though is a mutable borrow if i want to modify a piece of data that i'm borrowing i'm allowed to do that let's say function 2 now is going to modify bob i'm going to tag that mute keyword onto the end of the reference to tell rust that i want a mutable reference and then i could do stuff let's reassign n in here for example okay so function two is going to modify bob and that's allowed i'm allowed to borrow something and change it so long as i say so and let's make n1 a mutable borrow but what rust is going to tell me is that i can't have a mutable reference to data and an immutable reference to the data at the same time because you can imagine that situation if i've if i've told my function that it's getting an immutable reference i'm telling it that this data is not going to change you're not allowed to change it and i'm yeah i'm guaranteeing to you your data is going to stay the same if i have a mutable reference and a immutable reference at the same time you can see how that causes problems it's a slightly different type of problem this is a problem where the memory holds something different from what you think it should and so again the compiler is going to stop you doing that it's going to say no you're being naughty you can't have an immutable reference and a mutable reference to the same bit of data at the same time so it's protecting you from accidentally modifying data that another bit of your program assumes is constants really we've just touched on the main sort of way that you'll work with memory and rust this business of moving and borrowing there are other bits to it if you want to do it in the old c c plus plus way of manually allocating exactly what you need and manually freeing it when you need you can do that right russ supports that it just forces you to put it in a special block that's marked unsafe to make sure that you know as a programmer you're taking 100 control of the memory there are also constructs that you can use if you if you want to use that reference counting sort of garbage collection style of things that's particularly useful if you're sharing memory between multiple threads you have construct available that'll do that as well and i think this is one of the reasons why people like frost it's certainly why i like it is because it gives you this whole range of options for how to work with memory borrowing and moving is great for the vast majority of cases sometimes actually i want reference counting because sometimes i do one several different people to take ownership of this data and so in that case i can introduce some reference counting and and it will take care of it it'll be a bit slower but i can do it other times maybe i want precise fine-grained control of when memory gets allocated and freed because maybe i know that i can free up some data halfway through an object's lifetime and i can do that as well i can open an unsafe block and start using pointers directly russ lets me do that as well saves a whole lot of complexity in writing the code for not really much downside really stairs is red and football is great it's a terrible example because you wanted memory you had to ask for it and release it yourself so there are two primitives here one's called malloc and malloc says give me some quantity of