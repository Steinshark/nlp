okay so today we are joined right here by uncle bob the robert martin himself how you doing i'm well thank you why don't you give like a kind of an introduction to who you are so anyone that doesn't know they can get to know you oh heavens yes i'm uncle bobber i'm bob martin some people call me uncle bob i've been a programmer for 50 some odd years written all kinds of code in assembly language and c and fortran and cobal and and c++ and java and nowadays i work in closure that's the language i enjoy you may know me also as the author of clean code and a whole bunch of other books over the years so that's who i am you also signed the original agile manifesto 2003 february 131 february 2001 yes that's true we were all there together yep 17 us i just have to ask how did you get to closure because i i did read that article where you talked about closure and all that and i think that's how we had our first introduction is me reading that article which i just find closure to be such a bizarre language jump from from i guess the more like will we call it enterprise java style programming yeah so yeah it took a lot of therapy to get the closure somebody gave me a book recommendation 20 years ago and the book was the structure and interpretation of computer programs an old book right out of the 80s and i i got the book i think i got it on ebay and it was a secondhand book i stuck it on my shelf i didn't read it for a while and then one day i started just thumbing through it and the book just captivated me it was like one of those moments when like oh my god what the hell am i reading here and what's the name of the book again can you say the name one more time the structure and interpretation of computer programs which you can get for free nowadays it's sip. org i think okay i don't think i've ever read that oh yeah well you can google it you can get it for free you can also see all the old lectures by abson and susman they're all online and you know 1980s guys drawing parentheses on the blackboard very very fun fun stuff to do but the book just catalyzed me it energized me i thought well this is interesting and of course the language was lisp or it was scheme right a lisp derivative and i thought okay i had for 30 years thought i'm never going to learn lisp i don't want to learn lisp it sounds like a dumb language no i'm currently on that team and i'm i'm crossing my 20 year mark so i'm close okay so i read that book and it changed my mind and i thought okay i i got to get a list and i just happened to bump into closure i i had known rich hickey off and on for for long years cuz he used to debate on the c++ news groups back when there were news groups and i saw his work on closure and i thought i'm gonna get this language i'm gonna didd around with it and this was probably n 2010 and i just fell in love with the language it was just wonderful and i've been using it ever since wow okay yeah what is like just because i i'm i'm i'm fairly kind of stuck in my se look language ways i generally don't i i just we were having a talk earlier that i think one of the reasons why functional style languages are largely unsuccessful is because their syntax is stupid is what i was saying when i say stupid i mean that the average person who's had 10 years of programming that looks at functional syntax they're they're just like incapable of just even reading it to begin with it's just so divergent from what is like kind of the zee to programming and so how was how was that transition because that is that that's clearly a weird you you fell in love with it was there like a hard period was there a time where you're just like why am i doing this to myself so the the syntax of lisp and therefore closure is so absurdly simple that there is no syntax barrier to cross and there there's almost no syntax to the language so the most startling thing when you get into it most startling thing is you're asking yourself where where are all the handles how do i control this language where's the class keyword where's the type keywords where are all these keywords and the answer to that is there aren't any and all you really have are a couple of very very simple gestures which by the way makes the language remarkably expressive the less syntax the more semantics as it turns out so is that good or bad both okay it's both good and bad it's a it's a double-edged sword although i i air on the semantic side i like the expressivity if you've ever done any fourth i have not done four another one of these languages that has almost no syntax small talk another language that has almost no syntax there are a few languages like that and they become very expressive because you're not constrained by this big syntax iron curtain that drags around you all the time yeah but you have freedom to kill yourself so so that does that mean because i've heard this stated before and and i i don't quite understand it because i don't have the experience with lisp to actually like really concretely understand this besides for you know a square on a blackboard that every kind of lisp program is almost its own unique language onto itself is that does that kind of follow up with because you can kind of define everything yourself cu there is no real there is no real syntax as you said and so people kind of really create their own structures in every kind of unique way and so when you go from one to another you have this like you kind of have to adopt the person's mentality who wrote it this is generally true of every language right when you're when you're a programmer what you're really doing is you're inventing another language to express your problem in in in lisp the the syntax is so sparse that all you're doing is inventing another language to express your problem in without the constraints of the language syntax the the language also has a number of features that make it very easy features is not the right word affordances is a better word that make it very easy to add facilities to what appears to be the language i'm being obtuse on purpose but but there's no other way to say that okay okay i i think i i think i understand what you're trying to say if if i were to resay that it sounds like you're trying to say that the language allows you to make things that look like it's a part of the language that's correct and not something you've created thus this whole idea of you kind of invent your own every list program is its own language onto itself is partially in some sense true yes that's certain certainly true i i again i'll say also that every every programming language does that but it's most pronounced in a language like bl okay so how do you how do you reconcile because i you know you may have heard of clean code how how do you reconcile some of the approaches that are suggested in there with a language like closure because it sounds like closure is much more wild west and has very few constraints so you have to be more disciplined in closure there's you because you can go off the deep end really fast but the the clean code book is all about discipline so the the ideas in the clean code book move very well over into closure there's not there's no real friction there okay i like to keep my functions nice and small i like to keep my names expressive i like to keep my modules relatively small all of that is very easy to do in does does it have a concept of interface yes it does you can have polymorphic interfaces there's like three different ways to do that since closure rides on top of the java stack you can actually create java interfaces that a java program can call although you're doing it all in closure and you can also call java interfaces from closure so the the interoperability between the closure language and the java stack is almost perfect not quite almost yeah okay that makes sense i mean a lot of the jvm languages you can kind of call between we did a lot of groovy you may be familiar with that y that idea we'll call it an idea we i did a lot of groovy at one point and it's i mean you can call java functions really easy you know a lot of concurrent hash maps and all that but it was an experience nonetheless kind of working between jvm languages can sometimes be fantastic and sometimes be a huge pain so all right so you you're you've been off in the closure land and all that and you know there's a lot a lot of neerish languages go and rust i think are probably the two most big kind of splashy new languages if you will call it new and splashy that a lot of people have been kind of very excited about h how does clean code intersect those two languages i don't know a lot about rust i've only kind of looked at it cursorily go i'm a little more familiar with i've done a little bit of work in go i mean go is essentially c with a couple of widgets attached onto it and and very easy to do clean codish like things in in any language that's derived from c and any of the c style languages clean code is real easy to to work with in fact i'm not sure there's any language that you could not apply clean code to except maybe cobalt well cobalt is very very unique onto itself i' i've i've only done probably like 10 hours of cal it's it's very very tricky people are also saying is this true is pearl is pearl also is pearl also clean coatable probably not that's okay that's i actually have i have a i have a friend that may or may not be in this chat whose mother programs pearl fulltime wow i know no that's i didn't even know that was a position i didn't even know that was possible permanent pearl programmer permanent pro pearl programmer the the triple p all right so let's get kind of into some more the the fun stuff so the general goal here today is that i'm not trying to make this into some sort of debate i think debates largely tend to i mean the purpose of a debate in my head is that you try to make the crowd think like you and not necessarily come to any sort of agreement or understanding of one another's argument as much it is to try to defeat the other person if that makes sense and so i want this to kind of be more of like how do you think about things and then i'm going to try to represent as best i can maybe twitter's general thought process twitch's general thought process which by the way could be very room temperature iq for for you to kind of talk back and forth with does does that sound good sure that sounds fine all right so i the i i think for me the most important question to ask is that in the last about i'd say in the about 15ish years cuz when i went to college and when i started going to college clean code the gang of four this kind of this kind of we also had java as our primary language of of learning programming with was a very like important part when i would go into interviews it was always like all right tell me the you know tell me the design patterns that you know can you explain this in you know in these terms right solid was brought up a lot all that kind of stuff but then as time has gone on it feels like that's no longer talked about i i really don't ever hear the term design pattern ever discussed among anybody what kind of what kind of has caused this shift and do you think it's a it's a direct shifting away from something like clean code or is it just a nomenclature change among people what has caused the shift is what has caused that shift in the last 50 years the same it's the same effect and and the effect is that the demand for programmers is so large that the number number of programmers in the world doubles every five years or so and there's no way to keep up with a a a a way of thought when you've got a doubling of the number of people pouring in right so you might have some thought leaders from 30 years ago who had some really good ideas those ideas have been swept aside by the wave of people just pouring in and it's very very difficult to maintain any kind of consistent mode of thought when you're in that kind of demographic deluge yeah that makes perfect sense one of the things i try to do is yell out enough so that people remember some of these things and bring them back into the present so that they can look at them and go oh there are these things called design patterns gee i didn't know anything about that well maybe i had to read something about that by the way you know the design patterns book is probably the most important book written in the last 30 years and it's been swept away by this wave of incoming people do do you think that a lot of modern software can have the same benefit with these design patterns because i i'll i'll tell you like personally i i pretty much am a strategy pattern guy right i think the strategy pattern really is the basis of all patterns right i mean it's pretty much that is life is strategy that's pretty much just use an face do you think that much beyond that knowledge and the builder pattern that there is a lot of usefulness still to continue to like dive into these patterns oh there's a ton of usefulness to it because the purpose of a design pattern is to have a name on a structure so i can say to you well i think we ought to use the visitor pattern here and if you know what that pattern is which you're right it's just a bunch of strategies but if you know what that pattern is then that structure snaps into your mind and you and i can have an intelligent discussion about it and we can have a a a discussion of the of the pros and cons or if you're sitting there reading code and you see oh this is the xyz decorator and you happen to know the decorator pattern then the structure snaps into your brain and you don't have to work it out by reading the code perfectly right that's the whole point of design patterns to say a way to take one notch up on the level of abstraction so that you can look at things in the code and identify them without having to go line by line by line by line yes okay no i mean it's a very good answer because you know we often have a lot of data structures or algorithms if i say hey this is a general tree you already know what a general tree is right you don't have i don't have to explain to it that you have zero or more children right like that's just not a thought process we have to have so therefore you could make the argument that if we know what a builder pattern is and i say hey let's use the builder pattern you and i are both probably thinking something that's very very close to the same thing it may be slightly different but for the most part at least close to the same thing okay so i i think that's actually a pretty reasonable argument for design patterns but one thing can i say it this way that a lot of times what i see is that when people kind of are really into this because remember netflix was a ja a large java shop was there for a long time and so there was a lot of patterns i i i often find people reaching first first for a pattern and an abstraction before the problem is ever solved what do you think about that because i know you're you're very into the design first and then program kind of approach you said that in casey's gosh you said that in casey's here let me bring up your exact quote sorry i i did do like a little i i did try to at least read one thing right you said you said it was the latter zalot who thought it was better to leap into code without any forethought and that was kind of like there was some context to that of course but the the general idea is that some people or your suggested ways to like kind of design all things and you kind of create the abstractions and think about the structure of your code before you start coding is that correct am i am i am i correct on that one yes with caveats but yes okay a lot of like modern or at least what i would call modern thinking at least like the go way of thinking is that you kind of almost do somewhat of the opposite that you don't reach for abstraction first you actually try to get the thing itself first out and you allow the abstractions to more naturally percolate or manifest themselves h how how can you kind of resolve those two school of thoughts no i don't think there's a resolution there so so the way i work is that i will i will do the most concrete thing first i will think about the problem you know i'll and and you know the amount of thinking i do is an hour maybe okay and you know maybe i'll scratch a little design on a whiteboard or something or a piece of paper i'll think about it and then i will then i will enter it if the problem is large enough then i will do that and then i go right for the most concrete thing i can and then i i have the problem force me to become abstract as i'm adding more and more code it starts to get harder and harder to add that code without adding an abstraction of some kind and so i let the code force that abstraction upon me and i continue that process and typically you want up with an awful lot of abstractions once you follow that process do you ever knowing like let's say that you have like i don't i it's hard to always to come up with these examples kind of off the top of your head but you have something that you could easily see into a series of if statements or switch statements like right you have a message type that you're going to be handed it's a string and the first one is just message and then the next one you know there will be more but there might not be many how do you determine when to abstract vers is when to go you know what if there's three hardcoded strings i'm fine with that like when when do you make this decision for me it's a kind of feel thing as i'm working in the code i look at it and i i get this itchy feeling in in some part of my face or gut and i think oh man that's going to kill me later on and at some point that's overwhelming and then i make the abstraction but a a switch statement with two cases three cases probably not going to get upset about okay is there do you have a number that you put on it or is it really just only feel like can can five be too many like is there ever too many well i i think yes you can say a thousand is too many but agreed yeah there's no there's no hard number because it all depends on the context right if i'm if i'm putting together a program for a demonstration that i'm doing and i'm going to throw it away i'm not i'm just not going to worry about it very much on the other hand if it's if it's for a client and the client has a long lifetime and they're expecting to make you know a lot of changes to it then i'm g to be a lot more careful okay have you ever have you ever had a situation let's kind of keep on going with this whole message thing right you're coming up with some sort of custom protocol that's going to have a various set of commands have you ever reached for abstraction first and then regretted it in my younger days it's it's a hard lesson to learn right you because abstractions are beautiful and they're enticing and you want to do them and it looks so grand and after a while you learn well abstractions come at a cost and you will pay that cost as soon as you use the abstraction and it will not pay you back unless there is some reason to have that abstraction there so in my younger days i did a lot of that but having become old and jaded i try to stay as concrete as i can until i'm forced out of the concrete world you know that's it's it's funny it's funny you should say that because i i often you know i we have enough people hanging around here i don't know where we're at right now let's just grab a quick number 3,400 people currently watching and i often i often see kind of it's very hard to tell somebody a lot of these rules that i've kind of come up with like why do i approach software in this kind of specific method and a lot of it just comes from the fact that exactly what you said which is well one time i tried to make a game and i had seven layers of inheritance you want to guess how much i hated that experience yeah i i really did hate that experience because not all burgers are cheeseburgers and eventually you're just like i just need a whole new burger archetype you know like it just it just you just lose it and you kind of have to go through this experience a bunch of times before you kind of have like a a general feel of software and based on the things you're saying you're actually not really far either from the go philosophy like it is good to sit down and kind of think about what you know kind of what you want to build here i generally i i generally don't feel like i have to think hard in the sense that whenever i give a problem i just know the structure i want it to be and that is usually good for what i know what the inputs should be which obviously all good all good plans die at first contact right like they never they never go past that and so it's like oh i was totally wrong about like eight of my assumptions i guess i have to redo all these things have you ever been into the uml days like was there a point in your career where you were like big in the uml and oh yes absolutely mind okay about this cuz i was so heavy into it that's where like all my seven layers and all these things came from was that i was umling and dotting and compos it you know i was really into it oh yeah yeah yeah yeah yeah now me too and i still use uml from time to time i'll draw some diagrams on a board i know how to do it but that was a that was a time when we thought that we could capture software in a very abstract way and the goal was for highlevel analysts to draw these diagrams and we wouldn't even need programmers we could generate the code from those diagrams that was complet ridiculous failure i i i i may or may not have generated some code from uml at one point in my lifetime there were many tools there were many tools that could do it and and there's you can do it in intellig today you can draw a uml diagram and it'll generate code for you but who cares you don't want to generate code from a diagram that that has been tried so many times and it has failed every time it's like it's always the wrong solution unless you have an extremely constrained environment yeah that that actually makes a lot of sense i feel like if you are purely working in a black box you effectively can engineer that solution out because it like everything is known there's there there is no questions right like i had a i had something i had to build a long time ago for a little bit of a satellite that had 256 bits it's like you know what i could test every possible pattern or there's 256 possibilities it was eight bits it's like i could test every single possibility and we can actually design this to the 100% there is no you know like there is no possibilities that we won't be prepared for but that's kind of where i lost my uml mojo is after that cuz i realized that as kept going i kept designing these things and then again first contact with the enemy and my diagram was completely wrong and i spent so much time on the diagram oh yeah yeah that's that's always a problem and back in those days we used to think that this is before agile before the agile movement we used to think that you should spend weeks and weeks on those diagrams get the diagrams right first and then the code will just pour out well that never worked yeah i spent six months on one and it did it made it it made it three hours into programming before i realized that i made a program so slow for a supercomputer it couldn't run on a supercomputer and i was just like were we smoking man it was bad six months to be destroyed in three days or three hours okay well speaking of agile that's that's pretty a a pretty kind of a hot topic here how do you feel because you obviously signed the original you're one of the signatories or whatever they call whatever word they use there of the original agile manifesto yes how do you feel like the last what is it 23 years have gone since the since the agile manifesto has come out i wrote an entire book describing my feelings about that topic it's called clean agile i'm the old fuddy duddy who's yelling at the young kids to get off his lawn right the the agile the agile message has gotten so badly twisted and and torqued and perverted that i i wrote that book to try and reboot the whole thing say well nope that's not what we were saying you know what we were saying is something else agile was a small idea for helping small teams do small things it was not the overarching pattern of software development that was to dominate the world it was just a way to get six or seven guys to be able to work well together okay so what what made it fall apart then i can tell you that exactly how long do you have i have to help my wife move in 26 minutes okay well this won't take that long one of us decided that we wanted a scrum advocate ken schweber decided that he wanted to teach a course called the certified scrum master course and he came to me and he said hey bob can i borrow one of your offices so that i one of your classrooms so that i can teach this and i said yeah go ahead ken that's fine and he taught the very first certified scrum master course and the and the idea just took off everybody wanted to be a certified scrum master not one programmer wanted to be a certified scrum master all the project managers wanted it they wanted that little checkbox on their resume and the project managers flooded into the field they flooded into agile they took over the message they took over the conferences they took over everything and they literally pushed the programmers out and adob became a project management idea and the programmers looked around like you know they were left on the desert island and looked around like well how the hell did we wind up on this island and why are they sailing away in our ship that's what happened to agile so so what is the because i i often make this joke which is agile's a lot like communism you know people just keep not trying it correctly what is what is the correct way to agile oh gee it's a real simple idea right do things in really short sequences measure how much you get done in every sequence use that measurement to project an end date and tell everybody that's kind of it we could go into you know lower level details if you want but that's pretty much it do things in real short short segments like one week long right measure how much you get done project that out with an end date and then tell everybody hey that's the end date that we look like we're seeing and generally that date is so terrifying that people are like oh maybe we've got to do something about this early enough to actually get something done okay so so there there's so proper agile has no dictates on how the team accomplishes or even the timelines or the weeks days that are used to measure these short cycles shall we call them sprints yeah in scrum they're called sprints the there are individual implementations of agile so there's extreme programming there's scrum there's fdd there's dsdm there's a whole bunch of these processes that are more do sounded like drugs more than anything else are we sure we're on the same topic i'm pretty sure one of those is the dream drug i've heard about it yeah well i think a lot of them are dream drugs but but they are more defined agile is not agile is just this framework that says hey you know do it up do it in short cycles for ch sake and and that's kind of it now i i happen to be an extreme programming a fiction a i like the disciplines of extreme programming so you can you and i could have discussions on things like pa programming and test driven development and refactoring and simple design and things like that where we could get into a lot more detail but that's just an extension on top of agile okay i i mean i like this topic a lot we don't have a ton of time so i don't want to i don't want to linger here too long but i mean to me that this mo m oh my goodness this mostly makes sense in the sense that as far as i can tell i think netflix is one of the best executors of agile in the sense that no two teams operated the same every team was independent to choose their process how much process how much process they wanted what is their cycles how are they making promises how are they interfacing with other teams like everyone was their own kind of tower onto themselves and it largely worked for quite some time obviously as things kept growing things you know there's always friction no matter which way you choose we always said we choose people over process which i think is the right kind of way to go about things i think that is very agile in in sense but it's kind of good to understand kind of how the breakdown effectively happened and it makes sense that if agile is not applied on the individual basis it will it becomes well just becomes a series of meetings and all that how do you convince like a company that they're doing agile wrong and that you should leave it up to individual teams and individual teams should make their choices because that inevitably suggests chaos right like there is a level of chaos to that that you cannot control if two teams decide two different release cadences yep yeah where agile breaks down is when people try to put an overarching envelope around the outside and then demand certain behaviors across the board just was never designed for that so so how do you convince someone that they shouldn't do that right because that's that's largely how agile is kind of practiced today is that it's like everybody it's you know standups five days a week for everybody you know we do this we do this we do this like how do how do you say no no no no let those three people make their own determination let those five over there make their own determination and then they will figure out how to talk to each other like how do you convince management of said of that that because that sounds like the wild west sounds like chaos so i do that by writing books and yelling at people and things like that but but how would how would someone do that if they were trying to introduce agile into a an organization yeah how to introduce agile into an organization with scrum shall we say oh okay yeah how do you bring scrum into an organization so that always sorry say it again the inverse that it has scrum the kind of the ridiculous you're like now let's introduce agile let's how do we introduce the actual concept into this place how do we undo the scrum poison i don't know how you do that i don't know how you how you convince people to behave in a different way my whole career for the last 30 years has been in trying to convince people to behave in a different way and i've had some moderate amount of success just by yelling loud and publishing a lot but when i get into an individual company it's very very difficult what what will happen to me is that i will wind up leaving that company with one or two people who kind of got the light bulb on their head and then they leave they leave the company they go somewhere else that might not be the best selling for your contracting at all be like by the way if you bring me in you lose some employees well i don't do that anymore i don't do any of that stuff anymore to say that yeah all right all right i want to get to the the the things that i think are more probably exciting for me so i have a i have a really dumb rule of thumb when it comes to programming and it's it's a personal rule right which is that whenever i see columns exceed 80 i generally think what am i doing here now i i don't have a problem with columns exceeding 80 it's just kind of like a general heart mentality that when i've done that i kind of look back and go man i probably have a bunch of like maybe i have a nested function in here maybe i have two four loops that are nested i've just i've done something here that's probably slightly unusual to get out this far unless if i'm of course programming java or c++ then it's you know then you have to extend that line to a new new position you have one which is you don't like functions beyond four to six lines you know like that's your kind of smell how did you arrive to that because i i i have i have a few question questions on this so how did you get there so first of all on the linewidth side i don't set that at 80 i set it at 120 i did a statistical analysis on that and found that that if you go beyond 120 you're outside of the vast majority of programs ever written yeah yeah again mine mine is completely irrational so i'm not saying that you have to have rationality described this is just my feeling punch card width so that's rational 80 columns we've been living with that for 50 60 70 years now yeah function width function height right the number of lines in a function i don't really have a limit there i have said a number of times that i like four or five or six i think that's a good size for a function if i ever get a function that's 10 lines long it's not like i'm gonna throw it out it's like oh it's 10 lines long wonder why and then i continue on i like them to be small and the reason i like them to be small is that if a function does more than one thing and i can pull the two things apart and give them individual names i find that to be more readable that's that's the bottom line that's the only reason would the inverse could you say this kind of an inverse which is the more functions you have to go through to understand what is happening also the more contextual overhead you have to have cuz i can imagine if i had to have 20 lines on screen that kind of describe a few step process i can kind of keep that in my head cuz i don't even have to like use an lsp i don't have to use anything to jump to these definitions they're just like right there in my head but if you're always splitting these functions up it can also be difficult to be like okay what does this function do okay well this function is broken into two more functions what do those two functions do okay now understand those two let's undo that one let's undo that one let's go to the next one okay now we got to go you know you kind of effectively build a tree in your head of what is happening h how do you prevent that type of explosion with that type of rule so i don't prevent that type of explosion if if if that happens to me there's a single keystroke which will just pop those functions back in right the inline refactoring so in intellig i can just go you know control all then control all then control all then and it puts that whole function back together and i can read it so if i find myself in that situation then it's easy for me to undo it i also then realized that i had partitioned it incorrectly because if i find myself that situation it's because i did not put those functions apart correctly i did not give them the right names so that's a test for me right i can undo it and then redo it in a different way that maybe flows a little better the fear that you will drown underneath a sea of little tiny functions is not a very good fear what you want to do is state what each function does give it a nice name so that when you see a function and you read it you understand what it's doing without having to read the next function down if you can get that goal if you can get it so that you can read a function and not have to understand the next three functions down you've gained a big leg up on the problem of understanding what a system does yeah i i feel like that's true if mutation is low in the sense that if you have a complex enough problem right like if you write let's just say any new modern ui framework and you're in in the driver's seat and you have to sit down there and you have to do the actual writing of the framework right that would be understanding what a function does simply by its name could become excessively difficult if you've ever read through any of the source codes anything like that even though you can kind of understand it you kind of have to read the code to first really understand what these names mean and so that's always been kind of one of my my my problems because what what what i personally find happening is that i have a lot of these smaller functions and you have a lot of this and then you go to code review and code review is really where i think a lot of these weaknesses kind of show up cuz i can't look at the code without clicking around hopping to different files hopping to different locations trying to gain it in my head because it's like the code was written to be lsp navigatable but not reviewable if that makes sense yeah i understand i understand the fear and i understand the experience you know i've experienced that as well you you get badly partition code and you're leaping all over the place and you don't know where anything is and you can't keep anything in your head because you're constantly going here and you're constantly going there but that is a smell that's a symptom that's not that doesn't follow from the the process of breaking things down into well structured bits and giving them nice names you can break things down into little bits and giving them nice names without forcing that jumping around and that's part of the part of the part of the discipline of clean code you don't want to create those those nests of leaping around okay if you you've looked in the book you've seen that i like to order the functions in the order that they were called so inside of a class i will say well here's the main function and then below that are the ones that that guy called and below those those are the ones that that guy called so that you can read down in a single single scan and stop at the point where you say oh i think i understand everything i don't need to read the rest i don't get that last part that sounds very difficult but i but i difficult yes yes that's why i'm just like man i don't know if i could i don't know if i could do that i i generally have a a different a slightly different ordering but i'll grant that to you i put the most complicated usually at the bottom the least complicated at the top the least complicated are easy to kind of zip through where's the most complicated tends to be very meaty and slow rolling okay okay i just wanted to get get that out because i always have a hard time kind of reconciling how how those work and how they work in principle it what it really sounds like to me is that what you're trying to say is that you need the program for 20 years bite your shoot yourself in the foot a lot of times and then a lot of these things make more sense cuz i mean i'm not trying to put words in your mouth but that's generally the advice i tend to give which is that you have to shoot yourself in the foot a 100 times before you realize how you shot yourself in the foot and then you don't shoot yourself in the foot as often the way i like to to say it is that i i like to be polite to the next person coming right so any kind of code that forces someone to puzzle it out or leap around is rude it's rude code and i don't like my code to be rude i want it to be polite do you think that there i mean isn't some level of code you have to jump around you have to puzzle it out because i'm not sure if names can always convey the context because often the difficulty isn't in some sense the names though naming is very hard it's in the state change and the state change can really only be discovered by not just what the function's name is but by understanding why the state changes and how that affects the next said calls isn't there always going to be some level of like sorry i mean that's for that's why we both agree on the low comment thing i think comments are largely useless accidental and essential complexity there's an essential complexity you cannot get rid of then there's a bunch of of accidental complexity that programmers add to it that they didn't have to and you know my goal is to eliminate to reduce the accidental complexity to as close to zero as you can get it okay i like to rite a nice a nice 100% accidental complexity line it just feels good job security all right all right how about how about tdd so i've i i've been i've gone back and forth on tdd you're a very tdd fell right it is a discipline that i value okay let me tell you my t my tdd success story when i was a when i was a young fella long long time ago we had this app at a company called web filings now known as worka in which we had the original flash app in which people who are doing 10ks and 10 q's public quarterly reports would do all their editing along with a spreadsheet you could link values and all that update your spreadsheet boom it flows through all your documents all your documents are now up to date with your spreadsheets pretty nice and so you could do a comment on a spot and then someone could review it change all of that and we also had an ipad so i was in charge of the ipad the ipad you could zoom and do all that that was some fun matrix equations for zooming and doing all that because there was no zooming this was just a web app and a canvas and so we just you know we invented our own math there and so we did all that it was a lot of fun but if you touch the screen i need to be able to start a comment by you touching and dragging so that's kind of like a fun unique problem to kind of have and the thing is is that that has to line up with the original doc so it's like okay well i know a lot of this information i know where every character starts because we did our own handrolled kerning cuz kerning had to be identical to the flash app as it is in the ipad app which is an impossible problem by the way so you have to just infent your own kerning and write every single letter and so that's what we did we handrolled all of our own kerning and so i knew where every letter started i knew where every everything about every page and so therefore i could write my own like test before i ever even started because i'm like we need a search algorithm that when i press this it behaves this way this goes in this comes out i know everything about the problem it was a perfect what i'd consider a perfect tdd problem but i've never had that again okay h how my my my big problem that i see with tdd or at least how i feel about it is that i only know so much and most of the time i don't get the information that i need it's like hey let's do something we've never done before i don't even know what the enemy looks like yet why would i want to write a test first so as a yeah the way i do tdd is about one line at a time you know i will write a test and it's a very small test it's maybe one line or two lines and it will fail and then i will write a line of production code to make it pass this is so far below the idea of gosh i don't know what this code's going to do because i clearly do know what it's going to do that i can very easily write a test for that code in essence what i am doing is i am practicing double entry bookkeeping for every line of code i write i write a complimentary line of code that checks that i wrote the right line of code just the way accountants do with entering numbers into spreadsheets right okay i'm going to enter a transaction over here i better enter the the the complimentary one over here and make sure the balance sheet is still zero that's that's what test driven development is it's double entry bookkeeping it is a way for me on a minute by minute basis to be sure that i have not done something so globally stupid that it'll cost me three hours of debugging time well i guess the the followup is is why not write so this is generally how i do it i think you said you watched the stream for a little bit earlier so you saw me where i developed the tower defense the chat aggregator and then after i kind of i like this structure i kind of like what i have here then i go and i go okay let's i'm going to now test this to make sure it's correct like right i never i am not a fan of of of trying to run code to see if it's correct in the sense that like i'm going to now fire up the whole program to make sure i've written this few lines correctly because that is just like such a nightmare testing cycle that i always do reach for unit test pretty quickly as a as a means to drive correctness and implementation not as a means to develop the thing right so it's kind of like where the fundamental distraction comes from is that if i were to start off with a test it kind of almost feels like i've kind of kind of already pigeon hold myself into what i want to do when it's like well maybe i don't want to do it this way maybe i don't even know how i want to interface with it yet and so do you ever find yourself writing some test code writing some code realizing oh okay i can't even do it that way then going back to your test code then reformulating your test code and then going back and reformulating this and kind of doing this back and forth on it sure that happens all the time so why not just start with your base implementation first there's another another reason that i want i'm very curious by the way i'm not trying to like fight you on this i'm super curious on this no no no it's fine fine honest questions i know we talked about honest questions all right so there's another reason that i want that that test or those suite of tests i want to come up with a suite of tests that when it passes i feel comfortable to deploy i don't want to have to go through a long burins period you know where you you get the system running for a month and everybody kind of stares at it and wonders if it's going to crash you know i don't want to go through that i don't want to go through a long manual qa process with the a bunch of guys in india banging away on it i don't want to go through that i want to i want to cut that off as much as i can so i'll have a suite of tests that i can run and if that suite of test is covering almost every line of code in the system i have a high degree of confidence that i can take that code and move it closer to deployment i have worked on systems where that passing suite of tests was deployment we would just deploy it right then and and if you're going to do that you better have a real high degree of confidence in those tests so because of that i use this discipline to keep keep the number of tests high and and every line of code is somehow covered more or less now there's a whole bunch of exceptions to that there's a whole bunch of places where that just doesn't work a whole bunch i shouldn't say a whole bunch there's a number of places where that doesn't work but where it does work it's a discipline that i like to follow it it makes me feel very safe so i i kind of have like a different i guess view on testing which is that i can only test the things i know about meaning that i i actually have zero confidence every time all the test pass green i have zero confidence that there's not bugs in it right like i just i'm just like there's probably bugs like i just simply don't know what i don't know and so even though all things are green i'm highly confident i've screwed something up and so that's kind of always been my general approach which is that's i mean this is probably where or the reason why i write my base implementation first and then come back with the test because i i already know what i know and i'm not going to i'm not going to catch anything unless if i've just programmed wrong and the things that i already know would break they break so how so so so why does it this i mean so you say this 100 line you know this 100 effectively you're you're broaching the subject of 100% code coverage and i largely think 100% code coverage is a lie i don't think there should be even a number on it why why do you try to test every line try try to test it first of all i agree with you i don't want to number on it any kind of number you put on that is is a lie but i think that you're also you're always shooting asm totically towards 100% and i do that because i want that test suite that i can trust i have lived in that world where the test suite was so good that i could trust it and de employ and what that also allows is for me to fearlessly refactor if i need to change the design of the system and i've got a suite of tests that i really trust i can rip that system to shreds i can tear it apart in a in a period of two or three hours just making sure that the tests all all continue to pass change the design rip things out move things around change this change that tests all still pass and i'm running those tests all the time to make sure they still pass and i can i can have absolute control over the code that way and i use the word absolute it's never absolute but i i have a high degree of control over the code if i have a suite of tests that i can trust so i have lived in the world the other world i have lived in the world where the suite of tests can't be trusted right and there's no point in running them it's like okay the test passed so what i know there's bugs in there that's what i want to avoid that's what i want to avoid i don't want to live in that world now i'm working on a project right now half the system is has a suite of tests that i can trust and half the system doesn't and i i have a nice division between those two parts happens to be the gooey right that i can't test properly and then the rest of the processing code that i can and i have one way of dealing with the code that's under test and i have another way of dealing with the code that's not okay and so there's there's a lot of things that i want to talk about within all of all of that there's just so many of them right all right so i guess the first thing is that we you did talk a lot about refactoring refactoring confidently i guess that really dictates the type of test you're writing then right that must mean you don't test individual functions you test only contracts and is the assumption that when you refactor the contract doesn't change yes so that this is something you learn over a long period of time when you're doing test driven development you have to write your tests in such a way that they don't couple to the implementation and that first of all that takes a very long long time and then once you do learn it it takes a long time to learn and then once you do learn it you realize that you're only applying the exact same principles that you apply to all the code you've ever written before right because anytime you can touch a system in one place and it breaks in many you've got a design problem that's the that's the definition of a design problem touch it here breaks in 10 other places over there well that's also true of tests if i touch it here and it breaks 10 10 or 20 tests i've got a design problem so you internalize a developer well so you have a requirements change how many tests should break if the requirements change and the answer is one if you can get there it's not always easy to get there but if you can get there it should be one how many modules should you have to modify when there's a requirements change one if you can get there that's kind of the goal of design you want to focus change on individual modules so that when a change occurs one module is effective if you can pull that off and it's not easy to pull that off but that's only assuming that every module has one dependency right you could have many things depend on one thing yes yeah yes and if a module has many incoming dependencies that's a problem and if a module has many outgoing dependencies that's a problem and you can't eliminate them all but you can control that you can minimize that and get some kind of some kind of discipline around the number of dependencies between modules that's i wrote another book about that called clean architecture but don't you by but but that if you do that you also introduce natural abstraction that doesn't technically need to be there cuz now you're just abstracting to specific interfaces just putting a man in the middle i i am putting a barrier across an axis of change so yes it the the interfaces that you would put in there the abstractions that you would put in there are not strictly necessary for the behavior of the system but they vastly increase the ability to modify the system they keep it easy to make a change here without affecting something here all right all right i i i tend not to i i'm very pro or i'm very pro- anti- abstraction i'm not sure i probably should just say anti- abstraction i try to very minimally abstract my code when possible all right so that we began this by saying you know i don't put abstractions in unless the need is there but the need is there if i've got a change here and it's affecting a bunch of stuff over there then i'll put an instraction i don't know i think sometimes requirement changes are big enough to just warrant that right like if someone changes your fundamental data type a lot of things require that data type it's just by by its very nature must change the only way you can do that is if you can predict the future and i have proven to myself i am a shitty future predictor and and that's true yeah then i just have to make the same number of changes it's just propagated through 10 places that eventually get to the tips now you just have one changes eight times as opposed to one change that is eight oopsy daisies you're always going to get bit by that we always get bit by that that doesn't mean that you can't mitigate it and by the way also when you get bit by that you have the opportunity then to make sure you don't get bit by it again because the most likely thing to change is the thing that's been changing already so if you can if you can catch it early because somebody made a change and you can put in a protection for that change then when they change that thing again and they will you'll have a production built in maybe i'll give you a maybe on that one i'm gonna give you maybe i'll give you 5050 okay 5050 i'll take that so hold we got to go back to a little bit of testing when it comes to when it comes to testing and you try you know your goal as you say is asm totically reaching 100% why why why does it matter that you cover every line of code because i want a test suite that i can trust i know but not all cod is is code worth testing all yes all code is worth testing because any any error any any code that is in error can cause catastrophic results so yes all code is worth testing but not all code is worth testing directly i don't mind indirect tests you know for example i don't write tests for my getters and setters that's stupid right but i do write tests for the functions that call the getters and setters all right so i have a general rule of thumb which is that if i can't get the implementation right first try i test it okay and so that leaves some level of code always untested because i have a got the implementation right the first time because some things are really easy sum an array say that again some things are really easy some things are really easy sum an array like in javascript you have to sum an array right would write a test for summing an array i wouldn't i wouldn't write one either right and so i have kind of like a set of i have a general rule of thumb which is that if i'm doing something that is trivial in a function i just don't test it so yeah kent beck used to say only test the things that could possibly break yeah that's what i mean that's one reason why i do like uh erors as values languages is because they kind of force you to think about the places in which things break uncomfortably so but nonetheless they do that's why i've always been a very sus of the jvm is cuz it's kind of just like you don't have to handle it if you don't want to and it's just like well maybe we do want to handle it or at least think about it should be inconvenient when there's an error okay you don't think so i'm not a big fan of multiple return types like go does that i don't like the comma separated returns i think that complicates things so i i prefer to throw exceptions in languages that allow exceptions to be thrown yeah but but then you have you have a whole control flow problem then cuz now you have to you you necessarily skip a whole bunch of lines and you may even skip out of your function right like state becomes very unknown if you don't have every line that has an error considers the error so i mean that's also true when you return when you return error codes if you return an error code from the middle of a function you may not know the state of how that function left things by by the necessity you do because you actually chose okay i got an error i will now have to return from this error like you've made that choice at that point yes you have and and if i throw an exception i've i've chosen to throw the exception at that point but you don't know where point yeah i know but that but that's the problem is that if you caught it three functions up you now have many many layers well some you know come on so you know you've worked at places with at least three functions up it's like if you javascript they throw go everywhere doesn't necessarily mean it's a good idea but you know i like the exception model myself because i don't like to throw long distances you know i throw up to the next function so it's very much like an error code except that it's caught in a different way so you do like ss's values is what you're saying you just like two ways to return values because that's what it sounds like if you do if you do do a try catch every single time by the necessity you have multiple return values you just have multiple return channels okay i'm i'm happy with that okay okay hey that's fine hey look at that common ground all right who would have guessed who would have guessed all right well i guess i don't think we'll probably ever see eye to eye on on unit testing fully or test driven development though i mean i i like i said i've used it once where i really understood the problem and it was it was absolutely absolutely fantastic for sure but what do you prefer when it comes to testing are you do you drive more towards integration level like where do you choose your level is higher better or is lower better or is there any rule that you can say so the the i i'll just go back to kent beck statement i i will test anything that could possibly break i like to pose my tests as abstract tests the wrong word general tests against a family of functions rather than a test against every individual function i like ind direct testing i want to make sure every line is covered but the tests themselves are written at a slightly higher level but not so high that they're called integration tests they're still unit tests they're just testing a slightly larger unit than a single function okay do you think there's value in integration testing yes absolutely how much effort put in it depends on the complexity and the size of the system unit test are opic you know when you're writing unit test you're thinking of one thing when you're doing integration testing you're thinking about a number of things you've got a bunch of balls you're juggling in the air so they can be very useful but they should not be testing business rules integration tests should be testing integration they should be testing the choreography and the the flow of data through the units as opposed to individual business rules it's a waste when you do individual business rules in integration tests okay i i i i guess i'm slightly confused by that isn't the output of any integration test a series of business rules aren't you testing like a summation of business rules so my my goal in an integration test is not to make sure that all the business rules work i may have to test a business rule in order to test the data flows but if the data flows work in an integration test i'm not going to go through every one of the business rules that use those same data flows okay okay i've got unit test okay so you you just do more like does the system continue to operate i asked for a piece of data it did return this type out we're good enough is that kind of what you're trying to say well yes a little more detailed than that i want to know that the the processes got started properly the data flow channels got open properly that the right kind of data went across them so i might be putting in special little widgets to test those kinds of things i might stick in some extra fixture code that will look at the flows of data across those points integration tests are very technical you know that's the kind of thing a system architect does they trying to plum out the way the whole system functions how do you feel about golden f i see i see that a lot in integration tests like a bunch of golden files being used like i start up our system it goes off and it talks to the db it does all these things and then i expect this exact like shape of output how do you feel about that kind of the golden i guess they call them golden testing yeah it's a move of desperation you don't have enough insight into the system so the only thing you can look at is the output and you don't know what's going on inside and so okay well geez it seemed to print the report fine i guess the system's okay well if it's a complicated system that's not a very comforting approach why not because you're only testing a very small subset of the behaviors that you're trying to test if you've got two or three golden standards out there and you you run the tests and all the golden standards work you have not hit the conditions that the golden standards didn't cover and you don't even know what those conditions are yeah so you get a false sense of security now if that's all you got okay that's all you got but i would not start a system and and with the goal of testing it with golden standards golden standards are the least effective way of of keeping a system under control in my opinion other than just not that all i mean can't you make that exact same argument for every smaller set of tests because in some sense a unit test is a really a snapshot test just in the snapshot just happens to be really tiny well yes the snapshot's tiny the number of moving parts is innumerable and then you made the point earlier you know if you've only got eight bits you only got 256 possibilities and you can completely flesh that out now i can't completely flesh out the behavior of the system but i can look at an individual function or an individual small family of functions and be relatively certain that the behavior of those functions is well covered am i 100% certain no am i relatively certain to a high degree yes golden standard doesn't give you that because the golden standard is way too far out at the at the user interface there's too much stuff going on in there from from my point of view and and in a complicated system okay well unfortunately i do have to go as someone said chat my wife is going to be angry at me i may be 15 minutes late i do appreciate having you on here and talk about these things the goal again today was just to have it's so that you can kind of explain your positions and i hopefully did a good enough job kind of representing what i i would say your average twitter arguments were because i i've read a lot of the tweets and they all are just like for lights and you're just like well actually and so i wanted to make sure that that was close enough thank you i had a good time appreciate you yeah no this was a lot of fun i i i did like some of your takes i do like the you know the abstract when necessary start more concrete i i do think those are good things and and most of all i i think that the hardest part about software isn't that there's a bunch of design patterns you have to memorize there isn't some sort of like nomenclature that you and i have about you know we have our own set of special words in software development and which is very weird to use around your non-software development friends which i'm sure you've experienced you know you just don't throw the word integration testing around with them they're was this guy talking about but at the end of the day i feel like experience is always going to be the best teacher and it kind of like for me the only way i understand my principles is simply because i've just made bad decisions and i'm just trying to make less bad decisions as time has gone on and so maybe one day i will be sitting in your shoes telling all the kids to start doing tdd and i'll be like dang it how did this happen how did i get here oh my god i'm uncle bob now i know now uncle prime happen to next gen next gen i'm like saved by the bell next generation this is going to be terrible all right so you get the last word any anything you want to tell to the people watching things you want them to consider books you want to sh you you you name it you get to do oh heavens the most important thing i think is is keep on learning read like cra read things you don't agree with get a broad a broad understanding remember the story i told about the structure and interpretation of computer programs that was a book i expected not to agree with and it changed my life so just keep that up in mind right a broad mind read a bunch of junk constantly learn and in 20 or 30 years you know things could be good hopefully all right that's good that's that's fantastic anything else do you have any books or anything that you want to throw out there any courses whatever you have no no i don't do courses and stuff like that anymore i pretty much stick to my writing and and my programming of of stuff that i do there's a book that i is in production at the moment which is a history of ancient programmers you know starting with people like grace hopper and and john bakas and edar dyren a book that i'm i i had a lot of fun writing i don't know how many people will read it i hope people will but i had a ton of fun writing that book do you dod when you're wri book do i do tdd when i'm writing a book no i do not there's no automated tests i can run you know do reread it a lot but that's not quite the same all right well it sounds like you have manual testing somewhere in this pipeline we should fix this now okay hey did you hear there's this it was in ancient rome you might not i mean i i don't when you said the word ancient then you mentioned people from the 50s it sounds like you might not have i i believe the first programmer ever i i tried to look this up several times and i could never find it i watched it on a special once he did a play in a box where there was a spindle that had wires attached to it and as it spun it would drop and then it would rotate the other direction then it would drop and rotate the other direction effectively doing binary programming two about 2,000 years ago and it would make entire things move around based on this like onoff sequence and so technically considered like the first actual programmer just cool you know i only heard about a third of that because the network decided to cut out right about then oh that's too bad don't worry we we'll leave it for another time maybe i'll find the maybe i'll find i'll find the reference and toss it to you okay all right well you have no words hurts a little all right you have a good one uncle bob this was great thank you for coming on thank you appreciate it had a good good time all right take care