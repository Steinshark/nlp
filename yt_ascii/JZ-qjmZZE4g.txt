please when i say now ahead of time when you're watching this video please do not race off and say first the idea is you getting on yourself first and the answer to the question in the video is here we this is it okay so let's get there let's pose the question the reason for coming in on book codes is they're a particularly accessible and you know easy to visit application of checksum technology that's what it comes down to the classic isbn 10 10 digits long but that 10th digit is a weighted checksum of all of the digits that have occurred previously and in the course of working out let's say what is the checksum digit i mean last time when we introduced this we i went for the hard stuff first i regarded the checksum digit has been correct but if you remember we damaged one in the middle let's do a straightforward one this time and convince ourselves it does still work and work out late after that what might go wrong and would it work for bases of calculation this is different from 11 because remember it's effectively we're taking things modulo 11. in terms of doing another one i'm going to work out the checksum with you and then i'm going to challenge you to get out there and find out what this book is let me say to you i'm going to consider this isbn the first nine digits it's zero 201. zero seven nine one and i put a c at the end to denote that the checksum digit has still to be calculated those of you have seen the previous video on this topic you'd be very familiar with this if you're not see if you can follow it and if you can't follow it then go back and pull down the previous video to start off with every one of these digits in an isbn has a weighting starting at one from the left the second digit has a weighting of two third digit waiting three and so on all the way up to a weighting of nine but the checksum digit is the one that checks out all the rest when you've done this simple addition and multiplication sum modulo 11. so if you remember it goes like this i calculate the checksum digit by saying weighted multiply and addition 1 times 0 plus 2 times 2 plus 3 times 0 plus 4 times 1 and so on plus 0 times 5 plus 7 times 6 plus 9 times 7 plus 8 times 8 plus 9 times 1 plus the checksum digit c times 10 because that's in the 10th position on the right skip i did all this last night i worked it out which the answer to all of this is that the equation you have to solve is'6 plus 10c that's what it all comes down to has got to be equal to zero remembering what we did in high school algebra rearranging equations it's easy so far you say okay keep the 10c on the left-hand side move the'6 to the other side so it's 10c equals minus'6. so again using shawn's clocks method that he did last time he actually showed you a way of working out what a negative number is modulo a certain base and keep reminding yourself is modulo 11. another simple way to describe the algorithm for coping with negative results like this is to say keep adding multiples of 11 until it goes positive that's one of the ways i remind myself how to do it if you want to make that go positive using multiples of 11 well i would point out to you just off the top of my head that 11 times 17 is'7 and'7 is one more than'6. so if you have minus'6 plus'7 that comes out to being plus 1. you end up with the fact that -1 h6 let's use maths chat is congruent to 1 modulo 11 okay so if in doubt keep adding the plus 11 multiples until it goes positive and then you'll have your answer 10c therefore is now equal to 1 modulo 11. so c therefore bring the 100 and divide it is 1 divided by 10 modulo 11. what we did last time we're revising it by doing it again this time is we say ah we have to find inverses now at this stage we did this for the first time in the previous video i've written out the table of inverses modulo 11. well one is obviously a remainder of one if you want the inverse of two what do you have to do you have to find a multiple of that that makes it be one more than a multiple of 11. so 60 is a 12 but 11 to 12 goes once remainder one so in other words the key multiplier is six that turns a two into a twelve remainder one and again with a three it's different four you wouldn't need four threes or twelve is one eleven remain a one so here then on this bottom row are all of the inverses for one two three four up to ten and as you can see the inverse of ten is ten it's so-called self-inverse so our one-tenth here just yields us an answer is ten so c we've been trying to work out the checksum digit it is 10. this poses as a problem actually because 10 looks like two digits doesn't it looks like one zero but it isn't it's ten and immediately as a computer scientist if i had been on the isbn committee i might have jumped up and down in the 60s 70s whenever it was and said look we have a problem here but because we do modulo 11 we will end up occasionally with remainders of 10 how do we represent them my friends at ibm have the perfect answer and they're built in future proofing by inventing hexadecimal or goes all the way up to remaining 16 and they've just used abcdef i might have been tempted to say why not use a i don't know i think i'd have been laughed out of the room because of course isbns i think were developed really by people who were booksellers publishers librarians and as far as they're concerned it's a literary background not a computer science background and i bet you somebody said let's use roman numerals because x is 10. what does this lead us on to well without wanting to get too mathematical what it's led us into realizing is that remainders are important and the whole of our adventure we are beginning today is all about remainders because when you get into a fat more advanced coding theory which is what you all say you want me to do you've only yourselves to blame it's all down to remainders and we've got to get very comfortable with remainders and multiplicative inverses which we've done on the isbn example in mathematical terminology then you would say oh consider a set of integers z sub n what is z11 well z11 is basically isbns it's the rules say if you call it z11 then it means all the integers from naught up to n minus one so it's from naught to ten fine that's exactly what we've been doing the question is for any given n i mean you could have said three zed four z eleven said seventeen said whatever can you turn it into something that works and you would get one of these inverses like we had to do in solving our equation and the answer the short answer is yes you can as long as it's prime and i want to just try and convince you about that what we found in doing the example it was basically 10c equals 1 c equals 1 over 10. so what that's saying to us is if you want to divide by n it's the same as multiplying by 1 over n and if we know how to do multiples of things we know how to do division so long as it's possible to invert to form the reciprocal of any number in that field but if you ever stumble across something where for one reason or another you can't find an inverse then you really are scuppered this makes z be a finite field because it allows division if you get a set of numbers for a certain zn or whatever where you can't find the inverse then it becomes a mere ring not a field i hope i've got that right mathematicians but yes so in general then the set of infinite integers or go all the way to infinity it'll be quite a long way you cannot find an inverse so in general arbitrary sets of zero to positive integers for rings not fields but the special case where with the arithmetic we know their form fields is when they are prime what i'm saying here then is this divide is vital if it is absent but the other three plus minus multiplier are okay then for that particular choice of n p say then you could say well zp is a ring but it's not a field all of the prime numbers if they feature in this z sub m if m is a prime it will work it will have a multiplicative inverse you will be able to divide and there is no problem now i want to try and convince you about this and say it's not just a one or three by first of all doing a multiply an addition table for three we all agree three is a small odd number it happens to be a prime as well and then you will say ah but show us where it goes wrong then this is all about finding inverses and if we're using shall we say a system based on three rather than 11 then we know that three is prime is the smallest odd prime because one doesn't count remember computer scientists you might think of one ones being prime but oh that's heresy in mathematics one is special okay on this diagram here here i am tackling z3 here's our first foray into the way you should do things systematically is to say well if z3 is going to form one of these fields finite fields where everything wraps around and all the remainders work you need to always to do two things you need to construct an addition table and a multiplication table let's do the addition table first and we'll be just using ordinary decimal arithmetic like we do with aspirin but occasionally i'll be saying ah but that's modulo 3. whereas previously is modulo and we have to do a division and get a remainder not one two there not one two there here we go look zero plus zero is zero zero plus one is one zero plus two is two come to the second row one plus zero is one one plus one is two one plus two is three but we're working modulo three now three modulo three is zero two two plus zero is two two plus one is three ah but it's modulo three so there's a zero two plus two is four but divide that by three and it goes once remainder one so here we are look naught one two one two zero two naught one and here is another wonderful buzz phrase for you is that that edition table shows you that every one of your impossible remainders zero one and two in every row there is a zero entry and that zero entry is called the additive inverse and what it is saying is one plus two is three but because it's modulo 3 that's a remainder of 0. so in other words 2 in this field is behaving like minus 1 because 1 plus minus 1 cancels out to 0. so remember when you're doing additions in a finite field you should be looking at your table saying is there a zero on every row have i got an additive inverse because you absolutely got to have that okay and it's past all the tests so far there are additive inverses for everything and it relates the modulo business to negative numbers and everything so we've now discovered okay here's a somewhat harder one you have to construct for everything you intend to use in your codes you have to construct a multiply table as well and show it works zero times zero zero zero times one is zero anything times zero is zero so you get a row of zeros at the top that's absolutely common i did do a video here foreshadowing this ages ago involving read mother codes and i said there you will always get a row of zeros possibility for one of your code words it's called the zero vector and we're getting it here as well so don't get worried by that what about the second row one times zero is zero one times one is one one times two is two just using ordinary multiplication no problem two zeros are zero two ones are two two twos are four which is because once remainder one what do we look for in the multiply table what we look for in the multiply table is the ones entries and they must be there in every non-zero row you must have ones just one one you know and all that okay now i hope i've got enough space i just love saying this word this is the multiplicative inverse that's a way then of forming a table of inverses by methods other than just chatting to sean and saying oh it must be search and search is write down your multiply table look for all your ones they've got to be there and those are the multiplicative inverses of those particular numbers so wherever we find a one in that table the things either side of it will be the inverse of each yes the column head and the row head the trouble is this is easy-peasy they're both self-self-inverse one inverse differential we've done a table for you'll define it dotted with ones all over and if you'd picked out the row and column intersection for all those ones it would have given us the linear table i wrote out on the previous slide clearly then z3 is a prime field it's got a multiplicative inverse in every row which isn't the zero row a set of inverses can be found by looking into the multiply table picking them out reading off the column head in the row and there you are that inverts to that that inverts to that all right then so what what what could possibly go wrong in z4 we're motoring it cannot go wrong oh yes it can okay here we go folks this is z4 is that for a field is it a ring let us find out we've got the luxury again of just using ordinary decimal multipliers with remainders that we're familiar with so i won't go through it in great detail you know how this works now let's take the three row as an example three plus zero is three three plus one is four right but we remember working modulo four now four modulo four is zero three plus two is five but five modulo four is one three plus three is six six modulo four is two so we complete the addition table and we look through it and we say on every row there must be a zero because that's forming the additive inverse and enabling you to cope with negative integers in this field perfect no problem multiply let's try multiply on z4 what happens just like it did for three is that zero times anything is zero so you get a zero vector of four zeros and you look at one and you say all right here i go one times zero zero one times one is one one times two is two one times three so easy peasy now let's come on to two two times zero is zero two times one is two two times two is oh heck two times two is four right but four modulo four is zero fine two times three is six six modulo four is two that row is a disaster and why is it a disaster it's because two is a factor of four that's why it goes wrong too it's a bit like sequential cog wheels in bletchley park for those who watched that video you cannot have things that are factors of these alleged things at work now three behaves itself three times zero is zero three times one is three three times two is six modulo four is two three threes is nine but two fours are eight so that's one but that one bad row scuffles you because in order for a thing to be a field you have got to be able to find a one on every single row of your table and if you can't do that you've had it what we are going to find as we move on into the realms of higher coding theory is that galois comes to the rescue of computer scientists whereas in the very old i don't know egyptian mathematics days or something we'd have been stuck with the fact that they knew about primes they didn't know about what could be done with powers of primes and that is what the almost the entirety of computer-based coding theory is it is heavily dominated by powers of two but if you remember all the arithmetic has to be done modulo the number base or the characteristic so when you get to like 16 and you think of it as 2 to the 4 you do not do your arithmetic modulo 16 you still do it modulo 2. and modulo 2 in the addition framework means our good old friend exclusive or so that holds no perils for us whatsoever as computer scientists the multiply is harder because as we've seen with four just regarding it as an even number it goes wrong on two you can't find an inverse if you're going to find one what galway says is okay mathematicians computer scientists even listen to me i'm going to have to carefully redefine what divide and inverse mean stay with me now i've got the token so i can load a value in add the value for merger into it and store it back and hand the token and now i've got the token again i can load something into into my register add something onto it throw it back and pass the token