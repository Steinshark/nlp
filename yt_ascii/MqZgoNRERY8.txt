so in golf obviously the idea is you're supposed to get the ball in the hole with as few strokes as possible and in code golf you're supposed to write a program that does something with as few keystrokes as possible i guess right with as few characters as possible so you're trying to produce the shortest possible program that does a particular thing and it's a kind of a nerd sport you know although this is a very bad practice like if you're really writing software generally speaking you do not want the source code to be as small as possible right there are things sometimes you do want the source code to be small but you have things like minifiers that will deliberately you know programs that will automatically compress code this actually is just an example of a deliberately very short bit of code this is the code here and this is the whole of it and it plays a piece of music which i'm not exactly sure how long it lasts definitely 16 minutes possibly more like 30 minutes before it starts to actually repeat itself so it produces a fairly large amount of complexity the song is quite repetitive but well i'll play it so this is it starts off very simple and then becomes more complex with time all of the instruments are essentially the same but with different parameters so we can go into the code a little bit we send the source code to make a c program that will generate audio data and then we're running it and playing that audio data fairly straightforward as a structure yeah and then that's what you get it takes a few minutes to get actually good so so when you run it there i see one or two warnings pop up but they just just pay no attention to it most of this is the compiler complaining that we are torturing the c language c is really kind of permissive it lets you get away with an enormous amount that you really shouldn't be able to so here for example all of these defaults to int it turns out that if you c c is a strongly typed language right every variable has to have a type if that's an integer or a float or a character or a pointer or whatever but it turns out that if you don't specify that in principle you have to specify but if you don't it just goes oh you haven't specified it i'll assume it's an it so which is just an integer so everything every variable in here is an integer because that way we don't have to waste any characters specifying what it is and integers work fine for this so this program really has two main parts there's a function here called g and then there's a big loop which calls that function several times and then calls put char which prints a character to the output so if we remove the pipe to a play rather than piping the audio data to the speakers it will just pipe it to the screen and we can look at it and it looks like this kind of fun so you can see there's kind of structure to it there's a pattern it's not random noise there's kind of waveforms almost in chiptune music you tend to have a few basic waveforms that people use all the time because they're easy to generate right one of them is the square wave that has a particular sound which you recognize from the old time game music there's also the triangle wave which is sounds a bit like a sine wave but it's much easier to generate than a sine wave because it doesn't have that complicated curvy stuff and the other one is the sawtooth wave which is one that goes up and then jumps down and up and jumps down right kind of looks like the teeth of a saw and this works by sawtooth ways because it turns out sawtooth waves are super easy to produce just by overflow what does it mean to say you were overflowing an n-bit representation you have a fixed number of bits in your number and then you get up to one one one one one one one and if you add one to it you do one is one and zero carry the one carry the one carry the one carry the one carry the one and then you're carrying off the end and there's nothing there so the thing gets reset to zero so what this is doing in its loop is there's a constant loop here and then put char is expecting a char chars are only eight bits right eight big characters so the way that put char works is you give it 256 that's like giving it zero so by having this number that keeps going up going into put char you end up with this sawtooth shape right the number goes up and up and up until it goes off the scale and starts again at the bottom so this is the core on which the thing is built we just have a really simple loop we're incrementing i every time then we're putting that out as a character and printing it so if we look at that as it comes out it's just this and in fact you can see look it's very neat this is what happens if you just output increasingly higher numbers at the beginning you have a bunch of control codes which don't print and then you start getting into the characters you get punctuation then the numbers uppercase and then lowercase these are unprintable again because we've gone off the end of ascii it only uses the first half and then it loops around again so this is the output of that program if we then pipe that to a play we get that rather lovely sound because the way that a play works is it says and in fact it even tells us which is kind of nice playing raw data from standard input unsigned 8-bit at 8 000 hertz so what that's doing is saying okay i'm reading in unsigned eight bit is the same as a character i'm reading in one character at a time eight thousand in a second and i'm treating the value of each character as sort of the position that the diaphragm of the speaker should be at at that at that eight thousandth of a second so if you tell it this this these 256 values up to zero and down again you get whatever it is 8 000 divided by 256. now let's do that what is that i can't do maths you get a approximately 31 hertz square wave and in fact we could probably test that let's see there we are it's a b0 31.3 hertz and that's the core idea of how this works now if we wanted to make that higher pitched we just need to increase the rate at which the number goes up right so if instead of printing i we printed i star 2 for example what does that mean star two multiplied by two so now if we look at it it should skip every other one so rather than having zero one two three we have zero two four six eight because it's skipping them out so it's going twice as steeply so this ought to be about 60 hertz it's twice as high and we can look at it there now it's a b1 and it's 62.5 hertz and by this basic function by multiplying this by different values you can get any pitch you want and that's the core of how this makes music i'm seeing your code there and i'm thinking there's not 16 minutes worth of notes there so so what's going actually on it runs this loop and then it prints a character and the way it gets that character is by calling this function g four times one for each instrument and just adding up the results because in sound if you take one waveform and just superimpo and just add the other waveform on top that just makes the sound of both of them one of the arguments you pass into the instrument function is the volume that that instrument should play at and that is set by bit shifting the the incremented variable i by a very large number bit shifting is an operation a binary operation where you take your number and you sort of move the decimal place one point left or right in principle so in in in decimal if you were doing a shift of that sort you would be multiplying or dividing by 10 right by either chopping digits off the end or adding zeros and in binary what you're then effectively doing is halving or doubling and it's a very very fast efficient way of halving and doubling numbers music kind of works on doubling and halving in a sense right a lot of music so we can use this to get numbers which vary very slowly relatively speaking so you have your you have your number which is the level of your sawtooth waves which is going up very quickly one every single you know 8 000 times a second and then if you right shift that for example 17 times you get something that only happens once every two to the 17. samples which is i don't know i don't know off the top of my head what time do the 17 is but it's a pretty big number that then allows you to have something for example where it changes from one bar to the next it lets you have slow changing sections so that you can you can have a note that lasts a certain number of samples or a bar that lasts a certain number of samples or a phrase that lasts a certain number of samples and the way that the music is structured they're always even powers of two and it just so happens that that works out quite neatly musically we'd like to thank audible.com for sponsoring this episode of computer file if you visit audible.com computer file you can sign up for a 30-day free trial they've got over'0 000 books to choose from it's really straightforward you can browse by category or you can search by title or author today i'd like to recommend the curious incident of the dog in the night time which is a curious title in its own right it's a book by mark hadden it centers on a boy with asperger's syndrome people without asperger's syndrome can probably work out by intuition what's actually happened and so you kind of know what's happened but what you get to see in the book is how the boy works out what's happened for himself so thanks again to audible.com for sponsoring this episode of computer file remember audible.com slash computer file sign up for 30 days free i find it kind of calming to listen to like i found when i was working on it i would just kind of zone out and listen to it for 10 minutes and then go oh wait hang on okay i want to change this or i think i can make this bit shorter or something like that