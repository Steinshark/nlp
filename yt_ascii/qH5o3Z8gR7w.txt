hi everyone thank you for coming to my talk my name is olivia kin i work in the r&d department of clue points and my role is mainly to industrialize algorithm developed by our statistician to analyze clinical data that are collected in clinical trials and today the subject of my thought is apply modern c++ the problem of messages versioning in api so the content of the talk is an introduction of what is the problem for case the use case that i wanted to show you i hope you will find some maybe connection with your work and yeah we can discuss any input or question that we will have you will have later then i will speak about the rational be upgrading and downgrading message version i will show you two solution that i came up with a first solution that was developed several years ago in c++ 11 that was based on the curiously recurring template pattern and a second solution that was developed last year in c++ 17 which use modern c++ with stud variant and st visit i will so do a small live demo i hope it you work and i will conclude with what i learn during this project so the api versioning problem so you all know but it's good to refresh or have a common understanding so api stands for application programming interface and in the context of apis the word application refers to any software with a distinct function and the interface between softwares can be f as a contract of service between two application oh sorry this contract defines how the two communicate with each other using request and responses so small graph one side you have the client it sent a request to a service endp point and the service endp points send back a response so that is a call and is done via messages that must be understood by both sides so therefore we need to have a clear understanding what are the version of the client the service end point and the messages so this is our use case so we have in production we have a backand written in python which has a specific version and is calling a c++ executable to and this c++ executable is responsible to perform different statistical test on clinical data and the communication between the two is done via a json payload which has a specific format and of course because we work with clinical data everything must be qa approved so yes and that works fine if it stays like that forever but you know life is turns and so we have changes so for example one of those changes it's a bug fix in the on the c++ side so we need to change a version of the executable fortunately the payload doesn't change the back end doesn't need to change so it's fine that's an easy case and if you want i don't know sorry sorry so yeah we were here so that's where i wanted to go so if you represent that in terms of timeline for the production for the dev team and for the r&d team so in production you have the three version 2.7 1.3 2.4 we work in nd we do a b new version then it's qa approve got this final version it's push in dep that it's staging and then go back in pro so another use case is for example the back end need so refactoring and that refactoring also need a change in the json payload because it's easier for the python program to have that the name are chang in the json so we have a change in the backend version a chance a change in the json payload version so go from 1.3 to 1.3.1 and of course the executiv need to change to so to adapt to this new json payload so we have that sorry i'm going to the pdf the backup version so in term of timeline so in production is the three previous version so 2.7 1.3 2.4.1 the death starting to work on 2.8 but when they start working is still 1.3 for the payload and the executable is 2.4.1 so we work in cooporation inside andd with the def to have agree upon the new payload version whaton one we do the necessary development got qualified and then the def can use it but at this stage in fact some part of the component of the the dev backend still need to use the 1.3 because they're not yet ready to use the 1.3.1 but they already want to have the new executable so that's mean that we have to support the same time 1.3 and 1.3.1 so that's a bit more complicated than previously and then when everything is done again goes in staging and then goes in part this is another use case for example we have a new feature a new test statistical test that we want to put in production so means that you we need a new c++ executable so for example version 2.5 a new json payload because we will introduce new keywords in your jsm so new version and the back end if you if you want to use this new version needs also to be updated so for example 2.9 so in term of timeline we have this schema that i guess know you are more used to it so we work on the new feature get qa approved the dev again have to work the beginning with the previous version of the c+ speciic table at one point they start to work with the new version but again not the whole thing is going to switch directly to the new 1.4 format because they're not yet ready or they don't need it directly but at one point they will so it takes time to propagate everything and so we still need again to support at least two version so the end goes to staging and then to port so and that's a summary so we have a production a back end with a new version a c executable with new version a payload with a new version but also for example for this time we introduce a subcomponent which has also its own version this sub component is for example a post processing for the statist statistical test and it can be applied like in a pipeline but he will have also his own version because it makes life easier because if we have to change the whole payload version of the payload whereas we just want to update the this pipeline subcomponents it's it's getting really messy and it just increase a lot of the diversion changes just increase and it's quite meable at the end so summary of the api versioning problem so first point we have to support several api version at least two sometimes more and it is because there is different time frame for the release of for that can be used in development and production or even in par environment but that can be solved by using for example the green blue deployment pattern so you have just one version of the executable and you have a when you already you do the switch or another point is you have only one executable but the the endp points can be called with different api version so i want i'm a client with a certain version i want to communicate with the back end with a certain version and i expect the response with this version because i don't need to use the the new version so in the green blue pointment for example the you have to maintain different version of the executable so one that support one version 1.3 one that support version 1.4 but then you have b fixes that you have to put in 1.3 1.4 at the same time so it has some advantages and disadvantages and okay and the other solution is to have only one executable that is the same with all with all the environment but it supports the different a version that's and that is what we decided to go so the pros of this approach you have only one code branch to maintain so you don't have to backp back fixes into different branches and different release and also for us is quite important means that we have only to qualify one executable and not different version of the executable because i told you it's a clinical pharmaceutical environment so we need to qualify everything and we have to document everything it's every time a full folder for new release so we want to simplify that part too and the cons it's so we have a complex maybe a more complex implementation because you have to support inside the same executable different version but relation is it really more complicated or not so and now i will speak about one of the approach it's about upgrading and undergrading version messages so in fact we have one cent for example as i say you want to send a request in version 1.3 in the service endpoint which in fact is already supporting version 1.4 so what you should do so the approach we took it's we take the request in version 1.3 we upgrade it to one to version 1.3.1 and then upgrade to version 1.4 we do the competition with all the bo f and everything in 1.4 then we don't create the response to version 1.3 so that the client can understand our response so is there any problem with this kind of earning for example we have a minor change in the version so that's mean for example a field has been re renamed or move that doesn't really matter because the content is still there with the same meaning a feel is edit or remove or maybe you can use a default value for that additional field that was not present for example in 1.3 when you do the migration to 1.4 or here should have been a green mark and so yes most of the time for minor version you can use the default value would not cause any problem and for example if a value has been renamed for example it goes from one z to true false or yes no so it's the same meaning but the meaning is the same but the string representation is not the same so you can do a conversion or the worst case maybe do use a default value if you have a difference for different major differences between version for field rename and move that doesn't cause any problem if we have edit field or remove field in this case it might be more problematic if you have to use the default value same for when a value is rename edit to remove might cuse a problem so it might cause breaking changes and so so this is those breaking changes are important to consider when you design the new api and you have to know the risk behind it and to know if it's acceptable to to have those breaking changes or if you can mitigate them or if you say no i i can't do the the migration between 1.3 and 1.4 and so won't be possible so it's everything that needs to be discussed with the teams so an example so for example the input version 1.3 was something like that so you have a a field with the version and then there was some kind of group called web confing with a job id analysis id and a grouping type and after the refactoring instead of using camel case they use the underscore notation so of course it's different version if you don't do the the update won't work but here just simply matching and also the grouping tab has been moved outside the web config group so in the c executable the you have a read 1.3 version and a read 1.3.1 and it's filling structure input 1.3 and 1.3.1 in fact it's more or less the same and except the grouping tab is been move so when it's reading he's feeling this structure same from for the output except for the output in this case in fact there was no difference between 1.3 and 1.3.1 for the output it's just a way of formatting so job id has been moved to id simply so implementation so the first solution was was using the cous le recurring template pattern solution this is a screenshot of cpp reference so you have a base class which is a template and the t is referring to the tip of the d class so that base can use can access the members of the df class directly it's a kind of a static ying instead of having dynamic inheritance with a poter you have everything static everything is no and compile time so it's great and in our case it was used this way so we had a a version base with some common quantities and it is the crtp part where you have the version the the version we are going to implement and the previous version is the type of of the previous version version in this case was an element of the inim class version but you can find the the drf class because everything is defined like this so we have version 1.3 depends on of course version imp the 1.3 so this goes from there and you define a shortcut in c++ 11 so it's easy 1.3.1 it's 1.3.1 depends on 1.3 and so on and 1.4 and so on so that was fine but so it was a c++ solution so at that time i was migrating from c3 so that was quite a change it was nice it was quite straight forward but of course it worked for several years without p problem but when we mated to c++ 17 there was new way to do it so and yes so it was we needed a new solution and of course with that there was quite a lot of ball play because for every part of the application that we wanted to use the type this type of pattern we had to record a lot of things so it was not a really easily reable framework and it was also f lacking some flexibility in the case for example that you have a bug fix that you have to put in production so 1.3.1 goes 13.1.1 but you are already working on 1.4 then you have to put the the box fix 1. 4.1 because yeah it was not possible with this type of structure to represent this type of complexity so when we switch to to c++ 17 we use st variant and st visit so brief summary st st variant it's a class template that represent tip safe union so we just read but as ref a variant hold a value of some object type t the object representation of t is allocated directly within the object representation of the variant itself the variant is not allowed to allocate additional dynamic memory and to have consistent behavior of union during aggregation initialization a default constructed variance all the value of the first alternative if the first alternative is default constructed constructible and stud visit so st visit apply a visitor v which is a cable that can be called with any combination of type from variant to the variant in this list so now i will present you the the code and it's i will start from uh i will do top to bottom presentation so this is the end the more abra abstract layer of the code so we have all the version that are gathered here we specify the latest version to read an input stream we define a read function we use the read function from the versioning the variant versioning if we cannot read it we an exception and then we have to convert that data that we add to the latest version same for the right so we have the right we want to oppos it to oppos stream we want to have specific version for the output we have the output data in the latest version we first have to convert it to the requested version if the convered was okay was not okay we thre an exception and then finally we write it so that's quite straightforward code you can understand directly but for this we need to define each version as a type so for example we have stru v1.3 we have we defined what is the input data and the output data they can be defined somewhere else so and we have to define five function first one version which return a string view of the curr versions for example 1.3 we have a check version we check the content of a string if it's matching version we check if an input stream will match version 1.3 and we read an input stream and it will return an input data 1.3 and we can write toput stream output data 1.3 and as you can see here we separate data from iio operation so we respected the separation of concern pattern so we have the data and the output so and in fact the input and output stream can be anything you want for example it can be chason it can be socket it can be file so doesn't matter your data are not dependent on the iio operation you can define them separately so i use for inspiration the type sequence from the talk of andre and from cpp on 2021 embracing and also distroying variant so the variant versioning it's a varic template here and inside we define three var template version which is simply stood variant the of all the struct with the version that we want to play with we have the input data and output data variant for all the version and we have a a version function that will give you the actual version of the the actual version that is contained inside the version variant we want to check the input to say to give us which version is inside the input we want to read from the input stream and we want to write to theut stream the output data that we have you can see for the moment here we don't have any specific version so we just have variance so very generic but we also want to convert input data from one specific version to another so the first parameter two is the output version that we want to convert the input data from into same for the output for the output we have two version of the of the method output two the first one we want to specify the output version as a string and the second one we want to output to a tab define version so we specify the first parameter for example we want to output it to version 1.3 1.3.1 in the code so directly now i will go into the implementation detail of the check function it's so this is the the check function and simply return of the check input method of the input string with all the instance of the version paric version from the main template and the is the specialization so it get it's a meta data it's a meta programming so more so we'll take all the version here in these parameters we check for the first one if it meets it and then if so we return it if not we go to the next one and the latest things is to simply return when there is no more version to check you returns the n optional to get the version is quite easy so we have the variant withold the version and we apply a stud visit to it and it returns the version that is defined into inside the structure for the version yes so now i'm going to switch to the reading anon string and we want to return the actual version data structure from the input stream so we have an input stream we have first to get the version so apply check if we have a version we read the version we call this method with version from this sp read and the version that we found otherwise we we return the optional the new optional and with version is again very easy simply applying a a standard visitor to the method read for the version that we have found and now to convert some data from one version to another one that's a bit more tricky but in fact it's quite straightforward so two is the version i want to convert to and first defining the two input data which is simply the input data inside the the version and we apply a visitor to the from input data and the first case if we have exactly the same type from the input data and the two input version then we simply forward it otherwise we try to do a conversion if the conversion is defined so this is a contex if i will go to this function bit later and if the conversion cannot be defined would show runtime error and so this is convert function it's a structure that use substitution failure is not an error by default is false and is defined only if there is inside the two version a convert method that can accept a specific argument and we have a helper variable template is convert define v that takes directly the value to true or false so that's mean that input data you have to have a convert methods that take some input and do the transformation so for example for 1.4 you can convert from 1.3 put data and then you do the magic there and for everything else but you go back to the previous version 1.3.1 you call convert and in this case if you don't have it you won't compile so you will get a an error or you can also hand that with an exception and writing to output stream is about the same so we have right output stream and we have a the variant with the output data we take the index of the variant here and in fact what we're trying to find is the associated version so we have input data in a certain version but we want to find the version so we have to if you remember at the beginning we have first a variant with all the version and then a variant with all the output data associated to each version so we have to go back we have to traverse the the two and yes that's meta programming again and once you write it we call the right function of the associated uh version the conversion it's about the same as previously so we have a specific version in string and we are going to try to find the corresponding type for the version so we have to check it and if you check it means that you have the version so you do an output two with a specific tip type sorry forward it and if the conversion was okay you return it otherwise you return the n up and then if you then you do it for all the version in your sequence of version that is defined at the beginning so and it is the second part of the output two now we have the type and if the same type as the ind as this parameter we simply forward it otherwise we try to find a convert function that will match our parameters then we call it otherwise we return the n op optional so that means that for the output data you need to have some convert function template convert function that you can define a different stage in your application and so by default you can return a runtime error or you it means that if the type is not defined you will have an exception if the if you define a space spe if you specialize this template for specific version you can do the the conversion magic there so now i will switch to the demo can you read the the screen correctly or is it too small okay so so this is compiler explorer and it's a cake project inside compiler explorer so i have different file versioning hpp which is more less the code that i show you in the slide but with some additional debugging information so we will be able to see what's happening in the code when we will run it api is where you define all the version you're are going to use here we have two version that's been defined for the demo 1.1 and 1.0 we have the read and the right function that has been presented in the slide we have the two version so 1.0 so here for the simplicity of the demo we simply have for input input data output data a version with the string and a payload and some convert function and we have here the five method i told you about before so we have version check version check of the input stream in read and write so version we simply have v1.0 for the check simply a check of string when we want to check an input stream we are going to check if there is in the json a component called version and it must match the version we are currently working on for the read we are going to construct an input data and simply load the payload from this member so payload 1.0 and for the right aut data we write the version and we write a payload but of course you can imagine that the payload can be anything it can be a processed data so yes and for 1.1 it's about the same so we have a version a [music] payload default constructor here we have an explicit conversion operator so which take input data from version 1.1 and that's where the magic of the conversion between version happens so and here for example to to show that it's been there we simply take the payload from the 1.0 and we say it has been converted from 1.0 and so yeah and the conver function simply call this explicit conversion output data is the same so we have the template convert that will be defined bit later and again we have the five function so version check version check read and write and so here we define all the conversion all the allowed conversion between 1.1 and what. zero so by default you cannot convert but here we define that in fact we can convert from 1.1 to 1.0 or to 1.0 okay so and the main so this is very simple so for example in this case we have we define a payload in version 1.1 so payload payload 1.1 contains world we want to read version 1.1 so we will print the content of what we have been reading we want to put something to 1 one so we're going to dump the content and that's it so and if you sry already been executed so you have the the output of the program here so in fact here it's checking version 1.1 so the first go to check so you see 1.1 okay so i'm reading 1.1 and at the end so we have input 1.1 and what we put in the payload which was world and for the output okay we have 1.1 and we write it into 1.1 and the end we have the expected payload so payload 1.1 with h world and version is output 1. one so that's easy and now open up we are going to read payload 1.0 and we want to put to 1.0 so it's compiling okay it's done so here the output is a bit change of course is checking the first version 1.1 then doesn't match checking version 1.0 match read it so version is 1.0 and in fact because we wanted to work with version 1 one we have to convert from one to zero that's what we saw and now we want to do an output to version 1.0 but from 1.1 so we have 1.1 no yes for 1.0 writing version 1.0 so payload 1.0 convert to 1.1 so hello world and and the output version is 1.0 so that's about the end and yeah okay don't know if you have question on the demo or something okay yep yes so no wor summarize what i learn so first of course when you try to design a solution you have to think you have to try you have to test and in fact even if you have a good working solution again and the first thing you have to redo it because language the the sour language has some made some progress and so there is it's possible to to solve the same problem in a much more easy way and a much more say effective way and so that's why it's quite important to keep informed about the language specification and what you can use so thank you for your attention and if you have any question i would be happy to [applause] answer hi thank you you have one struct per version yeah and if i understood correctly well in your demo you had a very simple payload obviously yes yes yes so in a real production code the payload would be much more complex exactly now let's say okay from version 1.3 to version 1.4 let's say 90% of the payload stay exactly the same and there's 10% that you changed yes now would you copy everything from the type version 1.3 to type version 1.4 so you have basically frozen the code for version 1.3 or would you share code between versions to reduce code blow especially if you get a lot of versions that you want to support but for for the structure i keep them the same i don't change back version 1.3 to fit version 1.4 no no yeah yeah i i the i still have the everything associated to version 1.3 for reading and writing stay there because i sing them yeah but if you say okay version 1.4 is almost the same as version 1.3 there's just a few changes yes so do you completely redefine the payload for version 1.4 from scratch even if it looks almost the same as version3 okay but for reading you may re if you write it correctly what we we try to do we decompose the rle reading approach into several static method and so they can be called between version so if you're analizing one part of the component but one initiation of the payload is the same then yeah you can reise use that code as so you would use dis versioning structs per component and one component could be unchanged and the other could have a new version interface yes for example yeah i think so yeah if i understood correctly what you mean okay it's a complex topic thanks yeah yeah yeah it's a complex topic but here i i didn't stress but for example if you have the data in version 1.3 and when you want to migrated it to version 1.4 i try to also avoid memory copy i try to put everything with move so so that if i can extract some information from the input data 1.3 and i stay the same in one in version 1.4 then simply move them so the the w if it's 90% the same in memory then i will keep it just move it from one structure to the other one but the reading will be done in 1.3 yes so in the end the output of reading in 1.3 is input data version 1.3 and i want to migrate that data in memory to 1.3 to 1.4 if there are some common part i simply want to move that common part you one. four and the part that needs some conversion of course i will need to create a new d new data structure in memory to do the conversion but if there is no conversion that's i can move it directly so i made no copy in memory for what i do what doesn't change i don't know if that answer your question or if it's iuss yeah yeah yeah we can discuss specific case yeah yeah but i say that that is our use case say might create question for you we might bring you some ins of what can be done or not done depending on your use case of course the users of these new versions are there then also copies imagine you have your version 13 that has some kind of logic attached to it in a service it's being used and then you have version 1.3.1 which is just as minor change yes but the type is completely different do you template this then in the users in the services or how do you deal with the different types flowing through your service yeah so i am on the server side would say so yeah in fact creat one point some change of logic between two version and yes that that was creating some differences but it was decided that everything will need to be done in the latest version and so in fact even if the client we call 1.3 he will get the updated result from 1.4 but presented in 1.3 because that was was expected yeah you always because it a better answer you always conver to the latest version yeah yeah yeah yeah because if you wanted just to keep the the same say not faulty response then you can just keep the same executable but then you don't get the bug fix and improvement but what we want is to propagate the bg fix to change the improvement even in previous version okay but of course our use case is may be limited and it's nice for that because you always want to have the best result for the statistical test so you don't want exactly the same result because you know they are missing something so you can say to the client even if you use a previous version you will have the updated result anyway maybe a bit of an a naive question yes so i understand that you try to serve clients that talk different versions yes and you said it's mainly for your integration environment oh or is this also something that happens in production on your yeah yeah yeah but in production the problem is we have different version for example we have the production environment of course that use not the latest version but the one to previous yeah and somewh we have also a demo where people client can use the latest version so but we don't want to maintain everything so we just put the the latest executable version there so because we know there is bug fixes and better result and everything so yeah so yes we have a we need to support different version yeah d api what drove your your organization's decision to to do this in in one server version rather than just running two server instances in parallel that have different versions yeah yes that was this curse and that was the the blue green so something deployment or whatever you want to call it because at the time we were a very small company and it was hard even for the s team just to maintain different environments and so it was much easier if they would have just to pick the executable from one repository it will be always the last one it's easy so was also discuss discussion of say to ease the job of some of the teams okay and also yeah because we qualify that version is the latest one and so it's easy because otherwise you have to qualify also double application with one version and then another version and it's just just create a lot of problem okay well yes it's a tradeoff between qa paperwork and easiness of development and use so yeah thank you thank you short question do you employ things like semantic versioning to keep the number of versions that you have to support at a minimum no then i commment you do yeah well for you are supporting you are supporting everything from the beginning so we just yes we can do some code clean up too at one point because the d version i not use but in this case we need to make sure that we don't call some some reading function from version for example 1.0 or just have to duplicate to extract the code from that one so yeah yeah yeah so you just mentioned that you basically kept all versions active since beginning of time more or less yes what's the strategy with your example you showed earlier where you have this branching version numbering so where you have your hot fix and production you need to roll out but you're also introducing a new version which path are you taking that usually the very small one i don't take it okay because there is no point of there is a shorter path you can implement that logic directly in the code okay yeah so especially the latest version of the code you can decide from which version you can do the conversion so it's a bit more flexible you can do whatever logic you you you need and to respect the business logic hi thanks for the talk a bit of a follow-up question yes in the same logic of the guy what is what are the semantics of versioning like what can be in a in your example what can be a patch what can be a minor oh yes i i didn't really understand the okay yes the first number is the major version so second number is a change for example when you introduce the feature feat a new feature so can a breaking change in api api behavior in in in your company in this product can it be part of a minor change a manual a minor a minor change not really we try not to do if it's a breaking change then we want to update the the version number the main version number but you you need to be consistent internally and it's quite hard it's not always is yeah that's the whole subject of versioning choosing the right version number yeah yeah cuz i think the the whole room was a bit okay she she's renaming this variable but it's only a patch how does this work okay maybe we can talk about this yeah yeah yeah yeah okay hi yeah thank you for the talk so my question is so i understand that you kind of build the conversion chain from the latest version all the way until the first one right like in this convert yes chain but do you think of like making a shortcut from like version four to version one if like to skip intermediate yeah you you can do that yes and then and the second question is like if you do automatic like major if there a major chain you know build like basically split the version number into into like major and then let's say automatically in break that there is no conversion from version major version two to major version one because like you know this api break whatever you cannot maintain this yes yeah yeah yeah but it's possible it's possible you can do with the the latest version with the convert you can specify for example a realtime exception that say okay i can't convert that oh manually you mean yeah yeah yeah in the code yes but you have to yeah you you have to spe ifi or you convert so for example in your case if you implement the conversion from 1.4 to 1.0 and you have a function that does this has this matching signature it will be taken yeah but for shortcut i was mean like let's say you have you have client wants version one and you have version four and then your version four has like let's say you define conversion to version three and version two but for version one it will still will go 4 3 2 1 but instead of 42 one right like this it will not pick the shorter path even though it exists yeah yeah yeah it's not always the case but if you want to have the the shorter cut is possible to do it otherwise yes you you delegate to the previous version and so on and so on and so on but if you want to specify a shortcut you can do it yeah thanks so it's flexible hi thanks for the talk my question is i as a understand you always go through to the latest api and then uh well once you process it you go back to whatever the output is required right yeah what about the cases where it doesn't make semantic sense to do that from going from one version to the other i don't know let's say there's version one and there's a response one right and then there's version two and response two uh and they can be let's say through different paths internally you have different logic to handle that and there's responses to that but it doesn't make sense to go through this chain yeah but that may be your use case for us it's very important to have the latest response for for for the output of a statistical test so if we update a test so it's very important that the user see the updated value even if it's using a previous client but that's our use case so okay so you force the client to upgrade to the latest version no it doesn't need to communicate with the latest version but it will get updated result even if he use he doesn't upgrade his ver version so yes the output will be different because you will be will have some the latest version of the test even if it's not called directly so okay i have a question around so aside from the interesting payload that you transfer between clients and and collectors do you do any handling for tele syry or logs and can you distinguish if you do this progressive schema transformations can you distinguish live distribution of existing legacy versions out there sorry no i don't understand correctly what you want to say so can you can you can you first of all are you doing any collection of telemetry data or logs from clients nope okay so that's out and then can you distinguish for example do you have any plan on sun setting particular very older versions can you distinguish if you have an version distribution among your user pool if you do these transformations and always upgrade and downgrade messages that you transfer can you still have a clear picture of the pool of existing user for example how many many are in version 1.3 oh yeah you you yeah if you want yes but that's not really relevant for or use case so it's not a goal for you to no not not really but in fact you know use case what takes time is the computation so it's not really the the reading of the data or anything that's not even one of the 100% of the the the whole time so and you don't have like like a an objective of eliminating support for a particular range of version at some point we can decide that but for the moment there is no need so yes yeah it's best if everyone upgrades to the latest version of course yeah and okay i seem to be the last person i just wondered you were mentioning downgrading and upgrading but it seems that in your code you just have convert so you don't explicitly label a conversion as a downgrade conversion or an upgrade conversion and is that deliberate is that better or is it does it not matter i i think it's naming p i like the word convert is short whereas upgrading downgrading is yeah it's a bit longer to type and yeah i don't know okay thank you yeah okay well thank you