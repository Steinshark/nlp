good evening everyone nice to be addressing you i want to talk about color i've titled this everything you know about color is wrong i found out a lot of things whilst i was researching this talk and we're going to cover quite a lot of them let's get started first of all with about me my name is guy davidson i'm the principal coding manager at creative assembly i've been working there on the total war franchise for 20 years 20 20 years i'm a regular participant in wg21 meetings and telecons and that makes me on the committee let's take a look at some of this there we are on the committee i first achieved notoriety in the standards community by contributing to the graphics proposal p0260 but as a result of the poor reception that received i decided to adopt a piecemeal approach and started work on a linear algebra proposal which i've co-authored with bob stegall along the way i started work on a proposal to standardize an audio api for the library i'm also a co-founder of the hash include diversity and inclusion group for c plus engineers and i'd like to take a moment to talk about this the biggest problem that we have in the c-plus plus community is that there are more problems to solve than engineers to solve them especially at this time we need problem solvers to work on the hard problems historically software engineering has been an inclusive environment for example margaret hamilton was director of the software engineering division of the mit instrumentation laboratory which developed onboard flight software for nasa's apollo program and she's one of the people credited with coining the term software engineering but now however we appear to be heavily biased towards white men and have very low gender and ethnicity diversity we as a species need to fix this and if you're interested in helping please visit the website and join the discord server there's over 5000 of us thanks very much so this is our agenda we'll look at identifying colors and how we apprehend intensity and color we'll look at a couple of color spaces and a transfer function and we'll see how color management is widely misapplied we'll take a quick look at the linear algebra proposal because it's actually quite relevant and then finally we'll see how color can be used in c plus and review the proposed api now presentations can be very dull so i'd like to spice things up a little with artworks besides my own scribblings on my slides and i will periodically ask you to identify works and submit your answers to the chat just to check that you're still awake so any guesses he painted this and there are extra points for the correct name for the piece now this is of course jackson pollock this is number 34 which was painted in 1949 it's courtesy of the pollock krasner foundation so you should now know where the chat window is i hope you've been using it extensively all day and how to ask questions which yes will feel to me during the presentation and i will attempt to answer questions as we go so let's get started with another quiz please put your answers in the chat are you ready what color is this what color is this well of course it's white isn't it what about this what color is this well that in fact is red and this one it's not hard is it so this is green this color i really hope you're getting the hang of this now it's blue this one still quite simple nice big blob of primary yellow what about this oh this is the last of the simple ones i would call this purple this on the other hand what color is this well this is called teal although i would have said turquoise or maybe aquamarine but it's time to get a bit more complicated and how about this one what color is this well this is orange believe it or not according to the powerpoint color picker i'd have said i don't know brown or some kind of burnt sienna or burnt umber or something like that i'd have taken a long long time to actually arrive at orange so let's talk about colorimetry okay now the problem we have is one of subjectivity and also context which is the root of all ambiguity so subjectivity frankly it's a pain in the behind it is the home of opinions it is the enemy of engineering and it carries with it out of band information in the form of context in the prior example the out-of-band information was that the viewers were standing in different places and their answer depended on which position they were occupying and this would change their viewpoint this is very much like life itself and arguments on the internet so how do we eliminate subjectivity the obvious although not very useful answer is that we only consider objective criteria we only look at those things that are agreed to be independent of viewpoint so for example if i spread my arms out and they disappear entirely from the camera the distance between the tips of my middle fingers is 1.9 meters and nobody can argue about that we have a definition of a meter and if we apply it 1.9 times to the distance between the tips of my middle fingers we cover it perfectly you can try arguing with me but i would quickly discard you as a troll the secret here is measuring according to an accepted standard and everyone accepts the meter even the americans accept the meter but what about color how do we measure human vision well the first thing we need to observe is the perception is logarithmic differences at low levels are more significant than differences at high levels and this is fundamental to behavior it is evolutionarily advantageous if you're being tracked by a predator hearing a footstep in near silence is very valuable information but if 30 beasts are changing you chasing you then hearing a 31st isn't valuable information and the same is true of sight if you perceive the amount of light that's cast by a single bulb and then suddenly another bulb lights up the effect is noticeable and it will consume your attention on the other hand if you perceive the amount of light cast by eight bulbs adding another one isn't going to make much difference to you this is about the difference between contrast and brightness contrast is more useful than absolute brightness mechanical vision is linear i've put vision in quotes because it's not really vision it's photons hitting a ccd this red blue and green diagram is a diagram of a ccd chip vision is about apprehension understanding parsing contextualizing and that's why it's logarithmic because that's what is most useful machines just count photons using natural numbers in fact they don't even count the photons they take a sample rather than counting the entire number now the interesting information is at the dark end remember contrast not brightest brightness is important so we want to improve sampling at that end of the things that we store this so the solution is to store the square root rather than the actual value which gives us more values at the bottom in exchange for fewer at the top actually i'm over generalizing here it's not the square root it's in fact x to the power of somewhere between one upon one point eight and one upon one point two and this number is called the gamma value but more on this in a moment but you can see that's low gamma samples more evenly across the spectrum than high gamma so low gamma is good for bright pictures and high gamma is good for darker pictures you store the gamma correction out of band in your data so that you can decode it properly all right quiz fans who is this this is ophelia painted by john everett milay and there is a girls school near my studio named after him ophelia is dying in the water right but what about color now there are two kinds of light sensitive cells in the eye rods and cones rods apprehend lower intensities while cones apprehend brighter signals and also specialize over particular electromagnetic frequency ranges there are in fact three types of cones specializing in different ranges now they are labeled s m and l for short medium and long wavelength and as you can see from the picture the s cones respond to shorter wavelengths peaking at 420 nanometers and there are fewest of these they make up about two percent of the cones in the human eye the m cones make up about a third speaking at 530 nanometers and the l cones make up the majority and peak at the longer wavelength of 580 nanometers interestingly in these days of nano processors we're carving processes with tracks that are just you know tens less than tens of nanometers wide this is less than the wavelength of light i find that extraordinary anyway you can see red green and blue as the primary colors here three types of cone makes humans trichromats although originally we were tetrachromats four times until genetic mutation got in the way i've heard it suggested that van gaal was probably a tetrachromat and interestingly women are much more likely to be tetrachromats than men but they are non-functional tetrachromats there has only been one documented example of a functional tetrachromat she was found in 2016. but with three cones being the general case we only need a vector of three values to represent all human vision what we need is a way of transforming these electromagnetic emissions into perceived color so to do this you must take a standard human put them in a standard environment measure how they perceive electromagnetic waves by matching the colours of lights and then build a function that maps electromagnetic wavelengths to human perception giving three values x y and z and then we constrain this function so that all values are positive and luminance ranges from zero to one hundred now this was first attempted in a series of experiments in the late 1920s and these results were combined by the commission international declaration which in english is the international commission on illumination into the cie rgb color space from which the cie xyz color space was derived now not all values are possible the ranges overlap for example s and l cannot both be zero now engineering is messy engineering is real life so the vector space defined by this color space contains impossible values now we apprehend brightness separately from color so let's create a color space to reflect that we can normalize the values so that we have two values representing color and a third value for relative luminance informally known as brightness and it's important to emphasize that y is the relative luminance by deliberate choice now we have a two-dimensional color space that we can vary by brightness and it looks like this this is the xyy color space also known as the cie 1931 color space 1931 this has been going on a long time now the figures in blue in dark blue are the wavelengths x and y vary between zero and one and this diagram displays the maximally saturated bright colors that can be produced by a monitor the area is called the gamut of human vision now some interesting properties emerge all visible chromaticities correspond to non-negative values of x y and z and if you choose any two points of color on the chromaticity diagram then all the colors that line a straight line between the two points can be formed by mixing these two colors an equal mixture of two equally bright colors will not generally lie on the midpoint of that line segment in more general terms a distance on the chromaticity diagram does not correspond to the degree of difference between two colours it's not a linear relationship also if you choose three sources you'll get a large range of colors but you won't get the full range of colors visible to humans because this shape is not a triangle there's so much detail about this dude check wikipedia for an introduction to cie 1931 color space but be advised that several people have written the wikipedia articles and there are slight inconsistencies here and there do take care now i just want to call back to the earlier discussion on how we perceive brightness perceptual uniformity is a property where a small change in a value has the same effect in perceived color regardless of what the value is now values in this color space are not perceptually very perceptually uniform which makes it inefficient and there were three further attempts to achieve this but they still exhibited some distortion now in 1996 microsoft and hewlett-packard created the srgb standard it's a standard the international electric technical commission formerly identified this in 1999 it's often the default color space for images that contain no color space information especially if the image's pixels are stored in 8-bit integers per color channel this color space is designed for monitors and printers in the world wide web as you can imagine it is the most widely used color space srgb defines the chromaticities of the red green and blue primaries the colors where one of the three channels is non-zero and the other two are zero these primaries are defined in terms of the cie color space and they're based on the colors of the phosphors in cathode ray tube tv sets you remember those if you have gray hair and you might wonder if it's still relevant now that crt devices are all but extinct but you can make a try stimulus display that conforms to srgb without using phosphorus you can use leds of the same color and you can use any materials actually as long as the primaries match so let's take a look at the gamut now the triangle is the srgb gamut shown within the cie 1931 gamut it's all the colors you can see on an srgb monitor each corner of the triangle is a primary defined in x y it defines what rg and b relate to in srgb in terms of the absolute xyz definition now you might be thinking to yourself hang on what about the colors outside the triangle i can see those those colors i'm afraid are wrong they are an interpolation they're a representation this image is drawn using srgb the only colors that are available are the ones in the triangle the truth is we can't represent those colors on an rgb monitor or a projector don't get me started on adobe rgb the srgb standard also defines a transfer function between the intensity of these primaries and the actual numbers stored the function as you can see is non-linear and that word non-linear is really important and i'll come back to it in a moment now on the x-axis we have the stored values from 0 to 1. now if you store the value as 8-bit integers it would be from naught to 255. the right hand y-axis also ranging from zero to one you have the intensity so the red blocks the red plot is the srgb intensities versus the srgb numerical values and behind the red curve is a dashed black curve showing an exact gamma equals 2.2 power law as you can see there is more detail at lower values the upper half of the intensity spread is represented with only about a third of the stored values on the left-hand y-axis you have the effective local gamma so the blue plot is the function slope in log-log space which is the effective gamma at each point the gamma cannot be expressed as a single numerical value this is important the overall gamma is approximately 2.2 the number you may have heard the line at the top particularly 2.2 is the median value the value at half intensity however the whole gamma range consists of a linear section near black below a linear intensity of point zero zero three one three where gamma equals one and then a non-linear section elsewhere involving a 2.4 exponent and a gamma changing from 1 through about 2.3 the purpose of that linear section is so the curve does not have an infinite slope at zero this would cause dreadful problems what does this function look like well here we are now it's actually in four lines the first line creates rgb from xyz now this is a simple linear transformation by the power of matrices but that isn't enough we then have to do the gamma correction and this comes in two parts depending on the range for small intensities you simply multiply by 12.92 so those small intensities correspond to the linear part of the blue plot on the last slide the larger intensities you can see the rather unpleasant activity of taking the 5th power and then the 12th root the third and fourth line the reverse operation is going from rgb back to xyz and this is computationally expensive i think you'll agree now most of the time all you want to do is convert your rgb values to a linear space so that you can interpolate now this means you don't need the matrix transformation since that is simply another linear operation so let's look at an implementation of the gamma correction from rgb to a linear space so c underscore srgb is the individual rgb value being converted between zero and one whereas c lin is the linear target value that is a hefty piece of calculation performance is everything and a very common approximation is to simply raise it to the power of 11 over 5. so on the right hand axis you can see the absolute difference shaded in green it's okay but it's fairly inaccurate for example if the values are quantized to 8 bits for the srgb component value 197 over 255 the linear output is 145 instead of 142. can we do better well simply increasing the power a little to 2.233 recurring does improve overall accuracy although it reduces accuracy slightly at lower values but the real problem is that the power function is enormously expensive at three evaluations per pixel for 128 by 128 image you're looking at nearly 50 000 calculations you've got to do one for the r and the g and the b does it scale well sometimes the power function isn't even available you might be on hardware that doesn't offer something like that and you have to manually manually approximate and this approximation a cubic polynomial is actually rather cheaper it's rather better and it's available everywhere as you can see the differences are really quite quite tiny less than 0.2 all the way along but going back to srgb is rather more problematic so let's look at an implementation of the gamma correction from a linear space back to srgb a c underscore srgb is the target's rgb value and c underscore lin is the linear source value now the inverse of the original approximation raising to the power of 2.2 is very very poor please don't do that but fortunately a near perfect approximation is available where the linear part of the graph is clamped to non-negative numbers look at that it's beautiful but of course it does use pow so you can use a polynomial again three square root calls should be faster than the power but do check on your platform so in summary brian's perception is logarithmic xyz defines absolute perceptual colors the xy color space is linear linear interpolation is valid on linear color spaces srgb is defined relative to x y y but the transfer function is not a linear function and it's expensive srgb is non-linear which means that linear interpolation is invalid on srgb i'm sorry this has taken me 22 minutes to explain but there's a lot of background that's you really do need to know to understand why color is wrong in so many ways all right time for another abstract we painted this this is by vaseline kamdinsky it's called squares with concentric circles it's from 1913. so getting it wrong we've taken a look at the theory of colour measurement we've learned about linear and nonlinear colour spaces and we've learned that srgb is nonlinear what could possibly go wrong right here's a simple piece of interpolation x plus y over two i'm trying to find the midpoint between x and y what if the data being stored is in fact the square root square root of x plus square root of y divided by 2 is not the same as square root x plus y divided by 2. so consider x equals 9 and y equals 16. in the first case we have 3 plus 4 over 2 which equals 3.5 in the second case we have the square root of 25 over 2 which equals 3.535 the incorrect calculation is actually darker than the correct calculation 3.5 it's less than 3.535 believe it or not midpoint is a remarkably subtle expression and easy to get wrong last year marshall cloud spoke at several conferences all about it and i really do encourage you to find his find his conference talks and look it up it's a it's an extraordinary piece of work so new for c plus plus 20 is midpoint and lerp the more general version for linear interpolation so what does that look like in practice well the top bar on this on this diagram the top red to green bar is a correct interpolation between red and green the colour range has been correctly transferred to a linear colour space that has been interpolated and then returned to the original colour space the bottom bar is an interpolation without transference it is non-linear and it looks like a sludgy mess it's too dark in the middle i hope you have good bandwidth actually otherwise this might look a bit blurry now this is an 8-bit srgb perceptually linear ramp incorrectly taking a round trip through 8-bit linear color you can see that the darker colors those are on the top left experience severe banding we start off at zero and then we suddenly jump to 13. and this is there is a quite significant precision issue now this effect is known as posterization so this entails the conversion of the continuous gradation of tone to several regions of fewer tones with abrupt changes from one tone to another and you can see such an abrupt change at the start zero to thirteen the leaps get smaller as intensities increase and you will recall that sampling is at a much higher resolution at lower intensities so you would expect the error to be much more profound at those levels now this was originally done with photographic processes to create posters with reduced color depth when there were fewer inks available and wikipedia tells me it can now be done with digital image processing and made it may be deliberate or an unintended artifact of color quantization and it sounds like a rookie error doesn't it you wouldn't expect this in professional software sadly i have to ask you to think again my colleague james barrow brought his sleeves up and surveyed the landscape of code using color it was not a pretty sight and i present now his findings we'll start with sdl this is a popular cross-platform development library which provides low-level access to pc hardware it has a number of pixel formats this library features an srgb mode which yields quantization but there is no documentation about it at all now sfml is simple and fast multimedia library a popular cross-platform development library which provides low-level access to pc hardware it also has a number of pixel formats but this library features an srgb mode which also yields quantization and there are operator overloads on the colors but again there's no documentation about whether the linear or non-linear color spaces deer in gui is a bloat-free graphical user interface for c-plus plus with minimal dependencies it doesn't support it doesn't all alpha blending is wrong by default it treats srgb and linear color as interchangeable internally performing blending on 8-bit values which store srgb so that means it's hard to fix it exposes 32-bit color types in the api which results in quantization of using an srgb frame buffer and again no documentation flash was insanely popular until adobe quietly put it out to pasture the official documentation makes no mention of gamma correction 8-bit srgb colors are everywhere that are used like linear colors it seems that there's no support for linear color or gamma correction whatsoever and again no documentation ah unity there is no documentation on the color space here now assuming this class is meant to store srgb then lerp is incorrect and the operators provided are incorrect assuming this class is meant to store linear color the color constants are all incorrect hsv to rgb is incorrect assuming this class is meant to store both linear and non-linear then unity has a global toggle for whether or not the rendering is linear color or srgb which means that the interpretation of color and the correct operations on it are a runtime choice the documentation does not specify the color space of the default colors so overall unity's color management is fairly brittle look at godo again no documentation whatsoever on the color space and many of the documentation samples skip over the concrete examples that would demonstrate one way or another or they use weasel words to avoid specifying the intent of a function so assuming this class is meant to store srgb linear interpolation is incorrect blending is incorrect we check the source code and gray is calculated needlessly and incorrectly assuming this class is meant to store linear color most of the constructors and the conversion functions are incorrect gray is calculated again needlessly incorrectly and from unto hsb is incorrect and this is a miscellaneous issue in general gray is calculated incorrectly as r plus b plus g divided by three regardless of the actual color space and lightning darken are words used to imply something very different to what's actually being done this class is overall very easy to misuse ogre again no documentation whatsoever on the color space in the official docs now assuming that it's color class is meant to store srgb all the arithmetic operators are wrong assuming this class is meant to store sr elements or linear color then the color conversions are wrong so overall this color class is extremely likely to be misused so here's a picture of some cats any ideas who painted this this is by an austrian artist called carl carla he painted this in'93 and entitled it my wife's lovers those are turkish angora cats anyway as you can see it's not great this is some of the most widely used graphical software and i don't like just iterating through software and saying this is wrong this is wrong i don't like attacking my colleagues i don't like i don't like highlighting their faults or anything like that but i have to emphasize that color is wrong in so many places and in fact i'm only about halfway through the list let's crack on let's look at cryengine now there's a lot going on with cryengine james discovered six different representations of color in cryengine all of these so we have the usual set of errors so color tpl has arithmetic operators which can never be correct for for a type of studio intake not two five five other operators will quantize when t equals stood you in date and the color class can never store linear colors and there's no documentation so if these are srgb color space then arithmetic operators are incorrect srgb to rgb is lossy for color tpl scale col is probably incorrect lerpfloat will give unexpected results gray is probably incorrect and if there's a linear color space then color tpl provides incorrect packing operators to and from hsv is incorrect and more generally luminance calculation must be incorrect in one color space or the other there doesn't seem to be a canonical color representation that functions take which means that color management is ad hoc so text to screen takes a float rgba set clear color takes effect 3 set font color takes a color tpl draw 2d label takes a pointer to float and all of those functions are in the same class some documentation is just wrong rather than absent this is a real problem cute or qt i still don't know what the what the canonical present pronunciation is but it isn't too bad cute color seems to be implied to be gamma encoded only but a closer look brings up the the q color space class which allows you to convert 32-bit qrgb values to linear color their rgba values now this is not ideal but you have to really want to shoot yourself in the foot here so qr excuse me qrgb does have a q pre-multiply function which will produce quantization but other than that given that it's a ui toolkit it seems to handle everything fairly correctly there's almost no support for linear color in the api at all but apparently internally it's all linear color and can be correctly rendered with gamma correction so win let's rush through the rest matlab rgb to gray uses an incorrect formula to calculate luminance which assumes the ntsc color space open cvs convert color with cv color rgb to gray uses an incorrect formula to calculate luminance which again is only correct for ntsc now svg and css both of these perform blending in the incorrect color space by design now this website also links to several articles reinforcing the content of this talk i'm giving you right now eric mcclure writes and this is a long quote i'm going to read it out the amazing thing here is that the w3c is entirely aware of how wrong css3 linear gradients are but did it anyway to be consistent with everything else that does them wrong it's interesting that while svg is wrong by default it does provide a way to fix this via color interpolation of course css doesn't have this property yet so literally all gradients and transitions on the web are wrong because there is no other choice even if css provided a way to fix this it would still have to default to being wrong it seems we've reached a point where after years of doing srgb interpolation incorrectly we continue to do it wrong not because we don't know better but because everyone else is doing it wrong so everyone is doing it wrong because everyone else is doing it wrong a single bad choice done long ago has locked us into compatibility hell we got it wrong the first time so now we have to keep getting it wrong because everyone expects the wrong result this is a council of despair alacrity is the fastest terminal emulator in existence apparently using the gpu for rendering enables optimizations that simply aren't possible without it but sadly subpixel fonts aren't read correctly if srgb frame buffers are disabled msys2 has a command line terminal called minty color blending looks done incorrectly there's too much color in the sub pixels the windows console color blending also looks incorrect too much subpixel color microsoft terminal seems to handle things correctly in clear type mode nice but i'll reserve my strongest praise for unreal engine it is linear by default it has a class called f color and a class called f linear color it has appropriate operators and it has full documentation right finally linux has historically not had very good srgb support due to the x windows system opengl is simply underspecified so for example rendering to an srgb enabled back buffer opengl and opengles use different srgb enabled by default parameters with opengl having srgb disabled by default and gles having srgb enabled by default and this results in bad things happening for example within m script m scriptin compiled opengl they need a new name for that the linux nvidia bug where the default frame buffer can't be srgb drives me again to despair this is despair artwork can only tell me who painted this this is the desperate man by gustav kirby painted in'42 fortunately hope is at hand who can tell me who painted this so this is giving thanks after leaving the ark by enrico morelli about 1901 so we now know about colour we've seen what can go wrong time and again so how do you stop the world from making this mistake how do we break out from this never-ending cycle of pain well earlier i alluded to the linear answer proposal now this is paper number p1385 and it's an important proposal because it introduces a consistent api and syntax for performing linear algebra there's another linearity proposal in motion which i'll talk about later but this paper is informally called the syntax proposal now there are a number of high quality public and private linear algebra libraries in the c plus plus ecosystem but unfortunately they don't interoperate and if you want to build something universal then you're out of luck you have to build something that operates with all of these libraries so as a result other languages like python are stealing our lunch when it comes to things like ai now by creating a unifying syntax other library maintainers can use the customization points exposed in this paper to add their own optimizations so the goals of the linear algebra proposal are to provide linear algebra vocabulary types to parameterize orthogonal aspects of implementation by which i mean i'm offering static polymorphism using template parameters it offers defaults for the 90 of normal users and customizations for the 10 of power users it provides element access matrix arithmetic and fundamental operations and then it manages mixed precision and mixed representation expressions and these last two items are important to a color api so let's rattle through the nature of linear algebra it's the branch of mathematics concerning linear equations and linear functions and their representation through matrices and vector spaces now a linear equation is the sum of known coefficients that's a1 through a n multiplying a series of unknowns x1 through xn it's fundamental to analytical geometry and linear regression and solving simultaneous equations now a vector is a tuple of scalars and you can perform addition and the inverse operation subtraction if the operands have the same number of elements you can multiply by scalar and you can perform an inner product which is also known as a dot product vectors can be arranged as row vectors and column vectors so a dot product is performed between a row vector and a column vector of the same number of elements a matrix is a vector of tuples again you can perform addition if they have the same size along with the inverse operation and you can also perform scalar multiplication like this matrix multiplication is a rather more tricky affair it's not relevant to the code proposal but rest assured that the linear algebra proposal supports a broad range of applications and those of you who are really familiar with the linear algebra domain we've heard of blas this is also the subject of a proposal so it has the name the blast proposal the idea is to wrap up the c api defined by blas inside a c plus api the blast api is battle hardened through 40 years of use when i first started writing games blast was a year old now this is an excellent proposal and is complementary to the syntax proposal and the blast proposal and the syntax proposal are both targeting c plus plus 23 perhaps a little optimistically now the problem of mixed representation is tricky because c plus allows you to add a float to a double or a double to an integer it performs the appropriate conversion silently and lets you get on with things without cluttering up the code if it didn't do this you would be stuck with casting instructions all over your code but this isn't available for user defined types and of course it isn't how would that work and we already have this problem with the library defined stood complex type if you try and add a complex number of floats to a complex number of doubles you get a compilation error in the same way you might expect the multiplication of a vector of floats by a matrix of doubles to also fail in compilation now the library deals with this in quite a coming way but that doesn't matter to the color proposal but i will come back to this in a moment the proposal also allows for substituting alternative algorithms for particular use cases for example if you have a sparse matrix you may not want to use the regular multiplication strategy because it has a complexity of order n cubed and you might want to use something a little more appropriate for environment perhaps you want to use strassen's algorithm which has a complexity of order 2.807 this ability to customize algorithm choices is very useful for a color proposal now this is a really short summary and i've already spoken at several conferences over the past couple of years about linear algebra and geometry you can find these all over youtube and i'll be happy to answer questions about the linear algebra proposals later but we do need to move on so it's time for some more ass who painted this it's called spring sun i'll give you a clue yes this is tableau one painted in 1921 by p.a mondrian the first painting spring summers late 1909 early 1910 so the obvious first question to ask is why standardize color in c plus plus well it's been a long time since you could buy a green screen or a monochrome monitor colored text on a monitor has been available as standard since the last century the last century okay you don't get to say that very often all you need to do is power up a linux shell and type ls to see coloured text in action it's a very useful cue for differentiating information here blue is for directories green is for files but you can't write this in standard c plus you need to bind to a separate color implementation for your platform now one criterion for considering something for inclusion in the standard library is if it's hard to get right for example it's very hard to write concurrent cues such an entity is being proposed for specialization it can't come soon enough as we saw from the earlier parade of misfortune it seems to be very hard to get color right and this is all well and good but why teach it to c plus well there are three use cases that spring to mind immediately the fmt library is a great leap forward in text output but it doesn't handle color at all a color proposal will allow output of colored text to the standard output now next any serious graphics manipulation software is going to be written in c plus and this is where we have observed most of the problems with color in c plus software a color proposal will reduce the error here and then finally i have a provision in flight to introduce a simple drawing library to the standard library having color in the standard as well as linear algebra will reduce the bulk of this paper and if we're going to have a color proposal what are the requirements when it needs xyz support and conversion between xyz derived color spaces it needs compile time user defined color spaces and runtime data defined color spaces it needs to allow icc profile implementation we didn't cover that did we it needs to be strongly typed and it needs high performance without storage or speed overhead ah american spelling so basic color space is our first struct and it's a tag type like iterator category now from it we derive two color spaces rgb and xyz so then we have a basic color model which tells us how to store colors now in the case of xyz this is trivial it's a tuple of three floats the rgb model is a little more interesting it might be a tuple of floats or a vince or even a mixture in some strange cases now alpha is always linear so it's quite a simple type we need alpha for composition now putting these together we get a basic color type so this is simply a descriptive class that takes the color space the color model and the alpha model as template parameters and exports a number of symbols describing the space space type model type alpha model and now we can create color classes so let's start with the standard rgb space over unsigned 8-bit values without alpha so there we have it srgbu and date basic color over the standard rgb space over unsigned eight bitmap values no alpha and then we get the same thing but with floats srgb float srg it's a basic color over srgb space using the rgb float model and no alpha so now let's add alpha i hope you can see this is not quite rocket science and then we get the same again but with floats so linear rgb looks like this basic color of the linear rgb space using an rgb flow model without alpha and with alpha float alpha in this case and then finally we need an xyz class the xyz cover space no alpha of course now we need to be able to convert between things so here's conversion between alpha models pretty trivial and his conversion between rgb models so we need to take three parameters t u and v and we need one and two for each of the models and we have a context for void because it's simple it's just an arithmetic calculation that converts between rgb models now this beast and it is quite a large piece to afraid is for conversion between two arbitrary rgb spaces so you can see that our parameters is a space a model and a gamma and an alpha twice which completely defines your rgb spaces then we have conversion between generic rgb and xyz as you can see it starts to get quite hairy this is the other way around so recall the transfer function was a simple matrix vector multiplication and a gamma correction function with linear algebra in the library we can customize implementations according to use case so if you want something quicker than the absolutely correct function you can substitute your own function i'm going to skip over some of the implementation details and round off this section with the generic convert function that these enable so there we have it that's your simple conversion destination source and then all the arguments needed to describe the spaces so that small set of objects is all you need to describe colour and that about wraps it up we looked at identifying colours and how we apprehend intensity and colour we looked a couple of color spaces in the transfer function we saw how color management is widely misapplied we took a quick look at the linear algebra proposal and then we saw how color can be used in c plus plus and a proposed api so was everything you knew about color rom thanks very much