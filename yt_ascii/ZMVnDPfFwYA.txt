i want you hi meeting c plus plus online i want you to make error handling your user's problem it turns out they may thank you for it it says will users are ungrateful sometimes they should [music] this is inspired by bendin's now six-year-old talk using types effectively and and by a problem i had at work some time ago now but the very short version of it is you should write some total functions because they're easier to understand and they're easier to write and i have some very bare bones examples i'm sure you can extrapolate them to your own work but let's say we want to count some vowels in a text string it's not hard except what's the return type here what if they hand us a null pointer right we can't necessarily just always give a good answer you could say that there are no vowels in a null pointer but you could also say that a null pointer is not a string like it's not a string of chars so what do we do do we throw an exception some people hate exceptions we could make auto a pair right this we've seen this one before or it could be an output value or anything or we could just throw up our hands and say to the user actually you know what if you give us a null pointer that's ub like just don't do it there's a precondition on the input that you don't handle as a null pointer or you could just use a string view you could just use a string view obviously if you're in some very special case where you cannot use a string view or if your code is space is old enough then write your own string view if it's not in the standard yet but you can just use a string view the return type is a size type or it's an integer if you want it to be but the point is it's it's not in doubt like this this function is so easy to implement that it's almost it's almost embarrassing to talk about it like implements itself there are no weird edge cases with a string view solid return type and the users don't need to read the documentation for count vowel like you can see that single line of code returns the size type takes a string view i know what this function does i don't need to read any documentation now this is a symbol function but what if i don't need to read any documentation for other functions so string view is in the standard let's take a different example the reciprocal the inverse of a double i mean we we want to write it like this like that that's what we want to do but of course that's not how doubles work doubles aren't real numbers really we have a we have a bunch of preconditions each of these preconditions you could write them in the documentation the user is going to have to find out how how this function works somehow does it throw what does it do who knows but you should solve this problem exactly the same way right you should you shouldn't take a double you should take a divisor devices as class you write it yourself in five minutes and handles all of this so the function has no room for error anymore what if the user has a zero though what if they try to construct the device with a zero that's what i mean but you should make the the error the user's problem obviously if your user can use exceptions you write devices so the constructor throws that simple but if you don't the private constructor right have a static function in the divisor that gives you back an optional divisor or if you don't like optional in your code base because it's c plus 11 write your own optional but either way your actual function reciprocal is that symbol now this does have a problem because if you take every single input parameter that you have in all of your functions that currently throw or return errors and you write classes for them i have i have some sad news there's nobody who wants to read all of the documentation for a whole new class for every input parameter that's gonna get old but if you adopt this approach also of course consider adopting a framework do something like this the user this is this is the cpp file using divisor that line goes in the header file along with the with the function function signature so the user can see what it is a divisor is a constrained double it's not zero and it's finite and if you're not if you're not familiar with the c math library finite means it's not nan and it's also not infinite it covers both of them so i guess you have to know your your standard headers to know what this line of code means but the the great thing about this is that it shows the user right here without having to go anywhere to read documentation what the constraints are on a divisor you're going to have to write the constraint class yourself and your user is going to have to understand it but once they understand the constraint class in one place then when you use the constraint class in a different place they don't have to read it again it's just a set of constraints and if you name your constraints well you can read them all on that line see exactly what the requirements is for a double that wants to be used as a divisor so concluding really you should enforce your preconditions within variants it makes your functions much better it also lets your users select their error handling because if they can't handle exceptions you can just in your class that handles your parameter not use exceptions it's all been pushed out and instead of writing and documenting a lot of parameters you should consider using a framework to save time [music] that's that's really it i wrote a framework like that earlier this year it's fantastic it's going open source in a very short while but if you want to have something in-house write something in-house it's it's not very hard and it solves a lot of problems hey thank you that was interesting thank you sir um