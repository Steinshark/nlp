for this week's podcast we're going to take a look at a functional programming language called rock it's born out of a language that i'm very fond of called elm it's a really nice language and if you know anything about elm then you might know this week's guest richard feldman he's been hugely immersed in elm's approachable developer friendly interpretation of fp for years now he's given loads of talks about elm and he's been inspired by elm because there's always been a limit to elm it's just for the front end so in this episode we talk about what elm means to him and why it's inspired him to build a language that breaks out of that front-end limitation but also really curiously why he sees that limitation as something very freeing and why he sees the limitations of functional programming as freeing and how he's trying to make a new language with comfortable limitations that works in many many different domains he's almost trying to make rock a universal domain specific language by giving each domain the right set of constraints for that particular task if you can't quite imagine how that would work we should get into it i'm your host chris jenkins this is developer voices and today's voice is richard [music] feldman [music] so joining me today it's richard feldman richard how are you doing well chris nice to see you it's good to see you too i don't think we've seen each other since some conference in northern europe coup years go to copenhagen 2021 that was where you you gave me the my favorite explanation of what a pure function is or definition which is a lookup table i love that i still i use that all the time now so thank you it's a nice way to think of it i think i got that from some book on lis macros or some variant of that idea but yeah very nice when we now i can't remember when we were at that conference i can't remember if you were talking about elm or rock or you were just making the switch that's a good question i think that was the conference where i gave some sort of general talk i think it might have been why static typing came back no maybe that was a remote one oh it was a functional programming for prac ists i think which was yeah not not really specific to either rock or elm okay but so a lot of people the people that know you a lot of them are going to know you because for a while for a good number of years you were the poster child for elm you the face of elm i did a lot of elm talks that's for sure and i and wrote the book for manning yeah elm in action nice frontend masters course intro to elm and advanced elm and yeah a lot of el stuff are you still doing elm or have you moved on i wouldn't say i moved on it's more that i don't have time for things that aren't rock especially now that i have a kid it's it's really like my free time is like 90% rock and then there's a tiny bit of exercise and guitar in there and that's that's really it i just don't have like there's even like projects i'd like to do in elm i'd really like to go back and update elm spa example but like and elm elm css for a long time i had like pull requests that would be open i'll be like oh this weekend i'm gonna get to it and then after a while i was just like yeah this is never happening is it i'm just never gonna have like the bandwidth to do this stuff so i still love elm i just i just feel like i have a more of an obligation to rock because it's like if i want to make this new language happen i just got to put in the the amount of work that that takes and it's a very large amount of work because it turns lot of work and the price of a spare hour once you've got kids is very very different right yeah yeah i mean it's really like i mean it used to be like i got done with work and then it's like cool now i have the whole evening and now it's like i get done with work and i got to go pick up the kid and then go take him home and then feed him dinner and then give him a bath and then do some like play time and some story time and then then i get to eat and then it's like cool now i'm exhausted and let's see how much time i have for you know rock stuff maybe an hour and half an hour's worth of energy left yeah well then it's like well you know don't don't sacrifice your sleep because that catches up to you very quickly and so yeah a it's a difference i mean people have kids i'm sure are very familiar with this yeah you're you're listening to the joys of parenting podcast yeah i mean like it's it's also wonderful but it's it's definitely there's just a math problem yeah yeah okay so let's put it this way then there you are with a serious premium on your time and you decide to dedicate as much of that spare time as you can to rock so why why creating new language what's burning inside of you so you original motivation was three i could break it down to three categories so one was like i'm like i love elm but elm is very focused on front-end web development or at least that was true at the time now it's it's there's like a another thing that is unreleased but is is also very focused and so i was like but there's all these things that keep coming up that are not frontend web development where there's this really big gap between the user experience i'm used to in elm and really love and like the thing that's available and like the best experience i can possibly get in that domain so classic example of this is like web servers or command line apps or native desktop like graphical user interfaces but another example is just like a vim plugin like i was using vim at the time and i'm like i really would like to try to write a vim plugin but i don't want to do it in vim script i want to do it in like an elm like language you know or like a database extension like i would really like to try that out but i don't really want to i was like looking at the options and it's like there's plpgsql which i'm like i don't i don't really like that and there's like well you can do pv8 but now you have v8 running in your database like do i really want that and evan made a good point about like you know now you have garbage collection pauses in your database do you want that like definitely don't want that so everywhere i looked there would be or like arduino there' be these use cases where it's like yeah if you want to do something in this domain your options are limited to like javascript or python or lua or like c or some some variant of that and i i was just like that none of these options excite me i really want to try to get some sort of elm like experience in these domains but i'm also like elm's never going to expand to these domains like the whole point of elm or or a major point of elm is is to be really focused and like doing a really really good job with this one particular focus use case and so the idea of expanding elm to cover all these things just just it's not really elm so what i wanted to try and do is to try and answer the question is there some way to try and 8020 recreating that experience and try to make it so you can have what feels essentially like an elm like experience even if it's not like the absolute best to that one particular use case so that i can at least get that much closer to elm or like an elm like experience in all these different use cases yeah so that was that was one motivation another was over the years i'd talk to evan who made elm about various ideas that i'd had for elm and sometimes he would say that's actually not a good idea here's what you're missing and i'd be like okay good point good point i didn't think of that sometimes he'd say that's like a reasonable thing you could do but it's not what i want to do with this language so we're not going to do it and the third thing would be just like that actually is a cool idea we could try that but it's it's kind of like that ship is sailed like it would be too big of a breaking change to try like given how many thousands of people are using l and so those second two groups are like well h you know i like this even if evan doesn't i would like to try it or i'm really interested in trying this thing out but it's too late for elm but it wouldn't be too late for like a a new language built from scratch so those were kind of like accumulating you know as we had more and more these conversations oh i should mention that like another category of things is ev would be like oh yeah that's a good idea let's do it and then like that is an elm now but of course you know those are there there's nothing burning inside me about those i'm just like cool good so so that was like a second category of thing and then the third category of thing was just kind of thinking about you know i didn't really think about it this way at the time but over time it's it's kind of become an increasingly important thing to me is just thinking about feeling sort of bothered by the fact that functional programming or like pure functional programming is not widely used in industry in all these different domains like you look at like what's the most popular backend language and you know you have to go very far down the list before you find hasell which is like the number one most popular you know backend language you look at like game development it's like people are doing game development in c like i get people doing game development in c++ and in rust and in c and zig those all make sense to me i understand it you know you have very tight performance constraints but then people do it in like c and swift like well if you can do it in an automatic memory managed language why is why is there no like functional programming option for like you know game dev on like a console not not even just you know like on a computer but like on a phone like something like that yeah and so i just started thinking you know i don't think that it's it's like correct in the world that there should be no viable option like no mainstream option where people can just pick it up and say i want to go do game dev in a functional style and let's let's see how that goes in a world where like c and swift are considered reasonable ways to do it or or on java of course you have like you know sorry on android rather you have java and cotlin if those are all viable that i totally think they're a functional thing should be viable and in fact should be a really nice way to do those things and so putting all this together at some point i kind of reached a point where i was like i should do this like no nobody else is going to nobody else is going to do this i should i should just go and do it and i i have to admit that part of the motivation there was you know i sort of finished the book element action took me like four years to finally ship it i'd done these like courses on elm and at that point i was kind of feeling like you know i want another really big juicy project to sink my teeth into but i don't want to like manufacture one in elm just because that's what i know really well it's like i want i want some project where i feel like this is something that i can really devote a ton of time to this is before i had a kid so i had a lot more time you know back when i was asking the question of how can i fill my time with something rewarding but you and your partner came up with a far more efficient answer to that yeah and like we we' plan to have a kid so like i actually was thinking from the beginning i was like okay everybody says when you have a kid like time is you know lower and so how do i plan for not having the project grind to a screeching halt when that happens but basically i i was like looking for something where i was like i would like to be able to sink my teeth into something really difficult and that where it's going to be something i'm pushing myself and learning a lot and so it's not like you know i did an advanced elm course or front end masters but it's like i didn't really have a sense of like there exists a project within elm that i that that fits that characteristic so it was it was kind of exciting to me to be like this is something i can work on for like a decade plus and and you know if i'm successful at it then it'll be really rewarding and so that was also sort of part of the motivation so anyway all these things came together and i was like okay i think i'm going to do it and so i kind of in 2018 i started sort of drawing out some designs and like what had all these ideas like how do they all fit together like how do we try to do this recreating the elm feld and this long tale of domains like 8020 style and i talked to evan about it and his his initial impression i remember like i i told him at a l meet up in in san francisco and he he he he got this like smile on his face he's like this is a very u language which i i i i kind of like you know there i have guesses about like you know the different things that he meant by that but but i definitely take that as a compliment so he kind of like helped me out with like here's okay you're gonna need to read these papers about like you know type things and here's how to understand the notation of these papers so he was he was very encouraging and helpful and yeah so so i started doing it and i don't know fast forward four five years and now we have a real website and like people using it and it's it's become a whole thing so what are your what are your defining domain features for this language and at the same time what do you think makes elm so special that which bits did you pick of that that you thought these a priori is to having a language yeah okay so so to me one of the essential qualities of elm is the thing i was mentioning earlier which is having a sort of domain specific focus and you know although we can't completely replicate that while sort of targeting the longtail of domains one of the things that i do think is really valuable about that is having sort of a cohesive design for that domain so as an example of this so rust has in its standard library as most languages do ways to interact with the file system you can do you know read from a file write to a file but then you take rust and you put it in a web application like there's this framework called you ye ew for rust that's like okay compile your rust app to web assembly run that in the browser well then the question in my mind immediately becomes whatat about all these things in the standard library that aren't available in the browser like file system access like what happens if i call one of those or more importantly what happens if i use a dependency that calls one of those like i have some rust dependency that i depend on that maybe it depends on something else and somebody just added a little oh we'll have a little onis caching feature and maybe it doesn't come up all the time but all of a sudden you know i'm running my app and like what happens i mean i have to assume it crashes or something hopefully i mean ideally my app just wouldn't come compile but i don't expect that because it's using stuff that's in the standard library so things like this just don't happen in elm like an elm like the entire ecosystem is totally cohesive it's like you want to use it for browser based stuff the only things that are available in the whole ecosystem are things that are available in the browser and so you just don't have that problem or you think about like a database extension or you know do you want your database extensions using the network like just willy-nilly yeah i don't know like if i have a dependency that's like oh i'll go check for a new version of you know unicode or time zones or something like that do i want that happening in the middle of my database without knowing about it probably not so i think every domain can benefit from having some sort of first class concept of like this is the domain i'm working in here are the primitives that are available and they're sort of tailored to that domain that's something i found in elm that i haven't found in most other languages in fact very few other languages so that's definitely something that we want to replicate and rock and so the way that we do that is we have this concept of platforms and applications so a rock platform refers to sort of the domain that you're working in it's it's something like a framework so every application that you build has to have a platform like you have to pick a specific rock platform to build on and that platform's job is to do provide all the domain specific primitives so rock standard library actually does not have file system stuff it doesn't have any io at all that all comes from your platform so for example if i'm doing a web server platform it'll probably have things like file system and tcp but it probably won't have like read from standard in because if you're building a web server why do you want to block on like you know hey let's wait until we get input from standard in that's probably not doesn't make sense in the context of a web server but if you're building a command line app of course that makes sense that's that's you know a totally normal thing to do so sort of differences like that like like being having this domain specific focus and we can get into this a little bit later but one of the other things that platforms do that's different from like a frame framework for example besides being in charge of io is there also in charge of how memory gets managed to some extent which has some cool performance benefits that are kind of behind the scenes and you just sort of get for free as an application author okay are you expecting people to write these de these platforms for rock or is it something that the rock authors provide so we already have a couple of these so the two most commonly used ones are it's called basic cli and basic web server and as the name suggest it's a wait a platform building you know cis it's pretty basic one and then same thing for the web server and then we also already have a couple of variants of that and anyone can build a rock platform it's not like a you know you need like special well i guess you do need special knowledge in the sense that it's not very well documented currently how to build a platform we have a lot more all the documentation kind of focuses on applications the platform authoring story is a lot rougher right now i mean rock still work in progress and that's an area that's very work in progress but yeah like we so for example we have like a a tui like a terminal based ui where you have rather than a typical command line thing that's just sort of like well we'll do like print some stuff and then wait for user inputs like you know you have like the keyboard like arrow keys moving stuff around rendering on every frame and then you also have in addition to the basic web server there's another project called nia nea which is a fishan word actually for for never and it also kind of could be short for never ever allocate but basically what it does is it it presents the same kind of is basic web server for just i want to build my web server but behind the scenes it does things differently with memory management where you never get garbage collection pauses and allocations are much more cheap because basically what it does is every single web request you get the request comes in all the memory allocation for that entire request goes into this little arena that's dedicated for that request and it's bounded so you can say like you know i only want to allow this much memory per request if any given request goes over that it's going to immediately 500 and then as you know as long as you don't go over that then basically it just keeps allocating into this one block and then at the end once you've send the response back it says okay all of that is now garbage and it doesn't even need to free it it can just say all right somebody else gets this now some new request gets that that memory so it's really really cheap in terms of memory management it's very far from like mark and sweep garbage collection across all your different request handlers but you know it does have trade-offs it's not like that's you know just an unalloyed good it's like you know you have to decide how much memory you want to allow for each of these things and so forth and so that's a good example of sort of innovation that can happen by someone saying hey i've got the same constraints like the do same domain constraints like the same primitives for this platform versus another one you can now try it out as an application author and if they have compatible apis i can just change one line of code and try out this different platform it's like cool everything still works but now your sort of engine under the hood behind the scenes is different so yeah this is the type of stuff that in elm is not really possible and on the one hand that's good because it means you don't have these sort of like different decisions to make like one of the things that people love about elm is that you can have this sort of like all the questions have been answered for you at that level thing it's like it's a cohesive ecosystem built built around like like basically nobody uses frameworks in elm it's like you know you have the basic html stuff you have http stuff everybody just kind of uses the stuff that ships to the language that's a selling point of the language yeah yeah rock can't have that selling point because we have sort of longtail domains focus but a corresponding upside that comes with that is that you can get this sort of experimentation with like different things in the community and people can try out different approaches like that and maybe it turns out everybody loves the nia approach and and gravitates towards it and maybe some people say our allocation patterns are such that like they're kind of all over the place some requests use a tiny bit of memory some requests use a huge amount of memory and so this just doesn't work for us maybe somebody else tries a variation of nia that accommodates that with while still you know trying to maintain the benefits there's all these different ways that people can do those things and i think it's really cool that it is you know possible to do that i don't know of any other language specifically when it comes to memory management that has done that do you foresee someone writing a platform that's specific to the front end and eventually subsuming elm well eventually subsuming elm no i don't i don't see that happening but it has already happened that people have tried building rock you know like web assembly and like building a front end ui think so it turns out because of the way that rock is compiled it's not quite possible to do the elm architecture in the same way that elm has there's a lot of details behind that but if you try to just do the normal like html message thing that everybody loves an elm it it's not you can't quite implement it in rock for various reasons there's like you could do it like an extra type variable which is like kind of unergonomic and y y but to me i think one of the things that makes elm so great for the front end is that it's so tailored to that and is able to do things like elm compiles to javascript if you're comparing compiling web assembly to javascript i would have thought back in the day when i first heard about web assembly like oh that's just an upgrade like you compile to web assembly you get to go faster amazing well it turns out now that we've actually done some compiling to web assembly it's it's not that simple it's actually there's a lot more complexity that you don't have if you're compiling to javascript for example there is no way in web assembly to directly access the dom at all you have to go through javascript so what ends up happening is if you want to build a web assembly application like you or like you know doing it in rock you have to compile it to web assembly and then there has to be this javascript layer that does all the dom stuff that sort of communicates back and forth with web assembly and of course there's overhead there so it's like maybe your individual web assembly things are running really fast but unfortunately the corresponding downside of that is you have all this mandatory extra overhead of sending stuff to from javascript in order to do things with the dom so a it's it's not a given that the web assembly version is actually going to be faster b it's also not a given that the web assembly compiled asset's going to be smaller it might actually end up being bigger especially because rock has a monomorph ising compiler which is great for other domains but not as great for the web so to me it's like i totally understand the impulse to want to build that because a lot of people like having the exact same language on the client as on the server you know rather than for example having like two very similar languages like el and rock are very similar personally that's what i'd go for i'm like elm is the best at this and there's a whole ecosystem and so forth and like you know pair that with rock on the server but i totally understand that you know some people like want to do both but i don't really see that leading to like rock rock sort of like subsuming elm in the same way that like just because it can be done you know like people will simulate elm in like typescript and you know it's it's just not the same experience i think the experience would be a lot closer with rock than with something like typescript but at the end of the day i think you know there's there's just so many nice things about elm that are that would be really hard to replicate and rock you know even if we've got this sort of 8020 thing that in that one domain i just don't think it's ever going to be as good but you know maybe people will prove me wrong but that's that's just kind of my prediction okay okay so let's talk about some of those features of elum and whether they've made it into rock for instance one of the headline things is it's like it's probably the most userfriendly version of a hll like type system that i've seen in the wild and it gets there by like simplifying let's let's not say dumbing down but simplifying the hasal type system to the greatest hit that's that's one way to look at it i think so if if you're coming from a hll background i can see why that would be the way to think about it but like evan did a lot of like standard ml in college and i mean he learned haskal later on but i don't think you know i can't speak for him directly but i don't think he thought of it as like let's take hle and let's subtract things but rather like let's start from standard ml which is already a lot simpler and make some adjustments to that based on what i've seen in haskell and o camel in these other languages and i think the main thing that elm takes from haskell is actually syntax if anything like compared to sard ml and and also of course the idea of having pure functions for everything and like taking out the you know direct mutation capabilities so rock does all those things too but yeah i mean definitely for me pure functional programming has always had its benefits rooted in subtraction it's about like taking the whole possibilities of what the cpu can do and saying we're going to intentionally restrict that to this subset of things that you can do because there's a bunch of benefits if you do that there's a bunch of you know it's not like you're just taking capabilities away from yourself for no reason you're taking them away because then there's this whole category of things that you don't have to worry about anymore and these and it unlocks these other things that become a lot easier to optimize or to to improve in various ways that if you have the full range of capabilities become a lot harder to do or to do reliably especially across a big ecosystem so to me it's not so much about starting with like hascal and simplifying it's more like starting with you know pure some sort of like arbitrarily large language that can do mutation side effects whatever and then saying okay let's take out mutation let's take out side effects let's take out this and that and then figure out what's the sort of essential core and then if we have to and we run into certain use cases where we're like this is really unergonomic we need to add something back in to make this use case work then we do that that's kind of how i look at it and i think that's pretty similar to how evan looks at it to with okay okay have you hit any of those on the back end that are new things that we like that were unergonomic that we wanted to add something this is a complexity that we just have to bring back in because it's not going to work oh i see so it's not backend specific but it is long taale of domain specific so one of the things that elm does is that it has so i'll contrast it to hasell because i think that's the easiest or or to rust i guess so in haskell and rust and also now in rock the way that you have two things be equal to one another is you have in has they call it a type class and russ they call it a trait and we call it an ability but basically you say here's what equals means for this particular type like i'm defining some sort of new type and in that type i'm saying equals semantically means this so whenever you use double equals on these things it's going to run this function on this particular type so that's quite useful if you're defining custom data structures like if i'm making a custom hashmap or custom tree or something like that i want to be able to have these in my tests and say like okay my test i want to assert that this thing equals that thing and in that world where i'm saying i want to be able to define what equality means in a in a sort of custom way i also want to be able to say well hash should also match up with equals and there's ways you can do this so i have a a package in elm called elm sorter experiment or elm sort experiment something like that where i basically just said okay well every time you want to do equals on one of these you know trees or whatever you have to pass in a compartive function that tells me how to compare its elements for for sorting purposes so sorting equality hashing all of these things are sort of in common and in elm it's like well okay we have a certain set of baseline data structures that where this is all well and defined defining your own custom data structures just does not come up that much in elm my expectation though is that when you have a lot more different domains that you're targeting it is going to come up more so there's this blog post from people in elixir who talked about sorry some a blog post by a company that was using elixir and i think it was maybe discord but they basically had a chat client with a huge number of channels in it and they talked about how they needed a custom sorted set data structure with really high performance characteristics for dealing with the situation where you want to keep the list of users sorted all the time but people are joining and leaving the channel or the chat all the time in real time and you just need something that's that's really dedicated to that that's an example of the type of thing that i think is really difficult to just satisfy by making the standard library bigger and bigger because depending on your use case you're going to run into all sorts of different variations of things like that so so we really wanted to have some way that people could make their own data structures and define what equality and sorting and hashing means on those but i explicitly did not want to go as far as like hasle or p script do where you have higher kinded types where in addition to saying like in hasool type classes you can say here's equals and here's hash code and here's sorting but also you can go a step further and say here is a monad and here is a monoid and here is a funter and and sort of classify things in that way depending on who you ask that's a great feature okay depending on who you ask they'll say traversible is great what about traversible but but but there there is definitely a lot of added complexity to the language there there's definitely a lot of downsides that i don't hear talked about as much as the upsides and i just didn't want to have that and rock as a language that's one of the things i would want to subtract if i were starting from a hasal perspective so so the design ended up basically being that you have equals and hash and we actually don't have sort yet inspect is about to land which is a way to customize when you're debugging something like debug printing it you can customize that too okay and so basically all these things are designed to address the fact that unlike elm we do have this sort of broader scope and i i anticipate that wanting to customize those those things is going to come up a lot more often than it does in n okay okay so i'm just i'm just trying to think how this is going to play out when you've got several platforms working for roughly similar domains like from what you're saying i can foresee a future where you have a platform that's specific to writing postgress triggers totally yeah right and how is how is someone going to write that platform what do they write do they write it in rock great question so the short answer is that every platform has two pieces to it one part is the public facing rock api and if you're a rock application author that's the only part that you see is like oh here's here are the rock things that i can use the primitives the other part of it is the low-level implementation and we call that the host and that's always written in a language that's not rock so every platform has the rock part and the non-rock lower level part that sort of implements all the primitives like at a a really low level right so you can use whatever language you want for that but it needs to basically be something that's like compatible with c so you could use c itself or c++ or rust or basically any language that does c interop actually right now at work we're using we have this big no js back backend vendor v ndr that's the company i work for now and it's this very large no js backend and we're introducing rock to that by basically using no. jssc interop so we have this sort of custom platform that's just designed to be like use rock on node.js and the idea is essentially that any anything that can call a c function can call a rock function so that includes no. js using its c interop and so i have it set up there's actually a a thing we've published called a rock es build that just if you're using es build with node you can just include this and then you can now call rock functions from node and that's basically the way that it works is the platform's job in that case is to translate it's it's a little bit of c code that translates between here are your rock types in memory and let's just get those and translate those into node types and then back the other way such that nodejs you call this rock function passing a node string which is actually totally different in memory from a rock string right and then that gets translated by the little platform glue into a rock string and then the rock function runs and gives back an answer and you know whatever rock data structures those get translated back into node and off you go and so you can just do that in the middle of your you know you literally import a ro file now you could just call rock functions from node that makes me wonder what i thought i had handle on what rock was but now i feel like the ground has been pulled out from under me if you've got like rust and javascript under the hood and rock user space functions above what's the layer that's actually rock so essentially i mean the the part that's rock is or the part that's 100% rock is the application code so or or any libraries that it depends on so for example my co-workers at work all they have written is rock code none of them have done any of the c stuff i'm the only one at work doing that that sort of glue layer what they see is basically like okay here is a way that i can call a rock function from my c code so for example they'll just say all right we have this part of our codebase it's it's doing these calculations i want to rewrite that in rock they'll introduce a newro file we have our build set up already so that you know when you as soon as you import that it knows what to do and it'll compile that and set up the interupt behind the scenes so they write the rock file import it in their typescript code on node and then they just call it and it just gives back an answer and and it's almost as if you were calling a typescript function from their perspective the only difference is instead of importing a ts file they're importing a rock file okay so this is an example where you know unlike like basic cli and basic web server which are very much like the platform's job is to provide this sort of very generic experience for like you know you want to build a basic web server completely in rock from from the ground up here the the platform is serving a different purpose which is to be sort of a binding layer where rock is almost like this this scripting language or like this this new thing that you're introducing to a very large existing code base so the the platform scope in this case is like the entire existing vendor back end and then you know but but the same strategy still works so the important part is that the end user experience when they're writing the rock code is just like yeah i don't know everything you know that's available to me just works here like i i can any pr that's here will work fine we can also introduce new primitives this is not something you would normally do in in a sort of general purpose platform but in a bespoke platform like this where you're just trying to introduce a new language to an existing codebase we can do stuff like i'm going to introduce a new platform primitive that's like make this very specific request to our database which is all wired into node and all that stuff but on the rock side you're like i don't know it's just a function i can call and it's going to do the database thing so i don't care how it's implemented just like how in basic cli i don't care how the function to like read an environment variables implemented that's all behind the scenes details all i care about is i have this nice rock api that says here's how to use these things and given these primitives they all fit nicely together and work really well and so our strategy in this case is we're trying to incrementally transition the back end from from being all node.js to being someday all rock is is sort of the ultimate goal but you could also imagine somebody using a very similar thing in like a game where you have like a large c++ or rust or whatever codebase and you're like you know there's this one part of my code where it's not as performance critical and i just want some nice language that i can just work quickly in that's memory safe etc you can just do that and rock and have the rest of your whole code base be you know the game and maybe you don't ever intention intend to transition the whole thing to rock but again you can provide all of your game primitives to rock all these you know lowlevel draw this draw that whatever operations and rock can just sort of be like lua just a little bit of an add-on actually the original joke name for for rock was ty pure functional lua that was the joke name before it got the name rock because you do get a lot of games where like the main engine is in c+ plus but then the like the scripting for the mpcs that will be in something like famously i me i yeah i i don't personally have any game dev experience i know there's a there's sort of a spectrum is is what i've heard some people will say i don't want to use any scripting language and then some people will say i want to have a game engine and then i do everything in c or you swift or whatever and then some people are somewhere in between well they'll do like a mix of like a lot of c++ code but then some bits are are lua you know like i said not my world but the the point is that rocket has turned out to be very well suited to being embedded like that okay now now i'm starting to wonder if i could do something like build a rock platform that was specific to say kafka sure i don't see why not i mean i don't know i i've never used kafka directly so i don't know like i know if there's a query language or something like that but yeah i mean anything where so actually we have examples in in the rock repository of people doing really basic like hello world level stuff but like calling a rock function from scala and java and cotlin and ruby and python like basically any language that has c and rock which is kind of like all of them you can call rock functions from that so you in a way you're seeing rock as the sort of universal domain specific language that's a yeah i hadn't thought of it that way but that's that's a pretty good way to put it yeah okay you can have that for the marketing if you like yeah i mean the tagline is fast friendly functional language which are sort of like the values that you know like the main overarching design goals that i think are are powering the language but in terms of use cases i think that's a pretty good way to think about it yeah okay what are you writing rock the compiler itself in is it in c it's in rust it's in rust okay yeah so i when i started out i basically was i hadn't really done a significant amount of low-level programming since like college and then before that middle school so i really and i was never really very good at it i always like get seg fults and stuff and so i remember thinking starting a new codebase from scratch i really really want it to end up being as fast as possible so i want to use one of these languages that really doesn't put a a ceiling on how fast this can be it's it's like maximum performance i'm not really sacrificing anything because of i spend like 10 years of my life at least you know working on this thing i don't want to end up saying like oh and now if you really want to be faster you got to rewrite it in rust or whatever so i didn't want to i didn't want to have that happen so even though i didn't really know much rust at that point i i had like very li limited amount of experience it was at the intersection of having this promise of you won't get segals in this language you know as long as you can get it to compile you you'll be safe from that and also the performance ceiling is essentially unlimited i think if i were starting it over today i would have considered a lot of alternative languages i don't know if you know russ would have been like the best choice like zig is is the one that would be really tempting for me because in comparison to rust zig is a much much simpler language and certainly the memory management part which now that i've like seen how the compiler is shaken out it turns out that the memory management is actually very simple in terms of like what we need because basically we don't want to do a bunch of like allocations and deallocations that's inefficient we really just want to say like all right we're starting up do a bunch of allocations for you know parsing and canonicalization and typechecking all that stuff and then once you finished everything and you've compiled the output artifact that was all garbage throw it all away so the fact that rust provides all of these like this detailed tracking for all these lifetimes our lifetimes are actually really simple so with that in mind i don't know that i would have chosen to sign up for all of the complexity and especially long compile times which really bother me increasingly now that we have this big rust code base like 300,000 lines but you know at any rate that's that's you know at this point it's sort of like rust is what we're going with you know we're sticking with so it's it's kind of a mood point but yeah been overall happy with rust though i mean it definitely delivered on that promise of like you know we don't get seg fults all the time in the compiler we still do sometimes because we are generating machine code like there's no rock doesn't compile to a vm it's just like straight to b u bit code like the the actual machine code so because of that we we sometimes generate code that has seg fals because it doesn't have a borrow checker it's just cpu instructions but but overall yeah like i mean rust i think deserves its reputation for like memory stability and safety okay this is something i wanted to ask you about because rock you in a in rock you're essentially writing a compiler that compiles to two different targets right web assembly and assembly assembly well more than two so so because we're so we have four different compiler backends which is to say things that like output the final artifact so web assembly is one another one is x86 assembly or x64 assembly another one is arm assembly sorry i'm saying assembly i mean machine code web assembly is you know whatever binary same thing with those and then the the last one is llvm which is in its own category because a it's different than all those other ones and b lm itself can actually compile to web assembly and to arm and and x64 the problem is that it's quite slow so we use lvm to like when you do an optimize build you passed das das optimize and now you're using lvm instead of one of those other ones and basically what that means is your compiled program will run faster but it's going to take longer to compile right so even if you tell l you have to do zero optimizations as it turns out it's still quite slow to generate that code to the point where what we were seeing was on like non-trivial rock projects almost all of the time in compilation would be waiting for llvm and also for linking which we're doing our own linking as well but basically it was like all of the parsing name resolution type checking monomorph isation all of that was just kind of a drop in the bucket compared to waiting for llvm and then waiting for linking so we yeah we ended up just doing our own like go straight to machine code those are partially in use right now right now only the reppel is using all of those we haven't quite integrated it into the like full build system but that's kind of like one last step that we got to get over to be able to use those dev backends as we call them like the development backends but yes there there's a lot of that going on in the compiler okay is it it's just i'm sort of stepping back and thinking of the scope of this and you don't have a background in writing programming languages right that's true this is the only one i've well i i i can't say that i've written the whole thing i mean there i'm not even the number one committer anymore i'm number two now someone someone's passed me by fulker shout out to foger he's awesome but i mean we have a bunch of people and and they're all sort of have different areas of expertise like things that they're like the best at and i'm i'm really not the best i don't think at any one thing in the compiler anymore like when i started it was just me like all the commits but now like for any if you look at any point in the compiler i can say well brian carol's the web assembly guy like he he's your man if you want to know you know how the web assembly part of things works and if you want to know about the linking talk to brendan and if you want to know about type checking especially when it comes to abilities talk to aas and if you want to talk about you know monomorph isation talk to fulker and you know it's it's really become a lot more of a sort of the the more time goes on the more i'm more time i'm spending on like project management and like thinking about how all the feces fit together and like who's working on what and like like design stuff and less and less like i'm i'm sort of like driving the project forward through code because there's other people who are doing those things like you know better than i can i actually ended up spending a lot of time most recently on coding the website because not not that like we didn't have people who are capable of programming a website but more because i i'm just very particular about like how i wanted things to be communicated and so forth so and and you know how how things to be presented so a a common question i'm asking myself now is what can i spend my time on that is sort of like irreplaceable to me where i'm like it's something that i you know even if i could delegate it i really don't want to because i feel very protective of that particular thing and certainly one of the things is like how are we communicating about the language that's the thing that's very important to me that i i really want to control whereas with something like type checking or or monomorph isation or code generation those are very very important but i feel a lot more comfortable like explaining to someone else what the goals are and then just sort of saying okay you got this so yeah it's it's it's an interesting how how the project has evolved over time in that way ah interesting i've got to ask you about that but i have to briefly since you brought it up ask you what's rock's website written in oh a combination of things so the way i think about the website is at the end of the day i really want the final compiled artifact to have certain characteristics like i i it's really important to me that okay so really simple example of this back when when brian carroll first got involved in rock we didn't have any web assembly support at all like basically when people would ask like hey does rock target web assembly and my answer would always be technically llvm can admit that but we haven't really tried brian completely changed all that so he wrote the whole like dedicated web assembly backend without lm at all just going straight to the binary he just just completely overhauled rock's ability to compile web assembly and now actually web assembly is the most complete backend that we have now thanks to him so shout out to brian but basically he was asking you know like like why is it not more prioritized and i said well honestly like we just don't have people who have like use cases in mind for it i mean the main thing that i'm excited about for rock targeting web assembly is i would love to have a repple on the homepage that's running completely in the browser so that if we ever get on the front page of hacker news it won't flood our tiny server and take it down and then people are trying to come and try out the reppel and they can't because they're getting errors because our server is hosed okay and u i mean very recently that literally came up because we have a completely static website we have no like our there is no rock server backing any of this stuff on the website it's all on netlify and just static assets including the web repple which brian got down to six megabytes because which is you know not not nothing but also it's it's the whole rock compiler like when you use that reppel on the homepage every time you enter something it's compiling web assembly on the fly it's like compiling monomorph ising typechecking generating web assembly and then actually sending that web assembly back to javascript so the javascript can evaluate it because that's besides no dom access another thing that web assembly can't do is you web assembly is also not allowed in the browser to run more web assembly so the web assembly in the rebel has to go say hey javascript here's some new web assembly that run the javascript says cool i'll run it then tell the old web assembly what the answer was so there's a lot of intricate machinery going on in that little like you know rectangle on the we page yeah but so that's the type of thing where it's really important to me that that runs really well like it it needs to be like the and i even spent time like we have a list of sponsors across the bottom like corporate sponsor which if anyone is interested in sponsoring rock by the way we happily accept donations on on github and and liber not sure how to pronounce that and also corporate sponsors just dm me on zulip if you're interested in that but like they all have logos that thankfully are are svgs so i actually inlined all those logos into the html so they wouldn't need extra network requests and also i used classes for the white versus black parts of them so that their their letters are still visible in light mode versus dark mode ah so stuff like that is really important to me how all of that is generated is actually not that important to me so i actually used to just use plain html and then at some point someone implemented a little rock dsl for for generating static html that looks a lot like lm html so it's very familiar to all of us and started using that just as kind of a way to get like okay we'll have a common you know header bar across all of these just like basic code reuse stuff and so now a lot of it is written in that and then also it does some markdown parsing but at the end of the day i'm you know if we were doing a really complicated web app of course i would reach for elm but this is just a static site it's not like we we we need like elm architecture for like complicated state management it's like we have a tiny sprinkling of javascript for like a couple of little interactive things but okay but it's really like my goal for the website is really that it's like it's largely static and actually one of the things that i try to do is i try to make it so each page to the extent possible works without javascript so the homepage actually if you disable javascript because i there was a time in my life when i tried browsing the web that way and eventually i kind of gave up but it was really nice how many pages loaded instantly so if you go to the homepage and you turn off javascript what you'll see is everything works except for the reppel which is just hidden we just because that that can't work without javascript but everything else works including at the bottom we have a large code sample that's like interactive you can click on things to show like an explanation of what that piece of code's doing i actually did all that using css so that you know if you if you're browsing with javascript turned off it it still feels like it works so anyway that's that's what's important to me is like the the final end user experience not so much like you know how are we're building it okay i can see i can see why you're holding on to the design of the language rather than the implementation then i have to ask so if someone's curious to play around with rock what's the status of rock at the moment so you definitely can so we're we're before our first numbered release like it's all nightly releases right now okay so there actually isn't that much stuff changing right now if you go to the i think it's the community link on the web page we kind of have a little link to some sort of upcoming plans of things that are like in the works there's a there's a known coming breaking syntax change around how imports work which is motivated by a really really cool feature that i'm very excited about but that's going to take so hopefully we'll ship that in 2024 we'll see but basically it's it's from my perspective like i don't see how do i put this okay so there's there's a lot of different trade-offs around introducing like numbered releases to a language and one of them is a communication thing like as soon as you have a version number people start having different expectations i remember seeing a really strange in retrospect comment but at the time i was kind like yeah i kind of know what they mean i think it was on hacker news where someone basically said you know i have certain expectations of an od. 2 release of a language and i remember thinking like you know i i know what he means like it's it's not it's not like i have no expectations but at the same time it's kind of weird it's it's like clearly what someone's trying to communicate with a zero dot you know release of a language is like this is unfinished expect things to not be you know totally polished and that that there's going to be breaking changes yeah so i kind of like partly i'm thinking of it as like well maybe no version number is the new .1 you know that's that's how you really communicate that like look you're you're dealing with something that's unfinished and like still has a ways to go so the reason that we decided to sort of redo the website and make it like a real website because before we kind of had this placeholder that just had a bunch of text about like explaining things the motivation there was to just sort of communicate like hey this is a real thing you can try now but everywhere you can like install it or in the tutorial and stuff we try to take care to to note that like hey this is an unfinished language it's definitely like you're going to hit compiler bugs you're going to hit you know things that are just not there yet so i would definitely encourage people to try it out i would say if you want to try and use it at work just know that you're you're entering you know risky territory it's it's it's not going to be like totally smooth sailing because there are things that are unfinished that are unimplemented yet that there's going to be compiler bugs compiler crashes so you know we're comfortable using it at work because i'm sort of there to to make sure that you know like things can't go too wrong but but definitely i think if you want to start using rock on a more serious project i would strongly recommend like getting involved in like a zulip chat and like telling people like hey here's what i'm planning on doing and then people can tell you like well here's what to watch out for here's the things that you know the sharp edges you might run into and you know we can give you some support with that whereas like a year ago i probably would have just said don't do that like don't try don't attempt a serious project at rock because it's just not it's not going to go well now it's more like well as long as you're okay with the sort of bleeding edge experience and you you're you're comfortable running into some problems and having to work around them you can totally do that now and it's sort of crossed over that threshold where i went from sort of recommending against it to being like well let me give you a bunch of caveats and if you're okay with those caveats then go for it there's a lot of things to really like about the language already today and obviously we're working towards a future in which i can just say it's great go try it but we're not there yet right it's growing up it's gr not that level and away from production what about the other end of the spectrum if you want to learn rock is there a good way to learn it at the moment or are you assuming someone's coming in with a certain amount of knowledge oh sure i mean so there's a tutorial that just kind of explains like here's how to bake a command light app and rock we should probably also make one of those for other platforms like the web server i i i've sort of toyed around with the idea of maybe expanding the tutorial to start you off building on the command line platform and then because when i first wrote the tutorial that was the only one we had and then sort of maybe transition towards the end to being like okay and now let's let's build a web server and then you can use the command line to talk to your web server you just built i think that'd be kind of cool but we'll see if i actually do it but at any rate that's the tutorial i think is plenty enough to get going on application development however if you want to learn how to do platform development basically the procedure for that right now is just kind of like ask people because there there isn't a tutorial for that and part of the reason there isn't a tutorial for that is that that's an area that's like sort of heavily under construction and the tutorial would get outdated pretty quickly if we did have one right so yeah hopefully that will change also over the next year but we'll see do okay so maybe i'll make this the last question but do you foresee a future where there's like a package manager where you download libraries and another package manager where you download platforms or how's that going to work oh so i think it be all one package manager so i mentioned earlier that there's a syntax change for imports part of the motivation for that is there was a long-standing design question of exactly how do you want to be able to share common packages across platforms so a really easy example of this is error reporting so i i used my previous job we used bugs snag for error reporting at this job we use sentry let's say that someone wants to publish a sentry or bug snack package that says here's how to like you know report an error or you know the report let log something that that's happened well you can imagine wanting to use that on like a web server platform also on a cli platform maybe in your native desktop app platform mobile app whatever all of these things you know sort of raise the question of well if they all have their own different set of io primitives and this is something that wants to do io how do you write something that's of platform agnostic while still that does io operations yeah so we came with a design that actually has oh it's it's awesome i'm really really excited about it if you want we can get into it but but basically the the upshot of it is that what what will end up happening is that you write that platform and essentially it declares in a way that's has a turns out to have a bunch of side benefits like here's what i need in order to be able to run me i need some way to do http requests which means i need a function that's it's like given a request run this task and then it's going to give back a response if you can provide that primitive for me if you have that available somehow then you can use this package if you don't have that then i'm sorry i don't i don't work so in your hypothetical database extension platform where you just don't have you know that function available then you just can't use this package at compile time like you it's not like you know you run and you get an error it's like you just cannot depend on that you you'll get a build error so what's cool about that is that it's also flexible so even if like the command line app has a slightly different way of doing http than the web server and a slightly different way than the native desktop or the mobile whatever it doesn't matter because at the end of the day as long as you can provide that function which does that thing then bug snag is cool and you can use it and just you know everything just works so that's sort of where the design ended up so now you can have completely platform agnostic packages even if they do i/o obviously if they don't do io it's like okay you only depend on the standard library you know go for it no problem and who ends up writing that kind of bridge if you've got two platforms with the same capability but different apis who bridges them into the bug stack oh i mean you don't even there's no bridge necessary really so basically the the design of the the imports feature that makes this work nicely is such that as soon as you import bug snag it just it sort of gets wired up if that makes sense it just looks like in basically if i'm running the bug snag module i can declare at the top of module i need access to this function that has this type and if i don't have access to it then give an error if i do have access to it then it's like this is how i do htdp so i just call it and i don't know what the implementation of that function is going to be yet but i don't care because i'm just like look that's a dependency i have in order to import me you must provide this given that you provided this i'm going to call this in all my implementations and that's it okay but if you've got one platform that had two platforms with it get with a http api but one of them thinks that the url should be first and the method should be second and the other one thinks the method should be first and the url should be second yeah great question so the answer there is that culturally what we want to encourage is when you're dealing with operations like that we want to encourage platforms to do the lowest level thing possible so rather than saying i'm going to like bug snag saying i need an http that requires a url that's a string versus a url that's a list of bytes or whatever it's it's rather that you have something much more lowlevel than that that's like i i need something that has these exact like pieces to it and if someone wants to build an http request thing on top of that they totally can and maybe bug snag depends on that convenience wrapper that's more ergonomic and has like a get function and a and a post function whatever but what the platform should provide every platform should provide that wants to provide http is something that's super low level that's just like here you go this is like like the bare minimum it's all the information and you can actually have a package that defines what that is so you can have a package called like lowlevel http not sure exactly what the name for that should be yet we've talked about like lowlevel http http effects something like that that basically every platform can say okay cool i i will depend on this and just use it as a way to sort of specify what i'm providing to you and i'm going to conform to that and then now the ecosystem can say oh well as long as you know you're depending on http low level which is also what depend on then we know that these functions are going to sync up and then different people can say well i'm going to have a different rapper around this a different convenience rapper and it doesn't matter because as long as your library is using that sort of common denominator of like this is the lowest level idea of what an http request is then everybody can work with everybody else okay okay so you almost need it's reminding me of like the hardware abstraction layer you get in like embedded device programming maybe but like a much much simpler version of that i guess yeah remind me where we go to try out rock rock so r- l.org awesome i think it's time for us to go and do that richard fel thank you very much for joining us yeah thanks for having me thank you richard i will say if you do go and check out rock.org link in the show notes there's one extra thing in there i thought was worth highlighting for a bit of information design it's got a section in there called code samples with explanations and there's a block of rock codee that you can look at you kind of expect that for a language site right but if you click on any line in that block of code it gives you an explanation of what that line's doing and which language features it's trying to introduce you to and it's just a nice way of in a compact way going a bit deeper on what it's trying to explain to you and i mention that cuz if you're ever writing a site that has to explain itself through code i think that's worth looking at and filing away for for future projects before you file away or before you file me away which way around does this work before you file me in this episode away if you've enjoyed it please take a moment to like it rate it share it subscribe notify comment there are so many verbs you know which ones apply to your platform please the feedback is really helpful so do take a moment and i think that's all there is to say for this week so until next week i've been your host chris jenkins this has been developer voices with richard felman thank you for [music] listening