this week on developer voices we're talking about a new programming language and some new ideas for how programming languages should work by looking at the language unison now unison's been built specifically to tackle the problems of distributed computing and that might seem a bit niche but it's much more general than that because from a certain point of view when you think about it pretty much all computing is distributed these days we don't run code on one machine anymore there's the obvious kind of distributed computing when you push your code out to a cluster of servers and they're all working together on the same task but even in the more hand drum settings i write some code on my laptop i share it with the team they share it back with me we put it out to a ci server and test and prod and even though they're running different instances in different environments isn't that all distributed code across a distributed code base from a certain point of view i think it is and that's the cool thing about unison it's got some ideas for how we can unify all those different kinds of distributed code and make the experience better whether it's just you working on your laptop with a friend or a mega cluster with one simple trick as they say in the click bait i'm not going to give the game away but i'll give you a hint you know how git has changed the way we share source code and it did it with an immutable append only database that was cheap and easy to copy and just enough cryptography to verify that database as we pass it around and be absolutely sure that if i've got the same hash as you then we're working on the same source tree i've always thought git was a really smart approach it's worked really well in practice and yet we only apply it to source code can we take that idea further well let's find out i'm your host chris jenkins this is developer voices and today's voice is runar bjarnison [music] i'm joined today by runa bianerson bruno how you doing great how are you i'm very well i'm you're coming to us live from boston right that's right i'm just outside of boston but from icelandic roots yeah i'm originally i'm originally from akure iceland but i've come a long way since then you really have and you've got a career to match a long journey i think it's from what i gather it's been a long strange trip yeah do you have an academic background for starters i do not i went to a technical college in reykjavik but i dropped out because i got a job cataloging computer viruses and yet somehow the academic stuff has caught you up in a way yeah you know i've always been reader always sort of an auto didact taught myself how to program and on the sinclair spectrum zx oh which one did you have back in the day i had the zx 48k with zx plus a neighbor of mine had that and i have never been more envious of a human being before or since and i eventually got the next version the plus too but that's going back too far into history we need to get a bit more up to date more quickly so to ground this you in 2014 you released a book which you co-authored called functional programming in scala that's right and you clearly had got the functional programming in a statically typed language bug but that hadn't gone far enough so what did you do next what did i do next well you know i started with my co-author paul started developing the unison language so paul had been had actually been developing unison like after you know we sort of parted ways after the book and so he started unison and i was doing haskell programming for various clients and you know working in industry and and then you know he got a little bit along with this with his unison language and asked me to to join and form a company so we founded a company called unison computing and you know we're developing this language and that's been going for nearly 10 years the the language the language and the company so we started the company in 2018 okay and i think paul started working on it maybe 2016 something like that okay but the sort of genesis of it is that we we were actually working together so when we started writing the book we were working together writing scala you know purely functional scala and we actually developed a small language for the you know for our employer at the time and so we got this sort of language development bug from from there yeah hang on why why is a client asking you to write a language from scratch so this was for doing financial reports and like sort of doing quantitative analysis on you know portfolios and stuff like that and so it needed to be very expressive and they had this sort of visual language where you could like assemble uh sort of blocks of code together and kind of evolved into like a whole language it was pretty cool but that you didn't get the visual programming language bug you went back to text oh yeah yeah i think visual programming is kind of a dead end that it doesn't really allow for programs that are as expressive no and it doesn't manage complexity that well i think no that's true it doesn't hide the complexity very well no no and it makes it in rat's nest to debug anyway but you have some other ideas about how programming should work and this is i often think you can categorize languages as what they're like that's gone before what's brand new about them we should pay attention to yeah yeah can you categorize unison that way sure unison is a statically typed purely functional language similar to haskell in that sense but it is also a a sort of image based language similar to small talk that is the code base is not a collection of mutable text files it's an actual database that has your code in it so that's rather similar to to what languages like small talk to okay so that's how it's similar to other languages but the way it's different is that the code so all the code in your code base is referenced by hash so that's really the the main differentiator so every definition has a unique well you know most mostly unique and sort of eternal address which is the hash of its implementation and so you can unambiguously refer to any expression or type using its hash so you're doing this trick that git does but they do it like hash a file and store it under the hash you're doing it hash a function definition yes so it has your function definition we hash types we also hash name spaces you know that are collections of hashes right why what does that get you yeah why so the the main like for me the main benefit of this is that you know it allows you to unambiguously communicate code over time and space basically so over space meaning that you you can communicate over the network you know you can unambiguously communicate code over the network so whereas if you're developing a distributed system in a traditional language you will have to do something at like network boundaries for instance you'll take your data structures you'll serialize them to xml or json or some custom format and then send it to the other machine and then on the other side you have to have some code that deserializes that and and you know turns it into whatever data structures you you have you know or you can do like remote procedure calls but then the locations will have to agree on what the code is beforehand and like they can't get out of sync and stuff like that but in unison we can send the hash over the network and say hey here's the code i want to run that i want you to run it has this hash and if it has the hash then it just goes in and runs it but if it doesn't have the hash then we actually serialize the code you know we we capture the continuation of the program and we serialize that along with all of its dependencies up to some agreed upon depth and then the remote location continues to execute the program does that include the state of the computation it does so i can get halfway through a function suspend it and ship it over the network and have it run elsewhere yes that kind of okay so that remote kind of remote code execution raises a lot of questions the first one is security right so you so for for one thing you wouldn't want to you know accept this kind of call from the internet right yeah so you wouldn't want to to expose your your unison node to to the internet and say like oh hey send me whatever code you want so that's the first thing and the second thing is that since unison is you know strongly and statically typed and we have effect types so unison causes things abilities and so different locations have different abilities and when you when you know expose a location or like a unison node to like the rest of your your cloud then you specify what abilities it has and so you can't for instance send a computation that does some i o for instance unless the location specifies in its type that it is allowed to perform i o so i could i could build a service that allows you to send me code and i run it provided that code is only either pure functions or gets and sets on your personal key value database and it can't do anything security dangerous outside of that right that's interesting yeah because i remember saying because i saw you give a talk about unison at erdev a few years back which is a great conference in sweden and you said something else which relates to this you said languages have not caught up with the internet age which is a good quote related here and i want you to unpack it so well that was you know that was a few years ago but i think what i meant by that was that languages mostly talk about what one cpu process is doing so one os process you know it might have multiple threads and like doing lots of different things at the same time but it's mainly there's a single os thread and it's doing some stuff and if you want other os threads or other machines to do stuff you now need to break out of your programming language there usually aren't any facilities in the languages for talking about what other machines or other os processes are are doing so you need to you know get out protobufs or you know some other non-programming language in order to bridge that gap foreign i can think of at least one attempt to do that to believe to build a language from the ground up that doesn't believe it's running in one node and that would probably be erlang yeah how is your solution to this problem different well how is it different from erlang so i i don't know enough about erlang in order to talk about it intelligently but like i i you know i believe that the the the main difference is that we have this notion of hashing is that we can unambiguously talk about code like over the network so i think that you know if you are you know sending a message to on to an erlang location or node like you need to know something about what code it's executing like there's there there's going to be some kind of like version version mismatch or there's some impedance mismatch there that actually they probably can't bridge without this kind of unambiguous addressing because your system is gonna be able to say if i start this running on one node it can branch itself out to other nodes because it can deploy itself right it can take another machine run this and by the way if you need it i can send it to you yes and i can imagine the program just spreading out in its own self-managed rolling upgrade yeah that's right that's pretty cool and it's all done you know purely in the in the language so there's an ability called remote and it gives you this this ability to you know send the computation you basically have this notion of an abstract location and there's a function called i believe it's called fork at and you know it takes a like a lazy computations or like a captured continuation and the location and it'll send the code to that to that location and it's sending the data too right yeah it's sending the whole closure right so so everything that the that the computation depends on as well okay so it could it could not only map reduce data over a cluster it could map reduce the mapreduce computation as well yeah i mean it could yeah i i'm i have a benevolent an image of a benevolent virus in my head spreading itself across the cluster the benevolent virus is a good way of describing it we're calling it just in time deployment but yeah benevolent virus is a cool way of saying it depends on whether we want to sound safe or dramatic i guess right yeah it's a lot like just in time compilation you know where you know translating the program to machine code to run fast happens sort of just in time and you know in unison you know translating to network calls happens just in time okay this must okay this raises a couple of things let's go for the first one the the must raise the question are you planning some like global unison cluster where i just ship my code to that yes that's in fact the unison computing's flagship product is unison cloud where we basically provide you with a library that you just you know put in your in your code base and then you know you have an api key and when you call this library you are basically deploying your computation on our managed infrastructure and you can source as much you know a computational power as you as you require that feels like it's bridging the gap or eliminating the gap between something like you can get an ec2 machine on aws or you can get a laminator which is running a single function right it is it is like that but it i think it's for one it's a lot simpler and for another thing it's you're doing it in your language so it's really that you know you write your your code and then to run the program is to deploy it right it deploys itself on the manage infrastructure you don't have to write you know yaml files or like some kind of configuration you don't have to hire you know armies of devops peoples people to to like manage your clusters and and manage your ec2 instances and stuff like that so you know the the unison cloud is doing all that for you and okay all you have to do is just run your program and that deploys it so i've got i've got a hint of this from a talk i saw you give but you would you literally you load your code into like a reple and run it and it works and so then you say run it at boston compute dot unison yeah basically right so there there's a local interpreter for the for the remote ability so you know you can write your your program you know as a distributed thing you know using the remote ability and you can run it locally using the sort of local interpreter and there are other interpreters where you can like diagram your system so you can like see you know how it's like distributing itself over the network okay and that's all done locally but then there's the unison cloud interpreter which goes and actually deploys it on managed infrastructure in the cloud and you know it's live so how does that deal with i guess these are related things but how the other thing you need as well as deploying code for a remote managed service like that is you need persistence of data and you need migration of data yes how are you dealing with those things so that's you know that's early days so far so right now the things that you can do for instance is uh you can talk to s3 for instance right now okay and because you're unison you know unison cloud it's you know close to like wherever your s3 instances might be or your s3 objects might be but we're also developing a managed storage system so it's it's a typed storage it's basically just a unison library and then you can take any unison object and you can persist it in in the cloud and then you know you get basically typed access to it back and there are you know often there are problems with these kinds of things where like yo i can persist any object and then serialize it back but if you try to do this with you know i don't know like i've done this in languages like java where you know you have have a like a library that can persist any object to to disk or to a database yeah then you run into the issue that as the code evolves like the data types change you know and then you end up with a version mismatch and then like it's very difficult to get like old versions of stuff like out of storage yeah but unison doesn't have this problem because you can you know the the the storage knows what type the object is and so the the hash of the type is available and you can load that type and so you'll always have an object of the type that has that hash and you know you can recover the code for that for that type as well okay so even if you update the definition of the type you can still deserialize the old types because they're kind of stored in git ishness right that's the one sort of merkle tree yeah but then you've got the problem that your new code you've updated expects the new hash of the data type yeah but then you'll just get an ordinary type error and so all you have to do is basically convert the the data that you've restored to the new type and then you can store it again or do whatever but it's it's all like still very much in your language and you get the the benefit of like normal things like type errors rather than like a runtime error that says like oh version mismatch all right yeah so you're you're pushing the kind of data migration problem to compile time yes basically that's okay i like that because it's gonna that kind of area is going to come up and you have to deal with it anyway but so you might as well find out sooner and with better error messages right and then i mean you can migrate things programmatically obviously you can write a program that says like grab all this stuff and like convert it to the new version and serialize it again you know you can do all these sort of normal things that you would otherwise do you'll end up writing functions which take use dot hash one and return to use a dot hashtag that kind of thing right yeah yeah kind of thing and you can do that at compile time and it will check it for you and then just just work right that's an interesting promise for long-running computation long-running services so i best asked you this question what state is unison in is it alpha beta research production i would say sort of late beta stage at this at this point okay [music] so that's you know i wouldn't say anyone is using unison for like mission critical stuff in production at this moment and and you probably shouldn't but you know it's it's already a pretty capable language and has good library support already and you know we're constantly new libraries being developed as an active and friendly community and and you know there are all these things that are sort of converging this year which is you know we're we're getting unison cloud is coming out of out of beta it's so it's in sort of a private beta at the moment okay so you have to like get on a wait list and stuff but so we're bringing it out of beta this year we're adding this storage layer and unison is also getting native compilation like very soon so you will be able to you know run your code in the cloud very fast okay what's the current state of it so currently it is an interpreted language so it's a bytecode interpreter okay so it sort of compiles to like a unison bytecode and then there's an interpreter written in haskell that that interprets that that by code and so we have a just-in-time compiler that's being developed by the community and and by unison computing and that's all being developed in the open and so it compiles the scheme now and scheme compiles a very fast machine code right what's the other language that's idris doesn't that use scheme to compose i believe yes i believe so i believe address is compiles to chess game yeah i wonder what it is about scheme that makes it a nice compilation target i don't know i mean it's it's very comprehensible for one thing it's you know it's got good performance like the compiler produces really good machine code and we found that the the code that's generated by the the new justin time compiler is like between 400 and 700 times faster so that's pretty good that's cool and that's coming out this year yeah hopefully okay so there are a couple of so we've talked about like this get like thing i could come back to get as my reference point for hash it and ship it sure the other thing which you've touched on a bit we should go deeper in is is abilities we had louis pillfold the author of gleam on a few weeks ago and he said he really wanted to bring effects managed effects to the language but couldn't find a good way to do it how can i found a good way to do it what are managed effects for the listeners and have you found a good way to make it usable yeah i was so i don't i don't know exactly what he means by manage effect but i imagine that he means that the effects are attract in the type is it a type language yeah yeah i think he's going in the haskell type side effects direction okay plus plus all right perfect but yeah so you know there are a number of different ways that you can do this like manage effects in the in the type system and so the way that haskell has gone is to do this with monads so basically you just have a data type that's like parameterized and the data type you know represents like what kind of effects you can do like for instance you know there's an i o famously there's an i o data type yeah so instead of just having a string like you read a line from the from the console and you don't get a string you get an i o string yeah so you get this data type called io which has a parameter which is string so it's an i o sort of containing a string eventually and you know that's that's a perfectly cromulent way of managing effects in the language but it you know it has certain drawbacks for one thing monads are they have a syntactic overhead in the language so programs that that are pure you know that don't use any effects they are syntactically different from programs that do use monets and so you have this sort of two programming modes that yeah one of the first things you have to learn when you're learning haskell is how to flip between those two modes yeah yeah and then composing monets is you know as sort of an evergreen topic yes so one of the things that people do is like you know monet transformers so you get a you know you want to compose monet's fng and so you need a you know an ft mona transformer which is parameterized by another monet g and that compile you know combines them into the sort of composite monet where you want to do like oh say you know state and io for instance yeah and so then you get this like state t of i o or whatever yeah you can end up with like a program that has the side effect of accessing the database and doing logging is different to a program that has a side effect of doing logging and accessing a database yeah that's true logically they should just have those two side effects yes so what we're what we're doing is a little bit different so we're taking the approach of algebraic effects so we're calling these abilities which is a term that we got from a paper called which is just kind of awesome paper ever that's about a language called frank which is by conor mcbride i believe yeah i've seen color in action he's a great great thinker awesome yeah but yeah so you know we got got these these ideas from from there and so algebraic effects are a little bit different in that you you're able to combine effects sort of side by side so instead of you know pressing them together using like a transformer you have this just sort of set of abilities on your on your functions so a function will be you know it will require the abilities to do i o and state for instance and that's just like basically a set on the function arrow and so so combining these things this is sort of trivial you know if you invoke an i o thing that gets added to the sets if you invoke a thing that accesses the database you get that added to the set so when you're looking at the type signature you see the sum total of all the effects that particular function has demanded in order to run that's right yeah and then presumably you write some code that dispatches each of those effects so you see in your set it says i need logging so you wrap that function call in with standard out logging right exactly that takes logging out to the set and eventually you get down to just a computation yeah that's exactly how it works right and you can write you know custom handlers for these things unison has a keyword called handle where you can supply a handler for any any effect and you basically adjust pattern match on the constructors of the data type that represents the ability and also importantly i think it doesn't have any syntactic overhead or it has very minimal syntactic overhead so a a program that uses abilities looks a lot like an imperative program that doesn't use abilities so it's there's no sort of monadic syntax and we're not switching between do and bind syntax and regular pure function syntax right so you're always just writing sort of like a block and so you know you can just like write basically like a let block and you can do effects there and the whole block will take on the type of having or requiring those abilities that sounds a lot like the upside of haskell you know tracked effects tracked in the type system i think is a really good idea but it's hard to teach and it's a bit of a learning curve and it sounds like you may have solved that second problem if you're to be believed i don't know if we've solved it but i think it makes it a little bit easier to to think about at least for for people who are you know not you know first in monads you can still have monets in unison and you can have mona transformers and all that stuff like that's perfectly possible but but as you know it's not directly encouraged by like the standard library and things like that another thing is that there are of course downsides to this so one of the downsides is that algebraic effects at least in the form that they exist in in unison currently are not as expressive as monads and monad transformers and so you can't necessarily combine things in ways that you would otherwise do in in haskell can you give me an example can i give you an example like so for example in in in haskell you might be able to do sort of like a higher order effects where you you know you app you might abstract over monads that have a particular capability so you you know what's an example of this like mo there's something like monet state for instance so that's like a class that represents all the monads that could possibly be interpreted to you know to track some estate yeah and and so that's very expressive to be able to like abstract over all effect types that track state but but unison's type system users ability system doesn't allow you to talk about you know effects that like abstract over the capabilities of other effects at this moment but that may come later okay i think that's probably for the majority of programmers this is already astronauty enough for that to be okay yeah i mean it's a trade-off you know for for a lot of programmers you know seeing a library that is very abstract you know while using it might be pretty straightforward like once you get into it you know like the the compiler will take care of like mapping your concrete data types to their abstract types but just seeing a library that is very abstract you may struggle to understand like how you're supposed to actually use it yeah yeah that all depends on like compiler support like there are functions in haskell they're terribly useful but like have so many type variables i can't keep track right and the more type variables you have the worse the error messages get that is also true if you've done anything to solve that problem well you know one of the ways we solve that problem is is the you know you're encouraged to write things in a very direct style and so you know you don't end up necessarily with the sort of type astronauty things you know i i can think of you know a couple of libraries for haskell for instance where people really struggle with error messages and one of them is like lens where you know it's super useful i love the lens library and i use it all the time but often error messages are really abstract and you have to be sort of well-versed in how to use lens in order to understand it yeah and another one is servant which allows you to you know basically describe an http server as a type and so you get this sort of like typed communication over http which is super awesome and it basically just like generates all of the boilerplate for you but the error messages it gives you are just like you know it might be 20 pages long or something if you you know get you know like one type variable wrong and it can be really difficult to to decipher a type that a type that describes an entire http server yeah and so we're taking a lot of sort of we're taking a lot of cues from languages like python for instance like the the culture in in python in the python community generally is that you know you write libraries that work in the obvious way and people you know you sit down with a python library and you can sort of generally you can kind of assume that it's going to be written in a kind of obvious way that that how you're supposed to use this library is going to be straightforward and it's going to write it in a very direct style that's easier said than done though i mean yeah obvious yeah that's true so perhaps you should say who the who's your target audience for unison are you expecting haskell programmers to switch to it eventually or is it python programmers who's going to be adopting unison if you get your dream world well in the dream world it's basically everyone who wants to develop distributed systems which is really everybody because there aren't very many systems these days that aren't distributed you know even things like you know systems that have a front end and a back end you know like the communication between the browser and and your your back end if you're writing like a like a web application that's a distributed system and one of the things that we hope to develop in the future is you know a javascript compiler for for unison so yeah you should be able to write a distributed system that runs in your browser and deploys itself to the cloud yeah will we be getting a future in which the browser like checks out the hashes of the functions that have changed since the last time you checked the website yeah that would be that would be amazing oh that would that reminds me of something i i also remember you saying in your talk way back when which i'll let you explain it perfect compilation perfect incremental compilation oh yes that's a big one yeah so perfect incremental compilation so in unison your your code base is sort of always live so you it lives in a database and it's always compiled so let me contrast that with so let's do the genesis and differentia thing so contrasting that with the the way things work in most programming languages like let's take haskell for instance okay so in high school you you write a bunch of text files you know you proceed to mutate those text files and then you run the compiler and the compiler generates the code and then if you've done something wrong you get you know a long list of error messages and you've got to go mutate the text file some more and then run the compiler and then whenever you change something you gotta like run the compiler and like build everything okay so the way that unison works is that whenever you write like a definition or a type or something it gets compiled basically immediately you know you submit it to the unison code base manager and you can add it to your code base right there and then and it lives there in a compiled state and then when you write some more code it you know compiles that code and then you can add that to your code base and so it's very sort of incremental and your code base is never in a state where it's like broken like you can never you know mutate your your code base in such a way that it is that it doesn't compile all right right okay and you've also got like you're you've got if you've got like a large old code base where the majority of code there you don't actually touch yeah that never needs recompiling that's right yeah what if you get a new employee come along and they let's exaggerate and say we've got like google or facebook size mono reaper and they want to check that out and start working do they get everyone else's pre-compiled shared code base for free yes they do yep so the way that the unison code base manager works is that so everything is stored in its sort of compiled state and then you you can push that to you know other locations and and the the the one that we provide is called the unison share so it's sort of like our version of github in a sense and so you you push your your code to to share and then your the other developers that you're working with will pull that and what they're pulling isn't the the text of the program they're pulling the compiled version down and then they can use the codebase manager to view the source code or edit the source code but the source code is not stored anywhere okay so how does that work for like if you and i have two functionally identical functions but i've put comments in mind okay so that really depends on how you've added comments in it so so there's one kind of comment that's completely ignored so then it just gets thrown away when you like compile your your function and and if you delete the source code it's gone the comment is gone and it'll never come back it's sort of like a note to self another way you can write comments is to you basically just put strings in line in the program you know and you can you know there's a little function called ignore which will allow just tells the program to ignore this and that will change the hash of the program and so you know if you if you have identical functions that have like different comments they do get treated as as different different functions so we we've toyed with the idea of adding a third kind of comment which is sort of like a comment that lives in the compiled form but doesn't contribute to the hash but that has a downside that if you ever want to change the comment you would have to like basically delete that hash from your code base and add it back with the with the updated comment that's nasty yeah yeah hash the metadata separately yeah that's that's another thing you know we could do is to basically put and eunice unison the code base format has this facility for metadata now we include things like who wrote this and what's the license okay and stuff like that so every definition has you know some metadata hanging on it like author and license and maybe whether or not it's a test where's the documentation things like that could you theoretically then say i want to make sure that in production i'm not running any proprietary code yes you can and you can computationally do that you can ask you can basically write a program that takes a unison expression and you know at least data theoretically you could check the license yeah off the tree and ask it yeah or can i make sure that none of my test code makes into production yeah yeah yeah that's pretty cool okay one more thing on on that then so you're saying i write a function it gets hashed and the compiled version gets shipped over to the central repository someone else checks it out they can't get my syntactic sugar so there must be some official code formatting for unison yeah so unison will format the source code so you know there's a it currently has one surface syntax but theoretically there could be many we've toyed with the idea of having like a lisp syntax for for unison but my colleagues would never know your colleagues will just see they might see like the haskell like syntax that it currently has but yeah the the source code is is thrown away so you're never sort of like faffing about with formatting or whatever you just like write your code submit it and you can just trust that it'll look nice when it gets rendered or you know if it doesn't look nice at least it will look the way the unison code is supposed to look right yeah you have to agree with the one true way of formatting code but yeah yeah i like that too i don't like to have to think about you know formatting my my code that's just like not part of the job yeah yeah i i'd rather the entire team agreed on one code formatting and we all got it for free right yeah rather than debating and hand crafting to fit to match the blessed guide right i mean we have yeah you know unison is mostly written in haskell and so we have in our haskell code base you know there's there's this sort of blessed format which is which is generated by ormalu and and so you know we have well have these like commit triggers and whatever so that whenever you submit new haskell code it all gets formatted in the approved way and whatever yeah but even that can be contentious like oh maybe you have different versions of the formatter or you know maybe you don't like the way this is and so you kind of want to tweak it and so you may have to like form a committee about like oh do we want to tweak this parameter here so so even that like leads to bike setting but in unison that is just like completely out the window there is no tweaking the formatting at all you just you get what the what the code base manager you know it prints out and that's it but in theory you could have like you could have your preferred formatting that no one ever needed to worry about that's true and in theory you could do that because i've worked on teams where every single person just wanted the unified formatting except one guy who would absolutely use that's actually that's actually a good point you know you could we could introduce facilities so that you could tweak the formatting for for like just your instance of of the codebase manager so locally you're developing in you know beautiful you know some code that is exactly the way you want it but then once you submit it to the code base everybody else sees it the way they want it but then you see their code the way you want it as well yeah philosophically this is very it seems simple but very different that we're we're still dealing with text files but we're not really text files are just a projection of what we're really dealing with yeah yeah that's right i think that code as text is is really just a user interface onto like what you're actually doing it's a really good user interface like it's very expressive highly flexible you know we've toyed with things like structured editors and so where you're like directly editing the tree and like you can't get compile errors and stuff like that and i think that ideally that would be awesome like but the the user experience of it i've never found it to be as good as just writing text yeah yeah i tend to agree so i mean that sounds like something maybe for the next version or a few versions down the line yeah a few versions down the line maybe we'll have a structured editor yeah and custom formatters yeah i can believe but where are we today if i go and if i go and check out unison what kind of experience can i expect to have what kind of libraries am i going to wish were there but aren't that's a good question what kind of libraries would you wish they were but aren't well so when you when you install unison you know if you're if you have like brew you just say like brew install you know some lang or use a language and you know you can go to the to the website and like download the binary if you're on like linux or whatever and it's really straightforward setup there's one executable you run the executable you know it's called ucm you just run the executable and it's listening to changes to dot u files in the current directory so then you open your text your favorite text editor you open a buffer name dot u like something.u and you just edit you know you can write unison code directly in there and whenever you save it ucm will pick that up and you know type check it and i give you some feedback about it and then you can interact with the ucm to like add it to your code base or or you know ship it to unison share or stuff like that or run it so yeah it's it's a it's a very minimal setup like there's not a lot of like configuration or you know installation that needs to happen in order to get get going and and you can really just like start writing code right away that's not nothing nothing to like set up i'll tell you a way that this would instantly interest me right so i've got i can imagine going to a hackathon with you i run this unison code manager what i'd like to do quickly and easily is connect it to my teammate's laptops in in such that if i write a new function they can instantly pull it in if that's something i will need unison share for or can we just do like a local github you can you can use git in order to like push code around it does support that but it supports it as binary files so you push basically you push your code base as a binary file to you know like a shared git repository and they can pull it from there but the the nice way of doing things is just to use unison share because you don't you're not pushing these binary blobs around really okay all right so so another thing we had recently in the podcast was we were talking about advent of code as like a coding competition for different programming puzzles that goes on once a year i saw you had a unison challenge around advent of code yeah people participate that must have turned up a few like holes in the standard library that kind of thing did it oh absolutely yeah that was fantastic they've seen people you know solving these sort of simple programming puzzles it turned up a lot of useful functions that weren't in the standard library maybe whole libraries that didn't exist but should have but you know i actually would love to know the answer to this question like when somebody sits down you know with unison and like wants to to get started like what libraries are they finding aren't there because you know i i don't know the answer to that and i i would love to know because you know i i want to write those libraries that people want i am and i farm them out to the community like you know the community is hungry to to write useful libraries cool i'll give you i'll give you three off the top of my head because these are the first three i always look for in any language can i do a web server a web socket and connect to let's say postgres you can so the first one yes so there's a there's a web server library there's also another library that i'm currently working on that creates a sort of very ergonomic api on top of that that low level web server there is there's not currently a websockets library okay but that's that's a good one we could definitely do that and you can connect to postgres there is a little library that allows you to connect to the simple postgres protocol but currently underways development of a library that allows you to you know do connect to to use the more advanced postgres protocol do things like prepared statements and things like that and is there like an interrupt have you got any way of like [music] creating a new library quickly by reusing a java c library something like that no there isn't anything like that yeah it's got to be written in pure unison or it has to be added to the unison runtime like through haskell that's currently the way things are but that you know it won't be that way forever i i envision a future where you'll be able to make calls into foreign functions you know using the scheme interface yeah and speaking of the future perhaps to end on do you think you've got the big idea you seem to have here i mean you've got a few big ideas for mainstream programming but the big one is this idea of hashing code and and storing sharing hash code do you think do you think that will start to percolate into other languages and is that something you're trying to do yeah i i think so i think we're kind of already seeing that a little bit in in in various places you know i mean there's there's things like next for instance that you know is very much this idea that you know everything is hashed but it the granularity is different obviously there is i saw some some work underwear last year with haskell where you know they can do like term equivalence up to to hash so you know you can so basically inside the compiler you can decide whether two things are the same like based on the hash but that's you know not yet like communicating between machines or anything like that but but yeah i see i see this idea of hashing come up like all over the place and like even like languages that are based on like i don't know blockchain or whatever i mean the basic idea is that you have some like eternal address for an object and then you can like always refer to that you know that address on the on the blockchain or whatever yeah yeah yeah yeah they're encoding code on the hash and like you send money to a hash which turns out to be an executable contract that kind of thing yeah basically yeah and then you know there are like distributed hash tables like what's it called hsf s i forget what it's called but you know there's a you know there's a a number of implementations of like distributed hash tables where you can like store data like in the ether basically by by hash this big content addressable storage super network right yeah so so what we're saying is this idea is already percolating into the world and a great place to discover it would be unison yeah i think it's sort of an idea whose time has come and you know it has a lot of benefits again it comes with a lot of implications that changes the way things are done you know like things like builds and like dependency management and internode communication like basically everything changes when you when you start to refer to things by you know by a deterministic name rather than some invented name yeah yeah and some invented and commonly reused name we like function name tends to apply to all the versions of their function we've ever written right yeah and you know you'll have a data type called list in a standard library or whatever and like well do you mean list version one do you mean list version two like who knows yeah and like you will have different dependencies that might make different assumptions about what a particular name refers to and if they don't agree then you'll get like you know in the best case you'll get a dependency conflict at compile time or a build time in the worst case you'll get a runtime error and yeah so we we avoid that oh based on this problem we know exists but we kind of hand wave over because you've never had a good way of solving it right i think so [music] you might be a good way of getting to the next level of programming i certainly hope so yeah i mean i definitely want to encourage people to just like come to you know the unison slack come to the to the unison website download unison install it play with it and let us know like what's missing what could what could be better or you know let us know what's what's great what's cool like on the internet right yeah yeah cool so unison hyphen lang dot org is it yes that's right we'll link to it in the show notes but yeah for now i think we should leave people to go and check it out but for now bruno thank you very much for joining us thank you so much chris thank you roona you know it's my ambition for this podcast that we'll be always looking to where we hope our industry will be in five or ten years and if we just managed to get one or two of unison's ideas into the mainstream i think would be in such a better place i hope unison does it i hope someone does it you know even the approach to incremental compilation would change our working lives to change the speed at which we build and deploy i worked at the place once where their ci server was so log jammed that you would wait overnight to see if a branch would build i don't think that's so uncommon incremental compilation would have made that as simple as compiling a few functions i really hope it goes mainstream i look to the future as ever with optimism but that's all for now until we reach the glorious future of next week's episode take a look in the show notes for links to unison and how to get started i'll put in the link to that wonderfully titled research paper dooby dooby doo check out the like and subscribe and share buttons if you'd like to show your appreciation and i think that's all until next time i've been your host chris jenkins this has been developer voices with runar bianerson thanks for listening [music]