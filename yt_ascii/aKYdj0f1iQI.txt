this week on developer voices we're looking at a systems programming language called odin which is trying to be c but older and wiser how we might implement c if we knew then what we know now and that's led to a few really interesting choices at a low level it's got things like native support for matrixes control over how data gets laid out in memory some things that can have a really huge impact on performance when they're used well and then at a high level there are some ergonomic improvements we have been writing c for 50 years now there are patterns and conventions and expectations that should probably be supported by the language because they're so ubiquitous in practical terms it's been built from day one to support mac linux and windows and some embedded hardware most languages treat at least one of those as an afterthought so that's nice to see and i thought this was really cool the there's a good chance even if you've never heard of odin you've already seen it in action cuz its first big commercial user used it to write cgi software for generating things like smoke and flame and particle effects so there are little bits of odin that can be found in video games and movies these days joining me to discuss it all is the creator of odin bill hall who goes by the handle ginger bill and i would expect odin to be a friendly approachable language because bill is a terribly friendly and approachable guy but one with some strong opinions so we need to get into that i'm your host chris jenkins this is developer voices and today's voice is ginger bill [music] hall joined today by bill hall the creator of odin bill how are you i'm good how about yourself i'm very well yeah yeah i'm i'm looking forward to the weekend but i'm looking forward more to this conversation well thank you you've got some very interesting ideas about programming in fact right you created odin i assume you're responsible for the language on the homepage yes and one of the headlines it has right at the top is programming done right yes which is about to start a flame more on the internet as we speak of course it is of course it is it kind of implies that you think someone out there is doing programming wrong and you're here to fix it in a partial way it does yeah to a certain extent how do i put this there are people doing programming obviously and people are doing it right doing it right is just a very general term again it's a marketing term to be honest with you but the reason why is for us is that odin is i'm the greater of i've tried to be kind of like an alternative to see and a lot of new lang languages out here today ar are trying to do other big ideas and many ideas they have like different ideas about safety or memory allocations or how even just different paradigms in general and it's kind of like look we want to be a c alternative so we're going to keep within that kind of tradition so we're going to keep it doing it with doing it done right in of that tradition so you're saying your your idea is what if c had had a version two or whatever the next version along is not necessarily c itself but more of the the imperative procedural tradition itself so the c the pascals even the new ones even probably closest i can think of is go nowadays they're all in that lineage and more of a like okay how would i improve of that lineage rather than trying to go like oh we're going to try something completely different right right so it's not like an experimental research language it's no most of the ideas within this language are so old i think some of the newest some of them are like brand new but most like what the vast majority of it's from the 80s or even early 990s the ideas are they're not new but they're well tested in that regard and i know how well they work okay so give me an example what's something you've picked out as c should have had this by now one of the basic simple ones is the defer statement now some languages have had this for ages but this is a another way of doing control flow so you defer a statement to the end of a scope so languages such as like d have had this with scope exit go has defer but that is function exit so that calls a st statement at the end of a function the scope i know the languages out there as well have it as well but it's it's a very simple thing but it it it's it improves your control flow with like something that c would have and it would work absolutely well in c as well because all it's doing is saying hey defer this statement or any any statement fact whatever it is to the end of the scope and call it and there's a lot of things that would help like with clean up like if you've ever done like in the basic things like f open in see opening a file and then you've got to close it well you've got to be careful where you close it but if you just define it right bind it it's f open handle the error defer f close it's done it makes the api a lot clearer so that's a very simple thing that should have been say should have been inc already but it would have it would complement inc already you'd be happier if it were indeed yeah yeah yeah so contrast that for me because i that makes me think of something like in python we have a with statement but that's that's less explicit you yeah with python ap it's python's wi is effec hand like it goes over like the try except finally kind of thing that's what it's doing and wrapping around there so the thing that you call handles the defer deferred thing the finally thing for you would be it either be like a i don't know like a a co- routine kind of style thing or just whatever with an exception whatever it's being handled with this one it's very explicit where the control flow is like hey we're going to defer this statement here and be called the end the scope so it is similar to like python's wi in that regard but it isn't the same thing it's bit more explicit clear what's going on you seem to favor explicit behavior as part as a design feature for od not always but usually yes so when you're dealing with c you kind of want control over how things work usually how things operate so you want to be a bit more explicit but one of the design goals of odin is more of minimizing implicitness not maximizing explicitness so there's a lot of things in odin which are very implicit but they're very intuitive at the same time so even though they are a big implicit it's very much like i know why it's there it's not a problem that's intuitive and simple which is another word home yes they're very everyone thinks that they're simple and intuitive no they're not they're really not give me your definition i'm going to be very careful so simple in this case is an overloaded word there's two different kinds of simple there's simple as in the opposite of complex so i would call this simplex if you want to be the technical term so simple and complex and then there's the opposite of simple which most people mean is easy so the opposite of that would be hard so you've got easy and hard and simplex and complex right when it comes to like intuitions intuitions are kind of and instincts in general are built over time and they're kind of sometimes heuristics or sometimes they're just ways that seem correct to you that's a way what an intuition in the way an intuition is what to you says oh this seems how i know to know things so when you've come over bu programming over the years you build up many of these intuitions and these intuitions are very complex but they're easy to you to understand and grasp because they are like a big web of different ideas all meshed together but they're like a small unit of you easy to understand but complex in their construction so a lot of this when i was designning language you actually have to ask a lot of people and see what they do and see what actually happens when they do this weird things you ask them why were you expecting this like well it seemed intuitive to me that's usually what they will say i'm like this is what i expect and i'm like okay and then you find out what people like you have to dig further what why did they figure that find that out and go oh yeah what what it is and usually these minor these intuitions you kind of have to play with and sometimes there a lot of like there's a lot of implicitness in that intuition but if you make it kind of explicit what that and make it into a concrete idea it can simplify it a lot so mak makes it easier to understand can you give me a concrete example of that actually probably i can actually just let me think through the language so od has a very basic rudimentary type in system just help out a lot of the time what how it came to be a the the inference works is through that intuition stuff so a lot of things have like numbers in odm right so if i write the number one it's the number one but it's untyped so this is similar to like a language like go has something like this or you may call them existential types in hascal or there's all different things what you call them like this but this is a number and this number can then be represented by multiple different things like number one could be an integer it could be a float it it could be any stuff like this but if you have the right number 1.0 by default this is i call an un time float so it's default type with ba float type specifically in f64 however 1.0 is representable as an integer yeah right so why can't you just assign that to an a specific integer type and that's you can in know because the own understands the value system from these basic ideas of having all that they build up the the complexities and the intuitions of people because then things just start to feel correct and this makes seem like why is this such a big deal why do you have to have make even basic of numbers and constants feel correct well the thing is in c everything is typed even the numbers if you write the number one in c that is an integer if you write 1.0 that's a double if you want to get float you have to do 1.0f or if you have to do an unsigned you have to do like one u or one ul or one ul for a long long so you have all of these different subscripts because every little literal is typed and the thing is making it feel correct with all these different semantics about how constants values work again compared to see where everything's explicitly typed you and then sometimes this causes bugs in see as well like when you've written like 1.0 and that's a double but actually what you wanted was a float so you wanted an f on the end but the thing is there's some implicit conversions going on everywhere and these implicit conversions in c are usually sometimes to get around the constant value system in the language and it causes some again some friction so if you actually try and make it much more make it just work sorry i'm sounding like todd howard here but it does make it feel correct and it does it's kind of like you're figuring out what those intuitions that people have and that took a lot of experimentation to get it to go h that's what people actually want let's do that and codify the rules that's i mean that does take a lot of work it's it's very easy to get wrong i'm thinking of like javascript which has a lot of type coercion which doesn't really od doesn't odin actually has a versally no implicit conversions whatsoever because those values don't really have a type yet in a weird sense some people in the comments will go yes they do like i i know i understand them i know understand the type the that's not the point it's just they don't really have a concrete type yet so when they come to when used they will usually in a concrete specific case they will get a concrete type but they'll work and figure out which is the best one not the best one but the most intuitive technically speaking it's the best word i can use to describe this and it's just a little things just a little things like that but it makes it more in and get you actually solving the problem and not having to worry about other things did you was this born of just frustration with c or were there other languages inspiring loads of other language inspired me but a lot of it was born from frustration c cuz most of my day job was wr writing c and mostly c was plus but i did know a lot of other languages out there god i have too many languages that's half the problem but it's very much like i know how other languages solve certain problems it's like look i wish i had this idea from here or even just simplify like i wish i got rid of id some stuff in c like go like why do i have to deal with this stuff or can i just have a smaller language in times and so i when i was making odin i was kind of very drawn towards more of the pascal tradition so one of my favorite language designers anyway is depends on how you pronounce his name it's either nicolas viet or nicholas worth depending on if you do it by name or by value his name as the joke goes because he is the he is the creator of pascal but one thing he's always done pascal was a teaching language so he's done a lot of stuff over the years for teaching resources but one thing i've always loved about the pascal like family in general is it's very clear very clear what's going on usually and very well- defined and from that tradition many other things came out so another one of my kind of like design idols is actually rob pike so he's most people probably know him nowadays for the go language but he has done so many languages over the years for many domain specific tasks but also things that like in the 90s one of them that the odin's declaration syntax comes from technically speaking is the new squeak language which is back in the early 90s he developed so there's a lot of these different things which i've tried to draw together and i'm like look i know how these ideas work they've kind of been tested in the field like right can i have this back and keep it in the same kind of tradition of the c pascal tradition here and make it feel better for people and also make it to solve problems i don't have to be fighting the language every day which i was doing with c++ and even see at times you fight the language because it's like oh no i can't do that no i can't do that i'm gonna invite you to find a behavior no i can't do that because grammar doesn't work no there's all those are problems and you can't fix it unfortunately c is not fixable so and i found that out hard way trying to make me own c compile trying to fix i'm like nope the foundation's broken so we're going to have to go somewhere else do you know i've heard a lot of people recently because we doing a few episodes about c like languages and a lot of people have said well why not just fix c so maybe you can help us pin that down once and for all why is c unfixable firstly c is 50 years old when it was first created it was designed for certain systems had many ideas baked into it the reason why like again simplest one is look at the types you got char you got short int long well that's because those are generic terms because on the systems we were running on all of them were like different size bites like it could have been six bit bites could been 12 bit8 bit it could be anything in that regard sometimes even nowadays you still get 32bit bites sometimes on certain systems so you get all of these different size systems and it's like okay be very generic there's a lot of ideas which seemed good at the time or were actually good at the time but not good nowadays very good example of this is strings being null terminated null terminated strings made sense back in the day because it was costly to actually store an extra inure somewhere whereever that extra che the length and it was a cost so and back then it made sense but very much like you don't want to do that nowadays there is literally no real good reason to do that ever so unless you're interfacing with c obviously that's the problem it's the interfacing aspect so it is always the question of which bits can you fix but then the type systems broken with see like there are loads of little things like the type all the implicit casts causing issues the operator precedence like not even just syntax but like the semantics of language like there's a lot of undefined behavior like one thing i really don't like you can define the vast majority of the behavior and the stuff that is let say i'm playing pretty much everything you can define the question is where you're defining it and that's always the caveat when people always bring up with undefined behavior i'm like well you just specify who defines what like is it the compiler is it the language is it the platform is it the what who is defining the language you tell them you must define that for us and therefore it's now define and you get a lot rid of the vast majority of that undefined behavior the c has which is a massive annoyance we have to always kind of think like what am i invoking here again oh yeah great kind of thing so does that mean you've got like an official spec for odin that you're happy with there is no fully written spec yet i need to write it it's going to take me a few months pretty much but there will be an official spec and once that spec is written and the compiler adheres to it that is 1.0 for the language ah how long do you much how far away is that well the language itself is pretty much done but i've got to write the spec and i have no idea just because it's writing a big spec it's not like a little toy language anymore this is a huge language in many regards so it could take a year or more a lot longer maybe i'm not putting a date on anything so if anyone's put me to a date no no fair enough no yeah pretty much yeah it's like i don't really have an official road map because it's very much a we don't know when we need things we just do it when we need it pretty much when people asking like we do this working on it now official road maps i've always found like most people never keep up to them anyway ever so it's kind of a it's just you're advertising something that's not going to happen yeah yeah of i'd rather be honest with people who are using it i'm like no no we we going to do this oh no we're not going to do that okay honestly then what state is it in now is it production ready tenative to say so we for my job i work at janger effects and we develop realtime simulation software for like the game film and motion graphics industry our main product is embergen which is a again real time volumetric fire smoke and explosion simulator which many people in the games pretty much many games using it nowadays loads and loads of game studios have it most most modern games are using our software for that all of our products sh imen geogen and liquen are all written in odin how did that come about because they're not those aren't your products it's not your company no not exactly no so you couldn't dictate that they use your language no so when they first kind of started up there was two car founders there's nick and there is nick cver and morton vasic these two again the co-founders of the company i've known morton for years he's a friend of mine and they were starting up because they were thinking like okay let's do this thing they because nick is he's an artist by profession not a programmer and he was thinking like okay i know this real time smoke stuff i know it's possible can i find someone to do it so morton i'll do it helped start off with you and the language he says look we're not doing c++ nick whatever we do just don't use c++ look my friend bill he's got his own programming language and i want to be using that instead pretty much so they were working through that and doing their own tools and got all the things before eventually trying to get me on the team and eventually oh you want a kind of a job working for us bill and initially i went maybe not and then eventually went yeah okay sure pretty much so that's kind of got on there so i've now been with them well since 20 early 2020 so nearly four years at this time of the recording so it's been quite a long time i've been there but it's been really it is real that i working in a job where they use my language and i programming my language every day and we produce products that people actually want it's such a it is so surreal to say that at least and it's just lovely and now on our team we've got about 20 different people at the company o over probably a dozen programmers all using the language and it's yeah it's an experience i can tell you that so what how does this how does this work as a language designer in residence quite well surprisingly so usually because we're using in production sense i'm not saying i recommend other people to use in production obviously that's any language use at your own risk obviously there's warranties don't really exist in that domain but one thing that was helping me is that usually they would have like oh we found a compiler bug bill okay i'll fix it go just go fix the bug no problem then go back to working programming and od him whatever and again most of the time i not necessar working on the compiler i'm working on the products written in the language okay but also so sometimes we came up to problems and like actually we've got a problem there's a there's a deficiency in the language like we've got an issue here like semantics aren't correct or we need an extra feature or something would you consider doing it adding it into the language i'm like okay and a lot of the time i'd go yes sometimes i'll go no i'm just having a hard line then some look i've got like the freedom saying no i've got a hard line i'm saying no i'm the dictator of this language so this is how it goes because sometimes when people suggest things you have to go like it sounds good but it won't work out trust me about that kind of thing because i've probably tried it already and it didn't work out but it's very much like that so sometimes we added features and one little feat i'm trying to think yeah one little feature we added which it was mainly for profiling and the the immediate mode ui that we make as well and it was this again is coupling this defer sometimes sometimes we wanted say we call a function and it also defers another one so is this in case it is an implicit case but these two cases are pretty much the only cases you'll pretty much ever need this implicit deferred attribute on a function so where you call one function it defers another one so it's kind of like a weird bit of like ri if you start see but it's not on the type it's just on the function call and the only two cases we needed it for were profiling so if buch wanted to put this at the top we could say begin profiling instead of defer end we just put it in block but the other one was also for imoes like de if you know like dear imo is a popular imoy library was popularized by the idea was popularized by case moror about 20 years ago but we have our own in house one and we for a lot of the ui stuff it is really nice to actually have these scoped things like oh we open up a like if like say say if tree and you just open up the body or if menu and he does that for you so these these are implicit but it was very much like we started noticing there was a deficiency in the language and kind of needed it because we could just be explicit defer every time but it really was really cluttering up the code and actually causing certain bugs because you wanted to only open it up if it was valid or not so you'd have to like defer if this condition you have to defer an if statement as well so it was getting like the logic was getting a bit cumbersome right like that so that's one kind of those examples we've got loads more on top of that but certain things like that we go ah yeah we got to do that okay i i think we should delve into a few more of the features of the language that caught my eye when i was looking at it one is the headline one is that you say it's a data oriented language yeah yes tell me what you mean by that and what how it supports it so data oriented is data ored design was kind of popularized a few years ago as like an idea it's like hey look stop focusing on the data itself rather than like say object oriented or functional object whatever whatever the paradigm that's in vogue at the moment kind of thing where data orient is very much like look what's the data you've got how do you need to manipulate the data what what is the best way that can actually make it run to the fastest on that machine as well so a very good example of this would be there's a feature not in which we have is soa array so this is structure of arrays it's the difference for some people if you know database it's difference between like row oriented and column oriented in that regard so instead of having an array of structures in your data or or rows col rows of the data you can then reorganize the data by just adding a little tag that says hash soa and now it's structuring as if it's like array of columns it's like oh the first element array of that second element aray of that third element ray of that so it changes and certain things on the data access on the machine it makes even better because modern machines have things called like cach lines and stuff like that so you want to utilize them as much as possible right so this if you've got a thousand user structures yeah you've normally you'd have the username the age the next username the next age and this you'll have like a thousand usernames followed by a thousand ages correct yeah correct just checking you got it that's one thing so that's kind of sometimes having changed in the memory layer on that regard and keeping the same syntax as well which is actually the real point here you've got the same syntax as as if it was like a an array of structures like this row based but it's actually internally laid out as thing but the thing is the computer likes many cases loves having in that layout when it comes to other things within language ag we have like array programming as well so you can actually add two arays together element wise and it will actually lower down to the correct machine code like the simd for it but we've abstracted it so it actually feels really high level in many ways it makes you feel like you're actually programming in a shader language like if you' ever used glsl where it's got like the swizzling you can do like xy z or y y y z to a rush reference for some reason but then there is the you can and they multiply it together but the thing is there's actual instructions on your cpu for the hardware to do that so it's like why don't you bring that to the the fold and actually so you can manipulate and actually process the data in a much better way is this because you you're like looking at cpu architectures 50 years on from and saying here's a bunch of interesting new features we we should bring into language space pretty much yeah it's pretty much like we i know how the hardware works for the most part so like why can't we actually utilize that because again c was built back in the 50s yes the most modern incarnation really hasn't changed since the 90s in any many ways yes has been minor extension like c99 and c11 and now the new c23 but they really haven't changed the essence of the language the essence is pretty much the same and and for the most it still works but you're then still have but a lot of people still have to rely on like extensions or into the language to get these new features that the compiler can not the compiler the computer itself can do but the thing is it's like okay why can't you design a language for the more modern machine and more high performance machine because but still have the control that c would have gave you anyway and there weirdly enough many languages out there don't try and do that they're trying to be highly abstract and then take their abstract model and then apply it to the computer rather than kind of start looking for the bottom like what are the patterns that we can bring out from the computer and give it a nice construct from there ah so this is because i often think programming is divided into people that think programming is maths down and people who think it's cpu up i know both thinkings but i'm usually cpu up rather than the maths down i know the maths which does help you formalize it in many ways cu my background actually isn't in programming my background is in physics so i'm very much know my history and background is from like quantum mechanics and such so i do know like loads of the mathematics when you have to do math quantum mechanics and such but you do have to kind of like build up as well like it's kind of like you have to know both the directions the which come through and it actually helps you to like kind of ground you but also formalize you yeah so you have to know a bit of both but i usually more intuitively come from like the cpu up and try and look at the abstractions where come there and make them concrete whilst being influenced by the the mathematical side right i have to ask this if you got a background in quantum physics is there going to be a version of odin that supports primitives for quantum computing no so the reason as to why is classical computing and quantum computing are very different beasts and quantum computing at the moment is still in the very very early days there's not really any quantum computing programming languages out there at the end of the day they're just more more elaborate mathematics like hey look we've did a nice little matrix thing we've got here we're doing through this foro transform thing i'm like okay great this is still like raw math it's not really abstracted there they haven't found the abstractions yet quantum computing again is not going to it has very specific domains where it's very good and certain domains it's most most things aren't good like if you're going to make a computer game you're not gna use computer classical is gna be fine yeah kind of thing there seems to be a lot about odin that is leaning towards specifically the gaming world is that a deliberate choice origin no but again from my experience like i usually do like a lot of graphical stuff like physics and also 3d graphics so there are some things in there which are kind of tailored to towards it and as result of those little features really many people have been more drawn like oh i'll make a game with this or i'll like make some application devel again jangler effects we are doing stu that's not very dissimilar to making a game really we're utilizing the gpu a lot we are doing a lot of like physics and graphics and stuff that many games would also use in other 3d applications so many of the languages are the language itself edin is very tailored to those tasks it's but the thing is we also as our part of the odin's core library and vendor library we know that when people think about a language they don't just think about the language itself they think about everything the entire ecosystem thinking about the language itself the core library the the tooling around it and the ecosystem in general pack that what people think language that's the language for a person if you ask a computer scientist i'm sorry a scientist who uses computers what python is they'll think well python yeah it's got npy in it it's got c tools they don't think them are separate they think that that is what python is yeah so we've been trying to put effectively the kitchen sync in there as well in many ways but but nice packages so we have all of the graphics apis we have open gel vulcan direct 3d metal web g g webg we have all of those graphics apis and all native like metal is native know him it's not a rapper around anything so we are calling the direct objective cs underlying for it which is quite nice we've got other things in there which is very nice like even for prot like ray many people might use that to make little games or prototypes it's just box we've got stl glfw all these things that are great for making like little prototypes or tools or even full on fledged games it's in there as part you just download compiler and it's there getting ready to go this kind of the b the kitchen sink is is kind of the philosophy the batteries include as some you may call it yeah yeah how fully featured is that today quite actually so we have quite extensive vendor stuff the vendor libraries we're calling it rather than the core like which is core to language the vendor stuff if i can remember what's in there we've got we've got loads of like cryptography stuff in there as well we've got some like markdown readings the common marks specifically is that one we've got networking things in there we got our own odin network stuff but we've also got like eet if you want to use that or the ggpo so ggpo is for mainly for games so that you can have i'm trying to think deterministic gameplay across online such because that's something i need to roll back as well so you need to have a roll back deterministic gameplay so that's very something that's useful in there we've got even like what it micro ui miniu mini audio we've got a lot of tools in there already which help you to make graphic applications effectively graphical applications for your desktop and mobile devices sometimes mobile's not officially sported but some people have been tweaking so who's using this outside of the company you work for quite a few actually there's a lot people have been using it for tooling there's a lot of people who are again it's mainly for a lot of tooling is a lot of what people doing in that regard so there'll be like some people doing like profilers and such there's a company called they're doing spo making this is a high performance tracing and profiling application and it's one of the fastest out there as well which is pretty interesting there's some people who using it to make game games there's a lot of people making nice little games 3d 2d all all the range out there there a lot of people also just general for tooling and they like doing it as a tooling application so they may be at work it may not be their main product but they've been using it like oh i've been really like just make tools in it so i can make build scripts or make like passing tools or like that it's just much easier for them even though they would have gone like i would have gone for python like yeah but python's slow in comparison so i still get the high level features but i actually still get the performance in many ways and people that's why they're using it for those reasons but they're finding it more pleasant than the c based alternativ yes is surprisingly yeah interesting so if it's a simp simple and pleasant language to use there's there one particular feature jumped out at me as being very curious for a language that claims to be simple i want you to justify this for me so in tell me if i've got this wrong the way you call procedures in odin you can use a specify the calling convention whether it's passed by value or passed by reference or that not exactly so so how do i explain this so you can actually specify the calling convention usually that is necessary when you're dealing with foreign code in general be the calling convention could be c it could be the standard calling convention which is pascal like on windows it could be more fast call there's multiple different call conventions if you know enough like low level c you know different call conventions but the thing you're referring to here is more of how of those certain call interventions define things so in c specifically c passes everything by value so what this means is if you pass a integer depending on the calling information this is usually passed as a register but if it's big enough what will happen is the stack will copy it and pass it through there so it takes a copy it pass it on the stack and it has a copy so you've got a thing like that in the problem is in cc programmers are so used to knowing this they go like okay we're goingon to have to pass it by pointer because it's is going to be too big otherwise otherwise going to blow out the stack or something like that it's not going to be fast and it will make market as const as well to notice this is an input only parameter and that's usually what's really common in c and in c++ many people do the same thing they use a con reference explicitly and say i won't do this but there's a problem a lot of the time people either forget to do this or they overdo it and it's very hard to do so when you're passing something in you kind of want to say look this is an input parameter but i actually want it just be like do which is ever the most efficient way of doing things effectively like that's what most people would write intuitively surprisingly even though that many people say no i want it to be i want it i want always to be the same semantics like obviously i want it to be like you don't write code like that people don't they actually write it as a pass by point or pass by reference even if this causes a lising issues in the future so that's the thing is that is a fundamental problem but it exists in those languages because of the it's not even the implicit it's just the explicitness of doing it and people just forget there's aling happening so what odin's kind of done is kind of codified those general conventions that most people do so if the structure is too big to be passed in a registers it will try will just pass it by a internally it's a pointer or reference when you to call it but one the benefits in odin is all of the procedure parameters in odin are immutable so you can't take the pointer of them you can't reassign them in a sense you'd have to if you want explicit copy you have to do an explicit copy onto the stack so it's more of a we're making those general conventions that most programmers in this domain would have done anyway and making explicit implicit in that regard sorry implicit and it's just one of those that you do get a lot of benefits yes i'm being obvious honest here there are sometimes aliasing issues but empirically speaking those alas issues even exist if it was explicit they're the same problem it's nothing to do with the implicitness or explicitness it's just due to what people write effectively and unfortunately there's not really much way to prevent this unless you add more complications to the language like rust gets around this by having the ownership semantics but we didn't want to go that far down the substructural type system route right so so you're staying within like normal c just trying to trying to codify what's evolved as a convention in the language correct yes that makes sense that makes sense so you touched on this briefly i think we should dig into this a bit more calling foreign code conv like so is there can i call c code from oding can i call yeah absolutely fine and vice versa you can call loading code from c so that is very easy the foreign import system the foreign system in general loading is it understands c in that sense so you you but the thing is it you cannot say it knows what the c calling vention is so you can define the foreign blocks you define the signatures in there whatever you're fing and it will actually understand it and call it because that's just it's just what the linker does at the end of the day you're just linking code together and as long as they know the name the symbol names and the calling convention you can call between c node no problem like that the thing about odin as well in our foreign system as well we actually say when you import a foreign library you actually say which libraries you're importing like the do label the dll or the de or whatever it is and you actually link and say hey this is these import these foreign import names and stuff like this they're associated with this import thing that that's what is this this procedure foreign procedure is associated with these import symbols so if you don't use that foreign symbol symbol those things don't get linked against but if you do use it then it automatically link against what you need so it has something which in see people may know as an extension which is like pragma lib which is one of those old extensions this is kind of kind of codif codification of that and also not just making it always link it links only when you need it and used it like natural tree shaking pretty much yes yeah yeah that's nice that's nice if if we're getting into pragmas this raises another thing you say on the website which is no i'm going to quote this specifically no bad pre-processors yes that's a a very judgmental statement i assume you're saying that the macro system is bad in c yes so c's ma macro system is textual based it's the best way of putting it and as a result everything about the rank language is kind of based around that people always forget that the pre-processor is technically a separate language you could use the cpr processor in many other things languages on top of it you could even use it in python if you wanted i would not recommend this whatsoever but you could and that's kind of the thing so you've got things like when you include a file actually what's happening and see when you include a file is it pretends that these files are the same you're actually including it as one giant file so in that sense that's what's going on but there's a lot of issues with it because it's textural there's not a lot of safety now i know you're a bit of a lis guy yourself so you're more clos to these what hygienic macros and such like that where they're working on the as level in that regard yeah which is not necessarily a pre-processor in many ways because it's technically part the same language but it could be sometimes they can be conceived that way you could design a pre-processor that works on the as level modifies the code at the level and then goes back again now odin we don't have a pre-processor whatsoever as part of the language because we've not actually required it surprisingly you'd be surprised how if you actually do the things that people did inc with the pre-processor and actually just codify them as things actual constructs you' be surprised how little you actually require something like a macro system to begin with and the more the the more and more you do that you realize yeah we don't need a pre-process let lear a bad one anymore okay so does the phrase no bad pre-processor mean we've thrown out the bad pre-processor but we're still open to adding one if need be we probably won't ever add one ever again if you want to add your own on top you can but one of the reasons why there won't be a pre-process for odin is because we have got everything's out of order in odin how it compiles in sense so in see everything's top down you go from the top to the bottom and the grammar of c requires this for odin is effectively you pass files but the p each file gets passed into different threads it's completely out of order so it's it's context fre grammar in that regard and when you do all this it mean that you can actually and everything gets type checked out of order so a pre-processor in that regard would unfortunately linearize it make it in order if you did that on top now sometimes it is useful to have like a generator like some code generation but i just write that in odin to generate the code if i need to like if i've got some really complex table right i don't need to have a pre-processor per se as part of the language i can just add a tool usually most of the time they're just one-offs like you just write the code it's done and that's what i found most of the time over my life in career in general most people have as well right so instead of doing things at compile time you just have a separate compile phase yes but you say that we have sub but literally usually gets run once and never again yeah in practice and that's the thing it's like in practice that's what the case is okay okay yeah so if we're talking about compiling and the parallel compilation we should talk about comp compilation speed yes and plat forms that it's supported on yeah so starting with platforms odin is officially supports windows mac linux numerous of the bsd ones like free bsd open bsd whatever stuff like that we also support wm as a target as well so in that regard yeah yeah but also as long as the operating systems we also support it's amd64 so that's intel x64 x8 x86 64 whatever you call it amd amd64 call it there's arm 64 which is again what the new macs are using as well we support that and we i think that's what we only support officially at the moment anyway we could support more targets but that pretty much covers 99.99% of use cases for most people is amd64 arm 64 wm that's that's quite a lot though yeah that's quite a wide arc for relatively young language well that was one of my main goals when i made the language i wanted those specific targets i wanted mac linux mac linux and windows and amd64 and arm 64 and a lot of new languages out there at the moment don't usually focus on windows at all they really don't care they're really very much the linux mac focused and i'm like but i work on windows a lot all the time i'm making that's how i make my job i do make windows applications mostly so it's kind of like why most of them are kind of ignoring that and when they do add it it's more of a second thought usually well i when i developed od ev's always been on windows it's always kind of been like we polish make sure it works on windows because when you port to linux mac it's easier than going the other way around if you know what i mean i can believe that yeah because when you're on windows you you know what doesn't exist put it that way like if when you're on mac or linux you know the posx stuff i assume of posx and you go to windows like what's posix so you don't have you don't assume those libraries exist as for the compilation speed so there's different parts of the language in there so you'd call it the front end and the back end usually people have this so the front end is the the the tokenizer the passer the semantic checker kind of that stuff that part of the language is pretty damn fast because the language i designed it to be fast in that regard so i try to do all of that and that's good but the problem is our back end currently at least is lovm and lovm is very very slow even when you're doing like development builds and it takes about over 90% of the entire compile time is lvm and a lot the we've tried our best to even make it faster as well problem is lovm is slow inherently and to try and multi-thread lovm is not easy either because it's doesn't really want to be multi threaded the only way you have to multi thread it is you have to do a lot of tricks and most of them aren't even documented well because am vir nothing documented well but let's not going to that rant shall we but that's kind of thing so the odin itself it should be intrinsically fast to compile there is nothing like it should be as fast as you can get because again it's been designed to be very multi- threadable like even the language when i designed the the semantics i said that on average my my herisa was that most of the time when you're doing semantic checking is spent within procedure bodies so i went okay i'll design the language so that i can compile all the procedure bodies out of order and multi- threadable right okay that heuristic seems to be true even to this day so i made a good decision that regards there are some bits where if it isn't the case then clearly it becomes kind of more single threaded if you just if everything's just like big date strug like if 99% your code is data structures and there's no like procedure bodies then it will be more single threaded but that's just kind of the how designed the language but that's the thing as i was designing language knowing how modern hardware worked i tried to design it around that as well not just saying oh we'll try and just make it fast and make it a really fast single pass compiler like the old pascal compilers i'm like yes that'll get you so far but how can we expand this and go further again this is modern programming has moved on a most code bases are a lot of different files right pretty much yeah you'll have hundreds not hundreds of thousands some people have and it's not just one big file of small things anymore and it's not even that it's that we have threading now we have we have multiple calls on our machines most people have at least four even your even my phone has like four cores on it which is when you're thinking about way my phone is more powerful than my machine from like 15 years ago which is crazy to think about but it's true yeah yeah yeah mo's law in action yeah yeah but yeah so it does make sense but it that way that we should be designing our programming languages to take advantage of the cpu yes the de facto cpu layout of today pretty much yes this is this is slightly harking back to an earlier question but i've just thought you you target but we've been talking so much about cpus do you do do you target gpus as well no and half of the reason as to that is gpus are not as general purpose as a cpu is obviously they're very more specific what they do and for a gpu there's two different types of things you can run on a gpu there's one that's shaders pretty much everything the shad on a gp really but most of the type of shaders you're doing would be like some like g glsl or the direct 3es hls or the metal one or whatever and you do it through there you do like the pixel shaders the fragment shade the same thing ob pixel shaders or the vertex shaders or the compute shaders and such like that there are other languages such as like open cell and the cuda and all that lot which try to be a bit more general and make these kind of like kernel shaders in a sense but the thing is it's a very more different environment like the how the gpu works is not the same as how the cpu works so you in my personal opinion i wouldn't want to try and design a language to be the same across both right i'd try be for instance like at janger effects we technically have our own shading language which compiles down to either glsl or metal depending on which platform we're on and but it's very much like we've designed it so it is for the the gpu so it models all of their specific memory models as well like for instance atomics works different obviously so you have to deal with how those things work on those again those those types of machines so if you try to have a unification between the two it doesn't really help now many people just want the same syntax which is like okay syntax whatever but the semantics have to be really different and there probably will be a point in the future hopefully where the two will merge where and again with the apple stuff what they're doing with their system on a chip they're slowly getting that way so eventually there might be a unified language that be able to work on both the cpu and gpu we're not there yet and i'm i'd rather see it first and then develop for that rather than like i'm gonna design and hopefully this will work in the future i'm like i don't know the future okay if i did i'd be a millionaire so or or you despair about the state of the world yes that's another thing it's probably either to go into hell or heaven i'm not sure which find out the slow way yes so you so again you're waiting for the hardware to tell you what to do pretty much yes okay because i don't think how do i put this the languages of today aren't going to be the languages of the future necessarily c will probably be see it's been around for 50 years i'm expecting it's going to be another 50 years of c but there is not going to be the only language and i don't know what the new languages are going to be like they're probably going to be very similar to what we have today but they'll be more tailored hopefully to hardware yeah i i can see them being quite similar because i think the slowest the part of the system that changes most slowly is actually us programmers yeah well the other thing is also there's only a few different computational paradigms anyway so like the c tradition is still technically well c is kind of based on the von noyman idea like vman architecture which nowadays modern machines are like modified cambridge technically speaking but that's still of that tradition but then there's also like what's say got the ml language is that's all just like what's it called what's the ml family it's oh church whatever it is i can never remember names of people but there's different computation models but as you look at the computation models there's usually like a family of language around that model like there's the fourths there's the mls there's the c and the pascals which i'd call the alol technically speaking that's the alo family and then you'd probably what else is on that list you got the lists as well like the small talks of the world those are really actually part of the alcohol family at the end of the day yeah they're just a bit more extended they still got the same kind of memory model as the alol in many ways usually i know there's exceptions to that rule but that's pretty much the families do kind of bundle that so in the future i'm expecting unless they figured out a new computational model the language will look about the same 20 2030 would be the decade of prologue on the desktop probably not probably it'd be interesting to see a data dated language anywhere like that but yeah okay light it might be actually because of what unreal is doing with their language which is technically just prologue with different syntax i've not heard yeah i can't remember what it's called uh yeah unreal's got their own like little scripting language now and it's effect to be a prologue yeah that's curious why yeah i think it's just because they want have got a lot constraint based stuff so they want to like you've got these constraints within games and search they kind of like that's that's the thing they think there better way of explaining things rather more of a procedural way i think that's what i can't remember the name of the language someone will tell me in the description like it's this one tell me i'm like sorry i just names i forget them all the time i'll research it and stick it in the show notes maybe find a fut guests to talk about it that sounds cool there you go there was one other thing on my tick list of things i definitely wanted to talk to you about sure was your core data types so we've talked a bit about arrays but you've got like matrix and complex number as a core data we even have quan as well by the way yes oh so we have complex numers quan matrices array program in general so the reason as to that is is is pragmatic so the complex numbers andorians are there just because again i do a lot of like 3d stuff and it's honest with you it's useful to have just have them in but also the one reason is odin doesn't have operate over loading so as a result we don't have operated loading i thought okay what is the like 99% overlap that can get most people happy without over operate overloading okay just do that rather than trying to make it as generalized as possible the problem with opera overloading i have seen a lot of horrors with it i mean a lot of horrors and it's it's one of those where it's a slippery slope when you add it is as a feature into a language and it's very much like i drew a hard line i went no we're not going down that route no matter how much i know there are uses for it and but even like most uses most of the time it fits into two categories the first one is the mathematics well we have all that now you're pretty much everyone's pretty much happy that's why i've got the matrices the ar and the quintans that's all in there most people have they don't even need to worry anymore the other side is the data structures well in odin we have build data structures like we have an actual string type un like su we have a ray types proper ray types we have even a basic hashmap build thing say basic it's a heavy optimized one but yeah with soa data stru inside but yeah it's what pretty much like we've got the basic data trips that most people want 99.9% of the time if not higher than that and if they do need something more complex i personally i don't mind just calling some functions from time to time because it's not like i need it to be a syntax level thing for those things like if i've got a red black tree i don't really need syntax for that because i'm not really it's only like very specific cases where i need one of those data structures yeah yeah i'd agree i think yeah a lot of the time it's just laziness of typing i think yep do i really have to type five letters rather than one symbol which makes me laugh because it's like do you know what your profession is right yeah because it's like if you're optimizing for typing you're in the wrong job in my opinion like i know you shouldn't be writing load of stuff yes i understand writing loads can be annoying like redundant stuff but just trying to like reduce like oh instead of writing five characters i can write two i'm like yeah really but so many people want that and it's kind of a think about just kind of you need a bit more self-reflection in some cases from it's like oh goodness sake there is there is a balance to be struck between single character glyphs and the abstract proxy factory being yeah instance of java yeah i i i do write long function names but they usually very very descriptive so like oh this thing does that that thing and it's just usually kind of nearly in english but it's it's easy to read like you can the thing is most of the time you're reading code you're not writing it so why are you optimizing for the writing when it sounds like you're writing right once never be able to read by anyone else like again we have a team of like nearly a dozen programmers so we kind of have to write code that other people can read and a lot of odin's stuff within the language has actually helped us make it more readable just because of like the constructs kind of force you to kind like yeah you know what have to be readable in this regard makes me think one day we should do a podcast episode where we get all the different language designers we've had in to judge each other's code oh that's great yeah that would be great fun so we've talked about what's in odin is there anything that's missing anything you anything you'd like to add or anything you think someone would say oh odin doesn't have x so maybe i should stay away there's nothing i actually want to add to odin at the moment anymore or if there is it's very much i've chosen still not to add it because there's other like trade-offs you have to deal with but one thing like many people ask sometimes oh is there any methods in odin like nope odin does not have any methods it's just standalone functions everywhere and it's like oh wait why i'm like it's mer very much a i'm not saying i'm against object wi programming it's just i'm not going to do the c++ style one if i did it and also it's a rabbit hole of a feature like if you want to go down it like one of my my not say i want to do the exact same semantics but like one way go does it is i quite like the implicit interfaces but i wouldn't go down that route because it is a rabbit hole of a feature once you do it no no no no no no not worth it it it's it's kind of a you start then bifa language into multiple dialects this is the problem when people start asking for features they start ask they're effectively asking for dialects and i'm like that's i've already come from c++ where this is a huge problem so i didn't want to have to introduce that into my language already like i know there's going to be dialects but i kind of wanted to minimize them as much as possible by just not having so many options yeah yeah it makes me think of you know java they say everything's an object i don't necessarily agree that everything should be modeled as as an object if you're going to have a language that treats nearly everything as an object then it prob is better to have everything being an object just have one paradigm right like if you go like functional thing everything is a function like like in hascal pretty much everything is a function and it makes but in odin not everything is something like there are very distinct categories of what things are not everything is the same thing and that's a very thing common thing in like the imperative procedural tradition anyway some things are different things there's not like a unifying principle it's like very much like a lot of those kind the unifying principles are mathematically nice but practically don't help you at all i would say that pretty much everything is either data or a transformation of data that's my way of thinking yeah yeah that's the nicolas viet one it was one of my favorite books always recom from beginners if you can it's not in print anymore but if you can you can get the pdf for free it was data structures plus algorithms equals programs and it's a lovely way it's a good book but it's a really nice way of thinking about things for most people because most that's it's technically a wrong model of thinking because it isn't technically correct but it is very useful like most thing just think the data and the data structures and the algorithms and how they operate together yeah what do you think's missing from that why is it not technically correct technically wrong technically data structures are actually things that encode an algorithm already implicitly because they do have an algorithm when you use that data structure it's just implicit it's not made explicit okay yeah yeah yeah yeah so that is technically the case but what i'm saying is it's it's a good idea to think of that distinction usually it's a pract it's very practical yeah yeah that yeah i can see that that's particularly true when you think of something like a red black tree right yes yeah cuz a red black tree is explicit data structure but it has algorithms about how it works obviously absolutely yeah encapsulation back again yes back again okay if someone wants to try out odin how do they get started oh the easiest thing is just go on to the odin l.org website and you can download it and such no problem and you can just give it a go it's pretty easy to download pretty simple small executables if you're on mac or linux just follow the instructions ma lin windows is instructions how to install it and you should be getting going pretty quickly actually start a project where would you kick off depends on what you want to do it's like how long's a piece of string really it's if you want to make games we've got rib built into language so you could probably try rb library and try and do that way it's another good thing if you want to do a little networking thing you could probably just make a use the networking things for like tcp or something like that and make your own i don't know websocket thing i don't know just make something up that you want to try language to get a feel of it because i recommend this for anyone who's trying out any new language be odin or any other language try it out for at least le over a week and i mean properly make stuff in it to get a feel of what you like or dislike about that language because you might not like odin you may love odin but you don't know until you try obviously and i' recommend people to do that with as much as they can if you've got the option to actually choose a new language try them all out as you can yeah yeah and give them a proper try don't just bounce exactly yeah don't just like look at it and go well that doesn't seem right like try it out don't just read this like the overview you'll get a different feel sometimes well i hope for listening to this a few people are tempted to give it a proper kick of the tires as do i groy bill thanks very much for joining us no thank you very much chris anyway cheers see you again see you bye cheers bill as usual you'll find links to all the things we referenced in the show notes there's a link to odin's homepage of course and its package library i always like when i'm checking out a new programming language i always like to see which libraries are already available gives you a sense of how how mature it is what people are using it for all that and the one that bill mentioned rib does look really interesting if you're ever doing like a game jam or just playing around with implementing games might be a fun one to take a look at oh and if you're wondering i did look up the logic programming prish language that bill mentioned it's called verse and i'm pretty sure we're going to be having an episode on verse before long as well that's almost all for this week but before you go please take a moment to like subscribe rate share with a friend and generally you know feedback if you've enjoyed this episode we'll be back next week with another so until then i've been your host chris jenkins this has been developer voices with ginger bill hall thanks for [music] listening