uh thanks for inviting me jans it's always a pleasure to to come to meeting c plus plus both the conference and the the user group meetups hi everyone thanks for joining us so late maybe for some of you some of you might know me i've been involved with various projects for the past 20 years i've always built tools i've worked on advanced installer for 17 years building tools for developers and it pros i built some open source tools that some of you might know and use and recently i joined the visual c plus plus team at microsoft helping to improve the visual studio and vs code experiences the tools that i use every day so if you have any questions feel free to ask them post them in the q a tab i'll try to address them as they come along if they fit an natural stopping point during the presentation if not i'll defer them to the end and make sure i address each and every one and of course i invite you to join the lounge after the talk where you'll find me and we can have an unplugged discussion around these topics and maybe share your experiences about the things i'm gonna talk tonight and there will will have a chance to to be in a more relaxed context and and and chat freely about related topics so what's so spooky about this this presentation some people ask me about the the title and it's it's not it's not my quote it's a it's related to a famous quote by einstein about quantum entanglement and the fact that the fates of tiny particles seem to be linked to each other even if they're separated over long distances and i feel this is strongly related to what i'm trying to show here tonight about objects remote objects interacting through loose coupling and an alternative title for this presentation would have been revisiting observers or maybe subscribe to observer but i went for the catchy title right from the start i have to say that i kind of hate the term design patterns and the reason for that is that it implies that there are universal universally applicable solutions to some common code scenarios and in general just codifying existing practice into some rules like a recipe that you we can follow blindly it it might be a comfortable path sometimes but it's it's rarely the optimal one in general each situation is unique and it usually has a unique associated solution best fitted for the business logic at hand and in general following recipes not that easy anyway but there is value in in having a uniform chord structure throughout the project and these patterns as we like to call them because we we tend to identify them and see them repeated throughout our code bases have a value in in easing understanding and easing extensibility of the projects especially in a collaboration environment so this topic is not to be discarded just yet but it needs a discussion i'm sure almost everyone is familiar with classic design patterns by the gang of four [music] as they're colloquially called but i find it a bit too formal and dry and for someone who is trying to familiarize familiarize themselves with these concepts and these patterns i would recommend starting with something more accessible and maybe more entertaining and i would recommend bob nystrom's book game programming patterns where we we get to see common patterns in a more applied and presented in a more direct manner with nice illustrations and you know examples so i for someone who's starting out to learn about these kind of things i would definitely recommend starting with this book and maybe then go for the classic gang of four if you prefer the video format i highly recommend this presentation by klaus eagleburger from cppcon design patterns facts and misconceptions short abstract here just to give you a tease and maybe pick your interest he talks about facts and misconceptions and common misunderstandings among developers about design patterns in general and about particular patterns in particular and it explains this presentation explains what good strategies of software design are and how design patterns fit into these strategies and what these idioms imply in general and with specific patterns analyzed so feel free to watch this presentation when you have the time focusing on observer pattern and this would be our main subject for this presentation in terms of with inspectable properties of objects we have to think these years of object-oriented influence from other programming languages and from popular frameworks what have we really learned from from all of this thriving ecosystem of idioms and frameworks and can we leverage these borrower techniques in c plus plus in a value-oriented context which is prevalent in c plus plus world and does c plus plus benefit from other special considerations or issues that might arise from naive applications of the observer pattern and we'll see examples so we'll revisit our old friend the observer pattern from theory to practice i'm not gonna try to offer this solution but because i don't think there is one but we're gonna examine trade-offs of several possible implementations and of several parts tricky parts of dealing with this pattern in various scenarios from and with examples from a real project let's start from the basics 101 with observers observers are basically everywhere in various forms if you can think about model view controller or model view view model as frameworks of modeling ui you can think about acute signal slot mechanism that people might be familiar if you're using this framework but it's not just about gui and model interactions this pattern also applies to models model interactions and the way we send information across a network of objects and the way we couple remote objects and i'm gonna focus on that so i'm not gonna focus on typical idiomatic usages in in popular frameworks like gui frameworks i'm going to focus on model to model interactions and these connections these remote connections between objects and i'll give them special names just so that we have a common vocabulary and i'm not too vague when i'm expressing myself i'm going to call them actors and actions my slides are also color coded on this pattern for people that are able to observe these nuances so a subject or an actor doesn't know the type the observers are it just knows that they exist and it has a means to notify them when certain actions occur and this is how we express low coupling between these objects so we have the actors and we have the observers and the actors perform some actions that the observers might be interested in it's a subscription model and you can think of it as a tuning into a particular radio station or a particular frequency that would be the event that we're interested in from a particular object and this is where inspectable properties of remote objects comes into play and that's why i saw this connection with the spooky action at the distance and we're gonna see some spooky action for sure in a few a few slides ahead so a very basic example here is we have a setter for particular data payload and when this is changed we are interested in notifying some observer objects about the fact that the internal state changed because they might need to do something as a result of this as a consequence of this so it's all about side effects here the the the whole idea of inspectable remote objects is about side effects and if we think about the subscription because we're gonna focus on on the subscription and unregistration or de-registration if we think about subscription observers are added in a certain order but we have to ask ourselves in terms of the intended use or the need in a particular application do they need to respond in the same order and furthermore let's say we we we have them stored in a vector furthermore how do we handle these these registrations is a plain old pushback on our vector of observers good enough for subscribing is this the only possible strategy what about adding an observer more than once let's say we don't want to destroy to allow this to happen then we might do this check before adding a new new observer to see if we already have it registered but there are situations practical value situations where you might want to register the same observer twice and we're going to see some rationale about this when we talk about local reasoning or subparts of a particular function or tasking in within an application so in the situation where we do want to allow oversubscribing do we expect the observer to be called twice for the same event and how do we differentiate between the two instances we're talking about the same object instance but i mean the two sequences of registration which was the first one and which was the second one do we notify both of them and if so in which order and this is relevant for local reasoning it's easy to analyze this this idea in in if you're have a global view of the the object network and if the application or the interactions are fairly trivial like in in toy examples it's fairly easy to reason about these kinds of things but in in complex object networks and in large applications where components might be very far apart or even more where you might have components that are pluggable or components which can appear and disappear from the system and these components while registering in the system let's say a plug-in or something like that might become interested in receiving event streams from the the framework that they register into and when they are on the other side when they are unplugged we need to stop sending those signals to the to those components so the the the image here could get complicated but in let's say we have a a local scope or a local function that might be doing something important and they need to receive a particular notification while doing this block while executing this code block and it will choose to register itself at the beginning and the register at the end and receive events for the duration of this code block or this particular action or tasking within the application so the obvious problem here is what happens if the observer was already added before and in our local reasoning because we don't know what happened outside of our scope we we're trying to be careful and not depend on outside states so we add and remove because we're interested in these event streams but at the same time we don't have as this is constructed we don't have any information to know if we are the only one regi the only ones registering this instance or not and i specifically chose the the this as observer so that it's obvious that another function might have done the same so a fairly easy solution in this case would be to have some kind of raii register object that can keep track while constructing to keep track and hold on in internal state the fact that it was the one that regis the first one that registered this particular observer and subsequently deregistrate if if that was the case in the destructor so in order to do that we have to signal our register function has to signal out the fact that the registration was successful so it was the first time this observer was seen in the system or not so going back to over subscribing and adding an observer more than once and so we're removing the check for the existing instance if we're over subscribing do we expect the the observer to be called twice for the same event and this is tricky and in some situations there are legitimate cases where you would want that but there are there are other complications regarding a particular particular order of registration and notification again related to local reasoning and restricted lifetimes so if we if we if we we're talking about unsubscribe and removing observer in the in case we actually are it is meant to be removed and we're not in the situation over over subscribing then it's fairly easy but in the multiple registration scenario we might find a particular observer in in our collection and we choose to remove it because that was ins we were instructed to remove it by this api but how do we know if we are removing the wrong instance if we're removing if we have it registered in position 3 and in position 48 as the code is written right now it will remove the first one the first one that is found and that might not be what the code expects so in general of course it's not good practice to to be sensitive to the order of notifications so the code should be really resilient in case two events are fired and multiple observers are notified about a particular event in general we should not be sensitive to the order of notification of different observers like observer a was notified before observer b so in general it shouldn't be it shouldn't matter in reality these events and their implementation blocks are not pure functions and are modifying some kind of state in our global network of objects so they do have side effects so in in particular cases code might be very sensitive to the order of notification so now if we remove the wrong position the wrong instance although it's the same object but we remove it from order of notification three and we leave it in the position 48 now 47 because we're sliding so there are fewer observers in the list we changed its relative notification order relative to other still extant observers for that particular event so bugs will will happen so we have to be very careful in situations like this and i'm not saying they are outright bad ways of organizing code because there's legitimate situations where you do need oversubscription but we have to be very careful with unsubscribing and about a sensitive order of notifications if we choose to take the route of removing all instances then it's easier fewer complications but it's not always possible to do this and i'll never miss an opportunity to teach about a safer pattern in modern c-plus plus instead of using the awful you know erase remove idiom prefer to use the c-plus plus 20 function that is much safer and much cleaner than the raze movidium i have a short presentation at accu about the pairs of eurasia movidium and a good rationale to go for the c plus plus safer option the video will will be out in a few weeks i'm sure still is still in processing so who should be notified first my partic a particular valid strategy might be to treat this vector as as inserting at the beginning every new observer so that we we have some control of the notification order this might be a valid case in some scenarios i've seen this done i've seen other strategies of generalizing this and building priority packets having various rings of observers like most important observers less important observers or when we talk about sensitivity to the order of notifications so we have we may have ring zero observers that need to be notified before all the other ring one observers and before all the other ring two observers and so on so there are valid situations where you might need to construct specific priority buckets to group notifications relative to each other so i've seen strategies like this and then we can amend the api and and have something like this and pass the the priority as a parameter but what happens if we have an observer edge regis what if an observer is registered by mistake with a different prior with a different priority in the model of oversubscribing we might have the same observer registered with let's say ring zero the first time and registered with ring one the second time and what happens then and because weird side effects might occur if they're notified in different rings and even more complicated scenarios around registering these observers so we need to be very careful about using these patterns and now on the other side of things where after we have observer network all set up and we have all the connections linked let's talk about the mechanics of broadcasting these events and very simple implementation might be traversing our container of observers we have we had a vector previously so traversing the vector of observers and for each one trigger a particular event let's say the widget changed from our previous example with the data setter that would be the broadcast on the other side the observer some observer because there might be many some observer will tune in and it will receive this notification from the actor and react in some way to the changed object and maybe query something about the sender of the notification and so on maybe ask for the new internal state or new value something like that but there is an interesting particular case that i've seen pop-up and that is the one-shot observers that's what i call them and that is when an observer registers for a particular event and cares only about the first occurrence of that event so after the event happens this particular observer doesn't want to receive further notifications from that particular sender about that event so one way of dealing with this and i've seen this in practice is that while we get the notification let's say which widgets changed from this actor we do some something that might be important to react to that change and then we deregister ourselves so remove observer of this this being this instance of same observer and we do register because we don't want to receive further notification we're done we've seen it already and we don't want further events like this where there's there's a problem here and the problem is that there's a chain of of invocation if we're following the call stack it's more obvious and it's it's it's easy to see when we when we call this actual event handler which is changed we are doing this in our for loop that traverses the registered observers for that object so while we where where we're inside this callback which is changed in a synchronous manner we call remove observer and that causes the our erase implementation from remove observer we've seen it earlier when i mentioned the razer move idiom so that in turn calls erase and removes this instance from our observer list but we we we're we're happening to be inside the iteration look for this observer lists for this vector so we're we're removing something from this vector while we're iterating it so trouble there's a kind of a classic idiom or classic fix for these kinds of issues not just observers not just for observers and that is to use zombie positions or using sentinel values instead of deleting those instances so instead of erasing we're placing a sentinel value in this case we because we're holding pointers we can place a null pointer there and then we clean up and the reason why this works is because we can when we notify observers we we have to while we traverse our list of registered observers this list now may contain the zombie observers or observers that deregistered so we have and we now have the that sentinel value of null pointers so we have to add an extra check to see if that observer is still there before sending a notification and of course we have to do some cleanup at some point and remove those instances from our collection and that is easy too another case particularly when we're dealing with complex systems or nested functionality that might needs observers is that we have recursive ads but they are more rare in practice and the problems are similar as the problems we've seen with recursive remove observer another issue around such object networks is that sometimes we're dealing with really small objects and these small objects might be interested in having observers and notifying about particular changes let's say a simple case like inspectable property like a data setter but if we're dealing with small objects then it's not always affordable to have an intrusive list of observers in that small object because first of all we do pay the cost of actually having a vector there and maybe many instances in our network of such small objects because in many scenarios when we're dealing with small objects we tend to have lots of them and some some or many instances will never have a registered observer so they might have this ability to have observers but they might not register any so then we would we would pay the cost of storing an empty vector in each of these object instances and an empty vector is not tiny so in in many situations this is not acceptable one way to to deal with this that i've seen in practice is using some sort of lazy structure like a lazy vector let's say where we make use of operator star and operator arrow and we fold in the vector lazily the first time it's needed so in general we just paid the cost of a pointer and in in the situation where we actually need that instance actually needs observers then it will create the on-demand a new vector where it will hold the collection of observers and when the last one deregisters we can also de-allocate this block so fairly common strategy that i've seen to deal with this but if we have lots and lots of these again might not be the the best practical solution and even in that situation storing a pointer in those objects again might not be practical even the cost of a single pointer in that structure might be too much for some scenarios so another strategy that is in use is to have an aside lookup structure a lookup record of all observers for each object so i intuitively named it global bottleneck because kind of is and we can have a mapping of all these records for so for each actor that has gained some observers we have its collection of observers associated so in this side structure it is a bottleneck because if we have lots of these instances flying around okay you no longer pay the cost of storing it intrusively but we now we are gonna hit that this global data structure and you're gonna have contention on this structure for all your all your objects in in the object network so might not be the best strategy for or purposes but here is a strategy that people might want to use if we're talking about threads because we have to acknowledge the presence of threads in in and we have to deal with them in our object networks i like to call threads like multi-lane highways to crashes because sometimes they are and the immediate solution to this is to to use a mutex and we have to guard each such function let's say from our previous examples that setter we add observer move observer and the notify functions they all have to be guarded by such mutexes and if we're going back to the recursive ad or recursively move scenarios of oversubscribing first thing that comes to mind is using recursive mutex of course because the name is right there but as it turns out using recurs recursive mutex is almost always a bad idea and you can easily get yourself into that locks so it's not bulletproof it might work in a particular fairly simple scenario but you might end up dead locking in easily in the future so more about that later i talked about values at the beginning in our c plus plus universe and squaring the circle as it were a value-oriented design in an object-oriented system when we're talking about objects on the heap and object networks and reference types how do we reconcile that with value-oriented design or ephemeral objects that are created moved and destroyed fairly quickly i do strongly recommend this presentation by juan peppolivar puente value oriented design in an object-oriented system it's a very good presentation you can find it in multiple incarnations some older some newer i've linked one of them here it's it's a fantastic presentation that goes deep into scenarios and a case study for library to deal with such situations and how do you compose operations and deal with values and kind of use the type system to achieve things that sound very functional in way but it's at the same time very c plus plus so i do encourage you to watch this presentation if you haven't seen it already or maybe watch it a second time i know i did so when in doubt always make copies that would be my recommendation around threads it's always safer to make copies and move things around than actually trying to protect stuff and with that in mind if we're going back to our notify observers function where we traverse the list of observers and called the called our broadcast event which is changed as we called it and a fix a potential fix for this would be to actually have a copy of the observer list and use the plain old mutex to just very regionally protect where we need to for example when we copy the observer list when we modify the observers and when we traverse to broadcast this event we are actually gonna traverse the copy we just made so we we don't hold the lock for the whole duration of the event broadcast so i think this is important i i failed to highlight this on the slide and maybe i should have it's important that we don't hold the lock for the whole duration of the broadcast and i'm going to mention that why that is in immediately in in the next slide it's in general it's important to hold a lock for the minimum amount of time needed and even more important to to be aware of holding locks when calling external code and we when we're broadcasting this event which is changed we're calling into external code so we don't know what those objects will do as a reaction to this event and for sure building a copy and traversing copy avoids the issue with iterator and validation and with corrupting our observer container there if someone decides to re-register or unregister as a consequence of this broadcast but the code is messy and there are situations where even this combination might fail i'm gonna i promise i'm gonna go back to it and explaining the the holding the lock portion of that slide but before i do that i should probably need to [music] point out that there is a functionality that is worth studying and that is from cute framework i would encourage you to look into how delete later from queue object works in general if you even if you're not using qt as a ui framework i think it's instructive to understand how this mechanism works and um yeah it's very related to the the things i presented here so that would be homework material yeah if you're in interested to learn more about idioms like this of course i have to pitch the presentation by tony from a few years ago at c plus plus now around thread safe observer pattern and there in this presentation which is it's basically just a full-on demo rather than a presentation tony goes through several scenarios of registering and registering observers and firing events at various uncomfortable moments and breaking the system in all the ways possible and there you're gonna see events in the wrong order and crashes and even even when when we're almost sure that now he's got it right he nailed it down it's now it's gonna work he will find a way to disappoint and and find the corner case where that it will fail so a very instructive and at the same time disappointing outcome in that it's it's very difficult to build a robust object framework with in the presence of the observer pattern and the idea there is not to dismantle this pattern or to discourage its usage the idea there is raising awareness this very same thing i'm trying to achieve here in that there are very useful cases and there are tremendous advantages of using this low coupling mechanism in in complex object systems but we need to be aware about the particular situations in in our in in our application and how best to implement a particular strategy that we we need so definitely worth watching this presentation it's highly entertaining so going back to threads i promised i'm going to explain the holding the lock portion of that previous slide in in a multi-threaded context it's almost impossible to implement the solid observer pattern and that would be the the takeaway from tony stock i mentioned earlier and in real code you can't see the deadlocks until they happen in in toy examples and anything that we might build up here and in in tony's examples which are fairly trivial and easy to see in at a glance on a screen it's obvious when a dot block might happen if you have some experience with that looks but in in real code when we have complex interactions and far away reaching codes you won't see it until it happens until you hit a particular corner case and it it happens and the rule of thumb there would be don't hold the lock while calling unknown code and that's why i was explaining that holding the lock while broadcasting the message it's a very bad idea because broadcasting the message means you're calling external code and that code might end up taking in indirectly taking that lock that you're you're holding so you your deadlock potentially and not even know it or but in general holding a lock while calling unknown code has consequences and better not do it some say that it's a code smell that you need to do that but in general it's not a good strategy so anyway going back to the intrusive nature because so far all we've seen is intrusive designs so we we would want to encapsulate all this functionality into a separate let's say actor facility that we might reuse in this situation i named it to actor and it's templated on the particular widget that might use it and it will inherit all the necessary boilerplates because you don't want that in your in your mixed with your object functionality so on the other side for the remote observer most probably we would define a narrow interface there narrow protocol let's say i observer and we register on construction let's say and the register on destruction and we override a particular event let's say we might have a list of potential events that we might care about and do something as a consequence and of course you don't have to forget to cancel so always strive for something that is fairly automatic and easy to to keep track of so something like rea i have to mention optional protocol methods because this is something that we don't have in c plus plus other programming languages let's say objective objective-c or swift have optional protocol methods so we have to deal when we define this interface between our actors and observers we might have plenty of events that might possibly be fired up so a particular observer might not be interested in all of them so classic way of dealing with this is having stubby implementations and our spectator observer will actually implement the observer interface indirectly there via this stub stub class so that this particular spectator will override just the going to sleep event because they don't care about all the other events that might happen from a particular actor so fairly easy but necessary boilerplate because we don't have actual language support so yeah if we have let's say now we have the situation where in in a particular spectator in a particular observer object we're interested about multiple actors and multiple actors triggering let's say the same event we're interested about going to sleep event going to sleep event from multiple actors and i'm trying i'm gonna try to def name them differently so that there's no confusion i'm gonna call the first one the first type let's say it's an actor and the second type is a thespian and our spectator is interested about this very same event or events but just one would be enough to complicate things so we're interested about the going sleep event from both actors and thespians and we see the registration fairly intuitive for we add ourselves so we are the spectators this is this is spectator so we add ourselves as observer to the actor and as observer to the thespian and remove the same but we have a problem here because we have the same callback function we have the same event name and how can we reconcile that and as always every problem can be solved with another level of indirection and the solution here and if by the way if you recognize this pattern you've been probably probably writing c plus plus for a while it comes out of the loki library by andre alexandrescu and we can use the technique of using a type tag here and we construct a type with this facility into type let's say fairly trivial way of constructing such a unique type and the the way we're going to differentiate is using observer indexes let's say zero one and and name them so that we have unique instances and and how will that work so our staff observer will have various it's now a template on based on this observer index and it will have various event names here but the first parameter of each of them is this type tag that we're going to use and we have to build a proxy this this is the level of indirection i mentioned earlier we have to build an observer proxy and this observer proxy will be the one that implements the observer interface that we define our protocol and it will take a concrete observer and an observer index so it will be the unique type id and because this proxy that we're building is the one that implements the the protocol the observer protocol that we have in place it will have the two let's say the two events staff added and stuff removed i will name them here so this will be unique functions in this observer because this is the one we're using so they come from you see the override keyword they come from this protocol i color coded them appropriately and inside they will call the appropriate stuff added and stuff removed the corresponding event names from the actual observer the ones the the ones that have this type tag the ones that we defined on the previous slide here so they will call the appropriate the appropriate method by constructing a type id object just for the the purpose of type tag dispatch here so no other purpose but to pick the right overload and we define them easily let's say we for the example that we we set out to build our actor would be a staff observer the first one index zero and its proxy would be staff observer proxy of spectator with index 0 and the other actor type we call the thespian will be a staff observer 1 and its proxy would be staff observer proxy of spectator and one where spectator is the observer that is interested in both actors and thespian events and now when we define our observer our spectator that is interested in both actors and thespians so it will use them as bases so there will be staff observer zero and staff observer one these are the the early type aliases and when the spectator is created it will add as an as an observer the actor proxy to the actor rather than add itself like we had previously and it will add the thespian proxy as observer for the thespian type not itself previously we had an observer of this and this will construct this in directions so every time a notification will come it will come to the proxy and the proxy will forward it to the appropriate spectator which is this one but to the appropriate overload of the event in the spectator so if we define the spectator implementation we can see we have two events that are called going to sleep so there are two events but there are distinct functions one will take a type tag of the type observer proxy's actor type id and the one on the other one observer proxies thespian type id which is just a tag that will help us build an overload set and now our observer has a regular structure where we can clearly see that this event was triggered this event is called going to sleep and it was triggered for what type it was triggered for from an actor type and this going to the other going to sleep event it was triggered from the other type or thespian actor type so we can differentiate between them so we can have multiple events from multiple actors all within the same spectator by using this technique of using proxies and registering the proxies as direct observers and the proxies in turn will fire up the right overload in our spectator class so i found this technique very helpful and furthermore the the staff observer and staff observer proxies that we i showed in the previous slides can be used for any other spectator type and for any subjects and actors the the only specific part is the the protocol part or the interface that is used so the everything else is usable so we can use these template classes we can use them for different actor types so different senders and in different observers so we don't have to build new ones the only specific part is again the protocol so the events that are mentioned in that interface if we have different set of events or different protocol then we you would we will need to build a different different such usable components so this is a very useful pattern to to leverage multiple tuning into multiple events from multiple centers at the same time in closing i'm gonna mention a little bit about global state in general this pattern comes into play when we have observer networks and in general observer networks tend to form global state and we have to be very careful with about all these interactions and this is kind of the same reason why i dislike sharepointer everyone who knows me knows i really dislike sharepointer is that it helps you build huge object networks of and it builds global state and global connections between those objects that are sometimes very difficult to reason about and one particular consequence for using the observer pattern in such networks is that you can easily end up in in memory management issues you can end up with that subjects while having these observers active and running you can end up with missing observers and you can be blissfully dangling so we have to be very careful in how we orchestrate this dance of registering and unregistering and and and do it in a civilized manner and doing in a consistent way let's say associated with construction and this deconstruction of objects or in particular actions that are symmetric in their in their behavior or in their you know lifetime implications so we we if we arrange that we do our registrations and de-registrations carefully then we can avoid hitting memory management issues because they tend to be associated with improper usage of these loose coupling methods so we have to be careful not to end up like our funny little sketch with the dead parrot and with that thank you for tuning in and being good observers and i'm open for questions if you have them now or i'll meet you in the lounge for unplugged q a