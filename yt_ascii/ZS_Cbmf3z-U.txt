what is up guys in today's video by popular demand i'm going to be showing you guys how to put raw assembly onto your raspberry pi pico the way that we do this is actually surprisingly simple so i think you'll be really impressed with how quickly you can get it to work too on your device i have some starter code here it looks a lot like the blink led tutorial you have your top two lines where we include some libraries these three lines here we define gpio on being one off being zero and the led pin being 25 there's no change to previous tutorials from there and then here we're going to start with c the way this is going to work is we're going to actually write a function in assembly and then we're going to link it in at compile time so we have control over what assembly goes onto the device what we're going to do is we're going to create a function called loop that function is actually going to be an infinite loop that the raspberry pi pico cannot return from this will be a good test to make sure that our assembly is actually getting written right so if we do gpio put onto the led pin we put a gpio on and then we call our loop function and then we put gpio put to the led pin gpio off in theory if this doesn't return this led should stay on and never come back right so that'll be a good test so now we have to actually write the loop function how do we write that in assembly well first we have to make a new file and i'm going to save this file as assembly.s now we're writing assembly right this is arm assembly like all my other tutorials first what we have to do is we have to export the symbol of the loop functions that the compiler can use it right and the way in assembly to do that using the standard assembler is global loop that says i in this file i'm going to declare a symbol called loop and the object file that we create will export it then we're going to define the loop function and loop is a label where we branch to loop right so this will infinitely just run a circle here forever no no real tricks there right so let's walk through this again we turn our raspberry pi pico on we set the led gpio output port then we turn the led on we go into this infinite loop we should never get here and in this infinite loop we loop forever okay so how do we compile this cmake makes this very easy on your project line you need to make sure you include assembly as an allowable language on your project and then in your add executable lines you're just going to add assembly.s that tells cmake when you build your project to include this as one of the creatable files or the object files you want to link in and it knows to use the arm assembler to do that so it's actually really simple and then you're going to do the standard make dirt build export your sdk file cd into the build directory and then cmake dot dot what do we make takes a minute because cmake is actually building the entire raspberry pi pico library and there we go boom we have our executable and one easy way that we can actually confirm that our loop got written into our code as raw assembly is we can do arm none eabi object dump tac d on the output name of our file which in my case is assembly on rp2040.elf type that into less and what we're actually seeing here is the full output of the entire firmware that will go onto the raspberry pi pico there's a lot of extra code here that you didn't write that the pico sdk actually created for you but if you type slash and hit loop it's going to look for the word loop and our output there's a bunch of them here but eventually after we look for it a few times by hitting slash and enter we will find our function here right so we actually can see main goes out and it calls standard i o in it all it calls gpio in it and then we go to our loop great okay so that's in the code so now let's actually put it onto our raspberry pi pico so the way we do that we copy our assembly.uf2 file which is just a different file format and i have actually a video coming out on what the uf2 file actually is but it's pretty interesting how they made this work copy that onto media user here boom and so now you can see over here i have the raspberry pi pico put out the code is running but we don't get to the part we turn off the led which is pretty cool right okay so now we've confirmed that we are in this loop and our code is running infinitely forever and the processor is very sad so now that we have the ability to write assembly raw for the raspberry pi pico who cares like what are we gonna do people typically do this when they have code that they want to not fail or that they want complete control over what happens so we are actually on the processor in supervisor mode so we have the control of the processor completely and we can do some really cool stuff like for example there are some instructions in assembly where you can disable interops for example so being on the processor there is a chance that things like timers and the uart interrupts and stuff will go off and it could interrupt your code and if this is time-sensitive code you don't want that to happen so what we can actually do in this function that we call an assembly is a thing called cps interrupt disable all of our interrupts so what this instruction does it's a a supervised remote instruction it masks the flags in the processor that tell the processor to do interrupts so as we execute the rest of this code here there is no way for this code to get interrupted unless a processor crashes right like it it will not respond to irq's or interrupt requests so we can do some do time sensitive stuff and then to re-enable the requests right because we don't want to just leave the processor like this forever we want to do cps interrupt enable these flags and then we can branch exchange lr actually sorry branch lr and that's the assembly for return now when making this video i actually had a really weird error where i was trying to show you guys you could do gpio puts from within the assembly file but i actually ran into a linker issue where it doesn't know where the gpio put function lives the reason for that actually is that the gpio put function is an inline function in the pico sdk which means it's not externally linkable from assembly files it was kind of weird i had to figure that out it took me a long time but the way that we can actually do gpio puts is we have to write a wrapper function called my gpio put and i'll take a pin and a value and it's just going to call gpio put for us in c pin value and then return and then from within the assembly function we can actually call my gpio put and take out this global here and that works so we can set up the registers right to do r0 actually load into register r0 25 load into r1 0 and then we could do my gpio output and what this should do is this should go here we go into our sensitive function where we do time sensitive stuff and in this case we're turning off the led and then it should turn the led off so we should be able to remove this and the led should for like 10 clock cycles turn on and then it should turn off let's test that real quick so we're going to make this copy that boom and the file was put onto the raspberry pi pico it turned the device on and it turned it off really quick anyway guys i hope that was helpful i hope you learned something if you did do me a favor hit like hit subscribe and i'll see you guys next time thanks for watching bye