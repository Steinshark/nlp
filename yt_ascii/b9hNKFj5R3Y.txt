anyway who here has ever heard about ecs or entity component systems okay not even a half i would say i'm i'm bad at math just get out immediately out of i'm not a good math person but that was roughly half for the camera and maybe a bit less than that so that's good that's my audience we're going to learn together what it is about and what learnings we can take from it i'm not trying to sell you an ecs i think i'm maybe i'm getting ahead of myself a bit i'm not trying to sell you an ecs but i'm going to explain a bit what it is why do why did the concept come to exist and what you can take home even if it's not really a thing you can entirely use so if you ever been to like any game developer conference ever this is like if you ever get a bingo card this is the this is the the drer this is the one that always wins because regardless of the talk one of the first three comments would be by the way have you thought of using an ecs that would solve all your problems regardless of the talk you can talk about animation audio design doesn't matter use an ecs he will solve all your problems that's that's that's that used to be the talk like every time i watched the gdc talk that was guaranteed top three questions and and i i tried to do some google trend search just to just to see you can see there was a big spike somewhere in like 2017 2018 and then the hype kind of died down and then it's still backing up but i don't i i i don't know charts much i i don't really offer financial advice but it does look like it might be going down again we'll see so and also bonus apparently sweden is the chart so yeah it goes far i i live in sweden i don't speak swedish but it felt felt good i don't know why sweden is like 100% on ecs that's not entirely my experience but who knows anyway hi i'm matthew i'm a i'm a tech lead at the paradox development studio where i work on hearts of fire run and over stuff that i cannot talk about or else i'll be fired but yeah it's a video game company we make historical video games you may have heard about us so this was a a very difficult talk to work for me because i i knew over summer i wanted to talk about usually i talk about what i've researched the the year before that that's how i go for conferences and i was i i wanted to talk about that exploration about data oriented design and a bunch of things related but i couldn't really get the talk out so what i did is i went to my meetup and i say hey i have a talk about ecs but i don't really know if it's about ecs please come at the end and tell me what this is about i didn't get the feedback i hoped but i got a really good idea in my shower like four days ago so i reed half of my slides and i hope this has a better connection to to the thing if you've ever seen actually maybe another self likee appreciation as anyone have you seen my one of my talks before oh i have some fans nice okay for the camera there was everybody in the room by the way thank you okay so i made a talk about profiling i think like a year ago i made one about multi fring two years ago also based on my games one day i think i will have to talk about allocations but the the the thing that that i keep running around is basically it's performance related and it's usually things that i realize are bad for performance in the games i work on and how do i try to bring the after i solve some issues or i notice some issues with that or fix some problems how do i bring back that knowledge and i think this is really the working the the the the the thread through through all the talks like how can you profile your performance problems and then how can you use threads how can you fix your location which won't happen one day and today we're going to talk about caches data local and how does how does ram work basically that's going to be our goal so we're going to talk about what is ecs or entity component systems you will probably be like tired to death of hearing the words ecs by the end of this talk i'm i'm warning you in advance we will talk about data oriented design which i think is going to be maybe the meat of this talk and in general cach friendly data structure and why does that what does that mean and coupling or more importantly decoupling your code and you'll see there is a very strong connection to some degree between data oriented design and like fry thread friendly design but first let's talk about hardware because you know this is a c++ conference we really like to talk about hardware we like to say that we're very close to the metal to some degree so let's let's thought about that we can start by giving some appreciation for the people who make the cpus that make our job exist first we can eat and two they're actually pretty good at what they do like i don't know if you ever looked at like the actual rle numbers of how much stuff your cpu can do on a daily on a second on a nanc basis it is crazy like most b basic aric is like a couple cycles and you know i again i'm not a physician but from what i'm told like a cycle is like you divide the one by the frequency so like if you have 4 ghz that's about like something less than a nanc which is just an amount of time i just can't really be present in my head i'm told the best way to figure out the speed of light is to use like how much to figure out nanc is to figure out how fast the light can go in a nanc to give you like a a reasonable physical distance that you can make your head about it's it's nothing like a nanc is nothing again your cpu can do four billions of those in your cpu has four gz do does four billion of those things in a in a second that's that's an insane amount when i was in school i was taught to avot divisions in square roots in code because that's really bad and your cpu can't handle that that's i'm not saying it's a lie because it is technically way slower by maybe like a factor of five or 10 than making an addition or subtraction but it's still nothing like again a few dozen cycles again at 4 ghz your cpu can crunch like maybe not a billion of dos but probably hundreds of millions of dues per second i don't know how many numbers you need to divide but i i i don't think that's going to be your performance bottleneck and then if you have simd and every cpu for 20 years i've had simd you can multiply that by four or eight depending on how many levels of avx and n instructions you you have available it it is absolutely insane and that that's that really the bit where i like the cpus we have are really stupidly insane and i think that's been a big thread through the talks i've been having lately it's a simple but very important realization that none of the what we do should take that much time given how fast those things are and yet well we all have performance problems i mean i don't know who who who doesn't have performance problems okay i'm not lying this is nobody in the room everybody thinks like they could get a bit f fas if it could so here's the problem here is one of the problems that's the the problem we're going to focus on today the problem is memory right because there's this thing called physics which i'm about as good at as with math but it says that you can only go so fast so if if if things are too far away so basically your cpu is very fast as long as whatever data it needs to read like the those those bits or physically close to it and by physically close i don't mean in the same room or even in the same computer it it has to be on the chip if it's not on the chip it has to f it has to figure it out another way so basically what i mean is if it's if it's in the ram you're out of luck like if it's in your if it's in your cpu registers or in your l1 cache which are like data storage on your cpu then you you're fine you just it's it's really it's fast it's it's it's collocated so it can operate at the same frequency as the cpu but if it's not if it's somewhere in your ram sts and don't even get me started or if it's on desk or on a machine on the other side of the world like that we not even talking about that today we're talking about like if it's in your ram stake instead of your cpu it's too far away and i have a couple slides to explain exactly how much because i don't think it's always easy to grasp so here is a here's a very accurate representation of a cpu and some ram sts it's about 100 ns roughly speaking and as far as i know that number has not really changed in the past 10 years i mean they tried to do some stuff with like ci cls like super gamer ram but mean roughly speaking 100 ncs if you need to actually fetch some data from one of those like tiny chips and put it in this chip too scale or not i don't think it's too scale at all so 100 nanc okay but again what's the nanc we talked about that before that's a very hard number to reason about for most people like i i start complaining when when it takes a couple seconds for an application to to do a thing and probably if it doesn't respond in the second i'm i get angry but 100 nan seconds i don't think anybody can measure that in their head like that's just physically impossible for us but as we said before it's like a okay it's a 100 cycle at 1 ghz so already we start having like a a frame of reference assuming your cpu is running at 1 ghz it's not right it runs at like two three four ghz five if you have turbo but for n of magnitude is good enough if if if one arithmetic operation is like one nan one cycle so one nan seconds well fetching the same data from ram is 100 nond so it's 100 times slower to fetch the data do the addition and then push it back to whatever memory cell you have then to add it like if you have to fetch it add it and then push it back it's going to take you about yeah 200 200 nan seconds to do the the round trip and one nanc for the addition you're like you're wasting your time you're basically the aric doesn't matter what operation you're doing doesn't matter what matters is how fast it can get to your machine and to really hmer the point i want to compare that with like the over caches we have on your on on on a modern computer so if it's on a register it's usually considered free like it's basically as part of the as part of your operation that does like an add a multiply whatever other arithmetic your cpu does writing or reading it it's just free it doesn't really have a measurable impact if it's in your level one cache which is also on the chip about half a nanc you can measure it it's it is technically not free but it's as close to three as it can get if it's in your l2 cach then you start being a bit slower it's four nan seconds but still like those numbers especially if you start normalizing them like assuming that l1 cach head is is one it's a maget of it's it's time s and time 200 and to really make sure you understand this i'm going to show you a small animation that i i saw in the do talk and painfully recreated in in google slides because it's i'll see okay so i'll try to scale to show you the time to fetch so let's do l1 that's done you know you haven't you barely had the time to blink okay let's fetch for l2 cach with the same like time scale okay let's do it okay well i could see it going right so it's not as fast but still i mean if we compare it like okay this is in instantaneous and this is close enough all right let's fetch from ram now i can take a drink almost halfway there wait ah ah you almost got it you're almost going to be able to increment that pointer by four almost almost there we go and now we can d reference it and do it all over again because it's another part of the memory cool so i think you get my message right memory access is slow it is stupidly slow compared to what your cpu is able to do and it's basically ball necking a lot of things if you get in the wrong situation it's really bad and that's why engineers have spent the last 20 30 years making a lot of cash every time you see a cpu now it's a big argument how big the cach is and this is the reason is because l1 l2 l3 caches are trying to basically hide that latency from you by trying to get the data or keep the data around to help you but there are limitations and that's what i want to explain a bit this is what we call data locality and that's what i will explain okay so your caches like let's just say you have an l1 cach and it has a bunch of lines i think each l1 cach is about 64 bytes it's not a lot but you have a bunch of dos i can't remember the size of top of my head but you have a bunch of do and the idea is every time you try to read some data in memory the cpu is not going to just fetch the two bits or the not bits but bites like if you ask like to read like an inch four bytes it's going to be nice with you it's not going to just fetch those four bites because that would be super wasteful it's going to fetch those four bytes and everything around that like on a 64 byte segment basically the reason is well first of all it's just throughput like if if you can't beat the latency try to beat it by just more data because maybe you can just have more stuff going on your bus so that's the first thing and the other one is just usually or possibly when you access a bit of data there's a high or reasonably high chance that the next bit you will try to access is basically the one next to it which means it's already there we already paid the cost might as well might as well do it right and that's what that's what caches do right so if i keep reading my memory cell assuming it's an array for example like i have an array of ins in memory and i try to iterate from it h that's what it would do right i would just go through memory and i would just read them all the time the first one i will pay for because i have to fetch but all the other ones are virtually free because i already prefetched every line in immediately and your cpu founders are also really smart so what they realize is that if you keep you know walking through memory like one two three four there's a high chance that it's going to continue right patterns have this these things so we have a there's a mechanism called the prefetch we will automatically realize like hey you keep hitting those memory addresses in the sequence you know what i'm going to save you from yourself i'm going to prefetch the next one cuz so by the time you at the end of that one you're probably going to have this one already loaded very nice and they smart enough to realize that you know if you can plus plus you can minus minus that's usually let the two ways people go about rays so if you go the other way at some point they will also do the same thing and fetch the top one i'm sorry the color doesn't really show that much but as what i mean is yeah this line is now also loaded by the time you reach the end so even if you're going like decrement you will get there so every time a colleague tries to have an argument with you that you know going incrementally or decrementally for rate change this thing it doesn't it's it's roughly the same thing the cpu figure people have figured out that you can go two direction with with with basic ari effect and both direction have a prefetched mechanics no what it it works fine and it's really good so basically memory access is slow we we've been that but caches will try to alleviate most of that by making sure that the minute you start accessing some data somewhere in memory it will basically load the rest around that and then if you continue growing or decrementing addresses it will continue doing the same pattern and most of the time the data will be ready for you before you actually need it roughly speaking if it's if it's if it's if it can predict the thing but again it has to be able to predict the pattern and it's smart but it's not that smart so it can predict that after one comes two and after two comes three and the other way around that's that's has the two f he can he can he can do but if then you jump like plus 10 minus 5 42 and then completely somewhere in memory then you're out of luck then it can't predict where your memory next memory load will be so it can't pretch it for you so you're going to be looking at the loading animation that i showed you earlier so if i have to summarize it the most like stupid way possible it really is linear access good random access bad like if you go up or you go down you're fine if you do anything else and it doesn't really matter if if you jump 100 or like a million memory cell it's kind of roughly the same thing you will have the same problem you will you will hit the problem that this memory is not really available on your cache and it's going to have to fetch it first and this is basically the whole reason why there has been a push for this thing called data oriented designs it's not that new as far as i know people have been talking about it since like the early 2000s at least and the world ecs entity component system have also been mentioned somewhere in the 2000s but i know it's it's making a comeback and i think it might potentially be related to the fast that again we're hitting a bit where we can make the cpus as fast as we want but the ram staks have been as fast as they are for like 10 years and have not really changed so this is getting a bigger i don't know if it's a bigger deal but it's still a big deal it's never going to it's not going anywhere so the point of of data oriented design is to try to work with the cpu rather than against the cpu and basing okay your cpu is is good at arrays that's what it it's good at it sucks at m it sucks at maps it sucks at lists it sucks at anything that jumps randomly in memory what it's really good at is for i equal zer i less than size plus plus i it's really really really good at that and if you have to bu process anything it's going to be very good if you do that with a vector it's going to be horrible if you do that with anything else or anything else that is not linear access memory you might get away with a deck if your chunks of a deck are big enough enough but if you start going with a list a map even an unordered map especially the standard unordered map you're you're you're not going to have a good time so the idea is that okay we try to think about bulk because again when you program you should usually optimize for the bulk case not the one case right okay if you have to process a transaction it's a transaction but that's usually not the thing that kills your performance the thing is when you have to process a 100 of them and i know as programmers especially the way i was thought and i think it's still a thing we try to think of the one case and they okay i can generalize it by putting it in the loop and calling the same function that's that's a very normal way of modeling things in your head right like you you do the one case and then you write a loop that just calls the swing repeatedly which works but the idea is to try to go away away from that and say the one case is the exception it's not the one i care about the the care the one i care about is i have x amount of data and i will will process them in a bulk and you don't have to write it as a loop with no like function in between but the rough ide is that's how you should think about it it's it's really i want to do a bol processing and i want to do a bol processing that just takes an array in and outputs an array out or uses the same array both options are are correct and toh show you an example this is usually call as the array of struct versus struct of array debate or fight or gundrum whatever you want to call it so okay let's say we make a video game right a very simple video game we have a thing called a unit i make strategy games right so you have like units on the map like little dudes with guns and tanks and they just move around so it's it's maybe the simplest possible thing it has a position a velocity and some hp so position is free float because we're doing freed so you need free coordinates and it has a velocity which again like the one of them is probably zero your tank is usually not flying up but let's just say we want to handle every case so we don't bother that that's the thing it's it's free flats again and finally i have an end which is my hp and if i run below zero i die and the unit is gone that's very very basic like the dumbest possible thing i can do the classic way you would do it in in most like way you want to think about it's like okay that's what a unit is right a unit is described by its position its velocity of in hp so i chug all of those in a struct and then what what is my game about my game is about a vector of all those units that does make some kind of sense when you think about it that conceptually if you start trying to explain the design of your game it does make a lot of sense sadly your cpu hates you when you do that and you very much prefer the the one on the right which is okay we don't have a stru for a unit we have a stru for all the units and what is it it's a vector of positions a vector of velocities and a vector of hps and then at the end all unit is well it's just a well it's it's a struct of one item and why would we do that let's let's look at what it is like let's look at the memory layout of our of our thing let's see we have like a a classic array of struct so this is my memory this is i think each each cell on all my slides is considered four bytes because floats in eight or four bytes so this is my unit right it's it's it's 4 eight 12 12 bytes of position 12 bytes of velocity and an extra four byes at the end for for uh for for hp which is an in we don't have any extra alignment requirements so we can even just call them put them one by side by side and there is no padding or anything let's exclud padding from from the equation right now it's just that's our unit that's how it would be laid out in memory and oh sorry and so if i have a lot of them they would do that right like you would have the first one here the second one here etc etc and they would just be be laid out in memory like that in my vector that's that's reasonably what you would do but now let's look at what the operation i actually try to do on those on those on those units do it is very unlikely that i would have one or it would be probably bad design even from a simple like you know like single responsibility principle concept that i have one function that does update the thing that does everything in one go right i give it a unit and it does everything it draws it it updates it position it simulate combat it is the one function that's usually not how you would structure something you would have like several systems in your game that are possibly managed by different people or maybe at least return at different time or maybe run on different schedules and they would each access a part of the of the actual data so for example i have a bit that updates the position of my unit which i'm really bad at math but i'm i'm told it's just a sum of those two because if you sum your position and your velocity you have your new position you can multiply by a delta if you have time but that's that's the rough id so basically what we do is that we use those three here those three here and we output those three here that's basically the memory footprint and data footprint of for for function then i have a thing that will just simulate damage because i have a combat system somewhere and the only thing he will access is the it's the hp data member and he will probably change it and then i have a third system which is my 3d graphic thing that is just rendering all my stuff on the on on the screen and it doesn't care about any of that the only thing it cares about is the is the is the free coordinate so you can put it on the screen and see if it's visible for the player or not which is some math involved and it only cares about those three bits now here's the thing if i try to update position i will try to keep every time like in gray all the bits that you don't actually read but still have to fetch because you're reading this data from memory right and all those things come together so in a classic like layouts if i have my update position it's not too bad like out of seven quad bytes memory cells there's only one that i don't care about when i iterate through the array to update the positions so you know one in seven waste it's not the best but i've seen worse right as far as as far as as waste is concerned turn it's potentially an acceptable trade-off if that was the the only case i had i would say maybe it's not worth changing all my code just to get that benefit whatever it's fine but then we start having a function that just simulates damage and now we're like oh i only use one in and seven cells of memory and again memory fetch is are expensive and even if you can try to prefetch the more packed it is the more likely your pre-etch will actually give you all the data you want because even if you prefetch it still takes time so if in the time you the prefetch run the only thing you had is like touching one end it's very likely that the next bit you will need will not be ready and you will be waiting on the on the memory bs so that starts to be a problem because for every seven yeah quad btes i fetch i use one and the six over are just wasted i don't care about that data is just there to take space in the memory bus so i'm wasting a lot of bandwidth and we don't like to waste band with when we're talking about performance and then we when i start running my renderer i have the same issue it only cares about the free first quads of every of every structure and then the rest are just garbage with like those bites could be random for it cares it's never going to read them so same thing i'm wasting about over half of the over half of the memory fetches i do are useless and i could just do without them and roughly be twice as fast that's a bad estimation but i have some benchmark later so what if i do the opposite what if i have a vector of position a vector of velocities and a vector of head points for every for every for every unit i guess i should have like maybe split those because you can see that there's way more units stalled in this one than in those two at the top but that that's roughly the idea right this this this vector is like three times smaller in memory du to the sizes but if i start doing the same problem the same update thing well this time the green bit and like the gray bit is the bits i don't fetch but it's fine because i don't use them so while i will run this update i will have like my memory band with will fetch this uh disposition this this this this bit in memory too but it will never fetch those one so everything i fetch is exactly what i need i waste zero memory on the on the process and your caches are small enough that you can have several independent arrays in your in your in in if in your cach at the same time even if they share like some similar modular memory addresses there's a thing called associativity if you have a look at the specs of your cpu it will say like x x cache associative like i think the minimum nowadays four which is like if you have four if you try to fetch four pointers that happens to line on the same cach line you still manage to have the four and they don't eject each other and unlike big super modern cpus like the top like intel or imd cp you get i think you have like 12 lines or something ridiculous like that so you're not going to have a problem with that if i look at hit points it's probably the best i can ever do i'm just fetching a vector events and i'm just iterating through it and i will never bother reading the last one and same thing for the random thing i will only read my positions all the time and again all of those operation waste zero memory they always only read what they need and again that's the thing we're trying to optimize it's the amount of memory we fetch because that's our bottleneck so what we call data oriented transforms is basically the idea that you make small loops that operates on array of fields and those fields in the arrays are only what they need and exactly what they needed nothing else or as close as nothing else as they can there is an upper bound to this process because if you push this process far enough then every you don't every field is just one end or one bull or whatever at some point you start maybe thinking you know what it makes no sense to have two arrays of those things maybe they should be in the same array because they makes significant sense to be together even if half the transform maybe you're not using all the data but as far as possible what we're trying to do is make sure that we have small loops that operate exactly on arrays of fields they need and only what they need so you minimize the amount of data in the cash that isn't read or right during the update because again cash cash sizes are very very precious if you have a look at the spec sheet of your cpu i think you have like even on a very expensive cpu your l1 cach is like 64k i think'k maybe that's that's not much compared to like the i don't know 12 16 32 gigs of ram you will have so you really try to optimize that real estate and and that's the bonus that i will make a small uh a part like side side note about is those transforms then you realize wait a minute those fields that i'm looking at like they're entirely independent like you know this this this this step uses only do bets this step only uses do bits i could even run them at the same time on two different frets and i would not need any synchronization because i'm guaranteed by construction that they're literally not accessing the same data the same data fields and i think we had a talk ear you today about like data synchronization i couldn't make it but one of the big things you have to know is the best way to do data synchronization is to not have data dependencies and then you don't need any atomic or mutes or whatever you can just prove by construction that those two frets can run at the same time and another way to optimize cpus that have been working a lot for the past 10 years has been adding more cores so all right let's look real quick at a benchmark so far it doesn't look that big of a deal i made a small benchmark on quick bench which is just i created like i don't know 100,000 units and i run the free updates in sequence and this is what it got what you get when you do it with an array of strs and this is what you do if you have like a bunch of a stru full of arrays it's not i mean it's like a maybe 10 20% it's not non-negligible but it doesn't sound like a big deal i will get back to that but first this is the small break i have to talk about code architecture because this is this is the bit about coupling that i think is important to keep in mind after talking about caches because you know we're not only just wasting memory when we start having like cach line full of data that an operation doesn't need we also mixing up concerns because to some degree i think it ind this maintainability that is struct as a lot of fields that are technically not used in the same update even if logically it makes sense in your like mental model like you know if if you're trying to design a unit you say okay a unit is a position of velocity and and and and some hp but when you're thinking about code and what data do this function actually need to access then you realize that it's really hard to resign to to to reason about because in the first model my random method takes a unit as a parameter i cannot like unless i look at the implementation of the random method i cannot guarantee that it will not read any and all fields in the in the unit and then i don't know if two operation on a given unit or or threed safe for example and it's just a lot of cognitive load because there's all those fields that are given to me with my in my in my in my code and it turns out i only care about one so basically it's a thing that we we we've cautioned people against like coupling and and and mixing things together forever i think as as far as we taught computer science we say don't mix concerns that don't need to be mixed and usually when we think about that we think about code right we say okay this function should have only one responsibility but i think it should and i don't think it's it's a thing i invented i i'm pretty sure it's it's it's a thing that's being taught more and more it's a you should also apply that to data why do you have a struct that have members that do not appear in the same update well then maybe they shouldn't be the same update they should maybe be two two different structs and then you could have like a parent that is the same and they could both have the same index in two different arrays but they're not the same and they don't have a reason to live together if you don't actually use them together and again the point of data oriented is to look at like the the architecture comes from who where the data of how the the the data is accessed and not how the conceptual model in our head looks like so yeah basically don't mix fields that are not accessed by the same function it's all a nothing right like if if i take if i take if i take an object as a parameter or a collection of object as a parameter the default if i'm reading the code is to assume that they can access anything so the least i give them the better because the more assumption i can make and as i mentioned then i can yeah i can't reason about data sharing if i have two function that takes like a writing a a mutable copy of a mutable reference to to a unit i can't assume that they're both able to run at the same time i can try to read the code of both function prove well prove as in in my head convince myself that it's safe then decide to put them both in a different threet to gain performance and then the developer comes back and doesn't know about this thing because i mean he's given a function that is allowed to access all the unit and then starts creating a data race and i call enforce that in code because it's one struct and either i lock it for every either i lock it and then it's not multif fred anymore or i don't lock it and i pray to god that nobody violates the promise so yeah if you remember that talk i don't know if you've seen it it's pretty good you should take a look at it the is like yeah you can't you can't you can't you can't be fat safe if you use two function that that takes mutable references to the same thing so if you split the object in smaller parts then you can prove like by reading the code that those two functions literally do not access the same data member ao they are frat safe and if you decouple your data well first your buffer your memory will will thank you but also you will have a way easier ability to decide if those things can be fred safe if they can if they need to be save together a lot of good things come from here and now we can go back to our benchmarks so because you know i i only had 20% right in my in my in my in my previous benchmark about the difference between the two which sounds nice but i can understand why someone would come to me and say matthew like i'm not rewriting my entire like unit class and everything that accesses it just to gain 10% like i 10% is nice but it's it's not worth it and that's a fair argument i i i would accept it but now this was a minimalistic unit right this is not an actual unit in the game an actual unit in the game i'm just going to put some padding data to simulate it but an actual unit in the game in my game would have way more data than this you would probably have like a bunch of other stats and not just hp probably like some data concerning like which models and texture it should use who's the owner million other things you can imagine a simulation is doing to simulate an actual like unit and if it's a tank like maybe you have data for different parts like is the cannon damage is the did it l the track how much fuel does it still have you can go you can go as far as you want and we make very complex simulations that people really like having millions of stats per unit so that's that that gets that gets really quickly like an issue so they start to be a bit more fair so assume that instead of like no data here there's maybe 32 bytes of like extra stuff that i also don't need in my updates and now it starts turing to be a bit more like you can see the difference like it's very noticeable it's almost twice as fast if we start going to 64 bx reping it is yeah over two two times as fast and if i go to 128 bytes of extra data that i don't need for my updates you can start getting to i don't know like three times maybe four times i stopped here i could have continued it gets worse the good the good thing is at some point it stops it stops because there is a limit and the limit is for each unit you basically need to fetch the memory and weight and that's the worst you can do which is bad but it's it's it has an upper bound which is an upper band that your could probably has on some systems because mine has though i'm i'm assuming over people have the same it's there is an upper bound and it's not obvious that there is an upper bound but when you change your code you suddenly realize that wow the same exact code could run like eight or 10 times faster just because suddenly the memory access is actually efficient which brings us to the concept of ecs and why do people talk about ecs i know it took a while to get there but we finally going to start talking about what is ecs and again it's because the main point of this talk is not as much ecs but more like why are people talking about ecs what can you learn from it because as we will see it's somewhat of a fad but there is some interesting id behind that so the idea of ecs is that we bundle fields into components so like for example all my pos position would be a component which is like free free floats velocity would be a component hp would be a component i have another slide to explain it i think then every object in the world is an entity which has an unique id i mean classically from zero to like how many you have but that's that's you could you could you could do different models of of of id but some form of a unique identifier it allows me to look it up if i need to and then each entity can have an arbitrary number of components so like not every entity in the world will have a position of velocity hp and the 20 of a million components that you can think about in your game so like you know like does it have like a stockpile does it have like a fuel reserve does it have like an owner all those could be considered separate components basically and you can add or remove components through to a given entity at a given point for example like if a unit is under the construction maybe it has like a a construction progress thing but it doesn't have an actual like effective stat because it's not done and when it's done then you transform it and you say okay remove the construction component because it's been built and give it like an actual active rooll component instead things like that the other classic is an ai component like if you have a tank in the game as long as the player controls it for example you don't need any special data for it but if if it's not controlled by the player but it's controlled by an ai then maybe it has an ai component which holds all the data that the ai needs to simulate and make it move things like that and then what is a system well a system is a transform basically that operates on a selection of components so i have a i will explain that so yeah and then the the the big concept is like if you want to update the world what you do is that you gather all the entity in the world then for each transforms you say okay give me all the entities that satisfy all the components i need as input and output and then i do a ball transform on those and potentially through from framework magic i can realize that those transforms that do not use the same component sc mod at the same time we like some schedu mechanism basically that that's that's the the base idea so if we go back to a very minimalistic game design here so this would be like alter transform or like update position take damage and renders are basically all transforms all components are position velocity and hp each one is a different component and each unit is an entity so it has an in it has a unique id and it has potentially those three components maybe more maybe less that's the that's the reality so that's that's the components and that's the transform sl systems i think i need to update one of the subtitles on this so the efficiency basically comes from breaking objects into components and then storing them in dense arrays so we optimize the memory bandwidth associated with reading and writing them and the rest of the talk and the original point of my talk was how do we implement it which now is more like a a nice thing to learn but i think the main takeaway you should have has already been given but we can still continue and talk about implementation a bit because i haven't shown much code yet so actually there's no code it's mostly diagram s but i will explain to you how you can do something like that because again i think the the main point is okay that sounds interesting i would like to optimize the memory band for my program when i go home but maybe i don't want to use an or i cannot use an ecs system entirely or i think it's too much but maybe i could just take the data structure so let's look at what it's how it's done what's the goal what are we trying to achieve what are the constraints and also the constraints are important because they help you figure out can it work in my case or not because games have their own demands and they own necessities you might not work for whatever you're doing so obviously the thing we're optimizing the most and the thing we want is that if we're iterating for components we want it to be as fast as possible you know like as fast as the machine is basically allowing us to do it so mostly speaking it is like as make as better use as best use of the memory as you can to make sure we don't waste memory bandwidth cach utilization etc etc so yeah basically it should be as fast as going through an array that doesn't have any unrelated data if we do if we start doing topples for example like our our update position use component toles right because it takes all the position and all the velocities so it's technically a tole of both we would like to be very fast we can't be we can't guarantee that we will be as fast because it starts it's a problem that gets infinite complexity eventually but i want to try to if i want to do a zip iteration over like a selection of components i want it to be pretty fast extremely fast would be nice but most of the time due to implementation concern you can only go as good as pretty fast or very fast you can try to constraint the topol at creation saying okay like only those combinations of of of of of components will actually be used and then your your your data storage can try to optimize for those cases but it's it's a vast field and i don't have all the time in the world to explain why but trust me on the fact that is complex problem and it kind of runs into a like a combinator explosion issue eventually we want a fast lookup so for example if i have a given entity and i want a display on the screen either for debugging purposes or just like to give the player feedback or whatever else i want to be relatively fast in in getting all the components it has by which i mean like i think a linear search should be considered too expensive i won't want to have to go through every component table and say do you have ntx yes i know by because i i actually did like a linear search for the i want something faster so i need some form of an index or a lookup table that will allow me to be able to do a lookup in reasonably reasonable time that's the thing that not everybody does but for example my game is sometime needed sometime i need to be able to iterate for component in a deterministic order and by deterministic i mean if i start the game i start deleting and adding components all the time because some units so created and deleted i want a way to guarantee that if two players on two computers are iterating through the same collection i get the same order it's mostly used for multi multiplayer synchronicity and things like that but it is a use case that is not always used by every game but i would say i i don't have a number but a solid class of video games and the way they handle their simulation requires some time that they have to be able to iterate through all the component through a deterministic order it doesn't have to be by like increasing in index but it has to be deterministic we regardless of like how many items have been deleted even if someone like joins a game or whatever and gets like a copy of the current state and doesn't have to repack a bunch of data it still should get the same order and of course entity id should be stable upon creation and deletion so if i if i add or remove components or add or remove entities all the other ones i can still do a look up by id and i still find my my babies i don't have to do i i i i will not lose them so i looked a bit at some systems so i done some some some some checking unity engine has been offering like an ecs system since 2018 i think this is this is the big spike you see in the in the google trend that i showed earlier they made like a big deal of the fact that unity engine was was was going to do ns system in the future in 20180 they had a cool demo called the mega city there's an interesting talk behind it about how they did it it's it's it's a nice watch i recommend it i also get entt or ntity i'm not sure how it's supposed to be pronounced which is an open source one you can find it on the internet it's c++ unlike unity with c well and internally c++ but c as the api i think it's used part some parts of minecraft are using it which i included because that's one of the difficulties i had doing this talk was finding actual production use cases of of of of of of ecs because game developers love to tell other game developers that they should use an cs to solve all their problems but when you ask them okay whichs are using like we're not really doing ecs but so yeah and flex is the one that i looked at because it has been used in some bits of our engine but it's in c so i hate it and i refuse to take a look more than that because it's c i just don't respect that this is a c++ conference after all so you know let's let's focus on the important bits oh and that's the wait but my transition is broken okay fine we can move to the next slide so okay now i will just how much time do we still have okay 15 minutes i'll just show you very basics how can you implement like the most simple data structure that will allow you to do like those kind of magic vectors including the the the constraints we have because as as i mentioned before the constraints we have do not allow us to just use a vector just like a simple vector would not be good enough because as everybody knows if you delete an element in the middle of a vector you have to move everything around which means that suddenly you can't find your babies or you have holes in the section in the either you leave a hole but that's bad because then you need to skip some bits and then you don't have the most packed data structure ever or you don't and if you shuffle data around then your key starts getting jumble then you can't look up things so that's the that's the problem we're trying to solve right so some people have tried to make solution for this if you ever heard about a paper about colony or hype they keep changing the name i don't think it's been standardized yet but it's been in discussion for a bit it's a data structure that tries to address the problem by having what we call skip fields which is either a beted set or some metadata that basically allows you to jump across gaps in a vector so it's it's a vector and when you remove an element instead of repacking everything you just market as dead and then you have the whole thing is about having optimization to know how to jump through it when you when you iterate it's pretty good but it still weights memory because it's not densely packed and i think there are simpler way to do things and to me the simple way the one i' i want to focus on this is the one that's entity does for example is just swap every time you have to delete something just swap it to tail just just swap it with the last element and then have an external index because again like the thing we're trying to optimize most and again that's that's one of the main point here is that we trying trying to optimize the most is iteration lookup doesn't have to be 100% as fast it has to be fast enough so having an external table that does the lookup for us and and gives us the the the guaranteed like not iterator but index stability is good enough so how would we do it so yeah that's what i was saying here i can just skip that bit okay cool so all right let's skip this okay so here's here's how that works i don't have a name for this and this is the thing that sparked my talk already because i run into this data structure looking at how ecs are implemented i couldn't find a good name so you tell me if you've ever heard about this or at least the concept i don't know about the name the the guy who was mentioning it was the offer of entity has an interesting blog about how he implements the whole thing and how data structure should work with it i think he call it the dense slp array or the den array spar index it has different names but the whole idea is when you start you just have an array of of of all the the components so a bcd e fg is just like instances of the same components right i just tried to give them letters so not to confuse you with id at the botom you have an index look up that is just an offset it basically say okay if i want entity zero it's set index zero in the table if if i want entity one it's at it's at index one etc when you start when you just keep inserting that's very simple and consistent right you just this is this is the actual id this is the the this is the index of that id in the table that's that that's as simple as it is if i want to start deleting something then this is where i start doing some things so like i want to delete b for example b is dead that my unit b is gone forever rp and i i'm trying to delete it so i want to keep the in the thing at the top completely packed so what i will do first is i will mark this entity as dead the one of the classic option is to just do a minus one so if someone tries to look up entity one you just get like up not there anymore br you're going to have to do something else and then i swap it with the last one because i want to keep that one the top one packed and of course then wait did i do oh yeah and then i have to update this index because obviously now this entity number six is not is not out of set six it's it's out of that it's it's at of that one so i just update the index and that's it that's all i have to do so it's not well first of all there is no real like most of the time there's no reallocation it's just like a push back and no it's not even a push back it's it's just a swap like it's a it's one memory swap and two memory right and that's it and that's how i can delete something and i still keep my top array like packed so if i iterate over it again not deterministic order anymore because i start jumbling things around but i have all my entities super packed and i'm not wasting any memory bandwidth when i iterate over when my actual cost is one of the assumption is of course that iteration is more important than addition than adding and deleting stuff in general i mean if you're trying to optimize for a if you optimize for insertion and deletion you're probably not going to have a main your main issue is not iteration right but in video games and in many things we have the problem is not creating new things it's iterating over them and then we try to just make creating new ones not as painful as it could be now if i want to insert a new one well obviously i just put it at the back because that's the only place i can insert new elements because it's always a dense array and then i will just push back a new index entry and just say oh this is where your thing is and that's it that's that's really the data structure it's it's really simple i haven't seen any papers about standardizing anything similar that i could talk about about and again i did not i don't claim to have invented this i just found it by looking at the the blog of entity and how it's implemented and it's just two arrays it is just two arrays and that gives you good enough things to make sure that all your that satisfies all the constraints we have with one exception we talked about lookup before there's one case here that is not satisfied and it's the reverse lookup if i have like a component and i want to know what its index what its id is i can't right there no easy way for me to get it from there because unless you want every component to keep an index of itself which again is wasting memory most of the time that is not worth it i can't really reverse it from any of those index without a linear search which is not good so the solution would be if i really need that which in some cases you do so like okay i have a given i have a given component but i didn't i lost where it's coming from i lost its entity id well what i could do is just okay let's keep a number like you know this is this is basically the data i want right this is number zero this is number six this is number two three four 5 seven etc but i don't want to throw it in there so what i'll do is i'll do the exact same thing that i keep doing i'll just put it in another array and that array is shares the same index keys as the top one so if i'm given like entity g component g i compute his index we can i mean it's it's pointer ari but it's just a ric where he like okay it's it's basically st distance from the start to to it which gives me one and then i just take okay take that index in this one at the top and that's my thing and that's again that's just two memory lookups there is no linear search it's arguably constant time but again complexity you've noticed i haven't talked about complexity at all in this talk it's because complexity is important but memory latency is starting to get more important in some cases it's not 100% i'm not going to say it's fine as long as you have good data locality go nuts and use like factorial or or whatever polinomial like time no don't like try to keep it too constant or linear but but there are many cases where actually memory latency is a bigger problem than the fact that your thing is linear rather than than constant or maybe not concept but logarithmic is a big one i haven't had any slide about it because again i had to fit this slide and this talk in one hour but one of the big thing that that you can that people have started noticing is that binary search is starting to get slower than linear search in some cases because it keeps jumping through memory all the time and on top of that we have this thing called branch prediction which also hates when you randomly jump sl or right all the time and at sometime doing the dumb thing turns out to be faster and that's it that's if you really need to be able to keep your indexes back but you don't want to poison your actual like component data you can just have the third array and then you're back to be able to to have the relationship both way between indices and and components so yeah it's as easy as two or free array and it's like it's simple enough to implement like maybe it's not stand i would say it's not standardized because it's it's it's too easy to write is a bad argument because some people would argue that implementing vector is not that hard and still i'd rather have it than having to implement it myself so i don't know the second aray can be split into pages because one of the issues we you can run into is that you start having like big gaps in your indexes because this one will always be packed this one will always be packed you will always be paying as much memory as the number of active components but this one well you notice that we start putting like some minus ones when we kill some things and it's just going to keep growing and growing and growing unless i implement some form of like reuse of ids which is also a big important thing but again see me after or i'll probably make a blog post about it if you don't know this man this man is ferma he's very well known for having like a last theorem of fma which he famously in the paper that he wrote in the 1600 said oh i have a proof for this but it doesn't fit in the margin of my paper so don't worry about it trust me i'll tell you later and he never wrote it and it was proven 350 years later or something using computers and nobody thinks that this proof actually worked but that's the idea like see me after i can explain to you how to implement id reus and things like that which is usually a thing you want to do else your your index lookup table might start growing crazy even if you have only five items in it because you created and deleted a million entities and you usually want to avoid that do i even even have time for the multicomponent case i think i would rather take questions so i will skip that bit and go to the conclusion there we go sorry i have to skip over a few slide there we go okay so did it solve our problems is i guess a question right so again production games at pds do not use ecs like as as i know no no game in production at paradox uses ecs so far future titles i've been looking at potential uses as i said our engine team has been experimenting with flex for some animation system i think but it's still very much an experimentation and i don't know if we will keep it or not or wr our own and in the end if it's used by only one system maybe it's not really ecs maybe you just have this nice dens r and that it and yeah for game play i still looking for it if you're a game developer and you actually use thiss at scale with like i don't know 100 different concept or components and you actually manage to use an ecs framework from that i'm really curious so you did it because every time i try to ask people like we tried yeah we can skip that so yeah one of the issues that you run into this and that is somewhat important is that you want kind of want to tie down like which kind of component pairs you can have topples veal archetypes in some literature an archetype is basically an entity that is given that is guaranteed to have like a select set of components and that's usually the one you of operate about on on a given transform designer hate them especially if they're pinned in code because what designers love especially in like complex games that have lots of system that interact with each other is they like to say oh what if suddenly the unit system was starting to feed data from the spy system because that would be super cool and then you're like oh but you can't access the data here because i have to change the archetype and make sure that every of those has access to this component and that changes the whole lot blah blah blah blah blah and this is a thing we've started noticing when we tried to use a similar approach but it was mostly for multi threading at the time not for semi over talk i guess they really hated the fact that nowadays system updates are like taking very well defined sets of components in the signature they really like to be able to do unit. get or do access whatever and then just jam a gameplay feature like five minutes and be able to test it so that's cool i could do it and never like oh i can do that now i have to go back to the coler change the signature add one new component to this update and now i get warnings that this is they don't like it as much so there is limits to this but the the speed up is is is very important and again the fact that if you start defining your updates as free functions that take constraint input by a type will allow you to get multi friending for free and decoupling so i could have called this talk like you know i use thiss and it didn't solve any of my problems but it's not entirely true i think it is important to realize why we went there because of the data oriented concepts and all the speed ups that it can go if you start having multiple components and you want to make a z view iteration it starts getting a bit tricky that's the bet i skipped because this talk was complex enough but again single components is the structure i showed you i think it took like five minutes to explain maybe 10 i don't think it's really hard two or three vectors and you will get something out of it so yeah consider the dense par way it is pretty it's the fastest and all iteration speed you can do basically and it still keeps a constants outside of relocations obviously if you run out of memory in your vectors but outside of relocation it's constant distortion and delation time because it's just swap or or or or push back it's constant look up by id because you just look for an indirection table it has id stability but not pointer stability obviously if you insert or delete the memory address of a given component changes but the id is stable you can just do pay extra look up and find it again and it has okay but not amazing deterministic deterministic iteration speed because usually what you do if you want deterministic iteration is you go you go through the lookup array basically because that one is guaranteed to have a to have like an index and you do a jum memory jump so it's not as good because you keep jumping through memory but if it's packed enough you might not pay a cost that is too high and also like yeah it mostly works and i did not mention that before it mostly works with trivially relocatable types so like types that do not like have pointers to themselves or funny things like that it's just things that you can m copy and again i think this is a reaction thing that i that i've hear more and more in the c++ committees people going more and more to like dumb structs that you can just m copy everywhere because you you get a lot of places where you have huge gains by the fact that the thing can just be m copied and then forgot on that right so decouple your data is basically the one thing i want you to take home it's good for multif fring it's good for cash performance ecs is probably overkill but try to take a look at data structures that have spawn through the systems because there is something there that can probably be taken and used in your own projects oh and furthermore i think you build should be destroyed as usual thanks i have some reference is if you are interested there's the the the collection from m on the on ecs is pretty good there's the there is the the github of the project and he has made a talk i think in italian c++ or something like that where he compares his ecs to like unity and he talks more about the implementation if you're interested in that stuff i'm probably too late for questions but i don't know if we're not getting kicked out i can still maybe take one or two especially if you if if you use ecs and it solve all your problems i'm interested hey hello hi i i i've been trying to use ecs ever since i heard about it i think it was mike aon talk or something yes that's the one that's often mention i mean i i immediately fail at the first thing because the very basic example always is about position and how do you do hierarchical position because that's my biggest pet pee with this yes because ecs do not give you any cape of hierarchy right so for example the classic is people would like to put them in like quad trees or o trees or blah blah blah i actually have you seen this talk about the mega city in unity i did not know because he talks about it and he talks about how he managed to solve some of that hierarchical data not by introducing a new structure but by taking advantage of the fact that the way this is stored is hierarchical so basically having intermediary steps where you can basically skip over chunks of the of the of the of the object and i think the way it's done is that it probably keeps components into either different sets or at least sets that are together in memory so you can't use the spse thing because it keeps jumbling things around but it can take advantage of the fact that this this disarray you can basically do a jump like over a thousand entities because you know that the first thousand of this block then the next first next thousand are in this cell etc etc etc but yeah i think it's called like mega mega mega city unity thing it's a 30 minute talk it's pretty insightful cool thanks you said that the ecs concept is not that much applicable onto maps did you still explore the performance benefits if you try to build a map or sl dictionary structure the thing about maps is that there's only well okay actually like standard maps there's only bad ways to make them in memory right because it's going to be a red black tree that's basically the standard can of force it doesn't tell you it's a red black tree but if you look at the requirement it is a red black tree and it's a tree which means it's a list which means you jumping pointers all the time which mean there is no way you can guarantee data locality the best you can do is try to chug on a locator next to your map and try to get the poorman's version of data locality because every item in the map will hopefully be close enough in the same memory chunks but you're still jumping through memory and you can't guarantee that you're going to act that two elements are actually next to each other they guaranteed to be in the same map which is better than what map does but it's still very far away and that's why if you have looked at hash tables for example that's why people keep telling do not use an ordered map in the standard because an ordered map is also has to be what they called buckets with with lists like they can't use what we call open addressing and open address hashes i'm getting a bit far away from the topic but hash maps they always if you don't follow the standards to implement them as one ray with only a few gaps in it and it's it's okay enough for iteration because you just you just have to skip a bunch of it's it's it's kind of equivalent and not as good as colony in term of skip fields but it is still you have the guarantee that you're going through an array so as long as your as your hashmap is reasonably popular like let's say 75% or something you're mostly not you're not wasting too much memory when you're doing data when you're doing fetches although arguably you will still be fetching keys and a bunch of things that you don't care about for your actual update so it is okay but i i think this misses the point of just saying no no we want a vector of things and this is the end only thing that i'm going to fetch yeah okay thank you do we have any more questions okay so we're done you can come and ask me afterwards and i will happily answer anything else