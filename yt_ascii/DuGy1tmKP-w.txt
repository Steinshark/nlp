hello you're listening to developer voices and today we're going to put another new programming language under our spotlight this time it's the tone of gren that's g-r-e-n gren it's a language that's trying to take the biggest most important ideas from functional programming and then make them as accessible as possible but which ideas do you take and what does it mean to try and make them accessible to more developers and how do you do that joining me to discuss all of that is the creator of gren robin hagland hansen he started the project a few years back for that most noble of reasons he really really wanted it to exist so he started with a fork of elm if you've heard of that front-end language and he said about reshaping it in a few different ways and expanding its scope so it works on the back end as well as the front end we talk about all the directions he's trying to take it where he's looking to be in the future of gren and how he's trying to build up a sustainable community around it so that it doesn't just rely on him being the benevolent dictator for life i really hope he succeeds it's certainly an interesting journey to be on so let's join him and hear all about it i'm your host chris jenkins this is developer voices and today's voice is robin heglin hansen [music] thank you i'm joined today by robin hegeland hanson robin how are you hello thanks i'm fine and you're good yeah i'm good the sun is shining for once in england today so i'm happy oh brilliant we're having a extremely hot summer well i'm recording this from the basement so i'm like i'm able to focus and function is the word of the day look at that for a segway because you since we last met you've been creating a functional programming language right that's right yeah it's called the gram so i love the pronunciation you'll have to forgive me if i call it gren that's fine that's fine it's it's a norwegian word so i'm thinking that if i'm not pronouncing it correctly then it doesn't stand the chance [laughter] but but yeah graham is fine you can okay i do occasionally slip up as well but tell us about graham what's what's the elevator pitch the elevator picture okay so i would say that grand there you go graham is a simple language that tries to help you write maintainable readable and well-functioning applications okay and that doesn't really mean anything so gren is a is a statically tight language and it tries very hard to use that static typing to guide you to write robust applications another way of thinking of it is that we're trying to take the really good ideas of haskell and making it simple if if you're not one for complexity yeah i think a bit more approachable i'm a huge fan of haskell and i think it's the way programming should go long term but i've got to admit it's not accessible i wouldn't recommend it to anyone as their first or even second programming language i tried i i think i it took me three tries i think to learn asco until i like finally got over the got over the initial complexity and the the inherent fare i got from i think i think i bought this book which was way too thick and so every time i approached it yeah that's a danger these days because generally you buy ebooks and you can't tell what you're letting yourself in for yeah that's that's a good point okay so a more accessible thing in the spirit of haskell yeah well i think i think if you i think if you like haskell i think you will look at the grand and think this is this is not haskell but it but it has you know the ml syntax so it looks looks similar from afar and it has it has tried to stay away from all the from all the difficult concepts i think it never once do we mention the m word for instance i have to put a little subtitle on the video version of this so so no it's it tries to do it tries to make it approachable in a way but we're but we're also it's it's a very limited subset of haskell okay so if you're taking the subset what do you think the big ideas are that you're taking well for me the the it's different for a lot of people i guess but the most important parts of it for me is the fact that is the fact that the type system is used to check many things which in in many programs are completely unmanaged so you will have like for instance girian doesn't have exceptions that is that has to be represented as part of the type system and so while we while while we do have exceptions as a concept you can't define your own and you can't you can certainly not throw them you instead have to module that as part of the type system and the byproduct of that is that the compiler will catch errors that you probably should handle and another big thing about it is that side effects are also treated the same way so if you want to perform a side effect like reading from disk or sending something over http that has to be moduled as part of the type system so you can't accidentally inherit unpredictable functions into your case right exactly yeah and it it also gives you this sense of control that if you're going to import a third-party package if it if it hasn't specified a side effect in this type system that then you know that whatever it does it will remain local to this program that's one of those things i mean we often talk about it in terms of correctness but yep i'm surprised it doesn't get more headway in security yeah and that's that's one of the things that we're trying to push a little bit in gram especially on the back inside so we have this concept of applications and packages and those are two different things and in packages in order to perform certain things like reading from this reading a file for instance or performing a network request you first have to obtain a value that represents a permission to do such an action okay but those permissions are only handed to applications so as a package author there is no way for you to simply perform or even there is no way for you to perform a file i o unless you retrieve a special value from the application and that way the application author has full control over what parts of the system can perform which side effects so i can no longer write a library that claims to left pad strings but also runs a crypto mining bot at the same time yes yes unfortunately chris you lose that ability to riches all right like you can do that but again it will be very apparent in the type system that you gain that ability right yeah yeah and so and i you know the hope is that like the trade-off we're making here is that the application author has to do an extra bit of bookkeeping but at the same time it becomes very apparent what code that you're calling can do and so this is different from it's different from haskell and it's different from l which grand shares a lot of uh history with wherein whereby those languages expose this i o type and the elements called task and if you can see a task in the type types of a function then you know that this can perform one or really many kinds of side effects if it wants to and side effects can be anything but in gran we're trying to kind of like limit the powers of the the i o so you're going more granular on the yeah because yeah haskell always had that i think because they invented it before they realized how powerful it was and elm had it as a kind of way of simplifying this all down but you're saying it's worth the complexity to break it into different kinds of side effects i think so especially especially for sort of this is my hypothesis uh it's still very early forget it i don't know where you get we are releasing zero three in about a week so i've been doing this for about a year and a half so it's relatively new right okay but my yeah that's my working hypothesis that it'll be where that that extra bookkeeping will be worth it if you want that level of control tell me a bit about how you got started on this because it seemed i've i've checked it out briefly and i've played around with some of the demos it seems you share more than just inspiration with elm yeah how did you learn that no it's i it's it's it's no secret really that grand started his life as a fork of hell okay but i i i consider that mostly to be an implementation detail because it's not a goal of the grand project to remain compatible in any way shape or form with with element for the first release one of the first thing we do we did was like which parts of elm syntax don't be like for some reason and then you know remove or add to that so that for the first already from the first release we were in incompatible with them right deliberately you're cutting ties and not trying to yes deliberately and so so you know and and i it's important to note here that you know before i started working on gren i've i've contributed to elm the the standard library and written some packages of my own i worked professionally professionally in l and i like both the language uh evan who created language and the community a lot and i have a deep respect for them and so when i decided to create gran it was very important for me to not that grant wouldn't become something that stole attention from the community in any way so it has been an explicit design goal from the beginning to not be compatible with them to not make it easy to just take a known package and convert it to grim okay but why what wasn't because i know you're hugely into elm what was elm not doing for you so i it's not like so if i were to create if i were deciding that you know i'm gonna create a single page application for the browser i would still reach for elm i think alum really is if if that's the thing you're going to create i don't think you will find any better experience out there than l now you can do the same things in gran because we are a fork right at the moment but elm really really yeah the elements the nicest thing to use when writing those kinds of applications you put that ahead of oh sorry but i mean if you were talking to a general audience you'd you would recommend that ahead of say typescript and react yes good we've got the controversial quote in there yeah so like but so i think that the main thing missing for me is that you can't really make other things in in lm is very suited for one thing and if you want to do something else you're you're fighting this uphill battle single page web apps it's not a general purpose yeah yeah so yeah so i have used the thread like i have written a compiler for a toy language you know but you are you know you are fighting this uphill battle constantly and it's worth it because you really love the language and the semantics yeah but you know it's so so really the the trigger for me was i want i want elm i want the security it provides i want the convenience i want the the i i want out i really like it i want the semantics it has and but i i wanted four back-end applications because at some point i started doing back-end development and i feel that you know back-end development could really use all the features that elm has on all the benefits it has but there really isn't a good contender there i think yeah so you weren't tempted to go with something like haskell or pillow script i wasn't it's but it's funny that's the question i get the most like why why create while not use purescript or why not use haskell yeah and i think we we touched a little bit on it like haskell is partly because it it it was the first to do a lot of these things partly because it's also focused on being a research language haskell has a lot of complexity and a lot of terms and concepts that are not inherently approachable as they're not intuitive i guess and there's nothing inherently wrong with that like i enjoy programming languages i can spend the summer learning a new program language because i like the challenge and i like you know yeah but most of the people that i work with don't yeah most of the people that i work with are treating programming as a job and not a passion yeah and and you know they've learned one programming language why should they learn another and then i can say it has all these benefits but if they take one look at like the the best teaching book for haskell okay run for the hills i'm i essentially i i won't be able to work on it professionally at least not in the sort of products that i work on right now so the problem with haskell and pure script is is their complexity and that is a benefit for some like you can you can be very flexible in askle you can model things in a lot of different ways and that's very cool if you're into that but if all you want to do is get something done in the safest and best way as possible the complexity of purescript and haskell kind of get in the way i think i think that's fair and i i think the thing about elm is it did such a great job of being accessible and predictable and reliable that when people were getting started programming sometimes i would say well you know if you want a job get javascript or python but if you want to learn how to actually program without banging your head against the table elm is so friendly it's going to help you do you think you've managed to capture that accessible friendliness in gray that's a tough that's that's a tough benchmark but you know it's it's it's definitely a design goal to keep um it's a it's definitely a design goal to keep to keep that friendliness to keep those those benefits that make the language so approachable but it's like i've also gotten a lot of respect for the amount of work that takes like everything and you need to keep this in the back of your head like i want this thing because that would make this back-end thing easier to do and then you can implement that but actually making that easy to understand intuitive and have like error messages to say oh i think you did this because of your experience with javascript but in grand you should do this like those kinds of error messages yeah are an incredible amount of work so am i succeeding in this i don't know but i but i hope to continue that continue in those design footsteps to keep it that approachable and and yeah do you have any idea of how much how your workload breaks down with this how much are you understanding the code base you've originally forked versus developing new features versus making them usable user-friendly features well that's difficult to it's difficult to answer so the ground wasn't this it wasn't this an apple felt from a tree and a sudden realization that i was going to make a new program image a lot of these ideas and thoughts have have happened over a very long period of time so as you said i was very intel and i've been very intel for my god that's been six or seven years i think and i've been working with it full time in in certain respects and so a lot of the things that i know i want in gran are things that i've thought about for the last several years yeah and so now there is this i think now what i'm doing is i have this idea i know roughly how it should work and i know that this is an idea is better than other ideas for certain reasons so i think a lot of the time a lot of the time that goes into gran right now is figuring out the precise implementation details and actually talking with other people and getting their first impressions and and taking that into account when when doing things but this is also like a hobby project so i spent maybe i s i spend anywhere from one hour to five hours a week actually implementing things and then the rest of the time i'm spending 30 minutes or one hour before i fall asleep and like churning through like how should it actually work and what are the challenges here yeah what they call in closure world hammock time how much time yes yeah or you're just kicking back and thinking yeah so there's a lot of that and probably a lot more than actual implementation i would i would assume yeah one thing we haven't said here so the the people won't know elm was it purely like a front-end compiles down to javascript language i'm assuming that's still the case for gren that you're running on the browser and running on node is it going to stay like that for the foreseeable maybe currently like so we've inherited the javascript code generation from the elm compiler and it works and it's not the most important thing to tweak right now also the the the elm compiler is written with javascript as an explicit target in mind so there's a lot of things the elm compiler simply doesn't do because it doesn't really have to when targeting javascript so to target something other than javascript would be a huge amount of work yeah because the compiler simply isn't written written with that in mind yeah and so so i've been i've been focusing on trying to to add the what i like to think of the missing features to the language and once that is done i'm gonna if take some hammock time and evaluate should this target webassembly or or something else yeah there'd be an obvious next place to go right yeah yeah yeah okay so what what is your feature list my future list so so so in gram002 which came out in january i believe we supported compiling to different platforms so now you can target the browser platform which essentially just provides you apis that allow you to write browser single page applications essentially what elm already provides and but you can also say i'm gonna target node in which case you get some node specific apis and you can also say i'm gonna target neither of those platforms in which case you're limited to this cross-platform api that works in both worlds okay so that's what you can do now so you can write node applications or browser applications or you can write packages that can be pulled into both types of projects and then what i've been focusing on now for the last six months is testing and debugging so for a couple months ago i released the grand test framework so you now you can now pull in local meaning on disk projects that you can test before you do a release for instance and when the next release comes out girian will will create source maps which is a way of teaching the browser or node.js how the generated javascript output relates to the original source files so in the debugger in the chrome dev tools or whatnot you can actually debug gren source code instead of the generated javascript yeah yeah it carries a javascript error but it points you to where your code actually has some meaning exactly yeah not to mention you can actually step through gran code line by line that really helps so that's like the immediate thing that i'm working on and the next thing is working on what we're calling parametric modules or what is known in ocamel as functors okay so it's a way of saying that i have a module and this module requires requires some abstract module as input and then it will give you a concrete implementation of that module in return it's yes okay so so for instance i can create a dictionary module for a dictionary type and i can say that in order to actually realize this module in order to import this module you need to give this module a another module as input so it's kind of like a higher order module thing going on okay and that module has to have a type alias and a compare function for instance and then using that the compiler can kind of generate a dict implementation for you that is specialized for strings okay are integers or whatever type you wanna how is that going to differ from like just having type variables on on the regular module yeah so well i mean the normal way to solve things like this in other languages would be interfaces or type classes or protocols or whatnot yeah the difference here is that instead of doing runtime polymorphism where essentially we're essentially generating a new module for you ahead of time ah so yeah so we're essentially creating you a specialized dict module for every type you want to use it with instead of creating this runtime dictionary of types and matching implementations so is that more efficient when it finally gets to runtime it can be because the from a performance standpoint the benefit here is that the compiler will at any one time know exactly what functions and types are involved so the compiler can optimize around that whether we actually make use of that in the code generation depends because we since we're also targeting browsers i have to consider like code size as well oh yeah but you can do that like the compiler can in fact know exactly what types are involved instead of knowing that there are some dynamic thing here that i will figure out at runtime yeah because the generated types of javascript for a lot of these things is at runtime looking up in a hidden parameter dictionary itself which particular implementation it should be using for this single function call and that always feels kind of efficient so well of course the javascript runtime is specialized in this so it's relatively fast but you know so that is like from from a code generation standpoint that's the benefit you get like you know exactly what function you're going to call so you can optimize around that from a user standpoint i think the main benefit is that it's it's simpler because you as a user you also know the types involved right because you have to say that this is a string dictionary and so you also know exactly what types are involved and the error messages you get can potentially be a lot more concrete than saying you're supposed to send in a comparable but you've sent in not comparable right yeah yeah right so so we can we can be a lot more concrete in the feedback we gave to the user yeah yeah in haskell world it's great that you can be super abstract but sometimes your error messages are super abstract yeah and that's again that's in trying to keep with the tradition of being very approachable and and uh and i think that this will help us do that but another benefit that i think some people probably see as a downside is that it's very hard to be super abstract with this and i think that because you have to as part of importing the module you have to specify the exact type you're going to use and if you want like three dictionaries over three different types you have to import the module three times right so there's there is some boilerplate involved and if you are going to have a parametric module that takes in a parametric module that takes in like that sort of hierarchy yeah will be very difficult to model and that lack of flexibility in certain ways is i think a feature because it like some people will see that lack of flexibility and think ah this language is limiting i can't do exactly what i want but the effect of that is that you don't go too crazy on the abstractions yeah and so i think the net result is like that that little pushback will keep you dealing with concrete things and that overall is easier i think that comes back then to who is your target audience because it sounds like you're not trying to capture haskell people you've said you're not trying to capture the elm market are you trying to capture the typescript people [laughter] i think there is this there has been this thing said about i i don't know how to say but there like i i get this impression that a lot of people think that haskell is uh like a stepping stone to learn haskell l element to learn because because album is so simple that like you can learn ellen very easily and once you learn alan you will start to notice all that that it's so simple that you can't do like these crazy abstractions and that's when you'll take the next step and go to high school right yeah and elm is certainly simple to learn but i i also feel like the beauty of elm is that things never get too crazy that when you pull in the third party library you don't have to wrap your hands around why use this abstraction why use this thing and i think like for a lot of people who don't value i think sometimes you just want to get things done and so having a simple world is just really good for that yeah i think i'm just going to stop there because it it quickly becomes like ah these complexity loving people i don't like i i don't have anything against that but i personally i just enjoy simple languages that don't go too crazy on things there is a place for that like i enjoy i can enjoy dealing with language that has a lot like i can enjoy working in asco but not for work for work i just want to get things done without too much discussion and without like too much experimentation there's i love puzzles there's also no shame in shipping oh there's actually when i'm thinking uh actually another time to think about it's more there's another benefit to the parametric module approach and that is that there is some more flexibility in how to implement certain interface so in in haskell if you want to implement again we're going back to the dictionary example i i i'm gonna have a dictionary that dictionary is going to be sorted over some key yeah and if you are writing something where it's a benefit to know the sort order and make use of that then that can be pretty good but sometimes maybe you want strings to be sorted in the reverse order for some example yeah and if you want that then you would kind of like have to create a wrapper type in haskell and then you would have to implement a new comparison operator on that wrapped type yeah and you have to do that because you can't have two implementations of the same type class right you can't have and it's the same in java it's the same and go you can't have conflicting implementations of some interface whereas with the parametric modulus approach you can create a new module and that module can you know have functions that work on strings without wrapping it at all right you're sending it's the module that you're sending in as the input not a type and so if you wanted like a dictionary that sorted strings in reverse order for some reason you could just create a new module that module references the normal string type and the comparison operation would just be like a reverse compare and so you can okay you string a piece and then you can take the strings out and use them with any other string for function without unwrapping and wrapping to make that happen and you can use both in the single top level module without them conflicting exactly yeah yeah okay okay so that is another benefit of it okay if that's your feature list for for gren for the near future i get to ask about my feature list because there are a couple of things that bothered me about elm i'm wondering if you're gonna address the first is interop with javascript every now and then you want to do something from javascript and elm was always every new release had a new way of dealing with that which was usually a breaking change that was undocumented because if i can say this evan always punted the design question of interop do you have an answer so it's it's a it's a it's a tricky thing so i i get that you know for certain things you don't want to recreate the wheel reinvent the wheel by like if you want to use like a 3d library you don't want to invent like physics and and and 3d game creation just to be able to use some functionality in in now or get in right and that's that's quite relevant but the problem we have is that one of the one of the biggest benefits i think of l man of grim is that there are no exceptions to the guarantees it provides like you there is no mutability in them none you cannot even like there is no escape patch from that there is no other way like there are no exceptions and there are no escape patches for that there is manage side effects and there are no other way of dealing with side effects if you simply call javascript from anywhere then you can have mutation you can have exceptions you can't like and so having interrupt which essentially just lets you call javascript from anywhere breaks the guarantees of language yeah and that is something i'm super careful about maintaining like that for me like the the complexity of the language is one thing but also like the guarantees yeah being able to count on those guarantees are if you don't have that then you might as well in my opinion use purescript right so the trick is having a form of interrupt which allows you to do the things that would be too much of an ordeal if you were to rewrite or port the library that at the same time doesn't break the guarantees and i don't i don't like i've been thinking about it i know that the current system of using ports can work in certain cases but is very difficult in other cases and i've been thinking a little bit on how that could possibly be improved but at the same time it's it's it's a difficult question and it's not the most important thing right now so so so i i'll say this i agree with you that it could be better but it's also not easy yeah that's fair it's it's not it's not my near it's not in the near future i will probably look at it at some point but not right okay okay let me just quickly ask you then as an aside what because pure script's answer to this is you define the types of the javascript functions you want and you define the side effects it has and we will believe you and it's up to you to get it right what do you think of that approach so that's i i believe that's how worked in 0' 0 17 there was one release that took that away and everyone lost their minds me included yeah there were a lot like i get that because there were other you know there were a lot of people who had production code that relied on that thing we did as well and it was non-trivial to work around it what we discovered when we refactored a way out of that was that we did in fact have a lot of side effects not a lot but we had side effects and we had mutations in the program that we didn't actually realize that we had yeah and so by like by by writing ourselves out of it we actually fixed a few bugs in the process i think it was a race condition or something like that so and i you know i see it listens that api never went away it was just restricted to the core packages right so so ask the author of gren i there i did it again [laughter] so that's the author of gideon i i used an api constantly and even i mess up every now and again so i think like that's one way to go i don't think it will be i i hope to find something better than that because it's it's a it's a bit too easy to introduce and one thing is in your own applications right i have no problem with people breaking the world in their own application the trick is how to limit it to applications rather than libraries that get published yeah yeah because the the problem like so i remember another thing that was removed in elm zero' i believe was custom operators which i think it was sarah' and i i know a lot of i know a few people left the community because of that because they had written packages that made a lot of use of them and now suddenly they had to read everything to get it to work and i remember i remember we discussed it because i was a member of the core team at the time and one of the reasons for removing custom operators was that there was one package that did something and it was the only package that did that thing and it had the specific operator and it didn't have like a function implementation of it so you had to use the operator and i think the operator had like five five strange characters the operator was like it was a big entirely cryptic operator and i think like if you read code that included that stuff it was like this is not what i think album should look like yeah yeah so so uh it's yeah i don't i don't mind how people write their own applications the problem is when you have a package that implements something very important and you you're kind of like playing by that package's rules and so like the the thing that i think would be a shame is that if i allowed some limited form of javascript interop and that bleeds into a package and then that package introduces mutations or side effects or anything i would kind of feel like a big point of the grand language was lost yeah meaning so yeah absolutely because it's that's in practice and language is both its language and its libraries so the guarantees that you're trying to offer have to extend the library ecosystem come across to my other wishlist feature from elm which was package management was always very locked down and if you wanted to use like a package as a corporation if you had a package that you wanted to reuse across several projects that was painful under elm's package manager are you addressing that at all i i have actually so so i felt the same pain i think i wrote a third party package tool i guess for elm that was called elm gift install which allowed you to import code from private git repositories and it was a complete hack but it worked well enough in in grand the first release had to have its own like i couldn't rely on the unpackage manager obviously and so the solution i ended up with is that when you reference a package in gideon json it will actually it will actually turn that package reference into a github url and it will simply call your local git installation on that right github url so the package manager in gran is is simply using it and if you point that to a private github repository as long as you have access to that that will work okay and then i haven't gotten syntax yeah it's it does the job at least there is i haven't added syntax for referencing something other than github but there is no reason other than laziness for that so if someone comes along and says i would love to import stuff from gitlab then let's fix that right that's if someone gives me a syntax and everyone agrees that yeah this would be great then that can be out of there you make that sound desperately simple everyone agreeing on to intex [laughter] so so so yeah so it's essentially just a git based package manager have like this for core packages to enforce those rules we just talked about about not using certain private apis of the compiler if you try to download a core package then it will validate the signing key of the last commit to make sure that to make sure you're not trying to include a fork of the core library that does a lot of mutation or something like that right okay but other than that it's just a pure get based package management system that sounds pretty appealing to me that would that would have solved a few headaches in my previous life yeah yeah and yeah now when i you know when i did this professionally we only had like 90 of our dependencies were private dependencies that the corporation didn't want to get to be public so we had this problem a lot as well yeah yeah i've even for like personal projects i've had reusable libraries that just weren't in a state where i wanted to share them with the world you know even though it wasn't private it was just like i don't let people into my bedroom unless i have to yeah yeah and also it's it's also when like so when i'm creating new packages and i also have them private until it's ready to yeah to show it off right and being able to actually test that without doing magic is it's pretty good yeah so you've hinted on this in your easy hand waving of syntax but what's the development process is there a community around it is there a team is it just you on your own it's mostly just me at least to work on it regularly i have there is a tulip for gideon which everyone can join and i try my best to write down all the language changes and api chain well not necessarily api things but i tried to write down all changes to the language as a proposal and then i'll link it to the su loop and then ask for feedback the grand community isn't that big right now so mostly people just read it and gives me a thumbs up or something and you know i since it's since we're at this early state and i'm the the de facto benevolent dictator i do sometimes ignore feedback but i i try very hard to share all upcoming features and sync the exchanges to get as much feedback as i can and take that into the development process but when it comes but there are people have proposed things and people have implemented those changes after some feedback from me and there are people right now working on some major apis that they they mostly do on their own and then check back with me every once in a while and then we get those things merged so one i don't know if you i don't know if you've ever been angered by this course but in elm there is this limitation when updating records that the record you're updating has to be like a local variable it can't be any expression i don't think i've encountered that no well that is a limitation and i'm not going to go through like the reason for why that is the case but i've always well not always but i've i've disagreed with that design choice in the past so someone came into the su loop and say i want to remove this limitation i said fine and he did a pull request and then he got merged in time for grand o2 for instance cool okay so language change i'm open for language changes as long as they don't break with like the core principles of the language which is simplicity and having a very strict set of guarantees but also on the api front there is someone right now working on both the websocket api and they back in the http server api oh nice because that's another thing i remember the elm being a little bit all over the place with those websockets yeah yeah [music] this is a language it really suits like the whole architecture really suits the idea of real-time streaming websockets yeah so yeah i agree so and that's probably also one of the bigger changes from elm is the development model i try to be very open on suggestions and contributions from others so and and there's also a very there is a six month release cadence thing going on so yeah in general more open for contributions than than elements which isn't which isn't like i'm i just have to say that right now i don't necessarily disagree with the way their own project is run but there are there are trade-offs being made and i'm choosing a different path yeah with with the positives and negatives that are involved in that i you know i will i i'll allow myself to be a bit controversial there i think the thing about elm is it had a great design consistency because most of the development was kept in the head of one person who had great design shops the downside of that was the speed of development kind of waxed and waned depending on what his life was doing yeah and do you think that in the future that gren won't be entirely tied to robin hansen i hope so god i hope so like i have so that's the strange so i have i have i have a son who's turning three now and the thing that happens when you when that you know and when that happens to you which which is mostly good but what happens to you as a person is you start thinking 10 20 30 years down the line and i'm i'm doing gideon right now because i need something like this to exist and no one really stepped up to to do that and so i felt i had like if i'm not gonna do it that's it's just not gonna happen but i but i also have enough ideas and and for other things that i hope to be able to do someday in the future like maybe i spend 10 years on gran wow saying that out loud [laughter] but okay let's say i spent 10 years in green i hope to be able to like pass the torch to someone else but i but at the very least until grand reaches 1-0 until we have a community around it that are like that that until we have like a sense of what girian is and isn't then i think it it's best served by this single person development model well yeah in the future i hope to to change that i don't i don't expect or want to be in this role forever the benevolent dictator until you can abdicate to a democracy yeah yeah i had a i had a the year that i had a little bit of time in the university and i had this i had this t professor who once said that the ideal form of government is is dictatorship and where in st in place of elections you have public execution so after that like a dictatorship is is the is the most efficient way in the most consistent way of running a government but at some point you have to come to the conclusion that the dictator has to go maybe we'll apply that more to software models than says [laughter] yeah yeah we could very quickly go into completely different category of podcasts on that one so yeah so yeah but but i am like i am looking into so as i think like sig the language it's called sick i think so very interesting yeah yeah or zig for us audience yeah i think they've had andrew kelly i believe is the is the name of the creator of that one and i think they have had a very interesting approach where andrew kelly has been doing this in spare time and the language has evolved in a very consistent way and now recently the form the sig foundation the airport members and they've like gradually my impression is at least that it's gradually becoming a more democratized process okay if you were yeah so i'll be exploring that in the future but at least until we reach one hour it's probably going to be me with but with an open mind for external contributions okay tell me a bit about that road to wonder you've talked about some of the features but where are you trying to get to where will gren be five years from now modules thing and i'm gonna take a long hard look at the at the core packages and like so so there is it's a funny thing like if you look through the elm core package which granas inherited you will find this module that is called i think it's just called process and if you read the documentation it kind of hints that elm is aiming for this erlang style concurrency thing right but that it isn't finished so it's like watch this space more will come right and then nothing happened to it yeah so so one of the things to look at after the parametric modules thing is just go through the packages find the clues hidden there and then try to like complete complete the language in a way yeah and then another thing to explore and that is something i think which will just be a continuous evolution thing is to add missing apis there is this there is this mailing list entry email i guess that i i think you can find if you google for it but at once like long ago maybe in 2016 i think elm decided or evan decided that you know elm is going to be you won't be able to just use interrupt wherever you want right the thing you mentioned earlier like there was a point in time where that was decided and then people would ask well how do you support things like web sockets and how do you support you know other browser apis as they appear yeah and the answer at that time was well they're like if you think about it there really aren't that many web apis so creating like this immutable version of that api should be entirely possible and expose that to the to the ecosystem and i like that is i think that's part of the reason why alma stalled a bit because that is a lot of work yeah and you know finding people you trust to delegate that work to is necessarily easy but but i also think that's necessary if you want all the capabilities of the web platform or the node platform but at the same time remain or retain these immutable manage side effects guarantees yeah and where i'm going with this is that you know another thing to kind of like continuously work with on the road 210 is to find people who are willing to implement those apis and and kind of like help them through the process and yeah yeah so that's another important thing to do moving forward to just add apis and then it's going to be tricky to know exactly when to stop for instance but for but for note node has a built-in standard library that gives you a lot of the building blocks you need to further build anything on top of it really and so one of the things that i want to have before 1o is to support as many of those built-in apis that no dance yeah if someone wanted to contribute to that effort what are they actually doing are they writing gren are they writing javascript are they writing i think the compilers in written in haskell what skills do you need to be that person good question i i think i just you know to track back a little bit you know that i i think honestly i would be very happy if people just wrote gran and told me about the things they liked and didn't like that that would first of all be hugely helpful and and another thing that's usually helpful is like i mentioned that i published like language proposals to the grand tulip and getting detailed feedback on that would be nice so if you wanna if you want to help the project along you don't actually need to develop things for it just like giving your thoughts is is a very valid way of contributing like i said i i there is someone right now working on the http server api and i know he would love to get feedback on the current design okay so that's one way of contributing just you know provide your expertise and give feedback on the things that are in the works right now and if you want to contribute with code then it's really up to you i i yeah i would love help with the core library which mean you would be writing mostly grim but if you wanted to add support for web api there will be some javascript involved nothing too nothing too difficult but there is a the interop api you mentioned earlier it's still not very well documented and it will crash if you look at it in a strange way so they're like there there is there is some arcane lore you need to know in order to contribute javascript to your project yeah but entirely possible and if you want to help out in the compiler there are many things to do there and yeah that would require haskell knowledge okay so at this at this stage of development you can help him pretty much anyway or form you like okay then we should probably end on how you just rather become rather than becoming a contributor we should end on how you become a user so i know you start with npm install gren hyphen lang yeah what should i do after that so i think it's yeah so well i guess if there is an attempt at documenting the language at our website so there's a there's a link to a book it's mostly unfinished and if people would love to help out on that i'd welcome it but you get some documentation of the language there and at this moment in time the language is still resembling elm even though it's not 100 compatible so if you find home resource you can learn learn a lot there as well and then we have a packages website that contains documentation for the core package and most of the official packages and if you develop a package you can also register it at the site and get documentation uploaded there and and yeah get the word out essentially cool well that sounds like another fun thing to add to my to-do list of things to play with i might try porting some of my old untouched elm code and see how that works out well i i would love to have remote data my one claim to fame in the functional program yes yes cool that gives me a it gives me a project for the next few weeks robin thank you very much for joining us oh no worries thank you for having me thank you robin so an accessible safe functional language that's targeting all the places it needs to take you i think there are a few people vying to be the leaders in that space but i also think whoever wins you and i win right we're the richer for it or maybe it's not a competition at all maybe it's just this rich pool of ideas that are going to take us swimming to a better software future regardless we'll be back next week with more wonderful ideas floating in that pool so now might be the right time to hit subscribe or like or rate or share and let the algorithms know that you want to know when we're back in the meantime if you want to try writing some gren there's a link to grenlang.org in the show notes there's also a link to some example gren projects which is a great way to see what it would be like to write gren in practice and i'll also put a link to elmlang.org in the show notes too in case you want to kick the tires on elm and that should be more than enough food for thought until next week so i'll sign off i've been your host chris jenkins this has been developer voices with robin hegland hansen thanks for listening thank you