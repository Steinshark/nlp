well, let me begin by asking you a question okay, what do you think the simplest program we could write well not being a programmer but having done a lot of computerphile videos. i suspect we're going for hello world here so, yeah hello world i mean, it's probably the classic one everyone start with if we... we can even write it on a piece of paper i'm going to use c to talk about this. you could write it in any programming language of your choice let me guess you walked into dixon's and wrote a rather rude version of hello world. i didn't you, probably did oh, so the scrolling on the screen thing your basic is effectively hello world it's basically hello world so i'd go some prints something and then yeah, that's the more advanced version. but yeah, i think so we could write it and see we have our main function we have to have a few arguments if we're doing this properly because otherwise we'll get complaints in the comments and then we can do a printer hello dot dot backslash ames we want to go to a new line at the end and a head of files and we've written heather world these pens are bought because they're a bit quieter and yet there's always a compromise somewhere isn't there's no other perfect pen now we've got pens that you can't actually read so there's a hello world program and on the face of it it is one of the simplest programs you can write you can understand the instructions that's going on and it says print whatever string it is. hello world and it print it out. you compile it and you run it but actually when you think about what's going is it a lot a lot of functionality is being hidden behind there it's a good illustration and one of the things you see a lot in computer science is that we build computer systems by using layers of abstraction so we're making use of a code library. so what we've already got here is a level of abstraction in that printf does a lot of things it can do more than just print out a single line of text we can actually get it to print out numbers integers as text so we can read them on the screen and it will convert them from the integer to think so that's code libraries hiding a whole layer of instructions so we can think about this in terms of we get another bit paper. let's turn it upside down and use the australian version we can think about we write our program and we're writing it and i've used the wrong pen again we're writing it in c and we're making use of that c standard library to actually make it do things but of course as we know the computers don't understand c. they understand their machine code. so actually we already have to convert this into the machine code for the program so we convert it into the machine code for the cpu that we're running on in this case it's an x86 thing, but we could run it on a six eight thousand. we could run another zed 8006 five or a two powerpc whatever type of computer you wanted to so we've already got on two layers of abstraction there we've got without stretching away how the hardware works because as soon as you write it and see we can then compile it to run on different cpus but we've also started to abstract away how we actually print something out so we can use printf to print a number we can use it to print text but we don't have to know how to convert a number into text what does the f stand for? okay. well, that's a very good thing printf time to print formatted and that's what i was talking about so you can say i want to print this number and you can also say i want it formatted to look like this so i want this many of leading zeroes. i want this many decimal places afterwards and so on you can format the output hence the app so we've got a program here we've got a hello world program and we want to print out the variable with a 42 in it we can say print out hello world and we can put a % d in there. just say we want to print out a number and then we can compile that program of course they have not made any mistakes and if we run that thing it prints out the number 42 and again, this is a good example of that abstraction. if i were to print out that number with four leading zeros, i can say % 0 for d compile it again and it prints it out 0 0 for 2 all that sort of complexity well do i print out that number okay, well had open time ago divide it by 10 the remainder will be that did you i need to put it last than the rest of the number and then i drew that again that's all abstracted away from me as a programmer. i can think about what i want to write at a high level, which is our different out hello world followed by the number with two leading zeros, and we could write that so we've already abstracted that away but that standard library then still needs to print that out. so it needs to take each of the characters its generated and print them out on screen or send them to the serial teletype that you're dealing with or however it is you're outputting these things because if you think about it a modern computer system i'm sitting at my computer here typing the commands in to run that program just written on this system but i could have logged in remotely using ssh or something to another computer system and run the program there and then it would have had to do something different so in this case, it's printing it on my local screen if i'd logged in to a different machine you would have to run the program there send the characters. he wants to print having encrypted them to my machine and then print them out sue got a different thing so even the c standard library is built to print things out but it's built on and i was stretching in this case that abstraction is the operating system so we can add another layer of abstraction, which is the operating system and most operating systems. certainly the modern ones. we get unix windows mac o s-- viscose whatever one you were to do will provide some level of abstraction so you can just say print this and it will then send it to the right thing and do the right thing based on what you go so i hello world program are suddenly gone from being one line that prints things out, but that's then opened a can of worms because it's using a library it's also being converted to machine code we can see that so we can tell the compiler to just produce the machine code for us and then if we open that up we get the machine code version here. and as you can see that's quite a lot more lines of text that we've got there we can see there the call to printf and we're doing various things to get that how that works is perhaps another video on how we call the function in the machine code so let's backtrack a bit from printf because as we've talked about that's a more complicated implementation it can format the text and let's just think about how we can just print a single string to the screen so let's rewrite this program to use put's which is another c standard library function that can print out. i think this one can't do formatted text so remove our additions and so we now got a slightly simpler version of hello world that still does the same thing and then it prints out hello world it also prints an extra new line because puts my app as a standard output it adds a new line to use it got slightly from bit of functionality but we can start to think about how that works. so what that is given as input is the string hello world, which is arranged in memory suddenly. our program is getting more complicated because we're actually having to think about how things are stored in there as basically a series of memory locations one after the other with the h followed by the e followed by the l followed by another l followed by an o and so on and so what pot-stirring would have to do for a naive implementation would do is its points at the h it gets that character prints it out to the screen and it gets the next character prints it out to the screen then it gets the next character prints out of screen and so on until it gets to some end marker which in c is done by putting a 0? character the ascii code 0 to represent the end of string or the programming language do it differently pascal for example, put the length of the string at the beginning as a number so it's said to be x characters and then it print out x characters c says the strings ended by putting a 0 at the end so we've already what looked like a simple program when we take away the layer of abstraction becomes more complicated now actually if you were to implement this you wouldn't print each character separately because to print it we said we have to call the operating system and every time we call the operating system we have to pass control from the user mode to supervisor mode the operating system's mode which takes some time. so actually what we would do send it directly as a string to the operating system and then the operating system will print out that whole string for us so we can change our program to do that in that we now use the command write write consented lots of different places so we can set it to the standard output which on unix is number one? send the string and now we need to tell it how many characters there are so hello has got five worlds got five that's ten. i've got a space and a new line. that's 12. so we want to send 12 characters so let's compile that version up and i haven't put the right header in for that so we're getting a error message that was included to my harridans it's to work and now if you run hello world, it's still prints. hello world but we've taken away another layer of abstraction in that this case my c program is directly calling the operating system so we removed that level of abstraction now as we said the operating system code then has to interact with all the different things and on a system like unix because of the heritage of it back to the 1970s and earlier it emulates a tele time machine and a teletype machine was basically typewriter that was controlled by electronics and you sent the characters and in move things one after the other printing the characters out onto paper not unlike this and then when you sent the line feed character you actually move to the next line actually the original teletypes required you to send both a carriage return and a line feed because you have to send the thing back to the beginning of the carriage so these are mechanical bits of there's a mechanical bits of things and actually you still see this today the reason why unix and windows differ on how text files are encoded is that windows and carries both the carriage return which sends things back to the end and the line feed to go on to the next line that you have to send? to the teletype whereas the eunuch said. well actually what was going to send that different things have different things will just send a line feed and so the unix operating system abstracted that away so our hello world program simple and is simple because there's a whole load of other things going on which are hidden from us they're abstracted away so we can think about it in terms of i want to print out this line of text but actually under the hood there's lots of things going on extra bits of code which are doing things even things like when it appears on screen? the operating system is having to think. well, actually, i've got to draw the dots that make up the edge here and because the way a teletype certainly in the western world has been designed to work means of the ease following that then i've got to fin the e after that and work out what positions they're going on. and so if you were to look at all the code necessary to write hello world from the bare hardware bearing in mind that you've got to find out what hardware you've got on there and then talk to it in the right place you find it would be a lot of code to do a very simple program like hello world. is there a simpler program? it's a program. it doesn't do anything well if i just delete that we think that a program that starts and stops and doesn't do anything with that still call operating systems and open libraries and things so this is interesting things that yeah, this is a good point is that actually that program if we compile it and have a look at the machine code? we now see that actually there isn't much there. this is basically the whole code here. the rest is just setting up various things so it works what the compiler have done things there then and yes, we've now got we've got about four or five instruction but that isn't the beginning of our program when you compile the c program? there's an extra bit that's joined on to the beginning that's linked onto the beginning which sets up the operators and research how much memory this program needs and so on and gets things to the point where that prone could work? so actually that isn't the whole program but it's getting close enough and of course we still have to bear in mind that we've got to boot the computer when we turn the computer on the computer starts in a defined way. it starts executing code at a defined location your bios is then there in a modern machine or you fei in a really modern machine executing things that will then start to the point where it can load the operating system the operating systems loading up so it can talk to various other things and so on and there's all these layers hidden behind this to the point where we can just literally type run this program layers of abstraction are great in computer science because it means that we can think about the program. we want to write hello world rather than having to think about all the nitty-gritty details that we actually to get that implemented now the problem is if i send this off to the website i've just given them my password i mean not quite because sha-1 is hash but that could be broken especially if my password is not good right and also he's got a bunch of these passwords and hashes already computed in this database so as soon as he sees that i've got the hash