let's imagine that you work for a major streaming media provider right? so you have i know some 100 million drivers so you've got i don't know ten thousand videos on your site or many more audio files, right so for each user you're gonna have collected information on what they've watched when they've watched it how long they've watched it for whether they went from this one to this one. did that work? was that good for them? and so maybe you've got 30,000 data points per user we're now talking about trillions of data points and your job is to try and predict what someone wants to watch or listen to next best of luck so we've cleaned the data we've transformed our data everything's on the same scale we've joined data sets together the problem is because we've joined data sets together perhaps our data set has got quite large right now or maybe we just work for a company that has a lot a lot of data certainly the general consensus these days is to collect as much data as you can like this isn't always a good idea we what we want remember it's the smallest most compact and useful data set we can otherwise you're just going to be wasting cpu hours or gpu hours training on this wasting time we want to get to the knowledge as quickly as possible and if you can do that with a small amount of data that's going to be great so we've got quite an interesting data set to look at today based on music it's quite common these days when you're building something like a streaming service for example spotify you might want to have a recommender system this is an idea where you've maybe clustered people who are similar in their tastes, you know what kind of music they're listening to and you know, the attributes of that music and if you know that you can say well this person likes high tempo music so maybe he'd like this track as well. and this is how playlists are generated one of the problems is that you're gonna have to produce descriptions of the audio on things like tempo and how upbeat they are in order to machine learn on this kind of system right, and that's what this data sets about. so we've collected a dataset here today. that is lots and lots of metadata on music tracks right now. these are freely available tracks and freely available data and put a link in the description if you want to have a look at it yourself i've cleaned it up a bit already because obviously i've been through the process of cleaning and transforming my data so we're gonna load this now this takes quite a long time to do because there's quite a lot of attributes and quite a lot of instances it's loaded right? how much is this data? well, we've got 13,500 observations that's instances, and we've got seven hundred and sixty-two attributes, right? so that means another way of putting this if in sort of machine learning parlance is we've got thirteen thousand instances and 760 features now these features are a combination of things. so let's have a quick look at the columns we're looking at so we can see what this data sets about so names of music all right, so we've got some 760 features or attributes and you can see there's a lot of slightly meaningless text here but if we look at the top you'll see some actual things that may be familiar to us so we've got the track id album id the genre, right? so jean was an interesting one because maybe we can start to use some of these audio descriptions to predict what jean with its music is or something like that things like the track number and the track duration and then we get on to the actual audio description features. now. these have been generated by two different libraries the first is called lib rosa, which is a publicly available library for taking an mp3 and calculating musical sort of attributes of it what we're trying to do here is represent our data in terms of attributes an mp3 file is not an attribute it's a lot of data. so can we summarize it in some way? can we calculate by looking at the mp3? what the tempo is what the amplitude is how loud the track is these kind of things this is a kind of thing we're measuring and a lot of these are going to go into a lot of detail down at kind of a waveform level so we have the lib roza features first and then if we scroll down after a while we'd get to some echo nest features. echinus is a company that produces very interesting features on music and actually these are the features that power spotify is recommender system and numerous others we've got things like acoustic nurse. how a coup stick does it sound we've got instrumental nurse i'm not convinced that the word speech enos their hat hat to what extent is it speech or not? speech and then things like tempo how fast is it and valence? how happy does it sound right a track of zero would be quite sad? i guess and a track of one will be really high happy and upbeat and then of course we've got a load of features. i've labeled temporal here and these are going to be based on the actual music data themselves often when we talk about data reduction we're actually using its dimensionality reduction right well way of thinking about it is we as we started we've been looking at things like attributes and we've been saying what is the mean or a standard deviation of some attribute on our data but actually when we start to talk about clustering and machine learning we're going to talk a little bit more about dimensions. now. this is in many ways the number of attributes is the number of dimensions it's just another term for the same thing, but certainly from a machine learning background we refer to a lot of these things as dimensions so you can imagine if you've got some data here so you've got your instances down here and you've got your attributes across here so in this case our music data, we've got each song. so this is puts on one this is on two song three and then all the attributes of a temple echo nest attributes its tempo and things like this these are all dimensions in which this data can vary so they can be different in the first dimension, which is the track id but they can also down here be different in this dimension which is for tempo when we say? some data is seven hundred dimensional what that actually means is it has seven hundred different ways or different attributes in which it can vary and you can imagine that first of all this is going to get quite big quite quickly my seven hundred a tribute seems like a lot to me right and depending on what the algorithm you're running is it can get quite slow when you're running oh this kind of size of data and you can maybe this is a relatively small data set compared to what spotify might deal with on a daily basis but another way to think about this data is actually points in this space so we have some 700 different attributes that you can vary and when we take a specific track it sits somewhere in this space so if we were looking at it in just two dimensions you know a track one might be over here and track two over here and track three over here and in three dimensions track four might be back at the back here. you can imagine the more dimensions we add the further spread out these things are going to get but we can still do all the same things. we can in three dimensions in 700 dimensions. it just takes a little bit longer so one of the problems is that some things like machine learning don't like to have too many dimensions so things like linear regression can get quite slow if you have tens of thousands of attributes or dimensions so remember that perhaps the the default response to anyone collecting data is just deflect it all and worry about it. later this is a time reporting when you have to worry about it. what we're trying to do is move any redundant variables if you've got two? attributes of your music like tempo and valence that turn out to be exactly the same why are we using bo for making our problem a little bit harder right now in actual fact echo nests features are pretty good they don't tend to correlate that strongly but you might find where we've collected some data on a big scale actually a lot of it variables are very very similar all the time and you can just remove some of them or combine some of them together and just make your problem a little bit easier so let's look at this on the music data set and see what we can do so the first thing we can do is we could remove duplicates ryba sounds like an obvious one and perhaps one that we could also do during cleaning, but exactly when you do it doesn't really matter as long as you're paying attention what we're going to say is music all equals unique of music all and what that's going to do is look for find any duplicate rows and remove them the number of rows. we've got will drop by some amount. let's see thinking it's where you live timer actually, this is quite a slow process you've got to consider that we're going to look through every single row and try and find any other rows that match okay, so this is removed a bit about 40 rows so this meant we had some duplicate tracks you can imagine that things might get accidentally added to the database twice or maybe two tracks are actually identical because they were released multiple times or something like this now what this is doing? the unique function actually finds rows that are exactly the same for every single attribute or every single dimension, of course in practice you might find that you have two versions of the same track, which differ by one second they might have slightly different attributes hopefully they'll be very very similar. so what we could also do is have a threshold where we said these are too similar they're the same thing. the name is the same. the artist is the same and the audio descriptors are very very similar maybe we should just remove one of them well, this is the other thing you could do just for demonstration what we're going to do is focus on just a few of the genres in this data set right just to make things a little bit clearer for visualizations we're going to select just the classical jazz pop and spoken-word genres, right because these have a good distribution of different amounts in the data set so we're going to run that we're creating a list of genres. we're going to say music is musical where any time where the genre is in that list of genres we just produced? and that's going to produce a much smaller dataset of 1,600 observations the same number of attributes or dimensions now normally you would obviously keep most of your data in this is just for a demonstration but removing genres that aren't useful to you for your experiment is a perfectly reasonable way of reducing your data size if that's a problem assuming they've been labeled right in the first place, right that's on someone else. that's someone else's job let's imagine but 1,600 is still too long. now actually computers are getting pretty quick. maybe 1,600 observations is fine, but perhaps we want to remove some more the first thing we could do is just chop off the day to half way and keep about half. so let's try that first of all, so we're going to say the first music that's the first few rows of our music is rows 1 to 835 and all the columns. so we're going to run that and that's even smaller. right so we can start to whittle down our data. this is not necessarily a good idea we're assuming here that our genre is equally, you know, randomly sampled around our data set. that might not be true you might have all the lock first and then all the pop or something like that if you take the first few, you're just going to get all the rock right depending on what you like that might not be for you so let's plot these on was in the normal data set and you can see that we've got very little spoken word but it is there we have some classical international jazz and pop in sort of roughly the same amount if we plot after we've selected the first 50 you can see we've lost two of the genres like we only have classical international and jazz and there's hardly any jazz. that's not a good idea. so don't do that unless you know that your data is randomized so this is not this is not giving us a good representation of genres if we wanted to predict jonatha, for example based on the musical features cutting out half the genres seems like an unwise decision so a better thing to do will be to sample randomly from the data set so what we're going to do is we're going to use the sample function to give us 835 random indices into this data and then we're going to use that the index our music data frame instead alright, that's this line here and hopefully this will give us a better distribution if we plot the original again it looks like this and you can see we've got a broad distribution and then if we plot the randomized version you can see we've still got some spoken. it's actually going up slightly, but the distributions are broadly the same so this is worked exactly how we want so how you select your data? if you're trying to make it a little bit smaller it's very very important and consider but obviously we only had 1,600 here and even the human is whole data set is only 1,300 rows you could imagine that you might have tens of millions of rows and you've got to think about this before you start just getting rid of them completely randomized sampling is is a perfectly good way of selecting your data. obviously, it has a risk that maybe if the distributions of your genres are a little bit off and maybe you haven't got very much of a certain genre you can't guarantee that the distributions are going to be the same on the way out and if you're trying to predict jama that's going to be a problem. so perhaps the best approach is stratified sampling this is where we try and maintain the distribution of our classes so for example in this case genre so we could say we all we had 50% rock 30% pop and 20% spoken and we want to maintain that kind of distribution on the way out even if we only saw about 50% right? this is a little bit more complicated in our but it can be done and this is a good approach if you want to make absolutely sure with distributions of your sample data are the same as your original data. we just looked at some ways we can reduce the size of our data set in terms of a number of instances or the number of rows can we make the number of dimensions or the number of attributes smaller? because that's often one of the problems and the answer is yes and there's lots of different ways we can do this some more powerful and useful than others one of the ways we can do this is something called correlation analysis so a correlation between two attributes basically tells us that when one of them increases the other one either increases or decreases in general in relation to it. so you might have some data like this. we've actually won and we might have attribute two and they sort of look like this these are the data points for all of our different data obviously we've got a lot of data points and you can see that roughly speaking they kind of increase in this sort of direction here like this now it might be but if this correlation is very very strong. so basically attribute to is a copy of attribute one more or less maybe it doesn't make sense to have attribute two in our data set. maybe we can remove it without too much of a problem what we can do is something called correlation analysis where we pitch all of the attributes versus all of the other attributes we look for high correlations and we decide ourselves whether to remove them now, sometimes it's useful just to keep everything in and try not to remove them too early but on the other hand, if you've got a huge amount of data and your correlations are very high this could be one way of doing it. another option is something called forward or backward attribute selection now this is the idea that maybe we have a machine learning model or clustering algorithm in mind we can measure the performance of that and then we can remove features and see if the performance remains the same because if it does maybe we didn't need those features so what we could do is we could train our model on let's say a 720 dimensional data set and then we could get a certain level of accuracy and record that then we could try it again by removing one of the dimensions and try on 719 and maybe the accuracy is exactly the same in which case we can say well, we didn't really need that dimension at all and we can start to whittle down. are they set this way? another option is forwards attribute selection this is where we literally train our machine learning on just one of the attributes and then we see what our accuracy is and we keep adding attributes in and retraining until our performance plateaus and we can say you know what? we're not gaining anything now by adding more attributes obviously, there's the question of which order do you tribus in usually bandim? lee, so what you would do is you would train on all the data for example of a backwards attribute selection you take one out at random if your performance stays the same you can leave it out if your performance gets much worse you put it back in and you don't try that one again and you try a different one and you stole slowly start to take dimensions away and hopefully whittle daniel data let's have a quick look at correlation analysis on this data set you might imagine that if we're calculating features based on the mp3 from lib rosa or echo nest maybe they're quite similar a lot of the time and maybe we can remove them let's have a quick look. so we're just going to focus on one of a set of lib rosa features just for simplicity so we're going to select only the attributes that contain this chroma kurtosis field which is one of the attributes that you can calculate using lib rosa so i'm going to run that we're going to rename them just for a home simplicity to kurt one kurt - kurt 3 and then we're going to calculate a correlation matrix of each of these different features versus each other like this ok, finally, we're going to plot this and see what it looks like hopefully we can find some good correlations and we could have candidates for just removing a few of these dimensions if it's redundant and it's not too bad so you can see that we've got for example kurt 7 here. so index 7 is fairly similar to 8. that's a correlation of 0.65 maybe that means that we could remove one over two of those. this one here is 0.5 nine we've got a point four eight over here these are fairly high correlations if you're really stretched for cpu time, or you're worried about a size of your data set this is the kind of thing you could do to remove them of course, wherever point six five is a strong enough correlation that you want to delete and completely remove one of these dimensions it's really up to you and it's going to depend on your situation one of the reasons that the correlations aren't quite as hard as you might think is that these libraries have been designed with this in mind if you just if echo nests just produce 200 feet all exactly the same. it wouldn't be very useful for picking playlists so they've produced 200 features that are widely different. so we're not necessarily going to correlate all the time, right? that's the whole point and that's a really useful feature of this data we've looked at some ways we can try and make our data set a little bit smaller remember our ultimate goal is a smallest most sort of useful data we can get our hands on right then we can put that into machine learning or clustering and really extract some knowledge the problem is that what we might do may based on correlation analysis or forward backwards attribute selection we might just be deleting data and maybe the correlation wasn't one. it wasn't completely redundant do we actually want to completely remove this data? is there another way we can transform our data to make more informed decisions as to what we remove and more effective ones? that's pca or principal component analysis at the moment. we're just fitting one line through our two-dimensional data there's going to be more principal components later, right? but what we want to do is we want to pick the direction through this data however, many attributes it has that has the most spread. so how do we measure this? well quite simply