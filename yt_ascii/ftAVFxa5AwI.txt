real time data is sneaking into our world as a software requirement it's already there in some sectors there are some apps we expect to be real time like chat apps i type in a message i hit send i expect it to reach the destination pretty much instantly and if you can't send it that fast i'm probably just going to use a different app at the other end of the spectrum of speed there's probably my bank i would like to know the instant money leaves my account i think i have a right to know that but my bank doesn't do that they probably give me the information next business day and i'm probably not going to switch banks just because of that and then there are plenty of services in the middle ground where i kind of expect my taxi to give me real time updates of when it's going to arrive and i favor services that can provide that it's not a deal breaker but certainly those people go to the top of my list and that's why i say realtime data sneaking into our world some places it's a hard requirement some it's a nice to have some we can probably live without it it's probably a decade away from being the norm so that raises a bunch of questions to me and i'm interested in that sector i'm interested in these questions how important is realtime data how much user demand is there is it maybe a competitive edge thing if we can train users to expect faster updates with the business is providing it start to take over that sector personally i'd like to see some kind of data revolution where real time is a default and batch becomes rare but we're clearly not there yet an industry so what's holding us back do we still need some killer use cases are we waiting for the tech stack and the development experience to catch up is it a mindset shift thing is it just a case that the status quo is good enough joining me to discuss all that that i've got thomas camp he works at a they do realtime messaging infrastructure with a focus on the front end and i thought he'd be a good person to talk to most of my work in the real time space has been in the back end most of his in the front end in the user facing stuff so i thought it'd be good we could have a chat and chew through that balance of user demand versus our technology's ability to supply and as we go we try and figure out what's blocking the industry and what road map is to bringing that ideal future a little bit closer before we get stuck in i should probably clarify for the sticklers we are talking about soft real time here not hard real time so i'll give you my favorite definition of the difference if you want to build a self-driving car you probably got a camera in there that's going to capture the road 50 times a second and there's probably a component in there that can look at a picture of the road and say does this contain a stoplight and you've got 20 milliseconds to answer that question and if you can't answer within 20 milliseconds don't bother answering at all because the picture's out of date there's a new picture and there's a new question so at the 20 millisecond point the value of answering the question drops to hard zero and that's hard real time and that's the topic for another podcast soft real time doesn't have a drop dead date but now is better than in a minute is better than in an hour is better than start of next business day the sooner you answer a question the more valuable it is that's soft real time and with that difference defined it' be more valuable for us to move on to the discussion sooner rather than later so i'm your host chris jenkins this is developer voices and today's voice is thomas [music] camp [music] tom welcome to the podcast how you doing hey i'm doing well then kris how are you doing i'm good i'm good i'm i'm thinking back to the last time we saw each other in person and that was after a conference in a karaoke bar so i'd like to invite you to sing any answers you feel are appropriate oh no honestly with my experience in that karaoke bar i would not be singing a thing it was it was a dead drop moment i hate to say it but it's one of my favorite nights of the year so far so that's good i'm glad yeah but we're not here to talk about karaoke we're here to talk about a topic that's strong in my heart and is your day job too which is real time data and why isn't everyone doing it yeah i mean it's a good question there's a lot of things about it as you obviously you're very aware because you you've been incredibly involved in the space yourself yeah it's so we there are lots of ways we can tackle this but let's start with why don't we take a list of the obvious cases where real time dat is prominent and see if we can figure out what it's offering and then we'll delve a little deeper so what would you say are the the poster child headline cases h well i would say probably the most commonly used would be chat applications where you know if you think back to i mean quite a while again ago because even like msn had live updates but it would be you know where if you had a conversation where you needing to refresh the page every single time you wanted to actually see what other people have been saying or you're only getting updates once every like you know 10 five seconds or something yeah and and getting like suddenly 50 messages come through from your active chat that is not a very enjoyable experience because you're not able to have a fluent conversation you're not able to have these sort of realistic ex interactions with one another as you would in real life where you know someone says something you can straightway reply and just generally it adds you know if you're needing to refresh every 50 seconds or something then that's just you don't want to be doing that it's the same for email where you know again like these days at least they give an indicator at the very least saying you know more messages are available do you want to load those and again if you just had no idea this kind of lack of knowledge of the end user in these sorts of situations is quite detrimental to the use case because if you aren't aware there's a chat message then you need to be taking the initiative constantly to check if there is an update if there is anything that you need access to and you might fall behind on conversations you might miss communications be it in work which is obviously very bad if you're missing a message coming through or in you know personal conversations where again probably the other person won't like you if you're i mean even with real time updates to be honest i'm still terrible at not replying to a message for a good day and like guil char but at least that's on me then and not on the technology and it not notifying me yeah yeah we should be the limiting factor not not data transfer yeah yes if real time communications can resolve that perfect but not today but yes and then i would say outside of chat usually another common use case would be more of like a broadcast scenario so for example where it's the end users are receiving updates from some kind of central source so that would be like let's say news updates from websites where it's you know bbc might send out a notification saying that this has happened or there's been a live update on this occurrence yeah breaking stories yes exactly or a let's say a delivery app like uber eats or something where they'll be bring food around and you'll be having live updates as to the position of the delivery driver you'll get a notification saying that they're nearby you'll get a notification when they're at your door you get notifications the entire time and updates to the situation and i think for myself that's been incredible just in terms of my personal experiences with it because suddenly you're like how long do i have until the person's going to be here realistically yeah know back even like you know kind of 5 10 years ago you'd have to kind of go okay well the guesstimate they provided was they'll be here in half an hour so maybe it'll be maybe it be 10 minutes before that maybe it'll be you know 20 minutes after that but suddenly the moment you can see exactly where they are you know how close they're coming if they're even coming towards you or something odd has happened and they go in the opposite direction you can react and send a message saying hey what's going on which again for some reason that's happened to me a couple times my burger exactly you're starving and suddenly you see they're going off somewhere else you're like what are you doing that's an interesting dividing line though isn't it because like chat apps they don't they don't really exist unless it's real time whereas like delivery services taxi services they still they would still exist without that but it's a serious competitive advantage you're more likely to choose a place that gives you real-time notifications the second time once you've experienced it's like everyone else goes to the back of the queue yes i mean i would say definitely from my experience in let's say deliveroo there sometimes you have the tract orders the untracked orders and they let you know ahead of time and i will always pretty much only as long as there's an option for it go for a tracked order because i want to be able to know what's going on i want to be able to be able to get these notifications and updates because i want to i don't want to be left kind of for two hours with no information on where my food is or what's happened yeah versus at least if it's being tracked i'm getting actual updates i'm aware of the situation and it gives me that sort sort of at least an input and a control over what is happening at least a sense of progress that you aren't just hoping that they haven't forgotten you well yes exactly and if they have forgotten you at least you're aware of that because you're like right well they're just not coming towards me so you can do something about it yeah yes you can reach out to support or something like that at least but yeah and then you've got that whole category of things like like google docs right where that's something where real time data i mean couldn't exist before that yes i mean that's an interesting thing where again the core kind of experience which is editing a document that obviously existed before but yeah but the collaborative collabor collaborative aspect is what is the real value point suddenly but in you know before it existed that wouldn't have even been considered as an option as a as a selling point where it's it's almost a completely new product because this feature is so important allowing for anyone across the world to all edit a document together ask questions raise comments see what other people actively working on so all of these kind of small features inside of it which are only available because of the real time elements that allow for it to be such a useful tool it's every single thing even just from the little kind of avatar stack to see who's there at the top right with the little fun animal faces or whatever then that in it s is great because it lets you know ah this other person is in this document i can now communicate with them and ask them a message and be like hey i see you're looking at this can you you know what do you thought of that or it allows you to you know click on them and you go to exactly where they're editing and all of those elements together do almost create an entirely new product and new experience which makes it i would say considerably more valuable than just editing your own document because ab even in terms of just like capacity to share it like you know if you have have to edit something on your own local machine you still have to then go and upload it somewhere or provide it directly as a download to someone else yeah that is just i don't want to do that these days you got better options i remember the days of emailing around a word document and everyone arguing over which was the latest version oh yes exactly and it seemed like google solved that problem but at some point along that journey from having a single document where everyone goes to it it opened up this thing of let's open a document to collaborate and everyone works with through the document yes well i think that's the thing right it's like every aspect of the editing process has been enhanced it's as you say knowing what exactly is the definitive version of the document it's the see being able to look at a document and go through each of the lines at the exact same time and make live edits as requested for example we could be on a video call and i'll just have it rather than having to share my screen of my local document instead it's everyone can see it directly in their own place and they can see exactly follow my cursor to see where i go and what i do in that document and then obviously for the actual kind of commenting and creating edits and suggestions and everything like that that's just so valuable to have that so it's everything about the experience had been enhanced by a real time integration of some kind even if it's in different ways in each time in different ways each application of it yeah yeah i totally i totally agree with that but it's so the thing that really interests me is we have this we have a few places where real-time data is obviously enhancing or even creating the experience and then we have the rest of the industry the rest of the user experience of the world and i i don't know i want your opinion i have my opinions but i've got you in to give me your opinion do you think that we've kind of okay so there's this subsection where real time is a good thing and that's the beginning and end or do you think the industry is dragging its heels and not trying this technology or do you think there are some hidden gems that we don't know of of where this has a really great advantage yeah let's think so let me try and break it down so i guess first question of industries are they dragging their heel or why has in real time not been integrated in certain use cases i would say that i can't really imagine from the user side of things pretty much any use cases where real time wouldn't be superior maybe a bit as in a bold claim i'm sure someone's going to comment say you know ah this use case this cas i'm probably i'll be wrong but for the vast majority from just the user side not in terms of implementation not in terms of work required or potential things to go wrong wrong generally having information more readily available to end users is going to be a benefit to the end users and inherently a lot of features can be added to many use cases such as we said with like document editing or recently there's been more kind of collaborative spaces such as like whiteboards with mirror or things like that yeah which have become more and more popular now that they've kind of established it as this is a thing that can exist and it's very useful where before you know again it would be the same thing where you have local documents you have to be sharing around and it's a whole mess but without having these kind of leaders in the space these kind of new startups coming up and being like this is what we are going to focus on because we think this is a niche in the space i don't believe that many large organizations are going to feel the impetus to go towards the real time aspects largely because if something is working for them then why would they put in the extra engineering effort why would they risk a new kind of thing that can go wrong why would they put in the money and time and resources into something experimental when what they're currently selling which is you know a local version of these kind of collaborative experiences well sorry not collaborative experiences but editing experiences and whatever they may be selling is working fine for them so i think generally it's very hard to kind of justify because i would say generally i would i think that having persisted connections and persisted kind of state management and having to worry about fall over with these the state management and such has an inherent higher cost directly associated to it than a restful kind of communication because there's more that can go wrong i would argue okay we need to get into that because i i find that answer initially depressing yeah cu you're saying well the status quo is safe and i don't i want to know where we're going not where we are i know where we are right but okay so that but that's fair maybe it is new technology can be a higher risk and a higher mental overhead why is doing it in real time more risky and what can we do to mitigate it i think from my side of things the reason real time ends up being at least perceived as more risky is because one a lot of organizations don't have the in-house expertise in developing realtime systems so inherently there's a learning experience there's going to be common pitfalls that people fall into in terms of assumptions of how to manage like you know multiple connections and what happens if a machine goes down with those connections attached how do you do kind of effectively load balancing there's so many kind of small intricacies that if you're trying to build a real-time system from the ground up you need to consider and have some form of knowledge of which if the organization doesn't have those expertise or that knowledge they're probably going to potentially fall into those pitfalls likewise i would say that it kind of restful interfaces and such have had you know many many many years now of development and refinement and kind of ironing out the tooling and potential features that would be expected by users to make this a fully featured kind of method of communicating between devices as possible compared to let's say websockets where i feel a lot of people do just use the bare kind of interface of web sockets where you don't have connection hand connection reestablishment in bait into it you don't have methods of trying to retrieve historical data you don't have methods of querying directly and baked into the actual protocol itself you don't have so many of these kind of things that probably someone going from a kind of restful background into this real time real time space would suddenly have to completely change their way of thinking to get into i think it's not sorry because there is that thing like to have a to have real time data you need a persistent connection and that is inherently more complex than if you're doing request response the connection might fail you'll have to try again but you're going to do that anyway trying again is is your de facto way of talking to anyone do do you think that's a failure then in the websocket spec that it wasn't ambitious enough do you think it's a failure of libraries to to move forward or is it there a lack of demand what's what's going why get me to the future please well i think that's the thing i mean obviously i just to highlight i have a completely biased view on this because i work for an organization that basically builds kind of a lot of management of these of websockets and handling these protocols and handling of these problems so take everything i say with a pinch of salt because i do have a bias but so so far i'm on your side for the generics and i'll let people to decide whether your specific solution that work for but i i think that inherently it is it's not an inherent issue with the websocket spec being not ambitious enough i would say as and there's definitely room to grow but i think as with a lot of these specifications the amount of kind of iterations they have to go through and communication to make sure that it satisfies everyone's needs it doesn't break anything historically there's always that which is slowing things down i think even now of like http and you changes to that kind of specification we've seen that where it takes so many years for kind of fundamental changes to keep up with the current trends so yeah i kind of agree with that but it doesn't feel like much as changed in rest interfaces in the past 10 years no massive i would say that not a lot has changed but likewise that's why i'm not surprised that a lot hasn't changed in the websocket kind of interface as well because generally it's intended to act as this kind of fundamental layer of how things should work and it's hard to initiate the change because at the end of the day you're going to break someone's some stack somewhere potentially or break some niche use case i think there's like an x cas xq cd where there's a there's the what's it called someone is kind of reporting an issue of relying on the fact that their chip is overheating and a bug patch fixed that and suddenly they're like oh why have you broken this kind of feature of the chip when like i relied on the overheating and i feel like the same goes for any kind of specification where any you know you you have the users kind of building around any of the niche kind of use cases or unexpected outcomes of a specification and that always needs to be considered but yeah my favorite one of those is if you fixed all the bugs in the javascript spec you break so many websites oh yes exactly there's bugs in there canon right exactly and it's it just like the the more used anything gets the harder it is to change anything because you're going to upset and break so many things but i'd say outside of the core specification there are kind of useful open source kind of tools in libraries to help like socket iio i would say is one where it does try to handle a lot more of the kind of connection failing and reestablishment of connections and state management for you but again tell me a b about socket io so socket io effectively is a wrapper around websockets where it allows for kind of falling back onto other protocols where websockets isn't available it handles reestablishment of connections it adds kind of a bit more of an abstraction to what the core websocket requires and provides useful utility functions such as is just you know web soet iio do getet and you get you know space and then you can likewise just publish and you subscribe to a websocket and it just allows for this more intuitive interface i would say with a lot of the nitty-gritty abstracted away unless you choose to try and dig into it yourself which for most use cases thankfully you won't need to and it makes it far more accessible to start get started with websockets okay i am definitely looking at that one after finished talking i'll put a link in the show notes too oh yeah definitely do so there are tools which are starting to be built around trying to create this more user well more developer friendly interface with websockets but that i think for a lot of developers still has a fairway to go because of the fact that it considers i'm trying to think of a good way to put this it it's strongly connect strongly linked only to how the communication occurs but not how you handle any potential failure in the connection from like fall over of servers to clients having issues or persistence of data or anything like that which inherently a restful interface won't have to handle as you were just saying it's but suddenly because you're in this realtime space where you need this persisted state it's such a consideration and yet it's not really handled in a buy any of these libraries as far as i can tell these open source libraries yeah and obviously if you're aware of any please let me know because i love to dig into those but it's like such an inherent problem that's replicated across any use case of a real-time protocol and yet there's not a lot of open-source great solutions to that problem yeah there's also the it's not just the technical overhead which incidentally is doubled cuz you need backend support for this as well right but there's also the mental overhead like once you've got that websocket established like you've then got to think how do i build an application where i can't really ask for data anymore i mean i don't know i mean you can definitely still ask for data with a websocket i feel surely because that's the point it's like websockets unlike ss or something are bir directional so if you really want you can have still that kind of request response relationship between a client and a server but it's the the asynchronous nature it means you're not really saying give me the data and you get the data back so much as you're saying you should be sending me that data and then later that data might just magically show up it's it's disconnected yes i yes i get what you mean there's not an inherent link saying that this response is connected to this request but yeah i i mean i've done like myself quite a bit of experimen ation into this like i did a bit of a kind of websockets over html kind of demo that i was messing around with where it's basically just having live updates to the web page based off of things that are states that are changing in the client as well as on the server and in that what i ended up doing was kind of almost creating a faux kind of get request where effectively i have an id which i attached to the message i'm sending over the websocket and likewise the response would have the id so then you'd always know this is the response to that request you made and of course can a delay but i feel you know although a restful interface and like you know hate anything like that will abstract away what's happening under the hood at the end of the day there isn't a real core link between the request and the response it's just through these associations of ids and everything and the kind of agreed protocol that there is that link so but again as you say it's that's another layer so a developer has to think about when implementing something over websockets of how if you need to create a link between two bits of data or question or response or something how do you do that and that's not something you really have to think about when you're implementing your own kind of get posts all of these kind of you know classic protocol requirements because it's innate in the protocol do you think then do you think we should be going because there's there's a temptation which is what your demo is doing in a way to go into realtime streaming and then recreate the old protocol you're familiar with on top of that do you think i mean and that's that's got merit right because that's taking away the mental burden as well you know and just woring about the technology getting to your to the first rung of that ladder but you think that's what we should be doing or should we be trying to educate ourselves to go all in on a kind of reactive way of programming i mean i personally lean to so we should try you know in a perfect world we should try and go for the full reactive in that really what should be happening isn't that there's like a get request it should be that data is sent from a client which updates a global state of something and then whatever state or section of that state is relevant to the user should be recommunity with will provide updates and relevant information to said user whenever it's relevant to update to them so it's no longer you know you have to keep saying please give me this it's instead saying once every kind of you know however long when there has actually been an update worth sharing that will be shared with them but i think that i can understand why people would try to kind of start off with a restful interaction because so much of the current internet is based around that and it is something that's intuitive to current developers because that's how they've been educated that's what they've learned i'd hope that wouldn't be the case in the future not that they wouldn't be familiar with it but that they would be more familiar with kind of real time circumstances and how to actually build systems around it but at this stage i think it's yeah i can understand it at least yeah so i mean maybe this question is the whole of your job in a way but how do we draw people into that future oh well i think yeah yeah that it's a good question i think the always the easiest way is to create make it as easy as possible so having more open- source libraries which do handle a lot of the back you kind of lower level complexities of state management is crucial i think because if you don't have that then if you know it's the same for like if for any http request you actually had to handle all the headers yourself and all the interpretations yourself and you had to handle the use cases and circumstances of retries yourself and you had to worry about how to structure the message being sent back yourself and yeah there's so many aspects which are just abstracted away by current libraries and you know the protocol itself and how it's been implemented that you know we need to have the same sort of tooling for websockets where it should be easier to build kind of more complex data structures on top of the core webss protocol handle the connection failures handle the state representation preferably in open source libraries to make it as accessible as possible and then that at least you know so you can point to someone to it and then it can be a lot more intuitive to them rather than i feel for a lot of people who i've talked to myself they will try and start off with websockets they'll get like a basic demo going where they got you know a message from the server and the server sends a message back and maybe they have a couple more clients that connect and they're like great this is fun but the moment they start having to think about how to scale that up what happens when they need more than one server how do they handle the communications between servers to maintain a state yeah that's that's when it starts getting pretty hairy for them so i would say tooling is always going to be the make or break if there's not good tooling it doesn't matter how good your educational material is it doesn't matter how much you rave about the benefits if someone looks at it and goes i don't want to go near that then yeah it's never going to be great but i think then it is all about the benefits it which you need to prove the value preferably you should be able to prove the value in a sense that actually some things are easier where the real- time protocol than not such as i would say having this kind of let's say say in a chat application you're no longer having to worry about what state the client is in locally before sending an update you can trust them to be up to date or to at least have some rep like tim stamp of the last update received and send kind of live updates to them as they're occurring on receival by the server and it allows you to kind of almost separate out if you want the actual communication of messages from the kind of storage and and grouping up of messages and allows for i would say a kind of not necessarily a cleaner back end but i would say a more kind of separated separated is the right word you can have more kind of subsections at the back end which means you have less kind of bottlenecks potentially because of the fact that you have this kind of distribution section separate from the storage section separate from more of like a microservices sort of structure i would say but generally i'd say kind of there's so many use cases where real time is just better like as we've been saying with these kind of collaborative editing of documents and sharing of documents and having this kind of real- time updates of what where a where someone is in a location for a delivery yeah these sorts of things it's almost you can should be able to point it to even a layman and so is this feature useful and if they're like yes this is great i love this yeah that i think is kind of almost the bar for saying is this showing the value of this real time kind of functionality yeah i was thinking because so there's a there's a cost to even getting to that point where you can show it to a layman right yes i was and i've wondered about this a lot what how can we find the places ripe for this kind of change and then this morning just before we recorded this i was looking at google analytics and mashing the refresh butt button to see if yesterday's data are come in and i thought that's it anytime users are mashing refresh that should have been real time yes i mean definitely right as in there's been like chat as we were saying or email those are examples where thankfully that seems to be a thing of the past for most email providers and chat applications because it's just become so ubiquitous with real time updates but yeah i i'm i'm i've been in the same page as you with analytics where you just like why do i to keep hitting refresh yeah am i waiting for new york to wait midnight in new york or something or midnight in san francisco why won't this update yes exactly i i quite like that as a good kind of i feel that's definitely the moment you have to hit refresh constantly that is definitely a threshold of it's not that you just kind of need real time updates it's why the hell is this not a real time update it's like the canary and the coal mine for real time but but you kind of hinted at when you mentioned microservices and as you'll know i've got a background in kafka as well is this only really going to get sorted out if we tackle the whole stack i mean it's a good question i don't think inherently the whole stack does need to be addressed okay because i mean i think eventually it can benefit from being addressed but i don't think it needs to be let's say if a developer is looking to introduce some realtime features to the application they shouldn't be having to then also think okay how do i set up real time communications between my backend services do i need to make that non- restful now do i need to worry about having kind of load balances between my backend services do i need to worry about how i am structuring the data such that it works better with the backend services because i think there's definitely ways to kind of build midway points of progression to a real-time system like let's say i'm trying to think of like a recent example example of something i've had i mean let's just go with a chat application because that is such a fundamental use case let's say currently you do just have restful kind of http requests being sent from clients to some load balancer which is then fanning out to backend you know database and backend processing units to do something to the data and then restful messages are being sent back out to the clients there's no reason why the structure of the data needs to change that's being communicated if that stage is converted to websockets and there's no reason and thus you know it doesn't matter for the database or the backend kind of processing and there's no reason why the actual changing of that kind of communication from the clients to the kind of load balance as it were needs to impact anything else obviously you do need to have some changes in that you need to now consider how you handle state persistance but that's almost you can just introduce a new layer instead of the low balancer in front to effectively handle how you know where connections go which connections are handed off to which servers and thus also what happens if certain load balances fail and such so but that again allows you to kind of separate out having to update your all of the backend services that you already have to match with the new protocol being used on the front end there is then the how you handle the distribution of data and from the client side you of course need to update how it receives messages and the fact that you no longer need to send requests for updates and everything like that but that is all then completely separate from having to inherently update the backend stack i would say i'd be love to hear your thoughts on that though as well oh gosh i my perspective i can see where we are today i can see where we need to go but how do you do it peace meal m and and i guess i'm thinking of something like logistics is a nice one cuz that's one that can exist without real-time updates but is obviously better yes so i guess your peace me step from going from a request response traditional stack to some kind of realtime notification do you have to first hook into the source of the real-time data do you have to hook into the truck leaving the warehouse and say okay so that's going to get an insert into my database which will later to be queried on a on a select query but at the same time i'm going to have a channel b that streams that piece of data out just for the sake of the front end well i think it's one interesting thing with logistics in that i've i've talked to quite a couple logistics companies myself about like them wanting to introduce real time features to kind of updates to their end users or other steps of the logistics process and often a lot of the information of you know when something arrives where it's been etc is already communicated and it's already stored somewhere because they want to have an internal trace that they can go and query at some point you know in a non-real time fashion saying what happened to this what happened to that so there's i would i would say if you want stood at peac maill there's no reason why in that kind of step of persisting that data there can't just be an additional i guess additional kind of service provide created or something which can also be sent that information at the same time for than that redistribution where again that's now a new piece of backend service to then handle that distribution to connected services but it doesn't mean you have to impact your current stack which would be considerably safer i would say in that you don't have to worry about oh we tried to make this all real time and now nothing works because we didn't think of an edge cases well that random service off to the side that we made is no longer sending out messages which sucks but everything that we did before still works and yeah would allow for that kind of safer transition i wonder if the answer here and give me your opinion on this but so i can imagine we've got a stack where the the trucks coming into the warehouse and maybe another system insert into a database which is probably going to be oracle or postgress or one of the other favorites and you say to those two service providers we just need you to also send we need you to change your software so it also sends to x and that project dies on the vine yeah because you've got to get two other service providers to make changes and and so i wonder if the solution here really is to say we're inserting into the database which is inherently that change dis there's you can't get notifications out of a relational database for what's new i wonder if the missing piece here is something like deum which can turn relational database back into a source of real-time notifications h i mean i mean i i feel that yes that would be a solu but again there still quite a large architectural change i feel to introduce that wouldn't it the nice thing about that is you don't have to change any software you're just adding one observer to a pre-existing central piece like i see what you mean i could imagine that being quite good i feel that's the sort of level of involvement you want to require though right isn't it where it's you're not having to change anything of the core functionality or your current existing stack it is always just an appendage which if it fails there's no inherent failure that should be able to ur with it that will impact the rest of the stack yeah you're not going to break anything existing you're not going to ask anything existing to change that's probably our drisk best hope of actually adding in this new new world yeah i think that's the right sort of approach for transitioning existing solutions of course then there's the whole side of it of probably if you're building it up from the ground up then you want to be providing very different recommendations to developers than transitioning from an existing structure because yeah abs that isn't i would say it's a far less efficient way of building out a system from the ground up in that you're just adding in a lot of you know redundancy effectively but i think that's what makes it quite interesting as a problem because you do have to have these different approaches of how you implement it depending on the use case sp and how far into kind of static real rest based communications the developer is already yeah yeah the greenfield and brownfield projects are very very different beasts yes exactly which is always interesting from like an educational standpoint yeah i got one of my best educations if that's the right word from working at a bank where you very quickly realized requiring another department to change their software was game over yes it's just forget about it cuz it's going to take' months if it happens at all yeah man you're very lucky if it does happen at all yeah yeah don't want to go down there okay i i can believe that a combination of competitive advantage socket iio deum might get us there i'm do you think there's any anything else we can do to drisk this change what about the mental change needed yeah i mean i would say that's a lot of the education side of things right where right i guess i i would say actually it's probably two-part it's kind of the how proven is it to work because i feel that again proof of it working and having use cases to look at and compare your own existing stack to is almost one of the strongest convinces of is it feasible is it possible has someone else done this but also then the educational side of where do you even get started how do you start how how do you even learn how to start thinking in a realtime way but i think as we already touched on it's interesting because how you start thinking that way i think is very conditional on your own personal historical experience where if you're very used to thinking in a restful way it's quite counterintuitive to think in a real- time way because rest is very much so as you say transactional it's all about that kind of onetoone r relationship of a request or response or a post confirmation or something like that yeah but the real time is very much so everything is asynchronous everything is un aware necessarily of what else is there clients aren't aware of the other clients asynchronously sending communications and updates on the state only you know they usually will have some form of definitive state but that's only ever represented on the server and every client is only going to have some form of kind of mirage version of what the true state of the entire system is but then i would so i would say for an established developer with that previous experience it's how do you convert their existing knowledge over to think in a bit more kind of real-time manner which i would say is harder than taking someone with no experience where for example i've talked to like students for example who have been curious about you know what i do and this sort of space and generally when i've kind of talked to them or had like hackathons which involve real time protocols they seem to pick it up very quickly because yeah they're just like oh yeah so you know you just send something and then you have to worry about it and they actually think that's great because they're like okay you know there's no kind of like rigid requirements of like the communications and you're having to like get everything just right almost you know you know when you're building a true system you probably want to but in terms of getting started and understanding the fundamentals it just kind of makes sense it's more like you just are sending data when you want to send data and you send data the other way when you want to send data and that's that and you just kind of can you can and you cannot have any kind of like a subscriber listening to data coming in and you can handle it however you want and it's sorry sorry now i've i've i've worked on one project that was like completely 100% all in on this once you get used to it it's actually quite freeing cuz if you want to send something to the server you just send it like you say and and then you completely forget about it and then you put on a different programming hat and say okay what interesting things does the backend want me to listen to and you can kind of when you're doing request response programming you have to worry about the request and worry about the response and you get to separate those two jobs out into two different tasks which can be very freeing as you said yeah exactly i mean then you can start if you really want doing kind of weird quirky things where you have you know multiple messages being sent by the same user about like completely like disassociated you know points of data and suddenly the server once it's received enough of these kind of random messages to whatever criteria you wish to establish then you can be like okay now we're going to send a message back and there that it just allows for kind of more interesting applications of this kind of communication to occur because you're not strictly limited to this one to one relationship you suddenly can have you know you need six messages from different devices potentially to cause a response to two of them you can have you know five messages from one user and one from another being required so then actually have again a response to an absolute third disperate user there's no kind of inherent linking required in terms of the communication protocol that's been established besides the fact that two devices are able to communicate that's and that's kind of the beauty of how simple it is websockets is kind of almost getting to one of our earlier points it is simple and it can make it complex in places you don't want it to be complicated because it doesn't handle enough the base use cases but likewise that simplicity allows for a lot of innovation and i think for newer developers it can work more intuitively because it's not that they're constantly hitting walls because they don't understand what's expected of them they're instead actually able to just kind of try something be like this should be able to send a message to this now and this can now send a message to that and i just want to now communicate with that and they can because that's just inherent within the realtime communications yeah yeah it's also kind of freeing for i mean we think we're thinking about a lot of this from the front end point of view but it's also freeing for the back end because they can just wake up one day and say here's some data i think i should be sending to the client i don't to wait i don't have to agree a request protocol i don't have to even bother them to ask for it i think they should know eventually they'll deal with it yes exactly yeah and i think that's a large kind of nice bit of like you know say like a pub sub paradigm or something like that where you do have this kind of the solution this kind of you know devices or servers whatever which are responsible for handling the connections and then you have the actual you know backend services as you say they can just come on and just be like i want to communicate this down they'll just send it off to your pub sub server and then that will handle the rest for them because it's it's already got connections it's already got things connected to it that have said i'm interested in this sort of data and there's no inherent requirement of a link between the back end and the front end then almost it's both can just operate disparately and only indicate what information they're interested in when they're interested in it and outside of that anything goes yeah i wonder if we should be speaking if if our if our ripest market to persuade people is like erlang developers anyone using aa in java and scala people are used to the actor model where they have the freedom to just fire and forget once you sent the message at someone else's problem it's a good point i mean i think potentially but also actually this is a question i have no idea what do you know what sort of like kind of share of like these sorts of systems is built in those sorts of like languages this day and age because god i wish i knew yeah because obviously know nowadays it's like react for kind of frontend services and then communication to kind of back end is you know definitely the largest kind of group of developers i would say i think like in terms of like stack overflow polls and things as you know javascript developers doing react that's where the vast majority of developers at least do use stack overflow and reply to the the questions there are involved but i agree as i quite like i've done a fair bit of like go development and that's always like i feel the channel paradigm they have is very similar to the kind of websocket realtime communications where are you familiar just to check i'm not just going to talk ramble about something um let's go into it because there'll be plenty of people that don't yeah so basically in order to kind of communicate between different processes you create something called a channel which allows for a client to sorry for one process to communicate data to another process and likewise there's no requirement you can set up two channels so can be bidirectional and then again you have this kind of process where you can just send off messages and they will be handled by the receiving process and likewise being sent back and i myself at least that always felt very just like a real time kind of interaction because i tried almost creating a bit of a again a pub sub service using channels where you have like a central process which has loads of channels connected into it from other processes occurring and any process that comes up it connects to it and then likewise you can then have broadcast messages to all of the processes that you're running and go from this kind of core process and it's just quite it it feels like very freeing in the same way that real time protocols do where you can have this kind of you know message whenever you want to message there's no need for certain kind of hierarchies of communication and you know you need to wait for a request to send a response is that with inly within the code itself you can just be once you've established that channel messages can just be sent yeah so maybe considering so many people in this world have to front end developers for us to get the revolution that i want i think we both want maybe cu that's channels in go then are very similar to generators in javascript i think maybe we need to be advocating more for generators in javascript to get people slipping down the path towards thinking of like disconnected request and response i quite like that as an idea of kind of slowly ease them into it don't even tell them you're wanting them to start getting interested real time protocols you're like oh have you heard of generators they're really cool yeah you should check them out they'll really speed up your programming and then suddenly the next thing you know they're on websockets they've got mqtt everywhere ssse listening for updates yeah because there is a thing inherent because there is a very definite parallel between request response in an http request and calling a function and expecting an immediate response from it right we we are dyed in this wall of i ask a question and an answer comes back and generators channels are one way to break that mental link and think sending data is a separate thing from receiving data i like it as an idea i guess that's always going to be i think a trip up where as you say anything which has run on the same machine you can expect this kind of instantaneous responses and i would say a lot of experiences on the internet tried to give off that same exper experience of an instantaneous response at least to the human eye but in reality you know it's having to travel hundreds of miles each time that you're trying to send a single bit of data and i i wonder if obfuscating that kind of delay or actually trying to make it more ingrained into the considerations of the developer be the right way to go around it because obviously at the end of the day it is an inherent thing you have to consider because delay adds in a lot of considerations of how quickly front end kind of uis can update how quickly processing on the back end can then reply with a response to provide you know new table information or you know how something can go wrong where you know obviously your laptop may be fine but if a server crashes somewhere that's got an inherent issue on whether or not you're going to get your data back yeah and as a developer i i guess to introduce people to the concept you probably want to make it as fast and easy as possible for them to get going you don't want be having to worry about all of the edge cases you want to almost kind of get them with a treat saying like look how easy and nice it is and then you know they can find out the more painful points later which i mean i feel the same applies to most technologies that you know when you get to a certain level of depth you suddenly realize oh you know everything this you know majority of this project the 70% 90% was really easy but suddenly this last 10% yeah this is actually getting a bit nitty and gritty i'm always reminded of a thing in hitchiker guide to the galaxy i think it's the first of those books where he's talking about the evolution of ideas as the i i won't reconstruct the whole thing you should go and read the book if you haven't and you should reread it if you haven't read it recently but he's saying like humanity always has problems as we evolve the trick is to get to more interesting problems so the problem of how do we eat you can solve that and then you still got a problem but it's a more interesting problem of what should we eat right so maybe yeah the realterm future will definitely come with problems of course it will but they're more interesting problems to me yeah i would agree and it's almost problems which are more are meaningful and that by solving those problems you suddenly are providing so much more kind of value and value to the end user and so much more potential for you as a developer in terms of how you structure your applications and yeah what features you can have within your applications and how you can create more enjoyable experiences for the end user which i think is always makes it far more satisfying than you know having to if the base problem you're trying to solve is something like how do i just even send a message to someone and you just managed to send the message then you know it's great that you manage to solve it but that doesn't the outcome isn't necessarily as exciting yeah and we're and we might even end up with more reliable systems in the long run because that moment we're pretending that request response is reliable and the network is perfect because we're trying to pretend we're still on one machine as you yes as you hint and if we actually accept that disconnected computers behave differently we might end up with better more reliable systems because we're accepting and dealing with the limitations of disconnected machines i think that's a good point because as you say inherently a request response there's still many points of potential failure and that's a lot of it is abstracted away so the developer doesn't have to be aware but there isn't that there isn't fundamentally a core linking between the request and the response yeah so okay i like that of thought so we've got lots of ways we can i i think we've certainly i'm accidentally reaching the conclusion that maybe the the way to get people towards real time is to start by helping them accept that we're on multiple machines now and things are decoupled in a more profound way than they've ever been if you can grasp that mental model the world your roer yeah i think that's a good way to look at it yeah and yeah that decoupling is inherent in the entire system so the sooner we accept it the better a note to end on tom thank you very much for joining me in a more philosophical journey than i was expecting but very rewarding one thank you yes my favorite sort of conversation thank you so much for having me pleasure catch you soon than you bye thank you very much tom you know even more than usual that one's given me some food for thought i feel like it's crystallizing a thought i've been scratching around the edges of for a while that while i really believe real time data is a great feature and something we need in the future it's maybe not so much a thing in itself as a natural consequence of rethinking the way we communicate between machines you know you can either pretend that networking is the difficult mode of making function calls on a single machine or you can accept that it isn't and see where that rabbit hole leads and it leads to a lot of re architecting and rethinking and realtime data seems to kind of pop out of that as a nice reality of living in this new world and going to keep mulling on that one for a while so in the meantime we'll be back next week so if you want to catch that click subscribe or follow depending on what app you're using to make sure you catch us and if you've enjoyed this episode please click like leave a comment send a review so that i know you want me to keep making more episodes it does help and with that i think we'll get going i've been your host chris jenkins this has been developer voices with thomas camp thanks for listening [music] w