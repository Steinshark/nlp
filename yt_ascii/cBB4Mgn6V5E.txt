go 1.22 released all right i'm i've been loving go lately go is a language in which feels super just absolutely lame to type it does not it's not it's not a sexy language there's nothing about it that feels incredible but somehow it is the most productive language i think i've used in a long time let's go read 1.2 sorry i'm setting up something i want to see the chat over here i want to see the chat the latest go release version 1.22 arrives 6 months after go 1.21 most of its changes are an implementation of the tool chain runtime in libraries as always the release maintains the go one promise of compatibility we expect almost all go programs to continue to compile and run as before nice nice okay go 1.22 makes two changes to for loops previously the variables declared for a for loop for why are you scare quoting for loop for a for loop okay we all we all know what kind of loops you guys are doing it's not a for loop okay but it's like what is that what the hell does this even what the what what the hell does this even mean anyways previously the variable declared by a for loop were created once and updated by each iteration and go 1.22 each iteration of the loop creates a new variable to avoid a okay so this actually okay so this was a this was i thought this was oh was this opt in and go 1.21 and now is official and go 1.22 this is great by the way this is great why well there is a really good reason to do that in when they say for loop i believe they mean a range for loop the reason why it's a ranged for loop is that so so like you can still do for loops and go you can do like 4 i equals z i has to be less than this i+ plus or whatever it is right i don't know what goes exact syntaxes for it and you can do that and then you can adjust the i because it's a singular variable but a ranged one doesn't doesn't have like so if you go like four key value in this thing it doesn't update those values instead it creates you know creates new variables per loop so that's great right go slowly becoming python that'd be great right python's a very productive language so that's good like that's a very good thing because if you save any of those variables say in a function or anything like that it doesn't like it doesn't get updated underneath the hood on you if that makes sense so there you go so this is now this is now a good thing right for loop four loops may now have range over integers let's go let's go let's go let's go let's go that's great that's great you know what they could really do though you know what i'd love to see them do just go just go full ada go full pseudo code and just just hit us with a 0 to 10 just let us do that just hit us with the 0 to 10 you know what i mean just hit us with the 0 to 10 absolutely nothing is better than the full ada right because i think ada was one of the first languages did that did that that would be a new operator though fair okay fair they're trying to avoid operator because i go is the is an extremely fast compiled language so if i if they were to add something i could see it could it could slow things down we don't want to do that i'm actually i buy that as an argument i'd rather type a little bit more than have slow compile times fair go one22 includes a preview of a language change we are considering for future versions of go range over function iterators building with go experimental okay so i i got to see this let's just check this out really quickly okay type sequence v any yield function vb okay sequence 2 v key key value any function kv bull okay oh interesting so you can do some sort of four effectively you can just do like a four oh i think i see what's happening oh oh are whoa is go wait whoa whoa is go going iterator on us are we about to see a full because go's already like 95% functional it's almost there it just needs better iterator support and it's like fully there so you telling me that we about to hit some iterators let's go let's go that this is great this is great this is absolutely fantastic by the way this is i am very happy about this look that it even has a sequence and a stop let's go that is so good i'm very excited about this i'm very i'm actually very excited about this look at this like that this is this is super exciting this is super exciting stuff i don't know when this lands i i i i don't this must this is probably still it it looks like it's still in it's still in go experimental range function so that's still an experimental feature so my guess is whatever the next one is one 2 three maybe maybe 12 four but awesome so in know in a year it'll be just standard you won't have to have any sort of this but you can use it one thing i love about go is that the experimental features are just like you can just opt in and start using them you don't have to have like special tooling you don't have to have babel right you don't have to have a pre-compile step to your pre-compile step to run your javascript like you don't have to have the double whammy you could just you could just do the thing right no poly fills right [ __ ] babel all right the go commands commands and workspaces can now use a vendor directory containing the dependencies of workspace the directory is created by go work vendor oh super interesting i have never used workspaces so i'm not deeply familiar with workspaces at all i mean i have a general concept of what they should be but is go even like shooting for this mono repo style are we even getting some are we getting some full tooling support for mono repos let's go this is shockingly good go is all right hey hey hey used by build commands when the mod flag is set to vendor which is the default let's see when a workspace vendor directory is present okay okay this is super cool note that the vendor directory contains contents for a workspace are different from those of a single module if the directory at the root of a workspace also contains one of the modules in the workspace its vendor directory can contain the dependencies of either the workspace or the module but not both i'd have i i i don't quite understand what that it's again i'm not familiar with the workspace so i can't quite not sure exactly what this means but i love the idea of being able to vendor out your own libraries if you need to this is definitely like more of a se feel but you know there there there is this day there is a place that exists where you don't want to only use a dependency management system but you actually want to be able to bring in the dependencies yourself and have them as a part of the project like this is this is a real this is a real world thing and so to be able to have vendors like this and just be able to do that fantastic vendor folder is now shared by all modules in the workspace that's awesome goget is no longer supported outside of a module in the legacy go path mode that is with go 111111 module equals off other build commands such as go build and go test will continue to work indefinitely for legacy go paath programs okay dude i haven't used gopath in a long time go mod and nit no longer attempts to import module requirements from configuration files or other vendoring tools such as go package lock go test cover now prints coverage summaries for covered packages that do not have their own test files nice this is actually super cool i'd actually like to start because coverage is like a very so this is okay so we're going to get into some dicey territory when it comes to when it comes to this and i really want to see your guys' thoughts on this coverage what do you think of it hit me with some stuff anyone else see the notification on youtube and then immediately come to twitch that's why i do it no offense hey no offense you guys hey i love i dude i'm so happy you guys come along i greatly appreciate all of you over here i just want to let you know here i'll let you be a part of this conversation what do you feel about coverage do you think okay coverage dogma is bad dude oh my goodness coverage as dogma is bad coverage as dogma is one of the most unhealthy things of all time absolutely thank you geek coverage is good but onedimensional num numeric metric is it's useless agreed agreed i can give you a reason here i'll give you a quick reason why coverage is stupid okay are you guys ready for this here function watch this we'll call this caller r le right right you get to call an array for a certain amount of time and call okay good look copilot already knew what i was doing now i can have a test test caller right and it's going to look like this right and i can go like this all right we'll do this 10 times bam bam bam bam look at that i have 100% coverage right we just did 100% coverage right here can anyone see the bug that's like completely obvious anyone anyone want to see the bug that's completely and obvious right now here let me help you how about that there you go yeah i just got myself that that's an error that's a runtime error yeah and know be an out of bounds exception but i'm able to have 100% test coverage right so that's why test coverage js is the bug okay fair fair statement but that's why when people say like 100% test coverage is a requirement they're not saying they're they're not saying anything useful there's nothing useful about making a specific number requirement how i look how i prefer to do tests is i i think mocks are useless i think that if you rely on mocks and you do a whole bunch of testing that way you create very cumbersome tests and often what you're really doing is you're actually testing internals and i i i just think that that's not good for me for me is that i prefer that any function that does some sort of system integration type call is something that you pass in it's some sort of inversion of control and then during the test you just have a different version now you could call that like a mock but really what you want is that you want any system call that does its thing and then massages the data into the correct format that you expect it in and this is like a one-step thing and then that data gets passed into the thing that does all the work that way you can just pass the data in and do the testing on the thing that does the work and stop trying to like if i call in this thing 500s do we make sure at 500s it's like yeah of course it make sure 500 s just you know like that's not the point of the like what are you doing right so mock no i like the i like the data as the mock right and so i like something like you know you can have like say you have a status call right i i said that kind of goofy say you have a status call that has to go out to a you know http dot do dot dot do do right it makes a call and it returns this well this thing has a structure that it returns right whatever that structure is i don't care what that structure is right you know return some you know there we go status there there you go perfect right i want to take this data structure and then go like this then if we had some sort of you know whatever it is some sort some sort of operation on status we pass in this status object right right up here right that's what we pass in so that way i can test this thing i'm testing that i'm not testing can i make a function call i'm not testing can i make an internet call on the internet like that's stupid to test right like that's you're not you're not winning anything here okay this is where you do the winning okay that's where you do the winning right how do you prevent it from doing a hp call that's why they're separated i like getting the data separate from operating on the data and that can't always happen i get that like i'm a practical guy i don't try to make this happen 100% of the time but i try tr to make it so that it practically speaking whenever i do something there's the getting the data step and there's the operating on the data step and sometimes it's just impossible right like we have something right now at netflix where i'm working on some automation stuff where i have to go and i have to register i have to reserve a device i have to install the specific platform on it and then i have to reset the device and so you can't really like separate out those ones it's not really possible to separate out those ones so those are like that makes sense that if you want to test the various conditions that you aren't goofing up the device registration reserving installing restarting and uh deregistering you can't really do that without mocks of some sort right like there's not you can't really get away from that but anyways dude test coverage is stupid don't ever let someone tell you that test coverage is important writing good test is important writing good tests is important i would rather have five great tests that cover 40% of my program than 100% coverage because i can't make any judgments about how good or bad the 100% coverage tests are not agreed i literally just gave you a case where i did it right here we have 100% coverage right here and it's absolutely [ __ ] test it tests literally nothing important there's nothing important that we're testing here like nothing there's nothing important we've just test tested here 100% coverage is an illusion of safety exactly because it's a non-meaningful test i want meaningful tests right i want extremely meaningful tests anyways but hey cy hey since you're here i i i like this okay hey all ones one one11 frizo why not what's what's your counter to that why why why would you rather have 100 than f than 40% to meaningful tested hit me hit me with a reason i i want i want to know why because i i have because you know you come in here you you you give me the l take you give me the l take come on come into the big board let's go 100% valuable test is 40% valuable test well no one said i didn't say that i said 100% test coverage versus 40% but they're all valuable tests like if i could make a choice i knew one was 40% coverage and they're all high value tests and the other one is 100% test coverage as a mandate i would choose right high value tests over any mandate of coverage right i'd rather have 20 40 50% and then the and then the motivator to write more tests 40% means 60% untested code i don't think all code needs to be tested testing failure of testing a failure of code is important than testing happy path yeah the only way you're going to figure out the real failure points is by people using it that's the real test this is where production metrics are extremely important i'm actually fully on that team production man let's see management out here thinking they give us enough time to even write tests uh 100% cover in end to endend test is highly valuable yeah but have you tried to do 100% coverage yeah i i mean i i also develop libraries only i still don't go for 100% test coverage i think you're i think you're fooling yourself to think that 100% test coverage gives you any real safety i just think i i think that you end up whenever you do that you end up writing these tests that tests that you you do effectively blackbox testing where you know of a spefic specific if statement and when you do that you have coupled testing to your implementation and then what ends up happening is that when you change up your implementation slightly you break your tests not because you break your tests for a meaningful reason but because your if statement has been changed and that becomes this really bad thing when you when you couple implementation it ain't a black box anymore it's it's white b it's you you turn into white box testing like that's specific if statement testing is very very difficult and i mean remember i i i've had some libraries that have exceeded 90% test coverage and it's i'm still not loving it i i'm not loving it you know what i mean anyways okay so this is great runtime runtime now keeps type-based garbage collection metadata near to each heap object and improving the cpu performance latency or throughput of go programs by 1 to 3% interesting this changes also reduces the memory overhead of major majority of gopro programs by approximately 1% by d duplicating redundant metadata some programs may see similar improvement because this change adjusts the size class boundaries of the memory allocator and so some objects may be moved up a size class huh now keeps type-based garbage collection metadata near near to each heap object i want i mean i it sounds like there's like a kind of a cool algorithm that's that they've kind of figured out here it seems it seems cool built-in pooling yeah it kind of sounds like built-in pooling in some sort of sense or at least size pooling they're doing some sort of arena allocator here a consequence of this change is that some objects addresses that were previously al always aligned to a 16 byte or higher boundary will now only be aligned to an 8 byte boundary some programmers that use a sembly instructions that require memory addresses to be more than 8 byte aligned and rely on memory allocators previous alignment behavior may break yeah i mean you're already doing something crazy if that's what you're doing i'm just i'm just saying that's you're already in a complet like to me if you're doing that you're you've already made a great a great case to probably just use rust can we just all agree to that like if you're if you're like hand rolling assembly instructions i'm not even sure how to do that and go i didn't even know that was a thing you could do and go but if you're hand rolling some assembly type stuff you're you're probably wanting like a a rust or c experience you're not like go or zig zig is a great choice you're probably not probably just the wrong language at this point probably doing assembly in go is trivially trivially easy i i expect it is i'd still use something like zig like if i had to do that i'd probably i i would use zig it just seems like a better language for that because you have extreme control over memory once you're in garbage collection land sl manage memory that's kind of hard you know like that's a hard that's a hard one you know what i mean hey thank you hey you you jumped in the arena and then you you left it with the twitch prime appreciate that appreciate that that all once yeah i wouldn't do it yeah it amuses me people that do do it yeah it's crazy that it's trivial like that's kind of wild that it's trivial in a garbage collected language like that i would assume that it's it's much harder to do but hey all right hey all right some programs that use assembly instructions that require memory addresses more than eight byes reli oh i think we talked about this let's see let's go right here such a program may bu be built with go experimental no allocate no alloc headers to revert the old metadata layout and restore previous alignment behavior but package owners should update their assembly code to avoid the alignment assumption as this workaround will be removed in future releases on the windows amd64 port programs linking or loading go libraries with built-in build mode seed archive or build mode se shared can now use set unhandled exception filter win 32 functions to catch exceptions not handled by the go run time note that this was already supported on win 386 port well i know nothing about windows i don't work on windows dude they don't even have sockets aren't even file handles on windows what losers i what are you supposed to do with that i don't even know what to do with that sorry i like to make fun of sorry you know what i don't need to make you shouldn't make you know you shouldn't make fun of windows users okay because like you're already a loser and so it's kind of like it it's just rude to kick them while they're down you know what i mean so we shouldn't do that you know they're already they're already hurting you know what i mean they're already hurting and it was just it's it's just really rude to just to do that [music] okay don't you didn't you didn't hear anything okay that's not that's that wasn't w that wasn't windows that was not windows okay we're just gonna move on we're moving on profile guided optimizations pggo builds can now be dev virtualized a higher portion of calls than previously possible most programs from a representative set of go programs now see a 2 to 14% improvement from the uh what's it called p or by from enabling p wow that's cool because that came out in one 2 1.21 right this is cool this is wild this whatever this is i i know we talked about it earlier that it does some sort of like it it's just this is just for super clever stuff oh it's 1.2 okay this this stuff is pretty cool i i i'd like to i i mean i'd like to understand everything more but it doesn't look like it it's working out look at this in go 2 1.21 it's two to 7% better and now they're claiming that it's it's it's going up to 2 to 14% that's pretty wild that's like a lot c number one windows number one beast cco you shut up all right look at compiler now interleaves devirtualization and inlining so interface method calls are better optimized nice go 1.22 also includes a preview of an enhanced implementation of the compiler's inlining phase that uses heris to boost inability or inline ability at call sites deemed important for example in loops and discourage inlining at call sites deemed unimportant for example on panic paths building with go experimental new inliner enables the new call site her istics let's go boosting inability let's go inlining loops are going to be awesome yeah linker's s and w flags are now behav more consistently across all platforms nice i'm just going to move on from that one i don't necessarily care about that as mentioned in the in go 1.20 release notes go 1.22 now requires the final point release of go 1.2 or later for bootstrap we expect that go 1.24 will require final point release of go 1.22 later for bootstrap does that mean building the compiler itself is that what they're trying to say usually that's what they that's h my wrist hurts so much that i may like and subscribe yeah okay that makes sense go 1.22 includes the first v2 package in the standard library math rand v2 really okay nice okay cool this change compared to math rand are detailed in this proposal the most important changes are the read method deprecated in math rand was not carried forward in math rand v2 it remains available in math rand the vast majority of calls to read should use crypto rans read instead of otherwise let's see instead otherwise use a custom read that can be constructed using a u64 method global generator accessed by top level functions is unconditionally randomly seated because the api guarantees no fixed sequence of results optimizations like per thread random generator states are now possible okay interesting interesting the source interface now has a single un 64 method there is no source 64 interface let's go generics coming in boys boys we got those generics coming in at some point i cannot wait i cannot wait for just just things to be that way it's going to be great many methods now use faster algorithms that were not possible to adopt in math random because they changed because they changed the output streams okay so it looks like just a bunch of mathy stuff i i don't know anything about mathy stuff you know i'm just a i'm just a i'm just a diffy q chad i i don't know anything about real math we let's see okay so math got better new go version package the new go version package implements functions for validating and comparing go version strings enhanced routing patterns oh look at this hey can we all just take a second to just just just appreciate this that in the standard library they have an http package that not only is an htp package but it also provides routing and stuff can we all can we all get a little can we all get a little you know as it should be yeah can we all just appreciate that cuz it's not like http has been changing much like the the general usage of http hasn't changed from hp1 11 or even from 10 to three it's just like how the stuff gets trans transferred is really the only change well i mean you could say that hp3 is is different in the sense that the the ssl is in a different location or it's different but but but even hbs that's still hbs doesn't really affect http it's it's at a lower level in the network model right the application starts higher only quick changed that much quick didn't even really change http it just changed like how you interact right you'd still have routes right you still have path in your hp header right you still have like that thing so it's it's it's really hasn't changed it's still the same thing there's still headers right you use qack for compression you still have a path you still have like you still have methods that you call it's still like the same thing it's just now it's it's it's faster it's still request responses yeah it's just tcp versus udp and all the complications that go with udp because once you do udp you have to do you have to be able to construct packets and then you have to be able to decp or decry on a on a per packet base cause causes like a whole there's like a lot of thought about that but anyways hp or routing in standard library now is now more expressive the patterns used by net htp serve server or serve mck have been enhanced to accept methods and wild cards okay okay registering a handler with a method like post items create restricts ation of the handler to request with a given method a pattern with a method takes precedence over matching pattern without one a special case red string handler with get also registers it with head okay i didn't i didn't realize head was a method i i don't know what i i didn't even know about that wild card patterns like items this match segments of the url path the actual segment value may be accessed by doing path value oh my goodness this is so effing convenient a wild card ending like triple dot ellipsis file paths must occur at the end of the pattern and let's see it matches all the remaining segments you don't know head oh leaving yes i didn't know that this is great this is a part of the standard library like i get it that this it is super helpful like this is standard library stuff you don't have to d like you don't have to have like oh am i going to choose happy am i going to choose express am i going to choose restify or whatever it's called you don't have to choose through all this stuff it's just in the effing standard library right yeah i mean rexes aren't too surprising a pattern that ends in slash matches all ps that have it as a prefix as always to match the exact pattern include a trailing dollar sign oh nice okay if two patterns overlap in the request that they match then the more specific pattern takes prence perfect that would make sense cuz oh my goodness you could have a catchall and then you could have like a specific one this is is great this is great and the catch all would work oh beautiful the catch all would only work when the specific ones aren't matched this is great this rule generalizes the original precedence rules and maintains the property that the order in which patterns are registered does not matter perfect perfect this change break this change breaks backwards compatibility in small ways some obvious patterns with this and this behave differently and some some less so treatment of escaped paths have been improved the change is controlled by a go tobg field named hpmx go one 121 okay to restore old behavior this is super cool by the way this is super cool is this not very basic things for a web web a web request handler absolutely it's very basic things but name a single language that has it supported in the standard library right that's what i'm saying that's what's so cool about it go or like rust rust you download a library to get htp at all node no you get htp requests but that's about it right you can do h you can start an htp server but then you do all the handling right php don't you use like a dot access file with little with a little apache server in front of it i mean node just takes the same node takes almost no different path than any other language right no that cat girl cat girl you know you know i'm playing with you cat girl i'm talking about back in the day back in the day that's how you did that's how you did php back in the day minor changes to the to the library as always there are various minor changes in updates to the library with go one promise of compatibility in mind there are various performance improvements not enumerated here okay i don't care about a lot of these things compared the new function or returns the first se let's see first in a sequence of values that is not a zero value cool that's cool that's a that's that seems super con that seems super convenient let's go that's actually super cool so instead of having instead of having so effectively you're probably used to something like this right where you go like this you know a one value or two value or three val right you do something like that it sounds like in in go you're going to have something that looks more like this right compare or and then you just do or you know one value two value three value four value so all right all right all right i never really liked booing operators to assign value you know what i mean i've never really liked that it's always rubbed me the wrong way for a long time and so i'd rather i i mean personally i'd rather do this you know what i mean i'd rather use something like this because it just feels better i don't think it's i i mean it's just a it's just a weird concept right it's just a weird it's just a weird concept what about that well that doesn't quite it's not quite the same right so so this only works for null and undefined right what happen if you want to select the first truthy value then you have to do something different so it's they both have their own things you know what i mean this one's saying a non-zero value so this would be like a truthy value right anyways let's see crypto we're going to just stay out of the crypto one o what's this one the new nl t type provides a way to scan nullable columns for any column type nice okay i use at this point i'm using squeal c so i wouldn't i i i don't raw dog database squeal i just see the results of it so maybe it does something nicer for us that'd be cool all right encoding new methods of pend coding and append decode oh what is this append a code and append decode added to each of the encoding types in the the packages encoding base 32 and encoding base 64 and encoding hex simplify encoding and decoding from and two bite slices by taking care of bite slices buff buffer management okay oh cool yeah okay i see what happens you have a oopsies you have a you have a big old slice okay why didn't they use htm x to restore position this is ridiculous this is ridiculous i see what happens okay so this allows you effectively whenever you do binary operations you don't know how big your blob's going to be you allocate like a space right and then you start writing into it and then when you get to the maximum you have to like allocate a new amount of memory and do something with it and then when you get to the end of that you have to allocate a new piece of memory and then do something you know what i mean and so this this is nice to be able to just have this like hey now yeah you double the do you double the memory or do you go up by 50% or do you go up by you know like what do you do right a lot of people just double the memory and that's what they do whereas this like this just does it for you nice marshalling and encoding functionality now escape slb andf characters i don't know what i don't know what slb andf characters are but all right hey rock on i didn't realize there's an i didn't realize there's an thing is that for is this for like building is this like how temple does things what is a huh is it for comp is it for like doing cool go stuff slb is backspace yeah there's a go parser and go oh there's a go parser and go let's go and i assume this is the same thing o html templates javascript template literals may now contain go template actions and parsing template containing one will no longer return a air js template similarly the go tobg setting oh i want to see dude i wish they could have like a little i'd love a little little example of what they mean exactly here cuz i love their template their template library is extremely amazing for a default template library it contains like 90% of the things i want why do golang math functions return floats like ceiling i think that's a i think that's a xm mop i think that's a that's an artifact of the times if i'm not mistaken i think things will change well i mean the problem is that a ceiling takes in a float and so i guess i mean maybe that's more of a philosophical question i wonder if i wonder if they have it so that you can kind of change which one you want but i wonder if they i wonder if they've made it genericized so you can generic it into into an int yeah just cast into an int it's interesting though i' have i i i i guess i'm curious now why too maybe it's because floats can be specified in a range larger than what can be found in an integer very easily and so therefore casting a sealing a float is a bit dangerous in the sense that it can just it may accidentally and converting into an int may accidentally overflow it it might not fit yeah exactly you may accident get an overflow i want to learn more about how the structured loging came in this is new as of what go 1.2 20 1.20 i would like to learn more about i i don't know about how go does all of its logging all i know is the log class apparently is super convenient and people really love it and i've never heard anyone say anything but like this is the greatest thing ever so i want to learn more about this net hp serve file fs okay anything in here that we want to look about they have new functions serve files file system file server file system and new file transport file system are var are versions of the existing file serve file file serve and new file transport operating on the fs fs okay the hp server and client now reject requests and responses containing an invalid empty content length header the previous behavior uh may be restored by the go debug fields okay cool so if you give us a bad header then it fails properly feels good feels good yeah and then the path value path value is sweet let's see we'll just pass on by these ones os those are all windows except for this one io copy copies from a file to a net unix con it will now use linux send file to system call if possible okay i assume that just means better speedier operations both windows reflect okay there's dude there's a lot of stuff we're gon to there's a lot of stuff so looks like there's some runtime stuff with ppr trace slices o let's look at slices the new function can cat contains multiple slices functions that shrink the size of the slice delete delete fun compact compact fun and replace now zero the elements between the new length and the old length nice i like that insert now always panics if the argument i is out of range previously it did not panic in this a situation if there were no if there were no elements to be inserted okay good like it this is good this is good i actually really like i like this this is all pretty great this is all pretty good this is all pretty good stuff right here nice and they add a little bit of testing over logging interesting testing logging that's pretty interesting and there you go then some ports okay cool so this was awesome go 1.22 looking go 1.22 is looking good it's looking really good i don't know about you guys but i'm very happy about about newo i feel like go is in a great place and it's going in a great direction i feel like ever since they unlocked generics in 1.18 right i think that was go go generic release ever since then it feels like the standard library and the and and the whole system is just getting better in general i feel like it's really going places i kind of felt like it was at a it wasn't as good and now it's just f fantastic and the ecosystem is amazing and go i like it i'm very happy about it this release is much bigger than i thought and good yeah it's very good oh the change to the templates oh can you can you give me a link that doesn't suck i would like to see that template link i'd like to see it can you give me a can you try again just with just here i'll here i'll just copy and paste this what am i saying i'll just copy and paste it that link does suck though all right where where where where where is it where is it where is the thing yeah but hold on it didn't it didn't take me to wherever it is i don't want to go through all this stuff and try to find that one thing right there's a lot of there's a lot of code in here some ignorant ask new takes in chat i hate ms2 but there are some fake history being posted oh there's fake history welcome to the internet welcome to the internet hey this was great use go try it out try it out it's great i think you'll find that go will make you productive in a way you didn't think was possible and you will also potentially be a little bit bored you'll be a little bit bored because you just get stuff done and that's that bill gate sacrifices children to satan i don't know if that's microsoft revisionism or historically accurate i you know a little bit i don't i don't know which one's which i don't know which one's which but who knows nice nice nice based anyways the name is the prime the goen at this point i i think i think i become a go lover i always liked go i've been like my very first twitch stream i started building something called what's it called the hoff i believe that was my first project and that one i used go as a back end yeah i like go go's great go's a great time i've always liked go that was six years ago did you know i've been streaming for six years wild right a jen