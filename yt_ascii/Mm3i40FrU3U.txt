hi my name is julian jamie i'm leading the software solution team at kitware and i have been involved with cmx since pretty much its inception about 20 years ago and i lead the development of c-test and c-dash it's a pleasure for me to be presenting at building c crossbar this year so my talk is is going to be about cmec if there are some of you that are not familiar with cmake i'm going to describe the little details what cmake does and what cmec is i would also talk about about cmake on the support for c plus plus 20 modules and at the end i will talk also about c make dependency only which is something that is getting more and more important in the field these days so kitware works in a wild range of industries and we have five main divisions at kitware we work on the computer vision fields where we treat a lot of videos as well as data analytics and scientific computing with toolkits that we have developed on applications such as vtk and power view and in the medical computing fields the software solutions team is dealing with all the software process and is also responsible for the maintenance of cmake and we also help our customers and the community to get in the ends of cmake and and what's a little bit better with cmake [music] one thing we do at kitware is that we develop platforms and solutions that are based on open source software we are known mostly for vtk the visualization toolkit which was developed in the early days of kitware and keep keep growing we also are developing itk the inside toolkit as well as power view and we are the main developers and maintainer of cmake one particularity about kitware about what we do is that we develop toolkits as well as applications but our toolkits are mostly c plus plus and they have a little bit of particularity that they are cross-platform so they have to run on any type of operating system linux mac windows and also android systems sometimes as well as mobile devices and also they have to work on a wide range of devices such as web desktop mobile cloud or high performance computing so that makes our life a little bit interesting and that requires for us to develop tools that allows us to quickly develop on on cross-platform functionalities so for that we started with we see make and cmec actually started in 99 2000 in the year it was developed initially for the insights segmentation and registration toolkit itk itk is a toolkit meant for medical image processing and it was funded by the national library of medicine a branch of nih in the us and it's part of the visible human projects the visible human project is actually a kind of a interesting project that started in the in the 90s where someone gave his body to science and then he was scanned first cat scan high resolution at the time as well as mri so magnetic resonant imaging as well as slices of his body so his body was laid down it was actually frozen and it was sliced and imaged photography this is what you can see on the top right corner of this slide and this data was the acquisition was was controversial the project was a little bit controversial but but also it was a huge success because he provided for the scientific community the first of its kind data sets and in 99 the nlm looked a little bit at how the data sets were used and a lot of engineers and researchers across the world were using developing algorithms to do image processing on this data image processing such as segmentation so trying to figure out part of the body and extract part of the body in the digital way as well as registration what we call fusion so trying to fuse a cat scan with mri scan to collect the information put them together and so the nln decided to to quickly to develop a framework that will allow to have a common platform for developing these algorithms so instead of having two groups across across the world developing their own algorithms in in in their corner to put that together and and they decided to create the inside toolkit so the inside toolkit is a base c plus plus it's it's an open source toolkit it's available actually at itk.org and it was a consortium initially was was part of academia and part of industry and kitware was involved with this and one of the first stars that kit were at was actually to develop a tool or wait for this toolkit to be compiled this toolkit cpr space toolkit was meant to be used and compiled because it's not an application by a lot of users on researchers that don't necessarily know about drill system or compilations so it was very important for them to be able to easily compile the code so the three main platforms were linux mac and windows and at the time vtk it happened had a tool called pc maker so that was generating visual studio projects so that's how cmx since pretty much day one had a way to generate visual studio projects which was one the unique feature that cmec has at the time and then he grew quite a bit so cmec the 1.0 branch was created in 2001 and then he grew from there and we discussed a little bit about that so what is cmake c-mac is a cross-platform so it works on on a wide variety of platforms and when we say platform is combination of operating system but also hardware that you might have as well as as the tool chains that you might have as well it's open source it's really under a bsd license and it's a build system generator meaning that it's going to generate for your build system and depending on what you have it's it's going to to do that one particularity about cmec is that actually it has to run on a wide range of platforms that i was mentioning and we are testing that every day so we we see tests on c dash we've been developing ways also to test cmec and it happened that it helps us also to to test on house our other software from day one the goal of cmake was and the philosophy we had was to let the developer use their native development tools that they loved the most the main reason for that is instead of imposing the compiler the toolchains and the ide we wanted to let everyone use what they loved because we think first they are more productive this way and they don't have to relearn a tool but also they are able to just keep what they have and use the toolkit so the adoption actually not of c mac itself but the adoption of of the toolkits that will be used would be greater so that was the philosophy we try to keep and that's why c-mac is this way now and it doesn't do it's not perfect but we are trying to to make it uh better every day for that so cmake for those who don't really have touchy maker know what it how it works cmg takes plain text files as inputs so basically files that are called cmakeys.txt to describe your project and what it does is when you run it you will produce project files or mac files so project files will be for xcode for instance or visual studio and make files we support quite a bit of make files as well and cmec is also a family of software development tools so of course for the build we have cmag but we have also component tools such as c-test and c-dash for testing and packaging we have also c-pack so cpac is bundled with cmake if you download cmake you probably have cpac installed with it if you compile it yourself you have an option to compile cpac it's a very lightweight executable that allows you to create professional platform specific installer that's what we use for delivering cmake and it will provide windows mac and also on unix you will support package manager such as xeon apt and so on so it's a nice way to deliver your application so being closer to continuous delivery we use that also for applications that we have at kit where such as power view and others and and again if you use cmake you in your project using cpac is actually fairly simple in about 10 lines of cpac code or cmak code that you add in your in your code it's immaculate files you are able to have a packager of course it doesn't do everything potentially but it will solve most of the packaging problem or solutions that you want to have another component application that we have to cmake is a c test so c c-test is not a unique testing framework as his name might suggest but it's actually a testing driver meaning that it will take your unit testing framework and i say unit testing it could be functional testing any testing framework basically and it will drive it it will drive the test it will run them it will collect the information and then you can do what you want with it you can check if the output is right or not what we do here at kitware is we use it a companion with another tool that we have called c-dash which is a web-based dashboard for collecting testing results from c test the screenshot that you see is an example what we have so each line for instance is is a different configuration that we test for c mac we have android builds that are generated if we every every night where we test continuously this based on merge requests but also on a nightly basis and and we drive the packaging as well so c-dash is is is not going to drive your test itself ctas will do that for you and a lot some people use it in in combinations with jenkins for instance or or chevy ci or security and other ci tools but it's a nice way to display and show the testing results at kitware we work a lot in the visualization fields so when for instance you have a rendering that fails a couple of pixels you need to be able to to show that and you need to be able to explore what's going on so c dash will provide you that in a web manner to do that so one thing we wanted to do with cmake is the analogy we take sometimes is is we wanted to change the way we built c plus plus so interpolated languages some interpreting languages they solve a little bit the cross-platform way by making you install the an application that will do the interpretation of your language so make it portable by default and the same way that boost aims to give c plus that set of useful libraries to be able to use them like java python or csharp or net framework we wanted cmak2 aims at giving this c plus plus portability like the one like the compile wants one everywhere that these languages have and it's obviously not an easy task we've been facing challenges but the community have been has been really helping and we've been improving on top of that the the idea is to have a the same build tool on files for all the platforms we all know that it's not always possible that you need to have sometimes a platform specific ways of of compiling but at least provide a unified framework for that and it should be also easy to mix both large and small libraries that's something we wanted to have as well so the key cmake aspect and the vision of cmak is is basically that we want to only depend on the compiler we didn't want to have to rely on other things than a compiler and that's why some of you have been using cmec the first thing that when you run cmake for the first time the first thing that it does is actually checking which compiler you have and how this compiler works and basically defining this compiler which could be obviously tricky for when you do cross computation sometimes but that's a different story and we work course we want also cmake to work on any type of os compiler on id that would support c prosperous so of course the cmec team development team is is limited so supporting that at the greater scale is is requires community efforts so that's why we rely on the community to to be able to to help us supporting new compiler new ids and new operating system as well and and the goal is to allow linking not only for small projects but also for large projects and being able to do that in a in a seamless way i'm going to say but also to to be able to do that so that everyone can can use it so cmx reports a wide range of tools native tools we support actually pretty much all the version of visual studio starting for visual studio six and we are duplicating them as we go but even eight days ago microsoft announced that 2022 super cmax we'll talk a little bit about that we support volume make another type of make file ninja xcode as warm and we support quite a bit of ids most of these ideas actually have been contributed by the community so cmec is able to generate for this ide what we're seeing also now is that some ideas they will integrate cmec so they will make themselves basically understand cbank which is which is pretty nice to see from that so one thing about cmec is also that cmake it's it's a good system generator so the the part of the generator is important it means that it's not a build system itself so it has to to adapt to new technologies and new ideas and new compilers so for instance we work with microsoft on the visa studio team to have their team working on cmag that has releases supports basically the new version of visual studio are supported after the beta comes out the same with apple on xcode basically weeks after the beta comes out cmake will be supported we work with the google team and the ninja team to support a little bit more cmake as ninja matured and with the recent shift also with apple silicon we've been having support with that being able to support that and also we work with compiler providers and and client gcc intel and others to be able to support new version of the compilers meaning making sure that you make understand this new compiler and and improving that cmac is actually also quite popular according to the jetbrains id c-mac is is the most popular build tools at 53 percent i went up from 82 percent 42 sorry a year ago which is which is great to see and and it's getting a lot of traction so a lot of people are are starting to use cmake and especially for supersports projects so about over 90 percent of of the code that cmec deals with this c plus plus we have also of course cuda and and and all the nvidia efforts that are supported a little bit c sharp fortune as well and and a little bit some other languages that are a little bit more exotic that are not totally supported or that are a smaller version of people are using we also i think about three years ago we looked at job openings we see mac experience an indian on linkedin and just to see which company was was looking for cma developers or cmec understanding cmake or stmx expertise and there are quite a lot actually that are large corporations small corporation actually a startup as well looking for for cmake jobs so which is great to see it's it's great to see let's make this popular one thing i want to reiterate is is cmec is is definitely a community effort the team here at kitware that supports and and develop cmec is it's fairly small but we have great developers here and and we also provide support on training on top of that but there is really a community there are books that are released there are presentations at conferences about cmake and how to use cmake sharing experiences about cmake all of this is is great way to disseminate and i mean the goal of of what we had in mind with cmake was to release an open source good system generator that would work for everyone so that's our goal we're not saying that cmec is going to continue to grow and we are going to we are fairly flexible in trying to make it work for everyone we know that we cannot please everyone there are some projects that it might be difficult to to transition to cmake but most of the time we should be able to do so and and the community has been growing so quite a bit and and in this slide the comparison with auto tools is actually probably not fair but we've seen what is interesting in the blue graph that shows that in google trends it goes back to 2004 but it shows that cmec has been has been growing in interest quite a bit and the community as well has been growing as we can see you would see a small step around 2006 in that graph that's when kde the k desktop environments announced that they were transitioning to cmec so they had been looking at they were using autoconf and then they moved to to python to westcon sorry they try scones and then they finally decide to to move to cmake and we have the we still have the announcement somewhere it was it was great for cmake on the community and starting from there is like snowball into a lot of people using it including large corporations netflix have been using cmx c test on c dash for testing their streaming services for instance to to check the quality of the streaming and they release a small blog about this in in 2014 so we are looking forward for the next decade of cmec potentially growing and adapting and and we know there there will be some challenging out there and working with with the simple space community and others to to make sure that we adapt cmake is very important so so we can ask why cmac is is popular and and actually i mean if some of you have used cmank the getting started with cmak is actually very easy the the level of entry is is very easy with simple commands like ad library ad executable you are able to do again cross-platform being able to generate a library and being able to generate an executable with one line of code i mean you need a little bit more of that but basically with one line of code you are able to to generate that also because we are cross-platform because cmx is cross-platform you are able to generate we are able to touch more more parties and more users that that would be using cmake and and we have even some windows only developers that are using cmx because you make it's a little bit easier to to manage and to support than just staying with with the visual studio for instance only applications and a lot happens with this simple command that we have a lot happens behind the behind the scene that you that are under by cmake and basically you're trusting sima to do the right thing there and there is a lot to do but most of the c press plus nowadays projects that are starting a lot of them are using are using cmx so along the way we had we have some some unlikely but but pretty cool contributors to cmake one of them is in in the recent years we had a collaboration with minecraft so if you have kids or if you are younger than me and you play minecraft that this game is actually set up with a build with cmake because it has two on multiple platforms so it's been a great way for us to basically get into the the minecraft the the collaboration and of course challenges because it's a fairly large project and so on to work with that also starting 2017 visual studio 2017 the microsoft is now shipping cmec with visual studio which is which is great especially considering that not so long ago we were reverse engineering the visual studio project files to make sure that they run with cmac so it's it's been it's been very interesting a way to do that and thanks to the microsoft team for helping us with this and making sure that we are working on that and and they are also helping us on on the module support for instance we wish that to you a little bit later it's been a great addition to to cmec and and also for the developers around the world to be able to do that especially the one using a visual studio we also work with bloomberg engineering so they added a couple of support like the improvement to the exonic of object file definitions for instance or improving also the cmx file-based api that they needed again for their project and that we put in cmak320 not so long ago again these are examples of of communities supported so these are functionalities that are needed for some big projects but also that are used for their projects and it's great to see that and the cute company also has helping us describe some of these as well so i'm not going to go into too much detail about coding with cmake if you are interested i provide some resources at the end of this presentation i just wanted to to just show a little bit for if some of you don't know really about cmake how it works but the way it works is you have your c press plus code so instead of writing a mac file or writing or having your visual studio or xcode generate the mac files for you or project files basically you will describe your project so what you want to do what are the targets what are the dependencies between the targets some properties and so on you will describe that in text files that will be along with your source code in your project and then on each platform you will have cmake installed so what i want to mention about cmake is that cmec is actually a fairly light executable it's written it's meant to to be cross-platform so to work pretty much anywhere and you can compile it assuming that you have a superspace compiler and it's it's fairly easy and it's plain text files so it's it's fairly easy to understand and to parse for cmake and you will run that you will there is a configuration step and there there is also a generation step again i won't go into too much detail into that but basically at the end once you run cmake and you configure your projects you will be able to you will have a mac file or you will have a project file that you can run and then you launch your favorite id qt creator c lion for instance and you can compile your project he will he will exactly know what to do that's the main idea behind cmake there are a couple of ways to run cmake there is a cute guri that is a cross platform again called simek gui that allows you to show that to your developer to show the options so for instance you want to be the documentation do you want to build testing do you want to add specific configuration along the tree you can specify that in the cma gui there is a so terminal cli cc mac that will allow you to to do that and there is also you can run cmake from the command line as a non-interactive command line so basically being able to to run cmake again there is a configuration step on the generation step as well so this is an example of of the cmake workflow so so basically the first thing that you will do you will involve cmake and and if you can see from this slide of what cmac does is checking which compiler you have and it will check does do small configurations check that your compiler and then it will go into the configuration and then it will go it would generate the mac files you can also call cmak dash dash builds that will call your tool chain and that will compile your project automatically and then also you can run testing if you have testing for that so again i'm not going to go into too much detail about how to use cmake i hope i gave you some overview of of what cmake is for people we don't know what cmx does it's available at cmec.org so you can check that there is also documentation and again there are tutorials online that are available and ketu also does training if you are interested as well as support so now i'm going to talk a little bit more about something that we've been pushing in the past years about cmak and and the relation with c plus plus 20 modules which is something that we are very excited and a lot in the community i think are excited about the c plus plus modules but we need to find a way to support that so i'm pretty sure everyone knows how module works but this is a very light example of that is so let's say you have another world cpp file that has a module declaration so we export the hello world and we have an export declaration that export function hello in your main.cpp you will do an import declaration and then you will be able to call that function okay this is great but for from a build system perspective you cannot you need to know the dependencies you need to know that you have to compile helloworld.cpp b4 main.tpp otherwise the compiler will not work and that's something that without parsing the code and having information from the cpus bus compiler you cannot infer that so basically you need to have an external hint and c make there's another parser simple suspension we don't want to have one so we need to have a hint how to build that on the order of dependencies so the good news is well cmec has been doing modules for quite a long time over 60 years actually and one reason for that is because we've been dealing with fortran so kitware works a lot with the national lab the u.s national labs and and in the scientific community a lot of photon code base and mixing with super sparse as well and they have been using cmx so what happened is that in 2005 there was a an initial make file support for modules that was added to cmake barrier by breitkin actually at kitwer and i was added that i'm going to describe a little bit how it works but it was added to c-mac it was it was working pretty well and then in 10 years later we started to add support to ninja for fortune dependency five this was funded as part of the trainers projects from san diego national labs and the way it's been done is basically we had to fork ninja and we have to put the the functionality there and and be able to support to support the modules the good news is that four years later seeing that it was actually working well on the 14th job for this trillionaires project finos is a it's a very large project by the way it has quite a bit of dependencies the grill tree is actually pretty complicated and and with with the fault that we have a ninja work it will show that actually photon modules were working pretty well so what happened in 2019 ninja they merged all the changes upstream to support photon but that was done because also of cpr space module and they knew that super space modules were coming and the system was actually would work for that so how do we handle that in cmake for fortune and then i talk a little bit more about the translation and how that can be done in c plus plus when we move there but so let's say you have a module math here and when you compile it in fortran it would generate a module implementation of object file mazda but you will also generate a mazda mass.mod which is a modular interface file and this file will be actually used by your program main so to generate main.o so basically you need to have main.o to generate sorry you need to have mass that mod to generate your main.o so the build system it has to we must discover this dependency order in order to build and rebuild the program correctly okay so building the program correctly meaning that it has all the information and rebuild meaning that if something change it has to know the dependency and do it correctly but also if something doesn't change we don't want to rebuild all the time we just want to rebuild what's needed so how does it work for cmake so cmec is a target based system so basically in a cmak project we organize the source files into groups that are called targets really i mean if you don't make files that premiere what it is and each target basically corresponds to a final real artifact artifacts a correct build so what we want at the end is the coil grid that means when the source file is changed all the outputs which are affected by the sources contents have to be recreated and so that's the first thing that we want and we want an efficient build like i was saying before is that that means that any outputs which are not affected by the source changes shouldn't be recreated and we don't want to lose precious cpu time to recompile something that was not needed so if we look at the build graph for single source for our fortune module dependency we can look at the f90 original source what what's happening is that we have a preprocessor so the build system has to pre-process the source file to extract the module references and the build system may pre-process the surface independently and concurrently because these are especially these are independents of the module constructs so we should be able to to do that the pre-process rule what it does it's it's performed by compilers in our case and it under the resolution of the include and the defined directives for instance and during the execution of this rule basically cmec expects that there is a other dependency information that is going to be available and that stores in pp that f95 preprocessors so what we do after that we do a scan rule which is basically performed by cmake and the scan rule will extract the what we call the required and provides modules for a source file and and we start adding a ddi extension and once we have this ddi we perform a collate rule again this is performed by cmec and this is to collect information all the scan rules that you might have for your files and we collect that collects all the information also collect rules about the dependent targets and we write a model dependency information called gd file and dynamic definition dependency file and then once we are ready to compile we looked at his dynamic dependency file and one thing to realize here and the arrow that you see the blue arrow means that basically the compile rule cannot be run until the build tool that we are using takes the output of the of the collector so we have to the order has to be that the collect all the information about the collate has to be available for the compile to run so this is something very very important and that is what going to define the order so if we look at the graph for single target you will see that for instance if we have three source files a1 a2 a3 we will do the same thing the pre-process as usual the scan and we collect collate sorry all the scan files output sorry and and then we use that to compile so what you see in this graph actually there is interdependency between the compilation output that will be discovered during the build so you remember that c mac is run configure generate and then you delegate to the build time so at build time you have to understand that and that's why we had to modify ninja so that ninja is able to handle these dynamic dependencies you will note also that in this graph there is no interdependency between the compilation output so if there are any they would be discovered during the builds and that's what we show here is that basically you have a mass that mode that is needed for the object a2 to be compiled that will be discovered by ninja at build time and and and this graph shows a little bit it shows that when a that dd which is basically our output of the correct file that has all the information we need for the dependency when it's up to date and we can read it we'll discover a lot about our build graph and and the build system will understand everything about the big graph and what we can see quickly here is that first a1 and a3 can be compiled separately that a2 depends on a1 at this step and and we have that and more importantly that if something has changed in a1 we might have to recompile a2 but a3 should be good and again all of this is discovered by cmec and by ninja in that case and and we are able to to deal with this dependency and then it gets a little bit more complex when we do a build graph on multiple targets so then one thing we added is that the dd file actually the dependency the the dynamic dependency files for direct dependent targets they are actually additional input to the targets so that means that modules that are contained within a source file in library b for instance that will be used in another use another certified in library c they we will get the dependency correctly for that so i hope that that gives a brief overview on how the dependencies on the on the multiple step that we have the scan and and the collate and that does that does its job so how does c make handles the modules so basically we have a fortune parser that is based off magdeb f 90 which is a make dependency for 1090 applications it's a fortune purser it's not perfect but it works pretty well that's one thing we want to try to avoid adding a parser in in cmake but i touch based on that in two seconds we had to patch ninja and now that's upstream so that's that's pretty good and we have also a dynamic dependency collateral inside cmec that is available and this one could be reused for c plus plus so for the c plus first module actually we we can do exactly the same i mean we can we if we have l from the c plus plus compiler we can we can add the super source will graph and we should be able to skip this the pre-process form so basically we can just have a scan on collect and collate sorry and it will work pretty well exactly the same as as we've seen with the photon code and it will also work with compiled code generators as well so let's say you have j1 cpp.cpp here that generator executable that this executable is run at build time to generate code this a3 code we can do the same we can do a scan and collect on this generate the code and then scan and collect on the b system general on the a1 a2 m3 and then generate the dynamic dependency file for that and it will work exactly the same so we are very confident and and talk a little bit more about that but we are very confident that the what we have done for fortune actually will work for for c cosplayers for simple space modules so there are basically options and and we wrote as part of the c plus first order we wrote some some recommendations but there are some ways to to scan and collate so one option is to scan the sources independently then collect them and that might be preferred when you have incremental drills with a small number of change files because the scan rules on w5 will only be done when necessary we it might be recommended for a project with wide build graphs where the number of scans step at a given grass depth can saturate the build machine setup and also a project with a lot of generated sources obviously another option is to scan source all at once and then collect so that's something that is that is possible as well that might be preferred when we have from scratch builds and when we have also a platform with expensive process execution because you run only once the scan of course this step will require a more complex scan tool so because internally you should decide whether or not to update the output file depending on the source to avoid rerunning other words in necessarily so we need to we need to be a little bit careful when that would require a smart scan tool and the last option is is we can scan the sources and collect and collate all at once so this is probably the more extreme version of the previous examples and we'll need more more complexity for that so the the message here is that we don't want to put c parser in c mac because we feel that well first like the compiler are doing that already so we don't need to redo that we also learned from fortune that well we need to maintain that and when the language language evolved we need to make that evolved and the compiler should be doing that so basically we need we need compilers to provide support for that and and we think that the scan rule that has to be implemented can be implemented as phase four of the compiler and idea ideally will the compiler will provide the name of the module to be imported and exported the name of the header units that are imported so basically defining the dependencies on the path of the file that i weighed by the preprocessors and if we have that information we should be able to to take that and the b system should know the dependency and we should be good so we so we wrote as i was saying we wrote a couple of references and the secrets standard that are done and and actually a visual studio release in 2022 in the version of visual studio 2022 there it is a version of the scan version that seems to work we tested it there are a couple of tweaks that we need to do in cmag but it seems to to implement on that so we are hoping that we will have support for there for gcc on others and in the short future for that so hopefully it will work great next i'm going to talk about c-macon dependencies so as you know when we build a software most of the software they are not independent they are usually dependent depending on quite a few other libraries that are needed in our domain for instance for hpc simulations so high performance computing simulations there are quite a bit of libraries that are developed and for that so for instance either finance element libraries and neural nets libraries for hpc and they usually rely on on a lot of packages so like mfm relies on 31 packages mummy which is a cancer drug interaction modelling system for high performance computing they rely on almost 100 packages and a lot of dependency edges there so it's it's a little bit tricky so the way we try to handle that with cmake is is basically with the notion of find package which has been around forever so let's say you have a library foo and you need png you would do a fan package png and then you would compile your library and then you would use the target link libraries foo and include png and the nice thing with cmake is that actually everything is doing well it will not matter if the target has been installed if the target is the package or if the target is actually sources that you are doing cmake it should be transparent for cmake so cmec provides about 150 fine modules if you type cmake pass ourselves modulus you will get them but the question we have is when we add i mean actually in the in the past years is how do we maintain these modules so what happens is people will develop fine packages we will put them in cmake and then it will happen that these packages will not be supported so new version will be released and we would not have been able to to support this version because either the developer is moving on or we cannot keep up with it so up to like maybe five years or ten years ago i would say that we the idea was to create a full repository where people can commit these fine modules can help maintaining them it never happened but a better solution we realize with especially with what we call modern cmake it's to export the targets so let's the third party application in my case in an example of the png library if it's using cmake and using the install rules of cmake actually cme can generate imported targets for another application to use my png library and because i'm the developer of that png library i know exactly what should be installed what you need to use that png library and and in that case i will be able to provide that and and provide all the information for cmak21 and that's what we do with the install export commands that we generate the library but also generate the targets so the definition of the target so that you may can re-import them and use them this is important and this is great and what we do is we encourage people to that are maintaining a third party libraries that are meant to be used by other applications to to use exporting targets and coming back to exporting targets it's not something that is necessarily very easy to do depending on the complexity of your project but that's something that you can definitely do there are pretty good documentation online for how to do that a couple of other ways also to add a third party into your cmac project is to use what we call excellent projects also called superbuilds so that basically will allow you to build on importing targets at real time so this is something also that is fairly important for cmx so in in this example we point to a git repository with a github and we just add build time so when you type make it it will download and it will build that repository note that repository doesn't have to be cmek based it could be it could have make file it could have a different build system it would work as well i should work as well in three point eleven cement 3.11 we added something similar to super build which is called fetch content and this is basically you will see the signature is very similar to to the previous external project ad but basically it's a way to fetch the content at configure time so that they are available when you configure and it's a nice way to do that being able to deal with that so also that cmake provides all the functionality to under project dependency with external project fetch content or they will never replace cmake with not replace packages package managers so if you have complex software you might be able to handle it and we do that for instance for pi view we handle it with super builds but especially if you use different packages different languages package managers are the solutions for that so conan for instance vc pkg spike are all good options for managing this large deeper space project so konam if some of you probably know that but it's it's based on cmake and and what they do now starting with a newer version they then now able to generate this configure file for cmake so that your package can actually be used by other applications using cmake spark so spac is a package manager for super computers but it actually also allows you to you don't have to use a super computer but being able to use it on on other platforms so that's something also that is very promising and spec claim of fame is also for some code at lawrence livermore national labs using pytorch it goes from days to configure a project to about 20 minutes so a huge improvement there and at kitwa we also been working with the spec team to work us back on windows which is we we think it's going to be great so a couple of things just to to reflect a little bit on the future what we'd like to see for cmake is as i was mentioning we would like to see travel the super space compiler provide this building interface as for the secret source module and also have a standard for cross-platform information for the cma quantifier so that the packages can be can be known by cmake as well i'm going to go next over new cmake features that we've developed i mean that the community has been developing so in collaboration with microsoft we actually introduced starting in cmaj319 presets so basically it's a json file because you make reset.js and that allows you to specify the build directory the generator the cache variables all the information about your builds if you wanted to build on a different compiler most of the time you will have to define your environment different environments or create shell files a shell script nowadays presets allows you to do that so you can use the preset either from the user interface or from the command line with list presets and then you can use that presets with the dash dash preset command or directly from the command line by selecting your presets we added also a couple of new features and thanks for the to the qt company for supporting these developments we as you probably know qt is moving from from qmag to cmake which is great and improving cmake so we added to support speed up compilation the target pre-compilators commands available since 316. so basically allowing you to do precompilators we have also done unity builds so basically creating one source file to speed up the builds there is a documentation on these couple of options that you can set as well to set the size of the of the unity build and so on again available things cma 316 so most of you if you've been up to that we see like probably know that what it does we also introduced in cmac 317 we introduced a support for new geology configuration so before if you wanted to have a configuration like debug and release on ninja you needed to have two drill trees now with the ninja multi-config you can just have multiple configurations in the same drill tree from ninja so it makes things a little bit easier for the developer to work with that and we also added the custom command updates for dependency files for make files so that has been done a little bit more recently in 320. we've done that so that's almost the end of my presentation i just wanted to give you some some tips and what if you want to learn more about cmake we we at kitwa obviously do training and i know some other companies as well are doing training but we we are also available for support as well but so the way if you want to learn a little bit more what i would encourage you to do is not to copy a cma code from from your friends unless it's it's recent code when we do audit we usually can flag that very quickly but uh simek is a language so it's always evolving so i encourage you to to try to to keep up with the language and learn a little bit there are a lot of talks modern teammates on youtube and others platforms that are pretty well done there are books craig scott has been doing an excellent job on professional cmake we have also a discourse form that you can join and and you can look at the questions and ask questions and look at the answers there are documentation that is always up to date not always perfect but always up to date and we have tutorials as well available on the website cmake.org there are technical guides that are available and so tutorial on ways to do things there are also other guides that are available out there on the web that you can find that are fairly easy to follow and and we are also adding ways to we are testing within cmake the documentation it's important for us to to make sure that what is in cmak is able to work and is always compatible with the latest version of teammate that we release so something very important and one thing also is this year we the bookmastering cmac is now open so you can download it you can download the pdf if you want to and look at it we are still going to print a version that is going to be a little bit more lightweight if you like paper copy but otherwise it's it's available if you want to contribute you are welcome to and and again this cmake is a language so keep in mind that that is evolved and if you need more information feel free to contact me thank you very much and i wish you a great rest of the meaning secret press conference thank you