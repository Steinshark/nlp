what would it actually be like to write a vcs game i wish i'd never started now we've done some interesting vintage game videos with matt phillips on the sega mega drive tanglewood it's similar in some ways different in others obviously he was using the original hardware and software to try and develop pretty dug out an old pc the scuzzy card the connection things to do it i've gone for a different approach so i'm writing it in 6502 assembler which is the same with the cpu it uses all well the variant of it we'll look at the hardware more detail than another computer file but i'm writing in there and i'm emulating it using main to generate my display so i'm writing the software compiling it using a modern machines that were all the nice friendly tools but then i've written a couple of tools to generate the rom image which we can then feed into mame to generate things main aims to emulate the electronics very low level so it tries to be as accurate as possible in simulation which is good in this case i don't have an actual console but i do have courtesy of the wonders of the internet a copy of the circuit diagram and it's not that comp implicated machine you've got the 6507 cpu as far as the program is concerned it's a 6502 cpu the same as it found in the commodore 64 in the bbc micro nintendo various different things at the time the special thing about the 6507 is that it had a slightly reduced number of pins so it didn't have the full 16-bit address bus it's only got 13 bits available which means you haven't got quite so much memory and so on in terms of actually writing the software for it programs more or less the same you've also got the 6532 which again is a standard chip which provides some io and it also provides all the ram for the system which is 128 bytes yes one two eight bites not kilobytes not megabytes not gigabytes 128 bytes that's challenging to code for then where do you start with a thing like that well so the first thing you have to remember is that actually that's not the only one we've got so that's year round that's where you can store so that's where you store your variables and you can manipulate and store data there what you've also got is the game cartridge itself which is in fact a rom chip which i have sitting here these are bigger than you these these are 32k eeprom chips you only get 4k allocated on the 2600 so you've got to write your game or your program for the 2600 to run in 4k of memory to store the code but you can't change that so all your code your graphics your data has sounds have to be stored in that 4k you can't change it there are ways it came later where you can sort of bank switch to actually have more storage but you have to program that and build the hardware yourself on the base machine the base cartridge you've got 4k of rom which you can't change and 128 bytes of memory which you can use to store things now i may sound not too bad and you think well okay if i want to write something like pong which is what the sort of games it was originally designed for and it's still the position of bat one bat two the position of the ball and that's probably three but the other thing you have to remember is that when you call subroutines and things in a machine code program you need space to store where you've got to return to we looked at this in a previous video that normally goes on the stack and you've also got to fit that stack on the thing and the way the 6502 stack works is it starts counting down from one ff in hex down and so that meets up with your variables coming from 80 or so in hex and they sort of meet in the middle so you've not actually got that much space you have to keep track of things fairly carefully so that's the sort of standard stuff the thing that makes the 2600 the 2600 is it's got this chip in the middle the tia the television interface adapter and that's what generates the graphics that you see and the sound that you hear on screen when playing the games the system runs the software on the 6502 with the ram in there from the program in the cartridge and you have to drive the tia chip to generate the display on screen simple you might think but this is not a computer like say a bbc micro or c64 where you've actually got a a display where you can write characters into or you can set pixels on and off no this is very much a low level thing you have to program basically the whole video signal system that you would see on your screen almost by hand including turning the synchronization signals on that start this screen in the right place and make sure it actually looks right and if you get that wrong you won't produce a valid video signal that your tv would recognize and so the display would go all ski with and worst case scenario it wouldn't be impossible to make the tv catch fire if you got it really wrong whether it actually catch fire probably not but you could certainly do some nasty things if you got it wrong so the other thing just like matt was saying with the sega is that the cartridge is everything when you put the cartridge in the cpus connected directly to it and it starts executing the code from the cartridge so there's no operating system there so you have to set this everything up yourself so the first thing you have to do on the program is literally zero the memory turn off the interrupts and so on and just make sure everything is set up and then you have to go into what was often called the kernel of the 2600 and start programming it to display things so if i get the programmer's manual which again from the wonders of the internet you can get a copy of the tia chip or staff i think it's sometimes referred to in the 2600 will generate the horizontal sink everything else you're responsible for so it's generating one line of the image and then it'll start the next line if you want anything to appear in there you have to program that chip to generate that pattern that you want to expect and when you get to the next line you have to generate the bits on the next thing until you build it up to build up the whole image as you sort of scan down the thing and if you look at a crt in slow motion you will see it scanning down building up the image bit by bit and then building it up bit by bit it's a bit like ascii art isn't it you know you go along you put what you want in the right place and you press a carriage return and you carry on and yeah i mean that's what that's one way of thinking about it filling up the whole screen 50 times a second and you have to generate everything within those 312 and a half lines to generate the images again pal speak 625 lines on the screen 50 fields of half a frame and so i'm going to watch the video on interlacing or we can assume it's got 312 lines that we scan and if you look at this diagram then you have to make sure that a vertical thing happens for three scan lines and then you have a black bit which is basically telling the screen to make sure nothing is drawn as it refreshes back up to the top left of the screen to start drawing things again and then you start drawing your picture and you've got a little bit of space while the sync happens and you have to set all the data up to draw the first line go back to the next line start drawing the second line and so on all by hand there's no support here other than you can say to the tia wait for the horizontal sync and it will pause the cpu's execution until that happens and then start executing the program again so you have to write your code to do this literally drawing the screen line by line you then have 30 lines which you won't see on the tv because they're off the bottom of the picture and then you start the vertical think again you have to do this continuously because if you stop you don't generate a proper television program we tell the chip to start generating the vertical sync signal and you do this by writing to a particular memory location within that chip it's mapped in as we've talked about in the past we then wait for three of the lines so we've got a loop of three and we wait for the horizontal thing to happen and we count three and then we turn it off and then we start drawing the vertical bank blank area in the same way we've set a different location we wait 45 or so lines in a power image to do that and then we can actually start drawing our graphics let's just make it okay so we start the emulator for the first 128 lines or so we're literally just changing the color of the background on every line of the screen and then for the rest of the screen i've just filled it with white and again i'm counting the number of lines and then we stop and we start drawing this all again so we have to code that in the thing when programming the 2600 the phrase that people used was racing the beam because if your program got too long it would get out of sync with the beam and it would delay things and it would appear at a different point so this mean that store a variable in the wrong place would actually affect the graphics yeah so if you could did particularly things so storing your variables will take a constant amount of time but for example if you do make a decision you say you compare something then you branch or you don't branch they'll take different amounts of time or your code press would have different lengths and so in one way you might delay things to not happen at the right point there's two things you could do to sort of get out of that firstly you've got the vertical blank during that period nothing's being displayed so you can do all sorts of calculations there and not have to worry about it you can sort of work out on average how many lines this bit of code is going to take because you know how long each clock cycle is compared to the video signal so you saw you've got your video signal going and your cpu is going and you need to keep the track of how those things are until you get to the point where you think okay i've done everything i now got 30 lines left of the vertical blank i could just wait for 30 lines and so you're a slave to the display absolutely yeah if you if you've got things out of sync the display would have whatever data was in there what was on the previous line would continue displaying it and then you would get to that point and you could do things now the tih at the stellar chip did have some things to help you you had a background which was just a color which is the basing of this blade and then you could display on top of that various things so there's something called the play field which was 40 bits of graphics you could program 20 bits of them which would be displayed from the left half to the middle of the screen and then it would either repeat them or reflect them over the other side remember the chip was designed to sort of create the sort of pong or tank battle games that were popular in the late 70s and everything else was people abusing the system to provide to create more and more impressive game so you have the sort of play fields and if we turn this code back on we can start drawing things into the play field so i'm going to set the first before pixels to be on and i'm going to set the second eight pixel set of eight pixels to be an oscillating path in the next set of eight pixels to be a different oscillating pattern and then i'll reflect it or not reflecting it depending on which line i am on so if we turn that on we get a slightly different pattern displayed on screen so you've still got our colored bars as before but now we're getting these white lines or gaps where we've turned on the play field so that's like over the top of it is it yeah so we've got four bits here and just notice how big these bits take up they're sort of 40 bits across the whole thing on this we're either reflecting it or we're not so we get a slightly different pattern appearing there basically you've got the background color then the play field for that line drawn on top of that you've also got a ball that'll be drawn think of the pond games you can have a player one and player two and each of them could have a missile that could be fine and they appear on that line and you can set them to be different widths and sizes based on the bits patterns you can draw and you can sort of create the different graphics i decided okay can i draw the computer file logo on a 2600 can i write the code to do that so i set things up and i have a slightly more complicated program here i've got about halfway through it so we'll sort of talk about how this works and then we'll in a another episode we'll actually see if we can get this running on real hardware see whether i'm actually generating a proper sync signal probably not looking at the code and see whether it actually will finish off drawing it so i'm just using playfield graphics here and so on so what i'm going to do i'm going to draw a sort of sky color sort of cyan bluey type color i'm going to have a flashing different color ground and then i'm going to draw the computer file sort of logo and if we run it we've got the graphics being drawn and this is the pleco so the first one i have to set the play field up for eight lines or so in this position then i move on to set it up to draw it in this position and so on i'm changing the values that we're putting in there each time interesting if you look here it looks like i'm a bit late changing the background color and so we get a few pixels of blue being displayed before we get the psychedelia effect at the bottom here that's almost certainly that my code's being slightly delayed in drawing that you're drawing the left hand side of the screen and then you're using a flag that mirrors it yeah i am actually shooting does that mean that the middle bit is actually going to be quite difficult to draw yeah so there's two possible ways i could do it i could possibly do some of it in terms of the playfield graphics so things like if i position things in the right place the top bar at the bottom bar the c i could possibly do the play field graphics we'll try this out when i've actually got a real vcs or a real 2600 there's one on the way from ebay and we'll see if we can get this to actually draw the full logo so my current thoughts are i could perhaps draw the top bit and the bottom bit using the play field graphics and position them to actually just set a couple of pixels here get them reflected that appear in the right place and then perhaps abuse the balls or the missiles and so on to actually really racing the beam draw this side of the things the other thing i could possibly do if i was clever is update the playfield graphics after it's displayed here and count the cycles of the cpu going to change what's displayed here by the time it gets there and sort of draw using the play field graphics we'll have a bit of an experiment and we'll try it on real harder and we'll see what actually works but yeah definitely qdos to the real people who actually spent ages working out how to create games like pac-man and so on their skills are pretty impressive for having to spend some time and of course it's also worth remembering that you didn't just have to do this on the 2016 but even on something like the st or the amigas people are using similar tricks racing the beam across to change the setup for the either the sprite hardware on the amiga or the display on the pallets and things on the st to create graphics which will technically beyond what the hardware should have been capable of producing but of course people have found tricks to do things so for example on the amiga you had eight sprites that you could display on screw on a single line but of course if once it finishes playing one you could sort of move that to the other side of the screen before it got there and actually get things happening in the right place so yeah you have to count your cycles so sometimes the properties would die so you often would make backup copies let's try this one sounds more helpful and so there was this game called lander