we've i think done about five or maybe even six videos counting the extra bits in this area of information theory and a little bit of coding theory and we got to a reasonably good state with this but the story needs finishing off so i'd like to finish off the story and go back to our old example of san francisco weather states i'll try and make this completely understandable in a freestanding way but if you do get a bit lost go to the playlist and just catch up with the bits and pieces that you're not quite sure about what we've done here is split them up into four good codes that are meaningful and four bad ones we've been working for ages now with this very accurate model of san francisco weather that it's either foggy sunny cloudy or rainy and you get about 25% of each of those states so the probabilities a quarter it's a two bit code foggy 0 0 sunny z 1 cloudy 1 z rainy 1 one fine four states four different bit patterns two bits needed what we i think then did right at the very end was this what happens if you get a disturbance electrical disturbance on the line which either turns a zero into a one or a one into a zero now this is a good stage at which to say something which i've never actually emphasized before we're ass ass uming what claude shannon calls a symmetric channel in other words there is a if a bit gets clobbered it could be a zero turning into a one or it could be a one turning into a zero but if that happens it's equally probable either way in other words there's nothing about a one bit that makes it different from a zero bit in terms of its noise immunity so it's a binary symmetric channel we said all right letters add a third bit to these two bit codes and let us keep what's called the overall parity even in other words it must be an even number of ones so here we go look what could you add to two zeros as a third bit on the right and still keep it even parity well it's even parity already so you can add a zero if you send three bits then so long as they arrive looking like one of these patterns that's fine but then you get things like oh w suppose at sacramento they get 0 one0 that's not one of these four so what does 010 tells you well it tells you that something went wrong because it's not in the allowed set but the problem is there's no end of ways that 010 could have arisen so you can detect but you can't correct then we got on to talking about how would sacramento say back to san francisco i got it i love it or not acknowledge i don't like it it's a bad code so we invented a and knack back from sacramento to san francisco and then you go through the same argument finally we said what do we have to do to make a one bit error be correctable and this a and knack got us started famously and we're going to carry this story on today we drew a cube and we decorated around its vertices its corners with all the possible three bit combinations but i carefully arranged so that the three zeros which i'm now using for a three ones as knack i put them at the diametrically opposite corners of a cube and what is magic about doing that is that if there is a one error corruption of the code you can correct it because it is so close its nearest neighbor matching of the bad code against what it must have been so what we've discovered then is that in three bits you can have two so-cal code words bit patterns which are correctable as well as detectable but you can only have two nothing else will fit the remaining corners of the cube are needed to put things right when it goes wrong this is okay actually we've got a nice situation now you send message and you wait for the acknowledge or the not acknowledge to come back so you went out with three bit codes for four weather states and sacramento comes back either says acknowledge not acknowledge but because of this protection the a and the knack are going to get through 99.99999% of the time well there's nothing wrong with that you know as a communications protocol because this is exactly what happens on local area networks here we are then how do we say we've got four weather states but what we'd like to do is not do the act knack protocol we'd like to send them out with sufficient extra bits that the far end sacramento could put it right let's assume that san francisco and sacramento were miles apart you know and you want to transmit it once and have done with it you don't want repeats well three bits clearly isn't going to be enough three bits can accommodate two socalled three bit code words that are distinguishable from one another but no more and your first thought may well be well let's try four bits now the number of bits you use in your code strings equates if you like to the dimensionality of the cube and we've gone beyond cube now to hyper cube this is a topologically correct projection of a four-dimensional hypercube onto two-dimensional flat paper there's lots of ways to dep picked it i've always liked this one i think i saw it in martin gardner scientific american recreational maths column many many years ago you draw a cube and then inside it you draw another cube almost sort of suspended in midair inside the original cube you then connect all of the corresponding corners from the outer cube to the inner cube i've put those in in this diagram as dots but the dots don't mean anything they're just something that makes it easy easier for me to see the structure so don't worry about the dots every line in here is a projection of an edge in the hypercube it's got exactly the right topology but it's been distorted so that you can understand it so here's your challenge audience if you think visually like this oh and by the way we're going to stop at four dimensions i have no intention of going to five dimensions when we get to five bit codes four dimensions is enough but just look at this the challenge is to say we've got four zeros four ones maybe as our two code words still on the outer cube forbit coding on the inner cube can you choose any pair of corners which are not only three apart from each other on the inner cube but are also three jumps away from the existing code words on the outer cube well if i choose that corner it's hopeless it's only one away from existing code word even if i choose this one up here is that any good no it's one two away from here choose this one down here you know is that one any good down at the lower right no it's one two away no matter which of the eight corners you choose in that inner cube and try and get them diametrically opposite so maybe you can pack in two more you just can't do it you can't even pack in one more because it's always no better than two jumps away from existing code words in other words four-dimensional space has letters down big time but now we go over to a much more if you like algebraic bit patent computer science way and we say we will conjecture mathematicians would say this all the time even as computer scientists i conjecture that five bits might be enough to encode four weather states for san francisco go with some sort of protection in it so that far end can correct and cannot need to ask for a retransmit and this basically is the classic hamming code we're going to go against tradition a little bit you're very used to me putting up a bit pattern numbering it from the right and saying that's the zero bit that measures the ones the twos and go right to left for constructing hamming code you go left to right and you start number numbering up one not at zero okay what's special about one well in terms of powers of two is 2 to the power z i'm sure you will all remember anything to the power z is one two is no exception 2^ 0 is one two of course can be written as 2 to the^ one let's just put lines under these another exact power of two here four is 2^ squ so what happens said was this think of your positions that are exact powers of two as being where you put the parity check bits and then you use the other bits in your pattern to hold all the information bits and then i will give you a methodology for working out what the parity check bits would be so instead of adding one parity check bit now like we did you know in the three bit codes we're now going to end up adding no fewer than three par check bits i will stick to even parity nothing special about that you can do it hard if you want to but you must be consistent of course okay those are our column headings what was the state of weather in san francisco on the left the the first code was 0 0 if you remember and i put the information bits of the codes in the three and five positions where they are not poers of two you've got to remember that bit one acts as a checkpoint for the positions one 3 and five bit two is a check for bit two and bit three bit four up here the third pary check bit that checks four and five what you're doing is basically breaking down these order numbers into sums of powers of two let's just see if this i'm taking up two much space with green let's see if the blue works here what i'm pointing out to you is that three can be thought of as 1 + 2 five in terms of sums of powers of two can be thought of as 1 + 4 so this is how it works you write in your information bits and then you say what about my parity bits and you use the these rules here which effectively says that bits 1 three and five taken together must be even parity well look bits three and five information bits not and kn so if one + 3 + 5 in parity terms and of course a lot of you realize we're doing exclusive ors here of ones and zeros zero and zero it's even already so to keep the three bit grouping including one even it needs to be zero bit two checks two and three but three is already zero so 2 + three is parity bits must add up to being even it's zero already so we get another zero finally what about bit four unknown at the moment it's got to be a parity check ah well four and five taken together must form an even parity pair oh that's dead easy what it's predicted is it's a simple binary repetition code for one of the states okay but everything is guided by your information bits we're now going to move on to 01 same rule look bit one checks one three and five okay three and five are in there already they are data bits ah but there's one and a zero now to make the whole thing even pared then what have i got to do to the one bit make it a one because one and one give you even parity and then check out bit two bit two combined with bit three must give an even parity combination well bit three is in there is a zero so two combined with three you've got to have a zero and then finally bit four well four and five taken together must form an even parity combination so therefore if five is one then sorry folks four has got to be one the next information code i put in there which my note say is the cloudy code one and zero here we go again 1 three and five taken together must form an even parity combination but you've got a one there and a zero there so you need a one here to balance it off got an even number ones right and then bit two two and three taken together well three is one we're stuck with that it's part of the data so we put a one in here to make it even and then four and five taken together so that's a zero and finally rainy here we go again so our final bit pattern that we've got to locate in here is one one for rainy okay one three and five taken together must be even well one and one three and five that's even so keep it even by putting a zero in there but two and three taken together well three is a one so two and three taken together be parity must have a one there four and five that's a one so you need another one in here to make 4+ 5 so there we are folks those are our so-called code words for all of the states of weather look at them if you look at foggy and sunny in how many places do the bit patterns differ n one that's a difference n n that's matches that matches that's different that's different three differences they're distance three apart and remember distance three is magic we saw that on the cube if you keep your code words three bits apart from one another then everything follows absolutely beautifully and that works fine we're now in a situation where we can send all this stuff off to sacramento and they can bluming well sort it out for themselves so long as you don't get more than one error in that then fine you can correct it by using these hamming codes and you say well how do you correct it well the answer to that is you do various simple exclusive or operations on these parity check bits at the power of two positions you know like the one two and four position you use various combinations of those very much along the lines of how we encode it in the first place and depending on the outcome of those you'll find that some of them check out all right yes it's it's it is even some of them are bad and wrong and it's odd and by combining the start positions for the odd ones that are bad you can uniquely home in on the bit that's gone wrong and if you want to know more about that just write in and ask sean and we'll see what we can do b had a length of two h has a length of one so h has a distance of three b is done right we've done b we we can count that as is done so c next right so we're here we can't go to s we can only go to l that's a nice easy