we talked a bit about the hardware, you know, people are working on the hardware of quantum computing, yep what about software? where do you start thinking about that? writing software for a quantum computer in my opinion is actually not very very different from how we write software for just a normal computer and we think about software in terms of being able to write down instructions for the computer and the computer executing these instructions changing some internal state when i write instructions for any type of computer whether it be like a modern macbook pro or an old pdp-11 in both cases in the end, we have an assembly code that gets executed that's changing the memory the disk the registers in your cpu and so on and it's not different with a quantum computer it's just like the question is what are we changing? and how do we change them? we can really describe these things in quite simple terms, if we were to do this in with sort of full textbook honesty, we would discuss things like finite dimensional vector spaces and in hilbert spaces and linear operators and unitary maps and all that stuff and all that stuff is very very important if if you're actually sitting down writing a program but to get an understanding of it i think we can do away with it. and actually just think about things in terms of simple probabilities. so the idea of a qubit so qubit is a bit in a quantom computer yep it is. yeah. it's sort of the fundamental building block. it's like a it's like a bit and a regular computer the way i think of it is it's a resource in the computer. it's a resource that you can use to perform a computation so a qubit to me is anything it's sort of abstract. but anything that has two states of being and some possibility or probability of those states. so for instance we can think about photons and their polarization a photon can be sort of polarized left and right or it can be polarized up and down but if we're not looking then maybe it's it's possibly in one or the other. maybe it's 50% moving and traversing left and right and 50% moving up and down. this is just for photons turns out there are lots and lots of different ways to construct qubits the qubits that that we work on in the so called field of superconducting quantum computation. we use a device called a superconducting charge qubit it doesn't matter all the details, but it suffice to say that the two states there are is their charge or is there no charge in this circuit? and then of course, we have the same thing. it could we could have a probability like maybe there's a 10% chance there's a charge or maybe there's a 90% chance there's a charge. these are called superconducting charge qubits again, it sounds complicated, but the essence is the same two states but maybe it's in one or the other the interesting thing though is when we have multiple qubits, and this is really where the power of quantum computation happens we can actually think of it sort of simply diagrammatically that if qubits if i just represent them sort of as a circle here, maybe we have three the idea is that these qubits can interact this guy can interact with this guy? this guy can interact with this guy and these can interact with one another and every time we add a qubit if we were to add a circle here. let's say we added this fourth qubit right here we noticed that every single one of them can now interact with it. we have to draw lots of these lines it turns out that a quantum computer can deal with these additions of qubits in a very efficient fashion but like i said a qubit is something where it has two states so each of these guys can be in two states with a particular probability let's say the two states and our just 0 and 1, our qubit can be 0 or 1 or possibly something in between. so if i write down these qubits with the probability, let's say we have three qubits here i'll call it q0 q1 and q2 what we have is that qubit 0 let's say it's this one right here 1 and 2, well qubit 0 could be in 0 or 1 so it has some probability of being in 0 qubit 1 also has some probability of being in 0 and qubit 0 also has some probability being in 0 maybe that's a 10% chance but now we have to painstakingly go through a write every one qubit 0 has a probability of being in the 0 state qubit 1 also 0 and qubit 2 and we can write down all these possibilities etc, etc until we get to the possibility that all of them are one and each of them has a probability. maybe this is 5% maybe this is 7%, maybe this is like 35%, maybe there's a very high percentage chance that all of them are one 8% and so on so every time we add a qubit the size of this table doubles the number of probability percentages doubles and it turns out that these probabilities right here are ultimately what a quantum computer is computing with when we do an instruction on a quantum computer when we instruct it to do something in the end it's always about changing these probabilities to favor some computation that we're trying to do when we start up a quantum computer, when we flick the switch on it'll start as 100% in this state and everything else will be 0% we start off here, and we know that we start off here. it might be that when we apply a certain operation so for example an operation as is the so called superposition initialization or we call it hadamard initialization this is if we have any number of qubits, so starting off in zero, and maybe we want every probability to be equal so if we want to start off here we do something called hadamard initialization where we do a particular instruction called the hadamard gate and what happens is this 100% now turns into let's say we just have one qubit it would be 50% chance in the zero state and 50% chance in the one state if we had two qubits hadamard initialization would cause us to be 25% chance with both qubits being 0 25% chance 0 1 25% chance being 1 0 25% chance being 1 1 the point is is that this particular instructions one instruction on a quantum computer? allows us to change these probabilities in a way that we'd like and it might be useful for us to do something like this hadamard initialization with all the probabilities being equal because then from here we could do some operation that affects all these qubits and affects all these probabilities sort of in the same way. but like i said, this is just one possible instruction so there can be an infinite number just like a normal computer it's not that they're an infinite number of instructions it's that they're an infinite of possible things you could do with the instructions so one of the greatest discoveries was that we can arrange these probabilities to be in whatever way that we would like using five instructions total there are sort of five different ways that we can permute these things and change them and there are this, one is called a measure instruction measure instruction is pretty important because while we're talking about probabilities we can't actually see these probabilities in the quantum computer they're just in there at some point. we do want to see are they zeros or ones? like we need to answer that question so the measure instruction will take any list of probabilities and turn it into one of them will change to 100% so each of these is 25% chance. it'll pick one let's say it's this one right here and measure is gonna make this a hundred percent with the other ones being zero percent that's one way of changing and then incidentally we also get to read out from the clunkier that it was a 1 0 that's how we get our answers. that's the only way we get an answer. in fact from the quantum computer the rest of them are just purely ways of changing these probabilities. there are lots of different ways you can have instruction just like norm... regular computers every single computer that's ever been built or every single cpu that's erver been built always has a different instruction set one possible instruction set is the following we have this hadamard is that named after someone? yes, it's named after i think he was a mathematician he worked on a variety of mathematical subjects and there's a matrix that's actually one divided by square root of 2 1 1 1 negative 1 which is a so-called hadamard matrix incidentally this is also used to represent how these probabilities change so hadamard is one instruction there's another instruction called phase, again it just has the effect of changing probabilities around in a particular way there's another instruction called the t gate not very creatively named there's another instruction called the cnot gate and what's special about the cnot gate is that all of these right here act on one qubit we say i want to do a measure on qubit 2 or i want to do a t gate on qubit 0 it sort of affects only one qubit. it'll affect a lot of probabilities because even though we're operating on one qubit here it accounts for this entire column so it actually changes all the probabilities cnot is special because we get to choose two qubits this is how we get this interaction between them so cnot you can say i want to do this on qubit 0 and qubit 2 for instance and this itself is an instruction in a sort of quantum assembly code are these instructions a bit like gates? yea, so they are like gates but there's an interesting reversal and for example a nand gate is something like this where data is coming into the gate and data comes out of the gate what's interesting about these gates and quantum computation is sort of the opposite you have data that's sitting there all these probabilities and you like apply the gate to the machine and all the probabilities change. so you're not sending data into the gate you're not putting this gate on the chip like a nand gate for instance is a gate that you would actually etch into a chip here it's an instruction that you apply to the computer and it changes these probabilities, but nonetheless they're both different operations that you do on data and how does what you do is code get changed into these operations of instructions yeah, so like with normal computers you can write these instructions out as assembly code. in fact one example is say i want the following probabilities i have 0 0 0 1 1 0 1 1 i want this i want it to be 50% chance to be 0 0 or 50% chance to be 1 1 this is called a bell state with a bell state. it's interesting because theoretically let's suppose i have a qubit. let's say close i could hold a qubit and let's say i gave you a qubit it's 50% chance 0 0 or 50% chance 1 1 so even if we travelled halfway across the world and i decided to measure my qubit with the measure instruction and i determine that to 0 then i know for certain that you must be a 0 because there's a zero percent chance that were different, but somehow we determine this it's a 50% chance. it's not that it is already chosen literally is 50% chance. you don't know which one it is so we can write a program to construct a bell state i won't explain exactly why it works this way but you do a hadamard on my qubit, qubit 0 we do a cnot on my qubit and your qubit and we're done. this is a quantum program. you can write this out. now there are higher levels of quantum programming where we don't want to restrict ourselves these instructions maybe i want to more directly express the probabilities and how i want them to change they all have to add up to 1 of course. i mean, we have a certain percentage chance it has to be 100% in the end, but maybe i want to shift the probabilities around in a particular way but not in any of the ways that's in our gate set i can write that down that can use something called a quantum compiler a piece of software that that converts what i want into these native instructions that gives me the next level of abstraction in the code we can go all the way up to using a full-blown library for writing this stuff one library that we've constructed is something called "pyquil" which allows us to actually write python code to express quantum computations in quil is actually this instruction set here quil stands for quantum instruction language, which lets you write down this assembly code but hey, who came up with this things? is this a commercial thing or is this like... yeah, yeah so quil was originally this particular type of instruction set was a paper that i actually wrote a while ago the idea of gates and everything was very well known for many decades previous to that so this is a particular encoding of gates as instructions pyquil is a library that's open source, it's free there are no restrictions really on using it to construct these programs, but it does allow you to actually connect up to rigetti computing's real quantum computers if you if you so pleased to actually run your programs but if you don't want to connect up to the quantum computers and you just want to simulate on your own laptop this can connect up to a an open source simulation tool that we have if you just kind of want to see how these probabilities change and so on not quite you still have to express a quantum computation so a quantum computer doesn't print things out it's it's manipulating these probabilities so at some point you start to express things as quantum instructions, so definitely if you wanted to make a bell state writing the bell state program you could do that but could you write "hello world?" no, and this goes back to the fact that the quantum computer is a coprocessor just like saying you don't write 'hello world' on your gpu generally you don't express any particular computation and you also don't compile python into code on your gpu you write special code within python that gets run on your gpu and it's the same thing with quantum computing and i know you said there are certain stabilty issues do you get hard answers outta this? so, yeah, so when an answer comes out when you measure you do get definite answer out, however since there's noise what we have to do is write our program get an answer out and store that and actually rerun it multiple times we have to gather statistics about the answer and it turns out that the more you do this the more accurate your answers become and that is to account for noise in the quantum computer currently so when we're talking about setting these probabilities, what you want them to be and i understand kind of running operations and gates to do just sounds like you know the answer yeah, no, you don't know the answer you just show that if you were to do this series of operations that you'd get the right answer on, the answer might be different depending ofcourse the answer will be diffrent depending on the problem that you have so for instance one of the main questions the quantum computer can solve is the same question that you can get from something called the fourier transform where you can find if you have like a sound wave and you want to find what frequencies it has you know that if you run the fourier transform proven using mathematics and so on that the answer will be the set of frequencies that make up that sound likewise here. there's actually something called a quantum fourier transform where if you run it you know that probabilities will accumulate on the answers or the frequencies. maybe that your that your sound wave has so, you know just by the construction of your program that you'll get the correct answer not that you know the correct answer itself at the front-end, and that's the same with classical computing in my opinion you rarely do you know what the final answer is you just know the computation or the program that you've written will produce the correct answer you need more than one qubit to make this work you can use a qubit if you have a normal qubit your table is gonna look like this you're gonna have prob and maybe it's like 50% in your states are just 0 and 1 except they're just not very many useful things you can do with a single qubit the power really comes from multiple qubits because you get this nice scaling law where if you have n qubits the number of probabilities that you get to work with is 2 to the power of n so every single additional qubit you're doubling the number of probabilities that you have to work with how do you know how to do that for a regular computer though well, i suppose with a regular computer if you're if you're adding numbers together yep something comes out. mm-hmm. it's the same thing at the quantum computer your input is a bunch of probabilities which you know at the very start and all these gates change those probabilities in a controlled way you know exactly how hadamard or phase or t or cnot you know exactly how it's gonna change those and you can write down exactly how it'll change those so you can mechanically do the computation in the same way that we can mechanically do it with adders or ale use or whatever just turns out that the most basic type of computation is actually a really it's a really large one it's actually equivalent to a big matrix multiply. if you were to write this out your probabilities as a column vector 50% 25% whatever 7% etc, etc every operation in a quantum computer is actually specified as a matrix. you have a big set of matrix elements maybe it's like 1 0 0 0 0 0 0 0 1 1/2 3/4 whatever i'm making it up as i go along of course, but you know with certainty 100% certainty that this operation maybe this is like hadamard on qubit 0 and hadamard on qubit 1 or something like that it's not but you know that this operation is gonna change his probabilities and i could if i wanted to manually go and compute this matrix multiplication. the thing is like i said this vector right here grows doubles in size every time i add a qubit so it's better for a quantum computer to do it as opposed to me or even a normal computer doing it yep, this multiplication happens on the order of 50 to 250 nanoseconds on a computer no matter the number of qubits that you have even if you have 250 qubits this vector right here would be 2 to the power of 250 which is some enormously large number i don't even know an order of magnitude estimate of what that is it's so bigger than any computer on earth could store bigger than any computer in the universe could store but nonetheless it will do this multiplication in 50 nanoseconds, which really starts getting into why quantum computers show promise for very fast or very powerful applications how much does a quantum computer cost then? oh my gosh all the components it costs a great deal for sure if you want to buy one and have it in your living room yeah, so one of the big popular ones is a very recent algorithm back in i think 2014 is when i came out