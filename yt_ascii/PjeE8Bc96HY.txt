we've talked about various aspects of bootstrapping a lot on computer file going way back, i think to a ton robin video three or four years ago now which is doing very well dilemma of the chicken and the egg. he talks very well about the essential nature of bootstrapping and so on but he very carefully avoids going into detail because it does get complicated the way i've always found best to teach it is to use a tool called t diagrams, which you just draw for yourself i'm going to explain via diagrams what it means to bootstrap bootstrap a system like an assembler or a compiler or whatever, but first of all what is a t diagram draw me a t diagram let us assume that you have written a program? in bell lab c language, you are very very proud of this program you think is absolutely wonderful and will win an award and all that. this is the input to your program. this is the output from your program and at this level i can say what does that mean? it means that the program was written in i've chosen c deliberately because it's low level it's fairly close to the hardware something like this i hope you'll all recognize you're writing a simple program in a simple language and you're delighted when you're high level statements produce ultimately this thing i will try not to fall back into a cheese usage and say it produces a core image they even call it that's about as no. it's an executable. okay? well we all know that it's all very well saying our right? agency is gonna have this input it will produce that output. the next question is but how do you convert the c? into a runnable executable binary which will be your program. you have to get that c translated and here you begin to see the power of t diagrams draw this one again input/output it's written in c now here's the clever that positioning another t block like that up against this one shows you how this has to be processed what you need is something that will turn you'll see program statements into a working binary on the machine you're working on you may say mmm, but where did this come from? somebody provided me with a thing that is capable of taking in c statements is is itself an executable binary it's running on my arm chip on my intel on my apple or whatever this is my c compiler. of course, there's got to have come from somewhere, but we'll get into that later so there's the c compiler and if you feed the c language for your master program through that compiler, you know what happens? it produces an a dot out on unix or an executable binary the net effect of slotting that t diagram against here slightly downwards is to show you that the c you've written gets converted into binary and the net output from this process it produces out a program that you probably store in a file somewhere which is like this left-hand side only a little bit different because it's now input/output but look what has happened during the compilation process? is that by compiling your c statements for your program? it drinks the minutes data. the compiler itself is a binary running on your architecture that you're perfectly happy with. it is squirting out executable binary so i can write in here let's say that's my output binary code, but that output binary code i'll stick with a pink our right bin in here to show you that that is what the compiler has done for you you think of it as input? producing output and i wrote it in c and you close your eyes as to what happens it just works but your binary your a dot out your ultimate executable will tell your input will produce perfect out put first time of course, but it is essentially written in binary and has to be to execute directly the hardware that has been produced by ac compiler and the t diagram for c compiler is this i accept as input c. i am a runnable binary otherwise, i won't work at all, but i have code generation capabilities i generate binary that will run and that is your user executable and here's the first point i want to make the quality of the binary that actually is your compiler running may be very different from the quality of the binary that it spits out as a translation of your program they may be very similar or it could be that the c compiler is actually very very slow at producing your output binary, but if he gets there in the end you don't care it could be ultra fast it could be that you've written a see compilers are so bad that the output that it produces for you is worse than it itself is using. i hope you all get the hang here there's not necessarily any direct link between the quality of the binary you are running to make the c compiler work as opposed to the binary. it is spitting out for your program has its translation they may be related and may be close and all this what i think now i will try and do for you is to take the story one stage backwards and start speculating about how the heck did i get the c compiler? is it something that 10 thompson handed over or dennis ritchie hand it over to me already made it could have been oh you might say dennis how did you implement that to c? compiler and he was so well the first version i wrote off the back of an assembler and of course this it goes on recursively forever, but dennis who wrote the assembler you know and back and back and back right down to squirting ones and zeros in on hand kids no, let's presume for the next stage of the story that from somewhere your little machine did also come with an assembler for low-level programming for filling in the bits that may be the c compiler for one reason or another isn't suitable for well. how is that done in t diagram terms and by looking at how the assembler is done. we can then see how it's possible to bootstrap off an assembler version of something to a higher-level version an assembler is like a compiler except for those of you who've done it, you know in every sense an assembler is at a lower level assembler some particular macro assemblers, they'll give you a vestigial capability to do an array but they may not have structures almost certainly won't they're a high level constructs you see so you you're down with simple add subtract? statements you can move about memory. you've got to understand pointers we've done lots of those you do them at the assembler level. you're in charge you must keep track of what your pointers are in so on and so on and so on it's just a simpler view of the world and a more detailed and complicated one in several ways i'll call it ac and that stands for assembler input now you expect that assembler to produce you a runnable executable binary. well, i'm going to write this in here as saying that the code generation from the assembler is going to produce me what i'll call a binary of type a is produced from an assembler it's an assembler quality binary it depends on the koho wrote the code generator for the assembler as to how good that being a is now here's the thing again. you'll have to get your head round and get used to this is au been you i don't know how this was developed this assembler all i know is i met ken in the corridor david wheeler it came to the corridor and said hey, here's the assembler i use they handed over an executable and i did not ask questions about how that in itself may have been bootstrapped out of nothing. they just said here's an assembler it works use it. so okay. i say, thank you i mean at the midpoint of a endless sequence of bootstrapping but i can build on top of an sm to build the c compiler shall we say so you put assembler codes in of course? the unknown provenance binary is worrying away. and that is executing the assembler code and out it comes as binary of type a which you can put in a file bn a dot out file under you mix it could be whatever you can store it in a file you can invoke it you can execute it and the only difference from what's gone before is that the assembler code is it's a lower sophistication level than you'll see you would be a lot of you know again i keep harking back to bell labs history largely because it's very good for illustrating this thing you can say look this really happened. this really is what dennis inten did this is what you have to be aware of dennis said you can and cancers to dennis for the next version of the unix operating system we've gotta write it in something higher level it drives you mad writing it in assembler because there's no easy way of keeping track of pointers. there's no structures in fact in a recent video now out there in the wild somewhere ken thompson admits he said our first three attempts to write unix in a higher-level language and dennis was developing say the first three attempts. i tried i'm ken thompson failed. why did they fail i found later the fourth attempt dennis had put structures in c and that's what i needed because they automatically keep track of offsets and pointers. wonderful. okay so here we are then back in that kind of era. we are wanting to create a c language compiler, but we are writing it as a simpler code level it is going to produce a binary but going back to what we said last time because it came out of an assembler era we're going to presume that the binary that this thing produces is what we'll call binary a it came via an assembler did this execute them fine, but then you look at that say hey, come on. this is brushing over certain details you can't directly execute assembler and unless somebody's written an assembler interpreter for you, but they're again no, they haven't that's emblem coding. it's got to be converted into a binary how do you turn the assembler coding into a binary and so sort up another t diagram and visualize what goes on? there just happens to be hanging around because ken gave it to us in the corridor a thing called an assembler and the assembler accepts any old assembler code you like? produces what we'll call been a an executable binary but it came out of an assembler and that the assembler itself the binary is of unknown provenance candidate in absolute binary off the top of his head probably not but somebody labored long and hard to write a thing that really works as an assembler on this particular machine that you are working on what you need to do is to feed the assembler code that implements your c compiler into the assembler itself to assemble it. you've got to assemble the assembly code that is the compiler and it goes in as assembler coding. it's running on its own binary. you're thinking a while' crash no, it won't ken wrote it, you know this sort of thing that was around and it converts the assembler code into binary of quality a that binary of quality a when it's produced you can store in a file. it's an executable it's an a dot out file and then you have created a thing which takes in c produces binary a assembler coding so your net output here then is the following it's c. it spits out an executable binary for you the c compiler so we now have a c compiler that is not just as it were implemented at the assembly code level but that assembly code has been translated into a binary so that the c compiler can actually run on hardware and once again there's trace through the assembler code that implements the c compiler is fed into the assembler this thing was round and round like mad but the assembler code statements that are the compiler get translated into bin of quality a and that's the implementation vehicle for your new c compiler you have produced a c compiler by building it out of an assembler by using the assembler as the next stage long, which you have to do the assembler converts the assembler code that is the c compiler into being a workable runnable binary of quality a so that's the first start of your compiler is to say we we doing bootstrapping we've come up off an assembler solution we wrote in our high-level language and here we are a very very first c compiler is there a problem with it? not really? except that what we want to do here is to say well we want an ac compiler that will produce runnable binary of some sort and then we say hey but the only tool we've got to making a binary for this c compiler is that there is the assembler itself right the assembler produces benet, so you're stuck with that so can you see that by running the assembler there and making it squirt out binary a quality? equivalent to the assembler code that is the compiler you end up with ac compiler marquand that spits out benet but is running on binet we're at the mercy of bin of quality a the assembler quality binary. is it good? is it bad? could we do better? yeah we stop there but just as a marker for what's coming if your head isn't aching yet that thing is building a compiler off an assembler when that is working what do you do to make it better you rewrite it and you make a new version of a c compiler that produces beam b which is so binary but how do you compile a new version of the c compiler answer with the old one? so you end up with a seat have been better, but it's still running on binet next time i'd lost my compilers notes and assembling those did you see diagrams? but thanks to one of my grad students rom nots bless you ron who was a complete pack rat? he had rewritten all my notes in much better shape and had come on to them from 30-something years ago so i couldn't made this video without your own. thank you very much