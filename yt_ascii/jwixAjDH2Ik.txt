so yes indeed welcome to my talk on testing cute desktop applications i'm i'm claire mcrae i'm speaking to you from cambridge in england and it's an honor to have been invited to speak thank you very much i just a quick high level overview of the talk is predominantly about testing of cute but a significant part of what i talk about in the setting up testing which is the bulk of the talk it's actually more generally useful not just to gui testing but to testing large and complicated applications in general so if you're unsure whether to watch this and not a cute person do stick around at least until until till the end of that section i'll talk also about error-prone aspects of cute code because they're particular areas that you'll probably want to focus on testing and i'll mention at the end briefly about using the approval tests approach and library with cute code and i'll explain more about that when i get there briefly about me i started programming in c plus about the same time as i started programming with cute more than 20 years ago now i've always been interested in testing but in recent years helping to share what i've been learning about sustainable and efficient testing has really become my main focus in working life both when dealing with legacy code and when dealing with how to test code i'm the co-author with laurel and falco of the approval test library for testing c plus plus i'm happy to answer questions via twitter and email at any time but for larger bodies of work i'm also available for consulting and for training there are a lot of links in this talk you can get them from bitly slash testing cute from that qr code or from that github link and those appear at the end of the talk as well so don't worry if you don't catch them at this point the nature of an online event is that i can't really feasibly answer questions during the talk so there'll be a slot at the end to answer questions if you've got any questions pop them in the q a tab in remo if they relate to a particular slide i'd really appreciate if you could make a note of the slide number so we can get back to the right point so here's the scenario that i've talked about before but it's really important to understand the context so the context here is you've inherited some cute gui code and it's valuable so you need to you've been asked to make an improvement to it perhaps add a feature or fix a bug and you check whether it's got tests and it doesn't so therefore it wasn't designed for testing and it's hard to add tests so you would want to refactor it to make it testable but you can't do that safely without tests and that's the famous vicious circle when dealing with legacy code and in this talk my focus is on the right hand side so talking about when you have no test and the code wasn't designed for testing what can you do then i'm going to help you break out of that the circle at that point the talking about strategies and patterns for refactoring that's a whole other talk there's not time for that today so moving on to cute if for anyone who isn't familiar with it cute is a at least 20 year old framework cross-platform graphical user interface application application framework a library so many of the desktop and mobile applications that you're probably familiar with using will have been developed using qt and you can write your your user interface on one platform one desktop platform and run it on all desktop platforms really really powerful library but i firmly believe that qt's graphical user interface powers do make automated testing harder there's so much more to deal with than with testing console applications and my goal for today is to give you the confidence to start testing your cute application effectively and quickly as well so let's talk about setting up testing but before i do i just want to mention a tool called squish which is produced by the frog logic company it's an automated gui testing framework for kit for cute applications and typically almost always you would use it by running your entire application and squish test the behavior of your whole application it's a commercial tool so not not available for open source basically the way it works is you sort of sketch out a scenario a series of steps that you want to test and then with the squish tool running you go through those actions in your qt application and squish records your actions the events that you've triggered and saves them in the programming language of your choice i'm familiar with python using it with python and then you refactor the recorded events are no use for testing they're dependent on screen resolution and things like that so you refactor the recorded code and add checkpoints along the way in my opinion it's a very powerful tool but it's not a replacement for unit tests if you think about the the cycle of development if you're testing your whole application level you're going to have a whole lot more code to build and to link and to run and depending on the startup time of the application that may slow you down quite a lot as well i would also add that it requires a significant commitment on the part of the organization to training and to maintenance of the test they're higher level tests so they have a tendency to be more brittle but if you can use them well and there are certainly companies that have done they can replace a huge amount of manual testing that a lot of organizations if they don't have good unit test coverage they settle for manual testing typically before a release cycle and so squish can where i worked previously we use squish to significantly speed up our release cycle so i am not talking about squish but it's important to let people know that it exists because it is a powerful tool this summer there was a really good talk on behavior-driven development testing with squish and if you're going to use squish i really recommend this talk the link to it is in the notes that i'll share at the end so the talk the type of testing that i'm talking about is developer written tests where you've you're editing the code you've got access to the code and you're writing small amounts of c plus to exercise the code and test the behavior and when when necessary to modify the code that you're testing to make it easier to test so that's our context for today and i want to talk a little bit about how you add tests to an existing app because it's a question that i was asked after i'd given several talks on testing i realized that if you haven't used tests before understanding the starting point is really important and the answer is you don't add tests literally to your existing main so imagine that you have a program which for simplicity i'll call gui.xe it's got a main it's got a load of cpp and header files and if it's a cute application it's probably got ui files designer files and so on and what you do in order to make the bulk of that code testable is separate it out into a separate library which i've called ui.lib here and so you change your build system so that the build system creates a library a static library and i'll talk about why static in a minute and you link compile and link into that library your cpp files and your ui files and then your gui program links ideally just contains the main and the build system links that library into your gui program what that then allows you to do is to write a separate program called for example uitest.exe which has its own main and its own set of source files that contain the tests the assertions so this has lots of benefits one of which is developer productivity because the code in the library is only built once and then both of the executables link it and you can be confident that your tests when they're running that the way that the library code the implementation code is compiled is consistent with the way the release code is compiled so that's really good for safety if there's just too much code to move to the library and you can't move all of it then start by just moving out into a library the code that you're going to start by testing and it's worth emphasizing at this point that if you inherited a large amount of code that doesn't have tests you don't want to test everything you want to start by testing the areas of code that you're going to be changing it's too expensive and just too unproductive to disappear into a pit and test everything you'll never never release anything so let's talk quickly about why static libraries if you opted instead for a dynamic library then on windows you would find if you just linked your existing code into a dynamic library a dll you'd get lots of linker errors and then you would start googling about decal spec import dll import decal spec dll export you would investigate how cma makes doing that easier these days but you'd have a whole lot of chasing your tail to fix that kind of code whereas with the static library you don't need to change your source code similarly your release process if you move this is on all platforms you move to dynamic libraries those libraries remain separate from your executable and so you need to include those in your distributions to your users so that's a whole load of extra work to do whereas if it's a static library you don't need to change your release process so if you're starting from no libraries and just a collection of source files and you're moving to using a library start with static libraries because it's a smaller change it's simpler so nothing against dlls and dynamic libraries if you've got those that's great you're in business but if you don't have any start with static libraries for the mechanics of doing that separation it really depends on the build tool that you use if you use cmake then this series of blog posts by arnie mertz a couple of years ago will get you started it's very good introduction so now you've separated out your code that you're testing into a library how do you create the test executable well the first thing is pick a test framework that you're going to be using here's a selection of well-known very good test frameworks for this talk i've included included cute test which is the qt framework acute frameworks test library and it is really powerful for testing cute widgets mainly in this talk i'll talk about though using tests written with catch but also in conjunction with qtest some of the tricks that i talk about for integrating catch with cute testing will be useful as well if you are testing using google test or doc test and so on so there's someone it's not necessarily all specific to catch or catch two so let's compare and contrast the catch-2 framework what your test would look like with that for q test so on the right hand side i've got a trivial example where my test case is testing q strings to upper method and in catch the assertion is on line eight and it says check that string.2 up at qstring.2 upper is equal to hello this is what that would look like in the cute best framework so it's more than twice as many lines well about twice as many if you ignore the comment at the top and a particular thing to say is if you look at the bottom two lines you're having to generate a main in every one of your acute test source files and that comes with a whole load of extra boilerplate code and on line five you see you're having to create a class that inherits cue object and each of your tests is a slot private slot i don't know if it has to be private but a slot inside that queue object implementation and your qt test code will not work if you call qt verify and similar q verify inside non-slot methods so that's a really important thing to understand so on that code i'm not using the benefits of q test i'm only showing you the overheads of it let's move on to another example so here we're testing a couple of numbers so we've got another test case still no main and this is the extra code so again we're having to create another queue object another q test main so details of this don't matter the the point is how expressive the tests are and how simple it is to add new tests but what does that look in practice so i've shown you two trivial source code examples and you would build that using a single cmake lists file and a single main and i'll tell you in a minute how to set up that mate whereas with qt test each of your test files is a separate program so typically you would create a folder structure like this so then you need three cmake files and moreover in c line for example you're running a single program you're building and running a single program so you can run all your tests in one process you can put debug breakpoints in multiple different tests it's really flexible and really convenient whereas because of the structure of acute tests you've got two different programs and two different lots of mock generated output as well if you don't if you don't know what mock is don't worry it's detail and and so i wanted to try and give a flavor of why many people have written articles talking about how to use catch or google test to test cute code rather than cute test because it fits in with many people's idea of convenient development workflows so i said i would explain how to test how to set up your main and at this point i want to say that for acute test framework this is all hidden behind macros you don't need to set that up with catch or with any other runner you would need to to set up this kind of code so we're going to tell catch that we want to get it to generate code that we can call from within our own main so we define catch conflict runner and we include however you spell including the catch header with your your build layout and then a cute gooey widgets you can only create instances of cute application widgets if there is a cue application object in existence so we in our the main of our test program we create a queue application object there and then that exists for the entire lifetime of our tests when they're running i've sometimes seen people try and put create a cue application destroy a cue application in every one of their test cases and that gets gets fragile so it's better to create one in the main and let it live for the lifetime of the test how we can pass in and we should pass in the arguments that our program is run with to the queue application constructor and then it will pick out any of the standard applications like minus platform off screen so that's nice if you're running an ide and then running the test and you want to i don't know be checking your email and not having widgets all pop up all the time then you check the test results at the end and now we need to tell catch to run its tests and this is how you tell catch to create a session and run it and then we return the result so you could use minus minus break to tell cache to break into a debugger if a test fails so it's a bit of boilerplate but you only put it in your main now in order to have some examples to talk through here of slightly more realistic code well significantly more realistic code i've taken a couple of small chunks from this application super collider it's a fantastic platform and development environment for synthesizing music for synthesizing sounds and composing music by algorithm if you've seen sonic pi on the raspberry pi and the joy that brings to kids of all ages then super collider is a significant component of of sonic pi but for reasons i'll explain shortly i'm going to start with a trivially small part of super collider i'm going to start with this little red square in this composite widget custom widget that's somewhere in the the super collider ide and we're going to be testing the behavior of this little color widget is the name of the class this little picker when a user clicks on this red foreground square this probably represents text color maybe the color of an error message or something like that supercollider pops up a color picker dialog the user chooses a new color clicks on ok and then in the application the red square would change to green so what do we want to test well there's two halves on that screen on the left hand side is our custom code this is the code that is maintained in the super collider project and that's what we want to test on the right hand side this is either going to be acute dialogue or in some cases it may be a system dialogue provided by your operating system a it's going to be hard to test it is certainly possible to test dialogues especially in code that you maintain harder for system code it's the cute project's job to to test this it's not ours we want to only test our stuff so we're going to focus on testing what's on the left hand side and and when you start writing tests for code that you don't know initially you start just trying to make sure that you can call the code and run it and so that's what i'm doing here the little black square at the top shows that i'm testing the what turned out to be the initial state of the color widget which turns out to be black so i've got my catch test case i create a color widget object and in this case i'm going to write a really trivial test that says i expect it to be black and opaque and then i'm going to call check which is a catch assertion widget.color equals my expected color when i first wrote this test experimenting with it it failed and it took me a while to work out that i'd written zero zero zero zero so i'd said expect the behavior to be a transparent black rather than an opaque black so even the act of starting writing trivial tests enables you to learn about the code that you're going to be maintaining now if that fails and when it did fail for me initially catch writes out so catch is brilliant about writing out the values that differ on either side of your equality check or inequality or less than providing it's a class that it recognizes but of course catch out of the box doesn't know how to represent a cue color and so it wrote out curly braces question mark so that's what it wrote out so i wrote some code which you can get from the approval test cute library that i'll talk about later on to teach catch how to convert a cue color to a string and so this catch string maker convert technique is something that catch 2 provides to enable you to teach catch to how to represent [music] objects that are not already known to catch and so i made it say that a device and opaque black as zero zero zero comma alpha equals one which is nice and expressive of the values you can use that for generating tests so initially i wrote check that string representation of the color is an empty string then i ran the test i saw catch's console output and i copied and pasted the right answer back into the code lorellin falco and emily bates and others talk about call this approval testing where you run the code and you approve the results by copying and pasting the result back into your test code and from that point on if the behavior changes unintentionally you'll find out and when you're testing legacy code the right answer is always initially the current behavior so that's a really important principle now if we explore changing the state of the widget what's available in the public interface of color widget is the set color method so i'm going to create the widget as before and then call widget.setcolor and then assert that the new color is red and i'm going to i treat that as a safe test to write because i can see in the interface of color widget that set color is the only public way of changing the color of that widget and so i am going to trust that the implementation of the entire application calls via that method and it's sufficient to test at that sort of unit level so at this point some of you may be thinking oh it was quickly testing in the title that wasn't very quick and it's true when you start writing tests going from no test to the first test is always the hardest step that's normal there's so much to learn and to do and almost without fail every time you'll find out in the second the third test becomes much easier so the following on from that make the first test that you write as easy as possible because it's probably going to be hard and then step two is don't give up after step one try writing a few more tests and you'll start to get into your stride and you'll see the value of writing tests now let's look at a slightly more complex component of the super collider ide so if i zoom in on that red box this is how in the super collider development environment somebody can choose make the cursor jump to a particular line so users can type into the spinner and then click the go button and in the so how that's implemented the behavior of that is the user what we're going to test is the user typing a one and then a seven and then clicking on go and this widget doesn't know about the document model within supercollider it's entirely separate from that so when the user clicks go the widget emits a signal 17 a signal a signal called activated with the value 70. and what happens oh for those who don't know acute signal it's a special method for announcing changes within your gui and there's a corresponding thing so signals are private methods that you you can't call basically externally and then slots are special methods that you can call for responding to changes so you connect a signal to a slot and then the q framework takes care of triggering when a widget announces a change it looks everything that's connected to that and calls the corresponding slots corresponding methods so in the real application when that happened the cursor the tiny little cursor there would jump to line 17. we can't practically use that in our tests though to to test that behavior we'd have to make our tests create an entire supercollider application or at the very least we'd have to set up a super collided document and understand its document model which is a whole heap of work but what so the way we would write our test for that instead is to use a feature of q tests duty test libraries tools called q signal spy and as its name suggests it allows us to spy on signals and test various uses of them so we're saying create a q signal spy which is following our data member which is a go to line tool widget and listening out for calls to the the method go to line tool activated so in that previous slide where i talked about signals and things like that that's really implementation details of our panel our go to line panel and my really strong advice to you is to work hard to make your tests hide as much of the implementation detail of the the code that they're testing this is not just about testing widgets it's always across all tests if every one of our tests knows about the finest implementation detail in this case the particular widgets contained within the composite widget the custom widget for testing if we change the implementation we have to update all of our tests so you want to hide the details from the tests you want your test to be readable and expressive and you want to guard against changes to the implementation and this is an example of a way to implement that and as i said earlier this example is very much couched in cute test in acute world but you can think of the widget that we're testing as any chunk of code that you want to write tests for but in order to write the test you'd have to poke under the hood of the thing that you're testing this is nothing specific about this technique for testing so in the middle you can see i've got a class which is highlighted called go to line tool fixture and in this particular case it contains a private meth a private a data member which is private which is an instance of the widget that we're testing go to line two that's there and then the test class test fixture has one or more public methods that are written in terms of the kinds of actions that users will do so any application using this class is never going to want to represent users typing individual characters but we want to write our tests in terms of user actions and so we want our tests to be able to say type of one type of seven if we say set the value to 17 we're possibly bypassing some of the behaviors that might be programmed into the widget when it's responding to individual character clicks i i've shortly got a slide that shows more use of this i think should make it even clearer and then in catch when we're using a fixture class instead of saying test case we say test case method and the first parameter is the name of our fixture class and then the second parameter is our usual expressive useful name of the test that when the test fails the test name conveys to the person checking the build logs or the developer dealing with the failure what the intended behavior was and so what the nature of the error was and the test then says generate an action that types one into the thus the widget and then behind the scenes we haven't for that we haven't need to change our the class that we're testing at all so here's a bit more about what the fixture would look like and i think it's worth saying at this point that fixture in tests it means lots of different things lots of different people but i think broadly lots of different frameworks broadly it means a collection of code that you can reuse between tests if you're using a test framework that doesn't support fixtures you still you can create your own class that provides exactly this kind of functionality you might use it in a slightly different way but the technique is far more general than something specific to catch for example so i already mentioned that we had a go to line tool widget instance and now it becomes a little bit harder to manage the lifetime of our cue signal spice that's why that's a unique pointer and it's got other details like it's peaked inside the tool that we're testing to get pointers to the widgets the q spin box and the q tool button but they're private they're hidden so it's only this one place in your test code that knows about the innards of what you're testing and now we have the really nice feature that the fixtures constructor it's set up the widget but then anything that any boilerplate code you need to do like raise the widget show it set focus anything like that you hide away in your fixture class and without this fixture all of these lines setting up the spy doing the raise the show all of that stuff would be in each of your tests test cases or you have to write a function that you have to remember to call in each of your test cases but by doing it like this that's taken care of automatically so it's really powerful and of course all of that stuff is private the data is private it doesn't in order to write this and to go for much more verbose code and then hide the details into a fixture i started off with it public the data public and then i work towards making it private over a series of steps in catch fixtures are implemented using are used using inheritance so the test case method that i described earlier that creates a hidden clause it generates a class with some cryptic name that you don't need to worry about that inherits the fixture class so you can call any public and protected methods inside your test case so that's a really powerful way of sharing code between tests for minimal effort so here might be that test case that i described earlier the user steps written out in full so we've got our test case method now this widget needs to know how many lines there are in the document that it's representing the jumping of cursor in and we as i said we don't want to set up a document to to set that up so we say well let's pretend it's a document with 27 lines type of one type of seven click the go button and then q signal spy is actually really quite complicated to call you've got a lot of argument checking to do that also is all hidden away and i say check that my signal was only emitted once and check that that emission contain the value 70. so that's really expressive it's the intent is really clear and you might think that an actual natural next test to write might be what happens if the user clicks types 37 so if the requested line is outside the the line count limit what happens then is nothing emitted that kind of thing so you can start to explore the kinds of behaviors and corner cases that are important to test testing the number of times a signal is emitted is also worth doing i've seen errors where a connection gets lost or a loop gets created and a connection a signal may get emitted multiple times and that can be inefficient or can actually break the program so those are the kinds of things that's worth testing with cute code that code that i just talked you through is version three the third of a set of examples and so the first example the setup code example code in the setup is like five slides of code or something like that and then the assertion is one or two lines of code and i evolved that code through a second and then a third iteration at my talk cppcon this summer and i feel that you can i think it was important to in this talk to express the overall benefits of the fixture classes and that style of testing if it didn't make sense and you want to see more of the rationale behind it then there is a a more detailed a longer explanation in that talk but i hope i've done it justice in this one anyway to encourage you to look further now bonus points i talked about earlier talked earlier about separating the implementation details of the ui code out from the program itself i've worked in scientific software scientificate applications for many years and it's really easy for people to be so focused on the behavior that they want to implement in the gui that they start writing the logic the algorithms the data storage inside the widget code and once you've done that it can be really quite hard to separate the logic out but it's really worthwhile doing it and so for bonus points you would separate out any non-gui code or as much non-gui code as possible into a separate lower level library which is your model your business logic and so on and then your user interface library calls code in the model library for its implementation for its behavior and of course the gui executable that also may use model code directly or indirectly via the user interface library and then you write a separate test program in here called model tests for example and that has its own main and a different set of tests and the general rule is you want more tests for lower level code so you would test as much of the logic in the model tests and then the ui tests become much thinner and they're only testing the behavior of the widgets and not the details of what they do now i'm going to talk briefly about error-prone things with cute if by any chance you're working on code that was written in cute four days or earlier you might have signals and slots connected like this that's very error prone it's easy for the connection to be wrong and you only find out at runtime or when you get a bug report from the user if you're working on code like this i definitely recommend trying to switch to q5 style pointer to member function connections so here instead of the signal and slot macros we are saying when q push buttons method signal clicked is emitted then call the quit method inside sample main window there's lots and lots of reasons why this is a better and safer thing to do but in terms of safety and testing it's a complete no-brainer the klazy tool c-l-a-z-y or z-y has a way to make that updating automatically if you need to do it for lots of code event processing is another thing to be aware of in acute application the program's main event loop will be focusing we'll be processing events via qcor application process events and you can't rely on that in test programs so i'm not going to go into the details here but basically know your options know these things exist in the queue test framework if your test runner is q test you can also use those macro if i'd versions as well any if your test runner is not cute test avoid like the plague any macros provided by the q test framework so using cue signal spy and things like that that's all fine but their macros are not designed to work in non-um qt test driven programs the the nature of the error is your tests will silently pass even if the code is completely broken the first failing assertion it will silently return from your test function and you will never know so it's a really important caveat i'm not going to go into the details of this but when i gave a similar talk to this at meeting c plus plus in germany last year fabian from the cute company i described this problem to to fabian and he gave me some example code that showed how to redefine cue compare and make it a generator a compile time a compilation error if you call these macros outside of where they're meant to be used which is fantastically powerful and i would love to see that incorporated into the main q code once you've written these tests you want to be running them in a continuous integration system and the summary of this slide is make sure that your ci system has a gui environment so that your gui tests your widget test can run and windows will probably just work on linux you'll need to set up a virtual display xvf is commonly used and there's lots of information about that online and on mac you probably need to have a user logged in so that there's a display you may find that if you if the display mechanism breaks then your tests fail with some traceback and saying it can't create a widget in which case look at setting up a mechanism so that tests that require an environment have a graceful way at the start of them to say if i've got no gooey environment then return so that you get a message and you can fix the gui the display environment on the ci system and the rest of your test your non-googie test can go on and run gracefully now i'm going to talk briefly about approval tests and qt so if you haven't heard of approval tests before it's a way of testing code that it saves a it saves the current state it saves a snapshot of of behavior of an object a string a class as a file as a text file and so rather than your well you don't write tests that say check expected comma actual you say here's an object verify its state and then approval tests gracefully conveniently powerfully creates a text representation of that and that becomes the right answer in your test so it's great for large and complicated things with lots of state really powerful it's really powerful that it stores its expected information separate from the source code it keeps your source code simpler and more maintainable and the the outputs are much easier to deal with when they're separate files you have an xml file stored as an xml file rather than embedded as a string inside a c plus plus source file it's really powerful convenient and a quick tactic for testing legacy code but it doesn't know about cute this summer i gave a talk generally about the approval tests for c plus plus library and testing legacy code with that so there's a lot more information there if you're interested or ask me afterwards at this point i just want to mention that i have released a very small library called approval tests for cute and this is this little bit of the talk now is about awareness it's letting you know it exists so it's it is released containing a copy of approval tests for c plus plus and catch two and you need to provide your own build of the q5 test framework and q5 widgets and it has two goals it's my first goal was to hide all of that boilerplate main function that i showed you earlier so that if you want to use in this case catch to test you code you can do that even if you're not interested in approval tests and i also wanted to start adding approval test support for cute types so those are the links and as you can see it's a very ver very early version so on the left hand side with those two lines hash define approvals catch cute and then hash include approval test qt http it's released as a single header that generates the equivalent code to the code i showed you on the right hand side that's it that's all you need to do let's imagine that you've inherited some chemistry application that has got a table that shows you details about a series of atoms in a molecule in a crystal structure and the code for calculating those values is embedded inside the widget code and you want to separate that code out so you can reuse it in other code and you want to write a first test of the text generating code before you make a change this is what in that situation the code would look like using the approval test for acute framework so you have to you create a widget that is your table and then you call your population code to populate the sales however you would normally do it and in tests when you're calling existing code however complicated the code is to call you want to hide that away inside easy to call methods and then recall approval test qt verify cue table view so even though i'm passing in a table widget it would work with any table view and q table view implementation so you see there's no ex actual this is what the right answer is when that code is run it writes out a tab separated file and that file is automatic given a sensible name automatically based on the location of the test source code and the the name of the test that you're running and the test first time round would fail because it doesn't know what the right answer is and you use a differencing tool and this is all set up automatically with an approval test you use the differencing tool to copy the initial output file over to the the golden output the approved file and then this is your test expected test result this file forevermore i'm going to talk briefly about testing using screenshots and we do provide in this library the ability to take and save the image of a widget and use that for testing in general though it's never recommended to start your testing based on screenshots they're fragile they're large in the version control system always try and test the behavior as much as possible of your gui code and not the appearance but if you do need to do testing of appearance then there is a an implementation of approval tests for acute available so what's next as i said it's very early very early for this library so the number one priority is to guard against people accidentally using those cute macros that i mentioned and having incorrectly silently passing tests but mainly i would like feedback on it is there any interest in it are there any extra types cue widget types cue object types that you might like approval test support for and i'd like to add some more real world examples to the documentation so briefly now in summary the first thing here i want to say is it won't always feel like it but it truly is never too late to start testing however complicated the code is it's always possible to start testing and it's always worthwhile when you start writing tests and always in general try to test smaller units of code such as individual widgets individual components and test behaviors not appearance and as i said earlier keep your application logic separate from the gui code make your tests easy to write and therefore easy to read hide the details of custom widgets behind helper functions in tests and even better make your tests expressive and reachable with fixtures and lastly feedback on approval tests for cute it's very gratefully received that is how you quickly and effectively test desktop applications thank you very much now the references all the links and more including a link to another library that provides a nicer implementation of approval testing images and links to my other talks and how to get in touch with me if you want help with this or if you want consulting help thanks very much indeed