[music] [music] low level gang what is up welcome back obviously arm processors can't float in that sense they do not physically float but arm processors in the mathematical sense and the computer science sense can float arm processors after the cortex m4 have a floating point unit in them or an fpu a specific part of the processor whose entire purpose is to do floating point math operations you can tell if your computer has one by checking out the tool chain to build for that arm processor if it has an hf in the compiler build chain in this third word here that means that it has a hardware float unit or an fpu that is able to support doing vector operations as an entirely separate instruction set on the arm cortex processor so what i've mocked up here in c is a harness to call a function calc flow that we're going to write in assembly calc float will return a float value we'll call that x here and we're going to print out that float to prove that we've done some kind of math on the processor right so just to kind of walk this through pound includes standard diode h to get lib c linked in we're going to declare our calc float function but not actually define it so we don't set the compiler and then we have you know our int main prologue here and then we have our function and we're going to print out the return value of that function so now we have our float.s our assembly code will go into here and then finally once we're done with this we're going to build our program with this tool chain we're going to output the program name float and we're going to bring in float.s which is this assembly here and our main.c to make sure kimu can actually run our program you want to use tax static to statically compile that final binary so that kimu can actually use it so now what do we do so main.c is going to be c code that gets compiled this tool chain by default is going to produce thumb code so first off we need to make our code thumb to make sure that we don't have any issues with the code breaking next we're going to write a function called calc bloat right because that is a function expected by this c function here we have to define this symbol so to define a symbol we want to be linkable we have to export it into export assemble and assembly we say global calc float we're also going to say that this is a function and we're going to call the function calc float so that the prologue for the function gets set up properly in the assembler and then finally we need to make sure that the linker knows this is a thumb function so we'll say dot thumbfunc and then here we can do a quick little test to make sure that our code actually compiles builds and doesn't crash by saying branch exchange lr this is the arm version of return so if we get this to work this just means that we have returned successfully from this function and gotten to the next line so let's build it real quick and run it okay cool so our code runs no crashes we do return some garbage monster gigantic value but that's okay that's expected we didn't actually do any math here so it makes sense that nothing useful happened so in our program here i'm gonna show you guys how to do floating point math on the emulated fpu that we use in kimu what we're gonna do that math on is two separate floating point values value one and value two value one is going to be a float so we'll say dot float to set that up in the assembler we'll make it 420 and then dot float here we'll make it .69 these numbers are completely random do not read into these at all i just came up with these no special reason okay so now we need to actually use the instructions special instructions in the fpu to make the floating point math happen our first instruction we're going to run is not sexy at all we're going to do a basic load register r0 equal to val1 all this is going to do is load the address of val 1 into r0 next instruction will be our first special floating point instruction the instruction is b l d r this is vector load registers anything with a v in front of it is considered a vector instruction and those are the instructions that are happening in the fpu floats are referred to as vectors and some mathematical implementations so vector operations are floating point operations so vector ltr s0 and we're going to use this here so what this does is this tells the floating point unit load into s0 which is the single point accuracy register zero there are single point and double point and you could you know infer that the double point would be d0 but we're going to do s0 for right now load into s0 the single floating point register the address pointed to by r0 this is going to load 420 into this register on the fpu and now we need to do this again for our second value value 2 and to do that we can just copy this code here and change out s0 to s1 and value 1 to value 2. pretty straightforward so by the time this code has ram you've gotten to line 12 the fpu has two registers loaded with addresses and values that we care about that we're going to do math with so now we can run a math operation in the fpu using an fpu math operation to do this floating point math right so what we're going to do is we're going to run the instruction to do the math we can do v mul so vector multiply dot this is a conditional operator onto the vector multiply operation we're going to say do f 32 so you have two options when doing floating point math in these processors if you have double point accuracy you can decide to do single or double point accuracy on the processor to do single point you do f32 for 32-bit float or if you wanted to do double point accuracy you could do f64 we're not going to worry about that right now we'll do f32 and then after that we encode it like a standard arm instruction we'll say the destination is s2 and we're going to multiply s0 by s1 cool so once this instruction has ran the s2 register will contain the output of s0 times s1 awesome and then so again remember this is a function the function needs to return a float when a function returns a float in the arm calling convention it expects the register s0 to contain the response so how do we get it set up properly well at this point the response is contained in s2 we need to change that so normally we would do a move operation we're in the fpu so what instruction do you think we're going to do we're going to do vector move and we're going to move into s0 the value s2 so this is going to move the result into s0 and then return this is our final code here so again we'll compile it real quick gcc there's one error there we'll hit this enter key to make the assembler happy cool no errors and we'll run it and there's our answer let's check python to see if we're right 420 times 0.69 close enough low level gang i hope you learned something there i hope you enjoyed that video if you did do me a favor hit like hit subscribe leave a comment with what you want to see next and i'll see you in the next low level video take care [music]