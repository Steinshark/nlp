welcome and thanks for welcoming me and we're going to talk about product strategy and design strategy reasons why projects and products fail from a design point of view because we want to know how it affects our design and the strategy that goes hand in hand with design what i'm going to try to do for the next hour is to be roughly half and half talk and then q a so we hope to leave a good amount of time near the end for q a in remo but first let's talk about how to answer the question when you're starting a new project you have a new idea for a product or you're being asked to adopt somebody else's product or fund somebody else's project how to ask and answer the question well why is your thing going to succeed but you know i've seen a few things that look a lot like it and they haven't succeeded in the market what makes yours different that's the question that we're going to focus on answering because overcoming that history is and differentiating yourself not just in speaking to others but to know internally why am i strategizing and designing for success is important as we think about what our product is going to do now we're not going to talk about many of the reasons projects fail we're not going to talk about there wasn't enough funding either that the team was inadequate or the wrong kind of people that product quality was low the rollout advertising didn't happen and those kinds of things because those don't aren't directly intertwined with the design and strategy of a product's design and usually these ones are fairly obvious things that you see in a post-mortem well why didn't it succeed okay one of these things what we're going to focus on instead is what are the strategy differentiators that affect design and it's primarily going to be talking about compatibility but we'll see also how the value proposition and availability feed into compatibility and how these things are related but we're going to spend most of our time on number three so let me first define what a new thing is so the title of this talk is bridge to new thingia and yes that's a riff off bridge to terabithia because we're going to see there's a bridge involved that's we're going to talk about compatibility but what is new thingia what is the the place that we want to get people to i'm going to define a new thing as one of two things it can be a brand new competing product many of our examples will be from programming languages and there we see things like d go swift rust other new programming languages and those are easy to see are there a new thing because they have their own name but a new thing can also be the next major version of an existing product and think about it if you have an established product in the marketplace your biggest competition usually if you're the leader is your previous version and sometimes you have to do convincing and to be persuasive to get customers to upgrade from that to make sure they have a reason to so every major release of the c standard its major competitor is not some other language named language right now it is the previous version in the field of the standard a good example of why this this really matters is if you look at visual basic six it was a very very popular system had many strengths and some flaws but if you go to wikipedia today you will find two articles to this day about visual basic why because after visual basic six the visual basic name continued to be associated with a product that was incompatible and that was actually different to the point where they still have the same name but they're very different products witness they have their own wikipedia pages even though the product has the same name a new thing doesn't depend only on the name so it can be version next of the same brand product so let's first talk about the value the first question we have to answer is why should somebody be interested in the product that i'm designing there's been a lot written about that and it's all about the value proposition and the elevator pitch so let's just make one or two points about the key things in the value proposition if i'm going to be able to have that elevator pitch where i get in the proverbial elevator with the executive and i have about 30 seconds in that elevator ride to explain to my executive what's so exciting about my product how am i going to do that the easiest the simplest way is by saying hey you know this thing you already have we're going to solve this known pain point or these known pain points with that now as soon as you do that you haven't had to explain your product from scratch you've directly connected it to an existing well-known thing and you've by anchoring it you don't have to explain the the common fundamentals the general problem to be solved and you've also related your thing and oriented to an existing thing and you've been able to clearly say and we're going to solve these known pain points if you pick real pain points you won't have to explain them that's how you give a 30 second elevator pitch you refer to something the person already knows well an old thing that they know and product in the field you refer to pain points they probably already know well so you don't have to explain them either you just have to name them and you say i'm going to solve that problem that's how you give a 30-second pitch without talking a mile a minute and you're showing how i'm going to build a bridge across this chasm in this place to bring you to this shining hassle on the hill so for javascript it was well known that javascript is a very useful language and a foundational language to our modern web it is also well known to be very bloated intricate have lots of corner cases and if you just look at the books javascript the definitive guide javascript the good parts here is a well-known pain point with javascript complexity the learning curve the amount of stuff you need to know and more than one language has come along to try to solve that problem so both dart and typescript have come along and said you know what javascript you know it well it's great we want to solve this problem the pain point of the language's size and complexity and usability and that helped them to very easily in 30 seconds in fact we just did it in 10 seconds explain why these languages now these two examples were not equally successful we'll come to that in a moment but javascript is not alone here you may know of other languages that also have a good parts version where you can point to the same pain point and say you know this existing useful language the same opportunity exists here to solve the problem this pain point here of complexity so once we've articulated the value the proposition that 30 second elevator pitch which we can do best by saying you know this old thing we're going to solve these known pain points now you've got people interested how can they start kicking the tires by making it available if you tell people about this great idea and they say great where can i download something to try it out and you say we'll have that in about a year you're not going to get very far or it's not available on your platform yet so we want to design for having our new thing be available and the requirement is basically we want either initially or in the medium term there is no design obstacle for our new thing to be available on every platform and every place where old thing exists that means any user of old thing can try out new thing and start using it in their projects it works on my platform and i have to at least be able to add it in the same place where i have an old thing project in order to be able to try it out and compare so here are some examples from programming languages c came along at a time when every major system every major hardware system had its own programming language for systems programming there was no such thing as a portable language that gave you high performance c was the first to come along and try to solve that problem and we can argue about did it just work on all pdp-like architectures and then everything became pdp-like nevertheless c did something that a lot of people told dennis ritchie could not be done and that is create a single language that could give you portable performance where you write the same source code and you could translate that to an efficient binary on multiple machines different of different architectures he did that and that affected the design but notice how it ties in with availability that means regardless of what kind of major computer i was using i could get a c compiler and i could try it out because it supported a range of different hardware it didn't support just one particular hardware from one vendor see front see python still one of the main python translators and typescript all followed a very similar model for availability c front compiled c plus us to c which means it worked anywhere if c compiler existed that means as c was the old thing and now c plus plus was the new thing seeking to get interest well if if you like the ideas of c plus and you say where can i try it out well if you're already using a c compiler you can try c plus the reason is is c front itself was written in c plus plus but it translated programs down to c so that you could take any c plus program run it through c front and then through the c compiler you already had and be able to try it out get an executable but if you were on a system that c plus itself wasn't available on yet c front itself was written in c plus plus could be compiled down to c and you could take that and compile that with your c compiler and bootstrap your way to a c plus environment to this day c python is written in c it's available anywhere where c is every typescript program compiles to javascript it's available anywhere javascript is so in each case new thing is available in all the places old thing is and that enables people who are interested in your value proposition makes it available to them to try it out kick the tires now swift and roslin are two examples that didn't do it at a language and a compiler level so much they did it sort of kind of at the ieee level so swift was available out of the gate to every xcode developer on every platform xcode supported for objective c and now it actually supports more platforms than objective c but it was available if you were an objective-c developer and you liked what apple told you about this cool new swift language you just had to have the latest xcode which you were already using for objective c and swift would work on your platform so you could try it out roslyn which was the rebuilding of the net compiler so that you could do things like static reflection and a great tool-ability story these that's a great value proposition how do i try it out it was available on every vid to every visual studio developer on every platform visual studio and visual c sharp the compiler it replaced supported and you could still have your own visual c-sharp compiler to compile to native code to compile to.net assemblies and use roslyn for your ide but roswell could be there it was available i want to emphasize all of these were by design these were not accidents they affected product strategy they created constraints in how you built these things roslyn had huge compatibility constraints from the very beginning of the project and that slows down development it means you are doing more work it's not free you are paying for it in design trade-offs in overheads for quality and in this case compatibility gates but because of that roslyn made itself available but it wasn't an afterthought it was by design in all of these cases both value and availability are related to compatibility so let's spend the rest of our time talking about the compatibility bridge because this is how you then after they pick the tires you bring people to be able to adopt at scale your new thing and this is a key thing and a key place where people get it wrong and it doesn't mean they won't succeed but as we'll see it means it will cost them a decade and that's an empirical observation let's see examples when you're delivering a new thing or you're adopting it you're going to be able to put forth some effort and then see some value what do you want that adoption function to look like do you want to have to put forth on the left option a lots of effort before you start seeing value and then maybe you see a lot of value all at once but it took a lot of effort where you didn't actually see anything and that you had to put in up front before you saw any value do you want a or do you want b where you can put in a little effort and start to see some value put in a little more effort see more value that ramp b is the model that is going to make products succeed where others have failed and the basic requirement for that is high fidelity interoperation with old thing the very minimum bar is for it to be in the one direction where any new thing in this case in a case of a programming language any new thing code can seamlessly use old thing code written in the new language can seamlessly invoke code written in the old language now a good story is if i have an old language project that i can put in the new language in that project and use it side by side say in separate source files so i can add a to a c plus proj or c project i can add a dot cp file and start seeing some benefit the holy grail though is to be able to say i can start using the new language in just one place and just one line of code maybe even in old language file and start to see benefit and in case that sounds like too much of a holy grail it's been done repeatedly that's what c plus plus did for c you could largely still to this day largely take any dot c file and compile that c plus plus and you can add one class and start seeing benefit the rest of your your code compiled you can still call it from your c plus plus oh but now look i have an encapsulated class with private data i've seen some benefit by just writing a line or two of code the same thing is what typescript did for javascript every typescript program is a javascript program and you can by design rename any javascript file to typescript add one class and start seeing benefit that gives you the smooth adoption function and again it's by design because for that to be possible placed a great burden and a great restriction on the designers of c plus and typescript c plus to this day carries the baggage at the weight of the c compatibility that makes that story true but we wouldn't be talking about it today if it hadn't done that very likely similarly typescript took off as fast as it has in large part because of that compatibility with javascript that was a great con a very great constraint andres hausberg could have designed another scripting language equally technically good as typescript and even better in many ways if there wasn't the javascript compatibility restriction but it also would have been adopted far more slowly and been in because it would have been an incompatibility story rather than a compatibility story so ramps are great they're not just for old folks industrial strength use of ramps exists because it makes our lives easier to get things from point a to point b now we talked about c process and typescript this compatibility by design because every c program is a c plus program largely true and c s code from the beginning has seamlessly been able to invoke the c optimizer and linker they didn't have to rebuild their entire tool chain the armor by creating seafront leveraged the heck out of all the existing infrastructure that was already built into c instead of competing with it by being compatible he enabled us to reuse it same thing is true with typescript but now when we talk about swift and roslyn i just want to point out how important this is and how it affects design in a different way because swift and rosin are a bit different from what typescript and c-plus plus did with swift there's a bi-directional high-fidelity interop where objective c can call swift and swift can call objective c and that is because two basic things are true there's others but the two primary design constraints are swift uses essentially the objective c object model and it uses objective c lifetime model which is reference counting including arc the automatic reference counting model in objective c it also uses modules the same modules in swift and objective c this was not an accident in fact when ark first shipped an objective c before swift was announced it was already designed with swift in mind objective c modules were designed with swift in mind before anybody outside apple knew what swift was going to be so you could see apple already building that adoption ramp even before announcing new thing because they had control of old thing and were able to make old thing meet it you have less control when you're building a new thing externally entirely externally from old thing but in both cases it affects design swift could have been in many ways a better language for many things if it didn't have this backward compatibility constraint it also wouldn't have been as interesting or as used similarly roslyn as i mentioned had strict backward compatibility tests baked in from the very beginning and had to be adhered to rigorously from the beginning of the rosalind project up to be able to replace the c-sharp compiler that it was replacing and that was a compatibility constraint that added cost it added time to the project and it constrained the design but it also enabled roslyn to be transformational and adopted way faster than it could possibly have been if it hadn't incurred those costs it's a design strategy and a strategy for design that create a tax but it's a cost that we get a specific benefit for it it's conscious and it has to be from the beginning of the project it is very hard to retrofit if you hadn't designed rosalind to be a c-sharp drop-in replacement a compiler replacement from the beginning with compatibility tests if you hadn't designed swift to be an objective-c compatible replacement with the same object model and reference counting infrastructure of lifetime modules from the beginning and accepted those constraints and lived within them you wouldn't have been successful and you wouldn't have been able to backfill later we talked about a bit about typescript you might have mentioned remember we also mentioned dart dart also had the same value prop as typescript which is look how complex javascript is compared to javascript the good parts we're going to solve that problem so dart and typescript had very similar value basic value propositions we don't hear very much about dart today and its adoption was greatly slowed for several reasons but one major one was the lack of compatibility dart was not javascript compatible it had very minimal ability to call javascript to this day there are open here's a screenshot from github there are open issues for javascript to try to improve interop and notice that the words they use in those two paragraphs at the bottom of the screen are very similar to trying to get the value propositions that typescript had for javascript that c plus had for c that swift had for objective c but those three were successful because they had it from the beginning to design to guide and constrain their design as a stake in the ground up front it is very hard to go back later the reason is is because if you don't have a compatibility story up front you end up on a wrapping strategy those are the two major paths and there are flavors but you can either call the existing thing directly or you can't in which case you end up wrapping things until and you have an impedance mismatch on the boundary and that boundary can look different in different as you're bridging different gaps different things different new language old language combinations but it's basically a wrapping strategy you got to wrap it to be able to use it c plus a cli python three sequences winrt they all fall into this category the same thing with d and its compatibility for calling c plus plus types it's a wrapping story and that's the story the the plan that dart is on you can't switch back you can't go back in time and change your design to be object model compatible and bring compatibility back it has to be part of the initial design which means to backfill it basically means to start over it would require basically a reset here's an example from python and this can help us start to quantify what the cost is of compatibility so python 3 took a source breaking change in 2008. you cannot compile python 2 code as python 3. yes there are quite a few migration tools that really help make that transition but something as basic as what is the the type of 3 over 2 and what is the value of 3 over 2 has a different answer in python 2 than it does in python 3. there are other examples but i find that one to be a useful basic example of oh yeah well if i can't compile 3 over 2 and know what the answer is i'm in an incompatible language even if it's still called python it might as well be called abracadabra because it is an incompatible different language well what happened well nine years later as of 2017 most python code was still written in the intersection of python 2 and python 3 which may sound good until you realize wait a minute that means they aren't using any python 3 new features inherently now they got over it and that changed as of this year as of about 11 months ago python 2.x was frozen it is unsupported but at that time about 10 of python in the world was still written in python 2. think about what that means using an end-of-life product that is no longer supported even for if i remember correctly for security fixes so 90 adoption is great but even so to have 10 as of a year ago of your user base still in that unsupported old thing is a problem and it shows that this took a decade in this case 12 years to get to 90 plus percent adoption now compare that to the previous cadence previously for pythons one two and three those were released eight years apart so it's not just that it took eight years to adopt each one each one was adopted enough to freely be able to go to the next major release within an eight-year period 12 years after python 3 we're still talking about just finishing absorbing python 3. we're not talking about shipping python 4 yet now it's not just python even other languages like c went through this problem so in the late 1990s the c committee was very small it was dominated by a few special interest people who because the committee was small were able to get their way and add features that it turns out the larger community wasn't all that interested in including compiler vendors for c so there were several features in c99 that were standardized but were not widely supported in compilers for quite a few years in fact we mentioned c python which compiles 2c python 2c it itself as a c program is only allowed to use a very small number of c99 features as they're proven to be widely available in compilers that's today 20 years later that is still true so what happened at the halfway point between now and when c99 shipped the c11 standard came along so here they are 12 years later they added a new thing they added the idea of a conditional or optional feature and they applied that not to just some new c11 features but also retroactively to c99 complex and variable length arguments a variable variable sorry variable length arrays because those were controversial features that people were not implementing widely so they went back and made it optional it is easier to write a conforming c11 compiler than a conforming c99 compiler because you can just say macro defined no i don't support that feature and you're done with the optional features this even happened a little bit with c plus plus because c plus source is very backward compatible but every so often we took a breaking change and we did that with stood string in 2008 we adopted a change which shipped in 2000 the 2011 standard to say no you know stood string cannot be reference counted but this isn't some some corner case this is the standard string type we said oh you know it can't be reference counted and people agree to that understanding it would be an abi breaking change on some platforms but that didn't mean you could ship it right away it wasn't until 2015 that there were in gcc there was a conforming stood string being shipped by default then it was gradually adopted platform by platform and it wasn't until last year that one major platform red hat enterprise linux first turned on the new conforming string by default did you notice how many years that was interesting how that number keeps coming up this is what a decade looks like if you put the calendars for 10 years and 12 months side by side c99 it took about 12 years to fix the incompatibility mistake of the vlas and complex 10 years after they shipped 12 years after they shipped the c standard walked them back to be oh you know we weren't actually that serious about them they're optional c s 11 string stayed in the standard with its abi breaking change but it took about 11 years to reach some popular platforms python 3 from the time it was released so the time it received got to 90 plus percent penetration was about 12 years if you don't build a strong backward compatibility bridge meaning that new thing can seamlessly call old things doesn't mean you won't succeed you may still succeed but it's going to take you a decade longer absent other forces because there are other mistakes we could make or other things that we can do to force people to move even if they're not ready if we control a platform for example but generally experience has shown it's going to cost adoption a decade now like i said you might succeed anyway but not only does this extra decade slow down your adoption it also increases your risk because it means you have to keep surviving and getting some adoption and some traction for a longer period of time before you get to the hockey stick and you have to have a longer time you have to survive that adds risk to a project because your project needs to survive that long to survive at all so when we talk about incompatibility it's like taking a sharp turn every time you take a sharp turn some people fall off and occasionally you stop making progress entirely if too many people fall off or if the truck runs over turns over so let's talk about two pitfalls in conclusion two specific things that create a form of incompatibility that create that step function for adoption one is heavy annotation and heavy can be surprisingly low so if you ever had a product or tried to design a product and convince people to adopt it that said oh but you have to annotate your code how much ah one every 10 lines excuse me no thank you oh just one every 100 lines that's still way too much what does that mean for my million line of code project so even one line change per thousand lines of code is often viewed as a heavy number now if in addition the one of the ways that you can get this annotation requirement is when annotation has to be viral so i can't just annotate one place i have to annotate others so say i have a safe c dialect where i can annotate a function is safe wonderful but what if the rule is i can only call other safe functions from inside my safe function well then anything i call has to be annotated well anything it calls has to be annotated for it to be annotated safe so in that kind of case if you have like a red function like i say function can only call other red functions you need to do a bottom up annotation of your call trees that's going to hurt your adoption that's not compatible that creates that adoption step functions because it requires a lot of work before you can start using it and seeing benefit but you can also get viral upward so java found this out with checked exceptions if you have to say in java oh i can only call a red function from other red functions i can only call a function that throws x and y from a function that also advertises it throws an x and a y then i have to upward annotate the call path in order to call this function i have to annotate the caller function in java people voted with their feet and largely just turned off the feature by saying oh yeah throws exception i just throw the base class of all exceptions so i'm just basically not going to use the checked exceptions feature some people do use it not saying it's not used i'm saying that most people voted with their feet and just turned off the feature because they could we see the same in safe c dialects so both cyclone and c cured had this annotation problem c cured lasted long enough to have a follow-up paper type safe retrofitting of legacy code in 2005 where one of the things it would do is infer the annotations and newer efforts such as check c from five years ago david tardini up front is doing that value proposition thing we talked about at the beginning it's saying how are it's answering the question how are you different from cyclone and secured that have failed because check c sounds a lot like them ah because we are going to bring you across this bridge we're going to solve this pain point we're going to have backward compatibility and no annotation requirement incremental conversion so tardi answered the question how am i going to be different why might i succeed when cyclone and security failed by saying the value proposition i'm going to solve the safety problem but without viral annotation i'm going to solve the pitfall with these other two of that viral annotation and other incompatibility and i'm going to have a strong compatibility bridge where i can incrementally convert to c code base i can make a small change and start seeing benefit that doesn't mean that check c will succeed but it shows that they're doing it right they're applying the principles of this talk to answer the question why should you succeed when these others that look a lot like you failed ah here's what's different value availability but especially compatibility the second and last pitfall is false friends remember three over two has different answers in python two and three that means you have to start making hard choices you either don't allow them in the same source file which is what python did or you allow them in the same source file but then you have to have regions of code well i'm going to say pragma version 2 region or a pragma version 3 region that makes things harder for programmers because they still can't reason about this piece of code in the source file just looking at it without looking around to see what mode am i in and it creates similar problems for refactoring tools and other automation if the same code can mean different things especially inside the same source file that's what we call a false friend looks familiar but means something different so then how do we answer the question why will your new thing succeed when these others that look a lot like it have failed and once we take aside the usual answers of funding of the team of marketing and we look at what are the design and strategy reasons they come down to these three things the value proposition should clearly articulate how it's going to solve a known pain point with old thing and if it's a real pain point it will need very little explanation it needs to be available where old thing is used so people can start we're interested can start trying it and that affects design it has to be designed for from the start just like the seafront compiler architecture was and finally compatibility seamless backward interoperability with the old thing dart and others and d and even rust show that this is very hard to back into later it has to be an explicit design goal from the start if you don't do this from the start you may still succeed doesn't mean you'll fail but it will take you 10 years longer to get the adoption than you could have had at least you want to have the good story of i can use old thing side by side in a new thing project like a new dot cpp file in a dot c project the holy grail is i can write one line of code if it's a programming language and start to see benefit i can write one line of c source code in this c file by renaming its dot cpp and writing one line of code and start to see benefit sometimes i'm asked well what will the successor of c plus plus b will there be a successor to c plus s 20. some new language there's lots of lots of work being done in new languages d and rust are common examples but not the only ones and first of all language innovation is a good thing all of these languages are doing really interesting work that i think benefits the world regardless of whether they succeed broadly or not and can inform the work being done in adjacent languages like c plus plus and others but if languages like those haven't yet displaced c plus in the marketplace what's the difference well there is actually one language that has successfully displaced c plus in the marketplace but it's always c plus us next because remember the next release of a major product has as its primary competitor the previous release already in the field so we're shipping c plus 20 right now its primary competitor in the field is c plus 17. c plus 17's primary competitor with c plus 14 and each of those has displaced or we hope in with 20 will displace the previous primarily because it's solving problems it's available where the c-plus was previous was and it's got seamless backward compatibility if a new language wants to have a similar uptake it should have the same compatibility bridge and have seamless interoperability with c plus by design if it doesn't have that it doesn't mean it will fail but it will take a decade longer that's what it what it takes in the empirical observation of what languages have done that have gone before now there are sure are costs you have to know the sequester's object model model you have to be able to somehow inhale header files or do something to be able to seamlessly call functions that are written in cpus not just c but if you don't have that you have to be on a wrapping plan on a dart plan not a typescript plan so when we think about that shining city on the hill we give that value proposition of i'm going to solve these problems for you that's the elevator pitch i'm going to solve these pain points we then make it available all the places old thing is used and we give a compatibility bridge to new thing and if we can do that successfully where a new thing can seamlessly be used side by side with and call old thing or better then we have a good answer to why will your new thing succeed when others that superficially look a lot like it have failed because we've designed for the compatibility bridge to be able to make old thing a new thing work together and bring people to the new thing world