i'm currently reading domain driven design by eric evans it's quite interesting i might actually do more content about it now this is not a very new book it's from 2004 but it did make me realize something about what software development is going to look like in the future and that kind of took me by surprise so i'd like to share that with you today and i'm also curious to hear your thoughts about this now this is not going to be a coding video no code examples no complicated things wr in python so if you're looking for that you're dismissed if you do want to learn more about strategies like domain driven design or other ways to improve your python projects make sure you subscribe to my free newsletter by going to iron codes.com now before i talk about our future i first want to talk about what domain driven design actually is and the core of domain driven design is the domain model now what is a domain model it's basically a conceptual representation of a domain that captures both dat data and behavior a domain can be anything right if you're writing let's say hr software your domain is going to have employees and contracts and salaries and other things that you need in an hr system if your domain is electric vehicles then you're going to have things like batteries and charging stations and seats that make farting sounds sorry so obviously depending on the domain and what your customers want the software is going to be completely different now if you follow the very traditional waterfall style of development and first your business person is going to talk with the customer establish what the domain is and the requirements and then give it to you and like oh please build that but the whole concept of domain driven design is that that actually doesn't work because there is value in the interaction between the developers and the stakeholders it's valuable that you as a developer talk with customers and learn from them because simply put you can't write software for a domain in if you don't understand that domain it's going to lead to a ton of problems and misinterpretations and that means the software is not going to be suitable to the customer with domain driven design there's basically five important steps in how developers and customers stakeholders talk with each other so the first thing is that you need to bind or couple model and implementation and what that basically means is that you already start from the beginning to develop some sort of very simple prototype a playground of some sort so that you can build on that and get a better understanding of what's going on so the whole idea is that you need some sort of tangible starting point a crude prototype and then you keep working the model and keep improving the prototype at the same time to give you a simple example of this i'm developing a tool called learn tail which is an ai driven quiz generation tool you can actually try this out for free by going to learn tail.com and the whole idea is you can enter a youtube video url or a regular website or just a description of what you want the quiz to be about and then the system generates a quiz and basically the very first version of the system i developed that in an evening i basically created a very simple api that sent a request to open a and that returns a quiz in some json format and then i made a very quick ui to actually do the quiz and that was all it was and then having that meant that it was actually relatively easy to then extend it and build on it and improve it and get also a better understanding of what were the limitations and the problems of a system like this so having this prototype very early is a good thing it means you can iterate more quickly and you avoid a lot of problems by doing that and of course this is very much related to the agile way of doing software development which is what everybody is doing nowadays the second thing that's an important part of domain driven design is that you need to cultivate a language based on a model what i mean by that is that between the customers don't domain experts and developers you have some sort of common language a common understanding of what is what and that means that these two groups can learn from each other and that's the crucial thing of domain driven design the thing is that if you need to develop some piece of software as developer it's important that you understand the domain and how those concepts are related to each other because otherwise it's going to be very hard but the other way around is also true if customers don't understand how systems work how software works and most customers don't then it's very hard to come up with a shared understanding of what the domain is for example a customer that wants you to develop an hr system might want something crazy which is simply technically not feasible this is also an area where we as developers actually provide a lot of value we have very welldeveloped analytical skills that can help establish what a domain is and what the constraints are so that's what this step is about and by the way domain experts can also be seen in a more abstract fashion doesn't always have to be people that you talk with it can also be reading a book about a domain so that you understand it better or watching youtube videos about it so in the case of learn tail i spent quite a bit of time trying to understand what actually a quiz was and it led me to better understanding because initially i had the idea oh a quiz is always multiple choice questions but that's actually not true a quiz is simply a sequence of various types of questions that test your knowledge and those questions can be closed questions where have a fixed number of options or they can be open-ended questions where you have to actually type an answer understanding these concepts better is helpful when you write software that deals with these concepts a third part of domain driven design is that domain model that you are creating should be rich in knowledge it's not just a bunch of data structures it should encode behavior as well and that can get quite complex and it's something that you do iteratively by having this conceptual representation of the domain you can talk with your domain experts in the language that you now both understand and then improve things iteratively this also something that we did in learn tale where we started with simple quizzes but then we also wanted quizzes to have a score but then once you start thinking about those concepts then you have discussions about okay what does it actually mean to score a quiz and how does that relate to the actual skills that you have what would an a atic system that models that skill based on quizzes look like so by thinking about the domain you raise these types of questions and you have discussions about what those concepts mean and you iteratively revise it based on what you learn a fourth part of domain driven design that's actually also quite important is distilling the model and that basically means that you're removing concepts that are not relevant i don't know if you've read walter ison's biography of elon musk it's also quite an interesting read but one of the rules that elon has is that you should basically remove things and ideally you should remove too many things so that you have to put at least 10% back in and that's really about distilling things to the core so when you take your domain model sometimes you remove concepts and you replace them by something else for example in learn my initial idea is that there would be quizzes and exams and exams would be automatically graded or scored but then i thought well if we do everything automatically actually the concept exam doesn't really mean anything anymore so why do we still need it so i threw that out of the window the fifth part of domain driven design is that you do brainstorms and experiments so you have this domain model that you've established then with that domain model you can go through all sorts of different scenarios and ask questions and think about how that affects the model and this is also where you see how important the role of a developer is is in this process because you as a developer you have an important role of clarifying what the concepts and the relationships are and making sure it technically makes sense to have those and that you can actually also successfully translate that into a software system customers users typically have no idea what is involved in writing software and what some of the limitations are and what works and what doesn't you as developer you know that and that knowledge is really important when you have these discussions for example in lear if we know as developers how the system works and how ai apis work then we can revise the concepts and come up with something that suits our application better or look at electric vehicles an example i gave in the beginning of the video if you know how software works then you can also rethink how the traditional concepts from gas powered cars can be translated to electric vehicles and car software for example with gas power power vehicles it's quite common to have a clutch and a mechanical system for starting the car but with electric vehicles it's mostly buil around software and software has buttons and user interface so by knowing how software works you affect the design of how an electric vehicle works now it's interesting when talking about all these core concepts of domain driven designers actually i haven't talked about actual code when you look at code then in essence it's nothing more than an expression of the domain model and the thing is we tend to spend a lot of time on the miniature mina mina the details the details of software design and what our code should look like right should we use dependency injection here what do we call this method in a class should we use a function instead of class where do we put comments what do we consider pythonic where do we store configuration values and constants and so on and so on and we often think as developers that the code is like the most important thing that we do but it's actually not true what actually matters is the domain model if your domain model is wrong then writing great code doesn't matter you will have a very nicely designed software system that's very robust because of course you wrote a bunch of software tests but if the domain model is wrong then your user can't use your software and you spent all that time for nothing the longer i've been involved in software development the more i realize how important the domain model actually is and i view code more and more as just a temporary expression of that domain model and since the domain model is something that constantly changes and evolves it also means that in many cases your code will dramatically evolve and change as well because of that and when i look at the code that i write myself then in fact most of the code i write is going to be thrown out at some point and replaced by something better that's just how coding and refactoring works the domain model and your insights into what the concepts are and how they are related that's what persists and that's ultimately also what drives all the changes in your code and that means that if you want to write great software you need to optimize this process of iterating over this domain model and do it as quickly as possible because every iteration makes it a little bit better and as a result you need to make sure that it's easy to basically throw away and replace your code because ultimately the code is not the goal it's simply an expression of the domain model how do you make it easy to throw away your code and replace it well that's where design principles and design patterns help for example you use the strategy design pattern to easily throw away an old strategy and replace it by something new or you work on reducing coupling so that you can easily throw out a piece of code and replace it by something better without affecting the rest of the application or you write smaller functions with a single responsibility so it's easy to pick out these small things from your code without affecting the rest too much in essence what we should do is trash can oriented programming we write code in such a way that it's easy to throw away in the trash so that we can more effectively iterate on our domain model now this is not some sort of mind-blowing insight i mean developers have been talking about agile programming for many years but what i did find interesting is when i thought about how that actually relates to how ai tools are being used i mean as developers we use ai tools more and more right things like get up co-pilot for example to automatically write pieces of code for us but when you think about how this relates to domain driven design and how we write code if code is purely an expression of the domain model well basically ai tools help us do that more effectively they help us more effectively express the domain model in code so we can spend less time on writing code and we can spend more time iterating on the domain model and making things better so ultimately what ai will do for us as developers is that it will help us evolve the domain model more quickly and that means our biggest value will be in on the one hand having a better understanding of how systems and software work which customers and users typically don't and on the other hand developers often have strong analytical skills that help us crunch knowledge in the domain and represent it in a way that mak sense in a software system so in essence reading this 20-year-old book gave me an interesting insight about how ai and software development is going to work together in the future but i'd like to hear your thoughts about this what what do you think do you think this distinction between domain model and code and code being an expression of the domain model makes sense do you think we should view code purely as something that we're going to throw into the trash later let me know your thoughts in the comments this was a bit of a philosophical video i hope you don't mind me doing these from time to time as actually i really enjoy these kinds of videos as well now regardless of whether you agree with me or not it's still good practice to learn more than one programming language don't just learn python but learn other languages as well that going to broaden your horizon and makes you think more in terms of domains and concepts versus very specific programming language related things i found mainly python focused content on this channel but lately i've been diving into rust and it's quite an interesting language it's very from python if you want to learn more about rust i did a video about that a while ago and you can watch that right here thanks for watching i'll see you soon