it's finally happening after years of being on the fringes and struggling rust is now slowly entering the mainstream now if you're not really sure what i'm talking about the white house put out a report that is 19 pages long that details the importance of using memory safe languages to enable a more safe cyber secur future and in particular they call out languages like c and c++ for being unsafe and languages that are memory safe like rust for being safe in this video we're going to kind of break down this paper at the high points i'm going to give my commentary on it as a security researcher if you're new here this is a lel learning a channel where i do videos about software security and programming so if you're new here hit that subscribe button i really appreciate it so this paper is the output of a recently signed national cyber security executive order that the president signed off that's detailing how we can make america more secure from a cyber security standpoint and ultimately the world right president biden's national cyber security strategy outlines two fundamental shifts the need to both rebalance the responsibility to defend cyberspace and realign incentives to favor long-term cybercity investments in this report the case is made that the technical community is well postured to drive progress on both strategic goals and the most important one for the sake of this video is first in order to reduce memory safety vulnerabilities at scale creators of software and hardware can better secure the building blocks of cyberspace this report focuses on the programming language as a primary building block and explores hardware architecture and formal methods as complimentary approaches to achieve similar outcomes whenever i say that a language is unsafe i met with oh skill issue l like bad take like just write better code and like sure i i totally agree that it is on the programmer to write secure software however comma we are 50 years into a world that is written entirely by the c language so how is it that after 50 years of improvements and and security mitigations put onto the sea language we are still able to you know write insecure software is it because that 50 years later people still just have skill issues or is it that the language while powerful is not designed in a way that gives us secure software paper does go into this but first they talk about kind of the reactionary state of cyber security so users of software and hardware products are consistently placed in the untenable position of reacting to cyber emergencies responding on a crisis by crisis basis often leaves them on their heals and those securing systems on the front line should not be expected to bear the full weight of the of this burden the intensive reactive posture demanded by the current status quo reduces defender ability to predict and prepare for the next wave of incom incoming attacks so if you're a member of the cyber security or just the general tech community you're probably aware that like most security teams are extremely reactionary we don't have really defender roles we more have incident responders malware reverse engineers and basically teams that are meant to to put out a fire and not build a fireproof house this posture stems from the fact that mitigating known software vulnerabilities is a complex systems problem and the current ecosystem does not sufficiently incentivize the investments required to secure the foundations of cyberspace the problem they're highlighting here is so true in software up until like very recently i mean it's 2024 and like up until literally within the last few years security was an afterthought in software it's like build the thing wrap it in duct tape build the thing slap some security on it security was not built from the foundation and i think the reason that this happened is because profit is obviously the goal right if you can make a product prove that it works and get it to market as fast as possible you're going to have the most innovative thing and you're going to beat your competitors to market if security is not a part of the profit equation it'll always always be an afterthought and this is what they're saying about you know incentives right because nothing really incentivizes companies to build secure software people are not incentivized to write secure code why would they and then as a result you have these teams that are constantly reacting to incidents and not able to properly prepare for them a because of a lack of staffing but also because of b the the ecosystem is not designed around that so this is just for known vulnerabilities by the way these are just cve things that are already out there however even if every known vulnerability were to be fixed the prevalence of undiscovered vulnerabilities across the software ecosystem would still be a present additional risk a proactive approach that focuses on eliminating an entire class of vulnerabilities reduces the potential attack surface and results in more reliable code less down downtime and more predictable systems ultimately this approach enables the us to foster economic growth accelerate technological innovation and protect national security programmers writing lines of code do not do so without consequence the the way they do their work is of critical importance to the national interest and this is obvious for literally any country around the world if you look at some of the videos that i've done like the video on the thea system or even recent events like the colonial pipeline shut down when programmers write code if it's not secure people die or people lose money and not just people like corporate ceos like people who have jobs people who have to go and go to the gas station and fill their truck up like lose money so it's so important to take your opinion if even if it is oh it's just a skill issue and think a little harder about the problem at hand right the skill issue argument can't be true if it lasted for 50 years we need to have more secure foundations so in this report they focus on programming languages as a primary building block and explore hardware architecture and formal methods complimentary approaches to achieve similar outcomes now it maybe if you're watching this video and you don't actually know what memory safety is you've heard that term kind of thrown around but let's go into it and i actually really really like the way the white house broke this this down memory safety vulnerabilities are a class of vulnerability affecting how memory can be accessed written allocated or deallocated in unintended ways this is the nature of literally every exploit right people say oh when you write code just write the code correctly well if you write the code in a way where it has a vulnerability and you're able to exploit that vulnerability the computer will just do what you tell it to do so if you're able to overwrite metadata in the memory allocator if you're able to overwrite the return pointer on your call stack these are the fundamental flaws in software that enable hackers to do evil stuff so experts have identified a few programming languages that both lack traits associated with memory safety and also have high proliferation across critical systems such as c and c++ and they have a little footnote if you want to go read the sources but this is true literally the entire world is propped up on code written in languages like cn c++ that give the programmer incredible power but also require them to have a lot of responsibility because they're able to write code that can do literally anything in the c language for example exle if i give you an array and i let the user control the index of the array let's say array of 6969 there are no bounce checks to call out if i go outside of that array and so here they actually discuss the broad categories of mate safety vulnerabilities right there are two broad categories that are spatial and temporal and i've actually never heard it broken down like this but i really like how this makes it extremely simple to visualize so the spatial memory safety vulnerabilities issue from memory accesses performed outside of correct bounds established for variables and objects in memory so that's if you have maybe an arbitrary read where you're given an array and you can specify an index outside of that array in c you can do that there's no question you will it will allow you to compile a program where you give i as an index and i can be any value giving you an arbitrary read primitive if you're able to write outside of the bounds of a stack based array you can use that to overflow the control flow information and take control of the program so all of those rewriting outside of where memory should be written to is a spatial vulnerability a tempor al memory safety vulnerability arises when memories accessed outside of time or state such as accessing object data after the object is free to use after free or memory accesses are unexpectedly in leaves that's kind of a race condition right where you have like time of check and time of use maybe i read the value to check it but then it gets written to and the check happens after it gets read from two different threads and these two primitives the temporal and spatial memory corruptions are the result or are the reason for many cyber security vulnerabilities that have enabled the morris worm of 88 i wasn't alive for that i was also too young for this one but heart bleeding 2014 was a huge one where you could read arbitrarily the private keys out of the open ssl library the blast pass exploit chain of 2023 so for over 30 five years the same classes of vulnerabilities have vexed the digital ecosystem there should not be in my opinion at this point the skill issue argument just dies we've been dealing with the same problems for 35 years it's just it's not i don't i can't i don't understand how you can say oh just get better like is the world just not good after 35 years the highest leverage method to reduce memory safety vulnerabilities is to secure one of the building blocks of cyberspace the programming language using memory safe programming languages can eliminate most memory safety issues while in some distinct situations using a memory safe language may not be feasible and that's completely true in most cases using a memory safe programming language is the most efficient way to substantially improve software security boom rust mentioned actually rust has not been mentioned yet but it's coming building new products and migrating high impact legacy code to memory safe programming languages can sufficiently reduce the prevalence of memory safety vulnerabilities throughout the digital ecosystem to be sure there are no one-size fits all solutions in cyber security and using a memory safe programming language cannot eliminate every cyber security risk this is so true 70% of bugs were memory corruption vulnerabilities but you still have logic errors you still have command injections you still have all of the things that could go wrong that are not a result of memory corruption but 70% 70% of memory corruption however it is a substantial additional step technology manufacturers can take toward the elimination of broad categories of software vulnerabilities a recent report authored by sisa the nsa fbi and international cyber security agencies entitled the case for memory safe road maps provides guidance for manufacturers with steps to implement changes to eliminate cyber safety vulnerabilities from their products i have not read this i'm sure it's great now we do move on to another area of memory safe hardware which is an interesting term i haven't heard of i think they just mean like secure root of trust hardware but they do go into an interesting piece about space systems here the space ecosystem is not immune to memory safety vulnerabilities however there are several constraints in space systems with regards to language use and i did pre-read this and i found the last one very interesting let's kind of go through this first the language must allow the code to be close to the kernel so that it may tightly interact with both software and hardware this is either going to be low-level code that rides a top a kernel or maybe it's even real-time software an ars that can both act as the kernel touch the hardware but run user mode applications as well second the language must support determinism so the timing of the outputs are consistent and again that's a realtime operating system that mean meaning that you can determine the timing of when certain tasks are ran and third and interesting the language must not have or must be able to override the garbage collector a function that automatically reclaims memory allocated by the computer program that is no longer in use so effectively what they're saying is for some reason that i'm not really sure of you cannot use a garbage collected language in space maybe that has to do with the nasa video that i made i'll put a card up here for that yeah it's it's interesting for sure and this is kind of the the peace day resistance okay according to experts expert me both memory safe and memory unsafe programming languages meet these requirements at this time the most widely used languages that meet all these properties are c and c++ we discussed that previously which are not memory safe programming languages rust rust rust mentioned rust one example of a memory save language has the three requisite properties above but has not yet been proven in space systems oh we'll get there buddy further progress on development tool chains work force education and fielded case studies are necessary to demonstrate the viability of memory safe languages in these use cases you heard it here first folks white house calling you out right now go build a satellite go make a little cube set write it in rust shoot it into space see what happens call the white house all right cool therefore to reduce memory safety memory safety vulnerabilities in space and other embedded systems that face similar constraints a complimentary approach to implement memory safety through hardware can be explored go into in this last chapter some pretty interesting techniques that that chips use to do memory safety checks like memory tagging extensions it's a new spec from the arm chipset where effectively in hardware you can tag a particular heap chunk with a tag right you literally say this is an object fu and then if object fu that got tagged in memory ever gets used as an object bar it throws a cpu error cross check the validity of pointers to memory locations before using them if they are invalid the cpu throws an error there you go and then formal methods that kind of go into here using effectively mathematics to mathematically prove the security of a piece of software and then they go into their part to talk about secure systems so what do we learn today software security is hard and humans make mistakes the white house is beginning to catch on to the fact that c is great c++ is okay rust is better but harder and if we write our code in a memory safe language and use memory safe hardware maybe we'll get to a future where there are no vulnerabilities that's it welcome the assembly appreciate it again if you're new here hit that sub button and then go check this video out right there goodbye right