first the usual things to introduce the speaker i assume well i recognize most of the faces in the audience so you probably know who i am i work at kdub several roles and we are hiring so if you want to work at a company that does quite a few cool things and some really popular tools for c plus plus open source tools just ping me and i'll forward you to somebody else because obviously i'm not i don't have the hr head on top and i forgot to the email for for our hr so i also wrote a book that you might know of it it was translated into quite a few languages some more popular than other some that i understand and for that i don't but it's really nice to see all the random squig squigglys around the code that i wrote apart from that i'm a trainer consultant kd developer and the university professor who cares right so victor showed this already yesterday i'm not just a disclaimer for the disclaimer i'm not really sure that this is phil wadlow's quote but i did hear him say it once probably quoting somebody else but i don't know who who it was originally so i always quote i put phil butler because of the nice picture that that goes along with it and the second disclaimer that i took really seriously this time is that this is slideware the main part of the of preparing for the slides was actually removing references and stood calling calling and now whenever i see these slides they kind of trigger ocd for me because everything that i see something is like oh this shouldn't be for okay i removed forwarding so the code is meant to present an idea not to be the code that you're going to copy and paste to some other place now the question is why i talk about expected again in essence to quote clerks yet again i wasn't even supposed to be here today right in essence when the program for meeting c plus plus was published after some time i was invited to talk about something and i realized okay i looked at all the talks nobody talks about expected and at the same time i was at meeting civil sports community survey and there was a question which type of error handling are you using and obviously exceptions is the most popular one and expected like objects is the least popular one and i thought i was safe i'm going to present expected because it will be the only talk talking about expected on this conference and then another adult edition timber stock yesterday spent half of one hour and a half talk talking about expected so still i wasn't really that safe even if i was able to invent my topic after all the talks were published so let's start with a short introduction because teamwork didn't cover that usually we use exceptions we pretend that we use exceptions by throwing them right and we all know exceptions we know that they have quite a few downsides a lot of projects forbid using exceptions because of those downsides extremely slow sad path really optimal happy path but when you do the average it kind of sucks it they add quite quite a lot of boilerplate to your binaries even if you're not if you if you don't think you're using exceptions so usually in the embedded area nobody enables exceptions because just the binary increase is 50 or something like that for those small devices which is quite a huge increase execution paths are not that obvious because you can jump from a highly nested function randomly into something else most of us kind of well kind of know how normal functions work how you call a function you get something on your stack and then you call a return you get some in the previous stack and with exceptions basic my estimate is that maybe five percent of people at this conference know how they work internally so it's kind of kind of a little bit of a magic and the worst part is that exceptions are quite easy to ignore you love throwing them but you never catch them well at least most of the projects that i've seen exceptions in and exceptions are not really a part of the api we were told when we learned c plus plus in c plus plus everything can throw right so you don't see for each of the functions which function is safe which function is unsafe and while i do love no except as a c plus plus developer that likes performance introducing my except was kind we give up and not only c plus plus people but the first talk that i saw about mexico was by herbstater and he investigated well he found a couple of scientific papers that were talking about how people use exceptions most notably in javan because in java you have tactics exceptions you need to catch them and if i remember correctly it was 70 of all exception handling was either catch everything and ignore or catch everything and just print out the message and then continue as normal and no excerpt is kinda our take on that so yeah we like throwing and sometimes we do catch them but yeah usually we don't so let's just put no except on a function if you don't want it to throw because obviously know yourself doesn't mean the function doesn't throw it just means we are not going to check it so crash my application right now even worse thing that came from our ancestors the the beautiful language called c is since we cannot return several values at once or anything like that let's return a bull or an into denoting where the the operation was successful or not and then returned the proper result by an output parameter obviously this works very well this is efficient but the api is awful and before we had no disc no discard the errors were as easy to ignore as in exceptions may be a little bit even more because you didn't even need to write a catch or anything like that in essence if you forget to check for the result of the function you're screwed the next one which is also according to meeting c plus plus community survey a popular one is to use special values in a certain type now the question is is that a special value tied to the type itself or the usage of the type in some context and unfortunately even if we have some types that have built-in error values like not a number they're even in the standard functions that return 0 as the error so it's not even tied to the type and for integers sometimes we have positive integers or errors sometimes negative integers are sometimes zero is the error so it's completely completely muddy you have no idea for a certain type unless you read the documentation what the values are considered special and in this case if this is the easiest place to ignore the errors because not even now this card helps because you're going to access the return value and if it's a minus one denoting an error you're just going to ignore it and the compiler cannot help there so in all of these examples we kind of had something like all the functions of whichever area handling the was was used they have a result or something else or an error and we have we have a class that implements exactly that so a value type that can be either this thing or this thing and it's std variant now usually we mention andre because we we like him and he was the first one to mention something like this in the c plus plus community but in other communities this is a really really old idiom that you can have some type of a value or an error and use it for error handling especially for languages then don't come with exception handling natively so before we get to the std expected if you don't want to dive immediately but you just want to tip your toes in the water and you have your existing code that uses special values for errors you can just write a simple wrapper type over those return values that will store the result and have some policy class that will decide if that value is an error or not and then you can wrap c style apis into this thing so for example yeah i'm blanking out but for example xerium cure library has some notion of error handling via special values for integers you would be able to create your own result class that reps or your own wrapper for xero mq which would instead of returning an integer return and result of int and some policy that will in the api state which integer values are special and even if it's stated in the api you don't care you can just call the has value member function and it has value member function will rely on the validation policy to check whether that value is the special error handling value or not for those policies the most common ones are if a value is larger or equal to zero then it's a proper value if it's less than zero it's obviously an error the same thing a similar thing for unix usual return codes for applications if it's zero it's true or a valid result and otherwise it's an error etc and in the the last one if a value returns true it's a valid value then converted to a ball and if it returns false you can consider it an error useful for optionals useful for pointers useful for quite a few things any questions so far so when you create a wrapper like this you would be wise to add some member functions that are let's say commonly named so he has value to simulate the std optional and dot value again to simulate std option even more it would be even even nicer to also support the pointer syntax like scd optional does so that you don't need to write all the boilerplate yes value or something like that so what we want to have in c plus plus is a variant that has the api of an optional or of the previously created thin wrapper and that thing is called as it expected now there are two proposals for as did expected i call them the core proposal and the extensions proposal i don't want to use the proper names because i don't agree with them but the proposals are awesome the first proposal kind of got in c plus plus 23 early on but for the second one it was a really a whirlwind adventure of a romantic field day one today right so it was proposed for c plus plus 23 but then it was postponed for 26. then it got on the track for 23 then it was removed it was a huge story how we maybe got the extensions proposal for c plus plus 73. now it's from what i checked it's not yet in the draft standard but in kona it was voted in so we are going to hopefully if nothing bad happens we are going to have all the things that most of the things that i present today in the standard expected now since c plus plus 23 was feature frozen since summer c plus plus community took the usual mantra of software development it's not a bug it's a feature and turned it around so it's a bug it's not a feature and we added a few features so the extensions proposals was essentially considered a bug fix although it has quite a few member functions too as did expected so let's see an example if we have a function that returns expected of an email object or an error object it's parsing some some string and returns the email object if the regex doesn't match then we are going to return unexpected and the error since you can declare expected of t comma t for and use the same types there is there needs to be some way to differentiate do you want to create a valid value containing t or an error containing t so by default expected is going to create values if you provide a proper type and if you want to create an error then you write this written unexpected and some value inside so you can just think of it like std move hints that something should be moved and in this case unexpected hints to the expected that this will be the error value now if you just use the core proposal this is the api that we would have so this would look kinda like the old c-school where you check the result after each invocation of each function you get some input if input is not valid then report an error we will see how exactly then we are parsing the email accessing the value inside of the option because we already checked that the optional is valid we can access it with the reference operator and again if we didn't get a proper email but we got an error we bail out and the last one we apply a function called format link and we create a string that we return then to the column now it is worth focusing on this part this part here so this is not the common idiom the reason for it is that if the input is not true it's going to contain an error right so we can just directly return it but we can only return it if this type matches the type the return type of the function which in this case it is true so we have expected a string as the return type of the function and expected of string error t as the value that we are going to return but in the second case we have a parse email function which will return expected of email object and our function returns expected of string and this will not compile instead the geometric way is to always use return unexpected something dot error the previous code looked much nicer the second code works right so i'm not sure what's better yeah it's a plus plus and writing these things can be a little bit tedious but that's the core proposal the cool thing about expected is its predictable execution path you can have as many number of errors flying in the air as you want so again no magic that needs to be inside of the compiler or the runtime in order for these things to work this is just a normal value you call a normal function and your you return a normal value and again since i said unlimited number of errors flying another moment of silence for teagle okay now before before i continue like a breed breed we don't have the uniform call syntax so we care we have a few different ways to call functions when we have an object it's either a member function so we call it with the usual object oriented dot something syntax or we can have a non-member function and then we call function of that object now if by some weird coincidence the extensions proposal doesn't get merged all the things here are still applicable you can just write non-member functions but with non-member functions the syntax when you have a few functions nested is a little bit not something that c plus developers are accustomed to so instead all the following slides are going to use the range rotation if we ever get the ucs operator triangle or you can just implement these on your own obviously since i said we are not going to write any namespaces you should put your weird things into a namespace but on the slides i'm just going to omit it if you have a desire to to implement something like this and really use the pipe operator as the syntax for something it's quite trivial you just define the auto operator a dummy object called sum function and inside of the operator you can use concepts to check whether some function is a member function of a type then called the member function and otherwise just call some function of an object but this is not the part a part of this talk the point is just that you don't get surprised when you see that everything is using pipe something pipe something most of the time you'll be able to use just a dot if the extensions proposal goes through so we've seen this and we said this is the idiomatic way to use expected again tedious but idiomatic if you try to analyze what this function does if we haven't expected that contains an error then we are just returning kind of the same expected maybe a different type but it still contains the same error that the original one contained and otherwise for that thing expected and the value inside we are changing that value into something else and graphically this should remind you of something that victor talked about yesterday so if you have a function that transforms strings into email objects and you do this idiom on an expected that contains a string you'll get an expected that contains an email quite cool and if you do it on an unexpected that contains an error you get essentially the same equivalent error now the question is how we should call this function this edm when we wrap it inside the function and again if we draw from the stl we have this for vectors it's called transform we have this on options it's called transform and if the senders and receivers proposal is merged as it is in centers it's dotted then so use dot transform so email pipe transform and pipe it to through a format link now this function format link is a function that takes a string format link okay an email object and returns a string it cannot ever fail so it doesn't return expected of string it returns a proper string if we wanted to do something a little bit more complex because we've seen that format link has two arguments then we can just write a lambd and again we are kind of getting into the tedious part of the world so as long as you have functions named functions for everything this dots transform or pipe transform is beautiful as soon as you start adding lambdas you're kind of going to get the usual c plus plus code that is not as nice and as readable but still this is quite a few quite a useful idiom the second was we had also the parse email function and unlike the previous one this one does return expected so it takes a normal value and returns the expected value for it we cannot really use transform i'm not going to talk about why you can see the the talk from yesterday by victor so the difference is that we have a function that takes a string and doesn't return a proper value it can return expected that has a value or expected it has an error okay and in essence what we need to simulate this is something that will take out the value from expected if it exists apply the function and return whatever that function returned so it should be even easier than the previous one we don't need to wrap it as again inside of another expected and again if we have an error we're just going to ignore it and i think i'll need to speed up a little bit and this function again if we draw from the already existing naming for std optional it's called end then so we are going to use and then in these slides again if you want to draw from the senders and receivers it will be called let value so use and then so you can change these and say get input and then parse the email and then call sorry data transform call the function called format link quite useful and okay now the question is what should we do in the end we can return the expected to the caller and let the caller deal with the fallout or we can handle the and create a fallback for the expected value the fallback in this case if the value is not existing replace it replace the whole expected with an empty string or the expected that contains an empty string but usually just imagine this is some web application for some strange reason written in c plus plus when you type an invalid email you expect that the web page is going to say okay this is an invalid character in your email you're not going to expect to know just an empty string but at the same time if you didn't type anything in the web application shouldn't write this is a new valid email which most of them do nowadays because if i didn't even start typing of course i know that it's an invalid email so what what we want to do here is if we have a value just leave it as is if we have an error then we want to do something with the error and in some cases we are going to for example return a string if the email was empty we are going to return empty string and if the email wasn't empty so we had some kind of error inside we want to propagate the error so we can just flip the previous figure around the the axes if the value is here we do nothing if we had an error then we call a function that processes that error and can return an expected that has a value or expected that has an error and it looks essentially like and then but on the second argument and in expected proposal it's called called or else so after we have transformed we got the potential error when parsing the email we can just say or else if the error specified was reporting to us that the email string was empty then we don't really consider that an error we are just going to return an empty string by default default constructor of expected is going to default construct the value not to the error and otherwise we report the error in some way so if you want to handle some errors but not all you can always use or else hand layers hand layers and replace the error with a proper value otherwise you just propagate the error onwards minute of silence vertigo now the question is if you're working with several libraries at once and all the libraries they don't use exceptions we don't use exceptions for and then definitely the other libraries want we can have libraries in our project that use exceptions some that use out parameters etc we need a mechanism to convert between them so for special values i would first go for the thin wrappers and then if you need to bridge them somewhere to some code that actually uses expected then you just write the conversion functions so the benefit of simple wrappers is that they don't take more memory than the value type but they're not all powerful because you are removing some of the values from the domain and considering them special as soon as you need all the values in the domain then you're going to have to switch to something like std expected so for exceptions it would be quite cool to create an error type that is constructible from an exception pointer and after that you just write something like this you write a function x try that will take a function that can throw it will check for all the exceptions and if any of the exceptions occurred we are going to return an unexpected of that error type constructed from the exception pointer so wrapping the api that works with exceptions it's quite trivial obviously it's tedious because you would need to wrap all the functions but that's something that you can use tooling to to generate in order to convert from expected to exceptions you can just use dot value if the expected doesn't contain a value dot value is going to check and throw an exception it's not going to throw the object that was denoted as the error but bad expected excess or something like that but at least it's going to throw an exception unlike that star value or dereference operator it's not checking so if you didn't check in advance this will be a ub if you have out parameters similar to creating unexpected from an exception you can create expected from the output power parameters and i'm not going to delve deeper into this code because it's boring now if you have several libraries that use expected but with the different error type you would like to be able to convert between those so in this case we need something that again if it's a value it remains a value if it's an error or some type we want to switch to an error of some other type and i've i have to mention my favorite unicode character in terabeng the question mark and exclamation mark in the same same same place so these are the two different types of errors and we need some transformation function to convert an expected of one error type to expect it of another error type how would you call that that function transform error i have no idea what's it called inside receivers proposal so if you want to convert you can just say transform error to error code or so some other different type alternatively you can just use the you can just rely on the built-in conversion between expecteds if you have an old error type that is convertible to a new error type then expected of something old error type is convertible to expected of something new error type so if you have the error types that are convertible between each other you don't need transform error otherwise you just write a function a conversion function and pipe it through transform error so far so good okay and here we can see this thing in action so get email link returns something that has error t is the error and we want to assign it to my error t which has a constructor that accepts erity so it's convertible too also since variants can be constructed from the types that they contain you can also define my erity to be a variant of all the different error types that different libraries that you use provide to you and then everything will just work like magic but the magic that we know how how it works unlike exceptions and these are the most important things in the proposals as they currently stand s three but some of the examples are still not as pretty as we want them to be we have transform and we have entered them and both of them essentially accept a function that takes just a single argument and this is obviously really cool in haskell world in c plus plus we often have functions that are multiple arguments slide right so we've we had this for example we have the email and the email was expected in a sense if email can be empty then email dot user can be empty so this is a function format link that accepts two values and we are trying to call it weird to expect it's right and for that reason we have to wrap everything into a transform a lamp die and all of this nice nice c plus plus characters on the slide it would be really nice if he had a function that can just like exceptions if an exception arises anywhere the function is not called we're just going to drop out why don't we have something like i want to call this function where all the arguments can fail and only if they all succeeded we are going to call the original function with all the values from those arguments so we can write something like that we will call it x invoke and it will look as far as the usage goes something like this so just like std invoke we first have the argument function that we want to call and then the expecteds that should be evaluated before calling that function okay now the question is how to deduce the type of this huge thing if we have expected that contain different types of errors we can have different ways to return the final the the final type so we can force the user to explicitly specify the error type they that they want which can be tedious but again welcoming in some use cases we can just take the first error type that we found and consider all of the types convertible to it and just ignore if they're not or we can just use std variant of all of them now the question is if we have a list of types how to deduce all of these imagine there is a library it there is but you don't know it so you imagine there is a library that works like ranges but better without nico's problems and it works on template types on type lists so what we want to do is first create a type list of all the expected types so we have expected of string error expected of integer something and we want to collect all those types in a list then we want to remove severe ft so apply a function to it so if we had const expected ref it will just be expected ref in the following list and then this line you can ignore for for the time being but the point here is that i've said we had a function and we want to call it with several expecteds but sometimes you already have the values and you don't have the expected so it would be cool if this type deduction thing could differentiate between an argument that is expected value and then handle it in some strange magical way and the type that is already a proper value we will see an example a little bit later and in this case we are just taking the first argument at the first expected type we want to have a variant then you also need to pass it through the unique so that the types don't repeat and then pass it to a meta function variant so that you get variant off and the list of types but again this is magic and this is with dark background slide because this is not a part of this talk but this can be done and it's be actually quite it's not that difficult in c plus plus 20 and 23. and we're going to skip this one so what x in walk would look like the first basic version we find the error if the arrow was found then we don't even call the function that was passed to us we just returned that error to the caller somewhat-like exceptions right if something through then we are not going to call the functions we are just written in the exception the same thing goes here then we just construct sorry my my mouse is on the wrong screen we construct the expected we call the function and pass all the values that we extract from the expected with this lambda above so we have a list of expecteds we use default expression to apply a function to all of them extract value extract value extract value extract value and then we call that function with all the extracted values okay and then we can call format link with something like this email dot user is essentially pushing email to the transformation that calls user t colon colon user member function and email is email so we have two expecteds here and we call format link function we need to expect it now we can add since we as i said we want not only to be able to pass expected study function but also normal values we can complicate the value of our function a little bit more and check again if this type is an instantiation of expected then extract value from it if it's not an instantiation then just return that as a value and after that we would be able to use the api like so so for example imagine that the format link also accepts the css class whatever it's called and then for the first two arguments are expected and the last argument is just the plane string and this is at least for me quite quite simpler than all the lambda thing usually obviously you're not going to have this you're going to have separate instances of expected data don't depend on each other similarly we can create x coalesce if that's the pronunciation where you have a list of expected values and you want to call the function with the first one that is not invalid if they're all invalid again we are returning error so you can treat this as some kind of a fallback we have the main value for example high precision calculation of something and if that one failed we want to go to a hardware that was less less precise and if that one failed less precise etc so a list of values and you want to use the first valid one how much time have i left oh cool so we have x invoke and x call s but usually we also want not to even execute the code after some error has occurred right so we can also have x lazy invoke and x lazy coalesce where you would be able not only to pass normal values expected values but also functions that return expected values or ordinary ones and for this we can even complicate a little bit even more the value for a function if the argument is invokable then it's a function that will return as expected or a value and after the last night's talk i added the deducing this into the mix so that this is the first example where i've seen that a recursive lambdas are actually useful so alarmda will call called the the function the the invokable that was passed to it and then call itself with the result of that function and then fall back to the second or third if branch we have been passed the function then the function will be executed and the result will be treated either as either either as expected or as a normal value and if we got directly unexpected it will behave like it behaved before and it if it was a normal value again it will behave like it behaved before now as nico said cool is not good precise is better the idea that you should magically differentiate between functions and non-functions can be quite problematic and that's why in the standard we have find and find if count and countif we don't have the same thing that tries to figure out is this a predicate or not and then use it instead of that you can create again a thin wrapper just like std move or something like that that will hint to x invoke that you want to call this lazily and then for if we had some complex functions that calculates the cloud the css class we can replace that string the fixed string that we had with a lazy of some lambda or lazy of sum function and then this api is quite a clear and not not smart just like nikolai's likes okay so this part was a little bit probably more complicated so any questions if not the last really lightweight part you probably have seen this dog with this guy over here so he talked about coroutines and we all pretended that we understood coroutines afterwards his presentation was awesome you should watch it but probably three or four times so to to pick up all the things inside now the reason why i i'm showing this is that this code if we if we apply a specific filter called the freedom of information act to it this code should kind of start to look like something that we already had so we have i know this is an this was a normal function and this was the asynchronous function so we have something here so some value i assume and we have a lambda that does something with the result of whatever so whatever is we have a value i don't care what it was and then it's going to be processed and after a while it will produce a new value and we call a lambda on it if you try to let's say spell it out a little bit differently this is a value that will arrive at some point in the future and when we have that value a lambda should be called if that value never arrived we should do nothing if it arrived didn't arrive because of an error we should propagate the error does this sound like something that we already had the only difference between what i just said and what we already had was this some time afterwards core routines don't care in essence for core routines if it's immediate or afterwards it differences differs in implementation and ask address but conceptually wise it's the same thing so for example for tasks this is the code that is obvious what it does right we have a task again in the future we are going to get the result and the result of the user task will be assigned to this variable obviously i forgot the name of the variable cool and then we can use that variable to create a new task and again for the resulting task we do something and then in the end we return the name now i just want to mention one small thing and i said that core teens cannot have normal returns if they could this would be much shorter because what we are doing here is extracting the name and then returning the name inside of a new task and we already had the task name here so the ideal world would be that we can just say return new name task instead we need to extract the value and then cory turn it and put it again into a new task which is a little bit tedious but okay it works and the code theoretically if you had a library that allows us to do this could be written without any core routines just with and then and here it should be even more obvious that the last and then is completely useless essentially we are taking the name and returning the name nothing nothing more than that so this should be possible in some future world but again this is not to talk about futures or core routines or anything else but about expected this api we already have in expected just like we went from core routines to this it should be possible and ask address to go the other way as well so if he had expected and we added quarantine support for expected we could just write something like this get input again can we turn a value or an error then we correlate on it just imagine that color rate is not called covet but something put the value out of then it gets assigned to the string called input then we call another function that returns expected again kovate try to pull out the value from it and continue processing if any of these steps return an error inside of the expected immediately the core weight cannot put the value and the whole function just ends and the whole function just returns expected that contains that error so this is let's say 95 simulation of that exceptions do without the exception handling mechanism in the language as soon as any of these core weights cannot pull a value which means that the function that was called failed or through an error the whole function that uses the whole core routine is going to end and return the same error isn't this like a fancy point i promise that i'm not going to mention that name in the talk that's another reason why i didn't write the names of the proposals for expected of course it's offensive line so all of these things obviously the talk was mostly focused on std expected but all the idioms feed and then transform transform error can work with any type of error value or error type like boost outcome leave etc and also it can work quite well with values that don't have something or something but that have both value and an error at the same time now it might seem a little bit counterintuitive to have both the value and an error but just remember your days when you learned physics often you had the the result and the numeric calculation error next to it so sometimes you do have both and obviously you can complicate this even more and say we have a value and an error or a different type of error but that's a little bit of an overkill and all of these functions can be easily implemented for all of these and if you use the pipe operator then most of the implementations of and then or else etc can be implemented in a generic way to work on all of those types so as a summary you should put your errors inside of values but not inside of the domain types as animals said likes to say your class shouldn't have is valid there is a valid state should be inside of a wrapper like expected or something similar we've seen how to create interoperability between different error handling mechanisms conversions and how to easily compose functions that deal with expected values and in the end with the help of andreas we were able to even simul completely simulate the mechanisms for exceptions without the actual exception handling mechanisms so i'd guess this is the end [applause] as a small note this is how you can contact me i was also on mustard on earth for a long time but never active but nowadays a little bit more active than i used to be any questions thank you for the presentation and as you mentioned the this technique can be used instead of exceptions and exceptions are considered sometimes slow but do we have any estimations is it faster with this technique or then again with the exception or not good question so the happy path is a little bit slower than than exceptions because of the branching if and else the set path is as efficient as the happy path so it's a tiny tiny slower in the happy path and it's significantly faster in in the aeropath there is just before guy's question i forgot to say one really really huge benefit of proper values that denote errors as well you can serialize them to disk you can send them to the database you can send them over the network between threads between processes or anywhere else which you cannot do with exceptions and that's a really huge deal thank you very much that was a really good presentation i expected i'm almost certain i mean i'm on the library working group but i'm almost certain that jeff's additional stuff we'll get through but time will tell as a follow-up to the performance question i would have thought that the happy path would have you know branch prediction would effectively eliminate all of the that the happy path costs that you're describing with branching or am i missing something here so i would mostly agree with you and that's why i said it's a really really tiny one brand prediction is really efficient but is not as is it's not the same as no branches right yeah so i would say it's for most use cases it's an insignificant slowdown if you're andre then then it's probably not so in rust we have something very similar with the result and they have this question mark operator they have this pattern matching which helps a lot to deal with it and also on the library side i mean it's not standard but they have like this anyhow this error so it seems like really a lot of work went into it and they thought clearly about it do you think in this state it is already like usable for like really good usable for everyone without those parts so first i just want to say credit request you these things existed for much longer than rust does and all the things that are in rust just like c plus plus stills good ideas from other languages so did so did the rust i would say this is really useful it would be nice to have obviously pattern matching maybe even some special operators in c plus plus but for operators i don't expect to finally not intended i don't expect to see them probably at any point in in the future mostly what you can do by yourself is create functions and some dsls that allow you to work more easily with expected in essence this was kind of a just smaller dsl right so i would say that there 80 percent as useful as in other languages with maybe a little bit more annoying syntax last one okay thank you everyone thank you [applause]