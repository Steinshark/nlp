uh today's live stream on linkedin is with greg law from undo thank you for coming greg i'm looking forward to your presentation about time travel debugging let's take it away excellent thanks jen thanks for having me yeah so actually if anybody's got any questions yet do you you know fire them off during the talk i'm quite happy actually always happiest if we you know take a little bit of a a tour around and do it kind of in an interactive style so yeah questions are good right that's let's crack on so this chapter sir morris wilkes i think he has as good a claim as anybody to being the world's first professional programmer right the first person to write code on what you'd recognize as a computer of stored memory pro stored stored program computer and which is doing it to do a real thing right rather than just like prove this prototype machine actually worked it was actually solving a real problem so i think as i say good claims anybody to be the world's first programmer and he says in his memoirs that he remembers that moment when he realized that a good part of the remainder of my life was going to be spent finding errors in my own programs and i that resonates with me i've got to say i think of a lot of people at that moment when you start programming you kind of get bitten by and bitten by the bug just to use some confusing terminology but and and you realize it's just it's really hard to get it worked now did it work now of course the term debugging bugs and debugging hadn't been invented at this point this was invented by grace hopper when when she found in the back of her machine an actual bug a moth that was causing them that was the cause of the failure that they were investigating actually that story is not quite true so i like i never pass up the opportunity to be a pendant and it it turns out that debugging predates that by a long way and actually you can see here on the right is a copy of the a picture of the log book where that instance happened and you can see underneath where the moth is sticky taped into the logbook you can see underneath it says first actual case of a bug being found right so that doesn't make sense right first actual case of a bug that doesn't make sense unless it's already a term and this is a basically a joke it's humor right and in fact that debugging goes goes back at least 50 years before it turns up in edison's log books and he's debugging his his his inventions but i think it really became popularized with computer programming because it's just such a such a big part of programming right i mean if you think about it just for a moment how how many lines of code do you think would you back yourself to write and and and have it work you know have it work first time you know 10 maybe if it's quite simple and you and and you really think 20 and maybe maybe you're a better programmer than i am but i i you know in my experience 10 lines of code it doesn't work first time in practice right and even also actually i think how many lines of code can you change and have it work first time i actually i think that number is less than one you know it just just it's really debugging dominates in fact programming is sometimes said there's two parts to programming there's bugging and debugging there's writing the code typing the code in and making it work so computer's hard debugging is just this this that completely dominate software development but we don't really talk about it very much right it's kind of accepted it's a bit of a dirty secret perhaps and you know we just kind of get on with it but another another good quote here from this is from another very smart man brian kernaghan says you probably heard this is quite a well-known quote it says everyone knows that debugging is twice as hard as writing a program in the first place so if you're as clever as you can be when you write it how will you ever debug it now really saying here is you know keep it simple give yourself you know margin for error don't try and be as smart as you can be well i think there's an interesting corollary to this right if you take this as true and i think it is true then what this means is that debugability is the limiting factor in software development right so whatever your metric for good is in your program maybe it's how fast it runs or how extensible it is or how quickly you can write it or how small small it is whatever your metrics for good then if you make if the program is twice as debuggable then it can be twice as good right because it's this it's this limiting factor so i think we don't spend nearly enough time you know thinking about this and investing in tooling and skills and and everything to make us to make us better in practice you know if you think about how do we debug most of the time right you know given that if you know most of programmers time is spent debugging what are they doing well maybe we can we got you know pretty cool tools these days like the dynamic checkers like valgrind or the sanitizers you know very handy and sometimes very useful right but i'm not talking here about how how often do you how often do you run this like inside your ci or something maybe you've got some checkers in your in your ci pipeline that's good practice we certainly do it undo and very useful they are too but i'm talking about debugging i'm talking about my program's got a problem it's not doing what i wanted it to do and i'm trying to figure out why okay and in that process yeah you know maybe i suspect some stack overflow or something and i'm going to run it through valgrind and see if i get see if it gives me some a clue but for most people not very often right this is this is like you know [music] i think you'd measure this in like a few times per year tops most people actually i suspect it's a few times you know per decade or something right so so very useful but not used that much now debuggers gdb or visual studio whatever your favorite debugger is i think get used more frequently but still actually infrequently i think for most people once a month maybe if that right few times a year it depends some people use them as a matter of course but most people i think in my experience most of all turn to debugger relatively infrequently what do programmers do every single day i add more print tests right we add printf we run again we get some more information and you know this really hasn't developed either you know from the first programs that were were being written or indeed from the first time we programmed right if you can remember back when you first started programming and it didn't do what you wanted it to do you know yeah you start adding print tests and that's what most of us do most of the time and why why is that i think there's a couple of reasons for it and one actually slightly uh provocatively perhaps i think there's an element of laziness to this right at the printer if i recompile i run it again okay get a bit more information now i have to add another but not enough so but i've got a clue so i had another printf and another printf and i can kind of feel good about myself and not i'm yeah i'm working hard right i'm not slacking off i'm working hard but i'm not really thinking hard i'm just in this kind of going through the motions almost and and i think it's kind of it's kind of the programmer's equivalent of just reading email right people you can just read your email and feel like you're being efficient but actually you're not really doing anything print hefty plugin can be like that i think but i don't think that's the whole story right i think there are the reasons why printf debugging is so popular and i think a large part of it actually is when we're debugging it's really what it's a process of trying to think and figure out how did that happen right i don't mean like how did that happen or how did that happen i mean i mean i had some expectations of what my program was going to do when when it ran right and at some point reality diverged from those expectations and i got a different result maybe i've got an assertion failure maybe you know it crashed with a segway maybe it gave me bad results or ran too slowly it's not just the program didn't behave in the way that i expected and the process of debugging of course is thinking back from where i observe the difference back to where is the root cause where does it where does reality diverge from my expectations of course usually it's more like that and it can be that you go through a very kind of circuitous circuitous route if i can say that to uh you know to track back in some unexpected ways and this is really part of what makes debugging hard right often the bug itself happens a relatively long time might be just milliseconds but a long time in computer world the the bug between the bug and you noticing this is why assertions are very useful right because they basically they they reduce that window and they're reduced that time the longer you have to think back in time the harder it is but printf is good right because printf tells you what happened it's exactly what it's doing the debugger doesn't do that right i mean and the dynamic checker not really either i mean dynamic checker sort of says okay this set of i've got a hand kind of set of bad things and none of them happened right or maybe yeah one of my set fixed set of bad things happened here but it doesn't tell me what the program did right in the way that printf does and even the debugger not really very usefully i think you can sometimes i think you can think of the debugger as i i sometimes think of it as a bit like the these the the film the cinematography style that got popularized i think by the by the first matrix film where you know that everything freezes and then the camera kind of pans around 360 degrees and you can see you know the bullet kind of in mid-air as it's flying through the air from different angles that's what a debugger does it lets you lets you freeze time and let you look at you know anything any piece of your program state you can look from any angle of what's going on and you can maybe step forwards you know one frame very slow motion or you can just run forwards again at full speed but it doesn't tell you what happened right it tells you what's happening so princess kind of good but obviously printf is the limitations of printf are pretty obvious in particular you know usually you don't print what you need you're printing out you're necessarily printing out a tiny fraction of everything that the program has done right the computer's issuing billions of instructions every second even if you're pregnant with being very noisy and printing you know 100 messages a thousand messages a second it's still a tiny fraction of what's going on right so you have to get pretty lucky or be pretty smart for what you need to be in that log so what we want is both worlds we want the view of what happened and we want the ability to see everything to move that camera around 360 degrees look at any angle any piece of state and that's that's what we're going to get to so billions of instructions a second we're looking for that you know the ultimate needle in a haystack challenge what we want is the equivalent of a metal detector to help us and that's what time travel debugging is right it gives us the ability to wind the wind the tape back to any point in the program's execution literally any line of code that executed and c any piece of state this here you probably recognize this is from hg wells is the time machine or the film of and unlike many of the later time travel sci-fi stories which i'm kind of interested in what happens if i can go back in history and change time in in the time machine he's more kind of passive right he's an observer and what's going on and that's what we're talking about here so we're not talking about the ability to go back in time and change something and run forward on a new on a new timeline because that you know that famously you know there are paradoxes when you try and do that right and everything gets very complicated and uh it's actually not what you want what you want is to be able to know how did that happen so being able to go back in time and observe is exactly what you want and exactly what time travel debugger gives you so let's show you what this looks like in practice i'm going to show a couple of examples let me try and get a text message to some whoopsie i didn't do what i wanted i've got a text nice and big from leonard catova like what languages do we could you use with those tools we are presenting yeah i mean i think time travel time travel debugging is is i think it's an idea whose time has come and it's available right i mean there's a quite a few languages that that are supported so c plus absolutely and that's kind of you know the the context of this meetup right and c and assembly code anything actually the gdb can debug can be time travel debugged so rust fortran ada and there's also uh time triple debugging solutions for java for c-sharp on the windows platform and for um and and even for javascript so the front end you know web applications so there's a number of different languages now that have support for time travel debugging not everything but you know chances are there's something out there that will work for you i'll give it i've got a slide later on where i'll give a brief taxonomy of those again so so that should hopefully make it a bit clearer but let's do a little little demo of this then right so i've got here a programs about little bubble sort program and it looks like this right it's just it's a classic bubble sort implementation and the main function gets just takes an array puts random data in it and then sorts it and that's it and this is the program here it doesn't print anything on the screen just get some random data and sort it but look at that there's a bug there's a a there's an intermittent bug here actually this failed pretty early on it usually takes a few more goes than that but okay i've got an intermittent bug and it's created a core file so let's have a look what's that course file so that's this one here so what do we do we load that up into gdb right and and what do we do when we load a core file into 2db almost always the first thing you do when you load a core file into gdb is you ask for a batteries because what you want to know is what happened how did i get here right sometimes you get that kind of experience okay my back trace is garbage i i do have debug information in this so i know i do but i've got a i've got a a smashed stack now that obviously is a thing that can happen more often when you get a core file and you get a back trace the back phrase works but it doesn't contain the information that you need because it's a tiny sliver you know it's a tiny sliver of of of breadcrumbs of what the program did you so you can see it you know perhaps a dozen functions that it's been through but it doesn't tell me it doesn't tell me everything that happened so if i'm lucky i load my core file back trace oh yeah look i didn't you know check that pointer for null or something but but usually it's from you know if i'm usually the best i'll get is a clue and often i just get well that doesn't make any sense that's that phrase looks like either impossible that should never happen or looks fine but the snap but the core files everything about what the core file is here so the core file is a snapshot of the program state all the states with threads and the registers and everything but a snapshot of the program state at the point it crashed at the point it terminated right if i get a recording a time travel recording it's like that except it's got that full program state for all of history so let's try and do that so i'm going to use here a tool called rr rr stands for record and replay and it's an open source tool it's packaged with most of most distributions these days so it's probably there on your system and i can record it like that oh well i haven't we've rebooted my machine since i last gave this demo so it does rely on the performance counter as being available so we have to set so what we're going to do let's set uh echo one to sudo t that's that's just my password i think i want to miss that again oh it's hard to do your password when someone's watching isn't it right okay so this so i've now set up the system so that it's uh got the necessarily precise performance counters that rr depends on so we have let's have another go and don't look at that it failed first time but it usually doesn't right so but that one did fail first time i ran it so it's saving its execution trace there so rr replay that okay and what that does is give now this gives me look i'm an underscore starter so i'm right at the beginning of that program's execution and it's a recording of of everything that happened so i'm just going to continue this to the end okay and here we are when we've got our sec fault and if i go back grace yeah this you know okay slightly different batteries but still messed up so just like before but i've now got time travel so what i'm able to do is reverse step i okay so step i in gdb steps you forward one instruction reverse step i steps you back one instruction okay i just need to do that that's when the segment fee was received so i just need to do that once again and here i am now i've got a back race i'm only actually only at main i'm going to go layout source so we can see a little bit more easily what's going on so yeah so look i'm at the return from maine this is kind of i suppose vaguely what you'd expect right if i've if i've ruined the stack let's look at the let's look at the disassembly code here so oh that wasn't a very good view i'm just gonna go back into that disassembly so here's my main function and here's you can see from gdb here i am this is the little arrow here talking about this instruction i am indeed at the ret instruction so ret on x86 it will take what the stack pointer points to and branch to that right so it's a full descending stack so if i print there are smarter ways to do this but this will do if i print the stack pointer sorry sprint what's at the stack pointer that's what's at the top of the stack so if i were to try to look at that memory that's where we're returning to yeah it's boga to dress right i'm trying to return to it looks like it might be hex or some ascii or something that rather than the pointer whatever it is it's not a valid address so right so i've got garbage on my stack right someone's written into my stack and and i need to know like when did that happen now this is a very very small program just for demo purposes but i'm sure you've been there before with a more real program and it's really hard to know but what i can do here is so stack pointer is that so if i put a watch point and i'm gonna watch the top of the stack i'm going to watch that address okay now watch point something's called data breakpoint what it lets you just run the program until data changes which is it's a niche feature can be useful sometimes with time travel debugging this is like a killer feature right because you might be one step ahead of me or behind me here what i'm going to do is not continue until the data changes i'm going to reverse i'm going to i'm going to run backwards until the data changes and that will be the line of code that rose recently wrote to my stack right that's what i care about so reverse continue gosh right i've gone back in time i've gone back here look what's going on we're writing into this array that's writing into my array on the stack so that's not like super surprising we're writing into the ice element i is 35 that is kind of surprising because array is only 32 elements long and of course the bug here is that i've got percent percent size of which is of course bites the size of the ram bytes not the size of their own elements so i'm just i'm just writing over the end of the array and that happens to be on my stack and so when i return i'm returning to to garbage so tiny little program you could probably just stare at the lines of code for five minutes and and spot this but you can see hopefully how that will be very very useful in much larger programs with much more real kind of bugs and i think an important point to make is most of these time travel technologies do scale so i mean rr was basically invented to debug firefox and you know it does work on on programs of that scale you know our own stuff live recorder we we work on with programs that are sometimes terabytes literally terabytes of working set and literally days of runtime in extremists right and and yeah modern time travel debuggers do do scale the microsoft time travel debugger is used extensively by microsoft by the core teams by like the sql server team and the office team and and people like that so and you can see hopefully how that's very very useful i want to show you one more demo now that's still a bit of a toy program but it is could give you a sense of how it could be usefully integrated into into the workflow so i'm going to switch to okay right so greg yeah so one question like is like time travel debugging as a package comes that with gdb automatically or is are the tool you just showed do you need to install that rr is a separate tool there is some time travel debugging in gdb automatically but it's it's really good only for very small programs it's very very slow and it's not super well maintained so the thing called process record so i could just start gdb normally and i'll show you very quickly so if you start pdp normally like this start and i can enter this command record and then once i've done record i can do that and i can go reverse down okay yeah so so you can just do that yeah you can just do that but it's very slow and not super well maintained so if you do any some modern like evx type instructions which libsy will do it'll stop at that point so you really probably want rr or uh or life recorder or one of our sort of separate tools time travel debugging is built into the microsoft win dgb in dbg product so it's a bit more kind of standard there okay all right so so this this is a pull request on our actually on our internal github at undo that i made and like every pull request i made i have a make it has some failures so so i can't run more i can't write more than a few lines of code without creating a bug as discussed this one was deliberate but so when paul made a pull request it kicked off some tests to jenkins as normally happens right this is all pretty standard so some of those tests failed i can click through here and i can look at the best results and here we have the log of that test failure so this is like very normal right i mean the details are different but but the but the concept probably you're you're familiar with so here's the program here's some logs oh look here's an assertion failure and then there's some more stuff and there's back traces and but you know what i'm not going to go through all of this because i can tell you there's not any there's not enough information here to root cause this box sometimes when i get a failure and jenkins i can look in the log and i get enough information to to record the bug at that point but that is the not the common case right but what we have here in this and this jenkins is this thing called observatory so i'm going to just follow that link and this has got a bunch of artifacts some of these are recordings so here's a recording of that test that failed so click on that it's going to launch it up what it's going to do is it's going to do quite a lot of work behind the scenes it's going to provision a machine get the replay session on that machine and it's going to get the right version of the source code you know the the the that you know git version that was associated with that run it's going to get any artifacts from from their logs things like that and critic is going to load up this recording and this will just take me a few seconds and it's going to dump me in there so just by that single click 30 seconds the system goes off and does what it needs to do to get everything together so that i don't need to do what you normally need to do when investigating a desk failure which is the first thing you generally need to do is try and reproduce it well i don't need to reproduce anything here i'm just i've just dived straight into the recording so here i am so an exception has occurred because you know this assertion has failed so it's saying square root cash is zero and the correct value is 15 so hence the assertion has failed this by the way if you you might notice this is this is vs code this is a vs code interface running in the browser so i've got my call stack here on the left actually what this shows me is this is a multi-threaded program lots of threads thread number 10 is the one where the assertion has fired and actually you can see here from the call stack so vs code is kind of nice and puts you at the at the last line of code last line where you have debug information for the source code but it's actually deep inside the c library because that's what happens when an assertion fails why don't you go end up inside a board and then inside raise so that's fine we've recorded all of that we can record down to the instruction level so i'm going to hit this button here this reverse step out kind of uncalled button and watch the watch the stack as i do this and it's kind of like popping up the stack well you're probably thinking so what because you can always do that in even in a core file right but it's not the same as popping up the stack in a core file because it's really unwinding the execution all my globals and everything else go back to what they were it's not a guess about where i've been that's really is here as i saw in the last demo i can do that when i don't have a but anyway reverse back into my code here and we can see we've got all the data here and i'm going to do so this is like super cool here right so i've got my reverse step just like the step buttons that you're probably familiar with this has got a reverse tab when i click this we're going to go back one line right exactly one line and by the way watch the data up here in the top left because that will change as well so right they've also have gone back a line and only one piece of data changed at one variable change because that's anyone that that got changed yeah that's where it correct now what's going on so let's just have a big more look at what's going on so it's got this cash calculator i've passed it in number of 255 and it's returned zero and it what it was supposed to return is is square root correct it's supposed to return 15. supposed to return a square root right the square root of 255 is not zero so cash calculates return the wrong thing i need to know why did that happen right now you know this is a nice little example of where the core file that information is gone i can't go back i can't traverse the cool tree right other than just going directly up but this is time travel so i can here so here i go so i'm going to hit this button here we're going to reverse step into cash calculate so we can see why did it do what it did okay so here we are look it's returning this is how cash calculate returns it returns in the cache returns the ith entry in the cache i is 90. so i can have a look at that what's the 90th entry in the cache tells me the square root of 255 is zero so my cash is in a bad state and that's why that's why it's returned the wrong answer and so now i need to find out yeah why why how did that happen well it's a threaded program and i can see here i've got a lock and so yeah that's suspicious isn't it i mean that doesn't look obviously wrong but maybe there's a problem so what i'm going to do is back up back back back to there so this is just before this line of code executed so at this point the structure is locked right still it's telling me the square root of 255 is zero so yeah it doesn't look like anything obviously wrong with threads so well you know what i'm going to do is i'm just going to get that next off the screen so we've got a command here available in obviously called last which is a little bit like a contraction of a concatenation of what's point and reverse continue but i can go back to it's a little bit more convenient so i want to know when did that entry in the cache change so if i just go last gcash 90 it goes back in time to when that line when that cat was updated right it's the line of code that most recently wrote into my cache and so right so okay i'm writing square root adjacent and number adjacent into the cache i'm actually midway through updating the cache right because at the beginning of this line 45 so i can just go forward align that the cache is updated yeah that's the bad data right and if i step back to before that cache was updated okay so here the cache contains good data right the square root with integers of 40 is 6. if i step forwards this is kind of like you know action replay watching sports on the tv watch the data watch the data here as i step this forward step step that's it that's the corruption being happening right there writing into the cache what's so what's what gives why is it writing garbage was writing number adjacent which is negative one and it's square root which is nonsense because you can't take the square root of negative one so y is a number adjacent negative one that's not what i expected well i can just do ignore the numbers on the screen there that's a bug we need to fix but anyway so i can do last number of data to find out widest number of data contain negative one okay it's here it's being set number minus one and number here i can see is zero right so cash calculator got called they did the right thing got called within a parameter an argument of zero it returns zero but it updated the cache and it updated one entry either side on the basis some kind of locality of reference and so one of them was negative one and was garbage and my program didn't notice for quite a long time later and and when it tripped over the bad result and the assertion fired so again a small program just suitable for a demo but this is actually a canned demo of a real world a nice case study of time travel debugging where one of our customers cadence the chip design software people they have very complex software very long run times and one of their one of their customers was experiencing a problem where the soft cadence's software was crashing one run in 300 after about eight hours of execution and this is just a nightmare and every time it did crash it crashed in a different way it was a major problem for that customer because it sort of was disrupting their flow i mean it meant they couldn't you know tape out their chip and you know phone wouldn't hit the shelves in time for christmas or whatever so cadence had their software engineers on site with that customer for three months trying to get to the bottom of it right naked looking at core files every time they could load up a call file there was a negative one where there should have been a pointer but it was always in a different place there was just nothing to to to go on they couldn't find out where this minus one was being written into the in into their data and so that's when they turned to time travel debugging and they ran it with live recorder just set it up actually over the weekend actually won a bunch of machines just running again and again because took eight hours and only failed one running 300. but when i came in on monday a couple of them had failed and so they took one of those recordings put a watch point on that negative one just like i did here reverse back and they had it nailed in three hours so they went from three months to three hours actually they went from infinite time so we're getting nowhere after three months to three hours so that's a nice example of the power of time travel debugging but i think if you integrate it with your ci as i've just showed here yeah that's perhaps less high profile examples but if you routinely turning you know an afternoon debug session into 10 minutes and you just keep doing that the kind of compounding value of that is i think in some ways even more significant than those amazing sort of months or years down to hours cases foreign so that's those are the demos that i wanted to show let me go back to some slides over there here aren't i and yeah that's a question yeah so are there any similar tools like rr but for bare metal systems so like do you have customers to use your system on embedded or like you know right right so that so so there are for bare metal but now you need because you don't have kind of the the layers of os and everything else to help you you need to you need the hardware to help you here so green hills have a product called time machine and louder back have their debugger which will work with if you're your system has to support it so you need an arm chip with the embedded trace macro cell and there may be others i don't know about other designs but if it's arm it needs something better trace macro cell and i think you need to have the i don't know the details of this so it's not my field but you need to have sort of i don't know the jtag sort of appropriately you know that you can get at and things but if you've got everything that you need you can then get the loud back debugger or the or the time machine debugger from and and time travel debug at the at the hardware level yeah yeah and then and it's very good by the way and it runs you know like pretty much full speed and you get full kind of visibility so there are different flavors of it so depending on which exactly which kind of uh embedded trace macro cell you have i think you don't necessarily get the data but if you've got the kind of top of the range ones you do get the data as well as the program counter information foreign can we use this tool on other custom linux distributions yeah yeah so so so i showed two tools when i showed rr and i showed live recorder which is my own company's tool rr is a little bit more kind of it has requirements about has to have access particularly to the performance counters it needs se comp and a few other things of the kernel so so it does have quite kind of strict requirements but if all those are there then you know and and you've got a suitable cpu and so you need an intel or one of the very recent amd cpus that supports performance counters with the appropriate with the appropriate kind of precision but if you've got all that then then yeah it'll work our own product live recorder is a little bit less kind of fussy about where it runs because it's a it's a it's it doesn't rely on on those hardware features so or in any advanced kernel features so that will run on most and even quite cut down kernels and then the other really nice thing is you can take these recordings and and and replay them on a completely different system uh you know you can take it on a customized embedded linux and replay it on your ubuntu running on your laptop for example so yeah i talked about these earlier to the earlier question the different kind of flavors that are available so we just saw a live recorder in the demo there and we saw rr as well i showed very briefly gdp process record i talked a bit about microsoft time travel debugging solutions and also there's a company called rev debug it does java for windows and i mentioned replay.io as well for that sort of front end javascript time travel debugging i'm just going to go on to just talk a little bit well just before i do that actually yes so so time travel debugging is i think that's kind of the terminology that that everyone's kind of converging on this so the concepts here are kind of new and you know everyone's been kind of settling on what to call it so over the last few years people put in reversible debugging by directional debugging replay debugging in the world is kind of standardizing on time travel debugging is the right term for this they're all basically the same thing so let me just talk a couple of minutes about how how we implemented this and how tools like rr and microsoft td and others actually work because it's quite and i think quite interesting you know technical challenge right so we as i said earlier debugging is about what happened so i'm going to step back in time right but another way of saying perhaps slightly more precise way of asking what happened is what was the previous state i've got my program you know like i've got i've stopped my program inside the debugger and i want to know what the previous state of it was like a previous instruction or line of code that executed so how do i go how do i do that how do i go back to the previous state well there's two ways that you can do this right one is i can just save the previous date so then i can restore it now clearly i'm not going to like save the entire program state for every single instruction that executes because that would just be enormous and completely impractical but i could just save the delta right which is a very common technique sort of mpeg style i'm just going to change what what what change between this store what change between this instruction and the previous instruction and then i can reconstruct those previous dates by going and applying those changes that i've saved kind of in reverse and that's actually that's what gdb process record does it's still really slow and consumes loads of memory because you've just be back to this thing that the computer's doing billions of things every second so if i'm saving even though i'm just saving you know this registered update or every instruction i mean something's going to change every instruction right otherwise think about it otherwise i'm in an infinite loop just branching back to my to myself so something's going to change every instruction so that's going to be four bytes i mean at least several bits every introduction so billions you know gigabytes gigabytes of data saved per second of execution and and also it goes really slowly because it's just a lot of work to do between every single instruction so saving it is it works but it doesn't scale really is the problem so better to recompute it right i want to work out what my previous state was trouble is i can't just apply logic in reverse that doesn't work right if we've got a statement like this that's a reversible statement if i know if i've just executed that statement and a contains 42 and i know that the previous state a contained 41 right but that's not a reversible statement if i've just executed that statement and a and b both contain 42 i have no idea what a was before right that information like doesn't exist in the universe anymore but what we can do because we can't run a computer programs backwards but what we can do is rerun them we can run them again and try and make it make sure that it does the same thing the next time i run it right so we use this kind of snapshot and replay technique so when in the demos i'm going back a line of code what actually is happening is it's going back to a snapshot and playing it forward to just you know right before where it previously was and that gives me the illusion of stepping back through time and so and this works because computers are naturally deterministic things right if i take a program and give it the same starting state and give it the same inputs as it runs it will always do the same thing this is why random numbers are difficult to generate right because the catch is that the programs that are computers are deterministic except when they're not except when i've got any kind of the cat i just said that throw away statement i've got to feed it the same set of inputs as it runs and so that might be input to the network it might be from the user it might be timing things there are other non-deterministic stimuli particularly around threads and thread scheduling that's particularly challenging might be reading from shared memory and there's some instructions that are non-deterministic and if i add two numbers together and then the same two numbers i always get the same result if i do a read the timestamp counter i get a different result each time any kind of system call my life could get a different result in fact if i could predict the results of a system call based on what my program stage was then it probably shouldn't be a system called right should be a library function so i've got these certain things which are a real minority they're like 0.001 or something of the instructions most of the instructions of the program executes are you know add these two numbers together move this thing over here jump over there and they're all completely deterministic but just the very very few that are not we need to store those in an event log and then we can replay them and as we do so we can guarantee the program follows exactly the same exactly the same path and uh that's really that's the trick to this this is how how most of these tools work some variation on that so we need to store all these non-deterministic events which how many there are will depend entirely on what your program is doing if you're calculating pi to a billion decimal places then there'll be very few external events that you need to store in the event log if you're reading you know uncompressed high definition video then there's going to be a lot so it depends to tell you what the program is doing but typically the recordings that get generated kind of just a rough kind of rule of thumb typically it's like a few a few megabytes per second of recording so it's pretty efficient right these recordings tend to be on the order of where i don't mean one to ten one to 100 gigabytes is is probably the normal range i see them much smaller i see them much larger but that's kind of typical kind of range so they're quite you know you're probably not going to put these as an email attachment and send them but they're pretty manageable pretty manageable things just a quick plug for my gdp watch point tutorial a whole bunch of like five minute one minute videos on little tricks and tips with just regular gdb so hopefully that's useful for at least some of you any any more questions yeah that'd be a good question if there's any more questions i don't see any more questions in the chat right now but let's give people some time to type thank you greg what's a great presentation thank you very much and so yeah so if you have any questions type them in the chat and otherwise greg is available on linkedin and probably if you'll post later questions into the chat back if you if you actually watch the video and mentioned greg greg probably will come around and answer your question on linkedin and so far i don't see any new questions in the chat so that was an awesome presentation and life demo not easy to do thanks for doing and there's anything else yeah no it was good thank you for thank you for letting me talk about this stuff and and there were some nice questions as we as we went as well yeah one thing one person asked about courses online and that might be a good question like does undo have courses or like you know video series and etc like where you learn more about this yeah yeah so we do as you can see here undo.io resources gdp watch point so there's a bunch of stuff there that's on regular gdb a whole bunch of trading materials on on time travel debugging as well so yeah there's a bunch of stuff on the website and we do also do training to companies of you know sort of in-person in-person training sessions as well so if you're interested in that then probably the best things you can just email to sales at undo.io and there'll be they'll they'll connect you with the right person okay there's right now a question in the chat how effective would it be an empty and i think empty is moody threading very yeah i mean the demo the second demo i gave that was a multi-threaded program right it wasn't a much really bug but it was it wasn't really program one of the main use cases for this is diagnosing difficult race conditions right the the thing that makes the thing that makes bugs difficult is well there's there's i think it's two axes for difficulty says how long is it between the bug itself and me noticing recession failing or whatever on one axis and on the other axis it's sort of how repeatable is it does it always fail in the same way or does it fail in different way each time and when you get a kind of combination of those things long time between the bug and the kind of notification of the failure and it's non-deterministic it's non-repeatable then those are really really hard to debug right this is where print i mean printf really lets you down here because you know yeah it gives you a few of what one run of the program did but you had any print tests and the program does something different and so time travel debugging is super useful yeah that's really where it's most powerful where the bugs are the hardest and race conditions are a very that's kind of true of almost all race conditions right they're almost always non-repeatable and you usually don't notice something's gone wrong until sometime afterwards so yeah time so diagnosing race conditions is like one of the main use cases for time travel debugging i would say and one question i was just wondering about your writing a time travel debugger have you used your own like your own time travel debugger when when writing your time travel all the time absolutely yeah yeah so yeah a big fan of the dog food right and i showed you that was the second demo i did that was actually our internal ci system and and you could see you know we've been automatically generating recordings when tests fail so that our engineers can step through so yeah it can might slightly make your mind you know to sort of can be a bit of a bit of a head because you sort of i'm i'm debugging the debugger but yeah you know it happens happens all the time and and in fact we even have this is less common but sometimes sometimes we've found that so so i our own code is actually quite a good test case right it's quite it does a lot of stuff shared memory and it's asynchronous and there's multi-threading going on and generally it's a very good kind of test case workload for our own software right so it took us some time took us quite a few years before the technology was advanced enough that we could eat our own dog food it was one of the because kind of one of the last programs that we could record because it just does everything and at that point it was you know that that was um you know that was that kind of just massive improvement in our internal productivity when we could we could we could debug our own stuff and we occasionally have had you occasionally get a problem where we've got probably another thing so we record so we so we record live recorder and the recording of live recorder goes wrong for some different way like this happens much less often these days thankfully but but still a very occasionally can happen so there have been occasions where i've got a recording of live recorder that's recording live recorder i've never had to go more than three levels of three levels of recursion but you know in theory you can you could keep going okay that was an interesting story and with that i think we're through and great matter for the next meeting at the four points so thank you for your attention thank you for coming and thank you for you know just making this possible kind of you know the first time we're actually live on linkedin was a guest thank you greg excuse me so so if you have any more questions like this post them right under the chat and andrew probably will take care of that and with that we're going to enter the live stream thank you to undo thank you to greg and all the others in the chat thanks again thanks everyone