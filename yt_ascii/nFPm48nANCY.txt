so this is a language in which everybody tells me i must learn by the way i just turned off alerts so suck it youtube okay suck on that but this is the language i get probably the most amount of heresing to learn is nim it's either nimber odin and those two just seem to be the most popular but man do i get a lot of nim gang nim nim nim nim nim nim gangnam game like it's just constant the nim team is proud and happy to announce nim 2.0 man rust seething right now they can't 2.0 they you know there's talks about it but they can't do it cope and sees people this is an evolution not a revolution of nim bringing orc what why are there orcs orc memory management as a default what is orc memory management like i know what arcs are i know what rc's are but what's an orc what's the o stand for i assume it's something reference count oracle okay so it's an oracle reference counter object relational crap not sure what any of that means anyways this it seems seems exciting memory management as default along with many other new features and improvements nim is a programming language that is good for everything but not for everybody it focuses on imperative programming paradigm and enhances it with macro system so i actually really like this because i mean ultimately in the end i know procedural code is just really easy it can be very awful sometimes but i i end up enjoying it you know for whatever reason i always end up enjoying it the most it's customizable memory management makes it well suited for unforgiving domains such as hard or real-time systems and system programmings in general all right and so we have a little installing we won't sorry installing neovan or nim if you want to donating to nim hey check this out they take bitcoin or open collective go give them some money so new features let's do this again i've always wanted to learn this language i've just never taken the time to learn it okay tuple unpacking for variables is now treated as syntax sugar that directly expands into multiple assignments along with this tuple unpacking for variables can now be nested oh cool so here's a tuple obviously uh this is a foreple and in the four-pole the first position has a tuple in it oh cool hey cool i could like that could you like that i could like that improved type inference a new form of type reference called top down inference okay but when are we gonna get middle out inference okay i'm sick and tired of this hindley milner hindley milner inference or typescript in france but now we got top down inference i want middle out okay if you can't find the lowest distance between two points of inferencing what are you really even doing has been implemented for a variety of basic cases for example code like this now compiles okay let's see it a foo which is a sequence of float bite c string is this right here okay cool there must have been this little ad symbol or something must have just been something else forbidden tags oh i love anything that's forbidden tag tracking now supports the definition of forbidden tags by dot forbids pragma which is used to disable certain effects in proc types so for example you have this whole like type io we can read read line tags io discard echoline void no i o please forbids io oh interesting so something i see right away that's kind of cool over this notion right right away something that i think is kind of neat about that is that like imagine you had some some really speedy some really hot functions going on some just hot hansel hot and you want to ensure that they don't do certain operations you could imagine that you could tag certain things and just say hey you're not allowed to use these tags within this function because it's so hot right now it's hansel hot there's something kind of cool about that right it's useful for teens exactly that's what i was about to say this seems actually really useful for a team because you could you could imagine that you just come to a point of a piece of code you've never seen before it's just sitting there and you're like okay i don't what am i looking at what do you ask me to do you have to do a small bug fix so you just start putting stuff in it and you don't realize that you're about to like downgrade the entire system because you're in the hottest function so hot forbid give intern forbid code yeah that could be a good one all right i like that that's actually a pretty cool idea i mean i like it for communication purposes very very neat new standard library modules the famous os module got an overhaul several of its features are available under a new interface that produces path abstractions a path is a distinct string which improves the type safety when dealing with paths files and directories all right so you got a bunch of new stuff coming out okay i like that overloaded enums overloadable enums are no longer experimental for example enum value one enum value two okay i'm not really sure what i'm looking at here what does this mean the types e1 and e2 share the names value one and value two they are overloaded and usually overload disambiguation is used so that e1 and e2 prefixes can be left out in many cases okay you get you give it the same shape okay so the point is you give it the same shape so you don't have to do e1 dot this it just works you can just do that and it goes i already know i i get it i get it these features are most beneficial for independently developed libraries okay okay interesting weird i know it's a super weird language but people just non-stop talk about this you've always had the prefix the edoms with their type name yeah so this just this just allows that to effectively not happen okay default values for objects inside an object declaration fields can now have default values relational object okay cool so it can be an ant here's the default value perfect you get this thing you get a new relational boom you got that okay good i like i like that i like default values default values are really cool it's kind of it's kind of exciting doug typing in my compiled language what the yeah it's happening definitely a definite assignment analysis we found nim's default initialization rule has been one of the major source of bugs there's a new experimental switch called strict defs that protects against these bugs when enabled it enforces that a variable has been given a value explicitly before the variable can be used oh very cool oh awesome okay that's great i love that i love that perfect so it's just good linting right there building good linting into the system i love to see that let's see to turn the warning into an area used warning as air on a knit on okay cool cool the out the analysis understands basic control flow so the so following works because every possible code path signs are before it is used nice okay cool i love that because this is such an annoying thing when you get into when you get into conditions where like my least favorite part about typescript is when you're in a for loop and you have to index into the thing you're using and you check to see if the index item is there but then right afterwards you can't continue to use the indexed item so i wonder if this works in the same the same kind of concept can an indexed item work because i does not change i don't know it'd be cool to it'd be cool to find out because it always makes me just so frustrated even better this feature works with let variables too all right let rational this this okay cool it is checked that every lead variable is assigned a value exactly once perfect i do like that that is a cool feature so a let variable if i'm reading this correctly a let variable is something that can only be assigned once it's effectively a const but you don't have to define it in place you can do something like this i can dig i always wanted that that's one of those things that i've always wanted because i always have like i need to assign a value and there's like a bunch of things i might have to do to do something obviously something like oh camera rust kind of gets around it because expressions can return stuff but javascript you can't do it right so if you have a bunch of if state like you can't do that in javascript isn't that just a standard ml derived like yes yes but i'm just saying that there's like this thing that happens that it's just you can think of it as a runtime cons cool side effects sword pointer to t right so i just see this as soy sort a pointer to an array t all right all right here the let's see the meaning here is that sword has an effect has effects of compare sort and can raise exceptions comp proc this and closure orders yeah nim seems too strange for me to try to understand i'm trying to understand it but i you know obviously only looking at it for 10 seconds it's really hard to understand improved error message for a tight mismatch okay foo four produces let's see oh oh you got overloading in this language okay so you got overloading in this language and it says hey type mismatch you can't do this at least it's good it's good error messages right it's good error messages i like that oh star is not a pointer it's a declaration of public function oh okay okay consistent underscore handling the underscore identifier is now generally let's see is now generally not added to a scope when used as the name of a definition while this was the case for a variables it is now also the case for routine parameters generic parameters routine declarations type declarations etc this means the following code does not compile all right foo plus one why would you do this see whereas the following code does compile okay oh so you can no longer you can why doesn't this compile i'm let's see so this does this this this doesn't work because you can't do this right this doesn't work because you can't do this but this is fine it's this that's not fine is that what it's saying you just gotta look at code you got to generalize you got to kind of just it just you know work through a problem try to like try to argue with yourself why something doesn't doesn't you know it's good for the brain it's good for the brain to try to see things in a different light right javascript code gen improvement javascript backend now uses big in for 64 integer types a bigint is the bane in my life it you cannot jason stringify and parse begins which is just like the devil it's just the devil as this affects js code generation code using the types to interface with js backend may need to be able to update note that int and huint are not affected okay for compatibility with platforms that do not support big in the case of potential bugs with this new implementation the old behavior is still currently supported on the command line option that okay so you got some doc coaching very cool i don't think we care about docs we don't write docs around here c plus plus interrupt enhancements okay this is actually pretty cool nim takes the c plus interop to the next level with a new virtual prachma and the extended constructor pragma now one can define constructors and virtual procs that map to c plus constructors and virtual methods allowing for further customization with interoperability this allows extended support for the cogen decimal decal pragma okay let's see what this is struct bass and okay okay we got to okay okay okay okay type bass we got this thing notice that we can access this inside the constructor what is going on here because this okay so like this this looks like we're doing some c plus plus up here this looks like some c plus plus up here but now we're actually taking this import c plus plus and you're just like literally interrupting with c plus plus while you're writing it and then feels like three languages in a trench coat a nym plus plus i i think that that's pretty cool for anyone that does all you know anyone that does a lot of c plus plus and they wish they had a language that was a little bit easier to write which here's the problem okay so i'm gonna be real here everyone that likes to do c plus doesn't want another language to use so i'm not really sure who like in all reality i'm not really sure who you're actually advertising this stuff to as far as i can tell people that like c plus like c plus plus when they build a new program they build it in c plus plus what about carbon yeah i mean i see i see people excited about it but i just doubt that carbon i mean i i really doubt that that's gonna take off but i got too messy but why i don't know that's i use odin now odin seems very exciting okay arc arc and orc refinements with a 2.0 release arc and orc model got redefined once again and now i've finally complete programmers now of control over the item was moved from state with this was moved override there's new hadoop hook which is more efficient than the old combination was moved hmm stuff seems i feel like nim is gonna take a a ton of understanding like if if you were to get into nim it seems like it takes a lot of understanding when i read all this stuff i always come down to the same problem which is what is being solved here you know like what why why would someone why would someone hear there has to be people that use nimin in in here yeah it doesn't feel like a normal language why do you use nim why do you use nim over using a language that's already been around and it was good for me to transfer from knowing python to something else a good stepping stone to using something else okay there's there's some dimmers that's that's what i learned 10 years ago writing links is fun but i feel like there's saturation in the space yeah i use nim to write exploits when i don't have a lot of time same reason why i use russ to brag about it yeah okay it's a it's a talk only language i like pain why use any other language than russ will have you heard my friend oh campbell i feel like nim's learning curve is worse than russ yeah you read the patch notes or read a tutorial i know i'm reading the patch notes why is there yet another one let's see you use it to get free trips to conferences odin campbell have you heard of have you heard of mike hamilton just no mike oh campbell not my your camel oh camels i haven't heard of a greyhound and a hot minute yeah i know it's here we're listening to it why are we learning oh camel probably the same reason for people to learn nim oh camel is having a very large and faster industry adoption right now it's in a very great place it's really primed to become a language that actually might it might become the first more mainstream functional language i think it actually has a chance because i don't think there's a mainstream functional language right now and what i mean by that is that if someone says haskell you know they're just it's not true scala f sharp f sharp is not mainstream elixir i don't think it's maybe elixir oh camel are probably pretty near each other but they're just not like it's not it's not elixir is pretty mainstream no it's not because that's the thing is i know virtually nobody that knows a functional programming language that means it's not mainstream everybody knows c based style languages like that's that that's a mainstream language elixir is growing it's not mainstream yet exactly elixir has potential to be the first yeah it's yeah it's mainstream for a very specific niche use group right you mean it's not web dev it's not just that it's not web dev it's typically not cli it's typically not this it's typically not that it's typically not servers right elixir has the greatest chance because right now elixir has a really good strong story around servers and i think they're kind of they're kind of winning oh campbell's a very practical functional language you can write imperative if you need to yeah so for me it has first off oh camel's the most amazing type system i've ever used in my lifetime it is fantastic notice that i virtue i haven't set a single type yet everything in this file is completely typed right because this thing is typed it knows that okay this thing is an option of int so therefore this is that so when i do the match it has to have some and none that means handle to do has to take in an id this means that handle to do has to return a dream response that's threaded and if it doesn't it means that when i try to return something else this thing is going to err right so if i go here and go right and i just go what is it five right i i suck at this kind of stuff how do you how do you stop a match statement see i'm still pretty new to this stuff begin and there we go there we go this see look at this it's already telling you this is supposed to have a certain expression but it's not having it therefore it's not it's not working your type is wrong here you're doing the wrong type but when i go this this beauty it goes no your type is now right it can now be used how it's supposed to be used and i just think that that's so fantastic it has such a strong typing system that it's incredible what's a strong use case i really like it for processing stuff i think it could become i think that it could become my new favorite cli language because right now i write a lot of cli applications and i could i i can find myself liking more and more using it for clis right was written to write compilers exactly it's like it's a very cli friendly language and so i keep seeing it over and over again that i'm like okay i'm gonna learn it and now that i'm starting to learn and i go this is fantastic and the thing about ocamel is that it has a really strong you know ecosystem right now it's actually shockingly strong so again it always comes back to the same thing nim what are you like is it because you like writing programming languages or are you solving a real thing like i think of odin odin is a language designed for game programming it's designed for graphics programming maybe it would be a better way to say it jai is another language designed specifically for a niche use case which means that it can be very very good what is nim's niche use case i don't know like i i don't i don't i have no idea and so that's what i want to see is what is the niche use case for this what are you trying to solve that can be solved better than any other language now when it comes to when it comes to game programming in odin odin just has like really amazing things and it's just this really great a tunable gc isn't isn't a use case right it's not something that's a huge win a tunable gc just makes a language that should be fast faster like go like if you can do an arena allocation and go you just made your program from 99 to 99.5 faster so that's cool but it's not a reason to switch from say go to nim does that make sense and the name is the imogen