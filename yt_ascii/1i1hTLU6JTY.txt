hi everyone in this episode i'd like to make it so that if you're standing on a slope that exceeds the maximum slope angle then you'll automatically slide down that slope so let's head over to the controller 2d class and here we've got these two floats max climb angle and max descend angle now i think it makes sense for these two always have the same value so i'm going to just simplify it into a single variable called max slope angle so i'll rename this to max slope angle and then i'll rename the other one as well with command r max slope angle and then we can just get rid of one of them and let's make this public as well so that it shows up in the inspector and then coming down to the move method we've got this bit of code that says if the player is moving downwards then we're going to handle descending slopes so let's jump over to that method and we can see that this code here is only worrying about slopes which are less than the max slope angle so what we want to do now is handle slopes that exceed the max slope angle so we're going to need a new raycast so let's create raycast hit 2d and let's call this max slope hit left all right so this is going to be equal to physics 2d do recast we want to cast from the bottom left of the player so we can use our raycast origins dot bottom left and for our direction that will be vector 2 do down and the distance will be however far down the player is moving in this frame so move amount doy and we want to get the absolute value of that since this is supposed to be the distance and like always we'll add our small skin width value to that and then we want to use our collision mask so that is just collision mask all right now because we don't know which way this slope is fac faing if it's you know a slope like this or like that we're going to also have to make a ray cast from the bottom right of the player so let's copy this paste it here max slope hit right okay and the only difference is that this is cast from the bottom right of the player now i'm going to make a new method a void called slide down down max slope and this is going to take in a rast hit tod which we'll just call hit and it's also like our other move methods going to take in a reference to the vector 2 move amount so that it can modify that value all right so the first thing we want to do is we want to say if hit so if the raycast actually hit a slope then the first thing to do is to figure out the angle of that slope that's just the same as we do here and then we're going to say if the slope angle exceeds the max slope angle then we're going to want to set move amount. x equal to something and just what that something is we're going to have to use trigonometry of course to figure out so if we draw a quick diagram of this situation we've got our ground plane we've got a slope and we've got the player who is falling down the slope so we know the distance that the player is falling down we can call this y and obviously what we want to figure out is how far needs to be moved on the xaxis to be placed over here at the end of this frame so we've got this triangle now if the player starts a little bit above the slope then we've got little section here that sort of protrudes from the triangle we can measure that with our hit distance just the distance of the ray from where we cast it to the surface of the slope so if we just want this bit that actually forms part of the triangle that will be our y value minus the hit distance all right now we know this angle over here this is our slope angle and of course since these since these lines are parallel that is just the same as here so we know that we can call that data so the trig ratio that involves both our known value and our unknown value is of course tan opposite over ajacent so we can say that tan of theta is equal to y minus the hit distance divided by x and we're trying to solve for x so we can simply multiply both sides by x and then divide both sides by tan theta to get x = y- hit distance divided by tan theta our slope angle so that should be easy enough to code we say move amount. x is equal to the absolute value of move amount doy minus hit distance and then we want to divide all of that so let's make sure to capture that all in parentheses we want to divide that by math f. tan of slope angle and remember slope angle is in degrees and math f do10 takes in an angle in radians so we multiply this by the conversion mathf do degrees to radians all right now the one thing that we haven't accounted for is the direction of move amount. x so if the slope is like this then move amount do x should be positive and if it's like this then move amount. x should be negative so in this case the normal of this surface will be pointing off in this direction in other words it will have a negative x value for its normal and in this direction we'll have a positive x value for its normal so we we can simply multiply this entire expression by hit do normal dox all right let's just then say collisions do slope angle is equal to the slope angle that we've calculated and i'm going to go down to this collision info structure over here and also add in a new public pool so we've got ones for for climbing a slope and descending a slope and while technically what we're doing here is descending a slope i'm going to use descending to mean manually sort of inputting that we want to descend and just sort of sliding because it's too steep i'm going to call sliding down max slope all right and in our reset method we'll want to say sliding down max slope is equal to false and then up up here where is it we're going to say collisions dot sliding down max slope is true okay so what we want to do here is say slide down max slope pass in max slope hit left and pass in our move amount as a reference and then same thing for the max slope hit right ref move amount and then we only need to bother checking for a slope that is less than the max slope angle if we are not sliding down a max slope so in other words if not collisions do sliding down max slope only then do all of this stuff all right let's test test this out quickly by setting up a slope here i'll make this have a slope angle of- 60 and can just scale this out and then duplicate that make it positive 60 put on the other side and we can just move our player object up to the top here and just set the max slope angle to something less than 60 and then if we press play let's walk over to the slope here and you can see that we are automatically sliding down the slope but it is far from smooth so the reason for this is that in our player class we have this line in the update method where if we detect a collision below us we reset the y velocity to zero so this means that we're unable to build up any acceleration as we're sliding down the slope let's just implement a quick fix for now let's say that we only reset the velocity if not controller do collisions do sliding down max slope all right so let's try that if we come over here we slide down nice and smoothly now and the same happens on the other side one thing that's a bit weird though is that if we go into the slope and then try and move in the opposite direction you can see we slide down very slowly and you can also see that despite the fact that we're moving left our collision rays are being casted to the right so if we go into the controller 2d class we can see that this is because up in the move method we have set collisions. face direction equal to the sign of move amount dox and we're then using that in horizontal collisions to figure out which direction to cast the rays but with our new slide down max slope logic the sign of move amount. x might change after we've called this descend slope method so we should actually take this code and just paste it after that to make sure that we're getting the right value there so if we save that i head back here we can try out that same thing and we just slide down as we'd expect all right now one thing we need to worry about is that the player should accelerate down a slope like this more gradually then he would accelerate down a steeper slope and if we imagine this in terms of the slope with its surface normal which can be broken down into a vertical and horizontal component then it's the vertical component which is opposing the acceleration due to gravity of our player and then the obvious observation is that if we've got a steeper slope the vertical component of the surface normal is going to be smaller and so there will be less opposition to the down movement of the player and so he will accelerate faster all right so going into the controller 2d class let's come all the way down to collision info and let's add a public vector to called our slope normal and then in the reset method we can just say slope normal is equal to vacor 2.0 and then whenever we detect a slope we're going to set that so collisions do slope normal is equal to hit. normal and let's copy that and we'll paste it into the descend slope method as well and then in the climb slope method we don't have a raycast hit variable so we're going to have to take in vector 2 slope normal as a parameter and just set it like that then in this bit of code here this is inside of the vertical collisions method we'll want to once again have collisions. slope normal equals hit. normal and then just in the horizontal collisions method this is where we're actually calling climb slope so we'll add in our slope normal there by saying hit do normal all right let's save and go into the player class let's say that if we are sliding down a max slope so remove the no then velocity doy is going to be opposed by the controller do collisions. slope normal doy and we're going to multiply that by gravity here and gravity is negative so we'll add a negative sign in front of that to cancel it out and then we'll also multiply by time. delta time all right otherwise if we're not sliding down a max slope then everything will be like before velocity. y will just get set straight to zero all right so coming into unity let's slide down this slope that works as we'd expect and then i don't know how clear this is going to be to see but if we make the slope steeper then we're going to slide down it more quickly now there is a small bug at the moment and i think it's going to be easiest to demonstrate if i make the slope angle really small say 10degrees and then set the rotation of this to something like 11 let's put that over there now as i walk over here should see some strange twitching right there and that's because we're detecting a max slope on the bottom left of this character but the rest of the character is actually on flat ground so what we want to do is we only want to slide down a slope if the one side of the character detects a collision but the other side doesn't you can imagine if i just move this over here if we're actually on a slope this side is not going to be resting on the slope so no collision will be detected so let's go into the controller tod class and come down to the descend slope method and before we call either of these slide down max slope methods we'll say if we want to we want to say if only one of these has detected a collision so if max slope left and then we're going to use the exclusive or operator so or max slope right so if only one of those is true then we will call the slide down max slope method okay so now ah i lost that little change in the scene there like to get that back quickly so i'll set this to 11degrees put it over here and set my max slope angle to 10 and then let's try this out again we can see that it works fine now all right now the last thing i'd like to do is just work on the jumping behavior for these slopes so if we're sliding down one of these slopes and press jump we jump straight up which looks a little bit weird i'd actually expect the character sort of jump off at a bit more of an angle and then also we obviously can't climb up these slopes since they exceed the max slope angle but we can jump up them which is a little bit weird so i'd like to first of all restrict the jumping so that you can't jump up these slopes and then also make it so that if you're sliding down in press jump you jump off at an angle so let's go into the player class down here to on jump input down and this is all wall jumping over here but this is our regular jumping so we can have a little check if controller. collisions. sliding down max slope then we're going to have our custom jump code otherwise just continue as normal okay so over here we're going to start by comparing the direction of the x input to the direction of the the x component of the slope normal so we'll say if directional input dox is not equal to negative math f. sin of controller do collisions dolop normal dox so this translates to let me add a little comment over here this translates to not jumping against max slope so if we're not trying to jump against a max slope then we can simply say velocity doy is equal to max jump velocity multiplied by controller do collisions dos slope normal doy and then so that we have a bit of velocity on the xaxis as well let me copy this and just set velocity dox equal to max jump velocity time slope normal dox all right so if we save this now if i jump while sliding down the max slope you can see a shoot off at an angle and if i try jumping while sliding down the slope i have no success all right so that is all now working as intended so i guess this is where the episode ends until next time cheers