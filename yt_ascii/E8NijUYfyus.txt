welcome to my list of 21 more nooby python habits, i'm also giving away pycharm licenses so get your #pycharm down in the comments to enter nooby habits are things that noobs do that doesn't mean they're wrong or bad or that you can't or shouldn't use them but nonetheless they tip off other developers to your inexperience and avoiding them tends to improve your code so whether you're brand spanking new to python or just trying to keep that awesome tech job you somehow got let's dive in. nooby thing #1, manually rounding inside a print statement, you computed some value and it's time to print it out, but it's a floating point value, if you just print it out as is it's too many digits, too much clutter so you just round it, right? instead just use a format specifier. #2, repeatedly converting to and from numpy arrays, often accidentally. in most data analysis situations the best thing is usually to just immediately convert your data into numpy arrays or pandas data frames then just make sure you stick to all numpy or pandas functions, it's a pretty common mistake to actually use a non-numpy function like the built-in max which results in even worse performance than using max on a list. #3 manipulating paths as strings. for obvious reasons it's very common to represent a path as a string, so there's the obvious temptation to do string operations to manipulate the paths. but this approach is highly error prone. instead consider using the built-in pathlib. pathlib already has built-in most of the common file and directory manipulations that you would want to do. #4 writing io functions that take the path instead of an io object. there's nothing really wrong with having a convenience function that does this but what you should really do is have a separate function that does all of the writing operations. so this function does all of the logic of writing to the file and this function is just a convenient wrapper around it. the reason for doing this especially if you're writing a library is that people might not want to open a file, or they might want to be writing to a different kind of io object like to a zip file, to a network connection, or to a string. by providing this version of the function you allow people to write to whatever they want to instead of just to a file... and speaking of writing to a string, that brings us to our next nooby habit concatenating strings with plus. the plus operation on a string copies the string so in this for loop i end up making 100 copies of a larger and larger string. instead use a stringio object. this uses a growing in-memory buffer to minimize the number of copies of the string data and it has an interface just like a file object that you'd get from open, and once you're ready to convert the buffer back into an actual string object, call getvalue. #6, put a finger down if you've never done this one, using eval as a parser. through dubious means you've got a string with a data structure in it. just pass it to eval, what could possibly go wrong? well of course the answer is eval is bad and you should feel bad for trying. okay okay eval does have some legitimate uses, but parsing data from a string isn't one i would probably use in production. instead consider using an actual parsing library like the built-in json. #7 and this one really pains me to see, storing your function inputs and or outputs as global variables. if you're reading from a global and using it to change something about how your function works, then consider it might be better if it's just an input parameter, and if you're writing to a global variable it should probably be somewhere in your return value. hey, while you're here, did you know that i'm available for consulting? that's right, self promo! my team does python consulting, contracting, training, and interview prep. if you're interested, visit mcoding.io. #8 thinking "and" and "or" return bools. you may not have ever printed out the results of an "and" or an "or" because you typically just use them in "if" statements. but if you did you might have been surprised at the results. you don't get a true or false in general. "or" returns the first truthy thing or the last falsy thing, and "and" returns the first falsy thing or the last truthy thing. #9 single letter variables. there are of course cases where single letter variables are fine, a single underscore to denote something unused, calling a loop variable "i", common conventions like x, y, and z coordinates, or even well-known math formulas. no, what i'm talking about is a whole function where everything is just a single letter or maybe two. with just a few carefully thought out variable names it would be so much easier to understand. #10 using both div and mod instead of divmod. if you're doing, like, math i guess? there's a decent chance that you'll want to divide by a number and know both the quotient and remainder that's what divmod does, it gives you both a quotient and the remainder without repeating the calculation. #11 not knowing about properties. a lot of noobs, especially people coming from java, are in the habit of writing getters and setters for every variable. the more pythonic thing is to just leave the variable as part of the public interface but sometimes we use getters and setters because we want to actually do something in them. in that case having a separate get and set function does make sense, but doing that means that in order to access the value i'm now calling functions set_x and get_x instead of the more intuitive dot notation. well that's exactly what a property lets us do. now because of descriptor magic we can just say object.x equals 42 and that will actually call the setter with the value being 42. and on a related note #12 having expensive properties. cool cool you learned what a property is and now it's time to save two characters on every function call by converting them into properties. slow down there. it's not about saving characters. anything that takes much longer than just a normal attribute access shouldn't be turned into a property. if you have a function that might be very expensive make it look expensive. #13 inserting or deleting while iterating. here we're looping over the dictionary and while that iteration is in progress we try to delete a key. for a dictionary, doing this is going to raise a runtime error, but for other data types especially c extension types this might just do something very weird and not throw any error. replacing or modifying a value on the other hand is typically fine. another approach is to keep a set of keys that you're going to delete, loop over the dictionary and add anything that you want to delete into the to_delete set. then once you're done delete all of the keys afterwards. #14 and i know this will be controversial, any use of filter or map. the reason is that they encourage you to write code that looks like this. in general you can replace any filter like thism and you can replace any map like this, these generator comprehensions are lazy just like filter and map and they produce the same elements, and bonus points if you were just immediately going to convert that to a list. instead you could use a list comprehension which is even more readable. ...and it's tomorrow. who could have guessed that yelling python into a microphone for two hours was bad for your voice? but you're worth it, 14 down let's keep going. #15 defining too many or inappropriate dunder methods. some of them like init or hash make perfect sense to define for most classes. but the person class does not represent any kind of number or thing that naturally has a plus operation associated with it. but this code goes ahead and defines iadd to make plus-equals mean make these two people friends. don't use a dunder method to accomplish this task, just use a normal function with a good name. #16 trying to parse html or xml using regular expressions. it's not that you made a mistake, that your regular expression is bad or that you're not smart enough to come up with the complete one that handles all the edge cases. it's literally impossible to create a regular expression that can parse html because html is not a regular language. instead you're going to need an actual parser. you could use something like python's built-in html parser or you could reach for a more full featured third-party library like beautifulsoup, which of course has a parser inside of it. #17 not knowing about raw string literals. in most srings it doesn't matter, but specifically for windows paths and in regular expressions, using literal backlashes is very common. plop down an "r" in front of your string to make it a raw string literal. raw strings ignore escape sequences, making regular expressions much easier to read. #18 thinking that super means parent. you might think that the super call is going to call the root's version of "f", and in most cases you'd be right, but not in all cases. and the reason is that someone could inherit from your class. this instance of c is also an instance of a but when we call "f" we see that the chain of super calls goes from c to a to b to root. in particular this super call inside of a right after printing "a.f" sent us to the sibling class b, not to a's parent root. i've got a whole video on super if you'd like to hear more. #19 passing structured data around as a raw dictionary or tuple. you do some calculation, take a measurement, or summarize some data. if these values are meaningful and always need to stick together, then most likely this should be a class and you should give it a name. if you were returning a dictionary before, a data class is probably what you want, and if you were returning a tuple, then a namedtuple is probably what you want. #20 using collections namedtuple instead of typing namedtuple. back in the day this was a best-practice because it allowed you to give tuple elements good names. but nowadays the typing namedtuple is a much more readable way to do the same thing. it actually looks like a class definition, it's easy to read, and doesn't rely on strings. and as always saving the best for last, #21 import-time side effects. please please please don't print something when i import your module. even if your library can also be used as a script and that's the behavior that you want when you run the script, use the "def main if name main" idiom to hide it behind a "main" function. that's another one where i've got a whole video explaining the benefits of doing this. and that's 21. you must really love the sound of my voice, or maybe you just like my content in which case don't forget to subscribe and become one of my patrons on patreon. itching for more nooby habits? check out my first nooby habits video. as always thank you to my patrons and donors for their support, slap that like button an odd number of times, and i'll see you next time