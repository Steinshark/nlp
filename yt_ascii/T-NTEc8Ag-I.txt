you said you wanted to talk about algol 60 well is 60 things somebody has said it's 60th anniversary release which is rights i mean it did come out in 1960 which is why it was called algol 60 and so yes it is 16 years old 60 years of algol 60 birthday howl 60 it's another of these that was tremendously influential at the time and a flag of that everybody could rally around but in the end it was designed by a committee and despite all their attempts to be reasonable and not too demanding individual commission members tried like heck to get their favorite things in there regardless of how expensive they were to implement and saltz mightily or tended to if they didn't get them in i'm gonna start off with an al gore 60 version of we've done a video on this ackerman's function now algol 60 one of its famous selling points was that at last you'll be able to do truly desperately recursive things like a common dysfunction because this time and there was a big punch up in the committee about it basically say do we want to do recursion it's bound to give us a bad name cuz it'll be slow and everybody said now we've got to do it you know it's no good saying things like factorial and fibonacci can be done not properly recursively in loops essentially things like a command combi so we got to do it it's it's part of our duty as to what how god's going to be so this is the way it came out and it worked just fine i think i can even explain it to you using on here the comments of thing okay so i've just dragged over the word begin later on in the 60s decade when si came upon us they used open curly brace and close curly brace to define a block of code alcohol is much more of a bo's that uses begin and end could you miss those yes in fact i'm no one here look the initial begin is up at the top and this matches with that end but hidden in here as part of this program there is a do loop here but to show the extent of the do loop not curly braces like in c begin and end so here's my big it and here's the matching end that goes with it oh it's sort of working but then what happens after that well let's cut to the chase and let me tell you this thing first of all defines the ackermann procedure that is going to get called and it does it obviously in algol 60 nomenclature partway down the procedure stops and the bottom half is the main program now here is another contentious discussion point it's not immediately obvious until you look at the structure of the program that down here where it says integer m n that is not a part of the ackermann function it's part of the main program so when you move on to c which you can remember is eight or nine years downstream of the algol 60 committee so many lessons have been learned and the feeling was algol is terrible sometimes for you to have to mentally pause the program to discover where the main program begins wouldn't it be nice to flag it up with something like main which was obligatory yes it would it's a very good idea so if we go through this line by line we've got to begin and then that next line says integer procedure ackerman m n okay it's a procedure no abbreviation no ability to use proc or anything like that it's a procedure it delivers an integer no abbreviations allowed it's gotta be integer not int and what it's saying is ackerman takes two arguments m and n but at the end of the day when it's done its work it delivers back an integer that's why you say it's an integer procedure okay so it's heralding the idea of what's actually called a function more in c a thing that delivers back a value in integer or float or characters or whatever here we go then are now here comes something that we will absolutely be stumbling over in future discussion you had to say that the incoming arguments m and then were not very clever ones there were mayor values so you actually have to say not just m and n are integers but also the m and n are passed by value and not by reference which was the most general mechanism so all of that taught london is just the procedure heading then there's something which really does put alarm among human colon equals if m equals naught then n plus 1 else if well or whatever the rule was in algal sixty that you've returned the value of a function not with the reserved word return which by time c came along began the standard was it you say return thing or whatever no you returned it in a very logical way by doing a pseudo assignment to the name of the true savior you're saying the whole a command effect becomes the action of this procedure body here which are right act on the right hand side ackerman becomes the truth or falsehood all if m equals nor then delivered back n plus 1 so the value of m plus 1 whatever that says 6 or something would get put into not a real variable but put a pseudo variable that is there to return just the result of the procedure now that can be so confusing for beginners to say that it's confusing for me right now you declare it is a procedure but that's what it is so the obvious way to return its results is not to say return n but to say acumen becomes this thing using making it look like a pseudo assignment statement some people love it some people hate it but you see you can have arbitrary complexity on the right hand side it's saying well if m is naught and then you deliver the result is n plus 1 and here's the notorious bit that we've already covered in a video somewhere other as if n is naught then you cook up ackerman again now that's your first example of a recursive call you're calling your back ermine within ackerman but with arguments and minus one on one this time and if that is not true if it isn't naught then the most general recursive call of ackerman is a comment of n minus 1 and then the second argument from hell is itself a call ackerman to work out your second parameter and isn't that that drives is super exponential eventually but that's the end of the whole thing it may not be obvious to you but that thing they're saying it else ackerman m n minus 1 the next line says integer mmm what's that got to do with this function nothing at all it's part of them a program because you see you have given what would be a one-liner definition of what you want to deliver into ackerman so that clearly with its semicolon at the end of it is all you need to define what hakama to deliver so you didn't use a beginning end because she didn't have to it was an integer procedure there's the header and it was a one-liner pseudo assignment statement returned the value oh god i used to love teaching this to raw beginners so you had sort of put this paper down down to but not including integer m n is the procedure body but by the time we come through integer n n it's extra declarations in the main program here already to define the procedure ackerman but now these are common or garden integers were going to use so integer variables basically m&n fair enough and then we get on to a piece of code that is very very similar mean see very similar in whatever language you do basically just putting to do loops inside each other to investigate the low value parameter end of the ackermann function so we've got here for n different but similar you know you can think of a for loop in c with its parentheses in each colons inside it but this is very similar for m becomes 0 that's the star value step one step it up in warren as we go around the loop until it reaches three do with the following but then straightaway nested inside that it doesn't just say do it says do begin there's a no for loop for n from naught step one until six do and then here the next nightmare did algol 60 have standardly defined input/output no but you complicated and caused too many fistfights in the committee said it's implementing implementation dependent what your import output will look like it's always a mess and there's nothing to do with us but your programming manual will define for you what the input/output conventions are for your compilers running on your computer at your university or whatever so i've got here and this particular version from rosetta code they've used out integer which is as good as anything so out integer an out string they're using actually here and the way they're doing this is just putting out the values for m and n increasing in fact you know as we all know the first zeros values are just the numbers themselves are like 1 2 3 4 5 6 7 and so on so yes you can see from the printed out numbers there it works just fine but i think in terms of impenetrable obscurity it is not good the worst bit is the fact that you can carry on after what is obvious at the end of the integer procedure definition because there's a semicolon there no extra begins or ends to help you they're not necessary i can't quite recall whether it would have been wrong to put them in but anyway it was his heart was in the right place but the trouble is it was a committee and this is what came out of it these things you're talking about now with the benefit of hindsight and having used c for many years would you have thought of these things then or is this stuff that you can just see in hanson you get a lot of it you know in size the thing i think a lot of people said wow in the real live engineering and science world it might you might have some need for a factorial but you could always calculate it by going around a loop because it's a primitive recursive function and when people said but what do you really need recursion for that would matter to me the answer is probably nothing a lot of people did say and rightly once a recursion becomes part of the scenery people will work out how to implement it far more efficiently and it is actually for some problems a very very elegant way of coping with it but you need to be sure that your implementation if recursion has been done by somebody with at least the talents of ken thomason to make sure it doesn't run hideously hideously slowly so there we are it works algol 60 did the job it wasn't exactly obvious syntax as a method for doing economist e where the main program begins but nevertheless it did the job how did things improve and get more efficient by the time c was developed to fruition roughly eight to ten years later well rather than spend ages doing that myself i will refer you to one of my videos which is about the ackermann function what was it the most difficult program to compute question mark is what we call it yes the crush models are important as we went on to find different more difficult oh yes yes we discovered it wasn't coming we discovered busy beavers far worse but that's another story no in the ackerman info block i think you will find if you leave it in that video there is a link out there to either a package of stuff all to a listing of the c version of how to do the aquin function let me say right here and now i did it that way to prove a point it is very very old-fashioned see it is original kernighan and ritchie see where you specified the type of the incoming arguments to functions separately from the proceed ahead you had like a little separate well like in algol 60 you said in teh be inside not up at the top so please don't castigate me because at the time i was interested to see if my original usage of c to show that ackman's function worked would still stand up in the modern compiler and thank him gcc you did not fake a theological approach and refused to compile me you just understood it was old-fashioned but it was okay and it works pick out some things about algol 60 or send it in context i say okay the big three by the late fifties early sixties in a sense were you either a coding this whole thing down so this function works it has the correct behavior but it's not satisfactory because