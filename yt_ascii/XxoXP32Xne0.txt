typescript 5.3 let's do this are you guys excited are you guys excited man i have never been more excited to continue to not like something in my entire lifetime let's see what's new okay here's the quick list of it import attributes stable support resolution mode on in import type switch true narrowing narrowing on comparison switch true i feel like if i saw the term switch true i would want to punch somebody in the face narrowing on comparisons to booing in instance of narrowing through symbol has instance checks of super interactivity inlay hints okay interesting i like i like inlay hints optimizations by skipping js do parsing what happened if i want js do parsing by the way i wrote my first javascript plug-in yesterday and it used js do and guess what it was great dude i was sitting there trying to figure out how to run this and then i had to like run this entire thing and then i had to figure out how am i going to run this thing in javascript i had to created an entire build system just for this stupid file i don't want to deal with any of it so instead of doing with any of it i just used js doc and called it a day i defined like two variables bada bing bada boom it was more than enough called it a day it was so effing awesome i literally wrote a script i can call in node in three seconds with virtually no effort sorry anyways optimizations by comparing non-normalized intersections cu i don't know what that means oh who whose intersections aren't normalized consolidation between ts server library js and typescript js breaking changes and correctness improvements okay what is import attributes i don't know what this means oh great does this i can can you guys hear it right now can you guys hey guys can you hear that right now i can hear it that's bun crying a little bit why do we got to support another thing why why don't they just now dude we got so many sweet standards for importing stuff i love it i love it i'm so excited i'm so excited for more stuff we only want this to be interpreted as json not runnable malicious javas script file with a json extension the thing malicious about javascript is how much memory and cpu it uses all right anyways i mean i guess i get this but i just don't understand this put it in your browser probably not typescript is fine with this put it in your browser probably not let's see the contents of these attributes are not checked by typescript since the they are host specific and are simply left alone so that the browser and runtimes can handle them possibly error dynamic import calls calls can also use import through a second argument okay the expected type of the second argument is defined by the type called import call options which by default just expects a property called with note the import attributes are an evolution of an earlier proposal called import assertions which are implemented in typescript 4.5 the most obvious difference is the use of the wi keyword which by the way the word the with keyword wi is already a keyword in typescript and with is the devil with is single-handedly the worst keyword and idea ever created in any language and if you don't know what javascript with is go take a moment go check it out i okay so my big worry here is just like i don't want more stuff right first off who something has to say i i assume json is like a known one so it treats it like json but how do you extend this what does this mean what is fluffy bunny can you define fluffy bunny is it purely up to the vendors or are there going to be client side things are we going to now get typescript interacting with bundlers what's going to happen with this i don't know interesting stable support resolution mode in import types i'm not sure what that means all right 47 typescript added support for resolution mode i honestly never use these let's see resolve package as if we are importing with require bun is so screwed bun is so screwed how were you ever going to support this imagine how many different versions of s like stuff you have to dud dude this is insane i don't know how i feel about this one okay so you import from package but using the resolution of of require this one you do use it but you're using it with the resolution mode of import those import attributes can also be used with import types okay so you can still do the with resolution mode ah i mean again i'm not i just maybe i don't understand okay so so completely fair statement is that i can see why this is nice but can i also just argue that maybe if it ends with json you just force it to parse it as json and you don't allow runnable malicious javascript files hiding themselves as json right i mean is that fair just have the extension be the thing that denotes how you treat it because something. json oh i guess you could because because of how import works you have something. json. javascript right and so you've been lied to and they don't they they're none the they're none the wiser i mean i understand i guess i do understand this but but i guess i have a couple follow-up questions which is a how did you get this malicious javascript on your stuff at all i mean this is a local file import right here like how did you even get this okay how how did you even get this this local maliciousness on your but anyways i get the idea but still it just feels all upsetting if you program like this i think you deserve to be fired we're just going to move on we're just going to get moved on if i see this if i see this code i'm firing you okay use a gosh darn if statement for this who would do that would you really do this straight to jail that's crazy all right narrowing on comparisons to boings occasionally you may find yourself performing a direct comparison with true or false occasionally that's like 80% of programming is just if statements i mean a for loop is just that in a condition let's see usually these are unnecessary comparisons but you might prefer it as a point of style or to avoid certain issues around javascript truthiness regardless previous type oh they just mean literally having true or false yeah i don't mind that it happens all right so what's the deal let's see javascript or typescript 53 now keeps up and understands these expressions in narrowing variables all right function is a x my type x is a a in x if x is true it works oh nice i'm happy about that is there a deer prime engine no not in this one this is vs this is microsoft microsoft do not like me that's that's good okay hey that's good good job i i'm happy i'm happy with this instance of narrowing through symbol has instance new thing instance of weirdo undefined instance of weirdo true oh interesting okay so you can do type narrowing through has instance by the way this is such a weird example that they're doing like why would you do this this is just like painful to even look at okay but why would you do this give me like an example of where this is very nice all right static simple instance has instance vow is point like point like has x and y okay so if it has these two things all right wow that is such a deep dude look at this has instance it's crazy if in if value instance of point we can get x and y we don't have access to this because we have a point like but we don't actually have a point why would you ever want to programmatically override has instance of a class that has functions such as distance from origin and then only allow access to the variables at this point this is the only time an abstract class makes any sense you'd have to have an abstract class with these two things then you're going to have to extend because there's no reason in the world why you want to have point resolved to a point like whereas you should be able to use point like as an instance of check it just it just feels kind of cray okay it just feels kind of cray can we extend car into a cow type maybe we could yes that means you could you could do whatever you want here oh yeah let's try that right now pick pick good all oh crap we don't we don't quite have it i don't have i i'd have to install this i actually do want to try that can we do that let's find out okay let's go like this let's back it up let's go like this makeer fufu fufu npm uhit y let's in let's get the typescript beta just in here just strong beta mail vibes going on right here let's go tsc a nit all right vim test ts and dddd give me the d give me the d give me the d let's just grab this thing really quickly let's yank this thing let's put this in here and then let's go like this let's have a cow return a point like return true right close enough right so that means i should be able to go like this function let's see hold on oh f f let's see see a new cow all right there we go beautiful you you can just return whatever the hell you want who cares i don't even i don't even inherit from point like i don't even have an x or a y i can just make it whatever the hell i want type safety anyways okay checks from the super property access on instance field okay let's see super method base call derived method call su method there we go derived see this is the diff let's see this is different from writing something like this. su method since it could invoke an overridden method okay i'm confused a little bit here okay hold on javascript it's possible to access declaration in a base class through the super keyword okay fair this is different from writing something like this. meth some method me since it could invoke an overridden method this is a subtle distinction made more subtle by the fact that often the two can be interchangeable if the declaration is never overwritten at all okay yes okay that makes sense this since there is no this here it goes all the way up to the base yeah okay the problem with using them interchangeably is that super only works on members declared on the prototype not instance properties that means if you wrote something like super super su method but some method was defined as a field you'd get a runtime error if you wrote a field that is a function again the neck punching should just like you deserve you deserve the neck punch okay why why are you writing why are you writing a a field as a function okay it makes no sense what the hell's happening what the hell's happening in javascript every time i see this i just it just is emotionally painful tesp 53 now more closely inspects super property access methods calls to see if they are corresponding responding to a class fields if they do we'll now get a type checked there oh okay well i mean that's neat but still interesting all right interactive inlay hints for types by the way i hate inlay hints in the code i think neovim does it right they put the inlay hints on the outside i honestly think that's way better and it it's really great in rust my strategy is to be blind to all of these it helps me a little yeah these are all these all seem really kind of wild i'm a little bit confused i think right i think you should just never ever rely on any of anything that's been said up until this point all of these just seem like crazy features to me things that i i i mean the import one maybe i just don't understand fair fair but everything else seems a little wild typescript now supports inlay now supports jumping to definition of types oh cool i mean except for the whole mouse thing loser everything else pretty cool op optimizations by skipping js deck parsing when when running typescript via tsc the compiler will now avoid parsing js docs this drops parsing time on its own but also reduces memory usage to store comments along with time spent in garbage collection i would make an alternative which is you could always just write it in not javascript right like if you just wrote tsc and just not using javascript it would just be fast you know what i mean it would just be really fast and and everyone's life would be better instead of having es build and s swc and having hundreds of different new ones coming out i swear there's going to be another one there's going to be another one there's going to be another one after the another one just it's a non-stop fever dream of creating new javascript tools why don't you just make the one tool that everybody's relying on just make it correctly just make the effing thing in the correct thing okay just just write it in rust and then this is just not a problem write it and see write it in go write it in any write it in php just write it in anything but the language it's currently written in cuz it's crazy it's just not what javascript's good at that's all it is like javascript's graded a lot of things being fast is just not one of them every day a new jjs framework is born yes well there's also every day a new tool is written in javascript and it's coraly which is that tool will eventually be rewritten two times once in go and then once in rust it's part of the javascript rule set you just got to know let's see optimization by comparing non-normalized intersections in typescript unions and intersections always follow a specific form where intersections can contain union types this means we can create intersections like this okay a a is a union or it's a a union b or c that will be the intersection type of this okay fair still in some cases the type systems maintain the original form for display purposes it turns out that the original form can be used for some clever fast- path comparisons between types for example some type and type one to the 99th bajillion you want to see if it's assignable to some type recall that we don't really have an intersection oh i see why this is a fast type because you have some type off the rip we have unions that look like some type one some type two some type three some type all the way up to the 99 when checking if a union is assignable to the target type we have to check every member of the union yep okay that's i mean clever clever keep it in its original form because then you only have one check for the sum type if it's at least a sum type we know that then all we have to do is check these ones right in typescript 53 we peak at the original intersection form that we were able to tuck away when we compare these types we okay that's good like that consolidated between these two i don't think this one will be very useful i don't think types script itself ships to library files ts server library and typescript js there are certain apis available only in ts library okay okay so this is just a bunch of internal stuff not really for me all right breaking changes and correctness improvements lib dts i still can't ever get dts files to work the way i want them to types generated for dom may have an impact on your code base okay checks for super access okay so just a bunch of little bit and what's next at this point typescript 53 is what we'd call feature stable the focus on 53 will be bug fixes and polish and certain lowrisk editor features okay cool well i'm not going to lie to you everything that they've they've made better also seems crazy this just is crazy i i don't know why anyone would do this i'm still completely confused why anyone would want to write code like this this i'm i'm emotionally in pain why you'd want two different import systems going on i just don't get it i i guess also this i i really am not too sure about this in conclusion to write type js we write rescript at the end i i guess i i mean i i'm glad that they're making typescript better in the sense that this now has better type narrowing okay awesome i like to see that i'm just struggling you know what i mean i'm just struggling struggling to see why struggling to understand why this would why you'd want this type getting better we're trying to say it's better anyways i guess this la this one's really cool i'd say that if you use your mouse as in your editor then this is a really cool feature i can completely agree with this that's a super cool feature inside of your your mouse based editor right that seems pretty cool all right hey i guess the name is i'm still use i'm still gonna use goer rust a jen