all right hello and welcome to meeting c plus plus with this real great new tool for hosting this this virtual conference providing a way to still get together like in in-person events which we hopefully will have maybe next year i'm andreas ferdig i work as a trainer and consultant for seed plus i'm also obviously a speaker and the creator of c plus plus inside the tool which sadly we will not use today but we will see compiler explorer the topic of the today is c plus plus 20 templates the next double concepts and more so we will look at what c plus plus 20 brings us to make templates well usable in a wider range for people hopefully scare less people away yeah that's interesting because meeting c plus plus would be hosted in berlin usually so that's germany and i'm john and this is my last name my last name is obviously german it's pronounced feltic and you can translate it to finished ready complete or completed it's a really nice name if you look at it that way in german the issue is as a last name it's spelled with a capital first letter by a lesson adjective it's spelled with a lower first letter so i have a constant fighting with my spell checker and i like to say i think i'm really good with c plus plus in general and despite it i'm german and my last name is fatigue which is a very common word in german it took me quite a while so years roughly to learn that i mispronounce my own last name and proper german it's he at the end but as i said i think i'm much better in explaining c plus plus and using c plus plus so let's switch to that concepts concepts allow us to formulate requirements for a type if you want and if it's easier for you in the beginning you can compare it to a stood enable if but a student enable if is only a teeny tiny portion of what concepts can do for us okay but if it helps your model let's start with this one concepts always consist of the definition of a concept which we have a new keyword for to define that that's concept and requirements concepts consist of a couple of requirements at least one more and to specifying those we have another new keyword called requires okay in the figure below you can see how we can compose a concept it always starts with a template hat because concepts are meant for generic code they are always templates so they start with a template head and in the template head we can use all the usual things we know from functions or function or class templates we can use type and non-type template parameters we can use verity arguments we can use only a single type named t we can use multiples we can go crazy with class and type name and figure out the tiny differences and when they measure between the two but that's the template here that's that's the usual thing you already know and in the next line we have the new keyword concept that's where we see and the compiler as well that we are starting to define a concept here and followed by the keyword comes the concept name you can use any usual variable name or any syntax to declare variable names they are applicable here as well i chose my concept it's really bright concept i know and then after the equal sign we assign requirements to this concept in this specific case three of them stood same as that's the first concept you see figures out whether two types are the same and then is class v and is enum we and as you can also see we can use boolean algebra to piece them together using and or okay so that's how a concept itself looks like now let's explore how they help us and then where to use them let's say we want to write this function at and this function add it should use a vertical amount of parameters so x and epsilon here and in the code listing illustrates and should be usable with two and this four parameters and of course more and the force okay you look at the picture the only thing for now i want to restrict is mixed types this is line number three where i call address 2 comma 3 comma 3.14 this is something i like to forbid at this point because implicit conversions are fine but implicit integer conversions are if they are narrowing it's not that great okay so that's the task and you can easily see okay it should be a very template at this point so let's see how we can compose that in c plus plus 17 okay with the restriction pardon me i forgot one thing initially i asked you to hold your questions to the end of the talk we either have a couple of minutes there to hand them orients arranged one of these extra rooms where we can all come together after the talk and discuss your your questions okay i have roughly 10 minutes to discuss them after that i have to switch to the book fair to present my simple plus 20 book programming with c plus 20 which i welcome you to join as well but back to our example here so how to implement this function add in c plus plus 17 this is my approach the grade out code that's not important one here i quickly walk you through it's just two helpers the first one is our same we it's in line number two it's a variable template from c plus plus 14 and it uses stood conjunction wii and stood same as to look to compare our type name t to all the arguments in a parameter pack so stood the same compares t against every element in the parameter pack instead of conjunction ends them together seeing whether really all of these is same calls true so this is our check to ensure that all parameters in a parameter are of the same type and then below in line number 10 i have another helper first arc t and it's supposed to grab me out the first argument in the parameter pack because all arguments should be of the same type whether i pick the first one or the last one or some type in the middle doesn't matter they're all the same so i'm picking the first one out here and now to the code at the bottom that's the implementation of add we can see in line number one yes it's a very template it starts with type name dot dot so obviously there's a parameter pack and then in line number three i see the function name it's called add i'm passing the arguments to add and expanding the packy or the pack itself and on line number five i'm using default expression from c plus plus 17 expanding all the arguments in the pack and using the plus operation to add them together okay so that's so far all right especially c plus plus 17 that's i think really nice code the issue i have and that's the line i skipped intentionally that's line number two and i wrote this piece of code okay that's my own code i'm judging here it's the stood enable if t it's it's best enable if you can get because it's the enable ft which already spares you typing type name in front of enable if well that's that's great but other than that we are looking at a really bizarre looking construct here especially for people who don't write template code every day or who are new to c plus plus we have to know that the first thing we are passing in our r same we that's a boolean conditions or rcmv returns true or false and depending on this being true first arc t the second parameter to enable if is what enable if t returns me and that's also the return type of add because you don't see that anywhere else this is in the enable if and if they enable if or they are same we better yield false then the entire enable if cannot be instantiated we're talking about spin a here and that function well never makes it into the binary probably you're looking at one of these page long error messages where the compile tells you all the combinations he tried to instantiate a variation of add so i prefer putting the enable if at the return type because there's a place where nobody else can tamper with all other things like default parameters people can yeah modify it so this is the best way i think but it's still hard to read it's hard to teach is a lot we have to know about this and the return type is obfuscated so it's it's it's misusing that thing and what does enable if mean anyway and then it enables or disables something i don't know so this here is the plus plus 20 version in all fairness it also requires the helper our same way which i admitted because it's the same as we saw on the previous slide in line number one we still see very template there's the formula template head line number four now starts making more fun because drc auto is the return type of add and the rest of add here is the same the signature in line number six i see the fold expression as before expanding the arguments in the pack and using the plus operation to add them all together so line four is already improvement i have my return type back but why the y is in line number 3. here we are looking at another part of concept the requires clause which is one of the fundamental buildings blocks for concepts so in line number three i'm now saying requires our same we of my parameter pack arcs a really good precise description right this air function requires that our same we is true i accept that we might have to look up what our same way is and what it does but the rest of it it's so much cleaner and clearer what it does and no more tampering with return types which was wrong all the time but the only way how we could achieve what we wanted so this is first thing what c plus plus 20 is concepts give us where we look at a really simple example already okay that's not concepts just a part of concepts that's the requires clause okay now here are the different application areas for concepts we can use them as illustrated in c1 in the template here is a type constraint and there they replace the type name or class so up front we can start being very specific and say in our template head what subset or what constraint type this template at this point requires okay we don't have to go down there is no static assert that way too late tells us well the type is that's not really wanted here we can say this initially that helps a lot because it's also documentation the other place is the one we already saw that c2 in the so-called requires clause okay in c1 we can only use concepts in c2 we can also use typed rates for example and we can use boolean algebra to say c 2 and some other requirement and some other requirement and so forth in c3 and c4 we're looking at so-called constraint placeholder types these are more or less types where we have auto and c3 you already know that's the return type of the function which can be auto you can also see this it's the same for auto variables so for placeholder type variables where we can say auto we can put a concept in front of them to constrain these types so we can here in this case constrain our return type we can also constrain variables that are of type order and in c4 we are seeing something slightly new you might already notice from 0 14's generic lambdas there we could already have auto is a parameter type and this was extended and we are looking at apprehended function templates here which we will see an example about later but from syntax point it's the same as for the return type of order variables we can now say order is a parameter type and we can constrain that with a concept in this case the same goes for three cc all the concepts are allowed in these places and then in c5 we have the so-called trailing required clause that's more or less the same as the requires clause in c2 we can use concepts and type traits here and the training requires clause is very neat if we need to constrain a function that's not a template but maybe inside a class template so method inside the class template we can constrain with the training requires clause so application areas for concept [music] let's circle back to our ad example and let's look at it with some fresh eyes currently add only prevents mixed types so i can only stick in types of the the same type which is reasonable but the current ad version leaves a couple of things unspecified so currently in my implementation i can call add with only one parameter technically only also with zero parameters and that makes absolutely no sense maybe in highly generic code yes granted but let's say we want to prevent this the function's name is add so it's supposed to add at least two things together calling it with zero or one parameter that that's just a waste of resources so let's not do that let's limit add here as well then a possible requirement c in the next line is the type used in args must call the plus operation you might not even have thought about this because they showed you the implementation but that's a design choice it could also have required that my type must provide a member function at or that there should be a global function subtract which i call which makes even less sense but it's possible okay plus is reasonable here but it's hidden inside of the implementation and we have to figure that out once we pass in a type that doesn't met this requirement so that's one of these implicit arguments and then we have d the operation plus should be no excel at itself is no except i'm not sure if you spotted that one so let's make the plus operation or ensure that the plus operation is no except as well i don't want to build a try catch block around this thing and the last one e is an interesting one the return type of the operation plus should match the one of args right so usually our operator plus if we implement it it returns the same type as as it's called ratio usually the class but it doesn't has to it doesn't have to so to avoid surprises here let's require that the operation plus should return the same time type or must return the same type okay so these are four additional requirements that are pre to c plus plus 20 not that easy to implement so let's see how we can do in c plus plus 20. and for that we need another new thing and that's the requires expression we will see a lot of requires in c plus 20 code when it comes to concepts the graphic here illustrates how this thing works so i read it like a function that's always called requires it doesn't have a return type so maybe a constructor or something like that and it comes with a parameter list and in this parameter list i can declare any kind of parameter i want i can use all the types that are already available like building types like types from headers i included previously say stood string something like that i can use const and ref and star here so i can use a cons t ref t for example you can go crazy with left and or east and west cons everything is possible here requires expression is only used to compile time to evaluate whether the requirements in its body are fulfilled okay it never goes to your binary so we can also use mateendu here are template parameters they're coming either from the concept or from the template this requires expression is used in okay so that's why you can make up any type combination here it's just to use them later and we will see an example where it's really handy and helpful and the requires expression now itself comes with one requirement its body must have at least one requirement it can have multiple but it must have at least one to be valid so here we are looking at a requires expression previously we already saw requires clause this was on c3 in c3 and c4 on my application areas of concepts overview slide and we can see a requires clause as a boolean expression and the requires expression well that's a little bit more complicated it's like what we have with no except where we can ask a function whether it's no except or not and we can mark a function as no except so here we can see the requires clause we previously saw like an if that evaluates a boolean expression and our requires expression which we are looking at here provides such a boolean value okay so this how you can distinguish these two now in this requires expression we can use four different kinds of requirements we can use a simple requirement a nested requirement a compound requirement and a type requirement the last one doesn't make sense for this example so i will show you an example about this later and let's start simple with the sample requirement a simple requirement checks when an expression is valid and will compile that's all it does so here in line number one i'm starting my requires expression i'm using the parameter pack arcs and in line number three i'm formulating the required the simple requirement by reproducing the fault expression i use in the function's body that's a repetition i dislike but that's mostly subject to the example i chose here so that's all what a compiler does for a simple requirement is it checks whether it's instantiable okay so it for example would detect here if my type would not provide an operator plus but it would also detect other things so what we now limited or what this requirement checks here is our requirement c that it no longer works with a struct called no add which obviously brings no operator plus and if i now call add with two no add instances then this requirement will yield false and will most likely abort the compiler start the next thing is the nested requirement and that's a requirement a little bit tricky at this point what it does is it evaluates the boolean return value of an expression and in line number four and five we see a nested requirement and it always starts with requires so the next requires and this requires here is really important if you focus on line number five and if you omit the requires then you have only sizeof.rx grader1 and this sizeof.thing that's an expression and without the requires this is a simple requirement and the compiler will only check whether it's instantiable which it will always be even if there are zero arguments in the pack so we need a requires in front of it to force the compiler not only check whether it's instantiable but also evaluated at compile time and give us the true or false condition okay so this is the same for our same we have to put a requires in front of it with that we have our next two requirements a and b checked and below in the code example you can now see that i no longer can call address 2 and no add and also no longer can call add with only a single parameter that requires expression as we see it now limits the three requirements we found earlier so the last one we have to check is the compound requirement and the compound requirement checks two things at once it checks or it can check whether the expression was no except and the return type of this expression so in line number 10 you see these two checks in one line it starts with the curly braces and then sadly i have to repeat my fault expression as i said probably due to my example and then i say no except and that tells the compiler instantiate and compile them look at these expression in the code braces and figure out whether it's entirely no except or not if the answer is no this requirement yields false and then there comes the thing that looks like a trialling return type error here after you know except and it points to same as and same as the concept is a place where we must use a concept same as chem comes with plus plus 20 and it basically checks whether two types are the same and you can see i'm using first rt here so my helper grabbing the first type of a parameter pack and yeah well to what do i compare it right same as should compare it to something what a compiler does here it figures out the type from the compound requirement so from my expression at the start of line number 10 grabs the type and puts it as the first type in same as so it puts that type implicitly in there and by that i have the two types so the same as here compares the resulting type of the plus operation to my first arc t and with that we have our last requirement checked our last two requirements d and e i can no longer call add with a type that has a throwing operator plus and i can no longer call it with one that returns a different type in its operator plus okay practically you you can split these two checks in into two lines of code that's line number eight and nine that it's totally valid i simply prefer to have them in one line to reduce repetition at this point so congrats we have checked all our appointments we found all the implicit ones in the ad so let's put it together here is what's called an ad hoc constraint line number one we see a template here then line number two we first see a requires this starts to requires clause and then the credit part that's the requires expression we just did build together and then line number nine and twelve that's our implementation of add as it was before okay there's nothing going on line number two is the interesting one there we say requires requires whenever you see that you know two things first we are looking at an ad hoc constraint because we say requires requires and second that's potentially the first sign of a code smell why because we just spent a couple of minutes creating these requires expression okay and it has four lines of code for a very simple thing at this point already so these things tend to grow if we can't limit our types if we can constrain the operation if it can be more precise then we should do this and that means that we potentially write more code to specify the constraints but now we replaced it or we put it in one place and if you need it in another one copy and paste is not the best option at this point okay this is why it's the first sign of a code smell for that example here maybe we can say say it's so highly special and specific it would be okay okay it's always a design decision but it's a first sign of a code smell so think hard about this the alternative which i prefer in this case even is creating a concept so this is our first own concept it starts in line number one with a template head it takes a very number of arguments in line number two i say it's a concept i call it edible and then after the equal sign i assign the requires expression we previously created and used in the attack constraint as well to assign it to this concept and then in line number 10 we see the add function again and then line number 11 i would say it's now even easier to read i say requires so that's the requires clause and then i apply the concept to it edible okay so for me the function is here very clear to read so i think that's nice but it's also more recent reusable because now i have a concept that i can use in different places okay because we will use concepts more and more and they will start becoming more important and more complicated it's important to test them and here's one approach that you can do i have my number three this class template called stop which takes three non-type template parameters to control whether the operator plus is no except whether it has the operator plus at all and whether it it's the correct return type that this operator plus returns okay this is what we have here and i use this step then in line number 16 to 19 to create nice aliases like no add-on valid class because i always fail to remember what stop true false true was doing so it's no add and just there they have everything in place to simulate the the different conditions i can feed to add and now the best thing is we have everything out in place as well we don't need to to go out and find a cool testing framework we already have it it's our compiler and it's called static assert in this case because concepts are compile-time predicates so we can use that in a static assert and test it at compile time as i do here on line number two where it has that i cannot call edible with in the double and so forth then in line but 10 for example i use the stop with no add to check that i cannot call edible with two instances of no add so force so this is another way where concepts are a little bit better than ad hoc constraints because they can now test them without having to test a function but you may also want to add tests where you you test the requirements for the function as well but now you can see if just your concept fails and the implementation of the function has it is a different issue so this is how you can test concepts it's built in use it it's really cool i promise you that we also talk about abbreviated function templates and this here is my motivating example i do have this function template called do locked and this is a pattern i use very regularly where in the body of this function template i acquire a lock or maybe i do something else but in this case i acquire log and once that's achieved in line number six i'm calling the function f okay that's all that thing does but it spares so much code application all over the code base and gives so much more control it's really worth it but there are two things that bother me line number one the template hat it has as many characters as the entire declaration of two locked and the next thing is look at f it's a template parameter nobody knows what it's supposed to do in line number six you can see that it must be some callable some function some function pointer something that's invocable but that's not obvious if you simply look at the signature of two locked you can also pass an internet to it then you're back in the error world okay so that's that's not great in c plus plus 20 i can solve both the issues i have is the previous code with apprehended function templates the first thing is i can get rid of the template head in total because i use auto as a parameter as you can see in line number one and then i can use audio together with a type constraint stood invocable is a concept that's shipped with c plus plus 20 and that signals that you should pass in something there that's importable so you can see it by looking at the signature you don't have to go down in the function's body it's documentation and it's checked by the compiler okay no comment in c plus plus 17 will achieve the same thing then dissolution in c plus plus 20. and of course you can also use the template head and then put the type constraint in there as in the figure initially presented as c1 for example that would do the same job one important remark is whenever you see auto is a parameter to a function should it be a function template as here or a function is here or a lambda then please know that you're always looking at a template the compiler creates in the background the function template out of that thing for us you can use c plus plus insights to to see it yourself and play with it it's it's the same system that we already have since c plus plus seven is c plus plus 40 and with generic letters okay so how great are concepts that's the question and one thing that that people all the time tell me is the error messages are so bad when it comes to templates it's it's totally frustrating so here we are talking about error messages but to do that i have this example here and i think it's better that we start talking about something else and that's this example what it does is i have a let's call it type trade is container here that checks better a type that's pairs to it satisfies the container interface of the standard library and the subset here is it must provide a value type a size type allocator type iterator and considerate time and it also must provide the five member functions size begin and cn and c begin okay that's roughly a container interface and i need an awful lines of code to formulate that and depending on your your knowledge about templates or c plus plus in general if you're fresh to it that's fine if if you see this and work with this code on a daily basis then think about how it was whatever time it was back then when you started with c plus plus and templates there are some interesting things here line number two line number five i have two times the name is container that's really odd usually i get an odr validation for that but not here why well we learned line number two that's the primary template line number five that's the specialization all right you can learn that but then there's the next thing what was stood void t and line number seven doing again yeah right practically nothing it's true oh and then line number 12 decal type all over the place i'm not only talking about the repetition we have here five times but also what does decal type do again i mean i teach it in my classes but very briefly only because i think it's it's facility only important for library writers and then stood decolwell oh yeah what was that thing doing again right it creates me a type of this t such that i can call that size on it yeah yeah yeah i can teach you that as well but i rate i don't and then the best part is have you ever heard about inheritance usually things inherit from a common base class right here i have is container line number two inherits from stood false type let's ignore what stood false type now is again but line number five the second is container oh that that now inherits from a stood true type that is really odd isn't it it is and then line number 21 line number 22 where i test these two things i have to say colon colon value and where does that come from again oh you say from this true type and four steps thinking sure i can learn of all of that just give me another four weeks or so and i try to make it okay that's not nice in fact it makes me cry i am i'm happy that we could achieve all that in the past but you can also use a hammer to put a screw in the wall right so that's the wrong tool c plus plus 20 is the much better tool here first thing only one name container in line number two humidity is that's the common practice is something is for type trades and without the is it's a concept so here in line number two i'm starting my concept call it container and then we see a requires expression which takes a t which is from the titanic t and then in line number four to we can see a type requirement it always starts with type name t and it looks for a type called value type in the namespace of t in lineup 4 and for all the others and this specifically checks that there is a type behind this that's beautiful already right and then the line of nine t dot size because my requires expression provides me with a way to have a parameter for a certain type i cannot call a method on get type at compile time in the requires expression checking whether you're looking at a simple requirement whether it's instantiable or not so here's t a scythe method a begin method and so forth index just nice to read no type not tackle wall no false type no true type move stood is void t and all that stuff it's gone so much simpler it fits in the language and it's simple to read it's simple to teach and it's precise and then line number' and 19 no faults and no colon colon value okay a concept yields already a boolean value it's already fantastic right it makes me really smile but but i promise talking about error messages so let's head over to pilot explorer and have a look at the error messages so this is the code from the slides it's the same here it doesn't mean anything if you cannot clearly read it it's not a point error messages is what we are looking at and i squeezed one additional statement in and let's hear it check for his container of stood array of end of size five and currently that's negated to compile once i remove this not aesthetically certified and tells me that well it's not a container at this point i think clang is a little bit more nice here all right it's not the same thing so my static custod failed due to the requirement this container called column value i somehow guessed that but it doesn't leave me a clue why okay it's okay that we don't ship that one to the customer but it's not helpful in finding the error and some of you might already know what the issue at this point is here is the c plus plus 20 in concepts version and now i am removing this knob from the check here again and then we see first thing is even clang tells us or in clang in c plus plus 20 ah you're studying a third field okay thanks i expected that at this point and then it says because to the ray does not satisfy a container as a node all right i also guessed that because that's the only thing i have in the static assert but then the third line that's the deal breaker or not a deal breaker that's that's a breakthrough because time t allocator type would be invalid force to the array and i also have this squeezing marks under my allocator type here and of course stood array's purpose is to have the memory there at compile time so no dynamic memory allocations so yes thank you that's helpful i can track that down even in the bigger code base where i don't know the types with the error messages of concepts i get to a point where i can fix my wrong code or involve it calls to something so that really really is an improvement that makes me smile okay that's really really great so enough of concepts let's talk about other things that improved with templates in c plus plus 20s namely non-type clip parameters which can now also be of type double here you're looking at an example where in line number one i can declare a template function template called fun which takes a double as in ontap template parameter and that wasn't possible before line number six and seven also illustrates that it's a very precise representation at this point so plus zero dot zero and minus zero zero dot 0.0 are possible and these are different instantiations of fun let's look in compiler explorer at this once again and this time we are focusing on the assembly output here so this is our first call to double and as you can see thanks to the awesome highlighting from compiler explorer this is the positive zero and the line below this is the call to the negative zero and you can see that the bit pattern behind it is different because of course it's a different floating point number in the representation there and once i turn off tmangle identifiers we can also see that the result is that we are getting two different identifiers for this fun function so two different instantiations which we see below that means it makes a difference if you're passing positive or negative zero it's valuable for some applications in math but maybe a trap for others it also increases or has the potential to increase the size of our intermediate object files because the manual names are longer now but as we have a lot of disk space these days i think it's all right and it's better to have floating point parameters is non-type template parameters i'm saving a few bytes of disk space at this point saying with non-type template parameters what else do we have here we have a class template called fixed string it takes two parameters a type name jrt and a non-type template parameter size tn in lineup one and it uses that to create an array of char t of size n in line number three called data and then in line number i declare a constant x per constructor for fixed string which takes a reference to an array of size n of type char t so the same size and type is our data member data has in line three and then it copies the data into its internal representation or its internal buffer to be precise that's cool now in line number eight i can declare an object of type fixed string call it fas and initialize it with uniform initialization with hello comma or c plus plus 20 as a string and that compiled it's cool right but okay that's seated enhancements at this point and not so much about non-type template parameters but that's the building block i use in this version of the code here line number one takes a fixed string or my class fixed string as a non-type template parameter so aside from floating point types we can also use class types if they fulfill certain requirements as non-type template parameters in c plus 20. and here i'm creating this fixed string container class internally it has a function print line number four and there it's c out sdr dot data so the non-type template parameters data member which i made public to have it easily accessible there in real code you should probably think about making it private and employing a member function to access so that's already nice but line number 10 that that's the really cool part i can say that i'm creating a fixed string container and then i'm using the anchor brackets and it pairs a c string to it hello comma c plus plus that's all and that's the first time we can pass a string to a template as a parameter there were only tricks before to achieve that but now it's it's really possible passing it into this class fixed string and now in line number 11 i can call fc dot print so my fixed string container object dot print and it will print out the string hello c plus plus okay so this is non-type template parameter improvements in c plus plus 20. check them out they are enable us to write different code at this point and of course lenders who can miss landers in a talk so they're in mind as well why because lambdas and templates come together here i have an example it uses c plus plus 14's generic lambdas in line number three i'm creating myself a variable called max and this i assign this generic lambda to it takes two parameters x and epsilon and internally in lineup before it figures out which of the two parameters is the larger one and returns that one okay it's an implementation of what you already have in the standard library so use that version this year is only for illustration purposes i can use max now like in line number seven and eight to call it with two comma three and two comma three point zero i'm invoking the landlord getting back to the greater type i'm ignoring the return value here's a it's not the most sensible code but i'm trying to make a different point here it compiles inline number seven and line number eight i don't want line number a to compile we are looking at mixed types again what's the return type of line number eight it's a double because that button wins at this point but i'm risking having the wrong type here or truncating things so i don't want line number eight to compile but with generic calendars this isn't really feasible they are hacked to do it and i don't want to share them now so let's simply say it's it's not possible in c plus plus four you know c plus plus 17 to achieve that with a lambda in a sensible way c plus plus 20 now brought us lambdas with a template hat after the capture clause as you can see in number three we can now start in the ankle brackets a template hat okay we all we don't have to type is template because that's implicit at this point then here so we say and then go bracket a template hat and then we can use type name class non-type template parameters all what we want and now we are looking at what we already know from function templates i cannot say that this lambda takes a type name t and i use this t for my two parameters x and epsilon forcing this lambda to be only callable if x and epsilon are both of the same type because we are looking at templates here and there are no implicit conversions and that means that line number eight still compiles two and three obviously are both integers but line number nine no longer compiles because we are passing in an end and double at this point and that does not compile compiler now tells me does not know how to instantiate that lambda at this point and that's another one we can use now lambdas even better in generic code and also restrict them and it's needless to say in in three instead of type name of course you can use a concept there to constrain the type if you want okay and just to get you into thinking about new things here are two cases or two ways that you can now use lambda thanks to the template head in line number one i'm creating myself a lambda called lamp and it comes with a plate head type name t and this lambda now takes a stood vector of t okay that's possible the first time zone i can declare in line number two a variable of types to vector of end and i can call lamp with we my stood vector of in and it compiles but i can no longer call inline number five lamp with the number 20 for example okay because that doesn't work and that's another thing that wasn't easily achievable before and then non-type template parameters in the template head of lambda and that's the lower example at the bottom line number one there after the capture clause i say size t n and my lambda now takes the stood array of type end of size n and n is deduced by the compiler at compile time so in line number three i'm creating myself a stud array of type end of size two and i can call this version of lamp with my stood array and it will work it will stop compiling once i pass in a stood array of for example type char of any size so lambdas are much closer now the language to function templates we can use them like we can use function templates so that's also a great improvement here it also removes a couple of questions i got in the past why it is not possible like that so just the syntax here is now more uniform on things coming together all right i hope you learned something about templates concepts and all the things you can now do with them in c plus plus 20 of course this was only a brief peek into that there are more things that are under the surface you can head over and subscribe to my newsletter and grab yourself a concept cheat sheet it contains some two pages at the moment with the most important parts about how to piece concepts together or what's the elements in concepts and where and how to use the different things so that's helpful as i said you can also later come to the book fair and then check out my programming we see plus 20 book which of course also covers templates and we now have a few minutes left so after that we can go to the q a and if the hours are where we can move to the table and we have there 10 minutes okay so i hope you enjoyed this i hope you enjoy c plus plus 20. i hope you enjoy meeting c plus plus i'm looking forward to meeting you either at meeting plus so hopefully at one event where we can meet in prison hopefully in 2020 at this point i'm fairtick thank you so okay thanks for the nice presentation so actually we have two questions here should i just read them or do you want to [music] if you're already prepared it's probably i am trying to get to them okay i see them okay so first question is as a library developer would you rather create the oh no it's flipping the egg or the chicken first meaning would you rather create for instance and student work concept first then a student work function which is which first parameter is constrained using invokable or defined and workable as requires invoke well good question in my experience these things often come together so the moment you start for example creating the function invokable or invoke you figure out that it might be the good idea to constrain it and then write the concept invokable so i think from from the basic idea maybe the function comes first but once you start writing that you pause and write the concept and then figure out that that you have the tests in place and then write the the function seeing that that it works as as expected i hope this does answer your question and the next one is on the examples you showed now most of the requirements were nothing more than each statement of your function can be called does it mean at one point that the standard will say when no requirements are here each statement of your template function will be an implicit requirement oh that's an interesting idea well despite that i'm in the committee it's very hard to say what the future will be i don't think so and thanks for noticing this pattern i didn't see it before i think that's an artifact of coming with slide code so with an example that fits on the slide and that's readable and adjustable for the audience in time it may be good if you achieve the same thing in a real world code base such that every line comes with the requirement that's checked but that may also be too much so i think the idea is good whether it's achievable all the time it's a different question and this is not a point i did want to make but i agree this is what i showed so and then the next question for slide number 19 thanks for using the slide number so let's see what's on slide number 19 this one are you sure that static assert which stood invokable of t did not do the job for c plus plus 17. the static assert will do the job the difference is the static sword i don't know where you would put it but somewhere after line number two and before line number six so inside the body of do locked and by that users have to look into the function to see which the requirements of this dual locked function and what i'm mainly saying here with the concept as the parameter and it doesn't matter whether it's in the template head is a type constrained or here in the placeholder type constraining the placeholder type it's not a function signature it appears if you use the the ide of your choice and then you see the function it's documentation and it's it's not hidden inside the implementation of do locked so you can achieve the oh you shouldn't use it with that type situation in c plus 17 but that's too late i want users to have a way to notice this up front and only have the compiler jump in if they violate it because for some reason they i don't know didn't understand it didn't saw it ignored it whatever okay but the static assert inside the do log function that's too late in my experience all right and by that i think we are over time as i said we i will move over to the table we have i don't know five or a little bit more minutes before i have to head to the next table for the book but i'm happy to meet you there and see you there and talk to you for the first time then yeah and thank you again for your talk and we'll see at the question dancer table thank you for listening bye-bye and bye