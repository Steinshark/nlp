hi everyone by the end of this episode we'll have the basics of our curve editor setup so we'll be able to move these points around and also click to add in new segments ok so i'm going to be creating three scripts a path script for essentially holding and managing all of the points in the path then a path creator script which is responsible for creating and holding a reference to the path that we're currently working on and finally a path editor script for displaying and allowing us to manipulate the path in the scene view now this path editor script needs to go inside of the editor folder so when i put that in there and i'm going to open up the path script in here i'm going to remove this default monobehaviour code and just create a list of vector tools for holding the points and i want the starter to be saved but not show up in the inspector so i'm going to add both the serialized field and the hide in inspector attribute to this and i'll also add the system dot serializable attribute to this path class now i want to quickly create a constructor for the class so public path is going to take in a vector to center and here i'll initialize the points list to a set of four points around the center making up the first cubic curve so if this is the center here i'll have an anchor point on either side of it and then my two control points say here and here making up a curve that looks like this okay so in the script i'll say points is equal to a new list of vector twos and then open a pair of curly brackets and in here i'll have center plus vector two dot left then center plus vector two dot left plus vector two dot up x 1/2 center plus vector two dot right plus vector 2 dot down times 1/2 and finally center plus vector 2 dot right okay now let's say that the user clicks near the bottom right here to add in a new anchor point to complete this new segment were getting you to add in two control points the first one needs to form a straight line with the previous anchor point and its control point so that the two segments joined smoothly the second control point we can place wherever we want but i'll put it over here halfway between the last anchor point and the previous control point this will give us a curve that looks something like this let me quickly label all of these points with indices in the points list and then i'll go into the script and create a new public method called add segment which takes in a vector 2 for the new anchor position now we need to start by adding in the first control point what is 0.4 in the diagram so the position of 0.4 is equal to the position of 0.3 plus the displacement from point 2 to point 3 so 0.3 plus 0.3 minus 0.2 or in other words just 0.3 times 2 minus 0.2 so i'll write points and dot add and at the time of adding this point 0.3 is the last element in the list so i'll say points with an index of points count minus 1 x 2 minus 0.2 which is points with an index of points count minus 2 the second control point what is 0.5 in the diagram is just half way between 0.4 and 0.6 so hence s position is equal to 0.4 plus 0.6 divided by 2 in the script that comes out as points with an index of points count minus 1 plus the anchor position all divided by 2 so let me put that in parentheses and i'll just multiply it by 1/2 all right finally we get to add our new anchor position now that we can add new segments i'd also like a way to get the points in a certain segment so i'm going to create a public method which returns a vector to array i'll call this get points in segments this takes in an int for the index of the segment so every segment has got four points first segment would be points 0 1 2 3 and the second segment would be points 3 4 5 6 so we can return a new vector2 array and the first point in here will be points with an index of i times 3 then the next will be points with index of i times 3 plus 1 and then i times 3 plus 2 and finally i times 3 plus 3 all right now we also want a way to get the number of segments currently in the path so i'm going to create a little accessor here public inch numb segments and inside the get block we can calculate this so for the first segment here in the constructor we're adding 4 points but for subsequent segments we only had 3 points since it shares the last point of the previous segment so we can say that the number of segments is equal to the number of points minus 4 divided by 3 that will give us the number of these additional segments we've added and then we just need to add one for that initial segment ok now i'm also going to create a accessor to get the number of points in the points list so this is angel return points count and then i also want to give the editor script an easy way of accessing the values in the points list so i'm going to create a public indexer so this is of type vector 2 and then we save this and in square brackets and just have into i and in the get block just returns points with an index of i now full setting the position of a point we could just add a set block here but there's going to be a bunch of extra logic that goes along with that so i'd rather separate it out into its own method i'll have public void move point and this takes in an int for the index of that point and a vector2 for its new position for now i'll just simply get the point in the points list with index i and set that equal to the new position all right i'm going to save that and go into the path creator script and this is going to hold a public path variable which i'm going to hide in the inspector and then it's also going to have a public method create path and this is simply a reset path equal to a new path and we need to pass in the center so i'll just make that the transforms position okay i'll save that and head over to the path editor so here we're going to want to use the unity editor namespace inherit from the editor class and say this is a custom editor type of path creator all right and now you want a reference to the path creator i'll just call that creator and i'm gonna be convenient if we just have a direct reference to the past as well in here all right so when this editor is enabled then we can set greater equal to the editor target cast as a path creator like so and then i'm going to say if creator dot path is null then it should croatian new path and then we'll set path equal to created up path and then we create a new method called draw and i want to start by creating handles it can be moved around for each of the points in the path so i'll loop through all of the points for an equal 0 i less than path dot number of points i plus plus now the handles dot free move handle you can get the current position of the point with path i so making use of that index i we created and i'll just go to any on that identity for the rotation so no rotation i'll try size of 0.1 no snapping so vector 2.0 and then we need to pass in a cap function to tell it how to draw the handle and i wanted to draw it as a circle and there is this handle start circle handle cap function but that will only draw the outline of the circle so instead i'm going to use the cylinder handle cap like so ok now this free move handle method returns a vector 3 for the new position of the handle if it's been moved so i'm going to rewrite vector 2 new position is equal to that and then i want to check if the position has changed so i'll say if path with an index of i is not equal to the new position then i'm going to say path and dodge move point passing an eye and the new position and i also want to record that change with the undo system so to say undo drop record object recording the path creator and i'll call this move point alright we can also maybe choose a color for these handles so i'll just say handles it off color and i think i'll go with color dot red ok i need the straw method to be cold from somewhere so i'm going to create an unseen goobie method and i'll just call draw from that ok i'm going to save that and try this out quickly so once that compiles i'll a new empty object add the path crater to that and we can see the four points here and should be able to move those around she also test that once we move one of them we can then press undo to undo that movement and that does seem to be working nicely okay so let's head back to the script and i'm not going to draw the curve between those handles so i'm gonna great another for loop and this time it's gonna be i less than path dot number of segments and i'll start by getting a vector to array called points which will be equal to path dot yet points in segment passing in that segment index okay i'm now going to say handles dot draw bezier and we can see this takes in start position and positions dart tangent and end tangent so start position is just points with an index of 0 and position is points with an index of 3 and then start an end tangent or just off first and second control points so points 1 and points - ok then lots of color so just pass in colored of green and it won't say texture but if we read the summary here you can see that's only forgetting an anti aliasing effect don't really care about that too much right now so i'll just pass in null and then i'll also width and i'll just pass in 2 for that i'd also quickly like to draw lines going from the control points to their respective anchor points so i'll say handles and dodge draw line going from point 1 to point 0 and also from points to two points three and i'd like this to be drawn in black so i'll just quickly set handle store color equal to colored or black all right let me save that go into unity and should see this updating in a moment and we can now just play around with this a bit to make sure that it's all working as expected and it just seems to be so i'm going to move on to clicking to add in points so i'll go back to the editor script and i'm going to make a new method called input and in here on we start by getting the current gui event so i'll say event gui event is equal to event dot current and i want to figure out the mouse position in world space so i'm going to say vector - mouse pose is equal to handle utility gui point to world 3 can pass in the gui events mouse position and i'll just get the origin of that world right okay so and now i want to say that when the user shift left clicks it adds in a new segment at that mouse position so i'm going to say if a gui event type is equal to event type dot mouse down and i want to make sure that this is the left mouse button so q dot button is equal to 0 and also only check that shift is held down so gui event dot shift all right so if all of those conditions are match then i'm going to say path dodge add segment and pass in the mouse position i also want to record this with the undo system so i'll say undo record object creator and call this add segment we then just need to call input from the unseen gui method and then when that finishes compiling should be able to shift left click to add in these new segments cool so that is working properly and we can just check that the under system is recording that properly as well and that does seem to be the case so what i want to focus on now is when i move a control point i want the corresponding control point to rotate with it just to keep the join between the two segments continuous additionally if an anchor point is moved then i want its two control points to just move along with it so let me head over to the path script and in this move point method let's start by handling the case where an anchor point is being moved so anchor points are always at an index that is a multiple of three in the list so if i mod 3 is equal to zero we know that removing an anchor point and then we just want to move its two control points by the same amount so up here let's calculate the change in position of the point so call this delta move that's just equal to the new position minus the current position and then if we're moving an anchor point we can just say points with an index of i plus 1 plus equals the delta move and points with an index of i minus 1 plus equals delta move as well now of course for the start and end anchor points one of these control points won't exist so that'll give us a out of range exception so let's just check if i plus 1 is less than points count then we can do that and for this one you need to check if i minus 1 is greater than or equal to 0 then we should be safe all right now what if this is not an anchor point well here we want to start by figuring out the index of the corresponding control point now if the next point after this control point is an anchor point that means that the corresponding control point is two points ahead of the current point but if the previous point is an anchor point that means that the correspondent control point is two points behind the current point so let's figure out is the next point an anchor point so this is true if i plus 1 mod 3 is equal to 0 then we can say int i'll call this the corresponding control index and then in is a ternary operator to say that if the next point is an anchor then it's equal to i plus two otherwise its equal to i minus two now i'd also like to know the index of the anchor point that these two control points are attached to i'm going to write inch anchor index is equal to and of course if next point is an anchor then that will be simply i plus one otherwise it will be i minus one okay so now i want to move the corresponding control point but i wanted to maintain its current distance from the anchor point so i'm going to record that distance here float distance is equal to the anchor point minus the corresponding control point dot magnitude then i'm also going to get the direction from the new position of the control point that's being moved to the anchor so this will be equal to points with an index of anchor index minus the new position dot normalized and then we can just say points with an index of corresponding control index is equal to the anchor position so points anchor index plus the direction multiplied by the distance now of course before we do any of this we should make sure that the corresponding control point actually exists so let's just check if corresponding control index is greater than or equal to 0 and corresponding control index is less than point star count and i'll put that all in there okay here so if i save this go back into unity when that compiles should see that if i move an anchor point the control points move along with it and if i move a control point the correspondent control point rotates with it but always maintains its same distance okay that is gonna be everything for this episode so until the next one