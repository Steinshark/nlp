thank you for you know being part of this thank you for coming today olaf for really looking forward to your talk which actually is about rappers number here so let's take it away and see what you have to say thank you so my name is oliver and we're going to be talking about sandbox games using webassembly and c plus to make a a simple game simple game that's kind of the the main point here today so yeah that's the answer introduced my name is i am a senior software developer at turbo secas here in norway you can find me at oliver w on twitter while that's still a thing which is also one of those one of those things you can yell at me afterwards i work for turtle tech as we are a consultancy and training company we do all sorts of consultancy work we also do trainings at conferences so if you are at c plus or similar conferences you might see trainings by us so if you do see them please join and also talk to your companies about trainings i like to it's been kind of a theme year for me to have these philosophical quotes in the beginning and and i like to have have these philosophical quotes to start with and here we have i must go forward where i have never been instead of backwards where i have and that's of course winnie the pooh winnie the pooh lovely lovely guy so let's do a little what this talk is and what this talk isn't this is not going to be a game development talk or a game design talk so a while ago how this talk actually started to how this talk came to be i was making a game using webassembly and just figuring out what's going on what these things are and i i hit my head on a whole bunch of walls along the way and i kept notes and they saw basically the notes that i i from that session or sessions this is also not a comprehensive talk about webassembly that was another thing that i found when i was going through webassembly is there's a lot of talks about it especially simple personal assembly but those talks are very in detail like one person took i think gcc and converted gcc to webassembly so they're very like nitty-gritty details this is more pragmatic this is more i want to do a hello world i want to have a little project where do i go from here and what you'll get with this talk as well there's a bunch of links at the end you'll get a bunch of like simple small starter projects in various stages of of development so you can pick and choose and look at or adapt to your to your needs oh yeah thank you for the talking about the people liking the test slide that's very good so yeah the idea to be pragmatic and learn what this tool has to offer because like with anything else this is a tool repossible is a tool like anything else so so let's look at the problems we can solve so let's start with what is webassembly how can something be neither web nor assembly because so webassembly is a binary format yeah kind of kind of an asterisk on that one because so it's a lot designed to allow for performant execution of code within browsers that's kind of the initial idea it was announced in 2015 we have a working draft in 2018 a w3c recommendation in 2019 so it's relatively new although like the history of it is a bit longer than than that and a nice way to think about web example in the beginning is think of it as the target output of any language it doesn't matter what the language is representatively as a target output and even in recent times you can execute webassembly outside of the web so again it's not not necessarily web but it's a type of a execution environment if you think of it that way so the text version of web assembly kind of looks like this you have a function called add it takes in two parameters here called zero and one and it returns an i32 so you can see that it has types it has name for functions it has some sort of maybe you can think of it as scope you're adding two numbers there so you're fetching the local variable of one and zero you're doing an ad and it's a stack based language so the last thing on the stack is the thing that is returned so the last thing on the stack here is an i32 ad of these two local variables so that's the thing that's being returned so if you're reading through webassembly that's kind of how how you read it and we'll see way way more complicated ones and this is this function basically so adding two numbers together cool okay so many of you might associate webassembly with games and even yeah this talk is going to do that yeah where possibly is so much more and and you'll see you'll see what it has to offer i use games mainly because it it ticks a lot of the boxes that you might want from an execution environment it's executing code it's doing something visually it's it's maybe getting input from from files or or keyboard or mouse or whatever so it's ticking all these boxes but but don't focus on games even though we're gonna do that here today so here are some examples that you might think of not think of that are written with webassembly winter calculator so someone took the the code for windows calculator and converted it to webassembly i think microsoft open sourced the calculator a few years ago and yeah someone just made a web assembly executable from it then here we are that's the calculator if i remember correctly the whole thing like the whole website thing is not webassembly but there are parts of it that are reversibly so it this whole thing is not representably but a lot of things that are happening here or someone made like a photoshop like application in web or something and then later i heard that adobe might be doing something like that or are doing something like that themselves so yeah you can make an application like this and again it can just be the code so tensorflow.js the machine learning libraries has a webassembly backend so that's been pretty performant as well here is i think this is protein folding if i remember correctly so there was a website that does like these protein foldings and you can like you can lend your computer to help with protein folding and they converted some of their stuff to webassembly and got a 20x speed up the 20x beat up is is pretty high so don't expect if you convert your stuff over simply to always get a 20x speed up i'll show you some caveats later on with that so let's start with m script then so what is m script then because this is webassembly before webassembly so we originally had asm.js from mozilla it had similar goals to webassembly to run the phishing code on the web but it was a subset of javascript so you would take your low level code compile it with asm.js you would get javascript out and that's the thing that would be executed and that that's where m script and came to play initially was to help with converting your your lower level code into asm.js outputs an m scripting is the tool that we will then be using because they can also target out webassembly so m skating is based on llvm and clang so that's the tool sending you have and you can get many different types of outputs the files are called vasan files or dot wasn't you will also see dot js or javascript files and dot html in the stock so let's go over the installation process so if you were going through this and and wanted to set this up yourself so in this example we're going to use vs code that's the editor i'm using wsl2 you're using ubuntu 20. here's the code if you want if you want to take a screenshot and look at it later it's on my github called talk acc webassembly so you can do a suto of your favorite packet manager which one that is we at least need python 3 cmake and git that's kind of the base we need for this we will clone the m script then repo called emsdk we can go into the folder we can do a git pool for a good measure where if you're doing this later on there's a script there called emsdk called emsdk and install latest and this will then install the latest version of m script and into your machine it's a similar setup on meters or similar scripts so and this will this will take a little while but don't worry there and then you activate the latest it's one of those where you can have different versions installed and you can switch between them if you want to do that and there's also an emsdk environment script you can source it now or you can put it in your pass rc or something similar or put it in your in your path in windows yeah that's a similar one for windows as well what this will do is this will bring the m script and compilers into your path which is kind of handy so you can say emcc version and you will get this kind of output or something like this you can see m scripting is a gcc clang like replacement and some information and i can also say which emcc and it's in some home folder that i have if the msdk and then yeah the the script is there somewhere okay so now we basically have most of the things that we need to start developing so what should we do well it's the time order tradition right we're going to do a hello world right but there's a couple of more steps there's a there's a few things that we have to think about so this is hello what i'm going to do i'm doing in the c just because i thought it was a funny way to do hello world because most of the rest is simple plus but yeah here see include studio printer fellow world and return zero right i can compile it like this emcc hello world c able it will compile everything is happy the output you get looks like this you have a out.js and a out.wasum okay so what is this what can i do with this thing well not much what you can you can actually if you have an application called node node.js you can actually run a out.js at least in this state of the application but we want something else we want something more and what you actually do is you say emcc hello world.c and you say that the output is going to be an html file which is pretty pretty weird for for some i mentioned and what you get is a hello world html and then the the two files from before the javascript file and the boston file so yeah we have an html file we have a browser so let's open it well it's pretty long 1300 lines the html file and the javascript file is 2400 signs so what is this what are these files what are they doing because this feels like magic right i get some awesome file and then i get two huge files and and i'm not i'm not happy with that i want to learn why why what is this what is this doing so let's do that yeah with note you can run the javascript file just fine yeah let's open the html file should be no problem right no so this is the first wall you will hit because of course there's a problem browsers don't like opening random files from whatever location you decide that's that's the thing there's a thing called cross origin resource sharing or course so by default browsers don't like loading external files from disk because if you double click on the file it's going to open the html file fine but all the external dependencies the javascript file that we made the dot wasn't file that we made they are external files on disk and the browser is not going to allow you to open them so what you then need to do is to run a web server so for hello world yes you need a web server so ms kitten has a tool called em run and we will use that tool for for fewer for examples it's a very very basic web server so it's it's fine for development but as soon as you get a little bit more complicated you need to replace it with something else like an actual server or some some development environment but to begin with vm run that's fine they will do your your thing you can run it like this em run you give it a port you say hello world.html and it looks like this so we have our little hello world i can research the canvas and you can see so this thing in here in the middle is the canvas and here is the output so if you have any printable output using printf or or c out or any of those things when you're running it and developing and refreshing and doing that iteration you'll see the output there so hey we have hello world we should be happy right okay so let's look at the game we'll be making and because i talked about that this isn't going to be a game development talk i'm not going to go into super detail of how the game is made just we can look at how it works and you can look at the code afterwards and play with it that's totally fine you get full source code access to the game so the game we're going to make is a simple sliding puzzle game similar to games like threes and 2048 if you play those games so it looks like this so i can press up and down on the keyboard and new boxes will appear but if i then slide for example to the to the left those those two boxes will join if i slide down the the twos will join and then therefore will join and every time you do a slide a new box will appear so you can like you want to try to create like a really big number so here i've got a 16 second a four i got the 216 so i could slide down to join those two sixteens etc that's the game so we have some something visual we have some code we have some state we have some input that we have to deal with okay cool so let's convert this game over to webassembly because currently this version of the game is in javascript it's only javascript and html and nothing else so there are two ways to do this we can keep the drawing part of the the game in javascript and do the logic in the the state management and all this in simpleplus or we do everything in super plus even though even that drawing and we're actually going to look at both and we're gonna we're gonna hit some more walls in the way so let's look at some of the functions i mean if you're converting stuff over let's look at the stuff we have to convert okay some of these functions that we have even in the code don't even need to know about game state they they're just general utility functions so let's start with them right sounds like a good idea so here's two functions in the in the auto script version we have a get random coordinate so when i create the new box we need to find a random place to put the box so i get a random coordinate and i can also ask the question are you outside of the box which is just is the x bigger than the length of the board so i'm just testing so you don't go outside of the board so these are pretty simple functions so let's create the c plus version so here i have i include m script in the rates so after you install them scripting from before you should have access to m script and h i create a context per variable of port size i create a function called ace outbounds takes an x and a y the body of the function is the same we have a thing there called m skit and keep alive you'll see why we need this in a second and i also do an extern c and the reason for extern c sorry is because we need to access these functions from outside of the watson file because we don't want the name muggling to happen so we say external c of the functions so it's and it's only for the functions you want to expose so basically think of this as the things you want to export and this is the whole file this is the whole thing and this is the thing that we're going to compile and this is why we need m script and keep alive because this is the only function that's in the file there is no main function and there is no function calling this is outbounds function so we need to prevent that the compiler will actually optimize away this function so that's why we have abscape and keep alive these are just different different ways to prevent the compiler from from deleting our function we compiled it this way so emcc and g that's the source map you'll see why in a bit we need that we say no entry this means that there's no main function and i also say dash as standalonewassem and this is the the thing where i want to make this html and javascript file myself so it will only give me a dot wasn't file and this all this other stuff i have to make myself i gave it the name of the file and i say game logic html and we're not going to use that html file we're going to make our own things so because we want to know how this works we want to we want to learn what is actually what this is actually doing we make our own html file and make our own javascript file and in our javascript we do this we say import object this is an empty object we call web or simply thought instantiate streaming we call that on the game logic wasn't file and this will then load the file in the memory and we give it an empty import object and at the time i had no clue what this import object is so let's learn what what's happening here this is an asynchronous function so i do a dot then and i get results out and within those results is the instance of the watson file and within the instance of the watson file are the exported functions and within the exported function is our is outbounds function and what i can do now is because then i can say var is out bonds is equal to this function there and then i could just call the function so i can use s outbounds like a regular function i can give it two arguments and it will do its thing and here we have webassembly running and it's just this one function and nothing else so cool we are happy we are moving along breakneck speed so let's do the next one right we did we did the first one and now we're going to do the next one so the next one is get random coordinate this is to find out where we are on the map so it says math.floor and then math.random okay cool seems simple enough no it is not simple enough because where we are going there is no operating system so this is kind of the idea of the sandbox that we have because with the standalone watson file there is no operating system level functionality it is only that file and only that one function that we wrote into it you are all on your own kinda so how do we solve this problem so if you want to use random if you want to call timer functions many other operating system will have a functionality it has to come from somewhere right so thankfully there is a solution to this where if you build that the javascript file that we saw before in addition to your watson file that's the javascript file is your gateway to the operating system if you think of it that way so you can actually then call functions on the c plus side over two hourscript javascript will do its thing so you have exited the sandbox javascript will do whatever it wants to do and then it will come back into the washroom and then you get the results and so kind of think of it like a syscall that's happening here but instead of being assist call in an os it's a cs call where you're going to the javascript world and then going back but yeah how does this work can we do it ourselves there's a function within amsterdam called m script and nantum and this is just after i was googling like how does this work and it will generate a random number between zero one and it says here this maps to math random okay this looks great but how do we use it so what i did was i just said okay get random coordinate return and scranton right this compiled i was happy like okay let's change the the javascript part here you see here you see the whole html file i just say same thing import object it started streaming i get the results i get the function and i would like to print it out control log like what happens when you call this function i mean it seems sensible right but no it doesn't work so here it says web or something instantiate import module and error module is not an object or a function and this error kind of doesn't make sense if you if you ever happen to encounter it and what it's saying is that this import object here that's the important bit i'm sorry if you can hear my cat snoring oh that's okay she's sleeping very nicely i think so this import object this is the link between the the wasem world and the hours with world so it was asking for an object called nf so i'm like okay let's put an object called and in this import object does that work does it change anything well yeah it changes the error message it says module and function amp scripted random error function import requires a callable again this doesn't make sense so what's actually happening is if we now look at the bottom so this is the whole file there's nothing else there in this example i didn't have the other function just to simplify what's going on but we've only like the thing i showed it before is we've only looked at this part there's a function it's called something this one doesn't have a return value and we we do some work but look at this line over here it's we say call n m scranton so what is that so the thing that we haven't looked at in the watson file is the top part we can think of the top part as the the module definition or the header or something like that and you can see that on the second line there we are defining that there's a function called nskinton which is going to be imported it's going to be an in an object called nf there's going to be a function called amps with an anthem and it's going to return a value of f32 okay so what this actually means is there should be a function here so in the end object on the import object that you give to the instantiate streaming there should be a function called m script and random so here is the actual then implementation of random that our wasp file is depending on so again think of of the os level connection here the watson file needs random it can't implement random or like it doesn't implement random we need to run them in some way we go out to the javascript we call a function and then we go back and yeah this works this you're happy here and this is what the the javascript file is doing this is why it's so long because it's figuring out what it what are all of the operating system level things that you need from the outside let's fill in the javascript file with everything you need so yeah that's kind of the heavy lifting that m scripting is doing for you and other tools like it's not just okay so now we can move over to the rest of the logic the board is an array of arrays of boxes and the rest of the game logic is is basically identical i can show you in a bit so now the gameplay can be simulated and called from javascript but now we need to draw the data so we actually converted all the functions over the game state is iterating it's doing its thing but i would like to draw the data on screen and that's the next issue point where's the data because now i have a state in the in the watson file how do i get it out so we can communicate between c plus or was a millennials gift using primitive types like you saw before but soon as stuff gets a little bit more complicated you are in a bit of a trouble you could actually view the raw data of a stitch vector let's say you have a stitch vector in your supervisor side but that doesn't mean anything to to javascript like the list in javascript and vector in in webassembly don't match they're not the same data type there is a thing called em bind that helps us with passing these more complex objects so here i'm describing a class and i'm describing how do how how does the constructor look what are the functions the properties the static functions and you could do this to your your types there's even a thing called so embient has utilities also for vectors so you can register a vector you can say like there's going to be a vector it's called this that looks like this so then you can send the vectors back and forth you can even define a shared block of memory that can be used by either the object or c plus there's even an option to return a pointer you can yeah be careful please yeah this is you're in a territory we need to be a bit more careful but we possibly actually have some guarantees about like assumptions about the execution environment like the bytes are 8-bit addressable with the pipe memory underlined memory tools complement ieee little ndn those things so if you want to do like these more more finicky things it has these kinds of assumptions that you can take so like with any any restrictive execution environment so at least in this case yeah thankfully i wrote the game logic with with basically primitives so i can just send instance and floats back and forth so let's look at that version of the implementation so this is actually that version of the game it looks the same but the logic of the game where where the pieces are where they're moving all this stuff that's happening in in webassembly but the drawing is happening here so the calls are going back and forth so there's a lot of calls happening here that are going back and forth between representately and table plus so it's also it's not slow like you don't have to be super worried about this there's one thing as well that you might be thinking of like how am i doing this like how am i playing the game in the presentation and that's because did i not click here the presentation itself is also written in webassembly that's a bit of a bit of a twist here so i wrote a little slide application thing in rust so i have like this slight parsing code in rust and then i have the actual slides here in markdown and then in the markdown i can actually do an iframe of the game and the game is actually running here so all of the games are are running here in the background so i have all the examples running ready and the the slides are just showing the iframe of the the thing and i thought there was just a fun way of showing you other ways that webassembly can be helpful to you and this is called using a library called i think you say u it's y-e-w which is inverse and you also get you can actually access to this code as well if you want to look at it so that's what's happening here just a little fun example okay so this is working i can i can actually show you here let's go back to this it was i have this url here go to the actual page so this is the the web page itself let's go and talk this down here also because if you're thinking of like development and then how you are working with this whole thing so here i have the game it's in this like little canvas block over here and i can play the game you have control output so if you want to print things you can do a control output thing with the sources and this is so it's working for me here in some of the situations this was a bit finicky but you can do this you can actually get the cpp file itself so here i have here you can see the get quantum coordinate these are the bounds there's another one for is empty and you can ask the box if it's mergable like the the actual cpp code is here and if i put a break point here and then move the game i hit the breakpoint and i can see the actual values the the local stock and i can see the call back [music] basically the call stack itself but what this is doing i remember when i said when i'm compiling i say dash g and then dash source map what's happening is i'm actually putting a break point in the watson file so in the watson file is the breakpoint it's just mapping that line 54 in in game logic cbp is line whatever in the watson file so that's actually what's happening so yeah it should be it's a pretty long file but you can see like you can also get the file itself here and then look at what's happening and you can see also like we had the game we have the game running still the only thing that we ask for the from the external environment is the random function it's gonna fill up in a bit but it was fun that in in this case it was only the random function so i didn't need anything else yeah breakpoints is really cool to to see and i can put them in any file i but but note like i had some issues that sometimes the cpp files wouldn't appear and it seems to be about how you host the web server and where the paths are and and yeah but yeah we can do that and continue and continue playing the game and also because this is chrome you have the network tab if you do any networking things you have the performance tab so i can go here and play the game and hit stop and i get let me see here oops this is interactions yep let me make this a bit bigger here are the the calls so i can get the what's called the flame graph or whatever people call it so here's the main function a lot of gaps here between but yeah you can see all this stuff and the cool thing also is you get the screenshot of the game and you can be like oh it's over here here's the problem okay let's click there and zoom in ah i see the problem this is taking too long but whatever the problem is so you have chrome's developer tools and performance tools you get them for free basically so i think for memory you can take heap snapshots and all these other fancy things that chrome has and simple firefox as well what happens if you modify code when it's running you have to recompile it so you need to because what you're actually running is the awesome file so unless you're able to con modify the watson file while you're running so you have to yeah you have to modify the you have to modify the code recompile it and then yeah now i see the potential of google chrome my least favorite browser well it's the same in firefox if you want to use firefox so if firefox is your favorite browser you can also do it there i haven't tried opera but i also hear that it's the same thing same thing there so development that's kind of cool okay cool so now we basically have everything except the rendering in c plus right so let's move over the rendering because before i can actually show you if i can show you the project as well since we we have time we have plenty of time so this is the project that you can look at later it's numbered based on where we are in the process of converting the project so what js canvas is the whole game in javascript only so here's just a simple little bit quicker simple html file you have the game you have an update loop you have a draw function you have a main where you're like queuing up calls every 60 seconds getting a kind of context and then listening for keyboard events and yeah it's a very and then you have the the box logic of the boxes moving around and doing their thing if you want to look at this later and then there's all in within each folder there's always a little script hinting at like how you can run this so here is how you run this one for the here's the hello world then you also have how you can run the hello world how you can build the hello world and then we're here now with in three so this is awesome but with only game logic so we have our box in c4 plus we have the game logic and simple plus the thing we looked at before and you also we have the run script and you have the build script with all the the commands you want to use yeah here's the the gng source map and again we do we're doing no entry we're doing standalone awesome so we only get a awesome pilot that's the only thing we get and then yeah there's more in the project itself all right so because now we have the game logic in simple plus we have the the drawing in javascript let's move over the rest so let's do everything in c plus and the javascript version does basically nothing or very little or at least the code that we write for the architect is very little okay so thankfully m skating has great support for exactly what we need amp screen has built-in support for a thing called sdl which is a cross-platform library that provides all sorts of things the thing that we actually need is graphically graphical rendering it also does audio it does input it does yeah lots of lots of great things and it's usually used for games it has stl1 built in but for stl2 you need to download it and there's also there there is a script to download because there is kind of a chicken in the egg problem with stl that if you don't have stl installed and you make a project that requires sdl it doesn't compile because it can't find the stuff so there is this kind of what i call a first install script that is an empty cpp file but a build script that says hey we require sdl which we'll download the stl and then you can just delete this okay yeah and these are the commands you just add these to the build commands so and because we are using stl2 and all of those related functionalities and we we have now learned how how this works because there we've learned what the javascript file is doing it's providing the operating system level functionality to us the html file is just holding everything in place so then we will we're okay with using the the javascript code it generate so we're going to do that we're no longer going to be awesome standalone we're gonna we're gonna let m script and generate everything for us so yeah instead of creating the import object ourselves m script then it's going to do this for us and i can show you that file in a bit this also means that our our game is going to need the main function because we are no longer standalone and here we have some some information and if you have a canvas and you do an htl create window it will create the window on the canvas in the the thing that you are actually displaying so in the xml file that you have but this line here the bottom line is the one that i'm i'm most interested in because we don't want to hog all of the kind of the resources or the time so what we say is there's going to be a function called game loop and we're going to tell amp script then call this loop as often as you can so this is going to be your loop because otherwise if we call main it's never going to exit and the browser isn't going to get any time because they they share time between each other so i pulled over the rendering code it's very very simple rendering code it's let me actually show you real quick we go here to the game logic it is this i create a rectangle i set the color i draw the rectangle that's it let's click on oh yeah okay no i remember now i had the happy examples so drawing is we create a text here we set the background color for every row in the board and for every box in the row we draw the box and then we copy the texture and then we clear the texture and then draw looks like this that's the only thing that's happening so i created a rectangle of a certain size i set the color and i filled the rectangle and the texture is just on image and i i say like put a red rectangle here and then every frame i'm changing where the rectangle goes foreign so it compiles and in the beginning i'm only i'm only interested in the box i just want to see the box i'll do the text that goes on top of the box later so just the the box right now so it compiles looks like it should i run the code i see the box okay great i look at it for a couple of seconds and then boom runtime error aborted cannot enlarge memory arrays to size and then some certain size and it gives me some hints there so what's going on here so wall number four the sandbox is an infinite so up to this point we've been using the default memory size from amp script in and it just happens to fit but we need more memory now since sdl is involved we need to create textures we need to create images and that kind of thing so there are a few things you can do you can this is just again command line arguments you can add to the the build build step you can set the initial memory to a certain size if you say that the total memory is a certain size and you can also allow for memory growth so you have some flexibility there you don't have to use all three i use all three just to show you but you can pick so again this compiles and now we see the box okay i just changed the the size to something bigger and we're happy the next step is then to draw the text because it's a two-step process first we draw the box and then we draw the text on top of the box oh no that's wall number five file not found because the environment we are in it also doesn't have anything else except the wasem file so we have the awesome file we can communicate with the outside world but there isn't much else so the font file i want to use in this case i think i use aerial or something similar it doesn't exist because what is a file system in a sandbox like this so we have to provide the files in some way we have to tell the sandbox hey there's going to be a awesome file and there's also going to be a like another file over here and what you can do is you can do this and this is another compile step you can say preload file i point to a folder i said an art and then slash assets so i'm saying that there's going to be a folder over here and then pretend that the path to it is the second part and this then means that within the c plus file i can say this i can say slash assets slash aerial bold and that's the file i can open that file and there are two ways to add a file you can either pre-load the file or you can embed the file so the file is embedded in the whole thing script that also provides a bunch of helper utilities for common development tasks like make and cmic so i also wrote a simple cmap file so in the fourth project we have cmc these are no longer just the bass scripts we actually have fully full cmap for this but for cmake you have to say like if you want to say make you have to say em make make so it's you do that twice in mcmick clean and then emc make cmake or em make mech these em files these are python scripts that help they set up the environment for you so you know which make to call and then give it the correct environment variables and then yeah you have a cmake file so here's an example this is the one we're using right now we create a project we say that actually cutable suffix is html we give it the files i create the flags and notice app sign with has address and profiling this is how we got some of these warnings that we got before so you can use azure sanitizer you can use antivirus behavior sanitizer because like i mentioned before this is based on llvm and clan so those tools are there and you can use them i can even optimize to an o2 this here source map base this is one of those ideas where you can point to where the cpp files are again it sometimes works sometimes doesn't work but that's an option for you oh yeah and then htl in the memory and then you then you link these things together so that's great so yeah this is great we have everything running so let's look at it in action you hear the game for those with keen eyes might notice that the font isn't it's more jacket on the edges because i don't have the empty aliasing enabled for the text but otherwise yeah it's the same same game i can press all the buttons and do all the things and what's happening here then is we're pressing buttons on the javascript end we're sending those button presses to the web assembly and then we're getting the texture is being drawn on this canvas via stl basically so yeah everything is is mostly everything is on the web assembly and cool so let's summarize the walls that we have encountered files need to be served while developing so if you think about the hello world you can't open random files so you need to have some sort of server all functionality that you depend on os level kind of things they need to be implemented in the javascript in the in the webassembly file or they need to be given to you through that path that we saw data needs to be primitives or converted in some way maybe for example through the embi into those things memory size and growth needs to be thought about and any files that you want to use need to be embedded or pre-loaded with the output one more thing right you always need to have one more thing so in the project you have let's finish looking at wasn't 4. so here we have the the cmac file this is the same as we looked at in the presentation this is the first install stuff so you can just run the the batch file here the entex html it doesn't have much the most things it has is the key down event so we can send the the keyboard input the build script is just using make and cmc you can see that the assets are here filter called volt etf maybe interesting on yeah so here's the the awesome files in the maps and the server is a bit different as well just another example of a server to show you for this one i'm using python and i'm using the the simple http server thing that the python has just to show you another way that you can you can host these things one chainsaw i did was i changed that if it's a awesome file i i do a different request header but otherwise yeah this is the same okay so one more thing one more thing can i open who wants to play wordle listen wordle the cool thing now okay we're on a bit of a delay so i'm gonna play i'm gonna play world can i do what's a good four letter word any spots okay we have an o and we have over aha starts with an o and has an e or maybe we can do inspect and we can just cheat omega omega i'm so good at world i'm so good at wordle so i also implemented so this is another way of of doing a game within the project you also have wordle so if you want to do that so this is just word with the game we also have a wordlebot i'm gonna so people don't get they don't like the blinking lights so i'm going to show you again for a real second if you want to look away so we have a bot that plays wordle and it's trying very greedily to solve vernal by reducing the number of words that can be in the set and and we win about i'd say to be just an under half the games or about just under half the games and we could play about 30 games per second okay this sounds interesting right so let's look at the webassembly version because i also converted it to webassembly so if i go here and open straw i'm building that behind the scenes so that built i can i can do run to open the browser and let you see that for a little bit then i can close the graphics so this is accepted drawing part this is fully in webassembly but do you notice a thing so if i go here to the to the javascript version we're playing about 26 games a second in the beginning playing about yeah 30 games a second if i go back here again it's playing about 30 games a second why isn't it faster is the question you can ask i now converted the thing over to webassembly people talk about webassembly being faster why isn't it faster okay and i'll show you why so there's a thing that's happening here that we saw here before if i go back to performance and i i do a recording of the performance i play the game a bit and i hit stop remember if i make this a bit bigger here remember these gaps between because we're executing some code part of the execution of the code is the execution of the web assembly part that we had here so 0.11 milliseconds we do some tasks related to probably graphics and and compositing and then this kind of stuff and then we stop here so 726 milliseconds up to about here 7 32 milliseconds where we do it again we do main we do a draw and then we go again so here's the thing browsers have frame rates if you didn't know and because browsers have frame rates what we are doing if we look at for example the this one here how we did the graphics here we have a function called main we're asking for an animation frame from chrome then we do some work and when this starts we say when when you are ready to draw something on the screen dear chrome call this main function so that what we do we say hey call the main function we do our stuff we update we draw to the screen and then we come back and we say hey when you're ready again draw so this code over here only runs once every 60 frames or 120 144 based on your screen so our our wonderful yeah it's one because i've been off topping away this solver that's over here only gets to solve again once every 60 seconds the same thing with this one it only gets to solve a game every 60 seconds so what you then have to do is you have to say either thread things or say when you're going to solve a game solve as many games as you can in the allotted time and then when you're out of time hand over back to chrome and then give it give chrome the information and then chrome might draw something and then chrome gives execution back to you you try to solve as many games but this implementation is draw frame solve one action in the in the world draw one frame solve one action so this is another thing that you have to think about with your if you're doing if you want to have some performance code is you have to do either some threading or you have to basically be aware of this limitation that's there so this wordle thing is also there if you want to look at it it's these extra extra one two and three so extra one is just the game xo2 is the world will bot in the hour script and extra three is the world button in supercross it's a very it's a very simple and very greedy bot so if you want to optimizes it well as well you can do that then it has all the build script and everything is as well so please enjoy let me then come back to the presentation no more colombo and that's me my name is you can yell at me on twitter or muscle tone and these are the two links the accu webassembly for the code that we've been looking at and the web assembly presentation if you want to look at the rushed thing for the actual presentation and yeah then that's me yeah i think it's an hour thank you for your talk that was pretty awesome good introduction and how to get started with this web of something and do some security thank you so if you have any questions you can share them in the q a tab or in the chat and i'll be reading them and maybe copying them over okay yeah but still for the video purpose okay yeah but right now yeah some someone's saying very cool i agree to that and there's the first question is there a limitation on using threads so threads were very recently standardized within website whatever simply is yeah a sort of standard so there is a a like there's a proposal there's a version we have a version two i think coming up at some point so the if for a while it was only chrome that had implementation of the threads because they had this experimental extension of threads and then most of the browsers did followed suit and they implemented threads in the same way so it has just the same issues or or limitations and and all those asterisks and warnings you have with with normal threads is that you have to think about i haven't played with them a lot but yeah they are there and you can play with them is there a wall on linking to dynamic libraries so i don't know what they mean by by wall but regarding linking dynamic libraries think again around the environment that you're in where the watson file is and then the watson file that you're looking at maybe it's a nicer way to show it this way yeah the thing is still certain if i go to sources it wasn't this is it when you load a washing file this is the file that is loaded this is the code that you have on your hands and if you need anything think from the outside they are described here maybe it's cool to me if i go and let's go to the slides show you the full full c plus version you can see that i had issues with getting the cpp files here so they're not here but if we look at the wasp file this kind of may be a fun thing to look at look at the things that it's requiring is a bit more it's a little bit more it's not until here that we're done so all of these things that we're asking from the outside a lot of them are graphics related it's asking for opengl kind of graphic stuff and and that is implemented in that is implemented in m scripting through the use of webgl so that's one library that you can be using for example so here we have like terminate and retail and we have yeah some gamepad information and and all this stuff so if we go to here look at the the game js file so let's find one of these functions here [music] gl blend color classic function so here it is we can find that it is in a map so m script and tl blank color is calling a function called underscore ms implant color we scroll up here in this map the asm library argument go down here here is an object called info that has n this is the thing from before this is this object here info that is then being sent into webassembly instantiate so this this big javascript file that we had before it's doing the thing that we looked at before it's getting the binary and being given this info and info contains this awesome library argument if i look at that one here and let's look at again yeah i'm given pl color mask let's find that function and it's just calling this is webgl so it's calling the webgl functions so this is the environment you have so this is the code you have this this big file over here this is all the code you have and then you have connections to the to the javascript world if you need something else it either needs to be here in the watson file it needs to be another watson file then you have to communicate in some way or it needs to be in the outside world so yes yeah i think a good place to look for like how to handle dynamic libraries might be the acute port for assembly yeah there's a question on social media but yeah an important thing maybe to think of here like i'm showing you how it works and how very simple projects are are made when you go a bit further it's really nice to use solutions and libraries made by others like like what if q's doing or if you're using rush stuff or or any of these are the things that you're going to use but then if you have a problem if you're stuck somewhere you know how these things are wired you know what's happening behind the scenes it might look a bit more complicated but this this is what's happening so i recommend looking at this this way and playing with the project but then if you want to go further it's nice to use utilities made by someone else here's one is wasim a go-to solution for to porting over 20 megabyte application i haven't done really big applications i've mostly ported or made like smaller games if at any point you're at a conference and you can ask adobe what they're doing but what i know is if you want to have something on the web and you want to have let's say you you have an existing c plus code base and you want to use the same code base but then target web right you might not want to expose your entire copies to webassembly the web application might be a standalone thing but there are these few things that you want to use maybe some some algorithms you have or some some some functionality that you want to have in the same same code then you can just target webassembly for those functions generate the awesome file hook up to the javascript and then you off you go right but these really large applications are i don't know it wasn't yeah to the whole dom into the environment yeah yeah you can do all sorts of fun things because yeah like we showed that the only thing that's happening is you're calling a function in in javascript what's happening in the javascript function it's just the javascript function so you can do yeah whatever you want look at is called urs so this is in rust but there are i think similar in other languages this is to create web stuff like like the presentation i had this is webassembly like i can go inspect and go to sources it's a awesome file here it's very big here we go and it has a lot of interesting things but what this wasn't file is doing is this isn't the texture this is html this image here is just i can right click and save images right so yeah you can you can do all those things can you just configure resource limits around threads yeah yeah yeah i'll show it maybe to show you the show you the same effect so you have these initial memory and total memory and low memory growth for the yeah i think there are similar i only showed these like these task s or flags or for the damn script then there are way more there's a bunch of others about like limitations and and restricting and enlarging the environment so others so look for the the amp script and flags for your compiler and yeah i think the threat limits you can set you can even you can even change how threading works so you can say that from the c plus side it looks like you're mostly threaded but actually there's just one execution environment it's called i think it's called asyncify so that's gonna kind of meet yes did we had some had some fun washing the thread yeah i think though there's there's like a clarification on the question like users are meant to be users not like developers like can you configure the can you oh yeah sorry yeah i read that wrong can you just configure i haven't looked into that so yeah i might want to look into that and you can too but from what i see i i think no because we go here to i think it is under application and there might be there might be something here but that might depend on because yeah you can mess with the service worker so if you have any any offset workers but yeah not sure not sure on that one now i saw your drawing there but i wonder if like is webgl related to webassembly or is it something of its own it's something of its own so the processor implementing like a gl like thing so it's its own this morning on the cover on the canvas running then so here we have a beautiful little box yeah it's on the canvas click on the camera okay i don't see any more questions and these questions were very wonderful and good so thank you for your time and thank you the talk very awesome like you use now both c plus plus and rust for whatever salary what's like the difference for you and when you wrote this the stat tool in rust rust because it's also it has a package manager already built in so a lot of the helper tools and a lot of the utilities are just there so you can just install them via cargo and and you have them so the community is like slowly creating this little environment of these these nice things there's a thing called oops wrong window a thing called trunk to bundle and ship your rust possum so there's a really nice tool for that and if i go to i have a so here i have the repo for my talk and then i also have the repo for the presentation and this is the whole or last time i tried it this is the whole thing you have to do like from from you have you from you don't have rust until you run the presentation this is the whole thing so it's it's pretty nice it's pretty nice of course there's some there's some teething problems and then a lot of these libraries are young compared to like because you have m script in this is it's a much older project and it's based on llam and clang so there's a lot of history there and you have a lot of these mature tools there so yeah there's you can you can take different different aspects of it sure cool okay then thank you for your time thank you sir that's great to have you and i'm going to end the stream now and