hello and welcome i'm james murphy and today 
we're talking about how to exponentiate   efficiently. spoiler alert: this video was 
inspired by project euler's problem number 122.   suppose for a moment that we don't have access 
to the built-in exponentiation operator or any   math library that's going to do it for us. put 
yourself in the position of someone who might be   trying to write one of those libraries. this is 
the kind of thing that you might have to think   about if you were writing a programming language 
or a compiler for a programming language. here   i have the most obvious way you could possibly 
implement raising something to the 15th power.   namely just start with the variable and multiply 
it by itself 14 more times. assuming i didn't   make a typo, if you count the number of stars 
you'll see that this requires 14 multiplications,   but you can actually compute x to 
the 15th power using far fewer.   the first clever thing that you might think to do 
is to use the binary expansion of the number 15.   as we can see from the binary representation, 
15 requires 4 powers of 2: 1, 2, 4, and 8. we   can compute those by repeatedly squaring. i 
compute x squared is x times x, then x to the   fourth is x squared times x squared, then x to the 
eighth is x to the fourth times x to the fourth,   then to get x to the 15th power i 
just read off the binary expansion.   i need an x to the eighth, i need an x to the 
fourth, i need an x squared, and i need an   x. this allows me to compute x to the 15th power 
in only six multiplications. additionally, 15   isn't really special here, i could have done 
the same thing using basically any positive   integer. first write it in binary, compute all the 
powers of 2 that i need by repeatedly squaring,   and then put those powers of 2 together 
according to the number's binary expansion to   get the number. the number of multiplications 
needed for this method scales approximately   logarithmically with the size of this number 
15. this is much better than the linear number   of multiplications that we use in the naive 
method. okay so what's the minimum number of   multiplications that i could possibly get 
away with? well for 15 here's the answer:   you compute x squared and then x cubed and then 
x to the sixth then 12th then the 15th. however   unlike the binary example, there's no clear 
pattern as to how i got these numbers.   well it turns out this is a very hard problem 
the best algorithms so far are essentially try   every possible sequence of numbers and see 
which ones give you the least multiplications.   there are certainly some tricks that have 
been found that allow you to rule out some bad   guesses and things like that, but in general 
this is still an exponential time problem.   no one really knows how to do any better. you 
might think this is silly, when does anyone   raise something to the 15th power? but people 
really do care about this even in real life.   look what happens when i put this 
example into compiler explorer.   on the left i write x times x times x 15 times. 
on the right you can see both for gcc and clang   that each of these assembly outputs only uses 
six multiplications. this isn't a coincidence,   the people who wrote those compilers cared about 
this problem. before we dive into the code to try   to find these numbers, first let's note that we 
can represent this whole computation process just   with a string of numbers. the numbers are just 
the powers and the order that i compute them in.   so for the minimal example i compute x to the one 
then x squared then cubed then to the sixth then   twelfth then fifteenth. as you might guess i'm 
going to be storing these numbers in a tuple. we   will then successively try all the possibilities 
what can we make in one multiplication in two   multiplications in three multiplications and 
so on. because in the process of computing the   most efficient way to exponentiate for some power 
i'll also compute a whole bunch of other powers,   i'm going to represent and store all the 
information that i compute during the algorithm.   i will store all that information inside a class 
which i can then ask to compute more and more and   more until it finds the numbers that i'm looking 
for. i'll start with an initial chain of just 1   meaning x to the first power. i don't need to do 
any computations to get x to the first power. this   map will keep track of for each number what is a 
minimal length chain that ends up at that number.   so when i plug in 15 i should get this chain, 
or at least one that's the same length. every   time i multiply n plus one things together i first 
multiply n things together, so i know that when i   compute the next step of the algorithm i'm going 
to use the answers from the previous step. for   that reason i'll use this variable cached chains 
to store the answers from the previous step. the   step variable tells me what step of the algorithm 
i'm in, how many multiplications am i using.   and the step limit just tells me not to go too far 
so i don't run out of memory computing. a single   step is definitely the hard part of the algorithm. 
first i check that i haven't stepped too far and   then i increase the step count. i iterate through 
all the chains of one less length and for each of   them i need to compute what are all the new chains 
of one more length that i can make from them.   this corresponds to multiplying two smaller powers 
that we've already computed. for instance for this   chain i could add on an' by using 6 and 12 or 
a 21 by using 6 and 15. you might think that for   a given chain in order to extend it i need to 
try all possible pairs of elements in the chain   but it turns out that for exponents smaller than 
this it's always okay to assume that one of the   numbers is the largest number in the list. it is 
by no means obvious that assuming this will still   give you the right answer. i'm not going to even 
try to explain why this is allowed, but i will   link to a good starting point, a research paper 
that you can read if you want to look into it.   okay so i will always assume that one of the 
two powers that i'm using is the biggest one.   that is the last thing in the list. for the other 
one i just try all the other things in the list.   then i compute the exponent that i get 
by using those two smaller exponents.   i make a new chain that has now one more thing 
on the end of it, and then i add that to my set   of newly computed chains. now the important part. 
if this is the first time i have ever seen this   exponent, then i set this chain as the minimal 
chain for that exponent. i use the built-in   dictionary method set default to do this. what 
set default does is if a key already exists in   a dictionary it does nothing. but if it doesn't 
exist in the dictionary then it sets the value.   this ensures that each number is linked to 
the first chain that produces that number,   subsequent or longer chains will not overwrite 
this value. the last thing that we need to do   is set all the chains that we just computed 
to be the new cache for the next step.   then we make a little helper function which will 
facilitate finding the answer for a specific   exponent. basically we just keep computing longer 
and longer chains until the set default finally   finds a chain that is able to produce the desired 
number. then to find a chain for a specific   exponent we just step until it's computed and then 
return it. if for some reason we only cared about   the number of multiplications and not the actual 
chain that tells us how to get there, then we can   just note that the number of multiplications is 
one less than the length of the chain. so here's   how you would put it together to solve the project 
euler question, which asks us to compute the sum   of the first 300 answers. i'll time my answer to 
make sure it doesn't take more than one minute.   i set the end that i'm looking for as the number 
300 then i create an instance of my class. just   for my benefit i want to print out all the chains 
and then for project euler i'll just go ahead and   sum up the answers. let's see how it goes. okay 
it looks like we finished with an answer of 2593   in 51 seconds. scrolling up towards the top 
here we do see that it found the same answer   that i mentioned before for 15: 1 2 3 6 12 15. 
also notice that it's not a monotonic function,   sometimes a bigger exponent 
can take less multiplications.   the last thing that i want to mention is that 
although we did this problem for multiplication of   just integers we can actually say the exact same 
thing of multiplication of any kind of objects.   as long as i know what it means to multiply a 
thing by itself i can make sense of exponentiating   something or raising it to an integer power. 
this allows the answer to be useful in a more   general context beyond just what you would 
get for integers. for integers after all   when's the last time you ever raised something 
to a power other than two three or maybe four?   imagine for a moment that x is not an integer 
but a one million by one million matrix.   saving even just one multiplication might be 
meaningful when you have a problem this large.   i also want to point out that there are many 
matrix models that are useful in applications.   you start out with a vector and then repeatedly 
multiply by a matrix to get the next state in   the model. that means if you want to know what 
happens a thousand time steps later in the future,   that's equivalent to multiplying by 
the matrix to the power one thousand.   this is another place where taking 
a big power of an object comes up.   well that's all i've got on this topic, if you 
enjoyed the video please consider subscribing and   telling your friends, and as always don't forget 
to slap that like button an odd number of times