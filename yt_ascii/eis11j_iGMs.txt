today we're going to talk about one of my favorite topics in computer science which is the lambda calculus and in particular we're going to talk about three things we're going to think what actually is it why is it useful and where did it actually come from so we're going to start with the last question here where did it actually come from this is alonso church who was a mathematician at princeton university in the united states and he was the person who invented the lambda calculus and what he was interested in is what is the notion of a function from a computational perspective and his answer to this question is what we now know as the lambda calculus and there's an interesting piece of history here which many people don't know so it turns out that alonso church was the phd supervisor of someone very famous in computer science alan turing and of course alan turing amongst many other things which he did he invented turing machines which computer file has done a number of videos on and turing machines capture a basic state-based model of computation and it's interesting that his phd supervisor alonso church he captured a basic functional notion of computation with his lambda calculus and it turns out that these two quite different notions one functional and one state-based turn out to be equivalent and this is what's called the church turing hypothesis or part of the church during hypothesis so for church a function was a black box that you're not allowed to look inside and what it does is it takes some input so maybe it takes a number like x and it's going to process it in some way and it's going to produce an output so maybe it produces the output x plus 1. so this would be a function that takes a single input a number called x processes it in some way and then produces a single output which is the number x plus one then we could have a slightly more interesting example maybe we have a box with two inputs x and y and we process them in some way and maybe we produce their sum as the output so this would be a function which takes two inputs x and y processes them in some way and then produces their sum x plus y and there's two important things about functions in this sense the first is that they're black boxes you're not allowed to look inside them you can't see the mechanics of what's going on inside this box all you can do is put something in and observe what comes out the other side and the second important thing is that these functions are pure they have no internal state so all that happens when you map x across to x plus one is the magic goes on inside the box and there's no internal state there's no hidden information that we can use and this is quite different from the notion of computation that alan turing was interested in with his turing machines he had internal state there's no internal state these are pure mathematical functions now we can think how do you actually define functions in the lambda calculus and there's a very very simple syntax for this which i'll introduce to you now so let's think about the increment function in the lambda calculus what you do is you write down a lambda symbol so this is the greek lowercase letter lambda and that says we're introducing a function at this point and then you just write down the name of the input so that was x and then you have a dot and then you say how the output is calculated in terms of the input so that's x plus one so we could do the same with addition you just need two lambdas you write lambda x dot lambda y dot x plus y so this is the function that takes two inputs x and y and then delivers the result x plus y and this is written down formally in church's lambda calculus exactly like this so when you've got a function what can you do with it well all you can do is give it some input let it do its thing and it will give you some output so let's have a simple example of this if we take a function like increment which was lambda x x plus one and we apply it to a number like five what actually happens it's a basic process of substitution we're essentially substituting the number five here into the body of this lambda expression and then x becomes five so we get five plus one and then we get the result six on the other side and this is basically all there is to the lambda calculus it's only got three things it's got variables like x y and z it's got a way of building functions this lambda notation and it's got a way of applying functions this is the only three things that you have in this setting what is actually the point of the lambda calculus we've introduced this very simple notation why should you be interested in learning about it i think there's three answers which i would give to this the first point i'd make is that the lambda calculus can encode any computation if you write a program in any programming language which is ever been invented or ever will be invented or really any sequential programming language it can in some way be encoded in the lambda calculus and of course it may be extremely inefficient when you do that but that's not the point this is a basic idea of computation and we want to think how many what kind of programs can we encode in this and actually you can encode anything and this is really the kind of church turing hypothesis which i mentioned alan turing you can code anything in his turing machines and in churches lambda calculation can encode anything and actually these two systems are formerly equivalent any turing machine program can be translated into equivalent lambda calculus program and vice versa they're formally equivalent the second point i would make is that lum calculus can also be regarded as the basis for functional programming languages like haskell so these are becoming increasingly popular these days and actually a very sophisticated language like pascal is compiled down to a very small core language which is essentially a glorified form of lambda calculus so if you're interested in functional programming it's like haskell or the ml family these are all fundamentally based on the lambda calculus it's just kind of a glorified syntax on top of that the third point which i would make is that the lambda calculus is actually now present in most major programming languages so this wasn't the case 10 or 15 years ago but it is the case today so if you look at languages like java like c sharp even visual basic f sharp and so on all of these languages now encode lambda calculus or include lambda calculus as a fundamental component so every computer scientist today needs to know about lambda calculus what i'd like to end up with is a couple of little examples of what you can do with it so the lambda calculus has basically got nothing in it it's got variables it's got a way of building functions and it's got a way of applying functions it doesn't have any built-in data types like numbers or logical values recursion and things like that so if you want to do these things in the lavender calculus you need to encode them so i'll end up showing you a simple encoding and the encoding which i'm going to show you is the logical values true and false and the key to this is to think what do you do with logical values in a programming language and the basic observation is that you use them to make a choice between doing two things you say if something is true do one thing if something is false do another thing and we're going to use this idea of making a choice between two things to actually encode true and false so the trick is for true you write down this lambda expression so what it does is it takes two things x and y and then it chooses the first and false does the opposite it's going to take two things and it's going to choose the second so we've got two lambda expressions here both of which take two inputs x and y and one chooses the first one x and one chooses the second one y so fair enough what can we actually do with this well let's think how we could define a little logical operator so not is the most simple logical operator which i can think of it's going to flip true to false and false to true it's logical negation based upon this encoding how could i actually define the not operator or the not function well it's very easy to do i will take in a logical value or a boolean as it's normally called in computer science after george bush who first studied kind of formal logic so we take a boolean which will be one of true or false and here's what we do we apply it to false and we apply it to true and i claim that this is a valid definition for a not function but i can very easily convince you that it's the case because i can do a little calculation so let's check if we apply not to true that we actually get false in just a few steps using the lambda calculus magic we'll find that this actually works out so what can we do here well the only thing we can do is start to expand definitions so we know what the definition of not is it was lambda b b applied to false and true and then we just copy down the true so all i've done in the first step here is i've expanded my definition of not not was defined to be this lambda calculus expression here now i've got a function which is this thing and it's applied to an input so i can just apply it okay and the function says if i take in a b i just apply that b to false and true so the thing i'm applying it to is true here so i just do the little substitution rather than b i write true and then i copy down the false and copy down the true and i get down to here and at this point you might quite rightly be thinking this looks like complete rubbish i mean i've just written true false true what does that mean it means absolutely nothing but it means something in the lambda calculus because we continue to expand so what we can do now is expand the definition of true we said that true takes two things and chooses the first one so let's expand it out so true is lambda x lambda y x so it chooses the first thing of two things and then we just copy down the two inputs false and true and you can see what's going to happen now we've got a function here which takes two things and chooses the first thing here the first thing is false so when we apply the function we just get back false so what you see has happened here in just a few steps we've shown how using this encoding of true and false and not we can actually get the desired behavior and it's very easy to to check for yourself if you apply not to false you get true and i'd like to set your little kind of puzzle at this point think how you could define logical and or logical or in this style as well okay and i'm interested to see what kind of definitions people come up with in the comments so the very last thing i'd like to show you is this lambda expression here which is a very famous lambda calculus expression called the y combinator or the y operator and actually this is the key to doing recursion in the lambda calculus so as i mentioned lambda calculus has basically nothing in it or it's only got three things in it variables x y and z and so on a way of building functions and a way of applying functions it's got no other control structures no other data types no anything so if you want to do recursion like which is the basic mechanism for defining things in terms of themselves again computer files had videos on this you need to encode it it turns out that this expression here is the key to encoding recursion in the lambda calculus and this expression was invented by someone called haskell curry and this is the haskell that gives his name to the haskell programming language and he was a phd student of david hilbert who's a very famous mathematician the last observation i'd like to leave you with here is something that's interested me for many years i think there's a connection between this piece of kind of abstract computer science or abstract mathematics and biology if you look at human dna you have this double helix structure you have two copies of the same thing side by side and this is the key to allowing dna to self-replicate if you look at the structure of this lambda expression here you have two copies of the same thing side by side you have lambda x f applied to x x and exactly the same here and this is the key to doing recursion which is kind of related to self-replication in a programming language or in the lambda calculus and for me i don't think this is a coincidence i think it's a kind of interesting philosophical observation the lambda calculus has this kind of very clever way of doing recursion which would take a video on its own to explain how it actually works but you can look it up on wikipedia and there's a link here i think to biology somebody actually found the y combinator so interesting that they've had it tattooed permanently on their arm and you can find a picture of this if you do a quick web search what would people search for the y combo the y combinator in mathematics or computer science and tattoo i'm guessing yep