welcome to my talk on i'm better i will first introduce you to embedder i'm showing a couple of examples and then we try to look at it under the hood so what is i'm better well on first side and better is an ide for c and as the name suggests it's an dialect of c that focuses on embedded systems and beta came about 10 years ago as part of an industrial research project and its sable release was six years ago and it's since been used successfully in industrial projects and it's also the basis for commercial products now the core of umbrella is open source it's available on embedded.com and on on github i'm not part of any of this i'm just a happy and better user at zwieco university where i'm work and last year at meeting embedded i you know talked to to some of the attendees and i mentioned i'm better and no one actually knew about i'm better and i think there are you know lessons to be learned even for for c plus plus or rust developers even if you are not a c developer there are lessons to be learned and that's why i handed in this talk so let's see what is i'm better well this is i'm better well nothing really exciting here it's just ordinary c so why am i showing you this well things get more interesting when you zoom out and look at the whole program here there there's there's funny things on on top let me see here's a pointer here so there's you know something called model okay then there's this imports and constraints and then there's this exported keywords for the for the main function okay obviously there's something you know different from standard c but still it's not that's that interesting i guess but embedder has to offer what they call a cleaned up version of c99 for example in instead of header files they have a cleaned up module system with imports and exports and that is what we just saw in the example so we import nothing but we export the main function and they took away all the fun by not having macros so there's no preprocessor they they added strict typing for example there's a dedicated type for boolean which is not easily convertible to to index there's casting available but they are separate they are separate types and they they added anonymous functions which is quite interesting and also a syntax for for [music] arrays from these [music] and from the embedded c embedded c excuse me from the embedded c standard c gets generated so on the right hand side you can see the the code that would get generated for this little program on the on the left and it's actually quite quite readable for a co-generation approach now in the beginning i mentioned that embedder is of course i'm focused on to the embedded domain and what they also added is physical units so for example you can have you know integral types annotated with a unit seconds meters meters per second whatever and this is part of the the language it's not and not not annotated by means of comments or something it's it's actually part of the language and of course you get language support your compiler which will tell you that you're doing something wrong with the the units that they are not compatible as you would expect and there many more languages i will show you some in a bit and all these extensions are called domain specific languages so on top of the language for this cleanup c there are you know extensions for physical units and many many more extensions for example they added a domain specific language for testing which exposes concepts from the from the testing domain right in the language you know like test cases and assertions and so on there's also composite physical units and conversions between units and many more of these extensions for example for logging which can be surprisingly difficult in embedded systems and from a software architect more software architectural point of view there are interfaces and components that implement those those interfaces realize those interfaces and there's support for requirement specification and requirements tracing for documentation and defining inline tests right in in the in the documentation which is really nice and traces to other parts of the of the implementation right from from documentation and there's also support for variability configuration management so product line engineering and a lot more of these extensions are available as part of embedded core or commercially available or available on github for example freely available and of course you can build your own language extensions so did we here at spicker university we ported osec to lego mindstorms and did so using some of the extensions available for embedder from the robotics and real-time domain and we added our own extensions on top of these standard embedder extensions as i said you know a lot of extensions come with embedder already i can't go into all of these i will show you some later but there's there's a lot of abstractions available as we shall see in a second one of the more interesting extensions available for for embedder is and domain-specific language for state machines so they added a language that makes the concepts from the state machine domain explicitly available in in the in the better in the language so they're you know obviously state machines and states transitions guards actions and and so on the the usual suspects you would expect for state machines and the the way embedder approaches these extensions is quite interesting and i will go into more detail in later slides but for now just let me say that the domain specific languages that come with embedder they offer well-defined concepts by means of an abstract syntax or meta model and you you get high level extractions with rich semantics but still because there's this c base language still tight integration with the c programming language and for example what this explicit definition of concepts give us this visualization of state machines so you can you know easily visualize state machines using graphics or or whatever so on the right you can see a few not not an editor we will come to the other in a second you you can see a few of the state machine that was defined on the left-hand side and you can get graphical fuse for you know other parts of a system you know more behavioral stuff with something similar to uml sequence diagrams for example so these domain-specific languages they give us of of course productivity we we can think in in terms of the the abstractions of the problem domain but they also give us reasonability so we we get model checking [music] we can check for pre and post conditions of modules and interfaces software components and and interfaces and we get formal verification for example we could verify a state machine and see if you know every state can can be reached if transitions exiting from from the same state are unambiguous and so on and in this example here on on this slide you can see that there's something wrong with these guards here and this is done by an external tool by an external model checker which can be integrated into embedder and as you can see the the results from this model checker they are directly fed into the ide right on on the um abstraction level of state machines i will come to to that i will come back to that in a second so now i showed you some of the language exam intentions of i'm better i would like to look a bit under the hoods um and discuss how i'm better does this and and better is based on chatbrain's meta programming system mps which is a language workbench there are other language workbenches available but embedded is based on mps and mps offers something called projectional editing and projectional editing gives us complete notational freedom so instead of having a line-based and parser-based approach you can do in terms of notation you can basically do whatever you like so for example you could add tabular fuse to your more text-based editors and that's something that is quite difficult codes if not impossible to achieve with traditional parser-based approaches you could also have mathematical annotations write in your c like functions or you could have configuration editor for something like like make files and this projectional editing is quite different from more traditional ides it actually feels weird in the beginning but once you're used to this it's it's really great projectional editing means that the view is a direct projection of the abstract syntax tree and the f6263 is an instance of of the meta model so it's the diffuse a direct projection of the model and editing then means that users directly modify the the abstract syntax tree directly modify the model instead of having to go from text via parser to an abstract syntax stream so for example we could have a tabular editor for our state machine there's there's nothing that prevents us from you know having columns and and lines instead of this just line based approach to tabular to state machines that we saw earlier and still we get the tight integration with c we can still use c expressions in those table cells well we could also have diagrammatic fuse diagrammatic editing actually so this is not just a few this is an editor a lines and box this editor for state machines and it's still tightly integrated with the with embedded base language with the c dialogue i'm better users and you actually get what i would call roundtrip editing it's not quite roundtrip engineering but you can go from one representative representation to to another make modifications to your your program switch to another visualization and the modifications are right there so you can pick the the graphical annotation or the the view that best suits your your needs now after showing you some of the of the features of i'm better i would briefly go into how [music] c gets generated from embedded models as you saw everything you do in embedded is actually represented by means of models and then text model to text transformations are used to generate standard c code that then can be that then can be fed into gcc for example to build the binary and not only is c code generated but of course you can build configuration files like make files and so on documentation html latex whatever model checking configurations for various model trackers and so on so because there's this modern text transformation you can really generate any kind of artifacts that are required for your projects and instead of having a model to text transformation for each domain-specific language for each extension and embedder actually uses another kind of transformation called model to model transformations to go from high level abstractions to more lower level abstractions and then to the cleaned up version of c to the base language to a better space language and from the base language they go to model to text tran they do a model to text transformation to generate c code and build files and and so on so what else does embedder has to other offer in terms of ide integration there's really great support for debugging debugging on the domain specific languages level not on the c level so when you debug your state machines you're not doing so by debugging switch case statements in in c code in the code that gets generated but you do debug your state machines right in in the ide on the level of the state machine domain specific language so that's that's really cool and then there's integration for for version control again it's done on the dsl level so you know you get different merge right in for example a graphical view if that has been implemented for this visualization of a domain-specific language and you can integrate third-party c libraries so that you can make use of these apis from from embedder there's a ton of material available at embedded.com you can find tutorials and scientific papers about i'm better so please check out ambetter.com now why am i so so fond of i'm better well here at zwieker university i'm i work as a computer science professor and i try to teach you know good good tools to students and and good concepts that might be you know a bit ahead of what's used in in industry right now and what embedder gives us is you know high-level abstractions that are still integrated with c and and this is really important and better because it's based on on mps allows to combine different languages different aspects from from different domains because usually you require concepts from different domains to build a complete system and and some of the more traditional approaches like you know simulink and uml system they tend to focus on a single domain or it becomes really difficult to combine concepts from different domains so here's a very small example of how languages can be combined and better here in this example we have obviously state machines we are defining a state machine but we are using physical units here this small m indicates that we are checking the altitude for being zero meters so we are combining two different languages and that would be really difficult in parser-based approaches and this is where embedder really shines and embedder can shine when combining languages because it's built on the meta programming system which offers some great tools for for language engineering so because it's it's based on mps you get tools to build composable and extensible dsls you get tools to build the editors that best fit your user's needs so you have notational freedom you get other things like migrating from one version of a language to another and and so on so in a way this language workbench approach as offered by mps but also by by other tools kind of helps to to liberate this language engineering and that's what i really like about and better and mps in general so with that i'm finished and i would like to thank you for your attention but i would also like to thank the embedded team and the mps team for building such great tours thank you and i hope we can discuss about and better and i hope i provoked some controversy and maybe you know we can get into a discussion i prepared some [music] some topics that we we might talk about you know why not c plus how much do i have to invest in order to start using i'm better why should i even do it and why are you telling us about i'm better now so i hope we can discuss about this thank you yeah thank you for your talk frank