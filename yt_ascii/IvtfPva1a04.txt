i wanted to see if chat gpt was able to solve three relatively simple programming problems without creating any security vulnerabilities i am so confident in how bad a chat gbt is at programming that if there are no security vulnerabilities in all three of these i will quit my job and to spice it up if all of them have security vulnerabilities and we'll do something special at the end of the video now the assertion with chat gpt is that it is going to take all of our jobs as software developers and we will all be living on the street in the ai we'll be running the universe now the reason i don't think chat gpt will actually replace coders is because the code that chat gpt knows how to produce is just code that it's seen other people write on places like stack overflow wikipedia and places like that all because chat tpt has seen this code does not mean the code is inherently safe let's test out our first prompt and see how safe chat gbt's code is now the first prompt is i want chat cpt to program for me in http server that's a server that serves files on the internet when you go to website the protocol http is handled in the server that you're talking to and it delivers you the web page that you see okay so chat gpt did render some code here let's take this code out of chat gpt and put it into our vm and see if it even compiles this is code run and can we use it to run an http server let's try it out all right so we're in our vm now we're going to bim http.c we're going to copy and paste our code again we've written no code i'm just taking what chat gpt gave us and putting it into our editor now we're going to compile it should be as simple as gcc taco http http.c moment of truth it compiles wow that's actually crazy so it compiles no errors no warnings flat out just works so let's see if we can't serve the file within the file dog and it's going to say ao what that dog doing we're gonna save that file and now if i run this server oh i can't bind to that port i need to be root hold on let's do sudo http running ai code as root very safe cool so it's listening port 80 it works now if i go to a new window if i w get localhost and i look for the file dog oh i get the file dog and if i cat it it should say ayo what that dog doing the code is functional it does work let's take it a level deeper and see if there are any security vulnerabilities in it the code creates a socket in c to serve as the server that's easy enough scary parts gonna happen when we start reading data off the network so basically what's happening here it accepts a socket and it handles the request all of the juicy code is going to be in handling the request this is where the server could get it wrong we have the buffer for our request we have the file name that we could get and then we read in the request from the network and then we scan f oh there we go okay leave a comment below if you see the vulnerability here so this is actually a security vulnerability known as a buffer overflow where we extract from the request an arbitrary file name the user controls into a file name buffer however we don't specify the length of the buffer in this character format string here so because of that we can give it more than buffer size inputs in the file name that we're requesting and crash our server so we can look on the code the chat gpt gave us for the buffer size buffer sizes 10 24. let's see if we can make a 10 we'll call it 1050 byte file name and see if that crashes it we take all this python goodness and i'm going to request localhost slash that amount it'd probably help if i started my server on the server is root listing port 80 run it again oh interesting the file is not found on the server hmm interesting so i can't trigger the bug but that's definitely a bug there let's figure out why i can't trigger that bug in the code oh interesting because it only reads a buffer size off the network i can't actually overflow like i take my outer value that has buffer size and then i copy that into a smaller buffer and then i copy that into a buffer of the same size so this is a buffer overflow condition the problem is they got lucky and they just happened to make it so that the outer buffer was the same size as the inner buffer again i'm going to call this a security vulnerability because a person could take this code and expand on it and this this line right here gives user control of a buffer without specifying the length so zero of one for now chat tpt let's move to the next one okay prompt number two i want chat gpt to create for me a tlv server when you're passing binary data from a server to a client or vice versa it's very common to encode that data as a tlv that's a type or a tag the length and the value the way you implement this could have very very dangerous security vulnerabilities if you allow the user to control the length field because then that could cause buffer overflows in your code so let's run this and see what code chat gbt gives us okay interesting the code looks pretty normal we bind to a particular port it takes the port as input on the command line we listen and then we read some data from the user and then parse it into a tlv so let's pull this into our vm and see if it compiles let's do it right now okay we got the code all vimmed up let's get it all compiled gcc taco tlv tlv dot c baby and we compile easy again so again i'm very surprised that so far there have been no errors no warnings from from chat tpt because actually in preparing for this video i made some personal projects that i wrote that broke in chat gbt that like straight up would not compile they were syntactically incorrect in c so this is very impressive tlv and it takes port to listen on so we'll do one two three four i'm actually curious if i net cat locally if i can get any data so we'll say netcat localhost one two three four and if i go like this do i get any data so tag 97 length 115 value as def okay so it actually does work that's pretty interesting the one vulnerability i'm already kind of seeing here is that expected length 115 for me and i didn't send it 115 and there was no parsing errors here there should be a feature where if i send it 115 as the length and it doesn't get 115 it should discard that packet so let's see what the code does and see if the code is any vulnerabilities in it so this is all pretty boilerplate we we bind to our server we listen read all the good stuff so this is where it's actually parsing our request so buffer of i plus plus i don't like this at all doing i plus plus and not having like a hard cursor that you're checking is a little dirty so it reads the type it reads the length and it reads the value so in real life if you had a binary protocol you're working with you would say like if tag equals you know hello packet do this thing and if hell you know packet equals goodbye packet then do this thing so that's that's where you'd use this oh this is vulnerable as hell yeah yeah so mem copy is a copy operation right buffer overflows happen when you allow the user to control arbitrary data here we give the user direct control of the length value so by doing this the length value comes off the network and then i pass it into a mem copy so this is 100 vulnerable to about for overflow i could send it a bad value of length that doesn't match the packet and you know bad things can happen from there also it's casting a length which is a unsigned in off the network to a size t for mem copy so there's a lot of issues with this code 0 of 2 open ai i don't know man i'm a little nervous right now let's see what my final prompt has in store for us let's get into it and for my final prompt i present to you dark mode users cover your eyes a my homework just kidding i invented a fake school usu university school university u s u u s u where cs481 is a class where you have to create advanced code network programs not redundant at all in this prompt i ask you to make a better optimized file access protocol better referred to as bofa i'm going to give this prompt to chat gpt and i want to see if it can not only dissect this prompt from my homework but create the code that does this problem in a way that is both functional and secure let's see what chat tpt has to say all right i'm literally just going to copy the problem statement i'm not going to show the score because it might think that it was homework oh okay try tpt you think better than me all right take this copy it oh it it thinks that bofa is a real protocol and it's like i don't know how to do that okay so we're gonna we're gonna ask it to do it and say that it's not called the boba protocol i was like dude there's no way yeah okay it's doing the hello num tlv message length message data okay there i think i see a vulnerability already all right let's pull it into the into my vm and see how it looks let's let's see if it compiles oh it didn't generate the whole thing can't get chat tpt to actually finish the code this prompt may have been too complicated for it ha strike one chat gbt but i'm already seeing a bunch of gross stuff with this codes let's pull this code into my vm and i'll talk about all the issues i have with it i'm seeing a bunch of bad code smell issues and i've already found one security vulnerability so let's talk about that at first initial glance this code may look pretty good but there are some pretty nasty things in this code that a new programmer may not see and again this is my whole point with chat tpt it just it makes really bad code that tricks new programmers into thinking that it's right and then they've made catastrophic mistakes that not only will reinforce bad habits but it'll just make them produce bad code if they depend on using that tool so first of all if you look at this piece of code if you're a senior here you're probably throwing up in your mouth right now tons tons tons of magic values this code may functionally be correct but these magic values make it so that if you need to debug or add to this code functionally you cannot reproduce this code at all you have no idea what any of these numbers do why does six get you a message type why does seven get you a message length now there could be the argument that if the protocol is specked that way then six and seven are always the magic values okay fine but what if bofa 2.0 comes out and now it's at values seven and eight now your entire protocol is screwed and you're gonna spend hours re-figuring out why this code works the way that it does and then on top of that it's doing a bunch of mem copies it's reading the lengths of the tlvs off the network and then here we have the final blunder we read into the message data buffer a local stack buffer the message length length that comes off the network it's the exact same bug as before where we let the user control the length of a mem copy creating a buffer overflow condition and likely code that can get hacked now as the kids would say when i was trying to learn to play basketball in high school scoreboard and like i said because chat tpt not only lost but lost embarrassingly zero of three in the security vulnerability department a special part of the video happens now i'm not gonna lie i didn't think we got this far alright hit subscribe just kidding it's a fish