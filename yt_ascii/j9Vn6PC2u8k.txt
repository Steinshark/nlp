server-side rendering react in ocamel server reason react is an implementation of react dom server and some of reacts internals in ocamel its purpose is to render html marker from the server for a reason react application natively this post provides an overview of some of the concepts of the library and what it means to render react in ocamel and how we use it at rfs.com a benchmark against node equivalent and the future of all of this ooh it's kind of excited let's see how good it is against note because i have no idea what ocamel can do if you're not familiar with reason or oh camel it's fine the purpose of this post is not to convince you to learn or try those languages but rather to share something i built that i'm passionate about okay okay i will try to explain most concepts for any developer with experience and react don't be scared by any niche language technology mentioned here since i'll introduce them as we go the first piece of context to follow this post is to introduce reason and o camel for those who are not familiar okay so i know nothing about ocamel other than tj loves him tj is the biggest fan of oh camel it is right there there you go there we go okay let's see okay reason is a language built on top of o camel they share the compiler the type checker in most tooling around it was created by jordan walkie walkie walkie walkie walkie walkie am i saying that right anyways to allow javascript developers to enjoy oh camel okay okay i'm excited back in the days when typescript was not as popular many members of the javascript community were interested in reason o camel is a type safe and robust language that empowers a functional style with a powerful inference i didn't realize el camo types i didn't think it had types it's pronounced wally wally it provides a unique balance of performance maintainability and readability okay okay see that's how little i know about ocamel despite being a niche a programming language ocamel has made an impact on modern programming languages in language tooling the first version of rust were implemented in o campbell and meta's flow javascript type checker as well huh okay nowadays o camel is a solid option for general programming language backed by trade firms blockchain and sas companies the the three out of four riders of the apocalypse there i see is what writes them fintech blockchain and sas companies dang it all right and refs i'm a software engineer working on tooling io work on maintaining the design system style to ppx let's see helping the malays and now the server react reason refs is a comprehensive seo tool set okay let's just go to the problem i want to read the problem here all right one of the initial problems with our main react application was that the client was client-side rendering the canonical example of this problem happens on the header we had a to load a bunch of contextual data such as user permissions billings tokens and themes running all those requests on the client creates a request waterfall yep and often our users use more than one tool at a time where navigating between those is not an optimal experience yep okay navigation would be slow flashing the header for an entire let's say and the entire app while mounting each page time can be annoying and waste okay okay so you guys see the idea here we got some we got some request problems we got some waterfalls they're gonna try to solve this i assume a server-side rendering right to address those issues we implemented server-side rendering for our static parts a shell app and injected the hd or the data as regular scripts with serialized or jismo for short we used time xml time xml is that an xml library a library that generates html from ocamel okay for creating these static templates okay to improve the user experience by a lot since the html served contains the static part of the app so the browser can cache it locally but we quickly encountered a new problem having two separate implementations of the same component yes this is such a problem with all this stuff the client version written in react and the server version written in time xl time xl time xl i'm not sure how to say that but this is real this is real talk even even in like a lot of the days if you've been developing react long enough like this is just a problem in general you start getting these weird you start getting these weird things where you start writing things twice because of just all the problems that are caused not easy to share implementations or even styles between the two keeping both versions in sync with different data requirements is too much hustle yeah ensuring the server version of the component functions correctly without data in the client one mounts on top with the interaction the resulting tech was difficult to maintain deterring developers for making significant changes while the solution was adequate for some time we sought a more scalable approach to our front ends okay hydration issues always hydration always hydration issues to address some of those problems javi experimented to mix tax smell tax smell and reason react with a public and publish the experiment on his block okay in addition to server-side rendering rendering with each request we need a different strategy for our static pages such as server side generation what next calls incremental static regeneration running a rendering step at build time and populating state on each request okay okay ultimately our goal was to use the same client components from our design system in these server templates okay this is actually pretty interesting this is a really good i'd say this has been a really good kind of setup problem does everyone understand what's going on here because i'm very curious how how are they actually gonna you know it's used in a bunch of terms right there's a bunch of there's a bunch of terms that when people use in the in the front end world i get confused all right let's see the first approach the common solution to this problem is to go with a node-based solution such as nexjs gatsby or astro astro is pretty cool let's be real here astro is pretty cool after using gatsby and react snap for a few years and let's say in a proof of concept with next we weren't satisfied with any approach love it pre-rendering ssg with node running the pre-rendering step during the build and serving them via our back end in ocamel the solution couples the build process running in a ci with the runtime the production and staging servers increase the complexity on how we were serving those static files and how those static files became populated with data known as hydration interesting this just all seems really hard because whenever you're mixing light like because mixing languages especially when there's not like because javascript's the only one with the full react support so like this mixing of languages just seems like it's so hard i just assume this is so dang hard and yeah you could you create these templates but still templates could be unsafe to hydrate and error prone yep you need to generate templates for each language currently 17 and upload them well each language has in each spoken language that must be a spoken language thing that's tough we don't do it like that at netflix but interesting running the pre-rendering on ci made a weird combination pre-rendering required to couple our o camel back end with html files and be aware of purging the cache this is this sounds really hard this sounds really really hard running node with ssr on production the other solution is to serve applications by node and using ocamel as an api okay placing node in front is a very common architecture that works wonderful in some teams but there are still drawbacks when using node in the back end for refs is this so what he's saying is that you have an application that does just to get this kind of correct in my head i think what he's saying is that you have a client right here you have like middleware that is still node and then you have like an api that it calls into that is ocamel they don't just substitute translations in the one in the template they make multiple templates say yeah they make multiple templates one for each language hmm anyways very interesting i think that's what i'm saying i think that's what i'm seeing here most of our apis consist of fetching from different data storages and shuffle this data to serve it some of those problems make it not ideal for us single threaded nature node.js inherently single threaded yes which can lead to performance issues when dealing with high concurrency or cpu intensive tasks yes yes and yes node.js isn't the best player at memory consumption oh really i just read in our previous article that that javascript devs are very concerned about memory all of a sudden i'm looking right here and i don't know i don't i don't know about this you know what i mean seems a little suspicious you know what i mean seems a little suspicious ssr applications can be memory intensive potentially causing resource constrained in production environments yes this is real you use a lot of memory when you use something like react on the server right i think this is going to be a really big problem with the upcoming push for everyone writing a bunch of javascript applications all these serverless places like it's gonna need a lot of memories just not cheap and it's only getting less and less cheap all the time let's see additional burden on devops as they're not happy learning another language and a framework to manage with the emphasis since it's an entry point for users type safety concerns ensuring type safety would be required either using typescript and maintaining a separate type definitions or using a reason and compiling it to javascript however the node.js's bindings aren't my favorite part of reason okay let's see might lead to some duplication of logic yep yeah see this i mean this all makes sense you have two different you have two different problems you have two different back ends you're gonna have two different duplications logic switching a request from the server to the client or the other way around can be challenging potentially leading to increased complexity all right so it looks like it's time think of the poor devops guy we're just going to jump right down here entering server reason react reason react this reason the reason parser comes with the jsx transformations out of the box so jsx expressions are compiled down to function calls no need to use babel es build or white or in reason oh interesting is that because in i assume that's because in o camel there's some sort of macroing that's going on here right this little react component is some sort of macroing that's changing everything who is jay and why is he why is he sex oh j j sex yeah that's how you say the name properly uh that's cool this is super cool i think i think i could i think i could get used to that i like that i'm a little confused as how what the syntax means because i don't see like a return statement i see a semicolon at the end so you know if i apply my rust skills this is not returning anything out okay but i like that i love the idea that you don't have a build step for just a translation of the language right i i love so i love that idea reason reactor set our set of bindings to the javascript version of react so a tiny layer of the type system to tell the reason code the right interface of those hooks create element calls and any react api similar to what dot dts modules are in typescript okay or ffi and rust okay so what's server reason react server reason react is a re-implemented re-implementation of react dom server and some parts of react itself to generate markup from a react component but written in o camel more precisely react dom render to string and react okay okay to make sure that dom let's see react dom can represent all kinds of nodes in react components elements fragments providers consumers there's a node variant okay so this must be oh camera we're looking at here and so this must be this is effectively a tagged union are we seeing a tagged union here is that what this is right i don't really know what i'm looking at because i don't understand the syntax this looks like some sort of function here a function that takes it takes in the unit returns a node this takes in a unit returns a node i don't understand what that list does right there it's a rusty note yeah that's why i said tag dino yeah i kind of understand this okay cool all right they match with what react internally uses with symbols the actual string generation is done by traversing the component tree and generating specific html representation of each node and each node takes into account a few details let's say such a serialization dom processes let's see attributes process inline styles and code html and a few reacts particular such as dangerously set in set inner html so i've always was curious about how react does that so they keep it in a tree formation and then they walk the tree and generate the string as it goes okay that makes sense that makes sense a pseudo implementation of rendered a string to illustrate the mapping between components and html representation okay we're going full all in right now with o camera right here all right so render to string this must be the argument match node with lowercase tags attribute when html is self-closing tag okay okay there we go so it's generating this string right here tag attributes to string tag attributes okay so this must be a function call that takes in two arguments that's how i kind of read this and so it does each one of these okay and then we recall render to string with component goes back in here and goes back through here text it does a little text inner html okay list render to string list okay i think i understand that list itter i don't really quite get this this must taken list iter must take in a function to call with the thing to iterate over is that correct they get that correct okay cool i feel like okay like i mean the thing is i haven't written any ocamel so it feels i mean reading a language can be kind of easy if you have if you have something to think of like if you have some sort of template to think of and i kind of feel like you know it's supposed to be rusty right so you know i figured this was a tagged union i i know functional style is really confusing they love that kind of stuff but i could i could learn to love oh camel i could learn to love it to be sure it supports full render and hydration the same way as reacts does i migrated all tests oh really okay with all this solved on the server a rest of reacts such as hooks portals or any other apis were trivially trivial in comparison okay most hooks do nothing use the facts that don't run you state is only setting the initial value all states are ignored use callback creates a function once and probably never called use memo runs and gets the value yep okay this all makes sense yeah because on the server it's a bunch of nothings that totally makes sense once let's see one difference with my implementation is about doing a single pass on the react tree while react js does multiple passes it's let's see but it's on them to change it all nice with all this done we can return those strings as hp responses okay okay benchmark all right this is where the juice comes in this is what i'm very curious about does it win with the juices you know what i mean the juices the main question i got while i was implementing was this was about performance yeah the theory said that the compiled language ocamel should over perform and interpreted one javascript so you can't the thing is is that v8 is really amazing and there's a lot of things va can do that are really amazing you know string concatenation is a great example so in a more traditional language you're going to be making memory allocations every single time and you're going to have to reallocate and move things around whereas like v8 you got you know rope strings as we learned earlier you guys so it's a little different so it's a different world out there so even when v8 the internet runs on that node runs on top of is working tirelessly to optimize it there's been many benchmarks to prove but does it hold true here my guess is no i was curious too but as i explained above it was not the impetus impetus impetus did i say that word right that's impetus right impetus yeah for a reason react creation in fact the implementation isn't very optimized and not even profiled but it does let's see but it does try to minimize allocations and cpu cycles but there has been any performance work so far okay impotence impotence is a little bit different you know plenty of react applications get a little impotent let's say i made a small micro benchmark before pushing the production to ensure there wasn't any regressions and prove how much we gain let's see how much gain we were talking against node interesting and bun solutions oh and a bun solution okay interesting apparently buns quick we compared the performance of these three star stacks in terms of latency requests per second and transfer rate okay i love this node.js with express okay request per second average latency megabytes transferred bun okay okay so 17 about double so bun is significantly better than node is what we're looking at here but request per second it's not like it's it's great reason server server reason react 64 000 so about 10x node.js just dominating the response time the 5x better average latency 10x more requests per second transfer rate out of this world wow that's incredible i am surprised i am surprised by that much v8 is magical v8 is magical micro benchmarks do lie exactly they do lie i i always forget how bad react is okay so here's the deals i forget about how bad react is so i i didn't put that into my calculations you know when i played around with leptos and did like leptos versus react it was like a hundred x faster using like a tenth of the memory you know you forget about how bad react is when it comes to performance react has never been built at a as a performance first library that is not the point at all and so just it catches me off guard all tests run on my macbook okay okay in the benchmark okay so that's interesting so he was doing so i i would like to see this done my guess is he did this all locally so i'd like to see this done non-locally i'd love to see it put onto a server because it does make a big difference when you're on a server versus when you're local your applications do respond a lot different right i didn't realize it was going to be drastically different yeah same here yeah python is the best oh really okay status it's deployed to all of our users since february and planning to use it on all front ends although it's not ready for consumption the lack of documentation the shape of the libraries and some missing apis make it hard to use and i don't recommend relying on it okay it's open source in the repository lives here okay this could be fun this could be fun even with all of this if you're still interested feel free to contact okay so you know it would be really cool is to create a solid version right maybe you'll camel maybe i do need to start playing with oh camel okay so my general idea see oh okay there's there's some more stuff my general idea is that i do want my next project i do on stream after the interpreter is going to be trying to implement j diesel okay am i a genius can i implement j diesel but then after that maybe it's time to play with o camel you know what i mean it's working maybe i need to look into oh camel okay are you guys excited because i'm a genius and i'm going to implement the j diesel or are you excited because i might be touching o camel oh camel my camel let's go is it oh campbell or is it j diesel which one is it j diesel oh camel j diesel j diesel i know it's j diesel okay it could be cool let's see what it enables i got a little deep into some of the details about how it works with the curious minds but the implementation doesn't matter much what matters are the consequences same code for the front end and back and the same code gets compiled to native to native and javascript thanks entirely to malang's as far as i know it can't be done in any other native languages such as rust or go and let's see there are many similar situations but they don't cross compose the same code okay that's super cool that is super cool that that actually works it enables full stack applications written in reason no matter it's not a matter of one language to rule them all all but rather simplicity i'm actually in full support for single stack languages real real talk i'm in full support of single stack languages and it's one of the reasons why i've never loved go is because go does not have the language complexity to describe what it takes to have a single stack language and it's also the big problem about zig zig also does not have what it takes to be a single stack language but russ does and it seems like oh camel might as well so yeah rest us has what it takes russ does rust you can do you can do you can do a lot of cool stuff with rust right you know what i mean let's see simplicity on shares so i i'm curious about the debugging experience the debugging experience because the rust debugging experience with wasm is it sucks debugging wasm sucks real talk debugging wasm sucks it always sucks because you just get these arcane looking things and errors are weird and you're just trying to get stuff out like it does but if the transpilation of o camel into javascript and i can debug javascript i'm i wonder how i wonder what that translation is in your head if you're asking who tom is i personally would feel bad okay don't ask who thomas if you don't know the genius himself tom tom is a genius tom is a genius all right performance is much better performance is critical for any ssr solution absolutely that's that's been my whole problem so this has like been my whole new react world problem is that the new react world problem is purely this that react is now becoming this like whole streaming react server components react everything building it onto the server but it has abysmal performance and you're really tied to providers right now it's really just kind of like leaning into a lot of the serverless stuff and it feels like it's it's going to be hard for a lot of places to adopt this and so i'm very curious how this is all going to work out what is the future of react and all that so is this like a cool kind of like hey maybe you don't need that type of stuff i'm so curious right i'm curious right not not only the rendering engine itself but the platform you are running as well not only the number of requests per second it supports or the memory footprint but among many performance issues one that stands out is the slow start the slow start of a node application is a barrier for current solutions now often this problem is addressed by changing the architecture of your application by utilizing edge computing or a blocker to run ssr in development here's an example of the performance benefits of ocam o camel based frameworks are fast enough that you can boot for each request and tear down when a session finishes on the other hand this is much more challenging with note this is absolutely true you kind of i mean that's the whole cold start problem with node it is really really difficult to do this it is really really difficult heard of the bling project no by who by tan stack by solid tan stack and astro gnome weird i'm in a discord with them i should just ask them yeah i think i i mean i do think react has a lot of problems coming up allows for further explanation let's see of effects of react and no camel react has a let's see has been influenced by o camel and some of the functional programming concepts from the start such as immutability purity and eventually algebraic effects create let's see create some of these base implementations for server components which are a deal breaker for yep allowing to only run components on the server and stream the output representation of it without the client-side penalty of executing the javascript code can change radically how we write our back ends yep yep recently o camel 5-0 was released with high let's see with the highly anticipated features multi-core and effects these new features enable the possibility of exploring some of reacts concepts to be written in no camel in interesting interesting interesting interesting huh huh maybe yo camel's a little bit cooler than i thought maybe ocamel is just slightly cooler than i thought it was okay maybe i've been wrong let's see yeah the main reasons why i would not adopt this today the entire it's an entire new ecosystem new language new package manager new trade-offs okay the learning curve might be big the trade-offs made by ocamel do not match with by some of the javascript or node probably not as big as the learning curve how to deal with the paro checker okay see that's okay so this is what everyone says that oh camel is like rust without the borrow checker is this true tj because real talk all i want no offense i trust tj i don't trust you guys okay i know tj is a good engineer and i think you guys are a bunch of degenerates so i just want a trade system and iterators and then i would also love async iterators or some sort of push some sort of like rx-like thing in the language right that's really what i want and of course like a good typing system enums you know take to unions all that that's all i really want you're not wrong we are degenerates yeah i'm not trying to be mean to you guys i'm just saying if if o camel has a hurtful but true this man's not a line but what he says is correct tj it doesn't it doesn't have a type class well it doesn't have a type class in the same way but it has things like like that you can do but in a lot of ways you'll transfer your understanding of rust to okay well easily that's what i figured is that that's fair i'm a bad engineer okay everything you ask for is in c sharp yeah but then you have c sharp i'm very important person i drive a dodge stratus yeah the problem is you got that okay and i don't i don't i don't wanna i don't wanna i don't wanna do c sharp okay i don't like microsoft all right not everyone needs this at rev so we made it all let's see it made a lot of sense but it may not okay i'm very excited it's still experimental it requires let's see it requires to lift the ecosystem to work on the server so all client libraries need to be ported to ocamel okay or step okay that makes sense that could be true that okay that's our so this is a real problem smaller community but growing do we need to blow up this community degenerates okay okay so so so so so arguably oh camel is simpler than rust don't send the dj and army why not i mean then i can't do it on stream because the moment i started doing it i i've been looking i've been wanting to find a technology that i'm excited about writing full stack applications in okay because i'm so tired of of javascript javascript is just people always be like you know you can't why are you always talking bad about it why don't you just like you know just fix the things that are wrong you can't fundamentally fix these things okay it's like coming down to php laravel all right am i gonna do laravel or am i going to do full stack rust or are we going to do full stack o camel leptos is beautiful i love leptos real talk leptos is one of the best frameworks ever out there you mentioned you try to elixir i don't know if i i want to do elixir the the types really hurt me i hear great things about laravel everyone says laravel is amazing just don't make full stack frameworks that's fine the thing is i've just been wanting to try something to do that right and so i've just been on this language exploration for the last year because i really want to like make the right decision you know what i mean real talk i've been trying to make like i've been really trying out a bunch of languages like you guys have been here for this adventure and so like reading this this does get me excited you know what i think some of the tooling stuff is better in rust though yeah that's fine just to be aware the situation is getting much better for ocam on the open source space even the last six months okay i mean i'm programming with zig currently on stream have you seen the tooling in zig there we go stopped that a while ago flip stop it a while ago the name is the primogen all right