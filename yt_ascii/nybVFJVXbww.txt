yeah, we talked about elliptic curves and how we can use them as a sort of drop-in replacement for the mathematics in things like diffie-hellman key exchange and the digital signature algorithm and so on. there's another interesting story that people are asking me to talk about which is the story of the dual ec-drgb or the dual elliptic curve deterministic random bit generator, which is a pseudo-random generator for generating random numbers. most of the time you do programming, you don't need something that's truly random, right. if you're writing a computer game, and you need the ai to act in a kind of unpredictable way, a normal general mathematical random number generator, but just move some bits around and produces numbers between a minimum and a maximum should be fine for cryptography that is not the case for cryptography what you need to not be able to do is predict anything to do with what it's going to output it needs to be as random as you can and of course the problem of computers is they aren't random? they don't operate in a random way so if i produce any mathematical function or any logic circuit that produces something that looks random the problem is it isn't actually random what a normal operating system will do is combine an actual source of randomness so for example the decay on over radioactive isotope or my mouse clicks which are kind of random or my typing which is sort of the pace of which is a bit odd? and it'll combine that actual randomness with something that produces a very long stream of random bits for use by applications on a machine like these. oh these are called cryptographic random number generators. we're not talking about the actual randomness today we're talking about the generators for generating these random bits but they used all the time if you go onto if you perform a handshake on the internet you're going to be generating a random number used once you're going to be generating the private part of a different key exchange and so on so these need to be unpredictable if i can predict your private diffie-hellman key then i can just get straight in on your conversation that's not a good thing the way normally a random number generator like this works is a bit like this so we have some kind of state which we'll call s and that's the current internals for our random number generator, and that is a secret now this is seeded based on real random date so for example the keyboard taps or the hard disk latency and things like this on a computer now what we do i ask this random number generator to generate some random bits for me, and it passes this state through a function g. which is a one-way function like a hash function and this produces some seemingly random bits? which i can use in my application for something secure now if i ask it to produce g of s again it's going to be the same thing the hash is always the same so what happens is at this point? we pass s through another function f of s and it comes back down here to be s plus 1 and so the state gets updated. this is in general what a random number generator will do so we seed the random number generator with something actually random and we keep doing that whenever we can, but it doesn't happen all the time and then we can update the state and we can generate random bits as required now usually these are different functions but often hash functions of what we use the reason is because it has to be one way what we absolutely want to make sure is that i can't work out as an attacker what this state is because if i can i? can predict the next random value you're going to be that could be your password, but you're generating on your password manager so i've seen this output. this is something you sent in the clear. let's say a random number or something i've seen it can i calculate what the state is well no because it to do that i have to reverse this one-way function this hash function so i can't do it. i'm stuck here that's the idea now in the early two-thousands the national institute for standards and technology's in the us published a list of four new random number generators the idea being that these would be adopted by the kind of key players who are actually building these libraries like open ssl so most of these were kind of standard like like i'm showing you here one of them was based on elliptic curves and was a little bit unusual and so it kind of piqued everyone's interest and though i say peak devil and suspicion at the time this was called the dual elliptic curve drbg which i was going to call julie c from now on otherwise i'm going to get very tongue-tied it works very much like this using elliptic curves just to remind you when we talked about elliptic curves an elliptic curve looks a bit like this and it has a formula of the type y squared is xq plus a x plus b the idea is that this can be used to perform a one-way function like our hash if we have a point here p on our curve. we can produce a multiple of p let's say here. which is a p, and if i give you that you can't tell me? what a was right? that would be solving the elliptic curve discrete log problem very very difficult right that's all we really need to know about the mathematics for this particular one so we could replace these two one-way functions with these elliptic curve functions this point addition and kind of get the same kind of structure going and the and the nice thing about it if it worked would be that this is kind of mathematically provable in some sense because we know how difficult this problem is we don't know for sure what the difficulty of this hash function is because no one's broken it yet right we all fought sha-1 with unbreakable and then what happen all right so how does julie c work all right? so we have our two random variables on our curve right p? thank you. it doesn't matter where they are for this example they just points on the curve, so those each have an x and a y-coordinate we have a state for a random number generator s. that is not a point on the curve it's just a number so what we do we want to use s to generate some random bits but then we also need to update the state and their state has to remain secret remember so the first thing we do is we calculate s p all right, so we're moving p around the curve s x right and that gives us our r is just the x coordinate of this so this is going to be a point on the curve we take the x coordinate and that's our number now ah it's sort of an intermediate variable we're going to use it to generate our random bits, so we calculate our q and we take the x value so our q x in some sense and we scrap the first 16 bits of that we take the least significant bits of that from 16 to the end i'm using sort of python notation. why not write what sort of size and in bits is that number? they're going to be approximately 256 bits because they're modulo upon bits 256 bits and this particular curve now this has been our random number right so so far so good. we've got some random bits out we then use our we pass it through p again, so we say our p. don't doesn't so why and that? produces our new s but by taking just vx again so what we've got is the exact same framework that i showed you at the beginning we've got a state. we update the state by moving it around the elliptic curve a bit and taking just the x coordinate but we also can output some bits in principle which is not a terrible idea for a random number generator except for actually this is much slower than a normal hash based one by about a thousand times right which for you know for someone who really cares about security maybe they would be able to accept that but in fact actually there are some other bigger problems with this that mean that the thousand times is really the good part of the deal in sats in some sense remember that the whole point of this is that if i get this in the clear? i can't reverse to find this internal state the reason i can't do that is because first of all i don't know what our q was and even if i did i can't go backwards through this to find r. and then go this way right so we can't reverse that because that is a one-way function remember just because of the elliptic curve problem if i was an attacker how might i attack this well the first thing is to notice is for 16 bits it's not actually very many so i can brute-force through the possible our q's quite quickly to to the 16 operations 65,000 operations even on a laptop not going to take very long so i go through and i find all the possible x's for this random data and only some of them are going to adhere properly to that elliptic curve formula where we can find an actual y that goes with them. all right? so let's say we go from 65,000 to 10. we have 10 candidates that's a real problem, so we found that our q fat alone wouldn't actually be much of a problem so then the question becomes can we reverse this discrete log problem and find our way into this state which would be a huge issue and the answer is? if these two a random no we can't do that all right if p and q are truly random we have to brute force it we have to start with as one doesn't work ours, too doesn't work and how many how many of those are there? 256 bits worth which is not yeah, it gets a bit more complicated that not all point to valid on the curve and so on but is a lot of them now what if there was a secret mathematical relationship between would that change anything? what if he was actually equal to some multiple of hue like this now it will be very difficult to prove that because if we can't solve that problem we'd have to find that a by brute force ago or there is a relationship between the two brilliant right we don't know but the problem was that when this standard came out it was implied that the nsa were the ones that generated these points and they did not explain how they did it you remember the video on nothing up my sleeve numbers let's pick a number at random i don't know 24, and then did some trick with it you think well that's great but clearly 24 wasn't random there's something up the sleeve. we're not sure about it. if this is true. if there's a secret e which we can multiply by q to get to p, then? here's what happens? we have our q because we've derived it from bith here all right, we can calculate e our secret e times our cue, it's associative so it's actually our times eq eq is p so we've got r of p which is this and we've calculated the internal state? right this should be impossible to go backwards from here to get to here. it's trivial if we know this secretly right which is kind of worrying? what's more interesting about this it's not so much the mathematical backdoor, but could exist it's wherever it exists. no one knows and what happened when this nist standard was announced so when it was announced? cryptographers said well first of all this is not enough bits. you're cutting off here right. there's a slight bias in the output we don't like it. it doesn't look random enough. that's a problem. it's a thousand times slower. that's a problem all right, this didn't worry too much about this. they said it's fine. why we're gonna put it in then in 2007 dan sumo and niels ferguson from microsoft did a short talk explaining that this backdoor could exist you know that should have killed this off straight away but the problem was but it was an agreed standard in this it was starting to be implemented in some of these libraries and that's deeply concerning. we don't know whether this exists hypothetically it could all right but no one can find this e so how can we know but then the snowden leaks came along? and it looks even more suspicious money was changing hands between the nsa in companies to have them install this as their star for a number generation. that's deeply suspicious and so the strong opinion should he be consensus of the cryptographic community is that this is indeed a backdoor? someone knows that a but it isn't me and but we don't know for sure, but it's a really interesting issue because there could be a backdoor but they might not now of course when you're using this you can generate your own p&q and then it's not it hasn't got a backdoor. well if you put it in yourself but the interesting thing was in my list standard they said you have to use this p, and q if you don't we won't give you a fits accreditation for being extra secure which is also suspicious so it's a really interesting read if you read the history of this people were coming up with problems. they were publishing papers saying that's not right and they were being ignored and the standard was put through anyway, which is you know very interesting? if i was on stage i don't do magic right, but if i was on stage and i said to you let's pick a number at random i don't know 24 and then did some trick with it you think well that's great but clearly 24 wasn't mathematics to do with lines and the tangent of this curve it's actually not very complicated the point is of what we're doing is by multiplying g by both numbers or adding it to itself this point addition. we're moving around this curve