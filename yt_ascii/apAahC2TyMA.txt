um hi everyone i'm roy roy barkan and as mentioned we'll talk a little bit about the argument passing this is an interesting topic that seems like a very much like a beginner thing but there are some subtleties and delicate points to to to think about and hopefully you'll learn some cool things as we talk so i'll start off by saying that i'm not an expert on this i'm not a committee member and as i said i'm just a dude if you have anything that you disagree with please ask ask questions and i'd be happy to learn together with you guys so my name is rory barkhan as mentioned i mean i'm i live in tel aviv in israel i've been doing a c plus plus for quite a long time now and currently i work for a local high frequency trading company called the eastern research in israel where we do a finance and algo trading a lot of cool and hard technological problems if you're interested you can feel free to reach out to me and since kovid have been you know getting much more online than i used to and got there really addicted to civilized meetups both in israel and around the world there are several german meetups that i've been attending regularly and i really like it i try to participate as much as i can and ask questions and i really encourage you to ask questions and make comments as well due to the setup here i'll probably answer most of the questions around the end but feel free to ask anything and we'll get to the to answering as we get as you wrap around wrap up towards the end so the talk uh today is mostly about the simple fast core guideline f-16 civil pass core guidelines for those who aren't aware are just a set of guidelines initiated by brian strasstroop and herb sutter trying to encourage people to write simple plus in a safer and more modern way cbs plus as you know is a very backwards compatible language so there's a lot of his history to writing code and many things can be done in many different ways the guidelines are meant to help us and know how which parts of cpr plus are best to use and how to use them and the guide on f-16 has to do with passing arguments to functions and here's the guideline it says there for in parameters past cheaply copy types by value and others by reference to const okay so that all sounds quite reasonable and quite logical and they also say that the reason the reason is that both of these alternatives they let the caller know that the function will not modify the argument and they are both fine for our value arguments being passed in however the guideline you know doesn't hasn't told us yet when should one choose passing by value and one by reference and here's the their little description saying that c2 copy is something that isn't really hard or easily known it's something that depends on machine architecture and usually two or three words are best passed by values and the reasoning that they give is that nothing beats the simplicity and safety of copying and it's faster in in some cases if copies is cheap than actually passing things by reference so that's the guideline and to give us a little bit of a concrete idea oh yeah let's look at examples so here are four different functions that are very very similar doing similar things to objects of different types so first up we have this scaled down function that receives a vector of doubles many many doubles and wants to divide all of them by one single element okay and so it goes in a for loop divides every item by one single element and we choose to pass things by value because double is a small object okay and it's cheap to copy similarly if you want to do a similar thing not with doubles but with points maybe a two dimension or three dimensional points it's still relatively small so we pass it an origin location by value and we can move all the points by some specific origin or based on some specific origin location again cheap to copy pass by a value then if we move on to larger objects that are maybe not so cheap to copy we can have maybe a rotation matrix like a a change in the in rotation and changing perspective that i might want to do to many many objects many many other rotation matrices so here again i'll multiply every item by some delta and because rotation matrix is larger maybe four or nine elements i go and pass them by cross reference and similarly if i want to add the suffix to many many strings those strings can be potentially expensive to copy strings you know many times require memory allocations and so copying is hard so again we use the const reference so these four functions are very very similar and based on the core guideline we use either const reference or pass by value for different types okay one of the main questions that i thought to myself as i was reading the the guideline and as i was thinking about the new advances to modern c plus plus is what should people do with templates okay so i have a template function again very similar to all the ones above where i want to accept a container like a vector and a value and perform some binary operation on all the items i need to think whether i want to use pass by value or pass by const reference and the trick thing here is that the value here is templated on so i can't really know if it's going to be if it's cheap to copy or if it's maybe expensive to copy so i want i want to ask you and ask myself what's the best way to write such a template and how can i write a template function that it works based on the core guideline f16 okay so this is what we'll try to answer and think about throughout this talk today okay so for a trying to answer this question by myself i try to look around at the other pieces of generic code in the stl and see what what do they usually use okay so in most cases inside the stl the method used is passing by const reference okay the logic as far as i understand behind it is that passed by value can be cheap for cheaply copied items but it can be very expensive in some in some cases and password reference is generally always relatively cheap that's the the main assumption that people can use and think about and for that reason both in both examples here the call operator for a destruct plus uses a pass by reference and similarly the remove algorithm in the stl that wants to remove an element from a sequence it also takes the type t by reference you should note by the way that for plus operator it typically is used for cheaply copied items you know plus is usually an arithmetical type of thing and arithmetic k objects you usually think of them as relatively small but as we've seen in the examples previous slides sometimes even uh even arithmetic objects can be relatively large like large vectors matrices etc so that's what the stl usually does there are a few cases where they do pass things by value and one important example one such example there are cases where a copy is needed to be done anyway okay so regardless of whether it's cheap to copy or expensive to copy there must be a copy done at least once in some algorithms like in this accumulated function if a copy needs to be done then there's i guess no harm in doing it as part of the argument passing mechanism okay so accumulate has some initial value that can be passed to it that initial value gets modified inside the the function and the and returns back so in this case we do a pass by by value get the copy regardless of whether the element is cheap or expensive to copy a copy is needed anyway so why not pass by value there are other cases where a copy isn't needed but copying an item is much safer and i think a main example for that is actually the constructor of std column column bind i'm not sure how much you remember std colon column bind but it's a mechanism to basically create function objects out of other function objects it's like a functional approach and in this case here i wrote an implementation that divides every element in a vector by some constant a and that the constant a is is passed through the constructor to sd bind and then we get a transformer that divides everything by a and in this case because there's a construction a construction of an object you know being used and there's a potential risk of the lifetime of the bind object being longer than the lifetime of this object a then the stl chose to have the constructor get the elements by value and they also uh store store its value in that reference for for use later on okay so that's what the stl does and before trying to maybe write a mechanism that is more generic and tries to really adhere to to the guideline and tries to really write my template function in a way that behaves differently for cheaply copied and expensive to copy objects i want to address a little elephant in the room in a sidebar about an ocean called aliasing i don't know how many of you have heard of it but anything is actually an obscure but quite important part of the way that the cpus works especially when with regards to arguments but even more generally when it comes to pointers and references so where what's aliasing aliasing is basically the notion that if i have two objects or two references especially they can actually be a reference to the same place okay and if i go and try to write the scaled-down function that i showed before using const reference okay you see it's the same function is here but its behavior will be very very unexpected if i go and try to scale down a vector not by some arbitrary value but scale it down by one of its own members so this call here scale down of my vector scaling it by the first element you could think of it as sort of like a normalization operation trying to normalize the first element to one and everything else to normalize by the same factor but when the scale down function is implemented using a const reference the behavior is actually very different from what's expected let's go to compiler explorer and see that effect so here's the code base you can see that i create a vector with three elements all of them are equal to two and i want to scale scale the vector down by its first element and i would expect all the elements to be scaled down to one and have a vector of one one one but actually that's not the case and the the first element gets divided by itself to become one and then the rest of the elements they don't get changed at all because they are actually get divided by one itself okay so i hope where this example is understood that the object or the argument a is aliased it's it's actually the same value or the same object as the first object in the in the vector and for that reason inside my for loop after i divide that first element by itself then a also gets changed okay so a although a is a const reference and it's it's const there is a way for my code to change it as i'm running okay and this is perfectly legal c plus plus this is the the behavior that the standard defines although it can be a little bit unexpected and when we look at it this way okay so this is a tricky thing and there are also other cases in the real world where this thing can bite us for example here's a piece of code if you know the erase remove idiom that tries to take a vector of maybe non-uh unique items and they remove all instances of the maximum element okay so if the vector has multiple items that are equal to the maximum i want to remove all of them and this code is actually a bug and it will not perform what we expect and there's we'll see the example of this exact code a little later on and again the reason is that the sdd remove will accept this max element object by reference and even though and max element will return an iterator to the maximum element and the star operator will convert it from an iterator into a reference and that reference will be used inside std colon corona remove and as we go through the the vector in in the remove algorithm the the element itself or the reference itself might change and the things can go horribly horribly wrong if you look at the the documentation for cd column column reference in the cpp ref if obviously they call it remove sorry in cppreference.com you'll see there's an actual warning about this specific case okay so as you can see this is tricky stuff okay when you look at this code it's really it's not so easy to understand that a problem can occur here and i think things can be even more complicated when we think not just about functionality but also about performance okay so we rarely consider it ourselves and it can lead to strange and rare unexpected bugs and the compilers on the other hand they can't ignore it and the performance can can really really change when we move or switch from passing things by value to passing things by const reference so let's see the effect of aliasing on performance by taking a really really extreme example okay so let's look at this foo function that i wrote here again very very similar to the previous ones i take a vector v of doubles and the coefficient and i want to multiply each and every item by the sinus of the coefficient okay and this function that i wrote takes this double by a cons reference and as we've seen before aliasing can give us unexpected results and even if there are there is no aliasing and if the coefficient is not at least with the items the performance can really really be different compared to passing the coefficient by value we'll go to compiler explorer and see it in a second if we like but first i want to try and give you some intuition about why the this risk of aliasing why passing by reference can harm performance okay so the basic thing is is that the compiler has several optimization that it can do in general but are not possible when the compiler is afraid that there might be aliasing that there might be a chance that the coefficient here is actually one of the elements in the vector okay so first opportunity it has to do with registers versus memory okay whenever the compiler you know generates assembly it wants to to move whatever elements are heavily used and commonly used into registers and keep them in registers as long as possible but it's they it can't be done if the underlying variable that the object which moved into the register you know has been worked with could have been changed okay so if so in this case if we move the coefficient into a register as we walked through the vector and change elements in the vector the compiler cannot be sure that the vector itself isn't also pointing or looking at the coefficient so the compiler has to reread the coefficients from memory time after time to be sure that the value hasn't changed in the middle okay or to take the updated value okay another thing that compilers typically do and can cannot easily do where when it comes to references and aliasing is vectorization okay vectorization is also where something that people sometimes refer to as a simply simd it's it's an operation where the compiler can use specialized assembler instructions to perform multiple arithmetic operations on multiple items at the same time okay and in this case you know most comp processors both you know regular x86 processors as well as arm processors and also gpus they have the ability to perform multiple multiplications or several multiplications at the same time at once but if the compiler suspects that one of the multiple or one of the parallel multiplications will actually change the coefficient in the middle of its operation it will become illegal to do all of them at once you have to do them one by one and this can really hurt performance okay and the last opportunity that i can think of that's relevant for this case is what's known as expression hoisting okay expression hosting is an optimization that the compiler tries to do where it tries to see if there's any calculation that's done inside of a loop and it can be moved out and and taken and be calculated just once outside of the loop okay and in this case if the compiler knows that the coefficient is not part of the vector then the compiler can also know that the sinus function is what's known as a pure function has no side effects and has the ability to move this entire sinus calculation outside of the loop calculate it just once and then multiply all the items in the loop but if there's a chance that the coefficient itself might change throughout the loop then suddenly this expression hoisting becomes illegal and cannot be done okay so these are several opportunities the compiler is not able to do when it sees that there's a reference to the coefficient and there's a risk of aliasing and this is an extreme case and it can be really really uh harsh in terms of performance i don't know where how much you think it is but here's what cpp bench tells us with the with the google benchmark as we can see passing an item by reference in this specific case can make our our hot loop this loop run 40 times the slower 43 times lower than passing things by value so as you can see this can be very very important if this is the code inside your main loop so beware okay if we go back a little bit into compiler explorer this is relatively you know tough to see around here but here's here's our code there's the reference implementation there's the value implementation then the only difference is whether the coefficient gets passed by by value or by reference and it's really it's not so easy to see in the assembly but if you look really really closely you can see that the by ref function has these calls to [music] to the sinus function you can see this call here at 940 and and it's actually inside the main loop okay and and this here's another call and these are inside the main loop whereas the implementation of by value i can can actually do it just once hoist it and there's no need to call sinus calculation time after time again okay great let's uh move on and talk a little bit more about the aliasing and compilers and this performance penalty and how we can maybe deal with it in our own code base okay so first i should say that the compilers they really are aware compiler writers are really aware that this is a major issue and that performance can really go down if they have to be so conservative so a lot of the work of the optimizers is try to prove whether alice is possible or not possible so even if when the compiler tries to generate code for function that accepts several arguments by reference where some of them might change the compiler really tries to prove to itself if there's any reason or any case where the different references might at least to each other and whether this is a risk okay and if the compiler is able to prove that there is no aliasing then they can create the high performance code even for a function that accepts arguments by reference okay and there are actually also cases where the compiler is not sure but they can can think that the performance impact is so large that the generated code will actually check for aliasing in runtime okay so if the compiler can do it there are cases where the generated assembly code will start by checking to see whether a reference to cons or a reference might alias some other vector or some other region of area if there is aliasing it will go to and run the slower variation of the code and if there's no aliasing at runtime they can go and they run the fast code so that's something that's done by compilers but my personal experience is that compilers are really lacking still in this area and they can try to prove that there are many cases where they are not able and they go for this worse performance okay in the c language there's a way for us to help the compiler there's a keyword called restrict that programmers can use to annotate their variables or their arguments to tell the compiler this this pointer is a restricted pointer and it cannot alias okay so the general definition is that if there is a code block that has a pointer or an array in c that is a restrict point or array then the the developer the you know the programmer basically guarantees the compiler that uh there's there's no other there's no place inside this code block where this area pointed by the rest pointed by the restricted pointer will change either than through that pointer itself okay so if a function in c accepts several pointers into several regions of area and one of them is a restrict pointer then i'm basically telling the compiler that it can be sure that no other pointer will actually point or change that area appointed by the restricted variable except through this home pointer itself and if for some reason i tell the c compiler that a pointer is restricted and there actually is a aliasing in runtime in my code base then it's considered undefined behavior the compiler can ignore it and there's no reason for the compiler to even give a warning or treat anything here especially okay cpus pass it doesn't currently have the restricted keyword and many simplex compilers do have some support for for similar things but it's not part of the standard and this means that in c plus plus we don't we don't have the ability to really tell the compiler easily that we know something about what's going on and the compiler doesn't need to worry about things and this makes our life harder the reason why this keyword exists in c and not in c plus plus is i think because in simple plus things are more tricky okay if i add a new qualifier to arguments you know currently every argument can be const or volatile or const volatile now if there's a different qualifier or restrict we need to think about what does it mean for function overloading is a function that accepts a restricted reference different from a function that accepts a normal strict preference similar to const and that's a really tricky part so implementers really or i think the simple wars committee wasn't sure how to how to do it also in simpleplus there are references not just the pointers there are potentially template objects that are getting instantiated and again we need to think ourselves is a template to of to is a vector of int different or or the same than a vector of restrict int things like that and there's also the issue of functors and lambdas that need to accept sometimes the objects by reference and keep and keep the references to themselves and we need to think about whether if the argument that i get the lander accepts is a restrict argument should it take should the restrict property be propagated into the lambda itself so this is tricky and that's why the restrict keyword hasn't been adopted so easily into civil wars and hasn't been adopted yet but there have been various suggestions to try and add similar uh capabilities into the language all of them are relatively old like more than two years old i believe and so far as far as i understand there aren't there isn't they aren't really moving forward too much into the standard so there was one proposal to add up like an attribute called alias set where the programmer can give like add attributes to various references or pointers saying that they might alias with some other variables but not with others there's been a suggestion about adding things to the library like std column column this joins function where that i can call which will be sort of like a precondition for my function when i call it the compiler can know to not actually generate code but understand that this is this is like a precondition for my function and and then and generate code as if the two different references or two different arrays are disjoined and do not alias with each other and there's been also suggestions of maybe adding as like attributes to span and md span to say that a span of various elements is a restricted span meaning that the others spans or other pointers or references will not also you know alias or pointing to the same data in the span but all of these as mentioned have not been added to the standard yet as far as i know there are there aren't really a lot of productive discussions to adding into the language okay i should also say by the way that in c plus plus anything is type based okay so if i have two references to a double or and they might potentially aliase with one each other but if i have in a reference to a long and a reference to a double then they cannot aliase and the compiler knows that there's no reason that it's undefined behavior to have two uh two references pointing to the same address of different types there's a notion of what similar types are and if i have for example a union of double and longer than that union i can do those strange things perhaps but but then not much more and even with the union there's the notion of the active member and if a union of a double vlog currently has a longest act as being active also looking at it through a double reference is something that isn't a defined behavior and the compilers so if we have several references of different types the compiler is allowed to make the assumption that they will not always with each other and by the way std calling column byte and car are special you know types of of objects that can potentially aliase with with everything else and this means that the compiler has a little more opportunity to assume no aliasing if several types are are involved and this by the way is something that people sometimes overlook when they think of a strong type this okay so strong type diffs as we know are mechanisms to make the compiler more aware of the actual you know attributes or the actual meaning behind the different types and so we won't get confused and let the compiler give us errors if we try to for example add seconds to meters or do some inappropriate calculations between different types but something that people don't think about that much is that strong types can also improve performance because a reference to emitters cannot also cannot alias a reference to a second and that can really help because the compiler is much more aware of what can be done and then if i go and try to you know multiply several rotation matrices by one rotation matrix there's a change of aliasing but if i have strong typedefs for like an object orientation which is actually a rotation matrix and like a camera orientation which which might be a rotation matrix the compiler will know that a camera orientation and object orientation cannot enlist with each other okay if it makes sense and this is another motivation for us to try and start using strong type tips more because they can really improve performance in several cases okay i should also note that although the steepleverse language has these relatively strict rules about aliasing and on aliasing and there can be undefined behavior in many cases and most compilers relax the rules a little bit and there are some cases where although the signals language says that two different references cannot alias and it can be undefined behavior otherwise the compilers will actually check for aliasing and will actually not be aggressive with optimizations favoring more predictable executions over performance knowing that some programmers might use unsafe reinterpret casts and these types of things and the compilers prefer a predictability over performance which can be a shame for us i guess okay so that's my prelude about aliasing and now let's get back to the earlier discussion of how do i write a template function that that can either get things by value or get things by reference and how can i write a library that tries to cater to all different types so one thing that i want to say is that regardless of what the library does it can be very very powerful to also let the whoever uses my library give me some hints or give me some advice about what to do and how to do and this is something that already exists to some extent even in the language itself so one thing that you might be aware of is something called the reference wrapper used by std column colon ref which is a way to basically wrap a reference into something that looks like a value and something that has semantics which seem like a value semantics and if i use std column colon ref with the bind constructor then the the object that gets passed by value into bind is not the actual object a but a reference to a and the reference wrapper is sort of like a trick that existed since cps 98 it's a an object that inside it has a member that points to the object a and has a casting operator that can be the thing that can cast that pointer into reference to that object so it's a nice trick and it can and if you find yourself using a library that is templated maybe and it wants to get an object by by value then perhaps sometimes you can use the std column colon ref to make things easier and to avoid their paying the the cost of copying a large object into and outside of that function you should notice note that the std reference wrapper is relatively delicate it's not it's not easy to do everything with it you know the rules about when a compiler is allowed and not allowed to invoke the casting operator are relatively delicate so it's not a i can't promise that whenever you want to avoid the passing things by value you can just use sd card column ref but you should keep that in mind and i should also say that if you're writing your own template functions that do accept the values by or to accept arguments by value you should consider and think about cases where your whoever uses your function might want to use std quote unquote ref whether it makes sense as well and whether you can write your template functions to be accepting and willing to to take these types of arguments okay there's also the opposite way to give power to the caller in cases where i want uh the function wants to receive you know a pointer to to accounts reference or so i want to receive a account reference and i want to pass it an item by value to make sure that there's no aliasing okay so this is what we can do here there's this usage of a decal type of colon colon value type is basically a way for me to convert the reference that max element returns into a temporary object and that temp and and then sdd remove will accept a reference to the temporary object instead of getting a reference to inside the vector okay instead of this decal type colon colon value type ugliness there's a there's another simpler code called the decay copy it's not part of the standard but it actually appears as like a helper function in the cpl standard itself and it's relatively easy to to implement such a function and make sure that in this decay copy it knows how to create a temporary object if it receives something by reference but not a incur an extra copy if it's not necessary so let's look a little bit at this source code and see the behavior of the sd card corner remove with the amx element so here we can see a compiler explorer again i have a vector that has a four ones and a single maximum element which is two and i copy it so both vectors v one and v two have the same four elements and now we can i use the erase remove idiom first time on v1 using just asterisk star element and the second time i use this decal type quantum quantum value type trick to create a temporary object in reference to it and we can see in the output of compiler explorer that the second vector v2 has the size that i expected only the second element the maximum element was removed but there on the first example on v1 the you know aliasing really uh hurt us really shot us in the leg and there we suddenly get have a vector with only two elements and again this is perfectly legal plus code there's nothing undefined in here this is the way that the compiler should behave okay this is you it's on you to know not to pass a reference into the container when calling std colon code removed i hope this all makes sense and a short look at a decay copy so here's an implement you know you know suggested implementation for decay copy you can see it's a template function that gets a universal reference for for for a value and just affords it but it returns std column colon decay t okay so if i if the the function accepted the value type it will return a value type but if it accepts the reference it will still return a value type okay and this this way we can write a nicer code with the k copy and then get the exact behavior as we wanted okay there's also by the way a suggestion to the superior standard to create a new language facility called auto x where one could really just instead of calling a copy they could just use like auto as like just to create a temporary object of the type that it is and to basically materialize a reference into an object okay great [music] so now that we've seen all of these things i want to go and look at a way to create a general template function that can pass get accept things by value by reference based on uh based on whether they're cheap to copy or not and i'm actually you know taking a a suggestion from herb satter okay in cppcon 2020 last year herb sarger talked about this exact notion of passing arguments for input for output etc and he also noted that there should be a simpler way or simple way to write a template function that accepts an argument either by cons reference or by value based on whether it's seek to copy and he gave some a suggestion on how to do it as or seeing how complicated it is in the c plus plus a 20 as it is right now and his suggestion makes use of a c plus 20 concepts okay so this code here is relatively small that's i wrote it in a little larger font in the next slide and let's see what the suggestion is okay so the suggestion is basically to write the same function for twice okay once receiving the argument t by a value and the second time receiving it by cons reference and using the simple class requires mechanism okay simple plus concepts mechanism in order to let the compiler correctly choose which of the two implementations to to use for different types t okay before if we didn't have the required slots here the compiler would see these two full functions as ambiguous to each other okay but now in c plus 20 with requires if it's like a sphenoid mechanism to have only one of these two functions actually exist for each and every type t okay and uh so sutter actually created this or suggested this notion called the should pass by value to v which could be true or false for different types he also gave a suggested implementation using a context for boolean and the suggestion was saying that if something is trivially copyable and its size is smaller than eight bytes it can be passed by value v i should know that this is not something that really hurt things that should be added to the language okay herb just said that if we wanted to implement the template function in the correct manner for input input arguments c plus 20 this is the way to perhaps do it and he wants to suggest for newer versions of the language to have a simpler way to do this thing because this is quite a cumbersome and complicated what do you think about this approach do you think this is something that we can do and work with right now when we write our own functions food that are templated i personally think that there are several things that you know aren't really don't really make sense to me when i look at this code let's go through some of them first of all we can see that this is simple as 20 code but in herb's example should pass by value v is a context of boolean and not a concept okay herbstatter could have chosen to define this as a concept but he did not okay and this really puzzled me regarding why why did he use a conceptual boolean which is an older mechanism and not a concept and i'm not sure but i think that the main reason has to do with specializations okay cos x or booleans can be specialized and if i if i would have written my function for like this then any user that has a type t that may be and who isn't really satisfied with this condition over here can specialize should pass by value v for their own type okay concepts cannot be specialized okay secondly it's obviously always important to think about this condition and why why did he choose this condition not some other condition we can see that we you know we know that the core guidelines says something about the two or three machine words okay and this size of t smaller than eight is actually i think very very restrictive i potentially would have done something would be something larger but again this was just an example that he gave i don't think he really gave it much thought but then again maybe i'm wrong and thirdly i'm really concerned about the fact that the function foo needs to be re-implemented twice there's really a lot of code duplication a function foo is a large function it and you need to duplicate it twice it's really really a big shame and if you think about it it's really hard to get away with it or to get around it because if there's if those two functions have some share or they all share their code they want to call some share the functions themselves they want to you know extract all the shared code into some other internal function then you need to think about whether this internal function should receive the argument by value or by cons reference so it's really really difficult and without using some ugly preprocessor mechanics i don't think see an easy way with this kind of code to avoid the code duplication which is a shame okay and lastly and this is something that by the way herb starter also mentioned this code doesn't really think too much about aliasing okay and and this function foo if it just accepts one argument then there's potentially no no not much risk of aliasing perhaps maybe only aliasing with some global state but still um as we as we saw different types t if they would automatically be implemented with passing by value or passing by reference means that the behavior the the functional behavior of the function of the foo in cases and on those different types can be much much different in in face of aliasing which is tough and i think that you know any library that wants to be smart needs to also you know at least hint to the user about anything and let the user give us some guidance regarding what to do with aliasing okay so that's herbs code and now as we you know moving into the final part of of the talk let's i want to show you my suggestion for a way to do this type of functionality maybe in a simpler manner okay so this is a my suggestion and again i'm starting off where a herb such a left off with a context of boolean should pass by value v but instead of having two implementations and utilizing the requires clause mechanism to choose between them i try to write a single function a single apply function but which which will have a different argument type based on based on whether type t is is easy to copy or cheap to copy or expensive to copy and the mechanism i use for that is the std column column conditional okay so i said as far as i remember was added on 6.17 and it's a nice way to basically based on on some compile-time boolean choose between two different types okay so based on this compile-time boolean a copy or f is either a value of t or a cost reference of t okay and now my function apply can accept the value argument by a const reference okay and inside the function implementation after i received it by cons reference i create an internal member called v which is either an actual type t or or another reference okay and so for cheaply copied the items the the object will get passed sadly by reference into the function but then copied into the stack into an internal variable and then the compiler can know that there is no aliasing and can give us the best performance whatsoever and in case the object is expensive to copy then the reference will be passed into a function be kept as a reference inside the variable v and then and i won't need to have to pay for the for the expensive copying that they might you know that might hurt me okay and then if there's any reason or any case where the user of my function is concerned about aliasing even if they have an expensive copy argument and they are concerned about anything then they can just pass an extra boolean telling me that they want to force things to be passed by value they want to specifically you know have a copy made if necessary just to make sure that there is no aliasing okay so that's the potential idea and that's my suggestion it's still a little bit tricky that night and and not so nice to you know to look at all of this but at the end of the day it is a single function where where you know we can use either value semantics or reference semantics based on the different types and as mentioned i'm sure you might have nice ideas about how to improve it actually when i presented the version of this talk earlier this year on the dresden cps user group i got some great suggestions and incorporated them here so and i'm sure you'll have some suggestions as well yourself okay so wrapping up this is basically all that i had to share today and so to summarize it all argument passing as we know in c plus plus is a hard issue and it is it does make sense to have specific core guidelines about how to do it and it's something that we need to think about when we design our own functions and our apis aliasing is something we rarely think about it can cause rare bugs that are hard to find and also very frequent performance losses so if i use a passing arguments by cross reference i can sometimes leave a lot of performance on the table concepts in the simpleplus20 requires clauses can make it easy for library writers to capture nuances and have and let the compiler do more complicated things that existed before but things are still hard and there's all still issues related to to a co-duplication and also related to specialization and when you write your own templates i really i want to encourage you to think about your users think about how they might want to use your your functions in your code a little differently than what you expected so think about ways where when they might want to use std column code and ref or decay copy and try to make your template code as as positive and as accepting of these types of things yourself okay so that's what i had planned for today i'm very very happy to answer questions and listen to your comments so thank you thank you very much for the wonderful talk we already have a number of questions in the q a tab and audience please feel free to add some water there the first question concerns slide 10 so maybe if you could go back to slide 10 though yeah i'm trying we're currently seeing slide 13 i don't know no it's legend wonderful the question daniel asked is isn't the compiler allowed to assume that cool f is unchanged because it is marked as const and now someone asked the question yeah but the performance should then not be effective was what then you are sorry i just got it confused with it's good okay yeah great so so the compiler is not allowed to assume that the co-f will not be unchanged as discussed this is a tricky part in c plus plus where having you know a variable marked as conch reference means that it's not allowed to change it's by itself but if it's a reference to some place some other place then it's totally legal and totally fine to change that other place and assume that and the compiler must assume that that change will also affect the other accounts references and it's so the compiler is not allowed to make any such assumption and that's where the performance penalties lie okay okay wonderful the next question concerns slide 10. slide 12 sorry two slides further and the question is what is considered a strong type diff here wrapping a type in a new class struct is that what you meant there yeah so yes so a strong type def is a a notion that you know others have discussed the in the past there are some template libraries that implement these types of things and there are suggestions to add strong titles to the language itself either to the core languages or to the scl but basically they're these are usually things that are implemented as you mentioned there's a some wrapper class that has a member inside it and that rapper usually also supports like many operations that that the underlying class typically supports like maybe addition multiplication assignment comparisons etc but the compiler knows it's a different type it's a it's a different type and there's in the the compiler know that it's undefined behavior to take an object of one stroke tie def and just reinterpret cast uh you know another a pointer to another a strong type that with the same underlying type pointing to the same a location so this so it's undefined behavior to have two objects of different strong type diffs pointing to the same location and the compiler knows it and can give performance boosts based on that okay thank you the next question was if you could please clarify whether the k copy or any other workaround with stacker type still has the same performance as was passing by value that is still 43 times faster yeah so let's think about it so so the the the the you know the correct answer is that that it depends and it depends on the compiler the tricky thing here is that the compilers really try to prove whether aliasing is possible or not okay so if i have a function that accepts objects by by reference and that function is unknown to the compiler and cannot be inlined or like like in some third-party library then using the k-copy will not affect the performance or the code generation for that function and the decay copy will only assist me with a functionality to make sure that anything won't hurt my functionality but won't affect the performance on the other hand if the code of that function is known and there's a and the function might be inlined as well the compiler can really prove for itself that the copy operation happened and thus there's no aliasing and create its own separate like in-line implementation that is faster okay cool the next question is david zanevsky also showed some examples on how the compiler optimizes especially gcc and playing themselves makes best decision on how to pass the arguments into generated machine code it often ends up having nothing to do with c plus plus programmer wants to enforce why buzzer what is your opinion if you thought i would talk yeah yeah it's a long question let me try to read it to myself again yeah oh yeah okay so i see that this is a reference to david zlasky talk yesterday i only saw it briefly so but i encourage you to go and look at it it might be really really relevant and yeah so so first of all when it comes to argument passing as david said sometimes compilers can can do a lot of things and optimize things but sometimes they they actually cannot because there's the issue of abi and api is something that is very very strict and has and the compilers rarely have good ways to to go around it so it's it means that there's many cases where the compilers can't really make the best decisions themselves because they have to adhere to an api and then yeah i'm not sure what uh the you know what the what you mean by why why bother but i guess maybe we can take it you're welcome to join us in the lounge after the talk and i'll understand what you're asking and we'll see okay okay are there any further questions if so now would be the time to ask or later in the lounge as well will be available for questions there for a time yeah by the way i can also mention that uh if you any of you is interested in the rust programming language then in russ there's a notion of a borrow checker and then rust through the borrow checker the language tries to enforce a case where in case where if two references exist to the same underlying object then both of them have to be a constant you cannot have a mutable reference to an to an object and another reference to the object and that way rust can get the better performance than c plus plus and i should think that with something like the restrict keyword we can get that performance back but not until we do that so and again thank you everyone this was really a pleasure i hope you learned something uh cool and nice and i'll be happy to chat with you in the lounge so thanks thank you again for the great talk and for the great answers yeah of course so see you in the lounge bye