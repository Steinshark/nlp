thank you and thank you everyone for tuning in to my talk my name is daniel brady and today i want to talk about c plus bus curtains and cute i've been working with cute for over a decade now i actually learned c plus bus through qt and i i always thought i knew c bus bus fairly well up until to point up until the point where i actually left left my previous job and moved on to new job where i don't use qt anymore and i use basically p or c plus plus at that point i realized well i don't know c plus at all i realized what i knew was sort of the c q dialect of c plus plus because well they kid has certain parents right that of f api that don't necessarily match or or work well with whatever is the modern c plus bus thing and so i found it annoying that i that that you know i wanted to use the latest greatest features of simple spots that i just learned and it didn't always fit well with how cute works but nonetheless i found a new hobby and that's sort of learning new fancy sequels plus feature and then trying to see how to make it work with cute or if i can make it work with cute somehow and one of these latest sort of discoveries i made were curatings and i'm actually quite excited about that and just considering by the number of talks on this very conference about current insight i think i'm not the only one who's excited about coroutines and as i was learning about the quarantines i figured like maybe this is this is something that would work with cute very well this is something that could solve some of the pain points that i see whenever i look at my code base mostly when when dealing as more and more we deal with like asynchronous things asynchronous operations so you want to just wait for something to happen right and with q the code tends to get a bit complicated and well i thought curtains could solve that so i started playing around with that and the result of that is a library called qcoro that i want to introduce as part of this talk i'm sure you are on this talk because you are interested in cute and maybe coroutines so i guess you know a thing or two about cute still just to make sure we are on the same page i'll do a super super quick introduction to cute just so we are all on the same page then i'll try to explain the problem i have with how we deal with asynchronous operations or or so waiting for something in cute then outline the solution that uh coroutines and cucoro offer and finally i want to look a bit into what else we could do with current teens in good so as i mentioned i just want to do super super quick introduction into into cute then i will only mention the two core things that really matter for this talk and that's the cute event loop and the signals and slots concept the cute event loop it's just an event look like any other if you've never used cute but used some other system that has an event loop this is exactly the same thing usually you have a single event to bear thread you can also have threads without event loop but you can perfectly do that's perfectly valid case what we don't like to do in cube is nesting event loops event loops can be nested technically it's possible it's sometimes used to sort of like a hack to write work around uh where you really want to do some block blocks when you want to block inside some function but you don't want your like ui to freeze for instance you still want to be able to dispatch events even if you are not able to return to the main event so you nest it you create a nested cute event loop however that's generally just a whole can of worms that can lead to all kinds of crashes and issues with so so let's just assume let's just assume we don't want to do that at all right i mention it here because i will show you some examples afterwards and then to almost any of them or almost all of them you could ask you could say like well i could solve this with a nested event loop yes you could i'm not mentioning that at all because in generally you want to avoid nesting nesting event loops signals are slots that's sort of like something like a callbacks but for cube sigma is just a regular member function you as a programmer you only declare it you don't write the definition the implementation that's generated at compile time by by moc which is sort of like a little tiny cube helper tool when he i made the signal so you just call the function it's nothing nothing it's just a fancy name for calling a function cube then takes care of actually calling all slots that are connected to that particular signal and what is a slot well that's just a regular function and whatever signal that the slot is connected to is emitted the qt will make sure that the slot is called the relation can be like m to n so you can have multiple slots connected to a single single signal and you can have a single slot invoked from multiple different different signals the the main difference between this and callbacks like regular callbacks is that the connection between the signal and slot happens can happen outside of the two objects right outside of the emitter and the receiver you can have a third party that just binds them together which which helps with separating concerns and untangling interdependencies so there's just a super quick introduction into q because we will see those two things well i will mention event group and we will see some signal and slot connections all over the place so that's how i wanted just to make sure that we all that we are all on the same same page with this so now let's look at the the problem that i have with cute and that i was trying to solve enqueued or well generally programming right we often deal with asynchronous operations like network requests and when you do a network request you have you obviously want to wait for the answer and then process the result from that reply and the problem here is how do you wait how what do you do what should the code do while it's waiting right should it run some other stuff should it run some other tasks or should it just be blocked and wait until the reply receive arrives before it can continue or maybe should it just you know continue doing some other things like like you know looping in the event loop dispatching other events and making sure that the whole application remains responsive depends of course on the on the application but in all those cases you'll always be asking yourself when you're writing the code like how do i handle this right and then your eyes oh i also need to handle errors properly and error propagation and the whole problem just gets more and more complicated so let's look at an example that i have here so let's have a simple function of a simple member function which is called get username it's part of some remote some api you know class represents a net a remote api so the function if if a function is called get username i exp it takes user id and i expect it to return the username if it's called getusername right so this function takes a user id and resonates a cue string which contains the still retrieve the username how do we do this obviously in qt when you want to do a network request you need to set up a q net for access manager or it could be you know a member variable of the api service object but for just for to make this make those slides simpler i made it this way and then you call the network access manager.get which and you pass a q network request there the q network request just holds the url that we are actually sending the request to and then maybe some additional headers and whatnot and it returns a pointer to qnetwork reply so perfectly fine we jump here and we read whatever the reply contains so we read the data from the reply we interpret those data as our username and we return that to the caller problem solved right now the question obviously is so you know if i if i fire a network request i won't get the reply immediately right it will take a bit so how do i wait so obviously the most evil approach is just to use reply wait for ready read so this is a function that blocks until there is something to be read from the reply all right it's actually from qio device but still the good thing here is that this makes your code super simple to read right it does obvious things and you read it from top to bottom the disadvantage is that this function will actually block until the reply arrives so there is no event processing your event loop is blocked and while this is not the ideal solution right because if the username is really long you might not have the whole username arriving in the single chunk so the read all might not read the whole username then and then you get all the part of username so there would have to be some loop and so on but again for purposes of the slides this is one approach but obviously not the right one unless we want to like have every single request running in its own thread or something like that but then it makes it a bit more complicated again since you need to handle like how do i get the results from that threat so how do we do it with more non-blocking approach so this is one of the possible approaches if you look at the changes highlighted here is that the signature of the function has changed it now returns void and instead it takes a callback additional callback a national argument which is a callback that will be invoked by the function when the reply arrives and we use the connect connect here to connect the finished signal of the network reply to a lobby that we have created here so when the network reply emits the finished signal this lambda will get invoked by cute and what the lump that does it just simply reads whatever has arrived from the server and forwards it into the callback or it invokes the callback and passes the username to it so the caller can then do whatever they want to do with that so this is a fairly simple straightforward approach that you might use in order to to write a properly asynchronous network request right so this is sort of a typical well it's not that typical cute because it keep generally using callbacks is it's not as common i believe or i would say since the connect signature single slot syntax is trying to replace the callbacks system so this is an example of how you would use our getusername function so the the code at the top that is highlighted right now that's that's the the first blocking case right so you simply call api service dot get username it blocks for a while and gives you the username and then then you do something with that on the next line this is what it would look like if we were using the other option with the callback so again we call getusername and we pass lambda as a callback and when that lambda gets invoked we do something with the username again so the difference between this and that the the example above and below is not that big right it is still fairly easy to read them and understand the code flow and what's going on but this becomes more complicated once you start chaining those goals right imagine okay so i got the username now i need to ask another backend for something else and it gives you some other result and then you want to ask some other api endpoint to do something else with the data you know and you still need to change those requests if you use this the asynchronous approach this quickly becomes messy and things like error propagation becomes tricky right how do you actually pass an error back to the caller who called this whole thing probably the caller would have to pass you some callback as well that you would call here and it all you know tends to become a callback hell it's really difficult to navigate with the example above it would just be a series you know of of you a request you check if it failed if it failed you return early or you do next request the next request the next request and you have the whole thing in a single single chain of lines which is super easy to read and there are no hidden you know surprises or the code suddenly jumping somewhere else and then coming back so that's what's good about the blocking approach but obviously we don't know we don't want any blocking so we might end up doing the other the the other approach so this is to sum up the the pain points that i have so that chaining code is is difficult errors are hard to propagate and the hard the code gets hard to follow and hard to hard to understand especially if maybe you are not using lambdas everywhere but if you implement maybe part of it the callback logic would be implemented in a in a standalone function somewhere else and then you know you need to realize okay so i'm jumping to maybe a different file or somewhere else in the file what i've seen improve in projects that i've worked on as people start adding more and more code they sometimes put it in random places so then you imagine jumping down back down back and really it's hard the code becomes hard to maintain and treat so sorry let's look at the solution that i think i found and that that's coroutines so this is the example this is sort of a combination of the two examples that we have before if we look again at what has changed that's the highlighted parts so the return type of the function has changed it's now cue choro task q string what is cue curl task let's not care about that now i'll explain that in a moment but what's important is you can see the q string type there so in a way you see that the function returns q string ignore that it's wrapped in something for now and then there's the cool thing what we do next is the how we execute the request this is this really is similar to the first case we had the one that blocks what happens here is the network access manager dot get creates a queue network reply and the queue network reply gets passed to the co-weight keyboard and the co-way keyboard does magic and out comes again a key network reply but this time the reply is already finished what happens the code wait it checks if the reply is already finished if it not if it is not finished it suspends the routine it suspends this current function and when a function is suspended it chains up so it goes back to the caller the caller is very likely also co-weighting result of discord routine so it suspends as well because the result is not available and so on and so on until we reach the event loop and the event loop can continue have looping and dispatching events once the key network reply is finished the coroutine gets resumed so the weight keyword also the code weight the code that is hidden behind behind the weight let's put it this way it gets triggered again and resumes from there and it returns the q network reply that it got on the input but this time we know for sure that the key network reply that we have in the reply variable is already in the finished state so we can safely read all from it and then we at the end we use co-return instead of return because we are returning from coroutine so it has to be corridor so what we got here is a code that's written in a synchronous manner but in fact execute asynchronously without blocking our event loop so your application remains responsive which i think is really huge oh at least for me this is basically what i what i what i described so wait suspends the coroutine the execution returns to the caller if the caller wants the result of the callee and the caller knows it's curtin it will probably go wait on that colony so it will get suspended as well and you probably have this chain of coroutines up to the point where you reach a sort of a top level where your function your curtain was invoked by the cute event loop and the cute event loop doesn't care about coroutines it you know it just knows that oh the the the function that i just invoked has finished and returned so i can continue doing my event loop stuff so it gets unblocked the tricky part is when it is supposed to resume again because then the event loop somehow calls into the q network reply the key network reply emits the finished signal which then resumes resumes the coroutine so the the call chain if you look at that in gdb for instance it becomes really convoluted because you have like two loops through the same event loop yeah so that's that's that describe next slide there we go so now to describe the two the the cucurl task type that you saw as a return type of the routine why do we have q curve task why can't we just return q string well that's because have to have a special return dive that satisfies certain criteria it means that the coroutine we have can be awaited by the caller and other part of the queue task and that's the that's the part that makes it part makes this whole thing work is a promise type in our case it's cucu task promise and this is where the magic really lies because if you think about it we were called waiting on a q network reply and i was saying okay so the call wait it looks if the reply is finished and it's not it's a specific routine and then when it gets finished it resumes and and maybe you know they could like how does ko way know what key network reply is does this you know does the compiler magically understands cute libraries and the reality is no the co-weight keyword or the code behind kuwait does a lot of stuff there's actually to my own surprise there's a lot of code behind that single keyword that that's being emitted and one of the things that this code does it looks for a function called evade transform that's implemented on the on the promise type and in case of qcoro the the queue corro provides well sorry the the promise type in kucaro it has a special implementation of a weight transform that checks if there is a trade called key curve detail availa type for whatever reason i called it this name and if this type exists it means that there exists a wrapper that is currently aware for that particular type t so in our case t is q network reply and the q color library defines a trait for a q network reply and it creates it has a wrapper called q curve network reply which can which is compatible or supports the correct the necessary corroding functions so this is returned from a weight transform so basically what the qcoro task does to sum it up is it allows us to turn a type that does not support current things like your network reply into a type that does support coroutine like the cucurro netfi grip network reply wrapper and this type then can be co-weighted by by the ko wait the cool thing about this is that this all happens all of this stuff is basically hidden behind the co-weight keywords so there's a lot of boilerplate code going away and i really like that right this hides certain amount of complexity that you would have to copy and paste all over the place if it weren't designed this way so this is something i really like about it there we go okay so this is an example of of what it looks like of the what the trade looks like so it's like a template specialization for a particle type in this case it's q network reply pointer and it defines what is what the what the up in this case is what the type that can perform a particular operation but supports curtin is is called so in this case we have qcor wait for finished operation so it's just a class that simply has that gets well it looks like this i have it on the slide actually so it looks like this it's a it's a class which is constructed it takes the q network reply so it's like a simple wrapper class really and then it has the three key functions that are needed if your type is supposed to support corroutines so that's a weight ready the this function is called by the ko wait before it suspends the core routine just to check if it actually has to do that before going through all the loops and hoops of suspending a coroutine the code weight first checks if it actually has to do that so here we check if the network reply is not finished yet so for instance if we would pass a really invalid url the the q network reply that we get from q network access manager would already be in some finished but invalid or error state so there would be no reason no need to suspend however if this function written false then the coverweight goes on to call a vague suspense so it suspends the coroutine and it gives us a handle to the coroutine itself that is being suspended and what happens inside this function is super simple what we do is we simply connect to the q network reply finished signal and in the slot that's connected to the signal we simply call awaiting corroutine dot resume so we in that slot we simply just resume the coroutine again so when cute calls our slot when the network lebron is finished we simply resume the coroutine that's awaiting us and finally so when the curtin is resumed is awakened and resumed the coal weight extracts called this function which along extracts the q network reply the return type of a weight resume can be anything right so other option would be it could maybe return it could actually do the read all inside and it could return the q byte array with the whole data so you could just co-weight the data directly although this makes it a bit this makes it a bit more well you can handle errors and things like that right so that's why we are returning network reply but you will see that the key corro has a bit more too often over so to talk a bit more about qcaro itself it's a it's a mighty license library that supports gcc client and msvc so it supports all three major platforms so linux macos and windows basically to do something up it provides current internet wrappers for various standard cute classes those classes that are currently supported are qio device key process queue timer key feature q abstract socket so local socket key network reply qtcp server and qd bus bending call and qt bus reply those are the supported types right now just by supporting qio device gives you coroutine support for a wide range of qio device for basically many qi device subclass so for instance the queue process which is also a qio device subclass means that we get support for something that's extra in key process like waiting for the process to start and finish but we also get all the we can also co-weight on the io device having data ready to be read and or ready to be written and so on i'll show that a bit more in in the in the upcoming examples another useful thing that kikoro has is awaiting signal emissions so sometimes you may want to just wait for some signal to be emitted and we support that with qcro as well now what we saw was co-waiting directly the q network reply that is fine but there are types and keynote reply is actually one of those as well but for some reason i also decided to have sort of a default action certain cues types they have multiple operations that you may want to co-wait for for instance here i have an example from cubeprocess which has wait for starting and wait for finished function so it makes sense to be able to co-await both of them but if i would just you know to write overweight process what process would be the key process instance it's not clear which one of those is being awaited right so i'm waiting for it to start or i'm waiting for it to finish so in those cases well there is a qcoro function which is a function that is overloaded for all different kinds of queued compute classes or well at least for the cute classes that qcaro supports and it basically just returns a thin wrapper class for that particular type so for cue process we have a qcoro process and this qcaro process has a bunch of functions or methods and those are conveniently named the same as as the methods on the on the original class or some key process so cucurl process also does have wait for started and wait for finished the difference is that those classes return available types while cue process weight for started is a void function i believe or maybe boolean it returns whether it's timed out or not the wait for started methods implementing inquiry process they return so obviously operations or something so like wait for started operation and wait for finished operation and those types they are co-weightable they implement those three functions that we shown previously for the q network reply and the evade resume function the weight the result of the cold weight expression then of course returns the the again true or false very timed out now i noticed i have a mistake with my slides i apologize there should there's a there's a call weight missing here that should be cold weight and cold weight before the core sorry for that so so you have con started equals co weight q core process and so on and so on so this wouldn't actually build sorry this is another example though so this is an example where we use uh use the code so it's like we have we create a key process and then we start gpg which is like a encryption utility and now we want to know when it starts so we simply call wait for the process to start so we call qcorro which gives us the wrapper class that we call wait for started which gives us the actual type which discuss the waitable and then we co-weight on that next we know that okay the process is started so we can simply just write the data that we want to have encrypt that we want that we have encrypted so we have some encrypted data we've written into like standard input and then we close the right channel which indicates to the to the to gpg that it can start decrypting and then we just have to wait until the the tool finishes so again we use cold weight and after that we know for sure that the the the gpg has finished and that we can safely do read all because that means we get all the data now so if we were reading before that we might only get the first chunk of data that more could be arriving later now if you look at this code this looks absolutely synchronous right you would think like okay this will block my app until the whole decryption happens but the reality is it won't because we use ko weight here and the this carotene will get suspended in those two places and so you can have this single function called decrypt right which is in my eyes this is much simpler than like having to connect to start its signal and then writing the data and in the slot for that and then connecting to finished signal and then reading the data in that slot i find reading this much more straightforward especially as the code maybe grows more complex here's an example of evading signals so let's create just as an example let's create a key object derived class called process monitor and the process monitor will have a signal which is called process started and it has a single argument which is the name of the process that just started and now let's just say that we want this could be like a third party library that for some reason you can't patch it to make this routine friendly and so instead you want to but you still want to curl weight that signal to have to to be emitted so the way you do it is again by using a special overload of qcoro where you pass the the the object and the signal so this is the same as the connect well first half of connect syntax and then you then you call weight on whatever key coral returns the cool thing about this is that the result of the co-weight expression will be the argument to the signal right so this process started has a q string argument name so here you receive the argument as a as a return value from the codewave expression so so you can also read the signal arguments this way so again makes the code much more easy much more easier to read in my eyes obviously if you if you happen to have multiple arguments then they are returned as a as a as a tuple so so you can simply use uh the double decker position to to receive it this way into the color in the color so this is a i think a nice way to wait for signals here's another example of a super super super simple server so we create a tcp server we say okay listen for incoming connections and then we have an end like an endos loop which really if you like okay i never want to have this kind of construct in my main ui thread right this would just block forever the the cool thing about curtin is now you can you can simply have this in one of your slots that you just make sure gets invoked from the event loop and this will not freeze your your event loop and it will not make your ui freeze here what we do is we co-weight a new connection so again we've wrapped the server because the qtcp server has multiple operations that we may want to call wait for so we have to wrap it in quicaro that gives us the wrapper we call wait for new connection so it's not blocks but suspends until new connection is available or maybe forever if there are no incoming connections and when we have the connection we just again wait for there to be any data again by suspending not blocking and then we write them back and close it so it's sort of like a simple ping-pong server and then we go on to wait for another connection there is also a cute concurrent support so instead of having to you know wrangle with cue future and key future watcher you can simply just co-weight the the future which again makes suddenly in my eyes this suddenly makes using keep conquering much more user friendly because i always hated fiddling with these extra watcher types the same goes for d bus actually i do not have an example of d bus but but if you if you ever use qt d bus and you don't want to block or anything you don't want you want to absolutely avoid blocking the bus calls then you you hardly avoid using qd bus bending cold water so you get the call then you have to set up the watcher you know you can connect the signal slot and then you have to not forget to delete the watcher and again with d-bus the syntax looks very similar to this you can qcorro bring support for co-awaiting qd bus types like qd bus reply so this this actually happens automatically so i sort of getting to the end fairly quickly i have some future plans for the library i wrote it for the the types in queue that felt like like sort of like why don't they support it yet right well obviously because q doesn't allow c plus plus 20 yet and i don't see how core routines would come into into the cute api easily but i picked those classes like okay those are obvious candidates for having supporting pukaro but as i like sort of you know write more codes elsewhere in cute or although as i think about it i i'm coming always notice some new class that i say oh this one operation could be made into a do-core routine so i could make it i could co-weight it so my i would definitely like to introduce support for some gui and widget classes like for instance waiting for dialogue to complete and then or to be closed or well sorry accepted or rejected and then returning the result actually as a return value of the co-weight expression so that that might be interesting the library itself is the library itself is split into modules that have the same name as the cube module so that's q core core qr network q core d bus and those are separated separated libraries so you can actually just link the libraries that you use and it doesn't unnecessarily pull in like you know if you don't use d bus in your application it will not you just link qcoro core or qr core network and it will not unnecessarily pull in you know not just qr debugs but also qdbus if you don't need it or it's maybe not even supported on your platform and another big thing that i would like to add and that would really improved sort of compatibility with cute is for the cubecoro task thing to be able to have to be a cue object or have some other way to do that to emit a finished signal because sometimes you may find yourself in a case where you are implementing a function you are implementing like or re-implementing some virtual function some interface that was not created by you but someone else and you can't change it maybe it's a q abstract item model right and you're implementing data and here you would normally you would say oh it would be amazing if i could just co-await some you know like database fetch or whatnot but you can't right because q abstracted model data is not core routine you can't use call way there because the return type is q variant not choro task variant or something so in those cases i would like to have some way where you can use the standard old-school cute style of simply connecting a signal to a connecting slot to some like finished signal of the task object the object returned from the core team and then your slot would get invoked later on this so far i wasn't able to get it work so but this is something i would like to see because really it would allow using qcoro even in code bases that are absolutely not ready for this or a third part or integrating right with third-party libraries and so on another thing that i started sort of digging into is truly asynchronous and file and directory operations so right now q file and q direct queue data and the queue like qdr iterator and queue file info and all those classes they they do support you know file access but it's all synchronous right so if you if you for instance do like listing a large directory it will simply block so you have to figure out like okay am i going to work with big directories maybe i need to put the whole thing into a separate thread just so that my ui doesn't block while i'm listing all the files so i would like to have a an api which will be inspired by q file and q there and but it will be purely cucuru specific and it will be purely using coroutines and probably some asynchronous methods or some asynchronous uh operating system apis like on windows there's a great asynchronous api for for file access on linux there's no iou ring as well so i would like to use those to make sure that to avoid those blocking cisco's for instance as well and yeah i'm always open to receiving more ideas like which what could be turned into a current you know next so that's that from me hope it made some sense to you if you have any questions i'm happy to answer them thank you daniel for your nice talk there's a one question on a q a if you have more questions please write a question down and we will try to answer them here after the q a there will be a meet up in the lounge for track c so you can interact with daniel again so the first question is my understanding of is from kai a song my understanding is that when using this approach the core weight needs to be in the top level function of the core routine is if this is correct what is your approach for more complicated examples you would want to suspend a function called from the co routine well the co-way needs to be everywhere where you want to wait for a result of recording so if you have a coroutine that does something and you want its result you have to go wait it and then likely your function will have some result that caller of your function will also want to consume so the caller will have to call wait on it on your function and then this chains up up to the point in the for instance event loop which just just ignores the result it doesn't co-weight i i hope i understand that your question correctly that that's what you ask you don't need to co-weight all the way up to the event loop in theory you could co-weight you you you could decide not to await a particular routine but then you won't get the result of that corrupting right you will not be able to retrieve it and i'm actually not sure if that would work well with cucuru if the caller gets terminated before the all the nested coroutines are finished yeah usually the routine starts off in a suspended state or is suspended at any point where itself it awaits on something isn't it well okay well q-core actually the way it's done is the the current theme gets i think it gets resumed at the beginning automatically okay so i don't see any more questions it seems that twitter handles seems to be not correct on your sites how do i have my own twitter name wrong yeah probably thank you okay what's your actual twitter name i suppose it's don vravio then see i don't even know my own twitter name okay thanks again and let's meet on the in the lounge for track c and then discuss core routines with qt if you want thank you for attention see you at the launch bye bye