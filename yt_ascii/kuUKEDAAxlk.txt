i already turned off alerts okay i'm like a genius i'm an effing genius these days why it's necessary to shoot yourself in the foot without shooting yourself in the foot learning lacks motivation complexity without reason is really confusing i'm very excited about this this is my big worry about ai this is my big worry about chad gpt this is my big worry about a lot of a lot of these future texts which is okay i'm gonna give you my hypothesis of the world so i hope you're ready which is that experts who use ai will become even more experts novices who use ai will remain novices i think the only thing these ai things will do is make the gap the moat wider on experts it's not going to make it smaller that's my personal opinion pig is one of the biggest ways you become an expert is by doing something wrong and doing it over and over again and you have to do it wrong enough times that you see the right way to do something if you don't know how these things work if if you don't have the deep understanding you start you slowly lose it it's harder to bridge that gap and the gap just gets wider and wider that's like it's one of the reasons why i have problem with all the abstraction that we do today in modern web development is that it's really good it makes really amazing things and it's awesome that i don't have to think about deployment and all this kind of stuff and there's a lot of cool stuff about serverless that i really really like blah blah blah blah blah but in the end at the end of the day if you don't know how it works that moat is wide do you need to know how it works no you can be successful without ever knowing how it works but you will always have this huge knowledge gap which costs right it always will cost when a problem comes up right it just does the way i think i like this the level of novices will increase though they will be able to solve problems they could not before but improving this approach is hard but that's the problem is if you solve levels you are not meant to solve at your skill level you may be able to solve it but what is your debug time do you rely on the same tool that produce the buggy code to learn how to solve it and then you just you're never doing that exercise you know how many like you know how much intuition i've built up from just debugging all right i can see something that's gone wrong i can think of an error i can put one or two print statements and i can determine what happened to an entire system because i just have such a good intuition about it because of years of debugging anyways i hope that this is what this article is about i really do hope that this is what this is you know what i mean at the recurse center february 2020 i watched a talk during present let's see i watched a talk during presentations about someone optimizing a database engine it was really complicated and i remembered nothing about the talk itself what i do remember is thinking to myself this seems really complicated for no good reason keep in mind i had never made a web application at the time and when i needed to store data i just used a csv file or a python pickle file on the disk this is a great recognition of your own shortcomings i thought a file system was sufficient for storing data fast forward a few months i'm building my first web application i don't remember what it was for but i remember using a csv file as a database i had to load the file into memory every time i wanted to look up something look something up and it was a big pain i now understood why using a database is and sometimes a good idea this is also me this is me learning this is me learning to a t which is that like for me to discover something as good or to discover something as bad has almost universally always been me doing something that should not have been done a certain way and i learned why it is whereas if i just read why you should do something optimized it doesn't like set into my heart do you understand like it doesn't mean the same thing if i don't under i don't understand the the principles behind it you know what i mean i feel personally called out yeah learning rust july 2020. i started learning about the borrow checker it prevents you from keeping a pointer to an item of a vector yep if you pass the vectee as a mute i don't really get why this is necessary i have never done low-level programming before i have never used pointers and now i'm being told that following the borrow checker is safe it's still very confusing to me this is this is great this is great fast forward when i'm hey if you're following me and i'm causing you to learn zig and rust i'm very sorry fast forward to when i'm writing zig code i take arraylist item appended to arraylist and then i try to write to the stored pointer i get a seg fault ah now i get the problem rust solves i love this this is such a good article this is exactly what so many people need to have and it's one of the problems why if you don't ever do c i feel like some of the things that are really nice about zig are lost on you right if you've never done you know certain languages it's just you your brain can't think in a certain way until it sees a different perspective it's very interesting learning view july 2020 why are all those complicated ways to represent state shouldn't developing a web app be simpler than this after writing a bunch of vanilla.js i can see why these frameworks could be useful i could never made a very big web app but i could see that keeping track of state and what is or isn't rendered is hard and it gets much harder with a bigger web app absolutely to fully understand a best practice or why something is necessary it's important to experience how things go wrong without it yes when teaching programming we should let people make these mistakes and then show them the tools to correct them absolutely this is why like this is why one of my big things is is that go to advent of code learn a new language learn just a little bit about the language just enough to solve one problem and then try to solve the next problem with just your little bit of knowledge and you're going to run into all these weird things you're going to do a whole bunch of weird stuff and you're gonna be like man this is difficult to do this i can't express that i don't really like this oh man oh camel kind of sucks for these reasons and then you go and read the docs for a second go whoa look at that i love this i love that oh my goodness and then you go back and you solve that problem that you just kind of struggled on and it's like instantly easy and instead of understanding here you understand here and that's like the big difference that's what makes a really great programmers when you understand it in the heart right you understand it at a fundamental level that's just different than going oh you should always use enums because they are heterogeneous right understanding in the nipples right in the nipples just giving someone a complicated tool without a salient reason to explain its complexity will just make them really confused some opinions you should store stuff in csv files before using before using a database you should learn zig or c before you learn rust you should write a web app in vanilla js before you learn a framework you should write a game from scratch before using unity you should use java c from the command line before using an ide these are actually really these i mean i say a lot of very similar things a lot of areas i may not say java c because i i don't recommend using java but use vin right learn how your thing works learn how your environment works then go back to the idea if you want to totally cool know what's said awk and jq2 learn grep x arcs parallel learn just a couple of them because like parallel is one of the greatest tools ever and if you don't know parallel you're an ignorant like it you have no idea how good parallel is it solves an incredible amount of your things that suck like it's just an incredible amount of things anyways if you had an experience like this email the email this guy right here oh dude that is such a bold statement to put your email out but hey i love it jacob this was an amazing article this was perfectly written it was it was right to the point and it really just shows how someone learns doing the wrong thing doing the right thing at the right scale until that scale changes or the problem changes can instantly become the wrong thing and you will know why and you'll understand deep down why it's wrong love it examples on why use parallel okay here's an example for you i have a i have a program that has to go fetch data and i can't do massive joins like i have to use like a rest api to go get a bunch of stuff and it's just not available for me to do it and so i and i have a max number of parallel requests one can make and so what i did is i created a program that reads in from the standard in every single line that comes in is a json object it decodes the objects builds out the query sends it out to the rest api and now i can say hey parallel give me four running parallels and run them all together then all the output goes to the next file so i can stage all my changes so that way it's running as efficiently as possible and i don't write some stupid multi-threaded application i rate the world's dumbest script to go and get this thing done and it just does everything for me now the nice parts with with canoe gnu parallel is you can do the same thing except for if you're doing something with the file system you're doing searching you're doing replacing you're going through big files you're doing jq you're doing whatever whatever you want to do you can make it parallel and then make all the output joined back together on standard in or standard out it's beautiful it's truly a great it's a it's a great design gnu parallel it's very very good but it's one of these things that you don't know you need it until you know you need it i'm over here i'm over here writing these really really complex dumb articles or i mean these dumb scripts that are like multi-threaded and doing stuff and that's not what i want to do right i want to write a simple script and then have something that is designed to do it for me right it's glorious the name is i do appreciate some aspects of the unix philosophy again