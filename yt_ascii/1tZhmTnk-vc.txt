so i've been writing my own operating system and when it's done this little r toss should enable multitasking on the stm32 blue pill but when i was on twitch designing this os i had a hard time thinking how am i going to do task synchronization for those of you that don't know task synchronization is the computer science problem of synchronizing the execution of two tasks or threads that use the same global data to prevent data corruption or misinterpretation so for example if i have two threads thread a and b and the task of both threads is the same to print global counters and then decrement them this will create a synchronization problem the problem is that while the counter lives in global shared memory when thread a goes to retrieve the counter from memory and printed thread b may have already decremented the counter but hasn't had time to store it back into memory this condition known as a race condition is what task synchronization fixes an easy way to do task synchronization for example is using a mutex or a mutual exclusion object think of a mutex as a talking stick if our previous example had a mutex then when thread a locked the mutex only thread a could access the counter to print it and decrement it in c the way you use a mutex is actually pretty simple create a mutex structure globally initialize it with the p thread mutex init function and then when you want to block a piece of code to only be executed by one thread at a time lock that thread using the p thread mutex lock function then when the critical part of code is over unlock it pretty straightforward but this got me thinking how does a mutex even work how would i implement a mutex in my operating system doesn't multiple threads trying to access a single mutex also create a race condition couldn't two threads accidentally acquire the same mutex in a race condition at the same time the way this all works actually really cool all the mutex is at the end of the day is an integer value in global memory when it's initialized a mutex is set to the number one and just floating in the ether the interesting part then is how you interface with the mutex like i said before if the mutex were just the number one then two threads interacting with it could naturally create a race condition this is where the idea of atomic operations comes in atomic operations are instructions within the processor that are impossible to interrupt in intel assembly for example the lock prefix tells the processor to execute an instruction atomically meaning no one is able to access the memory targeted by the instruction until the instruction completes execution so how does this matter for mutexes remember how i said before that mutexes were just a global integer value this is still true a mutax is just a value zero or one that indicates to the thread if the lock has been acquired or not here is an example assembly snippet of how you could do a lock and mips assembly here we load the lock into a temporary register if it's one we continue to spin until it's not locked then we can access it or if it's zero we lock the mutex and continue on with our day but like i said before this inherently is vulnerable to a race condition what if two threads try to lock a mutex at the same time and race on the access to that lock again this is where atomic operations will save the day in this correct mips implementation of a mutex we load two values into temporary registers a locked and an unlocked state using the atomic mips operation compare and swap we can atomically in one instruction compare the unlocked value to the lock and if it succeeds it swaps it into t1 once we compare that value of the output we can fall through to our critical code section in the case that it is not locked already we then have to loop around in the case that it is previously locked we loop to the top of the function and wait for it to not be locked and then now using this atomic lock we can create our own mutex implementation in assembly that we can use in our os that's all for now guys thanks for watching i hope you enjoyed be sure to like and subscribe and i'll see you in the next video take care [music]