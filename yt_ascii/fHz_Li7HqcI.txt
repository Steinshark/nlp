as computers have evolved to have more cores with more threads of execution concurrency has become an extremely important topic in programming how can my program use all processing power available while performing computationally intensive algorithms while most languages have easy to use multi-threading libraries available that allow you to spawn additional threads with only a few lines of code the difficult part in concurrency is multiple accesses to a singular data location at the same time if not properly designed multiple threads accessing the same data location can create what is known as a race condition where the logic of your algorithm is a function of who gets there first race conditions can cause your program to have poor performance broken functionality or just straight up crash safe multi-threaded concurrency in rust is very similar to other languages but there is a catch that we'll get to at the end of the video step one just like in c or python we need to import or include the standard thread library now we make a vector or a list that tracks all of the handles to threads that we create with our code so that we can close them in the future in this program we're going to spawn 10 threads so we make a for loop from 0 to 10. and then here we spawn a thread using the standard thread library we use a rust move closure to pass all variables into the code by value and then the code on line 8 will be executed in a separate thread this line adds the newly created thread handle to our list of handles so we can join all the threads later on we call join on all of our handles wait for them to finish executing and then return great so now our code is multithreaded that seems easy enough what's the catch let's take it up a notch in this program we'll have an integer value that each thread is responsible for incrementing by one so at the end of the program the value of this number should be 10. to do this safely and correctly we'll need to use a mutex a mutex is an object that is used to ensure mutual exclusion meaning that only one thread has access to a resource at any given time here we'll create the mutex with the integer value 0 as the controlled resource normally in other languages like c or python mutexes are just a lock object and then the resource that is controlled is handled separately in rust mutexes actually contain the locked object here we ask for an exclusive reference to the integer from the mutex and then use that reference to increment the integer by one but the real question is does this compile and the answer is nope it doesn't this is where rusk gets a little funky when it comes to mutexes in thread objects what's happening here may not be obvious because we're in a move closure meaning all values are passed by value the mutex is told to invoke a copy trait of itself which it does not implement this causes our lock call to be unreachable and ultimately fail the compilation and that's the catch in multi-threaded rust programming we can't use the mutex on its own instead we need to wrap the mutex in what is known as a reference structure that can be passed by value into our movement closure to do this we'll include the atomic reference counted or arc from the standard sync library and use it to reference our mutex next we'll use the arc to clone a reference to our mutex which will get moved by value into our move closure moving the reference by value still appears like a mutex and allows the mutex's lock function to get called but the million dollar question still remains does it compile and would you look at that it does compile our multi-threaded code increments that integer value up to 10 doing it in a multi-threaded way anyway guys thanks for watching i really appreciate it if you like this video or if you learned something do me a favor hit like hit subscribe leave a comment down below and we'll see you guys in the next video take care [music]