so go is a very very simple game in terms of the rules but it's very difficult computationally there's an enormous depth of complexity that comes out of the very simple rules which is i think part of what makes people love it so much as a game so to understand why it's hard for computers i guess you have to go back a whole bunch and talk about just how computers play games in general these sort of turn b strategy games or that kind of thing and start with something easy like ns and crosses for the sake of internationalization yes tic-tac-toe i like n and crosses as a name because it's descriptive you know but whatever yeah we're going to look at ns and crosses as a game and i'm going to keep calling it that i apologize but you don't have to apologize i just i just want to make sure people people understand what we're talking about right right right right that's all so i'm talking about this game where you draw your octa thorp and then one person you know goes here and one person goes there and so on and you alternate placing ns and crosses and you have to get three in a row to explain ns and crosses we should play an even simpler game so the idea of the game is we're going to take it in turns to choose left or right and i'm going to try and get the highest number possible and you're going to try and get the lowest number possible it starts off my turn so if i choose left for example it goes down to here and then it's your turn and you get to choose left or right and then which number it ends up on is the outcome of the game so i want the highest number possible which is seven you want the lowest number possible which is one failing that i'd prefer the five to the three this is a perfect information game what's the difference what's what's an imperfect information right right so so a perfect information game is just a game where all of the players have all of the relevant information so this is like that knots and crosses is like that chess go these sorts of games you do get games that are not like that for example poker there's hidden information you can't see each other's hands so you have to if you want to write something that's going to play those types of games obviously it has to work differently to take into account that uncertainty the question is should i choose left or right and how do i make a principled decision now i want the seven so in principle i should be going this way right you would think i want to steer towards the seven but on the other hand at this point it's your choice you're not going to choose the seven cuz i know you want the low number you're going to choose the one so if i'm choosing this node i'm effectively choosing the one cuz i can predict you'll do that whereas if i choose the right then your choice is between a three and a five so you are going to choose the three which is better than the one so i should go right i'm trying to maximize the minimum value y i'm trying to make it so that the best choice available to you is as bad as possible for you and as good as possible for me so this is this is called minimax because i'm trying to minimize the ma you're trying to minimize the maximum i'm trying to maximize the minimum if you see what i mean yeah and then purely based upon who goes first as to who wins this right right yeah this is absolutely unfair game yeah i started off saying i want the i want the seven so maybe i should go left to get the seven right that's one thing i could look for the highest possible payoff and try and steer towards it that seems like a reasonable way of playing the game not on something this simple where you can see it obviously fails but in a more complex game you might think that look for the best outcome and try and steer towards it y but you've got to bear in mind that your opponent is steering away from it or i could look at it and say ah that's the one i definitely want to avoid the one so i can't possibly steer left i'm trying to avoid the bad outcome so i should go right or you could look at it and say okay how about this entire tree what's the average here what's the average goodness of steering left or right if you take an average on 7 and one yep ob get you get four four cuz that's plus eight if you take the average of three and five you also get four so in this case they're the same does that mean they're both equally good well no cuz one of them end up with a one and one of them end up with a three so so we're basically saying here okay there are different ways to evaluate the choices that you make yep and most of them don't work most of them aren't any good okay but there is one way that works which is basically what we did which is minax and so it's a recursive function so let's try try a more complicated game i'm going to generate some random numbers just using python to get us a list and then shuffle that list and there it is so i'm just going to draw the tree in before it was obvious that i kind of designed those choices to make a point here it's random so it's a real game now in many ways a better game than ns and crosses because somebody's can actually win probably whenever you see a tree in computer science you should always kind of be thinking about recursion which you've done a video on before right so people i dive back into this same piece of code because a tree has this kind of fractal structure where ideally you want to have an algorithm where you do the same thing at every part of the tree and then you can have one algorithm that processes the whole tree so the problem with recursion a problem with recursion is infinite recursion where you have this sort of loop of nested stuff that never ends you need a degenerate case you need a case where the answer is easy and in this case it's the bottom right so if we are at the bottom first move by the maximizing player second move by the minimizing player third move by the maximizing player so here which way should i go i should go with whichever one is bigger it's the seven right so we can effectively call call this a seven it's not the end of the game but the value of this node is effectively seven because if this player directs us to there the game will end with a seven so you can do that in each case so this one is a five because that's the bigger one this one is a three and this one it's the six so now these nodes which before you couldn't do because they didn't have any values now these look a lot like the nodes below so here now we're being the minimizing player so this will be a five and this will be a three and now we're being the maximizing player again who wants to go for the five so you can see here that as the maximizing player the best score i can get is the five that's assuming that we're all playing by the same decision making structure right it helps that it's the optimal decision- making structure in this situation okay but you don't have to make the best choice right if you make a mistake i have values on all the other nodes of the tree i can make probably do even better but the way that minmax works is you end up with the making the best possible play you could make as bad as possible and you're trying to do the same to me this is a game you can play with your friends it's a it's a huge fun for everyone if you can do minmax in your head and obviously if you have you can put 16 numbers at the bottom 32 whatever but you'll notice of course the more numbers you have at the bottom the more work you've got to do to figure out all of these inter intervening nodes and it's tractable for some real games that people play like ns and crosses so i could i i'm going to try it so you take a game like n and crosses tto which is so simple that human beings reliably learn to play it optimally you start off at the beginning your norts you have nine choices right because you can go 1 2 3 4 5 six 7even 8 n those are your options now it's the crosses turn and there you have eight options because one of the squares is taken so 1 2 3 4 5 6 7 eight and here there's eight and you see just quickly this becomes ridiculous but no game of knots and crosses lasts more than 9 turns guaranteed you run out of spaces we go along blah i'm only going to fill in part of the tree now the point is what's the degenerate case because we're not trying to get numbers so what you do is you say this isn't going to be right but let's just say as an example for a moment yes that it's that so it's a win for norts so if we're playing norts we give this board a score of one cuz we say one we've won excellent a different board where the crosses have a win that's a minus one cuz i really don't want that and then any state where the game is over but nobody's won it's surprisingly difficult i accidentally won it this is how hard this game is there what what can i do all i do is win so so okay assume that that's a draw yeah that's a draw so that's a zero if it's your turn and you have a move that can win then that board state is a win and therefore you just propagate that up indefinitely exactly the same way as you would before yeah so you can see how you can plot this out and it's much too big to actually do but if you write a computer program to do it it's not difficult it's a short program it doesn't take long to run and n and crosses is a solved game right so let's draw the thing for chess how much paper have we got yeah that's draw chess okay yeah i'm not going to draw chess why are you not going to draw chess well you know it can't be that much more difficult com yeah so we need more paper we need a lot more paper to draw chess and the issue is the thing the thing you can see the the thing that's so different here between the simple game the very simple game and ns and crosses is this thing called branching factor which is basically at each little node how many branches does the tree have simple in this game it's two here we have two choices here we have two choices here we have two choices you always have two choices this is a longer game it has more turns but the branching factor is still two every turn you have two choices you can make in ns and crosses okay firstly it's more complicated because the branching factor is higher secondly it's complicated because it changes in the first turn you have nine choices the second turn you have eight and so on so the branching factor actually reduces as the game goes on which is one of the things that makes it easier to compute so let's think about it let's think about chess then in chess the very beginning let's say your white you're about to start you've got eight pawns you could move you can move them forward one so that's eight possibilities or you could move it forward two so that's 16 plus you have two knights that are allowed to move because they can jump so each of those has two it's another four i think it's 20 don't really play chess but i think i think it's 20 i think you start off with 20 so i would be drawing 1 2 3 4 5 6 7 8 9 10 11 12 all the way up to 20 and then as the game goes on much like in ns and crosses the number of possible moves available to you legal moves varies right so presumably first it goes up yeah as the game opens up early on you get more moves available because you've got sort of more space and things can things can move to several different you know positions and all that kind of thing and then past a certain point it starts to go down again because pieces get captured and when obviously when you have only a few pieces on the board you don't have as many moves available to you but on average when people play chess i think the average branching factor is about 35 but chess games generally go longer than nine turns right so when you're calculating the number of no in your tree every turn you're multiplying by the branching factor and that quickly gets completely unmanageable so you can't just min max on chess like it's it's computationally completely infeasible which is why chess was considered such a big milestone for a long time if you could make a computer that could play chess you know you're not just doing this very trivial brute forcing thing like you're doing for ns and classes you oh if a computer could play chess it would really have to be thinking right you can see how here we were taking the end states where we knew the value of the game and then propagating backwards in time from there to give value to these board states that we didn't know the value of before the problem is there you have to go right from the very end of the game which in chess you you can't do there's there just too many possibilities so you need some way of giving boards values that isn't just propagating backwards from the the possibilities from known and you know checkmate states and luckily in chess there's a lot of things you can do about that the most obvious one is just counting up the pieces you just say well a porn is worth you know one point and the queen is worth nine you do some analysis of how games tend to go and you you try and figure out how good the pieces you have left are basically and the position of them obviously is important but you can get a good it's a good istic it's a good approximation to just add up the the scores of the pieces and say well you know this team has both their knights and still has their queen and this this only has one knight and is lost their queen so it's really obvious that this team is winning and therefore that's a good state of the board and you don't need to be able to see all the way to the end game to know that it's a good state to the board so the point is because chess's branching factor is so much higher you can't do this thing where you work backwards from the end states the branching factor is too high you have to start from where you are and look forwards and say okay hypothetically if i went this way what would that look like what boards would that allow me to get to and then if from there i went here how would that look and so on you don't know whether you're heading towards a win or not and this is where the heuristics come in is that they let you put some kind of numbers on these nodes like you know do i still have my queen in this node and that should guide you towards winning positions because there tend to be more winning positions in situations where you have your queen but it's always a heuristic you they're not the the chess a is not seeing forwards in time to a win they're seeing forwards a certain distance and seeing that it's a good position to be in according to and it obviously it's not just what they have on the board like that's an oversimplification there's a lot of different heuristics but the point is you're going to have to evaluate a very very large number of boards so you want something you can compute quickly because the more boards you can evaluate the further ahead you can look and therefore the better you can play even in this game if you're playing with someone and you can think more moves ahead than them that gives you a huge advantage because you can force them into a into a situation where the best move available to them is quite bad and they didn't think to steer away from that because they didn't look as far ahead as you what this number means is if i go here and then play perfectly from that point on what's the worst score i'd end up getting this algorithm assumes that your opponent is always going to play the best move that's available to them because you're always prepared for the worst possible scenario so you're only ever pleasantly surprised chess is a different ball game it's got more complicated maneuvers it's got different ways of branching as well as larger branches so how does this all feed back into our original point of go looks pretty straightforward to me right okay go right let's draw a go okay we're going to need more paper and a significantly larger universe to put that paper in go is difficult for a lot of reasons actually the first reason that makes go difficult is the branching factor is very high it's generally more than 200 compared to chess's 35 so every turn there are at least 200 possible moves you could be making and so if you imagine me drawing this tree with 200 come on then let's draw it let's do it 200 one going to i'm going to run out of pen 2 3 4 i'm going to go in between 5 6 7 39 40 41 i think life's too short rob yeah no you're right yeah this margin is too too narrow to contain so it's not going to happen right it's not going to happen and what's more or even you know it wasn't going to happen with kns and crosses but you can do it in a computer you can't do that with go you can't do that with chess even and you really can't do it with go and so even a lot of the cleverness of tree search and like pruning and all of the really neat algorithmic improvements people have made for ways of navigating these trees that allow this type of oldfashioned ai to to be extremely good at playing chess better than any human at this point that approach is not going to work with go and was never going to work with go and so go became the great oh my god past tense go became the great the great milestone right after chess go was the big one so right we we're going with why why is it so hard the branching factor is huge that's one thing but also you don't have a lot of the tricks that you have with chess you can glance at a chessboard as i said and just add up the pieces and say well this you know white is probably winning or black is probably winning in go that's not the case in the middle of a game of go between two good players other good players could not necessarily tell you who's winning right now because the specifics of who's winning depends very sensitively on the precise layout of the pieces it's not just a matter of who has more stones on the board or who has more territory or who has more points or anything like that it's sort of an emergent property of the pattern of the layout which means you don't have these easy shortcuts you can use to evaluate a position not only are there 10 times as many possibilities to search there's no obvious way to even tell if a if a position is good once once you're looking at it which is well this is why this is so impressive what's been achieved by alpha go to beat the best human players at a game where all of the standard tricks of the trade won't work and you have to really try something new head mounted display that tracks where you're looking and various other things so it overlays and this can represent the other paddle so we got two objects with the identical interface is want to represent the