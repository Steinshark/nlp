on developer voices today we're going to be looking at another one of those programming languages that all the cool people seem to be talking about these days it's kotlin so if you're a java programmer or you work on the jvm in some fashion you probably haven't escaped the buzz about kotlin but what i hadn't realized is how much further kotlin reaches these days it's not just a jvm language anymore it's making a really serious attempt to be the one language that you write and then run everywhere so it can take you to the back end and the front end a mobile and even embedded devices i think that's really appealing right once run everywhere it's always been appealing if it actually works and if kotlin is a nice language to write in in the first place so i've brought in an expert to discuss it coming direct from google we have james ward he's a product manager for kotlin at google he's a clear fan of the language and we're going to talk about why he's a fan what kotlin has to offer what's its focus what's it trying to be as a language and then how does this promise of getting you onto every platform actually work in practice and what happens when it breaks down when inevitably this attempt to treat all platforms is the same breaks down does it have a way of handling that well i've got to say james has some good answers some good reasons to believe that it will work and so we get right down into the weeds about it and kick the tires as much as we can in a podcast format and just to cap things off we recorded this podcast just as google i o was happening so he gives us a sneak peek into the future of kotlin where it's trying to go next so if the promise of writing one thing everywhere all at once appeals let's get stuck in i'm your host chris jenkins this is developer voices and today's voice is james ward [music] joining me today it's james ward james how are you today good thanks for having me chris great to see you again great to have you i haven't seen you in a little while i so i've brought you in to talk about kotlin which i know you could talk about forever but before we even get there i have i've got to ask you about your job title yes because you are product manager for kotlin at google yep kotlin isn't a google product so what's that all about yeah so over five years ago the android team i think so five years ago went kotlin first and this was really driven by the developer community around android they started doing kotlin kind of on their own and they're like hey this is this is pretty cool we we really like this language and what if android made that kind of the default and and so they announced tape we're kotlin first java is still supported on android but colin is the primary programming language and so that kind of set off a chain of events the the founding of the kotlin foundation with jet brands and google and and so yeah in in many ways google is is now incredibly involved in kotlin's development and and some of that is driven for android but also google has been using kotlin on the server side it and so now there's there's much more interest in how just google engineering uses kotlin and so they're getting more involved as well that's interesting because i always remember google as being the place that had c java python and go away those are the only three i think they've actually been swayed by users into changing that way yeah yeah i mean there's so many great language features in kotlin that help with ui development and make the programming model so much better and so see i think it makes sense and and the reception from the community has been incredibly positive around using kotlin for android and and so yeah it's you know it's it's cool that that this this great new modern language has has been able to to grow kind of organically in the android community and google as a whole so yeah so i'm product manager for kotlin which means that i get to help grow kotlin on the android side but then i also work internally with our engineering teams and their use of kotlin and doing a lot of things to keep in sync with jet brands and all the great stuff they're doing around kotlin and and then working on we we have a number of engineers working on the kotlin compiler itself there's a big compiler rewrite happening in kotlin and so we're working on that and then android studio will eventually use that new new kotlin compiler which is faster and better and more integratable and just a better foundation for the future so yeah just helping coordinate all the stuff so you're not too busy there's a lot going on and you know we just had we just had kotlin conf a month ago and had a bunch of stuff going on there and then had google i o this week a bunch of great kotlin stuff we talked about there and so so yeah just all sorts of good kotlin stuff happening around google well we should get to the we should get to what's new in kotlin maybe we should we are with what kotlin actually is do you have an elevator that's a good idea yeah good how would you characterize it in the landscape of languages yeah so i think there's a few things that stand out for me one is that it's it's a modern language it doesn't have the baggage of other language you know as languages evolve it gets harder for them to evolve because they don't want to break a bunch of stuff you know and there's different approaches to this i've as as you and i have talked about in the past i have done a lot of scala and i i think scala is a great language and it continues to evolve at a pretty rapid pace but one of the challenges with that is like how do you bring the community of users along with you into those new evolutions and so cotton three i think or sorry scala 3 has been out for a couple of years now and the adoption has been i think challenging because there are a number of pieces that have to move along for people to be able to adopt it they have to you know make potentially make code changes to adopt the new language they have to get the libraries that they're using compile their plugin and macros like there's just this giant ecosystem around language obviously like that's what you want and a language is a big ecosystem around it but how do you then evolve a language and bring that whole ecosystem with you and i'd say that generally a scholars had had some challenges around that whereas kotlin being i think it's like 10 years old now so relatively speaking for languages not super old and so bringing that ecosystem along doesn't maybe have all the challenges that that other languages have and then there is a a strong focus on on helping helping the developers and the ecosystem move to new versions and so i i don't i'm trying to think if there's like breaking been many breaking changes in the language and library compatibility issues like don't seem to be as prevalent in the kotlin space so the new compiler that is being worked on one of the big focuses of that new compiler is for most users to move to the new compiler they shouldn't have to change anything and so that's just one way to like all right can we replace the whole compiler underneath everyone with something new without them having to really be impacted by that change and yeah that's that's a huge challenge and takes a lot of engineering effort i'm thinking of scholar 3 which handled that fairly badly i'm gonna say yeah handled that pretty well going to python 3 and that was still a lot of work the the transition to python 3 was was i think also very challenging there was a few things that that required some significant changes in the ecosystem so the python 3 transition from what i know of it did take quite a lot of effort to to get that ecosystem moved now it's firmly moved and that's that's all great but scala 3 has not yet kind of reached that that kind of mass migration point yeah and so there's been some challenges there but i love scale of three that i'm using it a bunch of projects and and you know there's a lot of really good language features in there but yeah bringing the ecosystem along has been been more challenging but anyways back to kotlin there's we're allowed to talk languages on this podcast yeah awesome so so kotlin has has some great language features that lead to better productivity better reliability so just things like null safety being built into the language like i think that's kind of becoming an obvious default for programming languages these days yeah i really hope so yes but that's something that leads to fewer production issues for for people that are using it and and then language features like there's a nice dsl style way to to use a it's called lambda with receiver pattern that leads to a nice looking dsl if you in places where you want to have more of a dsl look to your code then you can use language features to do that things like callbacks there's a nice syntax for that which when you're doing ui programming called callback style programming is is an important piece and so yeah being able to have kind of language support for that is has been useful case classes to define your your data objects has been you know a feature that people really like co-routines is one of the big kind of headline features of kotlin which makes the async programming much more straightforward so yeah i think there's there's a type inference there's a number of language features that just make it a good modern productive language and then of course colin coming out of jet brands has a core focus of the language has been around ide support and so being able to have great id support that that is continuing continually evolving with the language has been important is that like a double-edged sword though because i know if you so coming from jet brands if you use intellij it has fantastic id support if you don't not so much right yeah i mean jeff bran's focus is definitely on their tooling and so so the best kotlin tooling is in intellij on android studio you can use vs code and there is a lsp for kotlin but because it's not core developed by the kotlin team yeah i think that there's some some lackings there if you want to be in vs code or any chance of google taking on the lsp plug-in hey you know google it's a good question google doing because google's doing a lot of kotlin development internally a lot of a lot of the engineers at google are using using cloud i think we just hit 15 million lines of kotlin code in the mono repo at google so quite a bit of of kotlin code there but google has its own tooling internally that that it uses and the for the mono repo in google there you have to take a bit of a different approach to how you do code intelligence and and understanding code and so so for for google's internal uses the the lsp doesn't necessarily make sense and so yeah i don't know what the how the future will will play out and then also like jet brands is a partner in all this so we want to make sure that jet brands is is successful so that bread is butted by having the ide of the world-class idea yeah exactly so so yeah not sure what the the future of that is i think generally for a lot of the stuff around kotlin there there is a focus on growing the ecosystem and as part of that there's no reason why third-party developers can't can't build these tools and and use them and and so yeah i think that as the ecosystem grows the language support for other ids will will certainly grow but yeah in terms of jet brands and google don't know if there will be specific investments into into alternative ideas okay okay while i wait for a more up-to-date lsp plug-in you can have to persuade me this language is so great that i should switch to jetbrite and so android studio yeah and if you're if you're doing kotlin i'd highly recommend that you use intelligent or android studio you're going to have your best experience there and so yeah that's that's a i think that's and i'm a long time intellij fan and user and so for me that's not an issue for for other people that may be from more familiar with other tools and so yeah but but for me that i love intellij so okay okay it's it's nearly as good as emacs i'll give you that okay so let's get into some of these better i'm a long time vi user so so i'm you know it's i i don't often edit code in vi anymore i'm pretty exclusively editing code and intellij yeah yeah it's it used to be like this classic war between vi and amex and now we realize we're both basically on the same side against the against if that's the word against the ides of this world well you can you can plug in the lsps and to via an emacs yeah so yeah that's why i need yeah yeah and i you know it is a community project around the lsp so hopefully that continues to evolve and yeah the community drives up more okay persuade me over to this other ide to persuade me to the dark side what let's talk about some of these language features and see what's good about them so the co-routines i know you're excited about incotman yeah yeah so we often in a ui program or on the server side you've got something async that you need to deal with and that's oftentimes related to io right your your firing off you know request to a server and then you don't want to block the thread while you're waiting for that to come back especially when you're on the ui you don't want to block the main ui thread because then the user you know their their ui is no longer responsive so yeah freeze while you do an http request that kind of thing exactly yeah yeah and on the server side it's the the most efficient way that you can use your resources in a in a system that has async calls i o calls is to not block those threads and so so definitely on the server side it also is important to be non-blocking on on io and so the in the world of kotlin you can use co-routines to do this and co-routines give you a i'm sure many developers now are familiar with async await style syntax where you can you can basically declare that this thing is async and then in kotlin underneath the covers that gets unrolled into the right like callbacks and and non-blocking stuff that you need but the programming model on kotlin is is nice you just if you call something that is a suspend function then you can on the next line of code use the result from what you get back but underneath the covers it ends up being actually async so it looks imperative do this do this do this but then it gets unrolled unrolled underneath the covers into the proper async constructs there so and the nice thing about co-routines is that it's it's a language feature with a supporting library and so so you can anywhere that kotlin works you can use co-routine so kotlin coming out of the the java jvm space certainly you can do this on on the jvm there are some alternatives we can talk about on the jvm that are upcoming loom but but the nice thing is is that places where you maybe don't have that loom style or loom capabilities like on android or there's now many other places where you can run kotlin you can now run kotlin on ios you can run it on the web you can build desktop applications with it you can build cli's with it so any of those places now you can use co routine so you get one async construct that works on all the different platforms so we'll talk about multi-platform intermix that's another interesting oh yeah but yeah the co routines definitely a great great programming model for doing async stuff and yeah it's i think now modern languages have i think generally embraced the that style of program i mean for doing async stuff in in some way or another and so so yeah i i there's two different sides of co routines that are interesting one is the like request response style where you're you're calling an async function and get back the result but but it's async but then there's the stream oriented construct as well where it's called flow and co-routines and flow gives you the the streaming style syntax for for being able to operate on a on a something that's not just a single result but but more than one result until you get both the the stream and the the function style approach to async and it handles both in the same mechanism kind of transparently are you saying yep yeah exactly yeah you you do have a different api for the stream construct so in co routines if you call a suspend function not something that produces a single result if you do want a stream then you use the flow and with flow there's an api where you can emit things into the flow or you can then read out of the the flow and so the like the the kafka in the kafka world you use a flow to interact with kafka so you hook you get a flow interface when you're reading from kafka or a flow interface when you're riding a kafka and so that's how you then interact with the the stream oriented approaches is through the flow api yeah yeah it's it's that difference between like grabbing a single row from a database and processing an ongoing stream of stuff yeah i often think that's quite nice distinction between http and websockets say yes yeah exactly and you won't quest response or or a stream of of data yeah yeah and so the the you can use also use a flow for a websocket and so that's in websocket stuff that i've built definitely will use the interface and it's great because then you get one programming model for doing any stream oriented processing so so yeah it's whether it's a websocket or kafka or whatever you use the flow interface for that that's cool so yeah there's that's co-routines definitely one of the the really important valuable features of kotlin is having that all kind of essentially built into the language so maybe we should talk just quickly since we've mentioned websockets http and kafka what's the library support like is it mostly go out to java or is it like plenty of native support for things yeah so there's as usual in the jvm ecosystem there's a lot of different options that you could go with and so on the http side all of the major jvm http libraries that are out there now have some kotlin support in some way and so spring is spring and spring boot is really the the primary one in the jvm space and so if you are in spring and you want to do async stuff in kotlin you just use suspend functions and flows just like you normally would and those integrate directly into how spring then handles the the reactive i o underneath the covers and so for example if you want to do a websocket you can just do a flow in spring and and that'll feed the data back colin does have a like a kotlin native a native is the wrong word but a kotlin idiomatic http library called kator and similar to spring you can use kotlin flows and suspend functions and then all the other jvm major jvm frameworks have kotlin support as well and cartoon support so so in some in the traditional jvm libraries the kotlin apis are just wrapping the the java apis so there's some translation to what's happening with the covers in in java but then in ktor you can plug in different engines neti or they have their own native http library called cio and so you can exchange you can interchange the actual engine underneath the covers but but your programming model with using co-routines and flows is all the same no matter what the actual underlining engine is okay yeah so lots of different options for ohio okay and then in the world of kafka there i believe that there's now a kafka native implementation of the kafka protocol in in colin i think that it does not this particular one i'm thinking of does not actually wrap the the java api of kafka i think they they re-implemented it i might be wrong on that but but from my standpoint when i'm doing colin with kafka i don't have to know or think about the actual underlying protocol handling of that i just you know write my calling code just as i normally would with cartoons and all just work so yeah it's i have to ask myself is is there like a kafka streams wrapper that works well i haven't seen that it definitely could exist but yeah i haven't haven't seen that okay that does lead into my next question my next two questions you can tackle these in any order you like because you've hinted at both of them ffi and multi-platform because kotlin started out as a jvm alternative to java right yeah so what's the ffi like and we're not just targeting java anymore right yeah yeah take me through this yeah oh this is great yeah so in the world of of kotlin you can target multiple platforms as we mentioned and jvm was the initial one and so the the interface between kotlin and java is bi-directional works great so you can you can interoperate with java could seamlessly in both directions and that's been an important focus for for colin is to allow that there's a lot of mixed java and kotlin code bases in android and on servers and so having that interoperability is has been has been essential and all works great outside of the jvm the the approach has has been similar in that that kotlin has made sure that the integration with the the native platform works really well and so that's the the ffi piece and so it's different how it actually works is different for for each platform but the the goal is to be able to have great interoperability no matter what platform you're on so if you're doing kotlin for ios then that actually compiles down into objective-c byte code and so you're you're running in process in your ios app you're not running in a sub process so there are other multi-platform technologies that that just essentially like vm your your your app and so you're running in a sub process and then ffi gets more challenging and because then you have to bridge some way between that kind of sub process to to the main process and it's not a native integration and so yeah that's sticky yeah there's you know performance challenges to that and then there's just like a lot of times you are in a mix code base so on in the world of ios you likely do want to take advantage of a lot of native ios functionality and then the world of kotlin on ios it's it's because it's just objective-c byte code that interop is direct and so there's there's definitely challenges to how that gets implemented because on the kotlin side you have to have a garbage collector and be able to like manage references you know across the those boundaries and still handle garbage collection correctly and so the kotlin native team is the one that that has has done all this work you know they've they've made sure that that garbage collector works well on ios and on other platforms they have been working on colin wasm this is another interesting multi-platform target and and the wasm webassembly folks just recently added support for wasm gc and i think this is still experimental you have to like from what i remember in the latest version of chrome and other browsers you still have to enable the wasmgc support but wasmgc allows good plugability and support for the kotlin garbage collection to happen inside of wasm so so yeah but again the native interop no matter what platform you're target getting has been a core focus of of kotlin and colin multi-platform is the the name for all all the stuff that is kotlin beyond the jvm and so yeah lots of lots of interesting pieces too how kotlin targets other platforms yeah and a lot of work under the hood to get it all working yeah yeah what's it like from the from a developer's point of view if i know how to do kotlin ffi to java well i roughly know the right syntax for for to objective c so so it does there it is a little bit trickier in that case because you do need to have some way so let's say you want to call some native code within objective c from your kotlin code you do have to like generate the the stubs essentially so that colin then knows about the types that exist on on the the raw objective c side and so there's tooling that helps you manage that but but yeah and then a lot of the a lot of the like the core libraries have have our are part of cotton multi-platform so so in the case of kotlin js they've taken the the javascript apis and made them available automatically to you so that when you're in the kotlin side you you don't have to necessarily write that bridging kind of interop code it's all just provided in the standard library now if you're doing something custom then you may have to to generate the stubs do your do that native bindings manually but but there's the tooling that exists to help you and help you do that i think the same thing with like c interop so there's c interop and so you can interrupt your native c application okay similar that that you need to you need to have the kotlin class that you're calling into and and so that then when so then your your kotlin code compiles and then gets linked together with your with your native code in the right way but yeah all that exists and is not too challenging you know there's a lot of other multi-platform systems that i think are much more challenging for how you do that native interop but in kotlin it's it's pretty pretty straightforward there's a lot of people doing it and with kind of different different platforms and is it like you know when you're if you're writing typescript and you want to use the javascript language library that doesn't have type annotations you've got to kind of come up with your own annotation for the function signatures is it a bit like yeah it's a bit like that yeah exactly you you have to tell kotlin about what you're calling into essentially but the nice thing is is that because all the codes being compiled down to the native platform that interop isn't through a a you're not having to come up with a socket way to do it or weird ffi system to do it all just gets linked together into the native executable and so so that approach allows for great interoperability but anytime you do interoperability across languages you're going to have to do you know some work to make that machinery all all happen so that things can be compiled and linked correctly i think everyone's expecting some work and the question is how much work are they actually going to come into and how how reliable it will be once you've done that work right yeah yes i think it's i think it's going well there we've seen a lot of a lot of use of kotlin on ios kotlin on other platforms it's been a little bit of use for kotlin for like native applications and that's like the sienna piece where you want to write a cli or something that that actually is you know running natively on linux mac windows whatever and so there are people doing that not as much as on the ios side there is kotlin.js which a number of people are using to do web applications with interop to the js side and then kotlin wasm coming up as being yet another target where you would want to probably do some type of interop the wasm interop story i think is being defined right now through a something called the wasm component model and so they are the wasm committees are working on the way to do interop between wasms and different languages so be interesting to see how that particular one plays out but suddenly getting nightmares of different committees trying to talk to other committees while they're committeeing their own agenda yeah from from the outside it seems like the wasm community is evolving very rapidly and working together well which is is kind of surprising for that there's a lot of different folks kind of involved involved in in wasm and and yeah from the outside it seems like that's all going well and and specifications are are evolving quickly and and with with good coordination across different people who have interest in wasm and so so yeah it's yeah this is rare and pleasing to hear yeah maybe if i was in the depths of all that maybe there would be a different story i don't know committee on the podcast yeah definitely yeah okay anyway interrupt right so i'm gonna go for a concrete example if i i can imagine then i might write some kotlin code that did a web server that was also feeding to an android app an ios app and a javascript client yeah i decide i want to write all four of those in kotlin with some degree of code sharing yes you know they'll probably be models data models among the shared among all of that some ui components shared among the three front end stuff like that yep yeah how painful is managing that which code can work where so great question yeah so what colin had to do around this was they had to create a programming model that allows you to to take kotlin code and be able to target different platforms so there's there's kotlin code that is 100 able to to just the same piece of kotlin code run everywhere and that's what we would call kotlin common so that's kotlin code that has no dependencies on any particular platform and so it's 100 portable to anywhere that called a multi-platform can work and so there's a lot of energy and and things happening in the kotlin ecosystem to do more kotlin common anything that can be caught in common make it caught in common because then it's totally portable across all the platforms but then there's places where when you're running in the browser you want to do something different than when you're running on ios and when you're running on android running on the server you want to have different functionality across those different platforms and so the kotlin team created this system called expect actuals and expect actuals are the programming model that you use where you say in your common code instead of providing the actual implementation for the different platforms you say i expect that each platform will have an implementation of this piece of functionality and so you you do the expect on the common side and then on for each platform you do the actual side and so the actual side is where you then provide the system the the platform specific pieces to that piece of functionality so in one example you you have in the browser you want to use a javascript api to like modify the dom but then on the android and ios side you don't want to modify the dom because you don't have a dom you instead want to like you know talk to a ui toolkit which skia is the ui toolkit that is being used as that cross-platform ui toolkit ski is a open source rendering toolkit that actually android uses to render on android but we're able to take skia and use it on ios and even use it in the browser with canvas and so then you get a consistent api for how you do rendering underneath the covers and so in that case you maybe you'd say all right if i'm running on something that's ski abacked then i can just have that piece of code be the actual for the platforms that have skia but then if i'm on render into the dom then i'm going to do something different in that path and so you'd have a different actual for for the dom implementation okay okay yeah i can see how that would work yeah yeah so from from the developer standpoint i'm still writing kotlin code for all these pieces unless there's some thing that doesn't exist in a standard library in a third-party library that's already done the the interop ffi you know piece for me and so in all the multi-platform kotlin code that i've written i haven't had to deal with the the interop directly because there's something that already exists for me some piece of column code that are is already doing that for me and so i'm just i'm writing my actuals in kotlin i do have to write them for each platform when there are differences but i'm still just writing the code there it just is doing calling a different api depending on the on the platform that i'm targeting yeah i would have thought the challenging part of that is getting the abstraction boundary right because like yeah button is a button is a button but there are like a table widget has very different properties across the different platforms right yeah yeah so there definitely is always the the trade-off often multi-platform programming is do you try to come up with the common denominator across all the platforms or do you really try to use what is native on the platform and so so dom versus skia is a good example where the capabilities are not the same across the platforms and then you do have to decide do i want to try to come up with some layer that that creates that common abstraction or do i actually just do the actuals on the platform and and decide all right on this platform i'm going to do this and on this platform i'm going to do this other thing and so it's the nice thing is that the facilities are there to go with whatever approach makes sense for you and you don't necessarily have to get locked into using a lowest common denominator across all the platforms you don't have to do that if you don't want to but you you can do that if if you choose to so jet brands has taken the the compose library which is the ui library for android and they've made did compose work on ios and on the browser and so you can just write one single compose ui and then target android ios desktop and web all with the same exact ui code and so that that you know if that's what you want if that's the the ui that works for you across all those platforms then great you can use that if you did instead want to have let's say just your business logic shared across the platforms but then have native uis then you could do that as well using the interoperability the native interoperability okay because i could see myself wanting to go for lowest common denominator just to launch and then refine it to platform specific for version two so i could do that for sure yeah yeah exactly so you can be anywhere on that spectrum and you can move freely across that spectrum so if you decide all right this particular view in my app i want to be native then you can just change that one view and not change everything so yeah and then on ios specifically you can kind of even embed in both directions so let's say that you're in a a compose ui and you want to embed a native ios widget you can do that but then you can also embed pieces of the ui being composed backed as well so so yeah lots of different kind of with levels of of doing the the integrations okay this is reminding me of an old promise of java that would be right once run everywhere and that never really worked out right yeah do you think kotlin has a shot of achieving that promise for people that want right once one anywhere they they can achieve that with compose multi-platform but then there are cases where that doesn't make sense and you do want to be native and you can do that as well so i think you know the the flexibility of of right once run anywhere or right some of it or up once and run anywhere and write and then have then the native implementations for specific things you can do that as well so so i think that's really one of the the compelling things about color multi-platform is that you don't have to buy into everything being one way you can choose where you want and you can adjust as you evolve along that spectrum in either direction okay okay that does sound nice it sounds like they might have actually got it working yeah you know i'm i certainly i'm i'm i'm a i think that this is the first time where i've seen a cross-platform technology that doesn't come with the typical cross-platform trade-offs that often have to be made so yeah so yeah i think it's it it is a good evolution in the space that that i don't know if i've really seen anyone else provide that ability to to choose where you want to be on that spectrum and move freely that's pretty cool it's pretty cool okay that let me let me segue into a different kind of choice between two worlds because i know that one of the things about kotlin is it's steep it's using some ideas from object orientation and some from functional programming yeah i i find that very interesting but i'm not sure how well anyone's got the two sets of ideas to sit together in an adhesive hole yeah so which pits has got them picked and how well has it blended them yeah it's it's just generally with languages we've seen most oh languages start to bring in functional constructs in in some way or another and that's been a really great language evolution across many different languages so kotlin is is one of those that has has kind of pulled in functional constructs in a variety of ways it's not it's not haskell right like i think you're you're kind of high school yeah yeah i know you love haskell and i knew i was so glad to have you on my podcast talking about high school and learned a lot on that one scholar was has been my primary experience with this like hybrid oh functional approach and and i i think that kotlin has done a pretty good job of integrating functional concepts in but it definitely doesn't go as far as as scala or or haskell is gone in that respect and so so you know some of the functional constructs and and that are important to me in kotlin one is immutability is i wouldn't say a 100 percent default but is much more default than in the world of java and so there is a strong bet in the world of kotlin towards creating immutable values versus versus mutable ones and so to me i'm like yes like i don't ever want to write immutable anything if i don't have to or immutable anything if i don't have to yeah so being able to easily be immutable and have the language and the library ecosystem really support that paradigm has has been has been good and then just like functions as being a a first class thing obviously that's that's an important piece that if i define a function i should be able to kind of pass the reference to that around and and do funk doors and all that kind of stuff easily definitely well supported in the world of kotlin so yeah i think yeah they're they're coming from scala there are things that i miss in the functional world so i'm type classes scholar threes type classes are really good and and and definitely a awesome programming model and so so i've i've i when i'm in the world of kotlin i miss things like type classes trying to think of other functional constructs that that i miss like colin doesn't have higher what's not hurt yeah does not have higher kind of types yeah yeah so it does not have higher kind of types and so so that's something that that when people get into kotlin they from scholar high school they're like i miss my hair kind of types and and so yeah if any listeners don't know what higher kind of types are there will link to the podcast i recorded on your show the happy path programming where we talk about it extensively yes yep yeah yeah so hair kind of types are something that that higher kind of types are are kind of beyond my realm of of brain capacity generally i think that i benefit from them with with good flat maps and and all that but in in the world of scala but i know that the in the world of kotlin those smarter people definitely complain about the lack of those and if we step one down i am assuming kotlin has generics like java right yes yeah yeah generics and and inheritance as well so coming from the world of java you kind of have to support support inheritance and so yeah it does support inheritance and and then there's some support for adts so you can do something like a some type with this kind of simulated in the old ways that we did it and in scala with a sealed sealed trait or sealed sealed class and that allows you to do your exhaustive pattern matching on some type and that sort of thing so but scholar 3's 82 support is is pretty pretty awesome and and kotlin doesn't go that far in terms of their adt support it sounds like you're vying to come back on the podcast to talk about scholar three at the same time sure yeah yeah we'll get you back in six months and we'll be we'll cover it perfect that sounds great okay yeah and then like the the thing in the scholar the scala ecosystem that i've really enjoyed lately is effect systems and and using scholarzio for effects and colin doesn't quite have a way to do effects system or kotlin doesn't quite have a way to do effect systems as well as has been done in in scala yet there's a new language feature that is experimental called context receivers and the there's a functional program in library in kotlin called arrow and the arrow folks have been experimenting with doing something kind of similar to an effect system on top of the context receivers the language feature in kotlin so so it's some interesting evolution in there but if you want to do functional programming in kotlin aero is definitely your your go-to for for how you do that so for those that don't know define an effect system oh yeah so an effect system for for me is a way to to to separate out the pure functions the things that that have no side effects so not talking to the outside world whether that's the network or even non-obvious things like getting the system clock or getting a random number from the system those are those are side effects there's some external call it's not a pure function the i think you can correct me if i'm wrong here but kind of the definition for me of a pure function is if i call the function more than once will it always produce the the same result is there a direct mapping between inputs and outputs and so with effects we recognize that hey it sure would be nice if we could kind of delineate the the pieces of our code that are pure from the pieces that have side effects and so the effects system gives you a programming model to do that delineation but then one of the challenges is that you when you're in the world of effects you're no longer working with a pure function you have some other construct that is that is modeling the the that that side effect that's happening and so all of the great things that we have in functional programming around function composition you then need to figure out okay how do i compose things that aren't pure functions but are effects and so and so there's some challenges to to dealing with with composition of effects and this is where scala zio has done such a great job of being able to to model the effect parts of an application and make them composable and so the the programming model in zeo it allows you to do some pretty amazing things like you if you've defined an effect but then let's say you want to repeat it or you want to retry it if it fails or you want to be able to race two effects you just get this really nice api for doing those sorts of effect compositions that are that are not functions because you're you're no longer in the in the realm of pure functions and so so yeah this is i've i've been loving effect oriented programming and programming in that style in in scala and then testability so one of the things that you get when you model your effects is that then when you do your tests you can swap out the side effects for something that is no longer a side effect so that you can more effectively unit test all of your side effecting code without actually doing the normal side effects so moving from your integration test that would be talking to the live random number generator which can be problematic in a test well it turns out you can just like in your test throw in an implementation of the side effecting piece and then it makes it much more testable so yeah that's a fun little tangent on yeah yeah it's a it's a bit like programming everything to an interface and then swapping out the real system for the mock but just nicer when it works it's so much nicer yeah yeah yeah one more thing on the whole because we talked a lot about uis and we've talked a bit about functional versus object orientation what and we've also talked about android which must have a lot of this what's kotlin's opinion on the right way to do user interfaces yeah so compose is the primary ui for building in uis for android with kotlin it's a kotlin only library so it's taken advantage of a bunch of kotlin features to be able to create a really nice program model it feels declarative but it's just using that dsl syntax and in kotlin to be able to to give you something that looks declarative but really is just just calling underneath the covers and then compose has a bunch of components and you can you know move use those munch those components together into what are called composables and build a whole ui based on your composables and so that is the the modern way to build uis and android and jet brands took that compose library and made it work on other platforms and so so yeah it's it's a it's a new programming model yeah is there anything else on uncompose that's interesting to compose is is i i think that the program model for me is is nice like it's a whole lot better than writing callbacks and you know the kind of older style of building a ui but it's it's not actually very like functional like like there i don't know if you've done elm but i love helm's approach to ui program because it is functional and so there is for me there's some some things that when i'm in compost i'm like oh i wish this was just a pure function you know yeah but and it's not it's you know it's composers managing the state underneath the covers and doing all sorts of clever things to make state state dealing with state efficient to be able to get high performance uis and all that but but it's it's a it's a different model of program in uis than than you would do in the functional world with something like a home is there is there like a comparable architecture if it's not like album is it like react is it like using jquery is it like swing i think that probably react would be the most similar that i that i've experienced but i haven't done a whole lot of actual web programming with with many of the the modern web stuff like reactor whatever so i don't know how similar it is to react but but it i i think the main point is it feels declarative you you have nice language support for doing callbacks like when somebody clicks on a button you need to do something to to that and then you can update state and compose manages oh the state changed in this particular piece of ui is bound to that state we need to obviously redraw that piece of the ui so compose does all that underneath the covers for you with that kind of connection between state mutable state and and your and the the ui that is bound to that state so yeah that's that's part of the compose runtime and compose compiler can work together to to make that all work kind of transparently and efficiently is is i think one of the important points is like you can do this you can do this in a naive approach and i think have a lot of performance issues but doing it in a way that works well for for you know non-laggy uis is a bit harder and that's what the the compose effects have done and i guess they're thinking about much lower power hardware right because they're working on mobile phones all the time yep yeah yeah definitely with with android you got to be thinking about the the lower power devices that that need to not use so many resources okay so let's talk a little bit about the future then having got a survey of the language you said you've been at kotlin come if you've been at google i google i o is happening as we're recording this i think yeah yeah you're making some announcements what's on there what's on the future list yeah so exciting stuff is the new compiler is is a big exciting piece because as kotlin code bases have gotten larger that has put more pressure on the compiler to to be fast and so the new compiler the the early benchmarks that we've seen on on compiling kotlin are that it's around can be around two times faster than the old compiler and so that definitely has an impact on on large code bases and and then things like when you're in the ide editing code you want to get code completion quickly and as the code base grows that code completion can get slower and so just providing a better more efficient way to be able to provide that code intelligence back to the ide is important and so this is this has been a big multi-year project of rewriting the compiler and at collin comp they announced that the new compiler will be the default in column 2.0 which i don't know the exact i don't know if they said the exact time frame for that yet but hopefully sometime in the next year or so we'll be getting kotlin 2.0 with a new compiler so so that's that's great that's going to lead to a kind of just a better foundation for moving forward and much better performance so so the the code name for that compiler was k2 and and the new compiler in kotlin 2.0 so so yeah that's that's one of the big exciting things other exciting stuff was there was a bunch of announcements at collin comp around column multi-platform so the colin wasm piece i think that's currently experimental composed for ios also also experimental i think so yeah so there's a bunch of exciting things happening on kotlin multi-platform announcements at colin conf i was working on a project that we announced at kotlin conf which is moving the default gradle build configuration for the the ecosystem around gradle from groovy to kotlin and so that was good things like why not have gradle supports kotlin as the build dsl and and so aligning around colin across jeff brains gradle and google to to make kotlin the default was announcement we made at collin comp so that was all good i'd certainly like writing my builds in kotlin so that's been been nice so it sounds like the main thing that's happened is organizing for for a larger future yeah yeah exactly yeah yeah just in in many different directions whether it's multi-platform or compilers or you know using kotlin and more more places like in the build just just kind of yeah setting up setting things for a better future but but also like it's impacting developers you know already today like the developers that are using kotlin are they they're generally happy which is kind of weird like normally in the language communities that i've been a part of like like people are grumpy and complaining about you know all sorts of things in the language and and i think the developers that are using kotlin are really happy with it they always say that they're having fun which is you know good thing to hear for for a language yeah absolutely it's funny how every language takes on a character partly by the language and partly by the designers and partly by the community yep yeah yeah and i think with content developers we they seem happy they seem like they're having fun that's that's a good thing good good that's what we're here for getting stuff done and enjoying it along the way i hope so yeah i mean i'm definitely been been part of language communities that that just feels like a lot of thrashing and you know a lot of like pounding my head against the wall in various ways and and yeah i don't i don't i don't feel that much in the kotlin community so that's that's been good that's really good that that actually leads me to one last question i have to ask you one last challenging question i think bashing your head against the wall the hot topic right now is getting artificial intelligence to support us as programmers yes will we be getting ai to help us write kotlin and you're at google so you should have great answers to that you know this is well timed because just yesterday in the google i o developer keynote there was a lot of ai stuff and one of the pieces of that was in they have something called android studio bot which is now integrated into the preview releases of android studio and it allows you to have a chat like experience to help you write your code or explain your code and so you can highlight a piece of kotlin code and say studio bot explain this to me and it'll explain it you can go into studio bot and say studio bot write something that will render an image for me with compose and boom like there's your code snippet and you can pull it right into your code base and so yeah that was that was actually the first time that i'd seen studio bot was yesterday watching the video and i was like this is really cool like integrated right into your developer tooling having that ai kind of experience helping you be a more efficient developer so yeah super exciting to see what's happened there i need to go play with it because i just saw history i'm like okay now i gotta go actually try this stuff this happened to me in a similar role the company announces something you've got i gotta play with this so i know what i'm talking about yeah yeah so at this point all i've seen is the demo it looked really amazing now i need to actually get my hands on it okay you can test if it's actually as good as the demo where yeah exactly yeah it was a live demo which i was like hey you know like like i i'm a huge fan of live demos i'm like if it works in a live demo there's a better chance that it's going to work for me while i'm sitting in front of my computer whereas i'm always a little leery of like the the pre-canned you know pre-recorded demos i'm like okay that to me is like a red flag that the path is not going to be as smooth for me as the user yeah if you do a live demo it proves you're prepared to put something on the line so final question then if someone wants to get started with kotlin are you recommending they start with android studio or what what's my what's my onboarding path yeah so i think it depends on which platform you want to start building for if you want to start building for android then android studio is going to be the right path there if you want to start with other platforms then you can just get intellij the community edition is free and start writing column code they've got some wizards to to build out new new projects and all that and then for kotlin multi-platform you can also start you know intellij and start creating multi-platform projects and and targeting other other operating systems and then the colin ling website has all sorts of great getting started learning material and all that for people that want to dive in but yeah lots lots of resources out there depending on you know what people want to do but but maybe to your point it depends on which platform you're interested in targeting for kind of what your entry point is into it and some some different options there okay that's that's a new one actually where it where you're compiling to makes a difference as to how you get started that is yeah that is interesting so if you're a server-side developer and spring is a great choice to start with with kotlin and so go to start.spring.io you can click kotlin as the language and boom you're like get your starter project and can start writing kotlin code for spring so yeah kind of a few different entry points depending on what what you want to build but yeah lots of lots of great resources out there for developers to learn okay cool i'm gonna append kotlin to my list of things to learn yeah let me know how it goes yeah i will to make sure that that getting started experience is great for you chris because if it's great for you then work on emac support dude yeah no i shouldn't have said that i take that back there are bigger issues than that is a choice i know yeah it's it you know it is wild in this the space that we have a lot of different options for how we write our code and and and you know i think it is important that we support everyone and their choices around that so yeah hopefully that space continues to evolve one challenge at a time yeah exactly james pleasure talking to you as always i hope i see you again thanks for joining us so yeah thanks for having me thank you james as you just heard james is the co-host of his own podcast called happy path programming so if you're interested in a bit of a role reversal there's an episode on there where i go and tell him all about my love of haskell i'll link to it in the show notes so if you really want you can get two languages for the price of one this week value that's value a if you'd like to give a smidgen of that value back please take a moment to like and subscribe i know everyone asks but i'm also asking because it genuinely does help or just drop me a comment i'm doing this because i'm a developer who loves talking to developers so come and say hi there should be a comment box nearby or if not my links are in the show notes you can get in touch with me and with that i think we've written one and it's time for me to run elsewhere i've been your host chris jenkins this has been developer voices with james ward thanks for listening all right