right time travel debugging good nice nice turnout always good to see so i'm going to talk about how we can basically debug a lot better using time travel debugging before i get started so before you like read the abstract to this talk who had heard of time travel debugging let say show hands okay so maybe like 2/3 and who had tried it in any form one two three like okay so like not even 10% 5% so about 2/3 kind of had heard of it 1/3 coming to find out what it's all about and only a handful having tried it hopefully i'm going to if i do one thing today i want to persuade you to go away and try it right and you can i mean all else being equal i want you to use the undo stuff because it's awesome but i don't really care right you can use any of the stuff out there depends what platform you're on there's open source tools we talk about the different things are available and why you would want to and may and a little bit like how they work and what they're good for and stuff ah that is right so let's just start most programmers spend most of their time debugging right i think that's a fairly uncontroversial statement but i don't think it's something that we really acknowledge as an industry right how many lines of code can you type in and have it work first time like maybe you're better than me but five 10 maybe no yeah how many lines of code can you change and have it work first time i reckon that averages to way less than one right so so yeah it's like just humans aren't very good at programming it's just too hard you need too much level of precision and the computer's doing billions of things every second and when something goes wrong trying to find out what went wrong is super hot so well someone put it much better than me this you probably you may know this quote it's quite a famous quote from brian kernigan everyone knows that debugging is twice as hard as writing a program in the first place so if you're as clever as you can be when you write it how will you ever debug it now i think what kigan is saying here is like keep it simple and give yourself margin for error you're probably not quite as smart as you think you are but i think there's an interesting corly of this as well which is that debug ability becomes the limiting factor in how good our code can be right whatever your metric for good whether it's how fast it runs or how small it is or how quickly i can write it or how extensible it is like pretty much any metric for good if you can make it twice as debuggable you can make it twice as good and there's a lot we can do to make it a lot more debuggable so what do we do to debug there's lots of things out there right so maybe we use dynamic checkers valind the dress sanitizer who uses those at least sometime okay pretty much like vast majority good you can use debugger so gdb or intellig if so show our hands again use a debugger at least sometime okay most people who used the debugger in the last week who used a debugger last week okay like half the people that's about half the hands so that's more than you like these talks kind of self- select a bit right to really kind of buy a sample in my experience it's maybe not that many but yeah so people can use a debugger dynamic logging it's not so much in the c++ world but kind of in microservices land there's lots of stuff out there light run and and they're competitors for sort of funky dynamic logging stuff or you can just use print f right print f yeah show hands print f yeah well come on if you're not putting your hand up then i don't believe you so so why is that right why do we why do we just why do most people debug most issues using printf well i think there's a couple of reasons one is going to say it kind just lazy right you have to think hard normally when you're programming add another printf let it recompile run again you don't have to really think in the same way it's kind of a natural kind of if you know the thinking fast and slow system one system two it's very much a system one automatic comfort zone activity and this is from a few years ago now but was quite kind of much repeated xk cd cartoon so yeah so the programmers are goofing about this is obviously pre-co when people actually went to the office but programmers are goofing about what are they doing they're compiling why is the code compiling because they added a prf right 99% of the time you recompile the code that's why so it's kind of the programmer's version of just reading email in the office right it kind of makes me feel like being productive feel busy but maybe not so that's one reason why people use printf but it's not the only reason right there's that's the bad reason there's also good reasons why people use print f at least in the absence of time travel debugging spoiler alette right but when we're debugging basically we're trying to think how did that happen right so not like i don't mean how did that happen or how did that happen but what i mean is i've got expectations about what my program is going to do and reality diverges from my expectations at some point right and the process of debugging is to work out where did well actually it's usually more like that but the process of debugging is where did reality diverge and if my computer is doing billions of things every second and i've got maybe millions of lines of code that's super hard right it's kind of the ultimate needle in hyack challenge but at least with prf it tells me what my program did and that's really what i'm trying to understand right when i'm debugging usually what happened and actually regular debuggers don't really do that right they tell you what's happening they tell you what the program is doing right now and then maybe you can go forward a line or run forward to a break point and then they tell you what's happening now but they don't tell you what happened well okay with the exception of back trace back trace gives you a bit of a clue about how i got here i say suspect that back trace is one of the most commonly used commands in gdb and features in debuggers because it's the closest you get to what happened but it's just a sliver of information of what happened how i got here right it's just my immediate call site and the pa and the immediate call sites thereof and all kinds of things may have happened in i mean this could be like this time here between here and here could be a really long time right and and yeah the longer it is kind of the harder things are to debug do i have a slide on that i can't remember who we just skipped forwards oh man that's yeah so we just go back in so yeah so trying to work out what happened sometimes it kind of feels a bit like this right and what we would like is to feel a bit more like this he looks a bit more serene and cool so this i i like this picture for for time travel by the way because partly it's kind of like you know cool cooler than some of the other more modern stuff but also this is the original this is hg world's the time machine and in it unlike a lot of the more it's kind of the first time travel science fiction and unlike the more modern ones he doesn't go back and change things right and in modern almost every modern time travel sci-fi they go you go back and and like change things and fix those mistakes that you made or whatever and that's not really what time travel debugging is about it's about observing so just like hd wells's time traveler we're just going to go back and observe and see what really happened we can't change the history because you know paradoxes and stuff right but i think i think there are two things that make debugging make bugs hard so if i just go back a few slides here so how long is it between diverging from expectations and me noticing right so if if like if i i don't know like just really stupid like forget to check a pointer for null and then it's segals i can load the core file up i can see that the time between the bug itself the bad line of code and the symptoms of crash is very short almost immediate so that's quite easy to debug if i've been a good programmer and i've littered my code with lots of assertions then hopefully that's narrowed the window between the thing going wrong and me noticing right that's why assertions are such powerful things and that's why the worst bug always is bad results right the thing ran to completion just didn't give me the answer that it should have those are horrible the other kind of dimension that makes bugs really hard is how deterministic are they right if every time i run the program it fails in exactly the same way then i can kind of get to the bottom of it like reasonably easy if you think of debugging as like putting a a jigsaw puzzle together and every time i run the program i'm getting a new clue about what went wrong and i'm getting a new kind of puzzle piece and you know sometimes when you get so sometimes when you get a crash report or a bug report and it might be that inner loop debugging where i'm just you know i've written the code and it didn't work or it might be that you know i thought it was perfect and it's deployed to production and someone has has sent a a bug report sometimes you get the crash report the log or whatever and you look at it and you can go ah don't i know what that is right but usually there's not enough information in that original crash report and i need to run it again and get more information right get more clues run more experiments and get more clues and if every time i run the program it does a different thing it maybe it fails in a different way maybe it only fails one run in a thousand if it's always doing the behavior of the program is different every time i run it then it's really hard to keep running those experiments right because every time i get a new jigsaw puzzle piece it's for a different jigsaw right and it's really hard to build a jigsaw that way so this this is why what we want is the is to have our debugger tell us really what happened right i think before i get into that i'm going to show just a little demo inside so there's i'm going to talk about the different things that are available soon but let me just show you what i mean because only a few hands went up of people have actually tried it so let's look at what this what this really looks like i'm just going to use gdb i have here a program sort i'll show you the code hang on so like the code isn't important right but it's just a bubble sort it gets some rand gets some numbers random numbers and then sorts them and if i run it it's not printing any output but it is usually working but i happen to know if i run this in a loop okay it failed first time that time and you get the point right so it like it's intermittent and it's quite intermittent it was very strange to fail on the first iteration of that loop but anyway so let's okay so i've got a core dump so yeah there it is so let's load that into gdb and what did we say b trace is usually what we do no information can you read that is that too maybe i'll let me make fewer whoa that's like really few lines let me do it like this and then i can move this up to the top okay that's probably a bit better right wasn't just to get the logo in i promise right yeah so it's that that core file is not very useful right so the information i need is gone from the universe it's not in that core file i do not have enough information to diagnose that so i'm going to run the program inside gdb and i'm going to use gdb has inbuilt time travel debugging it's called process record and it almost works it works well enough it works well enough to like have a play with an experiment what you're doing it works well enough that if you've got a specific small piece of code and it's really not clear what in earth is going on then actually it can be quite useful there but the problem is that the slowdown is too bad and it also doesn't it's not very well maintained so doesn't work great on modern cpus and stuff but it works well enough to show a demo works well enough to have a play so i am going to i'm going to start the program i'm going to put a proper break breakpoint on main and i'm going to use the commands command which if you don't know in gdb lets specify some gdb commands we're going to run every time that breakpoint is hit and so the first thing i'm going to say is record and the next thing i'm going to say is continue and i'm going to put another breakpoint on exit and i'm going to hang some commands of that well one command of that which is to run so if it gets to exit remember the program seg faults so if it gets to exit it will just rerun and then it'll hit main and it'll turn on recording and it'll rerun i'm just going to set pagination off and set confirm off because that messes everything up and i'm going to run and this is going to run you can kind of see how slow it is right this is a oh okay that very nice this is intermittent and crashing quickly usually it takes much longer so this is this is now actually doesn't doesn't say segv hit but it should do but it's a bug it but so now i can back trace looks much the same as before right it's garbage back trace so looks like i've got some kind of snack corruption so well time travel means as well as stepping forwards in time and running forwards in time i can just go backwards so i'm going to do the smallest increment of time travel that i can do i'm going to go back one instruction in history and well actually before i do that i'm going to go layout s actually no that i'm going to go two enable that's a bit clearer twoy mode if you don't know as much lets me see what i'm debugging who uses tuy mode when they use gdb oh not many who's who's heard of tuy mode okay like right not very well known so tuy mode makes gdb suck a lot actually gdb is really good but but two mode makes you to be suck a lot less it's like a poor person's ide anyway i've got no source available cuz like the things in hyperspace reverse step i is going to go back one instruction like i said the smallest amount of time travel that i can do okay and now look i'm back well this kind of isn't too surprising because i've looks like my return i'm i'm stack corruption right i could kind of tell that from the core file so let's see what's going on here so stack pointer is that so this is x86 it's just running on my my laptop so x86 is a fully descending stack so it means what's at the top of the stack should be the return address so let's have a look at that so that apparently is a return address which doesn't look very addressy if i do the x command that lets me examine memory at a given address and yes can that me that address doesn't exist so all right so the top of my stack contains garbage and so this is never a nice piece of you know things that happen as a programmer so why did that happen so i want to ask the program or ask the debugger to tell me how did i get here what happened and it's in particular i want to know what line of code most recently wrote to that address because that's probably what i care about right so i'm going to use a watch point here before i do that there's another bug strok in forcity you have to turn hardware watch points off details don't matter so now i'm going to put a watch point on that i'm going to do a location based watch point so i'm going to look for that specific address i don't want to watch the expression i want to watch the piece of memory that's being that i'm specifying here okay so i set this watch point okay now i reverse continue so i'm going to go back in time until the top of the stack changes until the line a code that wrote to the top of the stack okay here i am now somewhat unsurprisingly i'm at some right what's going on print i i is 35 what is array array is 32 elements long and so here's the stupid bug but it's the classic percent size of array and size of its bytes rather than number of elements so obviously a very small program and actually you could just run a dress sanitizer or valren didn't it would also find this issue but from everyone as as we know with think i mean like you should this i don't see time travel at all as a alternative to things like a dr sanitizer or vrin in fact they work really well together particularly with a dress sanitizer because with simple bugs all the like this is a stupid little demo which fits in you know on a single slide with decent font size but real world bugs well there's the type that are kind of obvious and you can figure it out from the crash or from the what address sanitizer told you but the thing that we spend all the time the thing that really dominates is the ones where it's kind of a chain reaction kind of a bit like every single you know airplane disaster is is like multiple things that go wrong that lead to it those are the ones that take all the time and so often a dress sanitizer tells us yeah there's something wrong here you're accessing this out of bounds or something and it's like well why is that why am i doing that out of bounds access i've accessed via some index and that index should always be within bounds right so address sanitizer has given me a clue if i then run that with time travel with some kind of recording then i can just go back to see why that index is wrong right so these things complement each other work very well together so that's just the simplest shortest demo of what time travel debugging is it just gives the debugger the ability to answer the question what happened okay very quickly so when when when would you use this so the most obvious thing i think most people think of most of the time when they first see this is i'm going to run this in production because those are the bug reports i get that i just can't fix i don't have enough information i don't have enough information in the logs now you can do this in production and people do people use our stuff and the other stuff in production but there is a slowdown when you're recording right nothing is for free depends what you're using so the gdb inbuilt process record is like i think it's like 100,000 times slowdown other tools are stuff are are the tdd we'll talk about the different tools that are available they run much more like half speed or there or thereabouts okay so some depends what you're doing in production sometimes that will work sometimes it won't most people in production they run it when they it's like it did it again that's the third time this week right now i'm going to enable recording perhaps in some subset of production and try and capture it and then i capture it and then i've got it but that's only one that's kind of usually that's the end of the journey right that's no what no nobody really starts time travel debugging there much better to start with in your ci right jenkins test your test fails rerun the test with recording get the recording file i know this test is flaky i mark it flaky and i'm just going to run that all the time in some flaky test with a recording enabled until recordings kind of of poop out of my of my system and then i can time travel debug those it's really good for flaky failures they actually start with the inner loop development right that thing we just said at the beginning you type in some code doesn't work why get a recording load it into the time travel debugger if it's not immediately ob okay that's the first part of the talk like what it is sh of hands who is convinced to immediately go back and try this how many have i got if i've completely failed in my okay there's more i'm just going to guilt you into it right there's a lot of people stubbornly got their hands down okay why not someone someone tell me from the audience what yes my experience is is sl very very slow can you can you kind of quantify how slow yeah gt so with okay so rr that's a surprise it doesn't you i mean like your mileage will vary gtp no record regular gtp no recording is going to take you f okay that's a surprise why what's what's leading to that slowdown is it like the time it spends because when you run in gdb it's normally going to run pretty much unencumbered right lb yeah so just the time so can we kind of quantify this so how long are you having to wait for lldb to open the binary and get you in there we talking like 30 seconds three minutes it's like five minutes five minutes so it's just just enough friction for you not to do it yeah okay yeah it was so modern particularly modern gdbs should be a lock quicker i mean i don't know how big your binary is obviously you know your mileage will vary but but new the newest versions of gdbs are are they multi-threaded debug info paing and stuff and they'll load much quicker but okay you're too impatient to load the debugger but you don't actually count as p answering because you've already tried it right so i want to know some i want somebody else who's like they've never tried it and they're not convinced now that it's worth trying anyone brave enough because of the slow down yeah can't really run it can't really run it in production no but could i i failed so badly what okay but but this is good kind like this is an honest open conversation so you'd rather just add the print statements and hope because because you think that's going to get you there quicker i know expect yeah yeah okay okay but how many times i i don't want to get into like a like argument over this so it's okay so concerned about the the runtime slowdown you think well that i' say if it's if it if your mileage will vary but if it's running at half speed with the recording you only need to save one rerun cycle and your parity and that assumes zero debug zero compile time okay do you know what i mean if i run it oh okay now i need to add a printer and run again well and now so i need to do two runs to get my answer and often as we all know actually we had another print f and another print f and another print f but let's say it's just two or three okay but see now you're going production and i agree so this is the thing right so people see this and they go they immediately think production don't start in production right because that's the heart that's where like you can do it people do it all the time it's super powerful but you really kind of that's the advanced usage and you need to know when because it doesn't make sense absolutely doesn't make sense in all scenarios but more and you kind of you know ever have to debug a flaky test test fails one run in 100 no doesn't happen okay all right well you wow no never have any flaky tests okay i wish i were you passes all the test production yeah okay yeah okay yeah you might want some more stress tests i think that might be the verdict there okay but that seems to be that's the thing i most commonly hear actually is concern about the runtime overhead and i think as i said just like all depends on the on on on the scenario but if you yeah if it slows down by 2x you save you just do it in one cycle rather than two print f cycles and you're ahead right and we all know it often takes a lot more than two right okay i don't want to come on forever and ever on that we're going to just start some more real world demos we've got until five haven't we in so we we've got a bit of time so i'm going to get into a bit of like what are the different options to do this and how does it work i'm going to assume that i'm going to assume that actually everybody is going to go ahead and try this straight after this talk and i didn't actually fail as badly as i did right so that's the wrong buton button again okay so i think i think this is an idea and a technology whose time has come essentially and there are a number of solutions out there and a lot of people are doing this like yeah in you know in production and in test and all the rest of it and it depends what platform you're on so if you're if you're writing i'm this is a c++ conference i'm assuming mostly it's c++ so if you're writing on linux like regular kind of you know kind of servers and and and and regular you know rather than em deeply embedded you've got our stuff which is wonderful you've got rr which stands for record and replay which is completely open source you can just download it and use it little bit limited in like where it can run but if it will run it's very good and i'll talk a bit about the trade-offs in a bit gdb which we've seen is kind of it's kind of good for play but probably not really good for for real world serious stuff windows has something called imaginatively enough microsoft love their unimaginative acron windows has something called ttd time travel debugging which you can run inside wind dbg and it it's it's really good and it works really well and microsoft themselves use it a lot for their own debugging of their own applications office and sql server and those kind of things there's some sniggering like maybe they need to use it more i don't know if you're embedded you're running like on an arts or directly on the hardware then you kind of need some you need some hardware support so lbac and green hills both have these kind of devices that you can plug into your jtag and they used as long as you've got the appropriate support in the cpu like the embedded trace macro cell of its arm will will give you that time travel experience without any operating so but if you if you have an operating system then then you don't need any of the fancy hardware and you can well unless you're mac in which case you should just write a letter to tim cook i suppose because they right actually there's loads and outside of c++ as well this is a c++ conference but lots of us write in different languages as well so i thought for completeness if you're doing oh i just pressed the button again oh thanks chris yeah back if you're doing javascript particularly react and there's a company called replay. which are kind of specializing in that there's on. net there's a couple of solutions including microsoft's own also a company called revy buug on java there's our stuff rust and go can be we we can do that as undo as can as can rr so kind of lots of different kind of combinations of things also the other java kind of jvm type languages like scalar and things like that will also work in undo okay so let's talk about about the history of this as said as an idea as time has come actually if you look back there's countless research papers and like countless phds certainly going back over the decades that have tried to implement something like this i've met many people over the years who've built something at their phd or sometime like that kind of experimental systems but it's only recently in the last 5 to 10 years that it's become i think ready for prime time as they say this was the first one that i saw thing called the omniscient debugger see the date stamp at the top there 2006 this is the first time i saw it i saw the concept it instruments the avm it's not super scalable but it actually worked reasonably well and when i first saw that like you you mind was blown could immediately see wow now the debugger can tell me what happened so yeah so we want to know the so this is the question right what happened and if i'm going to answer that in a in a debugger sense then a kind of more precise way of saying that is what was the previous state of my program right because what i want with what i can do with these time travel debuggers is i can go back just think about this i can go back to any line of code that executed and i can see any piece of program state at any point in history like there's nothing about my program's execution that i can't just see it's like it's a colossal amount of information so clearly i'm not going to capture every single previous state that's way too inefficient even if i just try and capture just the delta just like what changes that's also problematic just because billions of operations every second but basically i've got two ways that i can do this i'm not going to i'm not going to store the complete program state for every instruction executes that's just madness but i'm going to if i'm going to try and just store the the the deltas even then like i say that is that is that is uh just too much information so i can that's one but if i want to go back and i want to see what happened i can save it save each state transition or i can try and recompute it it's better to try and recompute right trying to figure out what the previous states were but that's harder than it first sounds because if i got a statement like this that is inherently reversible if i know the value of a after that statement executed i can deduce the value of a before the statement executed right it's not hard but i can't hear right sorry for those back i can't necessarily just see the lines if i just got a straight assignment a becomes b right well and now i know the value of a after that executes the value of a is 42 what was it before i have no way of knowing right that universe that that information does not exist in the universe anymore so we can't run computers backwards i mean there's some interesting research with reversible logic and kind of what that might mean does interesting things to actually turns out to be really efficient in terms of power consumption because there a sort of when you destroy information that actually consumes energy anyway that's not for this decade so i can't run computers backwards so if i'm going to deduce what that was before there is another way to recompute it which is to rerun it right i can periodically snapshot then i can go back to a preceding snapshot and run that to like just before where i am then that will have the illusion of going back in time i can get to any point in my program's execution just by going through to proceeding snapshot and running it to the right place now that's what that's what undo that's what we do at undo with live rec that's what an udb that's what rr does it's not quite what the microsoft ttd does it's what replay doio does and you can you can you know especially on linux you can just use fork to get nice copy on right semantics of the program state there are v sort of equivalents in windows that that ttd does so it can be very efficient to create those snapshots but we're not creating very many of them we only need to create the snapshots kind of human scale like every second or something in fact once we been running for a while we don't even need to record them every second we might record them every hour and then kind of postprocess and fill in the snapshots what the snapshots are just an optimization right i really only need the starting state and then i can rerun the program because computers are deterministic things right when i run the same program multiple times with the same starting state and the same inputs it will always do the right thing okay so computer programs are deterministic obviously except when they are not and practice like they usually aren't otherwise you wouldn't ever need to read it run it a second time so i need to what i need to do to make this work is capture the sources of non-determinism and replay them synthesize them reconstruct their side effects at the right points as i replay and then i can make the replay do exactly what happened the first time around so i store these events in an event log and this is kind of the basic architecture for most of the modern time travel debugging implementations this is like basically how you make it scale and it does scale by the way right so our stuff is and i said you know microsoft run it on sql server and other big stuff like that whoops i went too far again it doesn't matter we there we go thank you yeah so you know our customers routinely run on programs that are like hundreds of gigabytes in working set and run sometimes for days right this totally scales and it only scales using this kind of technique and this is what the the the modern versions do the other thing that i think is quite interesting is is that no i for there we go i i did have a proper clicker thing i left it at cppcon and i haven't managed to get one since right yes so what are we going to store when we say we're going to snapshot the program what exactly are we snapshotting and how are we going to capture the information that we need to capture it there's kind of different ways that you might do this particularly if you're going to work i mean in c++ it's a bit more obvious that you would work at the process level but it actually turns out to be the best way to do it regardless but so here's my really simplified i've got kernel and i've got processes running on the kernel right this is like pretty shouldn't be super interest and what i'm going to capture in my recording is around this process boundary right so basically all of these work at user level they're not capturing the kernel apart from if you use the embedded stuff from l toac or green hills but if you use software implementations they're all user space and they're capturing that process boundary like including libc and you know other system libraries they they live inside the process and it's everything between like the process and the kernel abi that's what that's what's being captured and it turns out that's a good way because we can make certain guarantees about you know this is my address space and i know that nothing is going to change that address space face like from outside right unless it's the memory is marked shared or it's async iio there's exceptions that we have to deal with but in the simple case in simple case i know that i've got guarantees about only the program a program's memory a processes memory can only be changed by the process itself right or some other entity that it's given permission to so we just capture everything like yeah lipsy and and everything down to the os abi and you can capture other processes you can capture all the processes or some of the processes or just one process it doesn't matter we're capturing at the process level and we need to reconstruct everything that's like unpredictable right so the reason this works the reason we can re-execute from a snapshot is yeah if i add two numbers together and i've got the same state of the program i'm going to get the same result right a better had otherwise everything's going to go kind of screwy i'm i'm even going to get like the same flags are going to be set in the flags register and everything else but there are some things that are not predictable based on the state of the program most notably system calls like if i could predict the system call based entirely on the state of the program then it shouldn't be a system call it should be a library call right so we need to intercept all the system calls at record time and record their results if i read from the file system we intercept that read and we capture the read in what was read into the event log when we're recording and then when we rep play we can re we can of reconstruct that thread switches and thread interactions clearly there un predictable i run the same multi threader program multiple times even with the same inputs it might do different things asynchronous signals and other events right so i get a sig alarm come in that could happen at any time any share memory accesses right so only the program only a program's memory can be changed only by itself unless it's arranged otherwise and it's got shared memory shared with another process shared with the shared with the os so most memory holds the property that when i read from it what i read is what i most recently wrote shared memory does not hold that property right so we need to record at least accesses to shared memory where it changed under our feet and certain machine instructions so on x86 read the time stamp counter is not predictable given the state of my program right there's also instructions how to get a random number equally obviously not predictable actually you could say that a system call is just an example of a machine instruction whose results are not predictable i've taken system call out as a separate case but in some ways it's a special case of an unpredictable instruction but if i do those at least on linux if i do those then that's it i can get perfect reconstruction of any program that executes so but there's a there's a bunch of different tools out there and they all make kind of slightly different design trade-offs so i just want to go through some of that before we get into some more meaningful demos so yeah we've got these design decisions right so what boundary to capture do we do at the process level or something else because if you're doing something for java you might think better to do that at the jvm level right and and and and so on so here's this is not exhaustive but this table is some of the more widely used odb is that omniscient debugger i put that on the end as kind of comparison point that didn't really scale so if you look at this at what boundary to capture all of them apart from obb capture at the process layer even surprisingly replay. so if you haven't seen replay. i very cool company and it's all about java script particular react re time travel debugging of web applications right and and and it's kind of yeah it's kind of counterintuitive that they've they found the best boundary to capture it is at the process level they actually have a modified version of firefox they've got a modified version of chrome as well now which will kind of hard hardcode those non-deterministic things and do the interception for them but they basically capture at the browser level not even just for your little javascript thing that's like deep inside the browser they capture the whole browser execution because that it turns out is the only sane way to do it like build by the way there a sort of irony building these systems they are like some of the most difficult to debug systems you can have themselves right at least until the point where you can eat your own dog food because they just if you if you get it wrong when you're replaying the execution if you get that just a little bit wrong so it diverges from the originally recorded state it can be a long time before you notice and that other dimension is kind of inherently in a neter inherently non-deterministic so so super hard to debug and so you need to be able to really reason about the system and the process boundary allows me to do that the sandbox my javascript runs in inside my browser it's like totally messy right and it's totally vulnerable to any browser bugs or anything that the developers just decide to like reach in and change his piece of state or any you know calls to and from the dom or anything like that so they do it at the at the process boundary as well there's a kind of big kind of design decision around whether you want binary rewriting instrumentation so so we do that and and the microsoft platform i don't know why i called it wind dbg but anyway the microsoft time table debugger platform does that so you don't have to modify the code you don't have to recompile it in a special way you oh for god's sake this is actually a really bad clicker i think i just press b so i think if you do four oh i'm going to buy a new clicker i've decided to hell with the expense yeah so so we do this binary rewriting implementation on the fly microsoft does the same so you don't need to recompile in any special way and you don't need any special hardware replay. did it differently they as i said they modifi the browser right so they've done it kind of statically rr doesn't use that it use rr uses performance counters on the cpu because the other hard thing you've got as well as capturing intercepting those non-deterministic things when you replay you have to replay those non-deterministic events at exactly the right time like down to the instruction level so let's say an asynchronous signal comes in let's say sig alarm comes in i've got to replay that sig arm at like exactly the right point otherwise my program is liable to diverge so i need this super fine control of time and so you can do that basically in two ways you can do that with binary rewriting instrumentation or you can do it by by using the program counters on the cpu right so the performance counters on the cpu tell you how many instructions you've executed or how many branches you've done which is kind of enough to figure it out the problem with that approach is that they are not generally they're not universally available right so you just get a machine off aws or something it probably doesn't have the performance counters available because you know i think partly for security reasons the you know potential for for side for these side channel attacks and partly because a lot of the hypervisors just haven't implemented it and it does mean you can only capture certain things like so share memory is out so by that with that approach you can't you haven't got enough information to do to monitor the shared memory accesses i could do a whole other talk about how time travel debuggers support share memory but we don't have time so do they allow share memory accesses so as in did they record every single share memory access or some of them or none of them and so rr can't record any windy buug will record pretty much all although there is some so turns out that even microsoft don't know in enough detail what the abi is between the windows kernel and user space to reliably intercept all of the system calls so they just pretect they just act as though all the memory is shared any of it may change at any time and then another design decision you might see in in a bit is so do you have separate record and replay phases so i haven't shown the the inbuilt gdb stuff in this table perhaps i should that doesn't require separate record and replay phases our interactive debugger called udb for undo debugger that doesn't require separate face you can just like attach to a running program and then you know do what you want to do all of the others have a kind of separate record phase and then you load that recording in and debug it later and sometimes i wish we'd done that because it's like it does remove a lot of the challenges it's a lot easier to implement we do have that option you can do that using the undo stuff using live record as a kind of headless record but but you don't have to so anyway these are just kind of like some of the different design decisions around the different platforms i think that takes us to demo time so we're going to sw quickly switch the switch the cable over and greg's left me lots of time for this i think if that's there you can hear me hopefully yeah this in so i i can get rid of this okay on the screen but everyone's eyesight is absolutely perfect right yeah okay let's maybe not go for crazy eyesight requirements let make this a bit bigger so we've seen the simple demo in the bubble sort example that greg gave earlier with gdb pardon i can hold it closer but then it's going to be a lot harder to type we'll see how we go okay so you could try this thing we'll go for this for the moment because hopefully it'll be more typing and less peing okay so i've taken the we decided that we'd actually try and show you a demo on a real world application rather than an artificial simple thing and gr has generously left me lots of time to do this so yay but i decided we did some exploration a while ago looking for some examples of these the demos that would make sense and speak to people esite wonderful project lots of people use it every day most of the time not knowing about it because it's in everything but this is an example of an issue found where an integrity check complains the data base as a disen function ah that will be perfect thank you i'll give this to you and i'll stand here while i talk about it so essentially we've got a a bug in their bug tracker we've got the ultimately we see the database dis images my formed era come out i online assuming i wasn't going to have the time to do it even though it only takes about a minute and a half i've already downloaded it i did the configure i did the make and then we can have a look at the ls and i can run it and i've already taken the sql from the website so if i pipe that in we run that we do indeed see the error so this is the the 3.3.0 release of the code downloaded replicated we've replicated the bug wonderful so headless record let's do this greg mentioned it earlier how we do record separately if i do live record umite yes certainly sorry so hopefully that's legible or just a massive mess of text if i do it again and this time i pipe in the command for those who didn't see it the first time you see we got the database discission how formed er it's too low okay well when i press enter it'll come higher up okay so we did it the first time now i've recorded it i'm going to use some mouse but at the top you can see there's going to be a recording saved it get saved to that file we see the error come out and then the bottom is just saying we're going to save it we've saved it we're detached and then edit so those who can't see the bottom lines don't worry too much i'm going to switch to an ide and there's not a lot in that bottom left corner unfortunately there is some typing at the bottom of the screen so i might drag that up but if i just do an ll- you can see we've got these recordings here there 17 megabytes to record this and this is now the repeatable recording we switch over to visual studio code which i'm going to use for this i told you i had the issue so these are the commands that we saw again let's make this a bit bigger okay that might be a little clunky so we've got our code here the the code for sqlite is actually shipped in rather large source files and we'll see that in a second but with the plugin installed i have the option to replay recording so i'll just start with playing that and then it'll offer me to choose the recording let's choose the one that i just made which would be this one today so it's loading the recording and with time travel debugging generally speaking we go to the end of the recording because that's sort of where the interesting thing happens although in this instance the code did just exit quite happily it reported the error and then it terminated in a normal fashion so our the first thing we're going to be wanting to do is how do we get back to where things interesting were happening and i'm going to suggest that this integrity check function is what caused the fault so if i take that string and copy that look in the source code if i look in shell. c f there there's no results seems see look i've done it before so there's no result for that so we'll lock in sq light. c f and we'll find there are two instances in here i'm just going to make this a bit bigger hopefully and so if i go to the first one you can see if the string integrity like is in the command then it's going to call this this function so let's put a break point here and we'll just check the second instance again if the string integrity light is there then we're going to cause this function as well so put the break point there so we've got break points in the past for where the integrity chain function is and now i can just run backwards i'm not going to i'll explain them a little as i get to them we have backwards buttons as well as forwards buttons at the top so this is just reverse continue and here we are at this point we can see we're before the function's called so rc which i'm going to guess is return code is zero if i look down here i can see that zero is the okay return code so if i just step over this function we can see rc is 267 okay so that's not okay and since we know what okay is if i right click and peak oh it's over here peak definition we can scroll down a little bit see actually here sq like corrupt is 11 well 267 is 256 plus 11 so if we scroll down a bit further we can see know we've got an sq v tab so we found the error code that's quite likely to produce the integrity error result we saw so now i want to know well where has that come from if i go back here so i'm here after the function call that's just returned this bad value or this error code let's go back into it and see why it did it if i start stepping over i can see it's 267 here step back a bit more hope this is legible at the back i'm sorry if it isn't but there only so big i can make the text before we're not able to see what's going on so yes rc is 267 let's step back again okay it's now zero so this function call is where happens because we can go backwards i'm going to go forwards and go backwards into it and if we go back again we can see here rc is still 267 but actually it's a very simple function this is pulling it out of this data shot structure so if i step back over here at this point the return code is that but this is the value where it actually came from so that's what i want to find when was this set i'll do this the quick way we have a button up here so last change this is going to basically allow me to set the watch point we saw greg demonstrated this earlier but in this code setting the watch point on this value with 267 press enter and we run backwards to here where we detected this and fts 5 corrupt if i hover over that is it going to tell me what it is there 267 peak at its definition oh it's taking this time we'll ignore this for now it'll probably catch up in a minute but we can start looking at what's going on here so we're in our integrity check code this is good we looking at our table i'm not hugely familiar with the sqlite code i know what this is cuz i have done done this before this isn't the first time i'm not that crazy to try and do this live without seeing it but essentially let's have a quick look at what's going on ah thank you you've been really helpful so basically it's a define and it's to the corrup vab value it got there eventually so what we're doing is if i off plus n bte is greater than p leaf that's size leaf everyone knows what that means right okay let's look at this a little bit more ey off offset maybe integer that's great nb well nite is really defined just above we can see i off is being incremented by some value we have a get variant 32 so that's going to get a variable width integer this is probably a macro i don't really care it's going to read from the current offset at the time at the moment it's saying four if i were to step back to that then we did that the i off was fre at the time so we it takes one bite to read it and it's going to read it into n b so if i step over again we can see n bite is 11 so we've read that we've got ey off is four n bite is 11 so that's probably telling you what the size of the next element in data structure is on the right hand side p leaf okay well we can see size leaf is 11 p leaf is fts 5 data let's just have a quick peek at its top definition hopefully this one's faster no not unhelpful this is a problem when you got 200,000 lines of code it's like it's not designed to help you debug it but i can hover over this and we can see p leaf is pointing to the leaf element in the data structure the size leaf is one of the elements fortunately this h was telling me what it is we have a pointer to the data nn is the number of bytes and n is the size minus the header so it we'll tell you this in a second when it catches up but the size is minus the header being 11 is smaller than a small offset and a size of 11 i think the 11s are probably coincidence but i'm very dubious about ah yay we finally got somewhere and i bet if i str that over there we go now i wasn't making it up so size leaf is the size of leaf without the page index and then it's the sizeing bites and that's pointed to the data so i'm a bit curious about this size leaf value not least of all because if we look at this the nn is 65568 which always gets me a little bit cautious because i know my powers of two so what i'm going to do is let's find out where this value was set so i can use this again go back and i'm now even more anxious because we're looking at unsign 16s with powers of two which are just a little bit over so i think that this 11 is probably our problem let's have a look at the data this might be difficult for people to see at the back so i'm sorry i'll try and tell explain what's going on i'm just going to look at p p so we're looking at the data and we can see at offset two that's going to be that zero and that 11 is it unti n that's 11 so i'm very dubious about this 11 i want to know where that's come from what i can i'm going to use the command line at the bottom so i'll explain what i'm typing and i'll make this thing a little bit bigger so maybe people can see as i do i want to know what was the last time p-p three which is the actual 11 value changed and we've gone back here and we can see yep the value is 11 i had the right offset and we're in a m copy i'm going to assume m copy works i'm going to assume that i don't really care what happened to the destination i want to go back to the source so i'm going to do a little bit of funky maths here so last charar now i want the source point which is p payload and then my index into that is going to be this address minus long of the p buff i say i'm sorry for those who if it's at the very bottom you can't see at the back but basically the the address of that 11 is in the p buff at the address of the break point minus the address of the start of the buffer so that gives my index in terms of characters and i'm using that offset into the p payload to say this is the address that i care about that should be the address of the 11 the first time so let's go back and see where that came from good news is i've got the 11 again bad news is we've got to do the same thing so this time i can make it a little bit easier firstly let's get the address oh okay i have to type it let's type it properly then no shortcuts not for today so p cell close brackets open brackets minus long p data and we'll go back again same again last open char yeah i wanted to do lots of typing in this demo that's what's going on here p source let's get this address long of p payload hopefully this is making sense i'm bas bally tracking backwards i'm going to be very quick cuz i've just been the session's over another m copy this is looking at p this is p m zed brackets i'm going to get there ah finally we're there we're at the point where we were doing the put u 16 so be very quick we can see we're storing the 11 but if i had the reverse finish you can see actually we're trying to store this pbff n and the value is 65547 so we found where it got corrupted i'm going to be extra cheeky with your time and do a last on when that was last modified and we can see at this point we allowed it to go from 59,000 that would have fit in the u6 offset to 65547 that doesn't and we seem to have been comparing against this page size so if we look at page size at 70,000 so last pgs see where that came from okay it came from a constant from the configuration and then and here we are we're setting it because we've requested it we're checking that it's not less than zero and not greater than this max value that max value is the issue here because we've allowed it to go over 64k it shouldn't be allowed to go over 64k that's where that's 128k for those who can see it so we've range checked this we've tried to set the page size and we've allowed it to go too big for what our data structure can actually implement rather than letting this go because we're out of time if i go back to the ticket if we look at the timeline we can see it was raised and there was a a fix that was checked in and if i look at the check-in fix i did this cu i was the network wi-fi was going to work so i've got the pages open we can scroll down and see that that fts 5 max page size was 128 and the fixed us to make it 64 so that has to be the most courageous live demo i've ever seen thank you chris hopefully you kept up that was yeah that was yeah that was quite something so like that was like how many three four five following the corruption back all the way to the source so i'm g to ask one more time who's going to go and try some kind of time travel debugging now have we changed anybody's mind there we go pretty much every hand up i think that was all for your demo thank you again chris that was absolutely brilliant so sorry sorry that we ran over a little bit but thank you