migrating millions of lines of code to typescript on sunday march 6th we migrated strip's largest javascript codebase powering the stripe database from flow to typescript in a single poll request we converted more than 3.7 million lines of code the next day hundreds of engineers came in to start writing typescript for their projects that's a big ass pr seriously unreal i remember a short time ago laughing at the idea of typescript ever landing at stripe and then i woke up monday morning and it was here thanks mike fix typescript is the deao standard for javascript typechecking and our engineers have been overjoyed by this migration we are sharing our typescript conversion tool on github to help others perform similar migrations okay okay so they are obviously going from flow to typescript by the way this should be just a good little mental note for everybody the next time you're hyped up about the greatest and latest javascript thing just remember that for every person that gets hyped up about some latest and greatest typescript javascript thing there's a company 5 years down the line trying to figure out how the hell do we get off of this old ass janky piece of system that somebody you know that was great at the time but now sucks just remember that just remember that most types or most react today are still classes legacy systems are real people functional components came out like 8 years ago and people are still just it's just classes classes everywhere i think a lot of people forget just how long software can be around when you write software you write it as if it's going to be around for a year and 90% of the time you're right the other 10% it's around for 20 years and you have some that i mean cobalt still exists for a reason today people if you if you just don't believe that just remember go look at cobalt and then you'll be then you'll remind yourself oh yeah that's why stripe has built a large scale frontend application since 2012 including stripe.com stripe.js and stripe dashboard as our company grew we increased the quality and reliability of our products by typechecking our js code in 2016 it should i mean should put you should put the word linting actually okay let me just put my fedor in 2016 we were an early adopter of flo an optional type system for javascript developed at meta then facebook since then flo has provided type safety for the majority of our frontend applications i have never actually really seen much about flow is this flow well i mean so far it it looks the same i wonder what that plus sign means example of generating flow type from an api resource and associated endpoints okay however engineers had trouble working with flow the type checker's memory usage would lock up laptops there's something so beautiful about this i mean remember typescript is is huge all right when you run typescript like if you run just right now if you go and run two separate files on just with typescript you'll probably use two three gigabytes of memory unironically here i think i have this thing around here just test yeah i can't remember how to how to actually run this bad boy cat package was i smart enough to leave myself any bread crumb no i wasn't let's go like this npx just oh yeah oh yeah oh yeah i left it around oh yeah we left it around boys all right so i'm going to take this thing i'm going to grab i'm going to grab this little thing right here don't worry it runs for 45 seconds it has a 45 second wait personal v vm rss vm rss paste that in there you go look at that here's the best part is this is like a generated small little project right here i r i'm running two tests look at all those empty node instances for no reason this is just how many cores my computer has it's 1.1 gb on on nothing it's two tests plus a whole bunch of just empty things running this is what just runs this is just run just which runs a shell which runs node which runs the amount of processes you have as nodes the in editor integration was frequently slow and unreliable meanwhile typescript and alternative type system developed at microsoft exploded in popularity thanks to its tooling and robust community typescript availability became a top request among engineers at strip i mean typescript the the lsp for typescript is pretty good it's fast it mostly works there's some gripes one could have about it like one thing that's really like if you've never worked in another language you may not realize some things that are really awesome and so one thing that you may not know if i'm in here and i'm working on a project right here right and i delete this and i run trouble i will get every single file in which i just broke okay here's every sing file that i just broke with that thing and some breaks that i just have if you're in typescript land what's going to end up happening is that only the files you've like told typescript about are they going to do and if you have a smarter system that actually does it for you it's really hard to say like what files should typescript tell you is broken because typescript itself doesn't have the knowledge of the bundler because you have to know where your entry point is what's running right like there's like a lot to it and so you'll get these kind of weird experiences typescript is great it's much better than than that than the alternative but it's also difficult you don't get the whole thing like go is also really great right you go you you make a small mistake in go and it'll tell you everywhere immediately in like zero in zero seconds it's great it's a good experience typescript is at least a second rate great experience which i think is a a dramatic improvement in javascript land stripes developers productivity team aims to provide our engineers with the most productive development environments of their careers and delight in our tools are crucial for that we work hard to identify the most pressing issues affecting developers for example we've built integrations into all of our development tools for reporting friction oh that's kind of cool i think this is really cool i love the mentality if you are a company of three people this is not important if you are a company of 30 people 50 people 100 people this is so important the care for internal tools is just so hard to sell but it is such a multiplier in productivity you just have to like lsps are not hard to create lean into it you have some proprietary configurations build an lsp link out to documentation make it easy for people just to use you internally right like just just go all in on it and so like for me it's just it it's just all about that which is how how well can you build internal tools and so i just love this i absolutely love that they're taking it most importantly it mak stripes sound like a cool place to work honestly which is quickly routed to the responsibility teams and prioritize typescript support was one such pressing issues and team supporting front-end engineers began to plan out supporting typescript across the company choosing the right migration strategy which was all of it at once our largest frontend codebase powers the stripe dashboard and other user facing products the dashboard codebase has tight coupling between disperate components and no cleanly factored dependency graph an incremental migration to typescript would force developers to work in both languages to accomplish common tasks we would also need interoperability layer to sync between definitions between both languages and keep them consistent throughout the development process that's a yikes from me prime got a different definition of friction he's moving so lightning fast that friction going to friction i'm not even sure what that means to tell you the truth in late 2020 we formed a new horizontal javascript infrastructure team a group of engineers solely focused on elevating the experience of writing js at stripe one of the team's first challenges was to replace flow with typescript with a long and uncertain migration we began speaking to companies who had ran into similar migrations and reading articles from air table and zappier describing their experiences these companies developed automated scripts to convert one language to another ran them over their entire code baces and merg that output as a single commit air table had published their conversion script to github as a source to source conversion tool or code mod that would parse flow i mean this is super cool i absolutely love this i did a like a semi similar experience i don't need it anymore but i had this really annoying problem at netflix where i had this untyped database database by the way and it would just send down just gallons gallons of just json objects so i made something called undefined and which would take all of the objects i'd feed it like like 3 million objects and then it would like union and collapse and create and then you could start naming it in config each one of the names or else it just give you like event one event two event three or whatever you wanted to call it and it would just build out this entire definition based on a huge amount of just untyped json very fun it was a fun project but generating types is hilariously fun can be great but man is it also a pain in the ass i can't imagine flow to typescript i'm sure there's these weird edge cases that are super annoying migrating in this way would greatly reduce the cognitive overhead for engineers who would not need to handle both type systems for the same product behavior we could have a clean break between flow and type script imagine the next day like after you put this in imagine what would go and how many bugs you'd have to deal with over time so you're saying you built quick type i don't even know what quick type is but something like that only prime would name a project undefined yeah it was me saying i hate you because the best part is is that when you required in you have to require in undefined super funny we are really impressed by the quality of air tes conversion code and decided to use that as a basis for our migration efforts many thanks to the the team at air table for building this out and sharing their work the open source community benefits a ton from examples like this we began by copying air table's code mod to stripes mono repo to run against our internal code our javascript projects make heavy use of sale a shared design system of strictly typed react components i don't know what this means so that was our initial area of focus we generated typescript definitions for sale rather than converting the code to typescript it would continue to support applications written in flow to safely support both type systems we wrote tests to verify that typescript definitions against any changes to underlying flow code this approach would be too cumbersome for a large code base but thankfully the sale component interface is explicit and quite rigid from the outside this just seems crazy the core code model was solid but not comprehensive for many files it would crash to generate imperfect output over several months we iterated to handle most syntactic and semantic edge cases for one example javascript arrow functions can return a single expression without a return statement such as the following y javascript object literals uses braces to wrap the definitions because those braces are used to delineate blocks of statements returning an object from an arrow function requires an additional are they not using some sort of like parsing tool apra or whatever people use these days we noticed that code mod was incorrectly stripping the extra parentheses from these arrow functions but only in the case of generic functions a function that takes a type argument which is syntax not available in standard javascript by the way i would say the bad isn't that it's not being handled properly it's the fact that you're like people got to stop i am perplexed at the usage of arrow functions i am okay i'm perplexed by the use of arrow functions and c and cons like this i guess i just don't understand it it's not it's not even like it's smaller right it's not like function fu it's not like you're saving it's not like you're saving code you're not doing anything more glorious here like what what are you buying here what are you what are you buying here yeah it only i mean if you're doing this i would just i would have so many questions the chainer's like well it makes sense if you're doing something like array map right like this actually that makes sense right we can all agree okay this is a good use of an arrow function but you're defining it like a function that's what i don't understand is like you are clearly creating a function i just don't get it hoisting no one relies on hoisting none of that makes any sense standard languages for the last forever other like every language other than c when you define a function x it is expected to be within the scope of x like that's just an expectation so you call x here you can call x here like this is just like it's in rust it's in other languages people just expect these things to exist in fact it's super annoying when you have to define your functions in order making it named function gives it better error message it does it's nice people love ligatures right i don't understand why like i get it for you know you're just having a small anonymous function or you're actually using this like there's a real reason this it makes sense i just don't understand it as like a top level function it's just like just yo bro just write function you're not you're not buying anything once sale was unusable from typescript we worked on a couple internal applications containing hundreds of js modules we also added a second pass to code bond to suppress errors in the generated code using typescripts ts expect error comment to tag these errors rather than resolving every error ahead of time we focused on eliminating flow as soon as possible tracking typescript error suppression to address the conversion after initial pass on the dashboard codebase created over 97,000 error suppressions with our interative approach updating the code mod we are able to get that number down to 37,000 or about one per thousand lines of code 3 7 million lines of code did anybody else catch the 37 million lines of code what the hell are you building you'd have to type one you'd have to type a line of code a second for a year and a half to get that much a th000 time a th000 is a million so 37 1000s would be 37 million just add three zeros dog just add three zeros right here you don't obviously they don't count node modules because node modules aren't in flow man this is comp dude rick rich clearly is here rich and brad and tom combined made 37 million that's just c i i'm having a hard time fathoming 37 million any anything okay like that's hard for me just to even think about both flow and typescript support measuring type coverage and we are pleasantly surprised that typescript reported higher coverage than flow even with the suppressions we attributed that to an increase in the number of quality or third-party type definitions available in typescript the lack of which was a large contributor to poort now i got another question about javascript type coverage here's like a no no of javascript that you may not know const fu fu equals json oopsies what is it gu right json parse you know some string right remember what comes out of parse is an any so it's like do you have code coverage here do you have type coverage i don't think you have type coverage you have type assumptions so you have to have something like zod right you have to have something as zod a lot of people don't realize how tricky typescript really is cuz typescripts not tricky when you have the things defined typescript is tricky at every place in which you have some sort of contact with some other world or where in any can exist that is why we have ambient declarations to make json pars return unknown yes i think that's matt did that right he did that whole like fixed typescript thing that was a very good i think that was a very good move ts is great because it can give you false sense of security ts reset that's what it is as we moved our dashboard with its tens of thousands of modules our approach created significant memory pressure on the typescript compiler our primary tool to address this was typescript project references although the dashboard is not structured as distinct modules we could infer a module structure and create project references based on that this approach gave us a headroom to run typescript over a code base without refactoring large chunks of application code all this makes perfect sense i don't think you're going to get away from the memory problem at 37 million lines of code like typescript is going to use 20 30 40 50 gigabyt of memory i don't see how you're getting away from it you have too much code and typescript and javascript aren't light on memory so it's just super hard it's 3.7 it's a typo how do you know it's a typo i you know what i'm going to i'm going to i'm going to believe you it's a typo oh it's in the typ oh nice you're right it is somewhere near the title i'm not sure where it is but i'm sure it is you're right it's right there okay cool but so you're right it is 3.7 million so it's a typo it must be one per 100 lines of code but i still have a question 3.7 million lines of cod that's still huge are you're right it's better it's still crazy all right going live hundreds of engineers contributed to the dashboard each week such a sweeping change would be exceptionally challenged to merge in normal working day so our team decided to commit to a date march 6th a sunday where we' lock the stripe monor repo and land our branch in the week before merging we focused on passing a build through our ci system and deploying it to our qa environment although typescript could successfully check the project other tools that process our source code es lint just webpack metro would also need updates one particular pain point was just snapshot testing oh really just generates snapshots with a hard-coded reference to a test file that generates them since our code mod would generate either a ts or a tsx extension for typescript files the snap snapshot would have invalid references back to their test sources we simplified by switching the generated to only use tsx this meant we could write the snapshot in bulk and keep 100% of those tests passing i mean whenever you do this kind of stuff this is what you're getting by the way in some cases we recognize that fixing the code of our typescript compellability would add weeks to our schedule one set of cases was our custom es lint rules we had a rule to reorder imports to enforce consistency between files i hate this by the way i hate this i honestly see no value in reordering inputs alphabetically can someone help me what what's the purpose helps people with ocd you know this is called exposure help right you slowly get first off it's not ocd okay you're just being an okay there's a difference between ocd which is a real medical disorder and requiring other people to organize their imports alphabetically that's just called being an there's just a big difference between the two i don't know who's organizing imports i have never had any i i don't i don't understand it group by imports by type yeah i mean i've seen people do this but again like i think all of this doesn't make any sense any anymore let's keep on going with passing buildin hand we reached out to our product teams with user facing functionality in the dashboard although the dashboard has extensive unit in functional testing it has limited end to-end test coverage this made manual testing by product stakeholders crucial those tests highlighted some minor bugs which we resolved during the final week in one case we are failing to load any translation for non-english dashboard users due to a hard-coded js extension in the translation landing code damn that sucks funny but that sucks this process gave us high confidence but there's always uncertainty with the change this large although we had a fir grasp on our developer tooling and build processes we were mutating every file in the codebase subtle errors in our conversion scripts for example removing an empty field from an object shared between multiple components i mean i think it's interesting i mean i don't know if you've ever done any sort of migration it's it's really really hard to migrate large amounts of code and this is clear on saturday march 5th the team generated a new migration branch and ran automated scripts when we deployed that branch to qa and repeated our validation process and including manual testing suggested by products team we found no issues man such a good feeling people tell me that's not a good feeling thanks to our caren rigger of the previous year's work we had no unpleasant surprises as we shifted traffic to the new code we unlocked the repository and let developers know the dashboard was now in typescript crazy imagine the first try imagine the first try on that that is awesome good job team the conversion was not perfect over the subsequent weeks the js infer team addressed issues as they arose natural one example we didn't anticipate was engineers reporting inconsistency between ci and local typescript runs yep makes sense typescripts we are able to use many third-party type definitions installed from npm and if those are updated engineers will need to install new versions yep this was different from our flow configuration where dependencies updates rarely changed types so we had to educate engineers about running yarn and stall as a  just i just i just love the fact i i just love it i just love it i love the fact that we live in a world in which our interpreted code you need to delete it and reinstall it regularly to ensure that you're having a good experience like there there's something about that just just tickles my fancy beyond anything else there's still more work to be done we know performance improvements further with our granular project references and better caching could speed up our ci runs however the benefits have far outweighed the bumps along the road engineers enjoy features such as automatic dependency imports and code completion as well as typescripts communities extensive corpus of third already type definitions and integrations yeah these are all great things having an lsp is a good thing can we all agree having lsps is a good thing when new engineers join stripe to write front end code from day one they can be successful in a language which they are more likely to be comfortable and familiar i really hate this statement which is i think the reason why we have so much javascript to begin with if you call yourself an engineer and yet you don't feel comfortable switching languages you're not an you're not a you're not an engineer if you're an engineer you you're solving problems if someone said i had to use objective c which i did have this happened at netflix i wrote a multi-threaded client in objective c my first time ever that's just life that's called being an engineer you have to just simply do what you got to do now if you just want to be a react andy go be a react andy no one's going to hey no live your best life okay if that's what you want go do it first try literally first try and it ran on it ran on ios for six years 7 years wrote it in like a month and a half it was a ton of fun i had a ton of fun doing objective c because i just made it fun as opposed to making it shitty sometimes you just got to do what you got to do anything but java i've had to write a lot of java i was the first person to spearhead metric reporting at netflix we had this problem where we had all of these images for all of our originals coming out and you have all the images localized to every language showing up in production and we didn't realize which ones were and were not so what did i do i took that system that we already had for fetching images and i started putting in a bunch of reporting and i just created an entire reporting i called it atlas mantis logger or aml it was monad likee it was monatic so you'd keep on it was pretty fun had this like fun little approach we did to it but it would allow for atlas logging which is like this persistent counter gauge graph and then mantis logging which is real time so you could actually just log on put in your like computer and it would just flow through and show you what's exactly happening in real time as you scroll through the website to go okay this is where we're failing or it would go into a persistent long-term one so we could actually say hey images are identified as being missing in these languages for this video ide go make sure that they're there boom right and that was all in that was all in java that was fun i had a lot of fun doing in java too what's a monad a monad is a burrito when we shared our story of our migration publicly the response was equally enthusiastic developers from across the industry reached out to learn more and apply the same improvements in their own code bases to support these developers who were sharing our typescript conversion code on github nice nice aside from the particulars of javascript or flow or typescript our big lesson from this migration is that dramatic improvements to large codebases are are possible with diligence commitment and optimism we will apply that mindset to other opportunities make our engineers more effective and hope others do the same nice i like it this is a great article this is a great article and i think there's a lot of really good lessons here that i i i genuinely like i love the idea of of going for it making large changes trying to make people's lives better i love the idea of having internal tools as a first class citizen as like a this must be done this is in incredibly important i just think that that is such good companies i get burrito comparison yeah you know you got your outside and your inside you know what i mean i don't know everyone keeps calling monads burritos i don't understand it but anyways i like the horror stories instead yeah horror stories are good but horror stories you learn just as much from as good stories this one had a really good meaning and a really good takeaway which is we really should take internal tools and internal tool teams as seriously as any product facing team because any internal team that has a lot of support will produce tools that create user-facing teams to be sign significantly more productive and at the end of the day that is what you're concerned about reliability and features the name is the primagen