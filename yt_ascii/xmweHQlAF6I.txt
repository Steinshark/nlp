uh okay so as as mentioned today i'm gonna talk about exceptions and i hope you find this stuff interesting but let me start with introducing myself so my name is inba levi i'm a c plus enthusiast i'm also an embedded software engineer at solaredge and i'm working on smart home devices i'm one of the organizers of core cpp conference and user group as anz mentioned a member of work group 21 and one of the founders of the israeli national body so we we just voted on simplest 20 that's i think it's a great start and i've studied physics i also love math so if anyone wants to talk with me about math later you're almost welcome so let's start with motivation so exceptions are are a mechanism that is widely used on c plus plus in general but you might be surprised to find out that quite a lot of the of the developers don't use the exceptions mechanism nicodem fully you can see here a survey from ezo that suggests that around 54 more than half of the developers don't use exceptions freely in their code and this is a survey that i did might have seen it on twitter via the core cpp account that you can see here that also quite a lot of of developers are working on on embedded systems or performance sensitive systems and so i'm sure that if i would have asked you you you would say that similar percentages are are working on exceptions so so i think it's very interesting so as i mentioned many industries and they don't they don't really use exceptions mechanism as as fully as as we would hope and their handling mechanism you might be surprised but it's it's also been addressed quite recently by the direction group which is a group of of the people in the committee that are mostly they're trying to address the core topics of simplest plus and they they have addressed their handling mechanism via contracts which is also a way to i it's it's relate it relates to preconditions but it's also a way to to address problem errors in the code and and to and to deal with with the decision-making result from it another thing sorry another thing that was also published quite recently was a paper by herb sadder and i'm sure you all heard heard of it zero overhead deterministic exceptions throwing values and in the last uh meeting in the last word group 21 meeting that took place and took place in february we also saw a very interesting paper the exception sorry low cost deterministic exceptions for embedded systems so it was also discussed quite widely so to conclude i accept i expected the error handling mechanism is going to be addressed widely in the near future in simplest standard so the outline for my talk is we're going to start with history and domain we're gonna look at exceptions overhead we will overview the design then we're gonna go over some alternatives both both proposed and things that are you know potentially might be potential in the future and then we're gonna see some some some directions for the future for you if you wanna if you wanna be involved if you wanna if you take interest in this topic and i hope you're i really hope that you'll find this inspiring so i just wanna i just wanna have a few disclaimers this is not a talk about best practices of exception usage there is a very good talk by klaus that i think yeah it wasn't cpp uh cp con 2020 so if you're interested in how to best use exceptions in your code you're most welcome to watch that talk and it's also another talk about a library the the code here is poc and concurrency i haven't addressed concurrency since at least in my industry it's less it's less relevant but but i'm sure that's also a very interesting topic you could expand on and i'm also addressing some of historical references but i wasn't there so take this as as it is so let's briefly go over the history and i'm not going to go into too many details but on the history of exceptions but i do want to have some point some points so in the beginning we had c then came c with classes and then came c plus plus but actually then came c plus plus with exceptions because exceptions were dealt with very early in the design of the language so just to go back a few years we had two main ways to deal with with errors so the first one was error codes just like we do on c and currently also doing on simplesplash in some in some cases and the second way to deal with errors was by using global it could have been erno it could have been some user-defined global these are just you know general design guidelines but we had those two main ways to deal with errors and just notice that here for the return value we have to propagate the return value throughout the calls so if bar was calling foo here then we have to take this all the way up to to the main and by using global we could basically skip so so the functions that weren't interested in the result didn't have to to address this didn't have to use this mechanism so i want to quote from design and evolution i think it's a great book so in the original design of c plus plus exceptions were considered but postponed because there were there weren't time to do a thorough job of exploring the design and implementation issues and because of the fear of the complexity that might add to the implementation to an implementation so it's true that exceptions are not a simple topic and i think it's it's very interesting that even in those years and remember this was really in the beginning of of the design of the language the problems already came up also in particular it was understood that poor design could cause runtime overhead and significant increase in importing times so as i mentioned they were considered very early and on the first standard of c plus plus you you can already see that there was a section addressing exception so the following inceptions were made regarding the exceptions usage so exceptions are used primarily for air handling and they're also rare and comparing to regular functions and and regular logics they as i said they occur infrequently and their language level concept so again this is a firm i haven't mentioned that but this is from the first paper that was trying to to to design the first exception handling mechanism which eventually led to the version that we had in the first standard so let's briefly look at the exceptions overhead and again this is not a talk suggesting or trying to address whether to add or not to add exceptions in your code this is of course your decision but we're basically i'm trying to focus on the overhead that is created by them and how can we minimize that so first of all just to mention the main difference between c and c plus plus is the cleanup progress so basically c plus plus by having constructions in the structures adding the cleanup progress to the language and by using a long jump and said jump that is can be widely used in c it is a topic to be to be discussed on but it's it's usable then we basically if if we would have used that and simple source would basically break the contract between the user and the language i also want to just clarify two terms that we're going to wisely use so there's a happy path which is the default scenario with no exceptions or error and the sad path and here in this talk i've mainly explored the said path just as a side note msbc actually supports a different behavior in said job in long jump etc but that would be something something that is unique to their implementation it's not something that is settled between different implementations so i've created a mini benchmark for exceptions versus error code and again i'm only focusing on the set path and you can see here that i'm returning three i'm foreign three types of exceptions versus returning three types three different error codes and you can see that the size of the sorry the size of the error code so this is the throwing three exceptions and this is a return value and you can see it's rather rather close on on on hosted devices but on embedded systems for i've used in this example on arm you can see that makes a great difference and another thing that you can see here is the difference on runtime which is by no doubt is trump like a significant significant difference between those two two ways and as i mentioned the clear observation is i mean you could do this benchmark on your systems and and you know if it's this this example is is with linux os but you could use it also try to do a sort of things in your systems but i'm pretty confident that you're gonna get a similar results or at least the the the major general notion of so i'm sure we're clear on having the fact that exceptions are slower than the return values and also as i mentioned it depends on your on your system you might find a bigger bigger difference so there's two main implementations for exception mechanism now we're gonna go deeper into how are they implemented so the first one is table based so gcc and clang they both use this method and i focused on this because it's creating better results on happy path now again i haven't addressed in this talk to happy path benchmarking but i think it's it makes more sense to to have this assumption because we want to have we want to have the regular code run as as you as you hope with better performance and the the code that that fails the the error handling to be slower but it's of course up to your system i just felt a more suitable and also aligned with the assumptions that we've seen in the in the history part the other option is the frame based and it's used by msvc and this this one gives a better setback results so table blast implementation have the additional overhead or headings to the program so first of all we have to have our tti to in order to identify the exception type that is thrown and another thing is the exception handlers have to be defined and again on gcc implementations they're something that's called landing pads so you have to basically you have to add a function a callback to handle the exceptions and it catching function contains additional information so so you have to be able to tell which of your functions is is catch can catch this type of exception so this is additional additional information that is kept regarding the functions so i've added here the general just you'll be able to see the amount of code so basically the functionality is split into two like main libraries so you have lib gcc which contains the functionality of stock unwinding and the libs c and again this is on gcc and it contains the functionality of exception handling so again you can see here the amount of code and the mechanism is quite complex so the stages of exception raising so first of all we allocate the exception by calling allocate exception function then we throw then we move to the lookup phase which is the phase in which we're looking for the for the function that can handle our our exception and at last if we in case we found this function we move to the cleanup phase which is the phase which calls all the all the cleanup [music] functionality per frame so in case of a failure so so the exceptions can be allocated with unlimited size but in case you can't allocate the exception because your system is low on on memory then you have some kind of an emergency buffer and it's also limited to up to four exceptions and there's additional conditions that regards to multi-threaded environment but again i said i won't be focusing on on it here but in general you could you could end up with problem activating this mechanism as we probably all know one of the problems of exceptions is the fact that they're undeterministic so we basically don't have a higher bar to limiting the overhead for the mechanism so the stages of exception raising so as i mentioned we would start with the luca phase and we trigger stark unwinding with the flag of unwind where's exception sorry with the flag of search phase for the function unwind raise exceptions and in case we fail we call to stood terminate and in case we succeed we get the we get the handler found and then we start the cleanup phase so the cleaver phase is basically going the same routine with cleanup face and the cleaning we start with calling the personality routine that i've i think i've mentioned before it's similar to it's the it's the part that actually handles the exception and we once we finished cleaning the the specific function we continue with unwind resume when you reach the stack frame which the with the proper catch we're calling begin catch and this is actually the thing that's supposed to treat the exception and then we can we call the end catch and in case we fail for some reason to to deal with the exception we might terminate and if we if we haven't also if we also haven't found the proper the purple implementation we need to move the past and exception on we can also call rethrow and eventually we'll continue unwinding so i've did a small uh draw because i think this makes things clearer so as i mentioned let's quickly go over the progress so we have allocating the exception by the subroutine that in case this subroutine was the one that failed and then we in case we can't allocate we terminate terminate the [music] program in case we succeed we continue then we throw and we start the lookup phase and we go over up the stack and look for the for the catch that actually handles our exception if we haven't found again we terminate if we have we go back to the first subroutine we go back to the beginning of the stack and then we start the cleanup phase and as i mentioned we look for the catch and we catch and in case we found the catch we resume the execution but after after that we we look for the finally block if it exists and if it doesn't we just resume execution so i'll just this is a small shorter version of my talks i want to briefly go over the designs decisions that were made of but i also want to address the general principle that i'm sure again we you're familiar with different different types of of errors needs to be handled differently in the program so on general the the the general direction of the comedian and you can see it in her paper as well is to have the to minimize the use of exceptions to the ones that actually are actually relevant so basically we don't want to throw logic errors and we don't want to throw recoverable errors as exceptions we might want to consider dealing them as part of the logic or as part of the other ways to deal with failures in our program and the things that are should be focused on are error that invalidate the program or are that that exhaust resources so again these are all the assumptions that were made regarding the first mechanism i just want to focus on on the ones on red here that they're marked so the again this is from the basic design so we want to be able to catch a group of exceptions we want to be able to catch arbitrary amount of information and we exceptions used permanently for error handling so i think we might want to consider to catch a single type of exception the amount can be limited to suit to our embedded systems and instead of having using this primarily will only be used for handling error handling so we'll avoid things like logic manipulating throughout the exception mechanism i mean it's clear but some languages might do it differently so there are some projects that actually use the try catch blocks to to to handle the logics so i would assume we don't want to use it we don't want to do that on c plus plus so general review on on what i think we should do regarding this this mechanism so do the sub routine and the one that wraps it up and the program wraps both of them sometimes we have the os and we have the platform and these are true for old all types of embedded systems but today we have some sometimes additional things for example we can have the connection to the cloud so we basically could decide that in case of an error we're gonna send the information outside and we also have more commonly since resources have been increased we also have additional programs and we could also have additional platforms so i'm just gonna read this quote again from the design and evolution and i really agree with it no single unit of a system can recover from every error that might happen to it and every bit of violence that might be done to it from the outside in extreme cases power will fail or memory location location will change and its value with no apparent reason so we need to be able to identify which are the errors that we want to have in deal with in our program and which ones are things that beyond the scope so to move to the alternatives some technique is some techniques sorry of acception mechanism can improve your performance the exception mechanism performance in your code so you could basically use the current mechanism and optimize for example by minimizing the number of exceptions to different types of exceptions you could override function calls from libstud plus you could re-implement parts of lipstick c plus plus and these are of course going more advanced topics and events work but it all depends on your on the things that you need in your system and you can use alternative mechanisms such as msbc's structure exception handling mechanism so i basically focused on one and two so this is an example of code that is trying to minimize the number of different error types thrown and you can see here that so first of all throwing one type of exception compared to return so you can see here that the ratio is actually increased so this shows us that just by adding the exception mechanism we only get the penalty and it doesn't really matter if you use a single for a single type of exceptions or multiple types of exceptions this is the the thing that creates the the overhead and the size is again quite quite similar though you can see a bigger difference and you can see on arm again that the size difference is bigger and if we'll compare to to throwing different type of different types of exceptions then you can see this is quite close ratios and again so my own platform you can also test it in your platform so i'll generally say that from here we can learn that the the overhead is added just by adding the exception mechanism and that just limiting to minimize the num the different types of exceptions thrown is not significant though i would expect it in a big project of course this is just a code that was created specifically for the example so i would expect that on on different code bases might be different results so i would recommend you to to test it so the second thing i've i've tried was creating the overloads for the libstud c plus plus and in this case we can see here that there's functions throwing and you can see that the thorin function is drawing some kind of exception and we over we hide basically hiding the functions we saw before for allocate exceptions and throw all right and here you can see the size of the exception i'll show it on the next slide but basically i've also used a predefined buffer for the exception instead of dynamic location so this is the allocate exception function and in case it fails to allocate its terminates otherwise it returns so i mean otherwise it returns the buffer of course it can be a every type of a fail we can we can basically decide what we what we define as a failure and here we can have we can see the throw function and it basically doesn't do much so i could have we could add here right to file or report to server or any any other thing that suitable for your specific environment that you wanna that we wanna use and then we exit of course we could exit not with success but with other things and here as i mentioned you can see the size of the buffer is defined globally so it's not dynamic allocated dynamically allocated and you can see they call for constructor and fail and exit so comparing this thin firm version to throwing an exception a single exception i get the ratio that is very similar to what we saw for return values versus exceptions and that means that the thin fro is actually sorry the thin furrow is is is very close to the to the return value in in performing performance wise runtime performance wise of course the size is still something that is added since we still get the rtti and the and the london and landon functions and the functions that can identify what whether the the exception is belongs to them or not but but it's still i think it's still very significant findings so i think it's interesting to get the performance again so similar to the one for the return and again this is not a production level code but this is trying to show we can actually customize the mechanism so here i just want to show my sort of my ideal throw so i would hope that in the future standard we're going to get some type of throw that we can customize and and uh pass some kind of a callback or functionality to it in order to determine do we want this to do we want this failure to to perform the unwinding etc and here in in this code you can basically see that the subroutine is passing the information to the program but we could also define this globally and in that case the program will definitely will basically define the the handling mechanism to the subroutines underneath it so let's focus on shortly on the few alternatives currently exist in the committee so the first one as i mentioned is the zero over deterministic exception foreign values herb is proposing a few different things here so first of all he's proposing that first of all he he identifies that we use exceptions too much or in different places that were originally addressed so again using exception for logic errors would probably give us very bad performance and we we don't need we don't need to use them to manage the flow and another thing that he mentions is that allocation failures or what i've previously addressed as exhausting the resources is a different type of exception that different type of error that we actually we we might want to use this mechanism for because this type of an error says that we can continue executing and and we also have some concrete proposals regarding the performance so he basically suggests and this is again this is a common this is relatively common nowadays at least there's a library called outcome also doing this specific this specific thing but i basically suggest to have some kind of a union that returned from from the function and this contains either success or the the values for for the success or the the error in case of a failure and a boolean that's just which one is it and i just want to emphasize here this is of course returned on the stack and this is not something that the the developer should implement this is a code that would be implemented from the compiler in this example and unlike unlike outcome for example and it also suggests that we could predefined the the allocator to report the error or to do other things and i think the notion of having the the the error mechanism to be suitable for your own program is something that is widely addressed in the committee nowadays i would hope that we'll get a more custom customizable mechanism in the future so as i mentioned again comparing to what we saw previously here the program is basically defining to the different subways how to handle the errors and the other paper that i've mentioned low cost deterministic exceptions is also very interesting and very promising this is actually showing implementation for trying to implement some of the things that herb have mentioned in his paper and we get here replacing allocated exceptions on things that are returned on the stack or kept on the stack and there's also some globally allocated memory here to to deal with the to to handle to help the mechanism but it's not it's not it's a basically a limited size buffer and we can also we throw by using this buffer globally allocated buffer and and and again some of the some of the principles that were addressed in herb's paper are implemented here with and showing promising results so i want to conclude with saying that you can create your own intelligence you could signal to a different progress or report to the cloud or write a file and you could use pre-allocated space as i've shown just by overriding or hiding the function that is in charge of allocating an exception you could have save the the minimal data that that need that is needed for example and and this is again this is an extreme idea for for certain cases probably only suitable for certain machines but but you could decide pre you could solder defined a table with numbers and and each number can identify a different error or even different location in your program you could just return this this single identifier if you if you think that's useful for your code so there's really different ways to address and to optimize this mechanism this current current version of mechanism but again i would hope that in the future the standard will address it and we'll have some better alternatives okay so there again as i've said other other mentioning of things in the standard relates to the error handling mechanism and i don't want to go too much into details here because this one's a shorter version of the talk but i just want to mention that there's some very promising directions and bloomberg is addressing the generally generally how do we address errors on on on debug mode or on on development stage versus the release code and there's also people in the committee that addresses the the question of who determines theirs so do we wanna handle their in the same place that in which we got it or do we want to handle their up the stack and just to conclude i think we should separate the semantics from the implementation i think we should allow behavior suitable for for the performance sensitive applications so we we should allow more customers while customizable systems and the overhead already exists and we already have the current mechanism already have its overhead so by having more customizable parts of the of the system we might get even a better better results for for broader spectrum of users and and just to again to to to i want to repeat this notion that the earth handling mechanism was really was really designed quite long ago and simples pass is about to is is turning 30. so we have we have to con to consider the differences that were made in embedded systems in the past 30 years and and we have to address this 50 of embedded developers that don't use the current mechanism and i think we should really consider the bigger picture i also added here the developer crust because i think that's more commonly these days we don't have someone that actually looks and errors or even even the logs we we have automated mechanisms that collect the data and and and we can have searches on these databases or whatever so it's also quite more common to have those types of error handling environments to conclude i invite you all to share your ideas with me regarding the ideal exception usage and i invite you all to to get this notions and to to to take them forward and to you know i think that it would be very helpful for the committee and for the progress of c plus plus if many people as possible would try and address those issues those questions those hard problems and give their inputs and i suggest that we'll rebase the exception handling mechanism on our on our code on a current simple sorry computing mechanism there currently exists and thank you these are all the links that i've mentioned and there's really a lot of very very interesting links here there's i just want to mention the proposal by ben craig two proposals by ben craig that do a more broader benchmark on on embedded systems and they're very interesting to to observe so i really recommend you to go and look for at them and i invite you all to send me your responses and your ideas regarding this thank you