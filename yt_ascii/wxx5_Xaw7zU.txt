zig helped us move data to the edge here are our impressions all right kicking the tires on zig with the greenfield open source project our company is a rust shop we love rust and we believe rust will be the main engine of our work for a lifetime but as a bunch of performance nerds we've been keeping a close eye on zig it evokes a feeling of simplicity that i long for the sea days yep agreed and comp time the ability to run arbitrary code at compile time is straight out brilliant idea welcome to costco almost as smart as me remembering to turn off alerts come completely agree so this is why i love the idea of zig it has the simplicity feeling of c but it also has calm time which effectively you get everything you need out of c plus right there so i love that idea like a shiny new tool we've been looking for a way to make use of zig in the shop rewriting existing production code really wasn't an option so we found a new project to give it a spin this article details our experience so i think this is pretty exciting our product or so if you don't know i am sponsored by tercel but i'm reading this article because other people send it to me because it's actually it's pretty great so just so you guys know this is technically not an ad though it may feel like one it's not one okay anyways it's an edge database if you're unfamiliar with the concept it's very simple if you're deploying your code in multiple geographical locations accessing your data from a central location will make your application slow you may not like it but a genius let's see but a genius a couple let's see but a genius a couple years ago proved there's nothing you can really do about it i'm talking about einstein not tom they know they know about tom that that's pretty good we already know where the link goes to we already know where the link goes to we all know where the link's about to go to we all knew what was gonna happen what what a play because of the limitations of the physical world the only way to get super fast database queries in both san francisco and sydney is to have the data replicated at both places keeping a database running in multiple locations is expensive which means to make this work you need a database that is extremely cheap to run that's why we use lib squeal they an open contribution fork of squeal light adds to that a lot of machinery to make replication simple and easy and automated and automatically route you to the closest replica and you have an edge database there we go storage costs replicating data everywhere does have a cost our reliance on a slim and mighty database helps us to keep the compute cost in check but for the data there's not much you can do about it want 10 replicas pay 10 times the storage makes sense this works for a variety of applications especially in the web where data volumes are low i have helped design a no squeal database before silo db that operates at the petabyte scale so low and high are always relative let's go around with the numbers storing a gigabyte of data on fast storage costs less than a dollar per month assume 25 cents to leave room for all markups storing 10 gigabytes of data will cost around two dollars and fifty cents per region we support up to 34 regions so if you deploy into all regions that's still 85 dollars a month for storage costs less than you'll pay for hubspot google workspaces or any other sas tool that your company depends on okay but even before we reached the petabyte level there are many use cases we'll accumulate will accumulate hundreds if not thousands of gbs and while you may have the money to spare the reality is that you don't need all the data on the edge some of it is just cold and you don't need it all the time an architecture that takes advantage of the edge while keeping the cost down is one will keep your database of record in a central location and then replicates some of the data to the edge clever right pretty clever the solution pt tercel to tackle this issue we built pg tercel a postgres extension that automatically syncs a slice of your data to torso it is completely experimental at the moment and not production ready we are making progress in productionizing it over the near future that way it works let's see the way it works is that your is that you choose a table or materialized view in postgres that you wish to replicate to the edge tables are often already a subset of your data a materialized view are standard ways of selecting part of your data for certain queries our extension then hooks into postgres local replication and materialize view refresh process replicating the changes right out to the turso database smart right this is actually pretty dang smart we built pg turso with zig the first reason why we may let's see why this made sense is that pg turso is a very self-contained and isolated project it does not need to share code with the rest of our database there's no need to rewrite production code or even take a dependency on zig okay the second reason was that there's already code in the wild written in c that was similar to what we wanted to do if we could reuse some of that code that would be a win postgres allows users to provide a logical decoding output plug-in which is a fancy name for your own replication routines postgres itself already has an example of the plugin to get you started cool right all right zig delivers foresee interoperability zig is famous for its seamless interoperability with c it even has cross compiler to transform c code right into zig oh that's cool i don't even know that i have never touched zig before and because what could go wrong so i just tried which it didn't work at all okay but that was just due to missing headers and to my a slight surprise zig translate include okay it compiled just fine dumping lots of valid zig code huh we still had work to do to make our extension but that's the start that's actually i didn't realize that you could do that you could just translate c into zig you could just like zig it's pretty cool the next step was to add some definitions about postgres module in the test code above was done with a macro which ziggs thankfully does not support for the rust people who complain about rust macros c macros are straight from hell they are they are straight from hell that required a bit of boilerplate code but still manageable and ergonomic to write predictably we are also going to need a few definitions from the postgres header interface forget binding generators and explicit foreign function interfaces in zig you just slap us a sim port ooh i got a lot of sim ports in the chat and call it a day all the c code available under an isolated namespace that's actually super cool i did not realize you could just you could just import and boom that actually just works okay that's pretty cool i did not know that about zig that it's it's it's it's actually that easy to just just make it happen that is cool that is super cool the support directive is based on the translate c which means that the header is translated to native zig code during compilation this is where zig shines it seamlessly wraps a c header into a zig structure as if it as if it yet oh my goodness as if it was yet another zig module where's tj to make fun of me and you are free to use all constants and functions as if they were native zig truly amazing this actually is like an incredible idea right here this is one thing about taking a known language not deviating far from the syntax or how it works and just fixing a few small things that's one thing i really appreciated about zig it's like if you're gonna write c well there's a bunch of things in c that kind of suck zig is just like it's really just slightly better see with comp time that's how i feel about it it's just like better c it's like go but the harder version it's just it's battle toads of go right there's there's the there's the easier game that you know go is more like the sims and and zig is more like battle toads if c is the father that's what you get out of it go but hard mode yeah debugging and cross compiling are smooth the way translate c works is that all the dependencies are cooked right into the final file this means the relevant parts of the c standard library also gets translated and added to the output that's very convenient because it makes the resulting a single source file self-contained a bonus of this behavior is that debugging deep issues the kind that always occur when writing system software is made much easier all the c dependencies the c standard library the zig standard library gets shipped as code that gets compiled along with your project that gives the compiler more opportunity to optimize inline and reduce your final binary to only what it needs but it also means you're free to edit the code yourself if you run into one of those unexplainable issues that could be coming from anywhere like we did huh another advantage is that it allows zig to shine in cross compilation in our company for example one of the reasons that led us to to code our cli and go is how well it cross-compiles to mac linux and even windows rust is nowhere near that yeah that's one of the i always hear this as an advantage to go and why i hear a lot of the devops stuff is is that cross compilation is just like top shelf in go translate c has some issues with obscure-code a great as great as they experiment with translate c was zig got some issues with some complicated macro constructs now say let's see now that same that says more about c macros than it does about zig i have mentioned how monstro c macros can be dude some of the worst things i've ever had the debug are c macros you get macros that call functions that call macros that call functions that call macros that call functions there was one in netflix for logging that was so complex i spent an entire day trying to trace it i could not figure it out i could not for the life of me in eight hours of looking at code figure out what the hell was happening it was just too difficult i hate pre-processor stuff it is just the worst the main issue is that zig compiler is not always capable of guessing the types safely in all fairness oftentimes with c macros humans cannot guess them either but reality is that the world of sia is full of those macros so expect interoperability to fail at times fair the good parts of russ are here judging modern languages like rust and zig needs to go beyond the language definitions the ecosystem matters absolutely it's one of the four axes of judging a language well the zika building process is elegant it would it wouldn't oh my goodness and it won't be a surprise for rust folks that have ever written a build rs script before zig is built on similar principles if you want to state that your code should be linked to the standard c library and compiled to a shared library you express that in zig yeah this makes sense i i've never you know you have to learn a little bit about zig to be able to build zig effectively in these larger projects but to me that's fine i'm fine with that a build system in zig forzig i'm okay with that another thing that rust hackers would admire is zig format an opinionated tool for formatting zig code so that you avoid endlessly bike shedding over code south i i'm i'm fine with that there's something about it no matter how much i dislike it which i feel like anytime you get four auto formatters nobody's technically happy therefore everybody's happy i kind of like that error handling is another ergonomic aspect of zig at first i was really confused when i saw catch unreachable yes idioms all over code samples but once i understood it it made perfect sense it also maps well to rust concepts it does very very well functions can explicitly declare if they may rate turn errors if they do you can use the try operator inside them which is conceptually similar to russ question mark it is it's almost identical it's the only downfall to it is that it's a prefix operation as opposed to a post-fix operation so that means chaining becomes hard you have to do things like this instead right so this just simply means that we're going to format this buff print we're going to grab some sort of offset starting from offset all the way through so we're going to do some sort of slice in here we're going to take the string null and do something with it and here's the options we're going to pass an anonymous empty struct with the default values put in and then just try that that means if there is an error we return the error else the value will be assigned to nothing right so very very similar to rest errors are handled by a catch operator yep you can do catch you can do a little catch air this is pretty cool too you can call a function and then call catch and provide a little closure right here effectively this is a capture group and just say hey give me the things it's pretty nice right i'm not a fan of the anonymous syntax truck yeah i think that it's a little weak i agree with it but it works uh and catch unreadable or unreachable as a concept twin of russ unwrap yes it aborts the execution of your program if an error occurs yep that makes sense right when an error happens this should never happen is what you're saying your program cannot proceed i miss ray zig is very opinionated on explicit is better than implicit as a consequent it lacks rust style destructors all the allocations need to happen explicitly the explicit allocations are definitely nice but it lacks destructors is a mild foot gun similar to go zig offers a defer keyword to let programmers create shutdown routines it's idiomatic to write code like this yeah you see this all the time right this is like super common in zig which it's nice it just simply means at the end of the scope we deallocated it's effectively like rust but you just have to write it it's easy to forget and easy to leak memory or hold on to resources yeah if you're used to rust or a modern programming language doing this again feels arcane you know i obviously do see the flip side of that sometimes you're not interested in calling destructors eg if your program uses arena allocators or creates long-lived objects which in rust are a bit painful to write absolutely still a person who forgets things i miss the convenience of default destroyed nature of rey and rust yeah i completely agree with this i wish there was a way that you could provide an interface much like try you know try also works this way i wish there was a way you could there could be like an auto destroy interface like if you just do if you implement this it just automatically does it for you that'd be fantastic as it goes out of scope i'd love that but i can see why they don't do that they don't like to do anything implicit using yeah using would be cool right anything inside the using we need a monad you could write a macro you could or a comp time thing the ecosystem is still maturing zig has http and json support embedded into the standard library which when i first did my work with it it did not you had to download it you had to import it it was not as nice which came in handy since torso is accessible over http however a lot of the cool features are only available in dev builds which daily releases and are explicitly described as not mature in their docs http support was one of them this forced us to use the newest dev release on our ci which kept breaking in backwards incompatible ways ooh rough and when we mentioned that having the whole library output the final file was handy for debugging that's from experience because of an issue with standard headers we couldn't get replication working ter so well we couldn't get replication working torso until it became clear it was an issue with the standard library we contributed the fixed back oh nice content length header was inspected by mistake which makes it effectively impossible to use chunks transfer encoding oh funny can't do that that's cool though that's cool that they're patching the hp stuff chunked chunked chunked encoding you know sometimes you just gotta have it kind of annoying but you gotta have it an experience cut let's see the experience of contributing to zig was really great the pr was promptly reviewed and accepted and landed in denver lease soon afterward but at the end of the day the issue issue that let's see an issue this central with http headers does show that the language has to to mature a bit before we can switch our whole company to it okay that's reasonable all right the verdict the overall experience was great zig code looks cleaner and postgres c api header is neatly hidden behind a zig interface and the standard library support for hp and json means that we don't need any external dependencies which has its own value i do agree with that you know i like the fact that i like when languages just provide the the things you need right i like that i personally want that i mean i know you can do saturday and then you can do saturday json and then you get it or you want some other version of the jetson you can use that as well but there is something really nice about a language just saying here is json here's how you decode it first class experience that is that there's something very i just i like that experience okay so like python like javascript or better be in javascript like not like rust though rust you do have to kind of you know get your own thing despite a couple of rough edges we remain incredibly bullish about the future of zig the future though is not yet here this was a great article [applause] i really really like these kind of articles because it wasn't too technically deep right we're not reading just gallons of code right this wasn't gallons of code to be read but it was perfectly to the point it highlighted everything i wanted to know about zig because the problem with zig is that i often build only toy projects i'm not building something fully like must be getting ready to be productionized meaning i'm making a really long-term bet on it and so for this is like a this is like a really good example of why you can make a long-term bet on it but you have to know what is happening and so generally how i i judge a language is like language syntax itself and then ecosystem that's really important and so the syntax itself and how it handles various cases like it doesn't throw errors it's just a must in today's languages i i hate using languages that throw errors at this point they're just so prone to the most thorny things and the one good use case is a global catch handler for a cli application that just terminates your program right like that's the only time i really like it and so zig really fulfills that the the community the ecosystem is pretty good blocks are pretty good so it is it is definitely poised to do something pretty amazing i think zig will win in embedded if we can really get the right you know if we can get enough people working on it which is kind of unfortunate that it takes a huge people but a huge amount of people to do that and i'm not that person but i think zig will win ultimately because zig is just easier to write it's just the right it's just the right thing you know anyways personal thoughts awesome links always in the description i'm actually pretty excited about dick i still think zig has a big future ahead of it i just don't feel like zig is there yet for me oh camel is actually i i'm really excited about oh camel i wrote yet another little thing in o camel this morning very excited about that you know i i really really want to see that so anywho the name is the primogen