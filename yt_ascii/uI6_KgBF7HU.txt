all right there we go all right oxidizing oh camel locality i don't know what that means obviously the last ones must mean something different but oxidizing oh camel let's do this this is brand new this is from jane street with me today of course is the young buck tj he has resting my hand in your or your my face in your palm there you go he has obviously a youtube channel and a twitch channel tiege underscore dv correct that's correct you can find me there and also twitter true if you want to see memes yep and okay we'll tweets yep a lot of vote camel tweets all right coming from ocam well the rust programming language has many appealing features oh yeah by the way why tj is probably what someone's asking because tj's been doing a lot of vocamo and has even played with this feature and i myself haven't for some amount of background this feature involves making oh camel have some features of rust around lifetimes correct yeah there's they're doing like a three-part series so hopefully we can do the second one later and then they're they're the ultimate goal is like eliminating data races completely so that's like one of the cool things that you can do we'll get there okay okay the rust programming language has many appealing features rust system for tracking lifetimes and ownership allows users to safely express patterns that are awkward in o camel such as stack allocated values and custom allocation schemes managed resources that can't be easily garbage collected i.e file descriptors or gpu memory mutable data structures in the presence of concurrency okay i think i understand most those words yeah i'm curious why just like even this like don't you just hold on oh yeah because the file descriptor often is a just a number right yeah and so yeah you're gonna show there's a cool example actually of that one but just like for some additional context for people who aren't like as aware right okay almost garbage collected i mean it's kind of implied in this right yeah so doing stuff like actually managing you know to put something on the stack instead of just allocating it to the heap and then checking for it later that's like you have to have some scheme to tell the language it's time to do this versus time to do that right yes and if you could do it it'd be fast it like greatly speeds it up like order of magnitude difference especially where you maybe need to like allocate this same kind of value a bunch of times right or or other things like that so like you know you got to think you write russ you're like i can pick where the memory lives but then you're writing okay i'm only like i just let the garbage collector do it what if there was an in-between yeah that'd be great honestly like i said if i could just use rust with the garbage collector i'd be super happy because you know there's times where i want the speed but for the most part a compiled language is fast enough right like just like go it's it's mostly just fast enough there's only very few niche instances where go stops being fast enough yep all right on the other hand rust approach comes with trade-offs as shoeing garbage collection requires careful consideration of lifetimes and ownership throughout the code base emphasizing lifetime polymorphism can make type inference untenable a design choice that wouldn't fit o camel not only that i think can we stop though and just say i'm really impressed i've never seen you read a paragraph with that many big words and actually make it through i did first try i did i made it through i've really been training for years at this point to be able to read at an 11th grader like level and i'm pretty proud of that are you like trying to do really good because i'm hanging out today or like what's going on i would like to say that despite your insults you still have your chair just sideways you just have a chair in the background ruining this entire thing while it's salting my reading skills thank you the slow disappear all right anyways one thing i don't think they also mentioned here is just that in general when you have to fully lifetime everything it can become just even a design choice that was good in the moment can become a very bad design choice later on and so there's like a lot of things in here that are just very interesting all right at jane street we've been working on extending oh camel to better support these use cases without giving up the principles that make oh camel a convenient and flexible language to do so we're introducing a system of modes which track properties like the locality and uniqueness of o camel values modes allow the compiler to emit better lower allocation code and power users to write safer apis and with advent of multi-course to statically guarantee there's that mispronunciation database freedom like it's still the right word it is close it was close all in a lightweight way that only affects those needs okay very interesting i'm very excited especially stack allocation to me this is like a w if you could get stack allocations in any language but mostly rely on garbage collection it's beautiful i'd love to see how they do this yeah i think the other thing that's interesting is as we get a little bit further you'll see but like they're making a distinction that i didn't catch the first time i read this about modes which is like modes aren't in the same way like part of the types system as like lifetimes so like lifetime is part of the type okay right but then oh [music] so it's like in some ways a little bit orthogonal to the type itself yes which is so so it's cool right because the as you played a little bit with o camel they talked about you want to be able to always infer the type of something for okay well basically like all the time right and so if this like effectively lifetimes light this is like the first part right it's like lifetime's light effectively if that was part of the type you wouldn't always be able to infer it and then you would have really really sad times right so you just want it to be i just want it to work so that's basically what's going on yep all right the first approximation this model requires allocating all values how you skip the first paragraph i did oh dang yeah the el camo compiler does not statically track lifetimes again reading skills you know how many comments i get with hey i most of hey i missed a paragraph you missed a gay paragraph and then you talked about it for five minutes [laughter] every video instead it relies on a garbage collector to figure out a suitable lifespan for each value at runtime values are collected only after they become unreferenced so ocamel programs are memory safety yep yeah the first approximation this model requires allocating all values on the heap fortunately o camel's generational gc can efficiently handle short-lived values minor heap allocations simply advance a ring buffer oh cool however placing everything on the heap is still pessimistic approach where possible using a val is using a specialized allocator could improve performance for example the minor heap is typically larger than cash so future allocations are likely to evict live values stack allocation would immediately reuse free space eliminating this concern okay exciting let's see providing an alternative to heap allocation would also have other benefits every minor heap allocation brings us closer to the next minor collection cycle a minor collection incurs some fixed overhead but more importantly frequent collection causes more values to be moved to the major heap yep promoted values become much costlier to collect it later on so this is the difference between a minor gc and a major gc really in javascript as well very similar idea i think they have some morbid term where the the the the the miner is called a nursery and to kill something else called infant mortality some just real morbid term yeah i think they avoid using those phrases in this article smartly yep yep just very big brain o camel programmer right there oh yeah infant mortality is bad let's not use that i like no we're not gonna make fun of emalek okay it's called malik for a reason at jane stream we often write zero allocation code which much never trigger a gc cycle i love this this is actually a really fun to write zero allocation code there's zero copy which is really really hard to do but zero allocation is pretty interesting because you can just for you just effectively create a bunch of stuff that you'll need and just continuously reuse what you have so unlike your compiler tj which you wrote to purely copy everything this would be the inverse of it all all right yes but micah tyler mostly just lives in the minor gc right so it still gets it's still very fast because it's just like allocator unless if we do too much applications then you bump all these little minor allocations to major allocations baby okay that ring buffers of limited size is the tear back the chair is back oh whoops i i only have so far i can i can push it there we go that sucks but it's fine it's close enough when such let's say hold on a stack allocator would make it easier to write programs that do not touch the heap when such performance concerns are relevant one should arguably be using a language based on explicit memory management like rust however garbage collection is genuinely useful explicit management is a burden on users ideally a language could improve a spectrum of allocation strategies freely interoperable with a single application with modes a user can write o camel with all the usual gc guarantees but when performance is paramount opt into the consideration of lifetimes ownership and concurrency okay i really like i really like where this is going so i hope that w i hope that for me we're going to get to the point of actually seeing what it does now okay local variables okay let's see in o camel turns out that many short-lived values can be stack allocated to safely referred to such values we introduce local variables okay determine whether a variable is local involves checking a certain condition on its lifetime considering the following function okay so we have a function is int which takes in a single str string opt is int of string opt in string so that opt must be a option yeah yeah instead of throwing an error raise an exception yeah okay so you have this sum okay cool this seems pretty simple you return true or you return false isn't okay perfect so you have kind of being able to read oh camel i haven't really written anything you're already there but i'm i'm getting i can read it just not write it yet that's just a matter of practice naively this function incurs a heap allocation the compiler does not know the lifetime of opt our function could return it or even store it in a global variable because opt could escape this function the value referenced by opt may need to live forever therefore it must be heap allocated okay that makes sense blah blah as a programmer however we can deduce that a shorter lifetime suffices in fact opt only needs to live until we match on it when is int returns opt is no longer accessible so it could safely be been allocated in stack memory local to is int okay datastack sum i what is opt again just to make sure okay opt is this thing option right here it only needs to live this long so it's it's an option yeah yeah okay that makes perfect sense it only really really needs to live very very short all right specifically oh hold on did i already read this part oh no we haven't did that part specifically how to say local because its lifetime does not exceed the enclosing stack frame which we will call its region at runtime entering is int begins a region by saving the current stack pointer exiting ends the region by reclaiming stack allocated memory reclaiming usually just means you move the stack pointer less high on the stack since opt is only accessible within this region it may safely be allocated in the corresponding stack frame beautiful note stack allocated values is not necessarily stored in the control flow stack as seen in languages supported by alaka alaka in this example we request space from stack based allocator backed entirely by entirely unrelated memory okay the locality mode so local variables are those that do not escape their region to formalize this constraint in a manner the compiler can check we introduce modes okay so i love this idea this is where we separate out the type of a lifetime like rust versus an operational paradigm of the like you're really just changing allocators in zig is that fair to say yeah although they're going to introduce some sort of like because this mode is more than just a hint to the compiler like you're able to do some stuff later but that's like the first pass of what to understand is definitely that yep okay by default variables have a global mode the global variable has the capability to escape any region so always reference the perfect sense variables with new local mode cannot escape their enclosing regions so may refer to the stack okay a mode is attached to a variable upon declaration either the left binding or a function parameter in both cases the compiler will check that value does not escape the region okay oh so let local why how does that let's see oh so how does it know not to make this a function that returns zero it like it will literally be a change in the compiler so right now they have a fork that you can like test out and you can do this but like it will literally be a change in the compiler and local will become a keyword okay okay this makes sense because right now you could imagine that that is just a function called local yes okay okay this variable escapes its region so that's the error i don't really understand why is it escaping its region and not why it's well why would also it's saying both of them do but like the first error prevents the rest of the compilation okay a local parameter represents a problem or oh my goodness a local parameter represents a promise by the kali the function will not story reference to the value anywhere that could be accessed after the function returns intuitively it's safe to pass stack allocated value to a function we know the values lifetime will not extend okay is empty local string string length equals zero perfect is it really just is it really just one equal sign it's not two yeah well you can they do different things the one is what you'd usually use oh isn't that for assignment not a quality check it's it's a different like operation based on where it is yeah sorry sometimes i don't know things sometimes i'm a little dumb that's okay let's see here the syntax string at local denotes is empty takes a parameter at the local mode okay so that second the one in green is like the type of it right that's that's what you get when you're running you top and you execute it and tells you what the type is it says hey look your first parameter is in the local mode and it's and then this thing returns a bull okay okay here the syntax string at local denotes the is empty okay that makes more sense i get this now even without explicit mode annotations the compiler can statically determine which variables may escape their enclosing regions such variables are assigned to global mode all others are automatically inferred to be local at this point the compiler may construct values bound to local variable using stack allocations interesting okay so it's up to the compiler you're not really actually telling it to use the stack you are just simply letting the compiler make that decision no well so you can tell it by using the local keyword but also like someone at aston chat a little bit ago but i knew this was coming out like if it's already allocated on the heat it just works it will do its best to figure out which things are local like based on the code that's written when it gets compiled and for those things it will then put it into local mode which will allow it to be put onto like the data stack instead of a heap and then they won't have to get garbage collected later okay that makes perfect sense so like local string you can pass in a heap allocated item it doesn't have to be a local explicit item this just means if it can be heap allocated it will be but if it can be stack allocated it also can be yeah where's the other one it's only heap only if you don't use local yeah they're going to talk about the interplay between which one's considered like a sub mode of the other this idea will be expanded in like other directions throughout the other ones to add the other features that are like interesting about light rusts like lifetime and ownership system later which is why i actually send you this one originally because i'm at the next article i think was where it would be like oh that's so cool okay but anyways this one still has a lot of cool stuff i mean this is cool right because it's basically like how often do you get to in a garbage collected language say i want to put this thing on the stack you don't usually you usually you don't i don't know of any language i guess i i don't know python well enough python seems to be able to do everything so i don't know if you would see yeah that's the thing is python usually the answer is yes python can do it but javascript you certainly cannot that's not an option or you don't plan on it being an option now whether or not they actually allow for it i don't know maybe and maybe if you do like simple integers and it's jaded it might be able to do some stack allocation in for some small lifetimes but you can't control it in any sense so local returns all right oh actually hold on so even without explicit mode annotations the compiler can statically determine which variables may escape their enclosing regions such variables are assigned the global mode all others are automatically inferred to be local at this point the compiler may construct values bound to local variables using stack allocations so this would also allow for faster compilation because it doesn't actually have to do like a full exhaustive searching it just has to be like do you escape or escape your global well right now it will be slower because right now it just always assumes everything is global right like compilation step because like right now it doesn't do any checking like once this is all the way done yeah when it's all the way done but rust is really slow yeah so it will be faster than rusts because i think it already is much faster like it's it's very fast compilation right now okay yes okay so i don't know i wouldn't want to make any promises you know but like it's it it should be simpler okay let's see returning a local value from a function should appear contradictory since the function's result has clearly escaped its region on the other hand if a function can only return globals constructing fully stack allocated values becomes difficult they become built up from literals the solution enclave i don't know if yeah apparently it's a real word oh sorry i had to google it i said and i didn't even see the x like the x became an n for me what's x clay i i don't remember exactly what the definition i had to look it up but basically it means well we'll just yeah a portion of territory of one state completely surrounded by territory of another or others as viewed by the home territory so it's basically like they're they're just gonna surround that piece of memory or something like that i don't remember exactly what the reasoning was for it but they also were trying to pick one that wouldn't be a word that was used a lot because like if you did return or something like that right like people are already using those words so you need to pick something that's maybe a little bit less likely to be used okay i get that it's also when functional bros get into it the terms get exceptionally complex it's true it's true they got a lot of words they got a lot of words a lot of words there okay so yes check out the type right here it's an int list at local right so it's telling you that like this thing can't escape the global scope okay so i wonder if you wonder if you a local allocation here and then exclave it out yeah yeah yeah okay so that's kind of like just passing it's just yeah okay cool right so that's basically the problem they're solving with it right otherwise they're saying you could only build it with literals as in oh prime flip's telling you to check your discord don't docs you could lose this bop and be out of content he says oh what's going on i don't know flip is telling you to check discord very negative that would be he doesn't want me to leak the dms by the way because his discord froze and i took pictures of him and he looks real real caveman-like anyways okay the exclave keyword ends the region and executes the given expression in the enclosing region the caller receives the local variable here i'm gonna go like this he's upset about that marker put the picture and flip do it yeah put the put the picture in right now all right anyway slip through it therefore it's safe to allocate that value on the caller stack frame the difference is simply which region the value lives in okay so let list equals local list in list okay list this value escapes its region why porque oh because this thing returns list right which then becomes here which it can only live within this in expression so if you did do an in and you did two semicolons then it could live right here because it live for the expression of bar correct as long as it isn't returned basically it's like you just can't return it okay you can't return it okay local returning functions are the primary method of creating stack allocated values as they can programmatically build up local data structures this mechanism allows for functions to return their local parameters lastly recall that local stack is distinct from the control flow stack making this behavior easy easy to implement so they could do exclave list which would then make it live to this level so if they did exclave list at the end of this then barr would return a local list which is legal like you can return it it would be up to whatever the callers of bar are doing to make sure that they don't violate like the promise of what it means to be a local list and by up to them i mean like the compiler will tell them if they fail to do that okay okay that's good to know okay locality in our apis locality doesn't only facilitate stack allocation it also lets us design safer apis the following code exhibits a common pattern for resource management with file file mode read only i don't i don't know what this is i don't know what these two so those are so that's just a named parameter so when it has like a tilde in the name so it's saying well we want to do the mode then you have a list of modes that you can do right so this one's saying it can be read only and then here's the function that you're going to call with this file and it passes the file descriptor okay but why oh because you can also define a function with fun right yeah yep okay so and then this is basically saying like open this file and close this file for me and like manage the files like in a sense right this this function exists already and then do these things with the file in the meantime right that's what the the callback does okay so this callback allows you to have effectively the lifetime for this when it however long this function lives is how long this file is open for yes but they're going to show how you can like break that without the locality okay here a file descriptor is open pass to the lambda function and close after the function returns this api allows lets users issue manually closing the phone i really like that word they did twice and twice in one article nice it's a lot of issuing however there's no guarantee that descriptor is not used after it's closed okay there you go so you can do this and then all of a sudden boom you now have stash right here and then later on you can close stash i don't know what bang does i don't some of these this is where i get into the more advanced okay that's just basically how you access a mutable value so like you can't just pass around mutable values like regular values to access the like inner value you do bang oh okay weird yep okay i'll have to we'll have to get there of course this design can be improved by making fda local parameter after changing the signature with with file the following way file string open list file descriptor okay so the big important part is inside of there where it says file descriptor.t at local so now it's saying hey we have a file descriptor and it can only live a local yeah it can only live within this function and whatever you return is also returned on the outside yeah right okay that's type polymorphism is that the term the parametric polymorphism yeah parametric polymorphism it's a parameter it's just like classic generics that you'd think of in like typescript or go basically right where you would like say that this is a t and it returns a t okay yes yes okay let's see let's see the callback must promise not to stash away the file descriptor therefore we know the file won't be used after the callback okay perfect in this example we're using modes to require a promise from the caller this usage might feel similar to local returns and for good reason formally when a parameter is used contravariantly there's one of those words again yep what does contravariantly mean so well they'll explain a little bit but it'll it's basically saying which one can be a broader or a tighter like i don't know what to say genericism i'm not sure exactly how to how to say it but like so contravariant i think is the way when it's saying like you can't pass in something that's bigger than this so like if you think about four types of something right if you had like inheritance this would be saying like oh if i'm an animal and a dog well i can't pass in an animal i'm expecting a dog okay right but if it was covering then it would say oh well since dog is an animal then you can do it i think i did it right but i keep on forgetting which way it is for which words but that's at least that's the goal of how to think about it and i never remember which word goes to which so it doesn't that part doesn't really matter but the idea is whether it allows you to go broader or tighter of like a type okay okay so narrowing versus broadening so one of these two mean that you can pass in a dog to a interface that takes animal the other one is you cannot pass an animal into an interface that takes dog yes okay yeah i don't know i i've heard these terms but i always forget what they mean and then i get into this situation every single time where i go i don't even remember which one it is your intuition though is like correct about it and that like it would make sense to you if you saw something was a function took in a dog you were like well i can't just pass in any animal yeah like it's specifically saying dog right that's exactly what they're saying here this one says it's taking in a local so it has to be a local it can't be a global that makes sense okay that makes sense so then just to be clear if we like scroll back up to the code example yeah i remember that one because that that's the one down a little bit i was also thinking about this one this one allows you to take in a local string but it doesn't necessarily require it to be local right it could be a global so how does this one denote that this one can't be anything but a local because since or wait maybe you're right maybe i am thinking of that backwards i have to think about it a little bit for the string one yeah i don't know i have to think about that one a little bit more actually i'm not sure maybe you can't pass a global to that one okay well i'm curious yeah that's why i want to play with this okay mode first time above we declare a local integer x using the syntax let local notably we didn't simply add a type annotation the local mode does not operate on types in fact the mode of x is entirely separate from the type of x beautiful that way we don't have all the rust stuff types describe data structures that is how to build up and take apart values on the other hand a mode encodes a proper property independent of data layout so maybe let's see so maybe attached to a variable of any type to illustrate this behavior type annotation specify a variable at a mode using syntax type at mode okay local local local local local right in this case of locality the salient property is whether a value may escape its region variables with the global mode can escape any region so global variables or global global values are correspondingly keep allocated conversely the local mode restricts a variable to its region a local value may be stack allocated maybe is that the key word that they may not always choose yeah that it's up to the compiler like you you can't necessarily like guarantee it i think or maybe like later they will right like but because this is still justin like jane street's fork right they're like working to get this upstreamed at some point and get in community feedback and all these other things etc right okay etc okay encoding locality is this me gathering community feedback i'd love to take a sponsorship okay we got two of us right here two right here influencers tech influencers tech influencers but we just told people not to listen to tech influencers so now what you should listen to tech influencers you know what i mean when it comes to me making hundreds if not thousands of pesos you need to listen to me okay i've played myself damn it i've played myself we just uno reversed ourselves i know terrible okay encoding locality with the mode has some advantages compared to rust type-centric approach in rust reference types are parameterized over specific regions represented by lifetime variables this design is more expressive than locality which only distinguishes values that may escape all regions from those that cannot escape any it's simpler and i think i like it more it makes your brain it's just like a super simple and like they're going to talk a little bit about it but the thing that i like is like most of the time that distinction is basically all you need right which is like can this go anywhere or is it going to stay here right which is like most of the time what you have with russ is like well i just want to say that this thing basically lives forever yeah or it can't live any longer than than this like function approximately you know so like it's i i like i like where this sort of idea is for a language with garbage collection right which like the in between times you just let the garbage collector handle it you let the garbage collection handle it but i mean there's plenty of stack stuff there you're just like i wish i could put on a stack all right on the other hand lifetime variables are a source of pervasive complexity when references are inherently polymorphic essentially all functions become lifetime polymorphic as well for example whenever a reference lacks a lifetime annotation an implicit lifetime variable appears yes yes exactly yes it's kind of like it's just kind of was that it's like nice except that it's annoying because then as soon as you need to start adding lifetime annotations it's like every single function i have i have to add this random syntax for it and then i have to like mark the ones and then oh my goodness well this one actually isn't exactly the same can be shorter and then ah yep and then you get into this whole a b problem which is like now you have two references in here you have two two different arguments that both need a lifetime on them do you make them separate lifetimes do you constrain them both the same lifetime then you have this whole like leaking of problem and then it just it just goes on and on and on and on and on since russ supports first class functions the result is that higher order functions require higher order polymorphism which the type inference is undecidable undecidable in general okay oh camel's modes do not affect type inference they preserve the types of existing code so users truly don't need to consider modes they aren't actively using beautiful in ocam we'll type inference higher order functions and garbage collection are all important parts of the development workflow so we consider the local mode to be a good fit i'm liking this this seems yeah really nice so the the one where you run into it a lot the example that they gave for us is like but if you try and write like a closure and you like capture anything it's just it's just done for right you know what i mean you end up always having to have to like parameterize the entire closure over all the values that you want to do otherwise you have to annotate all the annotations of those and make sure the closure can't escape anywhere and you can't reference those things longer than this or you have to say that and then you're like holy cow like i can't i just can't use closures that way which is they're not just like they're straight-offs right yeah this is trade-off and then you just call string.clone that's like that's really what you end up doing is that you make your own garbage collection you you pre you type move in front of your closure yeah and then you clone a bunch of things into it that's pretty much what i've done every single time all right yes above we noted that the mode describes properly a property independent of data layout such properties are deep as opposed to shallow layout encoded by a type to understand this distinction considering the following type okay so this is a list i don't i don't quite know what this is this is a it looks like whatever the the type yeah so you just think of it as a generic ti yeah generic it's either empty or more of a or a tuple is that a tuple of a a yeah so there's it's like the head and then the rest of the list which could be empty or it could be more list okay right head and rest of the list so you're creating like a tuple that gets deeper deeper deeper yeah it's just a linked list basically right okay destructuring a value of take a list produces two possible outcomes either the empty list or a pair of values see a pair of a value and another list of arbitrary shape hence the type only describes the values top level structure all right process list head remaining okay conversely there's that word again they're getting all close to those words destructuring issuing the structuring man i'm just too stupid for this the structuring and global variable of type tick a list produces either a empty list or a pair of global value and another global list that is the root node of the list may escape its region the subsequent nodes clearly can too so the entire list must be heap allocated okay more and more and more perfect the same logic applies to local case to structuring a local list produces a local value and another local list it is possible to create a local list consisting entirely of stack allocations so we must ensure the contents of the local list also do not escape okay exciting deepness enables the compiler to validate usage of local data structures okay so local list do this and this returns right don't we need the yep exclave this where's the exclaving well so that's what it's going to say oh it's value oh this value okay so i i i am getting it you're on it yeah you're right on track i'm right i'm following perfectly okay if locality didn't exhibit deepness it wouldn't be very useful if we could stack allocate the root note of the list but we'd have no way to express that further nodes it may also be stack allocated okay cool sub modes given deepness locality might appear to be an all or nothing choice so far we allocated our data structure entirely on the stack or entirely on the heap yep that's kind of how i've envisioned it to break this dichotomy we will explore another important property of modes each mode access emits a natural subtype relation subtyping relation okay this might be the part where i get too dumb in case of locality it's intuitively safe to use global variable as as if it were local absolutely for example a function expecting a local parameter promises equivalent behavior whether or not the parameter actually lives on the stack perfect therefore we say global is a sub mode of local interesting which makes perfect sense but still interesting it's weird because like generally you think of like which is when you're thinking of globals and locals you're like locals are kind of like a subset of globals right but like they're talking about it in a different relationship yes because there are always more globals than locals they're minimally has to be some level of globals that cannot exist locally so therefore something sometimes this isn't haskell this isn't hazard we're doing things so sub mode really isn't about the number of things right it's not a subset it's right the places in which it can operate yeah and like it's about well not even that which it's it's actually about like which direction just think about it as like local kind of like animal and global is like dog right yeah like that's how you should just think about it other way around global like global is a sub mode of local so like anywhere that you could use a local variable you can use a global okay anywhere you could use a global is not somewhere you can necessarily use a local okay okay okay okay i think okay yes yes correct and allow global values to be used at the local mode okay let localize x and cl exclavex does this mean you take global ones do what it does yeah it just takes this is a function that takes in something that's global and must make it into something that's local yeah okay and so that's why they said before locals may be on the stack i'm pretty sure i don't actually know because i have i like i haven't read this i don't know the implementation like actually i you know what i mean but like they're that's why it's may because like you could you could basically move a global into like a local with this kind of idea and restrict what you were gonna do with it right i think that's kind of okay kind of what's going on okay so you could potentially have two different uses so even though this will always still live on the heap it's now restricting its usage of it in some sense okay as far as i can tell yep okay it is safe for a local value to reference a global but not vice versa let's say at runtime this means we can create pointers from the stack to the heap but not from the heap to the stack for example we can create a local fully stack allocated list whose nodes refer to heap allocated values let's see all right let's see recursive globalized list exclave this list with either empty or the head remaining we're going to recall i don't know what more does what is more it's like making an enum so that's like the that's like the you know how in rust if you had like a list you'd have like list colon colon empty list colon colon more they they don't have the cold and cold in here like because they're contained inside of one type right so we made this like list type and it has empty or more so when you call more it's not really calling it it's saying this is more with this data that's the data that's inside of there okay so this localize a list so it creates a list of references yeah so this effectively creates a list of references to something on the heap but this list is allocated on the stack right wild i'd have to think about that for a little i mean i get i get conceptually what they're doing i'm just trying to think of why would i use this and when would i want to use this it's hard for me to envision what to do here so the the way that i was thinking of like why you would want to do this is if you have to do lots of iterations over this you're going to do a lot less pointer chasing right like because something like your whole all of your like pointers are actually on the stack right so you can just like oh locality zoom in like cpu locality right like zoom through the memory and then you're only referencing those out to the when you need to go check the value right because the value may be too big anyways for your stack and stuff or whatever right okay so this effectively takes indirect pointers and turn them into direct pointers yes i think so or single player that's what the picture makes me think of as well so i think we're matching up with the picture yeah because now you're just okay this makes i think this makes more sense okay we could create local list where the only first node is stack allocated say if we locally append to the global list we could create a local list where only the first node is stack allocated say if we locally append to the global list local cons wow local head remaining and let's see exclave morehead remaining okay so i don't know why you would do this one yeah i don't quite get this one because okay so the head is local that must mean the list is local as well but the remaining is global yeah so i think i think they're not saying that each of these is useful they're showing the deepness of the types yeah i think is like so that's they're just trying to show the different ways and like lists are pretty easy to picture yeah i guess so yeah yeah the problem is sometimes these type of operations make me more confused than anything else i totally i think i see what's happening they should have just stopped with the first two examples and then maybe i don't know but i think they're just trying to show how you can do like more things if it made sense but i'm not really sure okay let's see what we cannot create is a global list containing stack allocated nodes okay that makes sense again modes are deep so any global list must have only captured globals yep this preserves the invariant that whenever a node is heap allocated all nodes reachable from it are also heap allocated more rigorously we could say that as we traverse a value the current mode monotonically increases with depth this restriction should also make intuitive sense this sounds like my teacher teaching me computational theory it's intuitive and i'm like i don't think you know what means you should have gotten this already from the first sentence but if you're an idiot i'll give you a paragraph shoot sends any list without a proper let's see property contains a pointer from the heap to the stack let's say hold on this restriction should make it intuitive sense since any list without this property contains a pointer from the heap to the stack what judo said in chat he's not wrong let's see monotonically this gets nerds erect this does that's why we there's even an entire clock called the monatomic clock people love it all right such a pointer is potentially used after freebug the heap node may still be reachable after the stack has been freedomed okay so this is effectively what they're saying is that you start with a a depth of zero if you will and then once you move to the heap it's a depth of one therefore you cannot go back to a depth of zero right exactly right if i go then that's going to be real bad when that stack gets cleaned up and it no longer points to the thing you thought it did anymore i think you could resay all of these words which are all very fancy and beautiful sounding and have the word globalist in here i think it'd be a little bit easier to say that stacks stack memory can refer to heap but heap cannot refer to stack yeah agreed hey maybe i could be a writer one day me and chat tiffany were getting after it the in a sense you kind of are like if you think about the youtube videos that you make as the sum total of your writing prowess that then that is not a good prowess to brag about the above layout can represent let's see can be represented using rust lifetimes which supports subtyping however safely manipulating such data structures requires significantly more reasoning on the programmer's part agreed this is where it totally sucks check check mate this is just like where russ gets horrible when you start getting into these weird lifetime problems lifetime variables again it's super fast though if you can be good at it but i just don't have enough like the problem is i don't write enough libraries to be good enough at it so instead it's like every time i do it i kind of go okay i know what i'm trying to do let's start trying to do it and then when it doesn't work i get frustrated it takes me like five tries i'm like okay i got it and then it works and then i change one thing and then i have to rethink all the things yeah or like you move to make it go async and then it just starts feeling really bad then you just feel sad about yourself your life and your situation locality offers a compromise consider just one lifetime the current region makes efficient stack allocation easy to use in many practical scenarios values with other lifetimes are still managed by the garbage collector okay the global record fields because modes are deep a local record always contains local values hold on one second how much more do we have okay we're almost to the end nice i was about to say this is a long article however since global is a sub mode of local inner values may also be heap allocated and sometimes the programmer knows they always will be in this case locality isn't necessarily restrictive therefore we support annotating record fields with the explicit global mode the compiler forbids initializing a global field using a local variable global fields are hence allowed to escape the region yep okay so you can global you can be a globalist if you need to yeah you can just be a hidden globalist you're like parading around as a local you know but then you're actually a globalist oh damn that's like that's that's that that that's a conspiracy type explicitly mutable record fields are automatically considered global if this were not the case a function could leak a local variable by storing it with a local parameter violating region safety for example we have immutable x option this clear local box local y none in this okay so i don't quite basically like fields can be mutable or not mutable in ocamel you said it at the field level so like they said x is mutable right assign a local y into a local box but they're at different levels yes so then now like the box is gonna get the balls you're in trouble you're returning this box and or like it so it's like hey you can't just put this here this is you said this was local what are you doing yes okay for those that don't see what's happening here this is a scope this is a scope and so y lives this long box lives this long therefore this cannot happen yeah basically that's that's the case yeah okay okay cool that makes sense that makes perfect sense locality and practice at james street we've been using locality and production for some time developers who work on performance sensitive systems use locality daily and those who don't are largely unfamiliar with the feature which means we've successfully limited the cost to our users who care therefore we consider localities expressive expressivity and performance benefits worth the additional language complexity i agree if that if you could do that oopsies wrong way if you could do this and people don't realize they're using one of the two to me that seems like a w that means you've created a feature and which is not leaky right the outside doesn't need to know about it only the inside does yeah and when they say they've been using it in production that means like a lot i would assume they do here with how much old camel they have that's not like well we launched it and we've got eight users you know we have a cli that tom uses to compile j diesel right like it's actually yeah it's more than just for geniuses is what you're trying to say yes okay building on locality success the compiler team is now implementing additional modes for describing ownership constraints and part two we'll explore new mode access represented uniqueness and linear linearity linearity okay that seems like ownership basically those two together are ownership okay well i hey i love where this is going i i'm very happy i feel like okay i could love oh camel i'm still on the i don't know yet list okay i still don't know but i feel like i could love ocamel in reading stuff like this where you get practical performance without a like massive unsafety of c where it's just like sometimes it's such an annoying like if you've never worked out segmentation faults it's super not fun or rust where like you said you go with all these references and then you go async and then you hate your life and then you're just like why do i hate my life and you're like oh it's because of all this so i love this this is beautiful i'm very excited for the next one too especially if you'd get a little bit of time to practice some mo camel this week and then you'll start it's gonna look like just like some rust stuff and you'll be like oh my goodness so sweet that i don't have to think about it all the time one of the things there's a really great podcast signals and threads i haven't been on it if they ever want to have me on i'd like tj hasn't been on signals and threads by the way signals and threads if you're wondering but they they talk about how a lot of the goal of what they're trying to do for this is like make the complexity very much opt-in which they like mention at the end right but the idea is like you don't have to pay for the complexity on day one learning the language right and maybe not even day 100 but it's like when you run into the problem then you have the tool to solve it without having to resort resort to something like completely different right like oh we just have to rewrite this part of the stack in rust you're like oh dang it you know yeah okay so that's so that's what i'm excited about so anyways this has been the educational gin yeah this is the don't you don't do that that's my line it's completely inappropriate and i don't go underneath i go to the side okay you gotta go to the side all right that makes a big difference do you understand the education engine okay listen to this man's screams and be influenced get influenced kid all right get influenced the name quit your job tune in and drop out what what what did timothy lyrics buy my free course on front end masters and get bankrupted all right hey the name is underscore dv bye tj this is ridiculous okay bye chat love you everybody see you later