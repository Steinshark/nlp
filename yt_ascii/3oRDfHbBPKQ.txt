uh this is a talk on grpc with c++ and some solution some generic solution so welcome everyone my name isaka carotti i work as a senior software engineer in alter engineering for those of you who don't know alter alter is a global leader in computational science it provides software solutions for simulation hbc data analytics ai and much more if anyone wants to know more you can visit the website and you can even ask me after the talk or you can contact me by email so today we're going to see a solution in order to embed grpc into existing applications that probably have some all their complex designs where it's not very easy to discretize or componentize some functionality we need to share among apps by using the client and server applications existing data model so what we're going to go through we are going to go through some theory first basics what is grpc why use it the protuff serialization mechanism that is commonly used with grpc some info on how to build install and use grpc next we're going to go through the basic features of grpc naming rpc types and the service api types it provides we are going to see the standard approach like the common approach when you are going to create new services to use with grpc we're going to see an example simple example the restaurant example the autogenerated apis that are provided by grpc see why we do not want to use the the autogenerated apis and next we're going to move to another approach by wrapping up drpc and prot buff to a new library and make it possible to use generic services that have no direct grpc dependencies see the benefit buet of course that goes along with some cost so what is grpc grpc is a remote procedure called framework g stands for google this was originally created by google it is very modern open source high performance it connects services in and across data centers connects devices and mobile applications and browsers to backend services it gives you all the support you need for load balancing tracing health checking and authentication it comes in multiple language and it's crossplatform on the bottom you can see the websites where you can get all info for grpc and the languages it supports now protuff again provided by google is the common serialization mechanism that is used along with grpc as a serializer for structur data it is language neutral and platform neutral it generates native language bindings it is smaller much faster than other formats like json or xml and talking about protuff uh we not only mean the definition language in our dot proto files but also the code that the proto compiler generates and the serialization format for the data so to use grpc into your apps and services first you need to clone a repository from github naming the release tag that you like there are very clear instructions on how to build with basil and this is what zpc recommends you can also use cmake you will have no issue with cmake also and you will need to get the protoc compiler and all other dependencies again the instructions online are very clear and very straightforward so what are the common rpc types that grpc provides uh first we have unar calls where the client sends a signal request to the server and gets one single response back we have server streaming again the client sends a single response it gets a stream of a sequence of messages to read back there is client streaming where the client writes the sequence of messages to the server and gets one single response back and and then there is b directional streaming which is the most generic of all where both the client and the server exchange a sequence of messages to read and write back now on the service api types currently grpc provides three basic service api types it is the synchronous api named also blocking the client sends a request to the server and blocks until completion the server immediately responds back with the outcome and the status of the call there is the async api that binds a compl a completion q to an rpc call and the server gets to handle multiped requests at the same time there is also the call back api which is again an asynchronous api the difference here is that rpc directly calls user specified code at the completion of the rpcs and that is done through the usage of reactors there are also some mixed mode service api types that combine messages types with the api types we have the ow api in an asynchronous mode this is is a complete async api that uses a roby buffer as the request and the response message type there is the raw call back api which again is a call back api and the message types are using aite buffer and then there are the generic apis that come as async and callback again the message types are just roby buffers and they accept all rpcs and host and the difference is that they can initiate an rpc by name which is mainly what we want so we had to choose among the two for our solution the generic callback api is the one that we are going to use and you will see as we move forward how and why differences between asyn and callback api on the async api we're using a completion q for our rpcs it is the application that must provide and manage its own threads so the application must pull continuously the completion quee to determine which a sync actions have completed and it is the application also that is responsible for executing any action upon an rpc is complete notified by the completion queue on the callback api the user code is run from the library's own threads this is a reactor based api there is no explicit polling required for notification of completion of the rpcs and the library is responsible as we said before for executing any user specified code at the completion of the rpcs so this is what we chose to move forward with now let's see a simple example of using grpc the standard way as i call it using a simple client and server architecture so on the right we have the server the server in this case provides for example one service and in the process i call it an order service with some methods grouped under the service and again it publishes the message types that is going to to exchange with a client that is done through a dot proto file that we will see on the next slide so on the left we also have one client and when the client comes in he would like to make a request to the server now this is where grpc fits in so grpc will be available for the client to make an order in this case the client will say hi i would like some lasagna a salad and a glass of wine and then the client will initiate a call to the server through the grpc and the client will decide that he is going to block until the completion of the of the call so this is a synchronously called rpc another client comes in the client again will make an order say i would like a cheeseburger and a diet c p and we'll start another rpc to the server through grpc and client 2 decides that she will make a phone call until her mill is back so this is an asynchronous process so how do we model that using grpc and proto buff this is the dot proto file where the server initially will publish the services it provides along with the message types you can see here we have one service order service this is a this is grouping a few methods here we only have one for simplicity it's called prepare meal it takes one single request named order and order is defined as a message containing four string fields an appetizer and main of course a dessert and a drink the sver will process the request and gives back a meal to the client the meal consists of food which again we defined as a repeated field that means a list of recipe fields the recipe field can contain other things like ingredients or anything and also a double field which is the c poost so we start by providing that dot proto file to the protoc compiler and the protoc compiler will give us back some autogenerated code that contains the data model and the client library we call that a stab the stab is a component through which the client will interact with the server so all the these service api types that we you saw before are accessible to the client through the stab so originally we get two files with autogenerated code one is the data model here you can see that we have four classes for the four message types that we provided we have a recipe a food order a meal all those implement some basic protuff method type and they contain they they are ready to use classes they contain copy semantics move semantics everything you need for efficient memory allocation queries and you can use all directly but now the problem for us is that we already have these classes in our data model so we would like to use that instead together with the data model there is another autogenerated file that contains as we saw all the the the available service api types so the simplest one the the base of all is grpc service this one provides a blocking api so we see that the way to call prepair meal through the stab would be by providing a context an order request a meal response that we will eventually get back and a grpc status which is the status of the call that is originally written right after we have an async api that is called request prepare meal in this case that also takes a context a request a response writer to get the response back a completion quee for the client a completion quee for the server and we also need some unique tag for each rpc the callback api you see that in this case we call prepare meal there is a special type of a context in this case to exchange and again we give the order we will take back the meal in this case originally the method returns a server unary reactor because we defined this method as a unary method and through that reactor we are going to react some way on the server side and there is also the raw async api you see that this is identical to the previous a bing api that we saw the only difference is that now the request and message types are of type grpc bite buffer and the same goes for the callback raw api where again zpc bite buffer is what we need for request and message types so what do we need on the server side to call these apis our services need to implement one of these grpc provided service classes on the top you see the blocking base grpc service then we have async service call back service and two generic service based classes for the async and the callback apis so to implement and call a unar synchronous method named prepare meal we need to two implementations on both sides on the server side and on the client side on the server side as you can see we have some order service implementation that implements that synchronous base order service service base class and we define our prepared meal there along with its implementation where we will we will create food calculate cost create a meal using that and just giving those back to the client and on the client side our implementation needs to have a unique stab in order to generate the stab we need a channel of connection so first we create the channel outside the class then the stab and through the stab we call prepare meal after we have calculated our input some way and transform it into a protuff message type of type order and then immediately we get both the reply and the status of the call back so this is pretty simple and pretty straightforward now on the other hand if we need to call a bidirectional callback prepare meal method we actually need two things we first need to implement the reactors on both sides and the services like we will see on the next slide so the reactors as you can see we get one reactor on the server side named prepare mill reactor and we have to do that for every method that implements a server by directional reactor taking an input of type order and giving an output of type meal in this case we get three callbacks as you see one for every read operation one for every right operation a final one named on dan which we have to implement as it is a pure virtual method and we decide what to do upon every read and what to finally do at the end where does prepare method prepare meal method definition fits in here usually as you will see on the examples on github you will see that they they all use some next right method where they fit in the prepare meal calculation and then they call next right upon every read after calculating the output so on done on the server side will take us to onan on the client side on the client side also we are implementing the same call box every read from the server upon every right to the server and when everything is done the difference is that on creation of the of the reactor on construction we will use the stab to define that we are going to call prepare meal with the context next and the whole thing initiates by using this start call and the service in this case in both sides is implemented a different way it will actually in both cases it will construct a reactor so on the server side the implementation is just giving back a new reactor and everything is going to happen through that and on the client side again upon construction of the reactor the whole rpc is going to initiate this is why we see a message on the bottom that your order is getting ready so the pc has initiated and it's being processed by the server so everything seems good so far but for us that didn't work quite well because now on our applications we have added some direct grpc and also protuff dependency with all the extra dependencies compilation and whatever else it needs we also on our server and client applications we those already share an existing data model we would like to may use to make use of our our existing classes if we choose to make conversion between those classes that could be complex and inefficient as this classes may contain a lot of information in some complex way and also the third point the existing apis may not cover our needs there are some things that you don't get for free with grpc for example the row or the generic apis do not cover for unary methods the row apis cannot be extended in the sense that mixing rw data with structured data is not possible and at some point you may want to do that and also there is no clear objective on the callback apis on where this service method implementation should be like you saw we use next right in that case but this is not clear anyone can decide to place that definition anywhere so with that we will move to a new approach a more generic approach for the same example so now that we're going to see a client server architect using a new library named my grpc what we're going to do we will move this do proto file from the server to around grpc we will add some generic services in there basically only one is what you need with a list of some generic methods me and uh messages of more generic types that we will see uh we will use this proto file to generate code that will be internal and hidden from the user and we will use our own apis to access the services that eventually the server will provide so this is our new dot proto file now it is one and only and it's hidden completely the user doesn't have to know anything about proto buffer you see that there is one service called my grpc generic service here there is one method named call for and you can name it whatever you like invoke sometimes is the most common takes a stream of requests and retains a stream of responses this stream now does not refer to a streaming process but rather is used for message chunking so in case of large messages you can model that as a streaming process as the messages get chunked and read on a sequence basis for the message types we use a protuff type of bytes for all data we can add some optional fields to denote the the end of the message if we would like to chunk it anyway so this is why it's optional and this is like the most generic rpc signature of all so given that proto file with grpc we will wrap that and use some other components for our library so what we're going to need is my grpc generic service that we saw before some handlers for the methods a service method call that uniquely defines one rpc my service method reactor which will be an implementation of a generic that we saw before a generic by directional server reactor and the same goes for the other side of the client so again we're going to have a reactor a handler for the methods a method call for each rpc initiated by the client without of course my gpc generic service which is only the implementation on the server side and this is all internal nothing is exposed from these components and the exposed components contain two types for request and response which eventually wrap that proto buff message types a server a server class for in order to to access the server apis my service which will be now our new base for all of our services and my stab which will be the stab that we're going to use in the client to access the to to initiate rpcs and access the server services so also we need to decide on what our common service method signature will be just like grpc it has to be unique and common for all the methods so looking on the data my request and my response the only thing that those provide is actually a standard stream for the client and the server to read and write back and the library now is responsible to manage the lifetime of the request and the response stream the client and the server only acquire this stream to make read and right operations and behind the scenes the internal implementation of my request and my response as you see also contains a my zpc request as defined in the generic dopro file setters and getters and possibility to slice the data so getting the next slice once the message comes along this is just the same thing that we talked about only in code so you can see that the internal implementation contains two things and standard io stream but also a mypc protuff message type request it has the possibility to get and set the next slice and eventually get the grpc request in terms of again pro buff messages the response implementation is just exactly the same as the request so on the server you will see on the right that we have my grpc generic service implementation where this call for code uh the implementation is and this is the rpc entry point for each call we initiate from the client so once an rpc comes there it creates a generic reactor like we saw before through the reactor everything happens the reactor also performs any slicing that we would like to do for really large data it creates a method called instance that includes an id name maybe client initiator id for each call and we also have a handler to to keep track of all the calls and manage the lifetime of the calls and externally we have my service now all of our services are going to implement just that the my service implementation will contain a list of methods using the common signature but also there is get method and get method needs to implement it for each method in order to bind the particular method to a standard function object that we will be able to call by name my server provides apis like start stop register service all those are quite the same just like grpc so here is my grpc generic service you will see here that it only implements grpc service blocking base class but it doesn't matter because in here here we can include any service api type that we would like and we will see how as we move forward so you can choose to implement call for the way you like as a unary synchronous call as a bidirectional streaming synchronous call as a by directional call back call like we do on the bottom and this is basically what we do do what we choose because this is the most general of all so call for will take a context and return a type of server by directional reactor using protuff my grpc request and response and returns my server method reactor which is an implementation of such a reactor this is the the the server method reactor that we have in our library as you see this is an implementation of server by directional reactor so it includes all the call backs that that provides including any other that we would like to add that is undone what happens on every read what happens on every right what will happen on cancel and then that next right that we saw before in this case we'll call any of the methods that we would like that are provided by the server by name this is the my service oh sorry my service interface as we saw the only thing that we need to implement here is a way to bind our method with a standard function object that we are going to call so if you see this this is an implementation of the previous interface how we're going to implement now my order service in contast in contrast with what we did before so in this casee we have chosen to have a boolean prepare method prepare meal method that takes my request as input and gives my response back as output how to implement this we get the service from the request we will deserialize that using our own data model derial the serializer we will calculate the response so we will create the meal response and we will ser serialize that using again our meal in this case serializer and on get method we will just given the method name there's a missing statement here but if the method name is prepare meal then we will bind that prepared meal to a standard function object to call now this is a basic difference on the server api so you will see that to start the server in grpc we are doing actually one thing before really starting the server we create all of our services and we register those services to the server in this case we have an extra step where we configure my grpc generic service the way we would like so how do we do that we will use some grpc internal apis to create a service method the rpc the grpc way we will define the rpc type as you see as by directional streaming the rpc type as a as cback rpc and we will add this service method to the service so this is a way to define methods that you can use in using any rpc type you want and any service api type you want so you can have multiple methods with different service api types grouped on the same service then we registered my grpc generic service this is the common grpc approach through a server builder of grpc and we start the server the grpc way through the build there using build and start and next on the client side what we're going to expose is a stab that will group all these method apis for call 4 internally that all will be handled through a method called handler that again is is it is a a mirror approach of what we're doing on the server sorry so the handler keeps and manages the method calls which remain live until completion you can see that the rpc trigger point is basically through our generic reactor in this case and that that run method over there will start the call to access the server through the server reactor so now you see what we can include on my stab now i have added a call for blocking and a call for call back but normally you wouldn't do that normally you probably would have just one api or to make it more fancier and better we would have like separate stabs a blocking stab or a an asynchron stab like this is what happens in java the blocking api returns a status and apart from request and response it also takes a service name and method name to be able to call a method by name the callback api for call for again takes a service name and mage method name a request and a call back you can see with the signature of uh getting a drpc response giving back a response and a status and this is a boolean method so there are two points here in case we need to somehow simulate a streaming process we may also use an api using a vector or some list of requests for the streaming calls you can see that the context is missing here this is because we define everything at a higher level and internally but if you would like to exchange metadata per rpc then okay of course we will add a context as an input and now you can see that we can choose to return a status of our rpc for example if we need to make some monitoring on the client side uh for the calls if we need that we can also return a status we can basically do whatever we like point two yes choose among blocking or call back api or combine the two or just separate the stabs like we said uh we have the option to add a callback even for synchronous rpcs if this is something that we would like to add choosing the signature of the call back is one benefit we get and also if we already have some signaling mechanism in place we can even completely omit the call backs we embed that and our signaling mechanism we just signal through the reactors back to our code so the change if you see here this is what we did before so the standard way we saw that we we implement the reactors on both sides implement the service on both sides but now if we would like to call prepare meal our new way we will just have our call back and from the client through my stab now we will call for order service prepare meal given a request and binding that call back to the call and on the server side we will just implement get method to bind this prepared meal with some function object and implementing prepared meal so this is this is a very clear place where we define and implement all that so what what is the benefit that we got in the end so we removed all direct grbc dependencies on both sides now also the clients can decide on a synchronous or asynchronous or call back mode previously this was just defined by the service the service was the the service implementation was the one that decided how the clients will initiate rpcs we get the ability to group multiple methods with different api types under the same generic service we get more intuitive client lpa apis we also get cleaner code we now have the ability to to to add extra functionalities on a higher level so for multiple services or even servic methods like we did with message chuning the same we can do if for example we want to event a progress callback or anything else on some higher level and the cons of course since we are using our existing data model all our classes need to provide their own serialization mechanism so that along increases again the development cost cost and this is c++ only solution so there is no multil language support for that if we would like to use any other language then the library needs to provide bindings for that language also so as a summary we saw a few things in theory about grpc how is grpc is used with protuff and how it is used on newly created services and applications we saw an alternative approach that we can use in our existing applications and our existing data models and of course since we actually paid the price of developing such a library we got the extra bonus of the flexibility and the freedom that uh we could use in our newer apis so thank you [applause] hi thanks for the talk i have a question about keeping changing the grpc definitions over time with this break compatibility with like older clients that still use an older grpc definition of of my ap especially if i use the generated headers changing the definitions of grpc is even even better handled in this way because there is a common new library that will be maintained and you know by someone and not by everyone so you will obviously have to maintain the library and you have to keep up with any latest update but that will also uh move to your client and your server implementations without any cost from their side okay so i can just update my trpc and the client doesn't have to change in any way and can still use as long as you keep your a apis you know in a generic form that will not change over time then you get the benefit of changing the implementation internally and with no cost on the server and the client side thank you hi i sort of had the same question as before but i want to be more explicit in when you want to change the schema of a particular message or payload and how you handle api versioning specifically in in in parallel so when you want to support multiple versions of your api when you actually change fields in the schema the the schema of the that genetic schema that you saw obviously will not change because it's only row bytes you will not change it ever now of course if you want to change the schema in your applications the only thing that you need to maintain is your serializers and that's it that that makes no actual cost for this library i would need to maintain two czers like for each version that i'm i want to support in clients yes but in this case okay we are we are actually using a common data model in both so you ultimately you will have to do that yes i would like to continue the tangent that we're already on is it now not the case that your client doesn't know your api anymore if you use this generic situation then you have have just robw bites so if you want to expose some kind of api to your clients stating these are the methods we support yes you will yes actually you will have to do that for us we're using some json you know uh format to so that we reflect what kind of services and what kind of data we provide from the server to the client if you want to do that without any connection so just for discovery otherwise if you would like to just reflect what is available on the server after connection to the client you can have a reflection method included in your generic service that will basically mirror whatever is available from the server to the client reflection also is used by by drpc okay thank you still staying on a serializer i think you might have answered some of my questions already but what format did you use for your serializer did you stay with a proto of your custom serializer custom ser yes custom serializer just using standard streams standard stream yes on the same page of the other questions is one of the advantages of grpc is that you and basically you can violate the api you can violate the contract so now you have this stream rob bites so did you have any issues with calling for example the wrong method with the wrong b stream or something like that and you maybe catch that bug in some ways in testing for example any experience to mitigate these issues because this this solution suffers the very same problems of json that you basically can't statically avoid these kind of issues no we have not we didn't have such issues but maybe you can avoid these issues if you use a variant instead of you know separate types but so far we didn't have any issue thanks a lot thank you