so let's have a little look at message authentication codes which are slightly more interesting than they sound so people shouldn't which off yet on the internet when we send messages we often send them encrypted the idea being that we don't want people to read them that makes a lot of sense the issue is that not being able to read the message doesn't mean you can't interfere with the message. you can't start changing the message trying to i've erect the communication or alter surreptitiously the communication to say something that you want this is where message authentication codes become a really big deal max as we call them are attached to most of the messages that get sent on the internet however they're built into the cypher or they are appended to every message that gets sent even if it's encrypted and they basically guarantee that the message haven't been changed so let's have a little bit of a look at that but first let's have a quick look at an example of what you can do if you start officially changing ciphertext usually when we're encrypting data online we are view the block cipher or use a stream cipher like they each have pros and cons and a detailed look at each of those is for a different time, but a stream cipher. they're quite common you know when you do things like streaming video because they let you often seek straight to the middle of somewhere and it also very very quick right so mobile communications you stream cyphers quite a lot instead of encrypting a message of a key it will actually just use the key to generate a long pseudo-random key stream for as long as it's required and then we use xor to actually perform the encryption so basically we start flipping bits of a plaintext to get to the ciphertext now the difficulty with this is that we can bend as a sort of malicious third party just flip the bits back all right so we can flip the bits in the ciphertext and they will cause a direct change in the input all right so i'm going to show a quick example just to show you the kind of problem we're dealing with so i've got here a an xor calculated i found so i'm going to put in a message, please send my 100 pounds this is just a calculator who doesn't actually perform keystream generations i've got a key stream that i've i'm going to paste it in here. so this is my key stream which is just in hex? well, that's your stream come from is not just oh, i will actually generated it by just putting random nonsense into another stream cipher you could generate this any way you like it has to appear random if it's not random enuine rules have all the straight incisor for the sake of this small example. which is just random enough so you know so if i calculate the xor on this we get a message in let's say hexadecimal which is completely nonsense right? this is our encrypted message if you view this as ascii it won't say this and it won't say anything useful at all the problem is if i start changing the bits here and we reverse this process for decryption. we can actually change the amount i get sent like which unfortunately this is a purely hypothetical example. i don't actually get any money so in a block cipher because the whole block is encrypted as one usually any kind of bit change in this ciphertext will completely wreck the output when you try and decrypt it that is not true of a stream cipher a stream cipher is one bit at a time which means that if i change a bit in my ciphertext i can flip bits in my plaintext so let's try this if i put my encoded in hex in my input the key stays the same and we can't play it the xor you can see that we've decrypted two, please send micro hundred pounds, but if i flip, so these each of these bytes here corresponds to a bite of this ascii if i change this to a 31, and then i can't play the xor on it i'm suddenly being sent 900 pounds that's a huge profit if we weren't doing something else which of course is what i'm about to get to extreme size will be completely useless practically because you could just change the message even if you didn't know what it is things like bank transactions and logins and things like this are always sent in the same format it doesn't make sense for a bank to change the format they use all the time so although they're going to be more complicated than please send mike person please send mike which is computer although very more complicated than this they're not a lot more complicated and so the same bit will often correspond to the same part of the transaction account numbers the values this kind of thing so we can't allow people halfway middlemen to start flipping bits because it's gonna cause a real problem so people have luckily spotted this problem and dealt with it already right, so i'm going to explain how it's done well, you can imagine we might do is a bit like a checksum, right? so we've got a message here right that we want to try and verify that haven't been tampered with so i'm sending you a message. this is my message so what i do is i hash this message, or i can't paid chips i'm on it or something like that and i append that hash to the end of the message so think back to our video on char one the hash is just a usually shorter fixed length string that is essentially a summary or fingerprint of this message and the idea usually is that we can't find another hash for a different message, but it's the same so the problem here. can you finish what it is? surely you can just still change yeah it's totally useless like i've don't do this if you're watching this please don't quit the video now and go brilliant we've got the solution and the problem is if i'm a third party i intercept this message. i stop the transmission i then changed this message to be whatever. i want and then i recompute the hash and attach it and then the person verifying this message on the other end hashes it goes all the hashes match. this is the kind of naive approach which is isn't going to work long term? all right this works on like your disk for making sure that a file hasn't got like checksum errors and things like this beyond that if a security not going to work what we need to have is some kind of shared secret like wall of these things so let's imagine that you and i have shared a key okay? right so we have this secret key that only you and i know what we can do is we can take our message, and we can instead produce a hash of k appended to the message like this right again. don't quit the video yet. we're not i'm going to hit ourselves this is better right it's not complete solution but it's better the nice thing about this is that because i knew you and i know the key right which is it kind of the assumption of encryption? then no one else can change the message they alter the message they aren't going to be able to recompute this hash because they don't have the key that's the idea so this is called a message authentication code now. that works. okay. the problem is the hash functions. we use like sha-1 and sha-256 are based around this merkle-damgard construction which essentially changes their internal state and the problem is you can kind of resume that state and basically? append to the message we can maybe talk about laser extension attacks another time exactly how they work but the idea is that i could append to this message and be able to calculate a new hash reasonably well right, and it's not that difficult to do as long as i can guess the length of the ed key right which is not that hard compared to getting the actual key so this isn't going to work for current hash function ja three isn't? susceptible for this, but shafi doesn't see as much as sha-256 at moment, so this brings us on to our kind of true say our actual usable technique called the h mac which is the h ma see the keyed hash? message authentication code it's actually pretty similar to a standard message of indication code except with two hashes involved and it's completely immune to length extension attacks so what we do is we take our key and we use it to derive two sub keith's like k 1 and k 2 so this is k 2 this is k 1 and then we calculate our hash of k 1 with our message and then we append that to k 2 and we hash it again okay, so q nice animation but the idea is you can't perform the same length extension attack on? this message because essentially we would have to know what the internal state of our hash function was after this middle point which we wouldn't know like we were as we do know it here i mean, i think only personally i will be happy to derive is that ia there's no massive got a very good question okay? so be it either derived by basically taking two constants and xor in them with the key separately okay? so we have one constant then we just compare what they are on person idling. yeah, what's the i pad? rb inner pad is 36 and the outer pad is 5c. okay, this inner pad here is the ipad? which is oh what concerns the other half of the i'll pass along on a minute i? think the age mat construction was first constructed in 1996 so we this one did like actually this doesn't stand for i in terms of information, or you know? internet or anything webby? this is it's this hyper internal, so the ipad is our x 36 in hex the outer pad 53 those were chosen sort of arbitrarily. it's not very important what they are actually these are kind of like nothing up my sleeve numbers but they have it they have a for people who watch david wells's video. they have a large hamming distance between the two but the point is that they have they have that many bits in common, and they're not exactly the same which is crucial look more and more random as we go and at the same time we're bringing in bits from this message to further increase the appearance of randomness but also to make sure that this char function is calculating a digest on this specific message rather than just a general one that's the same every time for this