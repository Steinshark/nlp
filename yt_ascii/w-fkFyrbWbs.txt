a wonderful good morning and welcome to this talk about design patterns the most common misconceptions one of n so someone might not know me i'm not sure but just in case my name is cla eagle bger and perfectly happy if you stick that the first time so i'm close and some of you might know i've written book about e++ soft design which is a book pretty much on well so design and design patterns and so probably because of this and also because of all the training classes you give on the topic i've become kind of the design pattern guy okay this is something that you should not use this is not something that should stick this is i may see that you may not and so i i talk about design patterns this is what i want to do in this talk also but mostly this is not about talking about patterns how they work this talk is about terminology mostly because this is exactly what i find in so many publications in books and ebooks of course and in blocks some design p just explained incorrectly simply because the wrong names are used and i have so many that i had to choose this is why this is one of in i now have chosen the ones that from a point of view occur most often so before we go into the terminology part let's quickly recap what design pattern truly is so first a design pattern has a name that is already pretty essential because by using this name by communicating with this name you well communicate in intent this is what i want to do this is the solution i have in mind super important kind of the one thing that that that that we should not mess up the side patters as such try to reduce dependencies so that they work on a level where we really try to separate concerns try to minimize coupling and they usually do this by introducing some kind of abstraction this is something i'll definitely talk about too but already here couple of pointers yes an abstraction could be just a pointer including function pointers this could be base classes yeah so inheritance hieres templates as well anything design patterns are not just about base classes and do not functions to the very interest just name a few more and the sign patterns are not invented they are actually discovered so they discovered and they're discovered because they have proven to work over the years all right that's what a design pattern is but now for this talk it really is mostly about the name if i say something what do i communicate with this name terminology matters indeed and believe this this is the reason why we have these patterns in the first place and this is kind of what kaa lal also says in her book or in in a chapter of this book the use of design patterns provides us in our daily lives with decisive speed advantages for understanding complex structures this is also why patterns found their way into soft dat years ago consistently applied patterns help us deal with the complexity of source code good so it really is about mastering the complexity of software but of course this only works if the terminology is right so if i use the term builder should have an idea what i'm talking about intuitively you should have idea oh this is what he thinks we should use good then if i use the term factory method again this should give you a pretty good idea what i'm aiming for intuitively if you use the term bridge again ah this conscious of some image perhaps some dependency structure this is what the guy wants to achieve and there's one more term that i want to deal with today the term of design pattern itself in a little more depth so this is indeed the four terms that i want to deal with today not so much on the level of how exactly do the patterns work with a lot of examples but really what do they mean and when should we use the term and when not all right so let's start with the first term the builder pattern so i think this is what the the the idea for this talk started so a couple month ago on a nice morning i encountered this post on linkedin so this is actually site that you can follow to bite by go a lot of very very good visualizations of of complex things so that's definitely a good good resource and on that day there was a post about' key design patterns every developer should know okay this is the ones that you might have heard about that the usual ones and i was also the one here up up in the middle builder okay this was nice but then it was a post by the one of the guys behind by by by go alex who said or asked what is your favorite design pattern and you see that there were a lot of replies a lot of people chimed in and said oh my favorite pattern is and i was really surprised to find how many people said builder that was a little surprising i don't know how about you but i not used a lot of builders in my code so far i think it's a valuable design pattern but it's not really common and so i starting to wonder and asked many people here state that their favorite design pattern their favorite pattern is the builder pattern this makes me very curious which program language do you use and which builder do you refer to a the goof builder pattern i give a link or b josh blocks builder pattern gave another link unfortunately a lot of people replied perhaps they were confused or offended i don't know but at least five people consistently stated oh actually i'm talking about this one i thought about this b joshua block's builder pattern now you might not be directly aware of that so this is joshu block who is pretty famous author of effective java kind of the the java book in the so equivalent to effective c++ and in that book he describes a very useful pattern to implement constructors so now i have implemented this in c c++ in the way we would do today so imagine we have a widget class widget means it's some class but most importantly this class has a lot of constructor parameters many things that i have to provide this is a usual source of errors if you see this this call you just don't know what these numbers are magic numbers 47 maybe the x and zero the y point but you don't really see it at this point so now of course some people say we could use designated initializers today that's great but there's one other approach so the first thing that we definitely should do from my point of view we should not have several integers several integer parameters behind each other we should probably introduce some kind of strong types something that represents x and y and the width and the height perhaps even a title that it's it's a string but this already is a big improvement from an interface perspective i don't really expect x pa and y pa and all of these types and i really have to pass x pass and y pass with etc much better from a readability point of view and it's pretty much impossible to mess this up there is a very consistent ordering of of parameters great but now let's assume there might be even more parameters yeah not just five but 10 or whatever let's assume that many of them have defaults reasonable defaults and i just do not all the time want to provide all of the values because the defaults are just fine but with default values and so many this does not really work well either with these strong types it's much safer than without but it's inconvenient and having several constructors definitely is also not really what i want to have so here's where this block builder pattern comes in we first of all introduce a couple of set functions so we now have a set function for pretty much all of these values for x pass y+ width height and title there maybe more note in particular that we have the same name this is true overloading it's not called set x pa or set y part no we really need overloading at this point okay now we can set the values do not just have the constructor note however also that i might return something okay so i might return a widget to reference to widget all right next step we actually change the constructor the constructor is replaced by constructor that just takes well anything very template parameters we take anything and of course you can go wild with fooding references whatever i keep it simple and now inside i call set on all the values that i get just move or forward whatever these arguments to set wow this means that you cannot pass all the parameters that you want to pass the rest is just defaulted and this means that you can pass any parameters in any order you cannot mess an order up because there is no order it all is just given to the according set function which is easily possible because we have the strong types so when i call this i might give x+ y pass with but i could if i wanted to just omit the y pass which is now defaulted to zero indeed that is cool pretty convenient and definitely allows you to u pass all the parameters that you want to pass and just use the defaults for all the others great this is a pretty useful pattern indeed and so some people refer to this as builder simply because josa plar in the book called it builder however if you are asked what is your favorite design pattern and if you then think about this there's a misconception so i don't say it's a bad pattern no no no don't don't get me wrong but what you should think about design patterns is most likely this book that is where this other design pattern comes from the real design pattern that's the goof book go because gang of four because of the four authors and probably most of you have have seen this before super super old reference for design patterns in this book the gang of four describes in in a short form builder like this separate the construction of a complex object from its representation so that the same construction process can create different representations okay admittedly these short summaries are not entirely bad but they're also not particularly enlightening so let's take a look at what they propose in their book and of course some people cringe it's the book right 1994 that was the time the prime time of object programming so everything in the book is based on inheritance hierarchies and so the builder is to there's some director which constructs something and it uses a builder which is just implemented in various form so this the abstraction we can build something some parts and put them together eventually okay as i said i don't want to go into all the detail i want to go into the relevant parts that's the tic class diagram for that and now in comparison to the blog build is a very very important difference that's a line it's assumed it's implicit in the book but there is a line an architectural boundary and that's actually key that two parts in the code two people potentially that write different code there is the one who just wants to build something but doesn't care about the details and there is the one who knows about the details but doesn't have to have to put the things together with other things so that's the high level abstraction part and there's the detail part and in between this inheritance eror that's an inversion of dependencies all the eras in this little diagram and okay that's just one but all of them point from this detailed part to the abstract part that's an architecture it is an architecture because all the errors cross this line this this boundary in exactly one direction that's what makes this a design pattern i manage dependencies i can change switch implementations easily so there are two builders there's the golf builder and there is joshu block's builder now joshu bl is great i like this i use this a lot too but not as a design pattern so i do not really manage dependencies at all there is no architectural boundary i do not separate two levels of code i mostly do not think about reducing or inverting dependencies and i considered an implementation detail my choice how i implement my constructor super useful not not design pattern and so i would rate this as an api pattern it is a pattern for sure we reused this is commonly recurring but it's more for an api design and so there's something that i believe is super super similar to that that's the fluent interface api pattern so the idea of that which you can take a look at in wikipedia is that you can chain calls very conveniently and kind of build a language like sentences to to do something and this reads really well so again this is some kind of pattern okay first guideline please don't confuse josha pl's builder pattern with a golf builder pattern there are two different ones and if somebody ask about design pattern it is the one from the go book that you should should think about and if you're thinking about constructors then the other one is is nice so what if somebody says do you know builder to you okay then probably you will have to ask which builder you mean so be aware that the term builder is overloaded and it might help when you communicate to prefix this a little bit with golf the golf builder or block spiller and it should be relatively clear what what you're truly talking about all right so that's the first pattern misconception let's talk about the second one factory method oh and this is one of my pet pet terms that is pretty much used for anything now people feel like oh i can use this term for whatever i want to so let's start with well one of my pet examples toy examples let's read some draw some shapes again so i i simplified this quite a bit we have a vector of unic pointers of shape base class yeah please assume this is some base class call this shapes it's short we can draw all the shapes actually have animation so this nice but most importantly we can also read shapes from some json file we give a file name of course we start off with an md vector then we open a file read all the the shapes create circles rectangles you name it and return a vector hopefully nonone zero non empty all right and then in main i well first read the shapes from jason i might have some file name of course here i get some shapes and i draw them all good now the focus of attention is on the read shapes from json function that function takes a file name and returns shapes abstract shapes only pointers to base so this function knows about how to create the shapes right so that's obviously factory create something and that is why so many people in the community more than expected i think this is a great example for this design pattern thingy the factory method design pattern the design pattern that creates something right again not really not really a function that creates something is not a design pattern it's a function it's nothing but a function so note again i don't say it's bad at all this is great this is exactly what we should do we should encapsulate all the knowledge about how to create the shape somehow and so this definitely considerably increases the code quality absolutely yeah as i said encapsulates equation and we are in control to change everything in one place so if if we get a new shape we can add it in here if something changes in the file structure we can change it in here good single responsibility and try fulfilled however have they do with dependencies at this point not really we have not really thought about dependencies so we've not really designed code at this point you've not applied a design pattern and again this is mer a nice convenient implementation detail so now of course you say why is it not i mean it creates something let's just again reintroduce the one thing that we always have when a design pattern is involved let's introduce a line boundary an architectural boundary and again i have these weird terms high level and low level the stuff that uses the abstractions only and the stuff that knows about the details i'll just switch to perhaps slightly more convenient names so let's say the lower part that is your code and the upper part is my code all right so you have a read shapes from json function okay good for you hey great but i seriously don't care about this at all it's your little function that you use in order to structure your code a little better but i don't know about it and honestly i really don't care so i i didn't really design anything and it doesn't affect both sides of this line but all right let's move move towards a real factory let's first say that i am now suddenly interested in creating shapes for whatever reason i want to create shapes too perhaps because i want to create and draw shapes so i've my draw shapes function all right and i would like to create shapes from jason ah that of course at this point definitely doesn't work because it's your function you are in charge of read shapes from jason i actually at this point don't know this function just yet so what do i have to do well navely i have to take the function from you now it's my function i'm not sure if you're happy about this though no no no i i'm i'm pretty sure you're not particularly happy we're both a little bit in trouble now i am unfortunately suddenly in charge of dealing with jason files oh i i i actually don't care about jason structure i i really don't want to know about this stuff that's your your turf and you you unfortunately depend on me you cannot change this function anymore because it's my function it's in my part of the architecture so you depend on my decisions and you are no longer in in control to create the shapes ah so now suddenly we have to communicate suddenly we have to start to design the software so how can we work together well our goal is that i can create the shapes because i need to for some reason but i definitely don't want to depend on the details i don't care about them but you you want to be in charge of the details you know which json file is used which which format and you know which shapes exist i don't want to know so this is is exactly where do factory method design pattern iname all right so again i take a look at this g of for book and we take a quick look at the description of factory method define an interface for creating an object but let subclasses decide which class to instantiate factory method lets a class defer instantiations instantiation to sub classes okay yeah it say subass i know but as i said it's 1994 this is kind of the way of thinking 1994 they don't really mean it let somebody else decide what what to do right this is what they want to say so just to to make things obvious i not change the code in a slightly different way so first of all okay you get your function back it's yours you know the details but as i said i want to well read shapes from jason so i now introduce yes a function pointer okay i know that's the usual reaction when people see a function pointer nowadays this is not because i feel this is the right way of doing things but i'm already drawing you away from thinking oh we need a base class this is just just the function pointer a function pointer that takes a a string file name perhaps something else and returns a vector of shapes i call that thing get my shapes and i draw them all good and now i have given you the ability to give me the implementation details so in other words i don't care about these details still not but you can give me the details you can inject them into my code and so that that little function pointer that is an example for the factor method design pattern that's design so you can tell me what to do how to work how how to exactly create the shapes that little function here your function still a function a factory fun factory function yes but it's your implementation detail that's not the pattern all right so you don't pass this function to the create and draw shapes function i can do all the things and okay then we draw again whatever but this is how how it now works so again there's this line the un class elum that the g of 4 provides implicitly there's a line between this architecture boundary that's the abstract part that's your part yeah that the thing where we where you implement your details all right and again there is some form of dependency inversion going on somehow we manage this we mantion the dependency such that there is an architecture such that all the errors point from one side of the of the boundary to the other side all right so just because at this point some people feel like fu po okay just that you can sleep tonight i also now implement this by means of a class yeah base class hierarchy because some people just demand it so we could of course also have a class shapes factory oh that seems more familiar this function this this class comes with a create function then create and draw shapes takes a reference or pointer to the shapes factory okay why not and i call this cre function and you on your side you could just create a write an own class here your shapes factory it's a pretty silly name but okay you get my point you implement the create function and this of course works just as well so in other words it's it's totally irrelevant how you do that but we can communicate by means of a well- defined interface and by means of some abstraction that inverts the dependencies great so just as a mind u summary factory method is not factory function it's not i know it it sounds super super similar but it's not not the same thing and to make matters worse and i know that is something that people not believe some at least in c++ we actually don't have any methods seriously trust me and it's easy to prove if you go to the c++ standard and i don't mean buy the expensive thing no no no go to the web search for c++ standard draft you'll come to a website or at least two websites online where you can go to the c+ for standard then you click on index and yes you can click they links better than paper and if you if you click on index search for method there's no method in in c++ there's no term method they're functions you have member functions free functions all kinds of functions but there's no method and so if you want to say if you want to say um it just create something use factory function and if you specifically talk about the design pattern you can use factory method okay second kind of proof wikipedia again if you go to the english version factory in object and programming they actually not that too so if you scroll down to terminology the last sentence actually kind of skis us away also the general concept of a factory is often confused with a specific factory method pattern designed pattern okay there is something to improve probably this because of the link but you get the point all right so two different things so please remember that the term factory is heavily overloaded everything is a factory if it creates something but this is not necessarily a factory method design pattern and so distinguish between general idea a factory function creates something and indeed if it creates something you can use the term quite freely but only if you try to customize the creation in some form a customizable factor function then use that term all right second term let's go to the third one let's go to bridge aka pimple idium okay i see some people already have a pretty good idea when i say bridge of course a bridge i've used this multiple times in my code i have hundreds of them ah it's a pretty common one i we've used this in se times actually so let's use an example i use electric cars not necessarily because it's the best example but it now represents one thing that i'm really interested in change things change now this is some branch of technology that i believe changes quickly nowadays and so this now represents change so let's assume that we have some car electric car class the secondly car class might have a battery all right this a pretty useful data member but this now might introduce a lot of problems when developing the code because this battery class i'll just assume is changing often often there's a lot of improvement that can that goes into batteries with every change that i do with every single one this class might change most certainly the e.h header will change every time this this changes somehow so we might have to recompile but it actually might also break abis a battery might become bigger or smaller there can be an ai break anytime so that's exactly what we now want to prevent you want to hide the change we do not want people that use electric cars suffer from changes all place so we now replace this with a pointer okay bigger example i do it a little bit like the gang of four again not strictly necessary but let's introduce a base class again battery okay so the battery can be charged and probably you can do some more things a classic based class and the electric car now has a pointer to a battery probably done by uni point of course okay so how do you get the battery all right and now many publications many books many blocks just say well nothing easier than that let's just pass the battery here right here in the constructor cool that's how we get our battery okay then of course there many batteries just to say that we have many generations and changes again we have a battery gen one that's a real battery implementation okay and that thing is now here this is the the constructor again which takes the battery moves this in the data member all right and in main we are given a batter gen one that's the thing that we not supposed to use it's a bridge right no it's not now that is just a a oops a blame wrong explanation of the bridge design pattern now you say but but cl i've seen this so many times this this must be a bridge if so many people claim that's a bridge that must be a bridge but again it's kind of simple to just prove the opposite so i go to the original book and i just go to the original example that they used in the book okay the original example i know this is this is this slays you it's too much information but the one thing that matters is they use some windows system and there are many different implementations of window of course depending on the technology i use the operating system the many different kinds of windows x window cute window whatever that's details that would like to hide that's details that would like to totally encapsulate away from the user that's also exactly how it is described in the book consider the implementation of a portable window abstraction in a user interface toolkit clients should be able to create a window without committing to a concrete implementation only the window implementation should depend on the platform on which the application runs that's right here no i should not involve the user in this decision it's my knowledge it's my own little implementation detail that would like to hide so let's fix that's the the code example for from the gang of four the original one so yeah it's a little tough to see this kind of code nowadays with raw pointers but just to to point it out explicitly they have this window imp and it really it's just something that is hidden from few entirely the window itself has a window imp pointer and that's a bridge thing it's not passed anywhere it's not given anywhere this is total implementation detail within the class unfortunately unfortunately this example might be a little badly chosen because in the same example there's another pattern this data member here the contents which is given by means of the constructor but that's a different design pattern mixed into this example this is what we refer to as the strategy design pattern dependency injection and so seeing them next to each other this is an obvious difference the contents are given by somebody else so this class the window class doesn't care about the contents it is given that but it very much cares about the window imp it is not given that by the user it cares about this itself and that's two different ideas the strategy pattern is about dependenc injection some external customization point whereas bridge does never use any dependence injection never it's just about internal customization hiding details as much as possible okay so note by the way last note here doesn't really matter how you name your data member if you name this pimple or imple or whatever it doesn't make it a bre which that's not how it works it's really how you use the thing so just make it clear how to probably implement a str a bridge not a strategy so we still have the battery nothing's changed electric car has changed quite a bit simply because it no longer takes a battery in its constructor nope it might take a lot of other stuff but not a battery the battery is a hidden implementation detail okay no dependency ection we still have battery gen one okay still still the same then here in the electric car constructor no dependency injection still but we create our battery ourselves we know what we need we know that right now battery gen one is the right thing to use nobody has to know nobody sees that because it's nicely hidden in the source file that's the purpose of the bridge okay then of course in the main function again there's just no dependency injection users can just drive a car yeah they can enjoy this without having to bother with the battery okay however now at this point we probably should compare the the y class diagrams that is the y class diagram that i would use for bridge so we have this electric car it has a battery that's the has a relation yeah so we have an in battery strike that and we have several different implementations of battery because we can however if you now take a look at how the strategy design pattern looks like this is how it looks like so seriously perhaps you didn't see that i canot back when slide yeah don't blink ah there is a difference but of course you not asking what is the difference i i don't see a real difference here in human class diagram well that's the bad thing about class diagrams you can kind of show relations inheritance relations etc but it cannot show dependencies not directly if you put this into a dependency graph i believe it becomes much clearer so that's this battery class the base class this is electric car that uses a battery so there's a dependency but the electric car has a direct dependency also in the battery gen one direct depends it uses the thing it knows about it directly that's a bridge if i now want to change this to strategy all i know kind of doing is i'm moving the battery gen one down one level there's another boundary electric car no longer is spoted with battery gen one it only knows about the abstraction somebody else now is responsible for this implementation and that's the idea of dependence injection so there is no relation between these two they're on different levels of the architecture all right so please don't confuse bridge the bridge and the strategy design patterns internal versus external external customization points there's a reason why we have these two terms and yes they do mean very different things and so please use the term bridge to refer to some internal customization point no dependenc injection something that we do internally only and use the term strategy to refer to external customization which we usually refer to as dependency injection all right that was the third term but now you've already gotten a little bit of an idea there might be more to design patterns than just object oriented program perhaps a little bit and this is why i know as a fourth term choose the term design patterns itself that came into the talk actually with a review of one of my cpp cont talks so one reviewer of course i have no idea who that was said the following about one of my talks that actually just had design patterns in the title nothing more design patterns in the title i believe that object unit programming and especially its theory is overestimated c++ always had templates and now all has stood variant which makes most of the use of inheritance unnecessary this is the times when you actually wish that some people would not write reviews this is plain wrong this is one of the wrongest statements i've seen in a long time plain wrong i will take care of this in another talk but for now yes i serly have to however in there's now one thing that i also that i here want to point out i did not mention object program at all neither in the title nor in the abstract but the ara jumped to the conclusion i believe that object programming is overestimated interesting the assumption is the sign patterns are object programming right this is what they are this is how they have been introduced no no no and no again perhaps you just point out that this is not something i recently discovered no no no this is age-old knowledge you might have seen or even read this book okay who is aware of that book oh see many many people this is ages old this is from 2001 now andre's torture book torture because at that time temp templates were really young quite fresh and one compiler could compile his code he tortured compilers at the time but it's in the subtitle generic programming and design patterns applied i cannot claim i don't remember honestly that he did not use any inheritance he might in one of the chapters but he very very consistently used templates all over the place this is why it was so difficult for the compilers to compile this code so let's go back to this image the strategy design pattern this is how it was introduced but there's more to that idea dependen injection can happen in so many different ways object program is not the one and only solution or implementation of that pattern the standard library itself uses hundreds of strategies hundreds of them i don't know this sounds a little weird like i've not seen many base class in standard i that's the point there are many many strategies but there is pretty much no base class so let's take a look unic pointer okay super well known most people also know that unic pointer does not just have one template parameter but two the second is the deleter right you yourself can teach unic pointer how to delete the t or what to do with it once the unit pointer goes out of scope you can change that behavior by default it's default delete so by default deletes but you can change that you can change this by injecting some deleter this is dependence injection this is a strategy exactly the same idea just not with a base class but with a template parameter andre in his book called this policy based design it's kind of a different name for the same idea template based but still this is dependency injection second example st vector yeah st vector also has two template parameters a t and an allocator of course we usually forget about the allocator but it's there and this is defaulted the stood allocator which calls new but if you want to if you really want to we can change how vector acquires and releases its memory by injecting an allocator our own one that might do an aligned allocation or some some special purpose stuff we can inject that that's a strategy and just to show one one more class and container an actually has three template parameters that all you to change the behavior all of them strategies so you might realize at this point wow okay there are a couple of strategies but one more example one last i promise accumulate an algorithm so accumulate is the one that well as the name suggest accumulates the numbers by default it do a plus one i can and pass this on my own if i want to so we have some numbers we pass the numbers the range of numbers we pass some some initial value and we could say what to do for instance plus why not it might not have occur to you but this little parameter the fourth parameter allows you to change the behavior it allows you to inject how to accumulate how to reduce whatever the values that this a strategy as well wow there many algorithms you can inject the behavior a lot of strategies and so just for the fun of it one more generate generate takes a vector which has to have the right size already generate takes the numbers and it generates values in this vector you can check this behavior this is of course a no it's not a strategy that's what that's was mean that's a factory method i'm an evil person so okay it it's kind of the same mechanism but it's a different intention so design patterns they have a name you can commun some things but of course you communicate s tension here create something set the values to something in that special case the strategy is more like effectory method which shows yes they're very very similar there are strong overlaps but it is a good thing that we have these different terms so just to be clear on in this one example the classic generate of course takes a template parameter that's the right thing to do but this doesn't have to be the only way i implement this if i wanted to i could very easily also pass this by means of a function pointer no you would not do this no no no but you could it would still give you the ability to change the behavior so function you could also if you really wanted to introduce a base class some generator and you would pass a generator ref something you could do this it would give you the same idea not not really useful here and last but not least if you truly want to do you could also pass a st function same idea you inject the behavior and so all of these have their pros and cons now in the context of the stl definitely that the right thing is the template parameter but depending in on on what you want to do all of these have their merits but also disadvantages so design patterns are everywhere everywhere whatever you do in order to manage dependencies it is a design pattern it's not how it is implemented it definitely is the idea that you communicate so please do not believe design patterns are objectoriented programming they originate there but they are not so they are one of the most essential building plugs for successful softare development and please realize that the terminology around design patterns represents an essential tool to deal with software complexity we want to talk about this we want to communicate this in as as little with as little effort as possible and so come back to this quote which from my point of view is exactly expressing that idea the use of design patterns provides us in our daily lives with the iive speed advantages for understanding complex structures this is also why parents found their way into soft dment years ago consistantly applied patterns help us deal with the complexity of software code source code and so it is mostly about the terminology so terminology matters we should get this right and i hope that these couple of patterns already help to get at least these few terms right okay thank you very much okay you probably have time for a few questions if there are any if not not a problem at all you should get some fresh air and some lunch so enjoy