hi everyone following on from last episode let's go into the unit script and inside of the follow path c routine let's create a bu following path which is initially true and we can also create an int path index which starts at zero and we want to start with our unit facing the first look point in the path so we can say transform. lookat path. look points with an index of zero now this while loop is going to run while we are following the path so let's add that in there and then inside the loop we're going to want to constantly check if the unit has passed the next turn boundary now to do that we're going to need a 2d version of our own position so i'll create a vector 2 called pause 2d equals new vector 2 with transform.position dox and transform.position do zed as the coordinates and then we can say if path. turn boundaries with an index of path index if that has been crossed so we use dot has crossed line with our 2d position is the argument then if the path index is equal to path dot finish line index that means that we've actually finished the path so we'll set following path equal to false otherwise we simply want to increment the path index so we say path index plus+ all right now every frame provided we're still following the path we're going to want to rotate the unit a little bit towards the look point and also move the unit forwards a little bit along the path so let's create a querian target rotation which will set equal to quan do look rotation which takes in a vector 3 for the direction in which we want to look so that will be path. look points path index minus our current position we can then say transform do rotation is equal to quan do lp from our current rotation towards the target rotation with a speed of time. delta time times our turn speed which is a variable we will create in just a moment we then also want to move the unit forwards so we can say transform. translate vector 3. forwards multiplied by time. delta time multiplied by our move speed and then if even though it's the default setting let's just explicitly say that this is using space do self so it's moving relative to its own rotation all right very quickly let's go up here and create public float turn speed set that equal to three by default and we can then save and give this a try so pressing play we should see the unit smoothly following all of these waypoints now one thing if i quickly go into the seeker and set the speed very high say 150 and i press play you can see that the behavior is not quite perfect even if we turn the turn speed up a lot say to 50 still leaves a lot to be desired and that's because it's moving so fast that it's going past multiple turn boundaries in one frame however our code over here only handles updating the path index once per frame so what we'll do is we'll change this if rather to a while so it will keep looping until it's found the last turn boundary that it crossed of course since we're in a while loop now we'll want to break out of it if the following path becomes false so over here just write break if we try this again now we should see that it behaves far better now it is worth mentioning that when you launch the game inside the unity editor the first few frames can have relatively large delta time values and that means that right after hitting the play button the follow path accuracy will be a lot lower than it normally is for example say i press play and let me try pause this at the right moment you can see the unit has shot out all the way over here however if i press pause first and then play and then after a moment unpause it you can see that it follows it much more accurately because it isn't having those first few frames with the abnormally large delta time values so that's just something to obviously keep in mind if you're seeing any erratic behavior in the path following in the first few frames after launching the game let's now make it so that if the target position moves the path automatically updates so going into the unit script we can have a ctin so ion numerator call this update path and we'll just have a while true loop in here so every frame let's say we request a new path from the path request manager now of course requesting a new path every single frame is is not good for performance at all so we could first of all say only update the path if the target has moved more than a certain threshold distance so up at the top of the class somewhere we can create a constant float called something like path update move threshold let's say set that equal to .5 units then in the update path co routine as you not out aware comparing square distances is faster than comparing the actual distance since you can exclude the square root operation so let's say float square move threshold is equal to the path update move threshold squared and we're going to need to keep track of the targets previous position so vector 3 target pause old is equal to target. position and then inside the loop we can say if target. position minus target position old do square magnitude is greater than the square move threshold then we're going to need to request a new path of course at this moment we'll need to update the target position to the target's current position now on top of this we can also add a minimum amount of time that has to pass between each path request so up here let's create cons float min path update time and say set this equal to2 seconds then inside of the while loop we can yield return new wait for seconds min path update time now of course when update path is first called we want to request a new path regardless of whether the target has moved or not so let's copy this and just request a new path right up at the top here but to address the problem i was talking about earlier with large delta time values at the start of the game we can maybe say if time do time since level load is less than some threshold say uh3 seconds perhaps then we're going to yield return new wait for seconds. 3 okay let's bring our start method back we can say start co- routine update path in unity let's now press play and that's working nicely would like to bring these down to more reasonable values so i'll set the speed to 20 and the turn speed to three also want to get my target out in the open here so now when we press play the unit is moving towards the target and if we move this then you can see the path updates so that the unit will follow it all right so that's all very nice what i would like to do in the remainder of this episode is make it so that as the unit reaches the end of the path it actually slows down and comes to a gradual halt now in order to do this we're going to need to be able to calculate how far the unit is from the finish line so if we imagine this is our finish line and this point is the unit's current position then the closest point to the unit on the finish line is the point of intersection of the finish line with a perpendicular line from the unit's position now we have the equation of our finish line in the form y = mx + c and we can get the equation of the perpendicular line in that form as well at the point of intersection the y values of both equations will obviously be the same so we can set the two equations to be equal to one another thus we get m1 * x + c1 is equal to m2 * x + c2 we can easily rearrange this to solve for x and of course by feeding x back into the equation for either one of the two lines we can get the y value as well of the point of intersection so now the problem is as simple as finding the distance between two points all right now to actually code this let's go into the line script and i'll create a public method returning a float called something like distance from point taking an a vector 2 for our point we have already calculated the gradient and y intercept of the line itself and we know the gradient of the perpendicular line so we just need to find the y intercept of the line through point p so we've seen how to do this before over here we just take point doy minus gradient time the point dox so let's write float y intercept perpendicular is equal to p doy minus the gradient which in this case is gradient perpendicular multiplied by p.x then the x coordinate of the point of intersection so i'll call this intersect x is equal to as we saw the y intercept of our second line minus the y intercept of our first line divided by the gradient of our first line minus the gradient of the second line the point of intersection on the y ais is then simply gradient multiplied by intercept x plus the y intercept all right so now we can return vector 2. distance between the given point and a new vector 2 at intersect x and intersect y let's save this and go into our unit script in here i'm then going to make a public float stoping distance which is just how far from the finish line the unit starts slowing down so maybe set this equal to 10 then in the follow pathco routine we'll create a float speed percent it'll set to one and if we're following a path then we want to say speed percent is equal to the distance from the finish line so that would be path dot turn boundary with an index of finish line index do distance from our position 2d so this distance divided by the stopping distance we'll also want to clamp this between 0 and one with math f. clamp o1 and now we've got a value speed percent that is one when the distance from the finish line exceeds the stopping distance and moves toward zero as is the unit gets closer and closer to the finish line so when we are doing our translation we will multiply the speed by the speed percent now there's one potential problem with this implementation say we've got a path that starts somewhere over here and goes around some obstacle and ends up maybe over here now in this case our finish line going through the end point will be something like this the obvious problem here is that the unit will start slowing down somewhere over here since it's close to the finish line despite not being anywhere near to the end of the path i'll now fill in in blue where the look points for this path might be to solve the problem we'll work backwards from the end point summing the distances between each point until the total distance exceeds the stopping distance we'll then record the index of that point as the slowdown index and only start slowing the unit down once it has passed that point so let's go into our path class and add an additional parameter to the constructor float stopping distance and we'll also add a new public readon int that being the slowdown index then at the bottom of the constructor here we can have a not distance from end point which starts at zero and then we'll loop for in i equal to look points do length minus1 while i is greater than zero i minus minus we can say distance from end point gets increased by vector 3. distance between look points with an index of i and the previous look point so look points with an index of i minus one now if the distance from the end point is greater than the stopping distance then we'll say slowdown index is equal to i and we will break out of the loop let's save this and go into the unit and in here we'll say say that we're only going to bother slowing down if the path index is greater than or equal to path. slowdown index and also if the stopping distance is greater than zero all right now as speed percent becomes very very low it's going to take a long time to traverse the last tiny bit of distance to the finish line so what's probably a good idea is to say that if the speed percent becomes lower than some threshold i'll say 0.01 then we're just going to cut off the path right there by saying following path is now equal to false we must also remember to go up here to where we're creating a new path and pass in this additional stopping distance argument all right let's save this and go into unity and here we can try it out so as the unit gets close we should hopefully see it slowing down and it does let's just try this with a slightly higher speed and maybe a greater stopping distance and hopefully it will still work just as well very nice and if we move the target around it still continues to work all right so that is everything for this episode until next time cheers