so hello i'm chris and in this session i will take a i'll take you through an experiment i did and hopefully make the case that online development including the full cycle of software engineering with microcontrollers is actually possible and furthermore that is possible with modern c plus c plus plus 20 and also that with having that in mind that will get even better performance by leveraging c plus plus 20 and modern c plus plus then hundreds and c like solutions so if that sounds compelling to you stay tuned and without further ado let's begin and see how we go about it so [music] so what's the agenda for today at first we'll just you know i'll i give you a bit of motivation already but it will also establish a goal and how we'll go about it in this talk i will explore some tools and libraries online libraries and online tools because you know in this dna everything is about web and you know i think like embedded stuff it's not really leveraged yet in that space so i think it'll be really exciting to see how we can do it and in order to do so we'll do a simple project which will be a switcher based on microcontroller obviously we'll do the full cycle including the design implementation testing and simulation online so that would be the exciting part i'm looking forward to sharing you know that with you hopefully we'll do a small demo of the online tools and we'll see how that works and we'll sum it up just a reminder that if there will be there will be some code just to show off the modern c plus plus so if you have any dark blue background in in in on the slides and that would be something to remember and something to something important so yeah let's go and again so so the motivation obviously we have microcontrollers available you can buy them but what if you actually don't have it and you would like to start so you can imagine the use case that you know and i'm just a developer i would like to try a hobby or i just want to get into arduino or at megas or whatever but i don't have it yet i don't know how to start with it everything seems to be complicated in a motherboard and and what to do well there's not much we can do at the moment well we can but not out of the box so there is like arduino ide however it supports only gcc seven 73 and c 11 out of the box so if you don't do it yourself and change the flags you may not be able to leverage the most modern c plus plus switch which is a bummer what about simulation online that's hard to potentially do as well if you don't have a microcontroller or if you don't have proper tools installed might be difficult to start and everything is about this talk is about how can i easily start i have nothing i just want to go about it and do it right what about modern c plus plus you know if you take a look online you'll find all these c style-like courses with arduino where you have global variables and tons of if statements blah blah blah not the best code system like not also the most performant ones as well which i will try to prove here so all of that is not really encouraging at least to me and i think we can do better and i hope to show that in in this in this talk so what's the goal the goal is to implement a simple project a switcher which will have a button and a la an led which we will try to switch fully online the whole cycle as i pointed out before with c plus plus 20 and with and for multiple architectures so it will be for arduino and for the the the microcontroller which is you know the cheaper version of it as well which is compatible with that library what kind of tools we'll use so for the design there'll be plant uml we'll design our state machine because we'll use the state machine for that for for the for the talk so that we'll avoid all this branching and global variables and stuff so that we planned uml for that implementation we'll use and leverage one of the best tools available to experiment online compiler explorer we'll try to use modern c plus plus compile x plus supports gcc 9 2 or c plus plus 20. it also supports gcc triangle and clank trunk which will leverage for testing because we can do a lot of things with compiler explorer we'll leverage some libraries and we'll do them by including the http which is a unique feature for compiler explorer but it lets us easily experiment with hydrogen libraries we'll also do the cross compilation so we'll do the same code we'll compile the same code for two different architectures and also compile and run the tests all in one instance of compiler explorer which is super powerful and because we can test it immediately we can do tdd and see the results of our test and also the assembly output for probably microcontrollers testing will leverage the ut framework which i'm the author of it's c 20 but that's fine because we can do it inside the compiler explorer we can combine different version of c plus it's a single hydra module not a big one 2 000 live code only requires stl but that's not really important it's macro free so that's why i wanted to use it because i wanted to present the modern c plus plus what about implementation as i pointed out we'll try to leverage state machines instead of trying to go with the naive system-like approach with if else switch statements and stuff like that for the performance reasons and for easy to explain flow reasons as well and also you know i have also the versions with the switch and if but but we'll just compare them so it's c plus plus 14 it's uml 2.5 compliant which is important if you follow the state machine diagrams it's single header so we can include in the god bolt nothing is required for it so neither boost nor stl so it's perfect for embedded stuff because we can just you know pull include that file get it online and just go about it it supports supported without any virtuals rtti no exceptions required it's just perfect for meta staff as well and it has really a lot of policies to get performance out of it and it will be faster than 100 solutions in the end for simulation we'll use a website called tinkercad which allows to to leverage some of the microcontrollers available so there is arduino for example on it which we can experiment with the others as well and there are quite a few components to start with so okay let's dig in into the project as i pointed out the project would be s feature so if we write the requirements for it the feature will be to turn on and off the led when the button is switched so we'll have two scenarios which we'll try to implement assuming that we have a board which has a button an led when we switch the button and when the button is like switched off and the led is off when we switch the button we'll turn on the led obviously that's very simple use case and the other scenario will be the vice versa for for for that use case so we'll get switching via turning on the led via switching the button i hope that makes sense and i hope [music] we can move on so design as i pointed out we'll use plant uml to design it plant uml is a online tool which will allow us to write code like that which is a state machine text based uml diagram and that will generate a code like that so that would be the design i will start in the off state when the button will be pressed and the button is on minion is the high in in the high state we will just you know turn on the led and we'll get to the on state and after that when we press the button again with the and it'll be in the allow state meaning that we switch it off then we'll turn off the led so when we will have the demo i will show the tool itself but you can see how easy it is to start the design you can start from very simple text and get the really nice picture out of it to share with your co-workers or share the design so implementation implementation will be in c plus 20. so we'll start from concepts which are c plus 20 edition so we'll start with the concept component and we'll have three requirements for it will be a setup on and off setup will just set the pin mode and i don't know if we'll just verify whether where we when we read from from the pin and what kind of state it is in and then we'll have you know abstractions because we'll use c plus plus so we want to leverage zero overhead abstractions and one of them will be an led implementation of that concept for the setup we'll just set the pin mode and pin mode this arduino implementation of of the from the library of arduino and we'll set it to output obviously because it's an led and on and off we'll just read already the state of the pin button will be very similar we'll set the pin mode as an input on and off will depend on the pressed function which will read from the pin and if the state is high the button is switched and when the pin is when the state is low the state the button state will be off and it means that the button gonna switch off so i hope that makes sense we have really nice two abstractions with the component as well so moving on okay well just a reminder that concepts are something which is added in c plus plus 20 the type constraints they act like interface for like a documentation for interfaces and they mainly provide the better error messages because they are done on the point of instantiation on the cally side not the not the you know library site so you won't get the error messages from the stl or from within the library which is important they also gives you faster compilation times if you do a lot of spinner in i believe so they're great they come in and let's leverage them when we can so let's dig into the implementation a bit more as i pointed out it's based on the state machine so that our state machine design if you look at it from kind of a raw perspective you can translate this diagram to three row with two rows basically one is that we start from the off stay in the off state we when we press the when the button is pressed and the guard is on when we turn on the led and if you if you in the on state when the button is pressed and it's in the low state we turn off the led i hope that makes sense and and that's the implementation of using the sml library [music] in c plus so if you didn't realize the uml has a specific syntax for for the state machine transition and it you can find it on the transition dsl on the bottom code it starts from the source state after this there is a event in the square brackets you have a guard and followed by the forward slash there is an action and a destination state so if the guard is satisfied so so if you're in the source state and the event is received and the guard associated with that event is satisfied then the action will happen after the forward slash and after that the state will be changed to destination state so that's the way of expressing the flow using the uml state diagrams and you can see on the bottom that the class plus implementation is in sml library is very similar to to the one on the top which which is great because we can leverage the same kind of approach towards both you can see that the star is the initial state after that you have off state event card and action so i hope that makes sense because i'm going quite quick but the point is here that it's super easy to implement state machines and instead of having a global variables which you try to follow everywhere you can just have the flow in the state machine instead so what about the abstraction for the application itself we'll have the switcher which will take the button and the led component instead of type name we can or a class we can put the temp concepts here after that we'll have the switcher constructor which will just do this nifty trick from c plus 20 which is called immediately invoked lambda expressions with the familiar syntax where you can you know get this button and led a in the tss in a sense and absolutely just called setup on on all of them so that will basically do the same as button control and setup led concurrent setup you can imagine that if you have more components that might be beneficial and after that we'll have just the call operator which will copy which will implement the transaction table which we expressed before so that's it that does that's our application there's not much about it there's a you know something to remember it's that c plus plus 20 gives us this nice way of immediately involved function expressions to deal with and it's a really nice pattern if you haven't followed that one i would encourage you to do so because it gives a lot of leverage to to do really cool stuff with tmp so testing i think it's important to do the testing obviously and do the testing with bdd or tdd fashion so wherever you do that we can we can do that with the ut framework and test the state machine it's really hard to test the global state if you have global variables and a lot of if statements but it's really easy to test state machines and here we have just a button and led we create the state machine with the switcher that just fake fake ones and after that we should start in in the off state so we just verify that the state machine is in the off state by default and then we can just process event which is the pressed event and see that it will just change the state to on enough depending when we we switch it accordingly so that's very easy to to test and that's pretty cool to start with but what about the main implementation so that'll be the second main we'll have two mains one is for testing one is for the risk code we'll have the switcher and here we'll have different you know implementations for different microcontrollers for the arduino we'll just use button 2 and led 11 which are the names for the outputs and the inputs which will leverage in the in the demo for the other one we'll just use pb1 or pp0 depending on our board so we can easily change that and after that we have the main loop with the four you know that will just go forever and we'll leverage the same trick as before and process all the events which will come from the state machine state machine has this cool feature to avoid bulletproof codes to give us all the events which are required and we'll just get them processed by just calling and process event of on the state machine so we'll get all the events and we call process event on them and verify the guards whether they on and off so that's pretty cool not a lot of code just to to move on and you see that the design makes it really easy to extend maybe it's an overkill for this very simple example but in the long term when you have a lot of components you can see how beneficial that would be because this 4 here will never change you'll just add more components which are zero overhead abstractions either way so what about the the performance of it because it's kind of important in the you know embedded world and we want to have a small code size and we want to have fast performance so i implemented it using the kind of arduino approach when you have the loop global state and setup and you can see you get 44 lines of assembly i'm not claiming that assemblies the lower number of code assembly is always better because that depends on the instructions but in that case when we have very similar instructions is actually the case so you can see that we compile for [music] for a compiler a specific compiler here specific architecture and we get 44 lines of code if we do it just in main with if else statements we get a bit better because we don't have the global state anymore which had to be shared between the loop and the setup when everything is inlined in one function we get a bit better code better optimize code with 32 lines but still quite quite a lot in comparison to the sml and c plus plus 20 version where we get 24 lines of code so that's the winner and you see that c plus plus 20 by leveraging sml library and you know zero overhead abstractions and all these c plus plus tmp magic here which potentially can give us better a scale of scalability and maintainability in the future because we don't have to repeat ourselves a lot of time actually gives us the most performant code as well just 24 lines of code so yeah that's pretty cool that's exciting so just to sum up with c plus plus 11 or c style like if else globals you can say this just c basically 44 32 lines and with c plus plus 20 state machine approach 24 lines of curve of produce assembly and if you don't believe me you can try it on got bulk to yourself there is a link provided so what about the simulation in order to put that on the tinkercad we'll just do the empty setup and in the loop because thinker guide supports art supports only arduinos we'll just use assembly and just put the assembly output from the compiler explorer into it so that's the nifty trick which we can leverage to not to deal with the external libraries and other stuff in indian tinkercad so that will look like so that's our board for arduino we have an led you know in in on the board we have this feature as well and after that we just copy paste the output from the godbolt into the arduino tinkercad and and we'll just run it and the same for other microcontrollers as well and we'll have to have a different assembly output because of the different instructions but basically that's it so we have a few minutes so let's just try to do the demo so what about the design as i pointed out you can try it online you will get the the image if you go back and we'll go to the implementation that's the part which is the most exciting that's the full implementation of it we'll have the you know two version one when the microcontrollers is defined otherwise if it's not so that's the implementation which i gone through already that's the testing as well so you can see all that has a passing they can be run as well here and as they produce output for the arduino and that's for the other one as well you get 24 lines of code but a bit different instructions as well because this one is using our call and this one is using call whatever doesn't really matter but the idea is that you copy that code into the the tinkercad implementation of the board and you can simulate it and test it as well so here you can test the code itself and that's all the tests which can be run in the godbolt here you have the produced assembly for one one architecture here is for the second one and that's the whole implementation of it and here you can see the includes for the libraries and if you go to simulation you see that you can share it as well like in godbolt so that's pretty cool we can click simulate as well you'll see the code it's copied from the godbolt you can tinker that and and you know change it as well which is super cool we can start the simulation and then we do the switch and we just you know turn on of the led fully online you can share it with your mates as well which is pretty cool we can also check it for the cheaper version of arduino as well which is less than a dollar you see the code copied from the cutball to start the simulation and it also works so that's pretty cool and that's basically it [music] so as you can see just to sum up i believe that online development with microcontrollers is possible especially this possible with c plus 20 with tools like plant uml compiler explorer integra card we explored that you can leverage online tools and start if you don't have anything just see use and see how it works experiment leverage the modern c plus plus modern libraries gain the performance while it's doing that as well so that's even for the advanced users something to to to remember as well as i pointed out you can leverage the libraries get really expressive get well optimized better than the if else or switch cases as well and c plus plus 20 has a lot of and c plus plus itself has a lot of abstractions the overhead and libraries which can be used to to get the most out of it and you know enjoy the development of it so just to sum up i think the the me you know the mission statement here is like just let's embed all the things with c plus plus 20 and let's do it online if you cannot afford microcontrollers or if you don't want to screw them but you want to verify how they works quickly and see whether it's for you or whether you love it just do it online and just go for it slides are provided you can click of them if you wanna verify them and if you interested in sml or ut libraries you can check them on github as well so with that i guess that's it and i'm open for questions