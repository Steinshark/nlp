thank you for joining this talk so let me present myself my name is olivia kine i'm working inside the r d department of groupons groupons is a small company specializing in analyzing data from a clinical trial i guess you all know with the covet vaccine what is a clinical trial so i won't speak of that so let's go back to the talk which is about experimenting with type erasure slash external polymorphism in c plus plus 17. so in fact i was working on a project and i remember that there was a lightning talk in meeting c plus plus form and i think today if you have a nice project and you want to present submit a talk and here i am so let me present my projects which is sas file reader so what's a sas file it's a database storage file created by the sas company with a software and it contains binary encoded data sets for tabular data for advanced analytics business intelligent data management predictive phonetics and more and the more in fact is in clinical trial a lot of the data are stored in this type of file and so what did i decided to do this project is because yes there is a lot of sas reader available of course the official sas reader there is a c reader there is a python reader an r reader a julia reader but there was no c plus plus reader so i didn't find any so i wanted to program one and see oh and compare my implementation with auto implementation so and first i know what i didn't want it to do it's to have this line of code where you have on the left side the data set and a function that just read a file that you give the path do you want it to do that because i didn't want it to manage a data set or data frame which is a very very complex subject and most of the time maybe your implementation you are going to give is not what people want so do you want it to have that and it clearly lacks flexibility you cannot with this you have to read the raw file you cannot access part of the file and things like that so that's not what i wanted so what i wanted is to abstract the file and the data set so for the file i have source a data source and for the data set everything when i will drop the data so the data thing and of course you can have a filter so the only one part of the column of the file so you want to inject column filter so i wanted to have something more like this where you have a reader you pass the source the sync and the current filter but how to do that so object solution is to create a virtual base class in interface then you derive the source the thing the current filter from an interface you propose but then what you passed the diy classes you want to pass them by reference but then you have a lifetime problem you want to pass them with four pointers but that's bad maybe smart pointers but that was not good you still have a great dependency because you have to derive everything from a base class so and then i remember a nice talk from close which has breaking differentiency type erasure a design analysis so and i say why not use this for my project so and i will try to show you or i use this pattern for this project of course there is a lot of type erasure pattern there was another one presented in the c plus plus weekly episode by jason turner but it is quite different because it's using a lambda to map the the object and access the method so it's more like a view on an object but i want to pick up this pattern you can look in this episode it's very nice too but it's a complete different techniques to do type erasure and yeah it yeah it has some advantages but disadvantages too so what is type erasure so i will go back to the original paper from chris and douglas so this pattern allows classes that are not related by inheritance and i have no virtual method to be treated polymorphically this pattern combines c plus plus language features with patterns like adapter and decorator to give the appearance of polymorphic behavior on otherwise emulated classes so and i will take the example from the original paper to explain to you the ide that i presented and it's a screenshot of their paper mostly so the example they wanted to do is to dump or print the state of object in memory for debugging and the object could come from the code the right the right or from external libraries and so of course this again a different option to do that you can think of derive or object from a dumpable base class or you can also use a boot for solution to what is the all your known type inside db object or you can use the external polymorphism so i will show you so you have the first solution so with the base class the tree base solution so you have the done paper with the virtual dump that is and you can register this type of object inside the object db but you have to derive audio object for that deliver bass class so of course it's quite easy but might not be feasible all the time because it requires access to the source code all the class needs so then inherit from a common root class and of course it may change the layout for holding the v table so you cannot use concrete type with this the boot for solution is to adapt your object db so you have different what is the function to store all the objects you want to dump so it of course eliminates the need for common ancestor but on the other hand is tedious maintenance it's aeroprone because a lot of cotton paste and you might have some integration difficulties with different type and things so it's not easy and the third solution is the external probability solution again you have done paper but then you derive a concrete dumpable as a template that will contained in their paper a pointer to the object you want to dump and then the actual them function is delegated to an adapter so it's more or less the code they presented in their paper so you have a collection of jump people and via virtual function you call the adapter so it's looks nice transparent flexible peripheral because you can inject any type but there is a lot of border plates so and it's not that yeah there is a cost attached to this technique so in summary so for example you have a concept with several methods and you want to link into a particular implementation with maybe not exactly the same metal names that's why i introduce here underscore between method and one and you have a model that takes a template model that takes the implementation as a parameter and you have an instance of that implementation inside the class so the virtual method of funnel in the model and with the adapter by the design pattern you link this virtual final method to the actual implementation and if you want to go to the actual value type semantic you have to create an instance via the pimple of which design pattern and so we'll wrap everything nicely and so but of course we have the method one that we call the virtual method one then the adapter and then the actual implementation method one and so on for all the methods so that's it and what we have a value semantic object that can't contend any type of implementation as long as these two methods or the method in the concept are implemented so in summary type erasure enables to use various concrete types through a signal generic interface and it can be compared to doctyping in language like python so apply to the to a reader so you have a constructor with the different type so it allows you to read to write something like that so you have a data source and a data sync so data source will read a file and that i think will be a csv file directly so you write it and here you have read old so we'll read all the rows and so it's converting a sas file into a csv file in one line and so on depending on the method that you provide in the reader you can use different things so i know this is the experimenting part so now we have the goal where i want to go and i will show you what happened so for the data source again it's to think what we need for the data sort what is the method that we want to have for the yes so we want to read of course byte from the data source so we want to read a certain amount of byte and put them in the buffer and we also want to know did we reach the end of the string the stream so that's more or less an easy interface so anything that can implement this will be good for the data thing that was a bit more complicated so the data thing they must know the properties of the file so the different columns that is in the file so we can process them accordingly you must know the adder the metadata and so on so we need to have a method that will tell the thing what are the properties of the file so do whatever you want with it later and then we are going to push the row of the data set one by one and then at the end it's we have to tell the thing okay we are done end of data so the properties for the sas file and sas valley is quite tricky so it really depends the encoding actually depends on the initial platform so it can be 32-bit 62-bits with little or big indiana's it can be unique so windows it can be some compression and so on and it creates a lot of different offsets inside the file depending on all those options foreign so the colony can have a name a label a format specific format and there is more or less a fix finite set of type which is string number intention date time date time and i also put a known just in case something new in expected happens but you have to know that even if the number of type is finite the way they are encoded in the file can vary sometimes you have an integer on one by two by three byte four byte and the same phone number the number of by they can be encountered encoded can can vary for four to eight and yes you have to take care of that and so according to have a formatter so again i use the type erasure concept with for the formatter which i'll format in fact the rule memory to a the the final type that you want so that's the current formatter i can give you depending on the type you can call one of those six function get the string a number integer date time and so on and also edit a method to transform your type to a string and you can also retrieve for example the maximum length of the column which could be for string the maximum length of the string and for the current filter for in fact the concept is quite easy it's a simply do accept this column or not and pass the colon to the model that is provided by the the client code and it accept it or rejected so whatever the rules are so it's usually you have most of the implementation you have on include only this or includes do exclude those but you can think of any other rules and for example i include only integer cologne but you cannot do that with the actual python or reader so just based on a name yeah you can do you can do enables you want with this and so i follow the concept another design pattern from the close presentation so in short for the data source concept so we have these two function that i showed you before and then you have the data source which is a template and you have you have the source object at line 19 so which is directly constructed by a perfect forwarding and in this case called read byte on the source and the end of file on the source directly you can do something else and i will try to show it to you a bit later what else you can do too so what is difference is i define directly a unique pointer so for the source and also a build factory so it's a bit easier to conceptualize what you are going to do and yes so that's the original uh constructor for the video function so i have all the type and i construct i'm using the different build factory to have a yeah just my pointer to pass to a protected constructor so that i completely separated the the construction of the different entities for my reader and i also use a private implementation for the reader so everything is separated from the other file from the actual private implementation so i would show you yes so for the reader that's the actual definition of the different default constructor and destructor and then you have a different methods that are useful for the reader so you can retrieve the properties you can also signal okay no i want to stop reading the file stop end of data i want to skip some rows i want to read all the rows i want to read only one row i want to read a bunch of row and we draw those things it's a bit of a hack but they give you directly access to the rule buffer so and the current row index give you the position in the file that the reader is so that's the private implementation and why i needed to define those reader there with default and not in the other file it's because you have a unique pointer and if you define them in the header the you enter some problem with the mind that all be accessible especially the imp class for the for the reader so you have to define them there in the cpp so you have only one point where everything is managed for the pimple so again for the data source concept destructor virtual district or you have to define them there and then for the protected trader it seems it simply constructing the pimple so the private implementation to build factory function which do the the work so it's a betrayal here but i will tell you why so read data in fact just read the adder and the metadata of the file and that's why i pass properties two's time because in the one it will catch to the other part and the other one you will catch to the metadata and then it will return a variant to a reader template but with the correct engineers compression and platform and everything so after that i use the visitor pattern to create the private implementation for the video with all those parameters correctly set so at the end i have all the offset correctly set into forwarding the file okay and the rest is just passing all the properties to the to the pimp all the metals the pimple and that's it so if you're interested i will show you the structure of a sas file so you have a header with some magic number then you have the indent is alignment and things that you have to read the metadata and then you have a list of page that you can read with data so in fact you have to check for different things of course is it a valid file so check for the magic number then you check the indian is the format for 30 or 62-bit the alignments all of that you read the editor with no two parameters two template parameters in general format and then hit the metadata which give you the compression and then you read the read data which is a template structure that helps you read the whole file and everything from this template parameter you can get all the offset correctly so you don't have to do any if then else or inside the code is in many many implementation of this last reader you can find so and so yes so testing testing was of course a bit easier here in this case but we show you because you have all the components are in fact quite indefinite of each other you don't need an actual source you don't need an actual thing to do every all the testing you can test everything directly it's more or less i think so you can score dependency injection because for your test you can create mock easily in this sense for example this is easy to create in-memory data source or another thing because you don't want anything but of course also i wrote test on actual files to test all the encoding compassion and indianness option so several this is about 80 megabytes of data in 170 files so in the original talk from close to concept major class i declared private so for the errored recently that he made a note about that it's updated talk so the fact that there were private mixed harder to test them directly so and particularly i like to test every part of the code because i know myself i do cut and paste and i make errors so i want to test all the at section levels so so at that time i it's one way to overcome this is to create a prefix smartphone to remember factory to test them but there is another way i will show you you or you can also have in fact that's right you can place everything into a detailed namespace i know there are some people that doesn't like it but that's one way you can do whatever you like here so also in the original presentation you have this type of coal so the virtual final method in the model class is using a free function apply on the model but then if you do that you cannot compile and you have an error because you cannot find it and that's a bit annoying so there's different way to overcome this either you call the methods and you prefix it with a a namespace where all the methods need to be implemented that's one way but then you cannot define the front function inside your class because then you won't be found and also would be nice to have some kind of techniques to go okay i want to to apply this method on this object but please first check if this method is present in that object or called the free function with that object as a parameter so that's more or less the id presented by app server and cppcon 2022 can see professors be 10 times simpler and faster one point i remember when you say hey i have this it's funny it's nice and yes i really like the idea so that is the one way so you qualify the method where all the implementation needs to be defined so before going to the next part of this the presentation i would like to show you something inside compiler explorer to maybe because i know i really like when i see code and it's running so we'll try to show you the actual experiment oh can you read okay so it's pretty easy so yes [music] so that this is quite anti-implementation but there is more or less all the functionalities so i didn't place a the colon filter because you don't need that just a nice thing to have not exactly so you have the template source and sync for the reader you build it that's a protected and you move it into the this is also in sync so yes and here i use the detail so so for the source you have the two function for the model you have the two function and here i use the read bytes and the file so yes and same for it for this thing here only define the push row function and so on and so this is a small test i will show you so we have the reader with the source and the sink and i say there is two rows so i can read one row two row and the third row force is false and so and is the something you can create like this so for the source you have number four that you want to read format the buffers or read bytes the number of fruit that is in the source so you have the output here two one quiz number four and then for the end of file well just as long as there is four we are not done that's why you see but okay for this thing you just push printful on the screen so okay and this is where the adapter function resides so in that namespace so just making the call and so on so it's good but for example can you use a a type coming from the stl for example the ef stream yes so you define that you have string the reader and you simply sorry read from the string for the stream and you turn two if it's good and for the end well it's if it's not good you are at the end or if it's reach the end and so for the tests the second test it's simple so you have here takes directly the type up sorry so you have the string guitars and for this thing i just created the same one yeah and of course it fails because you cannot read anything on a compiler explorer the file doesn't exist so that's why it feels so that's more or less the id i don't know if you have question on this stage or do you want me to shows you some more stuff about this okay okay so next part the thing yes of course [music] yes so i wanted to know oh go to where my interface if for example i wanted to use it to write a python and a rubber package or something difficulties that are denied foresee so more or less it is the same diagram that can be used for python and r so you have a read sas function when you pass a file name a thing and the filters and yeah so you have the reader and in fact that call will instantiate an ins if i will create an instance of a cpp class that will reside in the python or namespace because you can do that that will be in fact one of the only super classes that will reside in both domain and that class will analyze the parameter that passed to it to a factory method to see if the actual sink which is a python object or r object as the correct methods and so if it has the correct method then we can create an underlying sync c plus sync that will have a link to the python object and we'll call that object what i didn't do in this for this wrapper is to have a data source because i just wanted to try for the thing because that's the most important thing and usually most of the time you read the file with the the sas file from the actual disk so i was just using my own data source object for that and so everything was fine it looks okay except that the performances were bad because communication between the different layers c plus plus and python are is in fact slow because you have to do a lot of data conversion so the pressure not so much so it's better to read by chunks of force or in fact reading the wall file and then creating the data frame in the default type that is available in those languages and for this at that time first time i didn't have the end of data method for the cinco de reader so that's the methods that i need to add in my initial design that i completely forgot i showed to you in the first part of the presentation but it came at a much later stage when i tried to implement those rubber so which i think it's always good to test your library for real use case because it makes you hey forgot something and so now i have this so you can have the reader and you can yes yes the super special thing still have a push wall but the python sink or the other thing as push rolls so because you are going to send a bunch of rows back to the single object in the in python language and then yes it works fine so it is the code for the python wrapper so you create for example a sync barrel or sing by chunk or single data so depending on the type of chunk that you want to create this is the default implementation but you can your own python independent implementation for the sink and just created a thing that the user can use directly that will create upon that data frame but you can use whatever you want in fact as long as you have the define the correct function in python for that sake so yes you have this you can read and interesting you would have the properties of the file and the data frame and it's quite easy and of course you can for example read all the file or read part of the file you can skip and whatever you want it's quite easy same for the workers more or less the same syntax but in r and so no i wanted to see and do some benchmark so i took two files they were quite big in the first file there was a lot of columns of different types and the second file was a lot of rows but only two currents and i did some measurement so the first line is the c plus code native how long it takes to read the wall files second line was the python implementation the python wrapper the r wrapper then there is the jeweler implementation which studies the c implementation then there is the the sas video from pandas and under the python library that can read says and so as i'm quite happy with the result i have to say even for for the rubber they're quite good in comparison to the other libraries so what i learned in this project in fact i had to look for name resolution adl because i had some problem with it so like is it better to call directly the the member function or to call a free function i i'm still don't know exactly where i stand on that one i think the free the free methods might be better because then you can really use concrete type or other type it's nice but then you have to yes the the user of your the library of your code need to define the adapter method in a particular name space for example so it's might be a bit too much constraining i don't know so that's something we can discuss but yeah also i realized that very big finals testing if you cannot test something so it's bad design so that's why i had to introduce i want i i need to either separate the concept model class into a detailed namespace and build something factory methods because it helps you to the world testing and yeah you don't have to create your own object directly or if you want you can yes go to the tab value semantic to another class that we create all those things but it's about the same and then you manipulate smart launcher or use the type directly it's just a matter of using the dot or the arrow and so also i have the question of ownership of the injected created object because you they are injecting to the reader but you cannot get them back so it's a bit harder to get them back so you have to somehow have a reference to those objects to what they are manipulating so yeah it's nice but yeah for example the data frame the thing the sync in fact if you want to use an external data frame you have to pass a reference to the data frame you are going to complete inside thing so it's a good if i don't know maybe would be nice if it will be possible to retrieve the sync at the end a bit like in python python is possible because yes but here it's a bit different to retrieve the actual erase type possible but with a dynamic cast and things so i don't know so yes so that's the end a bit shorter than one hour but that gives time for question and i would like to thank you [applause] so first of all thank you and i owe you an apology for the the mistakes on my slides sorry the adl problem indeed i totally overlooked yeah so when i realized the mistake i was indeed i felt very bad and the next time i gave the talk the problem is fixed yeah actually on youtube i put a comment that there is an updated version but as in code nobody reads comments so yes it's hard to find a comment in the list i just want to confirm that i believe that the free function approach is the better one from a dependency point of view yes if you force the dependency into the the objects that use can you have an intrusive design yes if we move this out it's definitely easier yeah but then yes of course you run into the ideal problem yes yes it is i'm sorry no it's okay thank you well i guess it's a continuation of the same what kind of thing methods i think are just genuinely unsafe like you can confirm whether this is the method you actually wanted to extend your kind of class with or not like what if there is like another eight bites that does something else so it's a bit scary i think if you just randomly pull methods but for the adl though i wanted to check what was the problem with non-namespace one so it's like so they can use the front function but i didn't find the freestanding function like free adl yes yes but yes one way is to change the name of the method so but then you create you add a prefix or something sorry so yeah yeah you said you have to you have to qualify yes the the method so i was wondering what exactly was the problem like because there is name clashes so if you use exactly the same name it will try to first fit it to the name of your class of the middle of the model class so you have the same name if i have method one method one it will try to match that one first and then that's not what you want to do and even if you put the main the model it's even worse when you put the model in the private part of your class then it's also clash with the method of your type object so yes so you have to change the name slightly so put a prefix or whatever you want but then that's i think it's a bit ugly so and yeah but might help so yeah it's a hi thank you for the talk so if you have just one reader i guess it's fine or one class i guess it's fine to implement manually or erase type manually but if you have a big project with hundreds of types i guess it would contain a lot of boilerplate course and you wouldn't do wouldn't want to do that manually and there are also a bunch of libraries that provide a possibility to raise types like maybe boost type ratio or dino fully polys it's non-released boost di did you try any of those do you have some preferences i look at boost more or less but yeah but i didn't manage to do exactly what i wanted to do with boosts so and i wanted to try actually the the rule i would say guacamole thing so and see how hard it is to really understand what is happening under the wood so yes so in the big project would you write it manually or you would rather use some library yeah i would write libraries of course but if libraries doesn't fit your need you may still end up to do your own stuff so just as a additional comment temperature is not a particularly difficult thing to do it's 20 30 lines of code per wrapper if you use a library you can reduce this by purpose 10 lines but this is not a lot but now you have bought into another dependency to this library so i would prefer to do it myself but i fully feel with you that it's it's a pain to again again do the same thing especially if you want to do a little optimization in these wrappers this is why we all wish for some language support if you write a concept kind of describe the requirements then if some type of racial wrapper would be generated from that we would all be so much more happy that's true i know yeah yeah that's true because it's just a lot of borrower plates cut and paste of exactly the same thing so but yeah okay thank you