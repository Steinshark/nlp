all right so if you're not joining us on you know twitch you've probably missed out on something pretty amazing going on chad stack is in full swing last night making a breakthrough we're actually like it's possibly viable at this point i think that we could make a pretty simple multi-page application with interactivity using the chad stack of course the chad stack the greatest stack that has ever been created cobalt haskell alpine.js and docker yeah the d's a little weak in chad stack but you know every chad you know sometimes has a hard time you know with with the d anyways so the first thing we were working on is this thing right here cobalt and wheelchair it's a beautiful product okay some of these commits are from 10 years ago okay 10 years ago they've been really working on this thing for quite some time and it allows for this like cgi interaction with cobalt so i'm like okay i could use that and then number two i could drop the apache requirement and just use haskell to do my cgi well there was a problem with it hey flashbang warning and this is my testing browser so suck it so this thing kept happening with haskell where the first item in the path that i'm you know highlighting up there would be dropped from the path and used as the script name and then the rest of the path would be the path you can see right here i am not in the index file my path is slash 22 11. i'm not in in the index my new path is this so how did i accomplish that well in haskell there was no way i could there's no editing right here i couldn't do anything about this this is just how the cgi stuff works i couldn't figure it out i'm terrible at haskell i've never really done any haskell so i figured i could probably do it in cobalt and that's exactly right so one of the first things i found in the old cobalt was this this is all the cgi environment variables this little x here that means it's a it's a new like byte array of size 20. very shocking i was not prepared i think that's what it means i actually don't even know what that really means anyways so i upgraded this script that was the code mobile on wheelchair to start taking out the script name along with the path info because i figured if i can keep track of the script name as well maybe i could put the strings together and you know what putting two strings together is a non-trivial amount of effort to figure out in cobalt i was i was completely i i can't even believe this is real so i found this okay so i figured out how to do an if statement if analyze script is equal to the index.cgi which by the way index.cgi right here that is just what happens this is the default spec right here this default classic app spec makes the very first cgi called index.cgi whatever we just made it happen so we have this analyze script if it's equal to that i'm the index i don't need to do any sort of fancy moving around of anything but if we're not what i need to do is i need to take the analyze script name i need to i don't even know what that means take the analyzed query i still don't know what that means and then i can put both of them into temp yaya and then end the string this actually creates a concatenated string out of two strings i had to make sure that temp query was big enough to be able to house both of these and then i can move my temp query into my analyzed query and then from there i can go through all my routes and try to find where to put it in baby the chad stack is alive so how does it actually work how does this actually work so there's this weird little word called an arouse which of course we ended up finding up here which is just pretty absurd hold on where where are you i don't even know where to look there we go so there's this file this file is like the crux of it all you define all your routes in this file and then the other one cycles through them one at a time so you do have to do something like this you have to define how many routes you have and then that that loop will figure out how to go through each one of them now this is where it gets fantastic so how does that work there's this controllers file this right here is show sum show some i could probably just generate this because this based on the url which will show some like a some sort of argument some sort of argument value one value two what i could do is i could generate all that because you'll see right here that we have it calls this cow template show some.cal so when we do that and we go down to where is it views show some you'll notice that i was able to call and even produce javascript with number one and number two which is the variables that we had up in the url and there you go this actually gets templated in and if you go over here and look because i'm really stupid and this obviously is a problem right here the query selector that can't be happening but nonetheless there's 22 there's 11. there's 22 there's 11. we got it working we can make this work but that's not good enough okay i need to make this pay or file based routing right that's what all the cool kids love is file based routing so this is what i'm thinking if we had a folder called pages inside pages we had show some inside show sum we had value like a colon value one that'd be the name of it colon value two that would be the name of it then we have this index.html where you can just write your html what's going to happen is that it's going to use that whole file based routing to actually produce the required controller that then passes in the variables and then use this as your template create the template compile the cobalt program and boom we have something running that means our little file right here we execute downhill to get sweet sweet cobalt and then we can run our haskell server but the best part is is right before we do that when we're up in here we actually have to go to the cgi bin and every single route is the biggest sibling over so i'm going to create this just amalgamation of just terribleness foreign it's just so ugly i can't believe it's actually gonna work dude the best part about this is that you can actually create something with this it's actually gonna work we're gonna be able to have interactivity multi-page application docker okay everything you've ever wanted in a single application and that my friends is the chad stack okay so i hope you're excited as excited at least as i am because we're gonna successfully create the greatest multi-plage application ever to exist the chat sack you know what's gonna happen after that we're gonna do a little performance test i don't think node is going to be able to keep up with chad no i don't think so i don't think so i even think i could raw dog node and it will be five times slower at producing html than the chad stack i'm putting money on it hey the name is the primogen i gotta press stop record now