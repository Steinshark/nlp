unique pointer is basically a fancy 
wrapper built around `new` and `delete`. and i don't use dynamic allocations.
so i don't need unique pointer.  that's what you might have said 
before you watched this video. part of that is true. by default; a unique pointer is just a 
convenience wrapper around `new` and `delete`. it's referred to as a 
smart pointer because it takes care of calling 
`delete`, so you don't have to remember to. unlike with the x pointer, 
the y pointer gets deleted automatically. but in this video, i'm not here to tell 
you about the basics of unique pointer. if you have no idea what a unique pointer 
is, please see my previous video on the topic.   we'll write a basic implementation 
of it in about 50 lines. and if you already know what a unique pointer is, 
you don't need to watch that previous video i mean, unless you want to. in this video, we're focusing on unique pointer's 
lesser-known second template argument - the deleter. when a unique pointer is destroyed, it doesn't 
just call the builtin `delete` on its managed object. it actually just passes its raw 
pointer to its deleter. it just so happens that the default 
deleter calls the built-in `delete`.  but theoretically, you could put 
pretty much whatever you want there. let's take a look at a classic example 
- interoperability with a c library.   as much as we love c++, there 
are times when an existing library that's already written in c is a better choice 
than rewriting something in c++. but c doesn't have, and probably 
doesn't want, smart pointers. so it's very common for 
library functions written in c to just `malloc` memory, put something in it, 
and then return the pointer to you. and oftentimes, it's up to you, 
the caller, to free that pointer. because the pointer was allocated using `malloc`, 
we need to delete it by using `free`. we can't use the built-in `delete`. therefore we also can't just use 
`unique_ptr` the way we normally would. by default, `unique_ptr` uses 
`delete`, not `free`. so instead, let's define 
our own custom deleter. we define a call operator that the unique 
pointer will call when it's destroyed. and instead of calling `delete`, 
we call `free`. just throw your custom deleter class in the second 
template argument, and you're done. now, at the closing curly brace, 
the `malloc` pointer will be freed. you may be wondering why 
i wrapped `free` up into a class that has a call operator 
with the same signature as `free`. it's actually for efficiency. you can directly pass in 
the `free` function like this. instead of using our `freedeleter` class, we 
could use the `decltype` of the `free` function. this `decltype` is 
a function pointer type. and we're storing the 
value `free` in that function pointer. because the unique pointer actually 
stores its deleter inside of itself, this means that it's storing 
an extra pointer. so if we go ahead and print 
out the size of the unique pointer, we see that it ends up being 
16 bytes, which is the size of two pointers. on the other hand, when 
we use our `freedeleter` class, we don't specify the second argument, 
and it just gets default constructed. but a `freedeleter` instance 
doesn't have any state. standard library implementers are very smart, 
and they do a neat trick here.   because the deleter doesn't have 
any state, they don't store it. so as you can see, the unique 
pointer ends up only being 8 bytes, which is the size of just a pointer. this is what allows a unique pointer to have 
basically no overhead compared to a raw pointer. because when you do it this way, it's 
just syntactic sugar that gets all compiled away. now, the `freedeleter` is something that you 
might want to use over and over again. so it makes sense to 
give it a name. but if you find yourself in a situation where you're 
only going to use this deleter once, you can go ahead and just put it directly
 in the template argument using a lambda like this. this tends to make things longer 
and can quickly become unreadable. so, use with caution. on the other hand, if you're using these 
unique pointers with free deleters all over the place and you find it annoying to 
constantly write this out, then you can use an alias. we use the `using` 
keyword to introduce the alias. and now we just have a c-friendly 
unique pointer that uses `free` instead of `delete`. personally, i often go one step further and define 
a c++-friendly wrapper around the c function. the wrapper just calls the underlying 
c function and wraps it in a unique pointer. doing it this way, there's 
nothing for the caller to forget. they don't need to remember 
to call `free`. they don't need to remember to 
wrap the result in a unique pointer. and there's no question about whether they got 
back an owning pointer or a non-owning pointer. it's a unique pointer, 
so they definitely own it. and this pattern doesn't just apply to heap 
allocation functions like `new` and `malloc`. anytime you have a resource that 
doesn't clean up after itself, you can use a unique pointer 
with a custom deleter. if a c library gave you a file 
handle that was opened with `fopen`, you need to close it with `fclose`. you
 could use a deleter for that. you could even use it 
with a custom allocator. i'm using standard allocator, 
which again just calls `new` and `delete`. but fill in here your favorite 
stack-based or arena allocator or whatever here. we use a lambda to define our 
custom deleter, which just calls `deallocate`. then we just pass that in as the second template argument 
and the second argument of the unique pointer.   the default allocator is stateless and doesn't 
do any work upon construction. so it's most efficient to 
just construct one right here. because our deleter is stateless, 
once again, we just have an 8-byte pointer. if your allocator is stateless, then 
you're going to need to capture it somehow. in this case, i'm 
capturing it by reference. in this case, the unique pointer needs 
to store that reference to that allocator. so it does increase the 
memory usage. so keep that in mind. this is actually a
 case where a unique pointer does have overhead.   you can get around this by using a stateless 
allocator or by storing it in a global variable. now, to the technical part - how do they 
actually implement the deleter in unique pointer? we're not going to be looking at the standard library 
implementation. it's basically unreadable.   but although this is not by any means a complete 
or probably even correct implementation,   it does carry all the main 
ideas in just a few lines of code. if you want to see the basic implementation 
that doesn't even have a deleter, then check out my previous 
video where i explained the whole thing. so for this, we start out by 
adding the deleter template argument. no surprise. we create a `defaultdelete` 
class that just calls `delete`. and set that as the default value 
for the template argument. unlike the version that used `free` on the pointer, 
the version that uses `delete` needs to be a template. this is because while it's possible to `free` a 
void pointer, it's not possible to `delete` a void pointer. okay, once we have our deleter type, then we 
just go down to our private members. and add in a `deleter` member. then, in the destructor and `reset`, and in other places 
where you might expect `delete` to be called, instead, we call the deleter, 
passing in our member pointer. we do an if check here. because although the built-in `delete` 
can handle null pointer, not every deleter can. then there are just a few 
other things that need to be changed. we add convenience functions, 
like adding a getter for the deleter. and then pretty much the only other thing 
that needs to change is constructors. we added a deleter member, so we just need to 
make sure that all of our constructors initialize it. but keep in mind, the most common,
 convenient, and efficient case is this one, when we have a stateless deleter 
that does nothing upon construction. pretty much nothing 
else needs to change. now we have a fully functioning unique pointer 
class that even supports custom deleters. unfortunately though, this
 implementation has one fatal flaw, which we'll see when we 
try to run our example again. when we run our example, 
even with the stateless allocator, we see that our unique pointer is 
taking up 16 bytes instead of eight. because the allocator is stateless, 
we don't really have anything to store. but for some reason, it's 
still taking up eight bytes. this is because, except 
for special exceptions, an object must 
take up at least one byte. so that's one byte for the deleter, eight bytes 
for the pointer, and it takes at least nine. and this class is eight bytes in size, 
so it ends up taking 16 bytes. but if you remember, standard unique 
pointer only took up eight bytes in this case. so how can we achieve that? if you have the great luxury 
of working with c++20 or later, then you have `[[no_unique_address]]`, or if you're on windows 
[[msvc::no_unique_address]]`. maybe they'll implement it 
without the msvc in the future. but with no other changes other 
than adding this no unique address, we're back down to 8 bytes. the `[[no_unique_address]]` attribute 
allows data members to overlap.   in the case of a stateless deleter, allowing it 
to overlap means it doesn't take up any memory.   so this is a hugely important 
attribute to become familiar with. it can really, really improve the data compactness 
and efficiency of your programs.   but remember, i said you can only do this 
if you have the luxury of using c++20.   but standard unique pointer 
works in c++11. so that means they're 
doing something a little bit trickier. they use what's called the 
empty base class optimization (ebo), which is a clever trick 
involving inheriting from your deleter. and explaining that would 
be its own whole video. so comment below if you're stuck on c++17 
or earlier and want to hear about it. and last but certainly not least, i'd like to thank pi for becoming 
an exponential tier patron on patreon. i really appreciate the support 
and encouragement. and i'm glad you think the 
videos are worth it. everyone else, don't forget to subscribe.
 and i'll see you in the next one.