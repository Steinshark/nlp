we're going to talk about going from galwa fields to read solomon codes we must be mad sure really i mean so many of you have said just do read solomon you know you've done hamming codes they can't be that much more complex oh yes they can the stuff we have done earlier and done a fair bit on hamming codes which if you remember are basically going to correct to sing and put write a single error that all happened in the 1960s and in two of the videos out there which will put the links out for you i did a thing called multi-dimensional error correction where i had two bits of information which was a san francisco state of weather so there was two bits for the state of the weather like i think it was 1-1 for sunny or something like that but in order to protect those bits against a one-bit damage i had to add no fewer than three extra bits i had to make it into a five-bit code but it was okay because checking up whether it had been damaged was easy it was a simple parity check it was effectively saying look here's the three parity check bits at the end i've made the rule that overall it must be even parity i know that one of them says one another one says zero but this bit i don't know but it's got to be even parity overall so if i've only got a single one and a zero i need another one to make that grouping be even parity now that's easy error correction how did it advance from that what changed well we're talking about 10 years hence i mean richard hamming is very definitely late 50s early 60s the next phase of this or this big jump forward we want to do by reed and solomon was 10 years later it was late 60s early 70s oh and a big surprise were reed and solomon at bell labs no for a change everybody else seemed to be at bell labs reed and solomon were at i think mit's lincoln laboratory but there was a realization that if you wanted more powerful error correction there were several things you could do but the more they looked into it the more they found themselves having to learn about pure mathematics concepts called galois fields and this is finite field arithmetic where you've got to be able to find a multiplicative and an additive inverse we've tried to prepare you for this by doing isbn book codes which is a very simple manifestation of those two things we thought in our early things were a code word being a string of bits and some of those are information bits and interleaved with them or parked at the right hand end very often were parity check bits what we're now going to try and do is instead of just having one great long string of bits linearly we're going to try and make it be almost two-dimensional think of every one of these positions in your code word now as not being a single bit but a column of bits let's say it's an 8-bit column if you're doing something like read solomon correction on in a cd context you know how big is the bucket size of these columns i think it's something like 40 odd bits but then even that couldn't cope they had like two layers of reed solomon encoding one backing up the other so if you like the filling up of these things instead of linearly going like that and then at the very far end you put a few parity check bits what we now do is we declare that every one of these positions isn't a bit position it's a symbol position but a symbol can be multiple bits okay for the sake of argument let's say it's an 8-bit symbol a byte the way they get filled up is the bit stream comes in and it fills up a column of eight and then it fills up a next column of eight and the next column of eight so it's almost like we've got a two dimensional array now of bits and of symbols in that direction but every symbol is composed of n bits as it goes along what's the advantage of doing that well you can see one advantage when you think about it straight away hamming codes for example the old way tended to presume you'd got the occasional error now and then wide apart what this is anticipating if you can fill up symbol positions is you might get burst errors yeah you might get here we go bits coming off a cd trying to play your music it's encoded music now if they're filling up a bucket in a column in some sense and then moving on to the next one there is just a chance that a localized scratch will get all its bit clobbering over and done with within two symbols shall we say so we know that we can devise codes that can detect and potentially correct a certain number of errors but if we can make it so that those errors are not bit errors within the symbol but just the symbol itself something's wrong with it right you then might stand the chance if you've got again parity check symbols at the far right hand end not parity check bits if they've got enough information in them you might be able to say something went wrong i got a burst error there there's a scratch on that cd can i put it right yes but it's not going to be simple minded parity checking it's going to be serious hardcore stuff because those check symbols at the end will normally be arranged so that if the information is correct and nothing's got damage they'll all be zeros if something gets damaged the first thing you know about it is that the parity check symbols at the end are non-zero you're getting 3 5 12 15. what does that mean well the answer is using lots and lots of detective work and by the way those symbols that you put on the far right-hand end revel in the name syndrome which i think is a wonderful word and my first thought was what on earth are pure mathematicians or communications engineers doing syndromes they're medical aren't they well i looked up in the dictionary and as far as i can make out it all makes sense if you have a certain syndrome it means you are exhibiting symptoms of an underlying problem so the grouping of symptoms that's caused by an underlying problem is often called a syndrome something like the guianbar syndrome isn't i don't know what it is but i'm no doubt it'll all put me right on that but you can see it makes sense the signal that something has gone wrong is you get all of these information bytes or even bigger columns multiple bytes whatever but right at the end is now a checksum from hell you have got a syndrome a set of remainders if you like that are not zeros given only that information how can you work backwards and find out which of these columns got hit and where in the column he got is and the answer is by using galway field theory over finite fields and doing lots and lots of long divisions and additions so the bottom line is that for this work and particularly if you're using as we are of course now powers of two galwa said i can liberate you from how it's having to be primes all the time i can do powers of primes and for all of you future computer scientists that i'm not even aware of you'll love this because your beloved too comes into the real world because you say four and i say don't think of it as 2 times 2 think of it as 2 to the power of 2. and so he said yeah i can do powers of any prime including 2. but what he didn't say is here are the rules if you you light on two and say you want to use my methods here's rule number one everything must be done modulo two not modulo your big number like 256. that's different modulo two so for addition what do we know about edition modulo 2 from bletchley park sean what do mathematic mathematical logicians call addition modulo 2 this is exclusive or it's exclusive or so no sweat for computer scientists all our additions of these numbers represented in bytes or whatever are going to be done with exclusive or worse still as we found out in the isbn previous example you've got to be able to find multiplicative inverses and that's going to lead us into doing long divisions modulo 2 in a galwa finite field now that is a bit hair-raising but not too terrifying but if you're prepared in the end to do all of that work then fine you can use your syndrome and analyze it to tell you where the errors went that's a lot of equation solving for those of you into these things it's like solving lots of simultaneous equations saying the only logical solution to this damage is it absolutely must be column 3 and column 13. that's where the damage has come does that syndrome always work back to giving you precisely one answer yes it's just magic the way that this error correction works but it is complex because the brute force way to do it is to get a set of simultaneous equations and some of you will know this get lots of simultaneous equations to solve use matrix inversion that is computationally a very heavy undertaking and so you're looking all the time for simplifications because if you don't you're sitting there like sean and i were in the early 80s thinking this error correction this is in real time how is this thing solving sets of matrix equations in real time to make sure i can listen to this cd without hearing the scratches where's our supercomputer free with every cd a cray xmp to solve your syndrome equations nope what's the answer you shake your head and you think it's those hardware types it's custom hardware yes custom hardware can fairly easily attain supercomputer capabilities so long as it's in a tightly defined field and it turns out thank heavens that error correction in reed solomon schemes lends itself very nicely indeed to things that computer engineers love like shift registers and all sorts of hardware specials now i've got the tokens with all the possible three bit combinations but i carefully arranged so that the three zeros which i'm now using for ack three ones as knack i put them at the diametrically opposite corners of the queue and what is magic about doing that