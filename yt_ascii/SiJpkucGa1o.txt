i wanted to talk a little bit about about image filtering. we had a video on image filtering a while ago on gaussian blurs and mean blurs and this kind of thing but remember we talked about convolutions and convolutions are actually used in a lot of places. so sobel operator for edge detection but also in deep networks, so deep networks have convolutions in as well so a huge problem with something like a gaussian blur is let's suppose we want to do a really big one right, we want to do a huge blur to really blow out an image. so you're talking about increasing the size of the kernel that's right the radius of the gaussian and the size of the window that we're sliding across is going to get much much bigger suppose you want to do is that even as even a relatively small standard deviation? you're going to have a very very large window, but you're sliding across during your convolution. that's going to get slow really really quickly let's remind ourselves very briefly. what a convolution is so let's suppose you have an image which is agreed i've always had bad luck drawing grids in computer file videos. they never come out parallel. i've seen what i mean we have something called a kernel right which is our filter that we're passing over this image so let's say we've got a very simple one which is our sobel filter or gaussian filter, which is a three by three now what we do on our image has put a bounds on there we go if we place this kernel over here over the top three and we do a sum product so we do the multiple of this one and this one plus this one and this one plus this one times this one plus this one times this one plus this one times this one and so on and now for a three by three operator that's going to be pretty quick right you can write this in c or something like that it's gonna go really really quickly and that's broadly speaking what a deep network does just doesn't lots and lots of times the probabilities that suppose we want to do like a big gaussian blur or really large window this is gonna get slow really really quickly because to every position in this image we're doing nine products and then adding them all up if this window is ten by ten or twenty by twenty or a hundred by a hundred the amount of operations per pixel is going to get really quite large and we're talking minutes to hours to just pass over this image and yet the thing is if you go into photoshop or you go into an image processing package and you perform a really really large blur. it doesn't take minutes or hours, right? because that's not acceptable. it goes very very quickly. and so what they're doing really is cheating, right? kind of what we're gonna do is we turn this kernel into an identical one in two passes where we have a 1 by 3 and then a 3 by 1 like that and what we're saying is if we convolve our image first by this one and then by this one we get the exact same product as we would have got if we just did it with the 3 by 3 and we've only used 6 values and that's going to get better and better valar and larger your kernel kernel goes okay, let's hang a minute. right? the first thing to note is we can't just have any you know n by n filter and decompose it into 2 1 by n filters and it definitely work right we have to make sure that the process of doing horizontal followed by vertical or vice versa is going to perform the exact same operation as the original combined filter and really this is a simple matrix multiplication. so you've got a situation where you want this matrix here however, big it is to be this one times by this one which means that if you convolve any image with these two, you're actually doing it with this right is easier isn't it on a short of it now that isn't true of every filter? it's true of a sobel you can split sobel up and it's true of gaussians and it's true of mean box blurs and so on but it's not true of any kernel you wanted to use right which is kind of relevant to deep learning. but but that's i'll mention that at the end. so, how does this work? well, let's imagine that we're convolving a pixel with this horizontal blur, right? so we've got our image which is going to be something like this. so you can also converting fast fourier transform. so that's another time right actually that is another time because because that's really fast that is that what it's called fast? no all right. so let's imagine we're looking at this pixel here now what we would normally do is we'd sort of put our our three by three kernel over here and we do this sum product right, but what we're going to do first is the horizontal pass so actually we're going to do it over this one this pixel here is going to include this one and it's going to include this one like sometimes in graphics they call this together in this one and this one and this one and this one but so this is going to be calculated using these three pixels this one is going to be calculated using these three pixels this one's going to be calculated using these three pixels. and that means that when we finally do our vertical pass here we're actually bringing this pixel in here like this and what you can see we've brought information from these four pixels which we haven't our boys done we haven't actually looked at those pixels with respect to here, but actually we've got that information and we've saved a bit of time right if you've got an n-by-n kernel and the number of alterations you're going to need to do for square kernel is going to be n squared it's going to be 2n for a vertical followed by a horizontal pass i've coded this up and let's see how much faster it is. we need a computer. where did i put it? i started writing some python code that i was gonna i'm going to release the code, right? so i tried to make it is, you know simple as possible. so there were libraries in python to do this like opencv, right? and they'll probably do it faster than my code. i wasn't really interested in how fast it was apart from a comparison, right and i also wanted people to be able to see how it works so what i've done is i've implemented it in python but it was too slow because python is not really suitable for you know, low-level pixel manipulations so what i did was i then used syphon to compile this python into c. and that's much much faster so if you want to look at the code, we'll put a link in the description. so essentially, this is very very simple. we load an image up. we turn it into a an array and then we pass it off to siphon which does a convolution with any kernel that we provide and then returns a response and at the moment what it's doing is it's doing a 2d gaussian blur over quite a large image so i've got this image, but i took this morning of a section of my christmas tree so, you know that's looks like many other people's christmas trees. it's a ball ball on it too many bubbles actually and at the moment. it's relatively sharp, right? but let's imagine we want to blur this image i'm going to blur it with a two dimensional gaussian of size 10 - oh that's a standard deviation of 10 the radius is going to be somewhere around 60 pixels something like that like to cover for the entire range of the gaussian so that's the one that now so i've already compiled the python into c and the c into anyway so this is quite a large image. i think it's something like 16 megapixels or 20 megapixels or somewhere? i don't know. i'm running on one of our servers nobody really matters it's going to take quite a long time because for every pixel in our image we're looking at a 60 by 60 window, right? this is the long 2d version right, which is why it's taking so long. in fact, we might want to go and get a coffee thank you it's not dependent on what those pixels eyes just it doesn't matter about what the pixels are the operations per pixel are the same. obviously it matters a little bit what the size of image is it's still going i mean we could work out roughly how many operations this has to do, but it's a lot i mean it's hard to know exactly how many it does because there are also bounds checks and things like this not all the time but some of the times so we could probably you say at least this money. yeah, i still going it's still a big it's muscle but yes it is if our server yeah, we're - cause it's not motivated though gpus would do this really really quickly but you still shouldn't be doing 2d convolutions like this because it's incredibly slow. so it's four nine one two pixels by 3 2 6 4 3 2 6 4 which is 16 megapixels and for each megapixel. so for each pixel it's going to do about 60 squared operations so times 60 times 60 that's quite a lot of operations actually see 37 billion and that's about the bounce checking and we have a business it has to do. oh, it's finished it took'9 seconds is it looking person? well, let's see it won't know it will be i mean, can you imagine you had to wait this long to do anything in photoshop? it would just be really bad news. so let's have a quick look at them. here's my output image and you can see we've managed to obtain a slight blur like was the standard deviation of 10 on the 16 megapixel image it's not actually that much you're going to need to do a standard deviation of into this sort of dozens before you start to know some real serious blur the complexity of this problem is n squared even increasing the standard deviation by a few more will massively increase the amount of time it takes so let's see if we can improve things so i'm gonna i'm going to remove that code and i'm going to instead run it in two passes so instead of going from the image to the output i go from the original image i do an n by 1 convolution into an intermediate image and then i convolve that with the vertical version into the final image so there's two convolutions, but it won't take double the time. so let's run it still pretty big image so the original one took'9 seconds eight seconds pretty good but eight seconds is now into the point where you could if as long as you had some progress bar or something on app people i'm gonna get too annoyed about it, right? so let's let's increase the standard deviation of this. let's do it a little bit more of an epic blur so forty five in my code a kernel of standard deviation 45 requires a window size or kernel size of 271 so for every pixel it would be doing 271 squared operations new so let's just do a single 271 by one and then a one by 271. all right so this one that see how long it takes this will take longer than eight seconds because it's much bigger than ten but not a huge amount longer, right? it goes up a little bit within rather than squaring. i'm gonna guess. all right so so quiz, i think 21 seconds okay, i have no, you know, i'm basing this on nothing but random guesswork path seems plausible yeah, how long's it been now course you don't know when is going to appeal my screen i could go that took 36 seconds, so not too bad, right that's a very large if you look at the actual blur itself, i mean you can't see anything anymore you know, it just looks like my camera work i'm thinking today to my yeah for my sins eggnog latte just once per year otherwise just a special treat near the end of the year