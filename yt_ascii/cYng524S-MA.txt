all right so what is this right here we've seen i do remember java started this like 1 billion row challenge i didn't realize that a bunch of are a bunch of languages now doing this 1 billion row challenge is this like a is this like a thing cuz i mean go sounds fantastic yeah they are the the 1 billion row challenge is intended to be a fun exploration of how far modern java can be pushed for aggregation 1 billion rows from a text file okay so they are okay so effectively it's how fast can you read and do something with one billion rows of data in a language so it's kind of like let's let's let's go to a pretty far case and then you have to do super weird programming to make it successful right all right anyways sometimes around the middle of january i stumbled across the 1 billion row challenge i had a lot of fun working on this i started with an execution time of larger than 6 minutes and finished at 14 seconds okay okay this sounds good what is the 1 billion row challenge and input a text file containing temperature values for a range of weather stations each row is one measurement in the format of string station name float measurement output for each unique station find the minimum average and maximum temperature recorded and admit the final result on standard out in the stations names alphabetical order with the format this 14 seconds dude i'm not going to lie to you if i could if if i could last 14 seconds i mean that would be an achievement in of itself okay i'm just letting you know i i would be stoked this is fantastic by the way 14 14 seconds to do a billion rows is still very impressive okay same brother yes hell hell yeah hell yeah ja dude java can do a 1.4 second damn what a lucky man what a lucky man let's see no constraints working with this temperature values are within effectively 100 up 100 down okay okay the temperature value has only exactly one fraction of a digit the bite length of the station is within this there will be a maximum of 10,000 unique stations rounding of the temperature must be done using semantics of i e 754 rounding direction round towards positive i don't what is what is round towards positive does that mean you just you just always round up you effectively just seal it's in the name dummy you just seal at all times i thought we just called that seal by the way every time i say seal i just i literally cannot help but to think i every time in my head somewhere deep down i go every single time i make a weird sound like i okay that's it sounds much weirder when you do it out loud you know now that i now that i did it out loud that sounds weird okay now that i've done it out loud i feel kind of weird about it but that's right think about every single time you ruin seal for me yeah i'm going to ruin seal for you cuz now you're going to think about seal seals the whole time the wrong kind of seals okay what are you going to do i think of batman forever what okay i know we're like trying to stay on on on track can somebody can somebody please explain batman can please can you explain why you think of batman forever when you see the word seal kiss from a rose seal wow that's wow okay okay okay eight okay okay okay sounds simple enough what's the catch the input file has 1 billion rows how big is a billion it's it's less than a trillion i can tell you that much if you started counting to one billion at a rate of three seconds per number that would take my guess is 99 years 95 years okay i was close i thought it was 33 years per billion if it's one out a second anyways the challenge is to process the file to print out the output in the least amount of time possible it's summarized nicely in this picture okay yeah yeah tools i'm working with the challenge was initially in induced introduced for java but folks started trying it out in different languages you can check out the discussion about the one brc in goang i solved this using goang 1.21 all benchmarks are ran on an apple m1 pro apple silicon mentioned apple silicon mentioned apparently sushi dragon told me a really cool story where he is like he is exploring the apple m1 stuff for for his kind of really crazy streaming setup and it consumes assumes like significantly less energy and it's just as fast and he's like very happy about it apple fanboy exposed d i don't even own an apple i actually i might i actually am curious if i do anyways a 2021 model with 16 gigs of memory and 10 vcpu the input file with 1 billion rows is about 16 gb you can find the github repository with my solution here i took the approach of solving this iteratively doing so helped me track my progress you can find the iterations documented in the repos read me with each iteration i focused on optimizing one of these three areas data structure concurrency reading the file now that all of this is out of the way let's dive in by the way i do want to do this again this would be like one of the things i'd want to do full-time content creation creation i wonder so what would be kind of fun is do you think that who do you think would produce better code gemini brock or jiid to solve this problem or co-pilot none probably none they would all produce shitty one i love you grug minstrel is minstrel a thing dolly dolly will just produce images of the weather stations you are ai i am i am i am i'm definitely not like i'm definitely i'm definitely not like not general ai i'm definitely i'm still learning i still have some problems like it's hard for me to self-learn we're getting places all right baseline implementation i start with the naive implementation to establish the base baseline runtime the first iteration did not make use of any concurrency good read a file line by line the input file each line can be processed independently so i started by reading the file line by line for this i used buff io's scanner with the default split function scan lines a pretty standard way to read the file read a file line by line in go l scanner is handy face that reads from file and see and returns contents up to the split defined for us this means a new character sln will not be returned for each line okay that makes sense so we won't have to handle it separately foreshadowing this is where the problem lies with this method of reading a file okay interesting okay ai vetle mentioned vetle mentioned did i just get a vetle thank you toaster chicken i appreciate that thank you by the way i i left alerts on boys we left alerts on alerts are on yeah i did i walked on stage it was fantastic data structure map to store all the temperature values recorded for each yeah okay this is what i would do as well the output requires minimum maximum and average temperatures rounded in each city so i initial initially started with a map that stored the all temperatures recorded for each unique station each station stored a string type and each temperature stored a float 64 type making this map signature map string float okay fair oh wait hold on wait no that's no no no no he said that wrong that's a that's a an array of floats you stored all the arrays you didn't just why would you store all the arrays anyways i would even think about storing the arrays i would just i would assume you' just do a summon account right i discovered your channel recently oh thank you as each line read from the file values were added to this map accordingly after the the entire file file contents are read and the map is constructed we iterate through each key value pair in the map and calculate the min max and average values okay so this is who here would probably create it something like this who would do something along this whole line of just reading line by line throwing it all in a map and calling it a day i think a lot of people would probably start there a lot of people would start there i would have started with the aggregate value with counting sum min and max i always reduce my loads when i can damn yeah i probably wouldn't start with an array because an array just requires more programming for me just being able to just do a quick if check as each one comes through it just feels easier if that makes sense i wonder what the i wonder what the answer is so in my head before looking forward without looking at what the the better thing to do is is that there has to be a way that you want to pass these values you want to be able to effectively have a bunch you want a bunch of threads doing something right but you need to be able to you need a way so that you can split out all these threads without now this is the big trick here you want to be able to do it without having to use a mutex right cuz that's where things get all that's where things get all terrible is once you use a mutex you then cause you cause things to slow down you don't want to do that so you could imagine that you could have like almost what it's like how i would refer to it as like a a consistent hash right so you could you could imagine that in my head how i would try to speed things up is that every city that starts with an a goes to a specific thread that's running and each one goes to a different thread so all a's are sorted in one area all b's are sorted in in one area all c's are sorted in one area so that way there's no they can all just run independently that like at least that's how i would i would like a thread index by key exactly that's like how i would think of it i don't know if that's i don't know if that's true i don't know if it's any good but that's i i would use a some sort of consistent hash that's like that's what i would that's like that's the first thing i think of how let's see how would you load b let's see how would you balance the load then i wouldn't try to balance the load not at first right cuz i don't know if there's any sort of like you know what i mean yeah i wouldn't do this either so someone just said do this right here i wouldn't do this either so this is so the reason why you don't want to do this is that there's one billion rows you have to do 1 billion divided by what you do is you just have a sum and a count right if you just have a sum and a count you already know the average at the very end right so that way you only do 10,000 divides all right you don't need to balance the load first first up a number of go routines that is guaranteed to be greater than 2x the cores and send messages in see that's kind of what i want to do so that's kind of how i'm thinking about it right if you just have the sum and count you're good won't the sum possibly overflow use a 64 then well you got to remember look at this will the sum overflow there's some rules to it which is the temperatures between 999 and positive 999 so that means you already know that you can only be less than you know you won't be any less than negative 100 and greater than 100 so a billion of those would be 100 billion right if it was all positive numbers in one location that's 100 billion that means you only need like what a 38 bit number to store all those so a 64 is plenty right it overflow on an in32 but you're using a float 64 anyways i just use the middle out strategy everyone's pretty much favored okay let's keep on going but that's how i would want to do it all right concurrency processes each mix let's see stations min max and average temperatures in separate go routines okay the first place i introduced concurrency was the last stage of execution for each city in in the map i instantiated a new go routine to process the city's min max and average temperatures oh that's clever okay so he went with literally just do it on a per city basis okay interesting i code up to this point can be found here so in my head i'd rather use a a fix sized array this improved performance by 100 seconds oh my goodness oh my goodness can someone drop the article for this yeah this is a great this is a great this is a great article 100 seconds that's pretty impressive okay okay i like it this is inefficient because we're spinning up too many go routines a maximum of 10,000 one for each station the go scheduler is spending more time managing the go rains than actual work we will fix this in the future iterations okay okay concurrency decoupling reading and processing of file contents currently we are reading a line from the file part parsing the station name and temperature and adding it to a map and then reading the next line doing this sequentially means that we are not taking advantage of all the cpu cores instead we are reading a line waiting to finish processing it before reading the next line to overcome this i decoupled reading and processing of lines i introduced two go routines a producer go routine responsible for scanning lines and a consumer go routine to process reading these lines okay that makes sense okay so now this is we're getting closer we're getting closer sup what's up baby i like like where this is going this is a good idea to communicate between these two go routines send the read lines from the producer to to the consumer go routine i used a channel all right channels are blocking the best way explained by the concurrency and go by katherine cox budet all any go routine that attempts to write to a channel that is full will wait until the channel has been emptied any go routine that attempts to read from a channel that is empty will wait until the one item is placed in it i just assume you make your channel big enough right isn't that like just like an easy way to kind of avoid it this means if we don't use a a buffer channel when one go routine is executing the other will be blocked okay i'm a genius i'm a genius let's see using an unbuffered channel the execution time indeed increased twofold nice cpu profiling the code we can see the most amount of time is going in go routine switches okay so we pretty much just sit there and is that what this is so i don't know what these things are that are i can't read this cuz i don't understand it i guess let's see go ready funk is go ready funk that one or is it this one oh schedule i guess yeah runtime. schedule yeah it looks like runtime schedule and runnable is just like just like getting whammed right there w this makes sense in alliance with our understanding of unbuffered channels okay using a buffer channel using a buffer channel with capacity 100 i just why why stop at 100 okay like why stop at a 100 why not a thousand it's a billion right anyways using a buffer channel with capacity 100 we see the performance increased by 50% compared to the unbuffered channel so that means you're at 4 and a half minutes so you're back to like nominal okay that does not look like 50% there buddy okay that's not 50% there i don't know if you guys can see that but 5 minutes and 22 seconds is not 50% of 9 minutes and 12 seconds okay we're doing some loose we're doing some loose ma some loose math here all right make channel one billion all right the code and profiles i'll point to can be found here okay we i feel like all this is like making sense cuz we haven't done anything different really like if you really think about it we haven't done anything that is fundamentally changing how much work he's doing but this still got slower than the previous iteration looking at the cpu profile we noticed that there's a sign significant time going into runtime channel receive people are just hanging out doing nothing let's see what are we looking at what are we looking at i do like okay i do want to take a pause here for a quick second i really like that he's taking the time and even though i feel like i could just improve this immediately he's not doing what he thinks is faster he is first profiling and then thinking about what he should do so you can see right here read file line by line into map is going real slow and channel receive is a huge portion of it right here right and then you can see this one right here a lot of p thread condition weight a lot of time spent in p thread condition weight and you sleep and this so these all seem very excited if i remember correctly if you keep a nice discreet stack size like 100 go will keep the references on the stack which makes it much faster oh okay that's good to know i like this setting a slice of lines on the channel one way to reduce the number of items we send on the channel is to chunk a few lines together in a slice and then send it over to the channel this means the chan channel type will change from string to string array okay okay buffer channels this this this seems like a good idea since the channel type is slice to avoid race conditions we need to create a copy of the slice to send it over the channel alternatively we can use sync. poool and reuse the memory and the limitation let's see in limit memory allocation i would just one would just simply assume that creating a new array might be easier i don't see why anyways whatever go has a handy data race detector which can be used by adding dash race flag when running your code okay look at that i don't i don't even want to know about all this all this code code after these change let's see changes in the state running this execution time comes down by 160 seconds now this is real this is good if go is keeping things on the stack then memory allocation shouldn't be a huge concern i'm not sure you i don't think you can keep this on the stack can you i'm not really sure how that would work with passing stuff through channels and keeping things on stack and stuff like that in my head i don't i don't i'd have to write it myself pretty much to understand why that works because i don't it'll only keep the references on stack judo isn't all references always on stack unless if you have unless if you have a double pointer how do they keep how do they keep a reference on the on the heap because don't you need a reference from the stack to look it up on the heap judo now you're now you're damn confusing me judo okay something has to be on the stack anyways data structures use n64 instead of float 64 really at this point i add a test in the ci and realized my tests were failing due to how i was rounding according to the constraints rounding should be done using the semantics of iple e 754 rounding detection round towards positive i fixed this by parsing the temperature string into int and then doing a summation int and converting it to a float 64 only after the calculations have been done this ended up improving considerably by almost 40 seconds wow that's a lot this ended by i'm surprised by that was surprised to see that there's such a significant performance improvement with this change i guess parsing a float is significantly more complicated than parsing an int i think that makes i think that makes sense now that i think about that i think that probably makes a lot more sense that parsing a parsing an int has to be easier well because floats can be like represented in all sorts of different i mean there's so much to floats it's about cpu registers i mean parsing a float is more work yes i assume there's there's because an int is just literally it's just a specific character range with the minus sign right floats have more the data is fixed fixed point yes but i'm just saying an int is but i can't imagine it's that much anyways i don't i don't know i don't get it results will wild very widely based on cpu architecture individual alu fpu performance as well as actual numbers of alus and f fpus available per core in super scaler designs which influence how many independent operations can be executed in parallel this means your hardw will play a major factor in determining how much this change will contribute to performance improvement a classic it depends moment there we go look at that there we go that's the data structure we were talking about i knew this would be the best i just knew it in the baseline this feels like a very obvious one right and it also feels easier honestly cuz then you don't have to you don't have to take you don't have to take a value read it put it into an array and then later rego over all the values and keep track of all four of those things it said you can have that all as one operation which just makes it seem like it's way easier right in the baseline implementation we're using a map of string to float float array where the each station we are storing all the temperatures recorded this is wasteful as we don't actually need to store the temperatures and it's just honestly simpler we can simply store the minimum maximum sum and count of all temperatures with this change we'll see performance improvements for two reasons one decreased memory allocations this will go from storing a slice of around 100,000 in 64 items to let's see more or less equaling whatever this is to ex storing exactly four oh really you're not doing an object you're doing you're doing like a little array okay i mean i guess that makes sense i like by the way i love this kind of stuff when you when you toss in an array like this i like it i like that this significantly decreases our memory footprint decreasing the number of go routines in the last step we can get rid of spinning up go routines to process temperatures of each station as we already processing the min max and count values while constructing the map itself this means the go schedule needs to worry about significantly lesser number of go routines making this change the execution time went down by 70 seconds which is a huge amount at this point let's see code and profiles till this point can be found here okay look at that we're getting low we're getting low i like this optimizing all three read chunks instead of one line at a time oh yeah so in other words my guess is this is just like take a file and read out whatever is like optimal to read out i don't know what i don't know if there's like an optimal amount of space you should read from a file but you can instead of having something that scans it in right you can just read a huge chunk and then you can just do it yourself in the baseline implementation we use buff iio scanner and read by file contents line by line while this is a handy interface it reads the file contents performs some checks and then iterates over it and returns a single line without whit space character if we read each file in chunks it will help performance in two ways single iteration over the btes when parsing the city temperatures we will avoid iterating over bytes that scanner f internally does yep you get yeah you get a little you get some nice ones right there it depends on the situation 128 is a good general value oh interesting okay hey hi hi from youtube hi this makes sense because you also get you i mean both are o of n but n drops a constant right to reduce the number of items sent over the channel we will be sending 100 lines together in a string slice we are sending one 10,000 items over the channel if we read 64 megabytes chunk from the file and send it over the channel that will be 256 items very significant reduction okay this is this is actually pretty neat i like this to process each chunk independently we should end in a new line we can do this in two ways after the chunk is read read until the next new line concatenate to the two bites and send it over the channel slice the read bites till the last new line the leftover chunk can be sent along with the next chunk read that's how i do it right here i would assume that you could just have an array that already exists and just mem copy it into your like temp array and then you don't have to like you don't have to do something clever like this because that's way too clever it's way too clever trying to do making it work out i first went with the first option as it was more clean to write and required less slice copying to implement i decided to use a buffered io buff reader i read a file in 64 megabyte chunks let's see to read till the new next line character i use read byes method this did not improve performance as read bites method again iterates over the characters to find the delimiter but there's something more both scanner scans method and reader read method internally calls os read but as they provide more functionality beyond simply reading the file they do extra processing on top of it look at the implementation for each okay so they do stuff they do stuff for our use case we really don't need these convenient helper interfaces i can directly just call os read this all makes sense this is great this is a great step- by- step like how to reduce stuff and a lot of this stuff is i think everybody in this channel right now like anyone in this channel find like a lot of this stuff too confusing or does this all just make sense because this feels like a really great this feels like a really great simple optimization problem where none of it is like wild optimizations and this is also really great like you can just watch the person's thought process which i think is just fantastic confusing for me because i'm kind of stupid i know but like which part is confusing like you could imagine that using something that reads over your data multiple times is not as fast as something that can just read the data out and give you each one of those chunks like you're reading once versus reading twice co-routines are confusing but just because i don't know go okay fair i guess it sounds like a really good and thorough thought out commit i still have no idea what you're talking about though it sounds absolutely amazing so it's kind of like rings of power absolutely amazing really well thought out everything is fantastic most average piece of stuff you've ever seen that's how i think about about it it really that wasn't a very good analogy but i just wanted to make fun of rings of power it was just like that's really all i really wanted to do i'm just i that's actually just what i wanted to do anyways hey nightshade dude thank you 51 months of caring dude hype trade incoming can you guys hold on i'm in the process of reading something all right hold on let's look at this let's look at the last one hold on people since we are now sending chunks over the chunk channel the chunk consumer go routines are the first spitting let's see splitting the chunks into lines processing each line and sending it over to the line channel the line consumer channel finally constructs the summarized map these chunk consumer go routines can work in parallel as they're not adding values to the map directly to take advantage of all the cpu cores i spun up a number of vcpus minus one of chunk consumer go routines each concurrently taking chunks from the channel processing it and adding lines to the line channel okay interesting so you'd have is he saying you have a read channel that just like sends a bunch of of data through then you have like a chunk channel yeah that makes sense i think that makes sense right for so for each each each step that would make sense if you could just read you could get like 64 megabytes send that 64 megabytes over and then you start reading again which takes a nonzero amount of times and while that nonzero amount of time is going you are processing and creating new lines right there which i think is fantastic gluns okay guys i'm still in the middle of doing this thank you for the hype tra hold on i'll say thank you in a moment i mean that that that this that makes sense right the chunk channel consumed by the chunk consumer go retains 250 items the line slice channel over the line channel constructs the final map okay the total number of items send and receed from all channels is around that okay to reduce this each chunk consumer go routine can process a chunk into a min summarized map this map can be sent over to the map channel the final map can be created by combining the min summarized maps h 250 let's see 250 file chunks sent over the chunk channel plus 2 50 min summarized map senter to the map channel i'd like dude i want to explore this so much implement they finally able to get it to 28 seconds okay improving string to n64 parsing looking at the flame graph we still see a considerable amount of time and going into this does isn't this just like emotional by the way that now you're getting to this level of improvement because if you look at this there is quite a bit right here right so 8 1% that's a lot initially i used a stir conver parse int to convert the string to un 64 looking at the implementation of stir conver parse int it does a lot of checks that we don't necessarily need ourselves like one thing about this data is you know it's all correct so technically you could read until the point and if it's always round up do we even need the rest wouldn't you just read till semicolon then read until period like couldn't you honestly just do that there's there is our arc oh is there an arc mutex is there an arc mutex hashmap at the end reading sequentially will always be better than spawning n threads yeah i mean i want to play around i want to play around what about x point0 then you need to make sure that that like yeah yeah negative 1.5 needs to be one exactly it's kind of interesting there seems to be something that's very interesting there which is if it's negative you don't add one if it's positive you check to see if the last item of the point is a zero or not if it's a zero let's see 0.9 will turn into zero not one that's not rounding up is it that doesn't seem right that doesn't seem that doesn't seem right because the whole thing was rounding up it had a very specific thing you always round towards positive infinity right all right let's see further optimizations i only got this far with the challenge deadline january 31st there's a lot more to explore some ideas with the latest cpu trace flame graph the most of the time now seems to be going to map access and assign potential ways to optimize this using numeric keys in a map so one thing you know is that you have alphabetically sorted you need alphabetically sorted items and you have 10,000 i wonder if there's something there that could make sense with being able to put them into i'm very curious about that like how can you make it so you don't have to look stuff up in a map i don't know i don't know yet i don't i have no idea a tree would be sick something like that but a tree i assume would be slower than a map you look like someone that was in the military i was not but thank you though anyways replace in built-in maps with fast string maps or swiss maps i don't even know what a swiss map is is it a very like neutral map replace map uses which the tree data structure i wonder i wonder how that would work because how do you store the tree data like what do you store it in don't would you store a isn't i guess yeah if if your if your node was an array of 26 slots right then yeah because then you don't then you don't need to do that because then you literally just take a you literally just take your your character and you look it up in that position offset into it does that make sense a tree this is called a tree a tree is just like auto autocomplete a tree would be really good for inserting but might be awful for printing out the final answers yeah because you have to traverse the tree and you'd have to construct those things unless if you have the leaf node contain the constructed values i hadn't used unsafe so far because i wanted to see how far i can get without it turns out a lot map can be used let's see can be used to get better results than io speed methods from go's unsafe package can also be used for string and bite manipulation okay interesting i had a lot of fun working on this massive shout outs to gunner morling for putting this together challenge together by the way this was awesome this was fantastic that challenge i cannot believe how great this challenge was i started with a rather impressive execution time of greater than 6 minutes and brought it down to 14 seconds i actually i i want to do this because i don't i have never used any of like i haven't really used a lot of go like this is this seems like a great way to learn the language you want to learn because i want to learn more go go is kind of like the language i want to learn so this is a this is on my this is on my [ __ ] list now it is well hey go follow it on twitter go follow boom followed amazing absolutely out of control this was fantastic we'll link i i'll try to make sure i link all of that in the on the stuff all right hey the name you know what the name is you know what the name is hey prate it is prate the prate the prate agen the billen the one billion aen i don't know what what is the name what is the name what is the name what is the name the name is the prime gen thank you very much spell with an a at the end thank you