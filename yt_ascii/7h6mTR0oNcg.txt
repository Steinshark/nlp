the raspberry pico rp2040 is an arm cortex m0 based microprocessor equipped with two cores in this video i'll show you how to write code for the raspberry pico that uses a second core on the processor using the second core enables you to make your picot projects twice as powerful by using a completely separate thread of execution to talk about doing multi-core programming we first need to define what the word core means a core is a functional unit on the processor capable of executing program code by having multiple cores on a processor you can execute multiple segments of code at the same time whenever we write code for the raspberry pico for example core zero the first core executes the code the second core is on standby never doing anything here you see a depiction of two cores each core is separately running its own code completely independently they have separate program code and separate memory space there are cases however where the course can share program code and memory space sharing code is not problematic as fetching code is a read instruction and it does not create a race condition however sharing the same locations for data is problematic as it creates a possibility for a race condition to exist where mutual accesses to the memory is not assured so if the cores aren't supposed to share memory directly then how did the course communicate well the masterminds at raspberry pi figured this out and created two separate fifos or first in first out structures to act as a mechanism for communicating between the cores only one fifo is writable by core zero and only one fifo is writable by core one this way no core is ever writing to the same location at the same time in this example core zero has some memory it needs to communicate to core one for some kind of processing instead of writing that memory directly into core one's memory space which could introduce a race condition core zero uses its writable fifo to push that data to core one core one does its processing and then uses its fifo to get that process data back to core zero core zero could have been executing other tasks while waited for core one to finish processing this process of using fifo's to pass data around prevents weird cases where core zero is reaching into core one's memory or vice versa so with that being said let's write some code to make this happen in c okay so here we are in my linux build environment if you haven't watched my previous video on how to set up a cmake build environment for the raspberry pico c sdk please go watch that it'll make this video much more easy to digest i know i keep beating this up but i do have to say i could not have done this tutorial if i didn't have the raspberry pi pico c sdk document in front of me the entire time they do a very good job of documenting all the functions i'll be using today in the tutorial so after this tutorial go give this a read and see what other trouble you can get yourself into anyway back to the code so over on the right we're going to be writing the code that's going to go onto our raspberry pi pico so this is a multi-core video so the first thing we need to do is initiate the second core and the way we do that with raspberry pi pico is first we have to pound the pico slash multi-core dot h library what that does is it includes the library of code that raspberry pi has produced to enable us to do multi-process programming on the raspberry pi pico next we need to tell the raspberry pi pico to launch code on its second core and just to prevent any confusion the second core is called core one just so you're aware so the code starts this code will start in court zero and the rest of the code that we launch on the second core will be in core one just so we're all on the same page we're gonna call this function and we're gonna call it on the function name that's going to get ran by the second core and we're gonna call that second core code and then we have to define a function we're going to define it as a void second core code and then whatever we write in this area is going to get ran on the second core so that was pretty fast what we need to actually do now is write something to happen so what we're going to do is we're going to do the blink led example but we're going to have the second core tell the first core when to turn the led on and off and the first core is going to actually turn the led on and off so the way we're going to do that is we are going to use the fifo we talked about to push data to the first core every half a second so here's how we're going to do that we're going to create a while loop and then first we need to sleep for half a second and then we're going to push data into the first core the way we do that is with multi-core fifo push blocking and we're gonna push the command gpio on so that means that every half a second the second core will put the gpio on data which is just the number one into its fifo to the first core and then we're going to copy this code and paste it and then we are instead of using the gpio on command we're going to use the gpio off command that will tell the processor to turn its its led off awesome pretty straightforward okay so now that we have the code set up for the second chord to execute we need to now make sure we actually have the blink led happening so we need to do that by running gpio init on the led pin which we have as a pound defined up top we need to do gpio set direction to led pin making it a gpio output pin and then forever while one we need to get data from this fifo that came from the second core right we're gonna create a variable called command and the command is going to equal multi-core fifo pop blocking what the blocking means is that it will actually sit here and wait like no more code will get executed until something comes out of the fifo so we will sit here and wait for half a second for the fifo to push data out we will receive it here and it will get stored in this command variable and then once we have the command we are going to do a gpio put on the led pin and we are going to set the value to command okay that's it so what's gonna happen here is we're going to launch this code on our second core this second core is going to wait half a second and then put data onto a fifo wait half a second and put the other data on the fifo we're going to set up our led pin while this runs and then we're going to serve forever and we're going to pop out one of these commands we're going to put it on the led pin okay so let's build our code here just like before we used to do make dirt build cmake behind it oh we have to export our sdk path first then we see make now we make no it's sorry i got an error here it's sleep ms for milliseconds great and now that we have our code figured out we're going to take our compiled program so it's multi.uf2 and put it onto our raspberry pi pico and as you can see here our raspberry pi has now rebooted running our code the first core is running in this loop and it's pulling data out of that fifo and putting it onto the led pin and the second core is every half a second commanding the first core to do something anyway guys that's it for this video i hope you learned something if you did do me a favor hit like hit subscribe come back for another video and i'll see you guys next time bye