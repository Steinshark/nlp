hey what is up guys welcome back to another low level learning tutorial in today's tutorial by popular demand we're going to be talking about arm 64-bit loops and subroutines or more popularly called function calls before we get into that first of all i wanted to thank you guys for all subscribing so much we've gotten the channel to over a hundred subscribers if you're watching this and you're not subscribed do me a favor hit the sub button i put out content like this every week or so we get into really cool topics of the low level like assembly c programming stuff like that anyways let's dive right into it the code here on the left is from my arm 64-bit hello world tutorial to my big video if you haven't already seen that get out of here go watch that get real familiar with that code and then come back and watch this if you try to watch this now without knowing that base knowledge all these instructions like register assignment and stuff are going to make probably no sense to you it's going to get way out of control real fast so go watch that then come back for those of you that have seen it we're going to get into loops right now looping is this thing in assembly that we do where we use a jump instruction to make the same code happen over and over again to do a loop we need to do three separate things we need to have a loop created by setting up some kind of counter we need to then run the code the loop contains and right do some kind of functionality and then finally we need to check to make sure that the loop doesn't need to end and if the loop needs to end we need to end it so let's get into that right now by writing some code so step one we're going to set up our loop counter and the loop counter we're going to use is going to be held in register x15 x15 is a volatile register so we can just put data in there no issue we're going to set it to 15 because you know it's called x15 so why not so now that we have our counter set up we're going to actually create the label which is just an address that represents where our loop begins right we don't want to set x15 every time because then the loop would never end right so we have this loop and now we need to check is it time to end our loop and how do we do that well we need to compare our counter to some value and in this case we're going to call it 0 right if x15 if x15 has gotten to 0 if we've done our loop 15 times it's time to end and what do we do if that comparison is true well the way that we check to see if it is actually gotten to zero is run an instruction called branch eq or branch equal and that means that if the output of the previous instruction so this comparison if x15 is equal to zero we do something we're going to branch in this case to a label called exit and where we're going to put exit is right here and this is our old code from the previous tutorial that did the exit system call right so if our counter has become zero right we compare x 15 to zero and if they're the same we need to exit that means that we're done our loop has ran 15 times and we're done with the program if it hasn't been ran 15 times this branch will not happen right it's very important this doesn't always execute it's a conditional operation if they're not the same we will keep running and we will run through this code that outputs hello world from a previous tutorial right and that's what we want to happen that's our functional part the second part of the loop so once that's ran we need to somehow get back into our loop and make sure that it's done in a same way and by saying i mean we need to decrement the counter right and the way we do that is with the subtract instruction so we're going to say sub x 15 x 15 1. and what this reads to in human verbiage is that subtract 1 from x15 and put it into x15 right so that means we've decremented our counter by the value of one pretty straightforward and then once that has happened we need to go somewhere right we don't want to keep we don't want to leave this on its own because this instruction will get ran and it'll just fall through to the exit code and it's like we didn't even do a loop we need to do a b for branch and this branch happens every time it's a branch always back to loop so would it be right create a counter called x15 and make its value 15. at every iteration of the loop compare it to 0 if 0 and x15 are the same which means our loop is done we exit otherwise we're going to do some code and in this case that code writes hello world and then once that's completed subtract 1 from the counter and start all over by going back to loop cool so let's compile that code remember if you saw my previous tutorial the way we compile this assembly is we first use the assembler to assemble the assembly into an object file that should yield no errors good and then we invoke gcc to output an elf using that object file and we have to say no standard lib to not include glib c and make it a static binary to ignore possible linker errors right cool no errors and now we can run our program and we get 15 iterations of hello world and just to prove that i'm not blowing smoke we're going to change this counter to i'll just call it six for fun assemble gcc elf and we get six iterations right awesome so that kind of handles the loop part of this tutorial but what i wanted to get into too was functions and what is the difference between a branch or a jump as they're called in other architectures and a function a function call is basically just a branch where the instruction of the next where the address of the next instruction is preserved right so what we can actually do to kind of test this functionality is we're going to take the code that cleans up the loop and we're gonna put it up here and we're gonna call this little blob hello world right so this little hello world we're gonna treat this as a function so instead of putting it here in the middle we're going to have it be put somewhere else and the way we're going to call it is by doing the arm instruction called branch and link and we'll talk about that in a second so branch and link is this operation in arm 64 where not only do we transfer code execution to this label we preserve in l the link register the address of the next instruction right so that once this code has gotten done running it knows where to go next so let's look at our loop again we set up a counter set it's a six if the loop needs to exit we exit otherwise we do a function call so let's then go into this function call and we do some stuff the question then is how do we go from the function back to control to the user and the way we do that is with the ret or return instruction in arm 64. the ret instruction pretty simply is what's going on is the processor is saying put the value of the link register which is set during this branch and link instruction to pc so then pc will end up actually running at this instruction it gives code control back to whoever called that function right so we do our call the call comes back we subtract 1 from 15 and put it back into 15 and then we loop all over again so now we're treating hello world instead of this blob in the middle of the code we're treating it more as a function right so let's clean this up assemble compile and run our code and we get the same functionality right the blob that does the actual system call is treated as a function instead of a blob it just lives in the middle of the code there is a little more fanciness that you can do with a function call to set up this thing called a stack frame and the stack frame is an area on the stack that contains memory for local variables but we're not going to get into that today that's really complicated we need to kind of draw some pictures for that anyway i hope you guys learned something today if you did do me a favor drop a like leave a comment hit subscribe and i'll see you guys next week keep on learning have a good night bye