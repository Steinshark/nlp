what else do we got on this thing fetch over web rtc or how i started calling it don't drink and code kids how would i literally not read this article this is designed for me to love this okay web rtc is fantastic oh man oh this whole thing is great the voices in my head tell me networking design sometimes and when they win i start coding and don't stop this is the result of me having an idea while drinking with my family and not stopping having the idea until i was done two months later i wonder if he also didn't stop drinking the whole way that's the real question that's the real question to provide some context i am working on a web-based ttrpg platform designed to cost me as little as possible to run and maintain so i can get away not making it a product i could in theory just use the cloud and hoist it on some aws magic server but i am romanian in translation too poor for cloud hosting and while thinking about some of the networking problems that come from making a decentralized gaming platform i realize that most people don't actually have public ip addresses at home the advantages of living in eastern europe i guess and asking for one can be difficult and costly process so in the end having a home server is not a solution for everyone okay this is great okay we're great background great background right now thankfully the network networking nerds thought about it in the '90s the biggest showstopper for client server hosted is the isps are translating your home private ip port combination into a public facing one this combination is not static and the client typically does not know it happens but if you can deduce it in theory you could link two clients without them having public static addresses okay okay very exciting very exciting to achieve this the nerds developed an entire family of standards some which includes stun turn ice and web rtc man okay so i've never done anything with with turn i've read part of the ice and stun stuff and i've i've done a decent amount of reading into web rtc i've never actually implemented any of it the latter was developed by google and the browsers copy pasted into their code bases web rtc was originally developed for real-time communication services but during this article we will be twist we our article will be twisting into a channel for http and websocket communication i love this this is so good to make a very long stupid and nerdy short story story short web rtc creates a connection oriented channel through which the peers are intended to communicate freely without dedicated structure so to recreate http all we have to do is send messages and expect responses from the server that's it that's all you got to do okay it's that easy there is no server sorry i had to say that web rtc was developed for the browser and last i checked a browser is not a server yet so node it's basically a browser no sadly no there's no official support for web rtc on node and i refuse to handcraft my packets for something that i'm not even sure will work it's it would also be an incredible amount of work you got to remember web rtc you got udp rtp you got rtcp back channel communications you got so much crap that goes into what sdp for for for what's it called for abilities information transfer like what can i handle flag flag stuff dude there's so much crap that goes into web rtc it would be impossible to do in any short amount of time with one person that isn't an extremely experienced programmer so time to see if anyone else had the same intrusive thought after another beer i found a few li found a few libraries to achieve the exact achieve exactly that i think i found seven to eight libraries three of which didn't receive an update in the last 5 years three that just don't work and finally one whift that has a work in progress documentation so it's and is in japanese looks like a good time you know you know for a fact you you're you you are in the truest rabbit hole when your only when your only options a working work in progress documentation and it's in japanese like you are in a you are in a in a good place right now hey there hef i'll call the pane of existence but man does it make you do some good crazy good [ __ ] it does one one other problem i wanted to use pjs because allegedly that's how you do web rtc or something i was very drunk by this point so don't question my l logic this library again has no support for node but luck was on my side apparently someone by the name of afro kick made a merge request for a 2.0 beta for pjs two years ago that should work on node they were even kind enough to leave behind an example thanks afro kick first off can we get some can we get some claps for afro kick what a good guy what a good guy just coming in there leaving exactly what this man needs just just absolutely a great just a great thing right there shout out to afro kick can we shout out afro kick you know i know this isn't the same afro kick but you know what afro kick whoever you are you're getting a sh you're getting a shout out whoever you are good job and i'm going to give you a follow whoever you are not even the same one but it's it's the it's the spirit that counts all right they were even kind enough to leave behind an example thanks afro kick sadly it uses one of the libraries that i tested and didn't seem to work but if the w rift library is real and the web rtc implementation is mostly accurate i could use it in place of web rtc and hope it works okay spoiler alert it mostly works it's horrible and required me to make some changes changes pjs i have no idea what i want to change or i have no idea what i changed it was something about the message sending part but it works okay nice back to normality with web rc on node working all i have to do all i have to figure out is is how do i put this dumpster fire in its own box so i don't have to look at it again okay i like it simple make a web rtc server smuggle the data into a real server and back to the unfortunate souls using the house of cars those poor the poor the poor the poor unfortunate alls all i have to do is mock the htp parameters and structure in a way that my proxy will be able to format and forward it to a real server and convert that response back to my stupid messaging system to send it to the client yeah okay that makes sense yeah it's just an adapter layer right you're just you're literally just recreating http over udp that shouldn't be like i mean and web rtc has reliability built in correct so therefore i mean that should make most inventions are not a necessity you know the necessity may be something else here that we're missing okay the necessity might be the need to go to treatment for drinking alcohol so we don't know what it is but we do know that at the end of the day somebody made this images oh god people send images over the internet and i'm making a json based messaging protoc okay why would you use web rc just to end with json you didn't even hand roll your own your your own your own encoding format don't worry about it how would a normal person send images over a json messaging format you don't well you'd probably x6 what was you get b 64 but at this point i'm not stopping so [ __ ] it base 64 pre r pre-read that one the images and make a mockery out of the multiform data structure as well and put them in the json and sent it wait why are my requests not reaching my client apparently even though sctp the protocol used for sending reliable data supports message fragmentation most browsers cannot be asked to implement that part existence is pain that means you're going to have to do it so i have to make my own fragmentation and reassembly mechanism in javascript don't worry about it it's really not that bad if you already had the incoming things you already knew it was a like i mean you really didn't even have to i mean you really could just use a one bite identifier in front of the message to say what type of message it is whether it's json or image and then you could just dump the image wholeheartedly whole binarily raw dog it across the internet read the first bite and say first bite equals image and it's this long next two bytes three bytes four bytes whatever you need for the next part is just how long it's going to be probably toss a version at the very beginning just so you can version your protocol bada bing bada boom you got yourself a delicious versioned protocol that takes in length and type of message and like that's it that's all you got to do it's that easy that's how most games do it of course they do they have a version they have a they have a version they have a type and then they have a length and bada bing you just got done making yourself a protocol this remind reminds me of a smart guy that said always put a version in your protocol header yeah probably a smart and good-look fow if we're honest with ourselves so i have to make my own fragmentation reassembling mechanism in javascript don't worry about it when i came up with take my message convert it to binary slice it into 16k parts convert the binary back to text yes we can we can still only send text i mean can you i mean text is binary why can you only send text i'm c i'm curious about that last part make a j let's see make a j oh is it because you're only using json okay yeah never mind for whatever reason my suggestion for how the protocol should go became how the protocol should go we do all this hope the client can can somehow reassemble mess you already have array buffers again dude imagine if you would have listened to me in the past in the future and put a version in your header protocol of course but then after that put a length to your message you could have allocated an array buffer that's like javascript right i can jump in here and i can jump in here and i can go like this i can go const a equals new array buffer right and i can do like 1024 and like bada bing bada boom and now i got myself one of those and then you can have a const view and the view can simply be like a a new uint 8 array that references the underlying array buffer now you can be like you know view. set or whatever it is get what what the hell what the hell does view do again oh yeah it's just a u8 and buffer you can set that to like one and then i can print a and a has has this huge thing but a also now has this beautiful little int8 buffer at there you go it has a one on it cuz we're editing it with a view like that's all you got to do baby just write it in just write just write it in all right conclusion what was the point of this article to rant mostly and to tell any unfortunate soul that wants to do web rtc things please read the original rfc's most articles i found on the subject sucked and i would have saved so much time if i had read the original standards first here's a link to them for your convenience i was hoping for a little bit more to this to this article i think it's hilarious that you used web rtc just to use jon like what what what was your goal here what's the goal what's the goal here people you can't do that makes me a little sad i wanted to see something out of it like some sort of performance or some sort of something out of it okay because because it sounds exciting okay session traversal utilities for a nap i've never done anything with stun i know that this is a thing i lightly read it at one point it is like rfcs are not small by the way okay they are not exciting to read anyways what the heck is pjs who knows what pjs okay well this is awesome i love i love i love just the ridiculous nature of this by the way this is just how you uplevel yourself so much as an engineer please if there's one thing i can convince you of is do something that you just don't think you can do other than traveling salesman or any problem that can be uh reworked into the traveling salesman pick a problem that you just don't think you can do and do it if you've never built rtp try building rtp why not if you've never parsed out an and codes to make a to to turn them into to binary that you can send to a server and thus deliver to a bunch of people at once you know why not why not just pick something and do it no matter talk to a woman get crazy out there jet ski you know do what you got to do not because you must but because you can i might as well touch grass that okay now we're getting a little too crazy here okay okay did you just expose me i did b you know create your own protocol for socket communication why not like if you want to learn how something works or you want to understand something at a more fundamental level you have to build it right you know something that you could do is try to build your own minor version of github right git is just de centralized that's all it is is a decentralized version control system that's it like that's it there's nothing else to it github is just someone else's machine running your git now obviously there's a whole bunch of stuff that goes on between it but nonetheless it that's all it is at the end of the day you know what i mean reinventing the wheel is super valuable and you really know why the wheel is so great exactly the name is the primagen