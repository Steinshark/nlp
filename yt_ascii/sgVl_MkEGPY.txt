okay hello my name is christine elczek and let's talk today about writing sustainable software the honda mod and let's oh here sorry let's start with things first you can see all the questions we asking in the talk and also the code examples in this github repository i will also add this at the end of the last slide this link and also when you click on my profile for meeting c plus plus you will also see this link and then you can check out the slides later and also questions code examples and so on so who am i i'm a c plus plus developer who works for isa right so on ice rigs which is an open source inner process communication framework for safety critical system what this means is in the end let's say you have a car with a lot of sensors and these sensors have to communicate for instance the radio has to yeah communicate to a break that there is a tree coming and therefore it has to do an emergency break and this communication is done via iso x isorix is written in c plus and is also open source and available via github and since we are a framework for a safety critical system we come with some restrictions for instance we are not allowed to use the heap because we have to guarantee always that there is memory available if something needs to be sent and we are not allowed to have undefined behavior and certainly also no exceptions and inside of the iso works we have also the israelis that extends on and these are stl types like optional vector string expected and so on all implemented in c plus plus 14 but again for a safety critical system so again no heat no exceptions and so on and why i'm here is ice rigs is a software which is running on machines and cars which sooner or later will be involved in accidents not by fault of the software but maybe some kind of other external incident and we have to really make sure that our software is never the cause of such an incident and therefore we have to really ensure the software quality and sometimes in my field some have maybe the misconception that when you certify a software it's automatically safe but this is not the case you have to make the software first safe and then you certify it and then you can really say you have done everything to ensure the software quality and when i took a look i think in the last month or where the pull request we received and then i just asked myself maybe we can improve the code quality of our own commits and all of our contributors by just asking the right questions so because something which you want to never see in a safety critical environment is some statement like when i wrote this only god and i understood what was i what i was doing now god only knows this is a quotation from carl vyastras maybe it's a german mathematician but when i researched it in the internet it wasn't really known beyond where it comes from and this talks presents some ideas and concepts which are important in our safety context but i think they can also apply to many other domains because what we also all care for is a stable software where we as a developer do not have to do overtime or some crunching we just write something and it works out of the box hopefully and maybe we can inspire each other so here's also some kind of key difference when you take a look at the cpu plus in a safety critical environment and cpr plus in general you say what you don't use you don't pay for you want to have maximum performance but in a safety critical system when you are driving in a car or flying in a plane you do not want to have this you want to say safety first performance seconds this does not mean that we do not care about performance performance is also very important but if you have the choice between undefined behavior and maximum performance or we have defined behavior it costs a little bit performance but you have safety guaranteed with this then we go for safety so and here what i explained sooner or later the products which are running our software will be involved in some accidents and we have to make sure that our software is not the cause and here's also something murphy's law for instance when you take a look at this it states everything that can happen will happen and here when you take a look at bucks for instance you can say if the code base is large enough every possible bug will soon or later will be somewhere happen and we have static code analysis tools to reduce the probability of this but it's never zero and therefore the question is can we do something about this and the first thing we also have to be aware is when you write software it's like painting a picture this is especially something which i realized for big companies big companies like to plan everything from from the beginning to the end but this is not possible for a software project for instance a software project starts mostly some kind of idea with ice rigs it started with like we want to have some kind of software where we can establish some kind of communication between applications in a safety critical environment and then we discovered new use cases and new features we would like to have and then it grow and we didn't foresee all the abilities and ideas we and features we had in this now in this product right from the beginning but in the companies they like to plan software projects like an architecture architect we built a bridge because they think okay if you plan it wrongly you have to demolish the bridge and yeah then you end with something like this here this is a bridge was built but not over the wrong river a rainfall accord and then the riverbed changed and this is of course expensive to change but if you write a software carefully i think such changes will never happen or that you can in such a situation that you cannot change the software project or the features anymore when you write clean code you can adapt this very well and that it's like painting a sketch this is a pencil sketch of a moose from me and here i started also with the idea i want to draw a moose i have no idea if it's laughing or crying or somehow weird and then with the new features it's like painting then you add some trees at the hill some kind of sunlight or atmosphere or moon whatever you want to have at the colors and these are all the features which are coming in and you adapt this maybe you override something and so on so now this is the questions we will look at and the first one is the design over abstracted again since it's like painting a picture you have to realize that design is always incomplete and you cannot foresee all the features which you like to have and the software is like a living organism when you write the code you will realize that there are new features things you can adapt or apply the software and therefore just consider the the basic use case and start with this but the beginner mistake is that you create a new mlb diagram with a lot of classes in enterprise architect and you try to cover all the the stuff and to try to make it as abstract and extendable as possible but then for instance enterprise architect does not verify if the code has circular dependencies which makes it more or less impossible to implement or you use some dirty tricks to with pointers and pipple and so on to to realize this code and this is a typical beginner mistake and how to avoid this over abstraction is very simplistic do small cycles have your one basic use case in our case it was establish a very basic communication send a message hello world message and receive it on the other side print it out and you can do this for instance you can do this with blend umail or enterprise architect but my favorite method is here just declare some empty classes with empty implementations but you declare all the methods then you can compile this actually and you see for instance that the code you are designing is somehow working you do not only have to fill the implementation then and then you can use doxygen for instance to generate a class diagram can review it can maybe do some cycles here and then you have to base the most basic use case working and can then extend the design and this is some some circle which always runs like this you create your design element in a basic use case for instance when we write some kind of communication software we have a sender the receiver we create this design element we create some empty methods we compile the stuff so that we say okay the header is fine then we implement the basic use kit and then we start again so and here is some philosophical idea which came up around our colleagues is in the middle ages you had the chester or the professional fool it was not only for entertaining the people but also sometimes for the lawmakers the professional fool read the laws from the lawmakers and if the professional fool could explain the intention of the law to the lawmakers as they intended they'll always pass otherwise the law could not be understood by the common people and therefore has to be rewritten and now the question is can we adapt this idea somehow for our newly developed api for instance there the idea would be we have a colleague which is a good developer but not so familiar with the product we are currently we are very currently working on with all the details and side effects and so on and then we just say here we have two classes for instance for you the the basic use case is the following thing can you implement an example and here for instance we also state that the developer does not get any kind of documentation because as beyonce sub states the compiler doesn't read comments neither do i and here the idea is can the api be used intuitively right if not we maybe have to adapt the api though that it can because in the end when a developer starts working with such a framework they are maybe under pressure have a 60-hour work week and maybe they are not do not have the time to really read the documents carefully and therefore easy to use api is extremely important so now the question is this api easy to use and hard to misuse let's take a look at this bad api and here we have a receiver and this receiver has a constructor init method at connection connect and disconnect and with these methods there comes a lot of contract first of all the init has to be called first after init is called we can add some connections after we added some connections we can call connect and when we are connected we can again call disconnect but only after we called connect and it can all can't be called only once therefore if you do not read the documentation carefully you are doomed to misuse it and now let's say we would give this our colleague and say yeah this is a receiver you can hear add some connections disconnected and so on just use it and maybe think of something like this yeah first i want to connect the receiver then i had some connections then i disconnected again and then maybe assumes here you need maybe it's something like a placement new or whatever or it resets the object so i just call in it and then i add some connections again because maybe i am assuming that the connections are then resetted and then i start again and here we are violating the contract all over the place and when you are under time pressure this can lead to extremely good behavior how can we do better so let's take a look at the object and we realize that it actually has three states the first state is before init was called we just constructed it then the second state is after we called init then we have the ability to connect or add connections and then the third state is when it's connected and then we would be at a rust conference everyone now stream and say yeah it's a type state pattern but we are the c plus conference and therefore what is the type state pattern so the type state pattern is we encode the runtime state in its compile time interface this means that depending on the state the interface is different and therefore by the compiler can warn us or can hit us what kind of methods we should use and it would look something like this when we implement this the first element or class we would require this receiver state this would be the class where all the member variables these following objects would share then we have a class called receiver connected here we can just call disconnect because assume we are on the connected state we are only allowed to to disconnect according to the contract and we have a constructor where we retrieve the ownership of a unique point of the receiver state so that we now own the object or the state then we have the second class called receiver initialized here we again retrieve the unique pointer the ownership of the members and we can add connections or we can connect depending on what's what we want to do and when we connect we return the receiver connect state and then can work with this and the initial class initial state would be receiver where we can just call init and then retrieve a receiver initialized object and the receiver state is depending on which state or in which class we are is then moved to the according class and then when you take a look how one could use this it would look like this then you just say receiver.enid.net and then you connect and let's say for instance now our developer would like to misuse this it's impossible because it would lead to a compile time error because you cannot call any twice you cannot call ad connection of your after you call connect and you are only able to disconnect after you called connected and this is a design or an idea which is known as design by contract this means the contract is enforced via the interface and now the most awesome thing is that your ide will tell you how to use this object because when you start receiver and then press start you get only one suggest that as a gesture and this is indeed after this you complete it you have two options add connections or connect therefore you do not need to read some kind of documentation you can't just use this object right away only correctly and yeah this is quite nice but it's also cumbersome when you have you want to move the state transition in multiple functions and you have also some other problems for instance here's a hidden move inside let's try to take a look at this and try to fix this so let's say first we want to use this api and move some kind of state transitions into different functions therefore you can say something like this we create our receiver then with this we create our receiver initialized object and when we say receiver init then we add some connections initially and then we connect the whole receiver and after some time we can disconnect it but what we have here is the thing is a little bit cumbersome to use and the other thing is in these functions here for instance here is a hidden transition of ownership the unique pointer to the receiver state is moved from the receiver to receiver initialize and this is not the compiler is not really aware of this and the user is also not every of this and then when you write something like this you have undefined behavior so how can we fix it so the first idea would be to just introduce static methods which are called disconnect connected init which we had before and here we move the previous state into this new object therefore it's completely clear for the user and also for the reviewer that now the ownership has changed and is now on a different state and when you take a look at the code it looks like this we have a receiver initialized then we have to move the initial receiver into the receive and the reservation a method and then we can add some connections and then we can continue and connect the receiver when we move the receive initialize object inside this connect static method and then we can call disconnect and so on and now the ownership is clear to the review and also clear footer compiler then we now write something like this here we get a use of the move warning for instance i tried it with the current compiler it works perfectly with gcc it has at the moment some problems but nevertheless okay but let's say i want to ensure that these methods are all chained together because i wanted to use them like this i can do the following trick i can make these methods here the ignite and that connection i can change them to our value methods this means they can only be called if the underlying object is an r value therefore you cannot store the receiver in some kind of variable and then call the method it has to always be an r value you can do this nevertheless and try to misuse it but it's very easy to split the spot then it would like a look like this he would just call stood move create an r value of out of receive initialize to just call the method and connection which would be just wrong and it's easy to spot in a review okay next question can we reduce the error handling again let's stick to the receiver and since we have here four methods which can be misused and misused means here they are just called in the wrong order we have to inform the user that the call actually was successful and sometimes the user really doesn't know is unsure and maybe say okay i have no idea what to do here when it fails therefore i just propagate the arrow upper layer to the public api and so on and if you follow this kind of behavior you have a lot of unnecessary error handling in the public api which can just clutter the code with unnecessary tests and so on just take a look at this for instance let's say for instance we want to also have the ability to remove connections therefore we can add a connection and then we have some kind of comment which states it returns true when the connection existed and was removed otherwise false and now you read your code and see something like this you see here that when the remote point connection has failed we have to maybe do some stuff but here in the end the contract is after you called remove connection the connection is no longer present in the receiver if it existed before is irrelevant because the contract is either fulfilled and here something would be for instance here we can really omit the error handling completely because it's nonsense because the contract is fulfilled either way but if you want to make sure for instance if some kind of connection is present in the receiver you can add a certain method for this like this connection present or something like this which then returns the bool to just reduce the error handling because it really accumulates and multiplies in the public api and you have thousands of lines of code and thousands of lines of unit testing because you have to handle all these kind of errors and have to really test if the object is behaving correctly in these error cases just take a look at this comparison we have either the left side where we just say receiver enate at connection connection connect or we just have the right hand side and we do not use such a contract by a design approach and with every method we have the possibility to that the method is failing and therefore we have to do some kind of cleanup code have to return some kind of error code and then in the public api some poor developer has to handle all these errors which in the end are not really necessary and then in the end when you write safety critical software you have to also test this this means also mcdc testing therefore you have to really test every branch is that the code behaves correctly and these are thousands of lines of code and this with this additional lines of code although the probability for bugs increases so next thing is is this api easy to use the concurrent case let's say we are very smart and we wrote a perfect thread save integer vector which is luxury and has all the features and is has no box boxes whatsoever and now we just take a look at those two methods the the square operator to just to access an element at a certain position and to check if the thread safe integer vector is empty and now someone uses our vector and writes code like this whenever my vector is empty i want to just print out the first element in a single threaded case this is perfectly fine but in a multi-threaded case we have here multiple issues the first thing is as soon as we acquired the information that the vector is empty our operating system can us can interrupt us for any arbitrary time another thread can swoop in and say oh i don't like this vector anymore i just clean it completely and then it's empty again and you access an element which is no longer valid and the next thing is again this vector itself is thread safe but maybe here in this case it has no responsibility to make thread safe integers the integer itself is again not thread safe then when you hear xs a reference to the underlying integer which the thread save integer vector is managing it's possible that someone writes data into the integer while you're reading it and then you have again race condition and data races therefore here's the question is when you're working on a concurrent api is it useful to that it looks like a non-concurrent api sometimes it's maybe useful to just dismiss a completely standard api and go a completely different approach a functional approach how would it look like for instance you know for each from the stl for each is the the from algorithm where you can just iterate over a range and then you can do something with the elements in that range or let's say we have a four method which does exactly the same thing but only for one specific position and then we can write code like this for index null if the index null is present please just bring it out otherwise don't do anything and with this functional approach it's impossible for the user to misuse this in this particular case for instance here also what comes in with when you provide empty and an access operator for the vector you have to also introduce now as a user artificially another mutex to just make sure that these two operations are empty and the access of the element that you can access this thread save and then you just yeah somehow supplemented the cool features of the thread safe integer workflow vector and have introduced another mutex so why not just get rid of this error and introduce a functional ipi another thing a use case of a vector is that you maybe want to add an element and later you do not care anymore for this element then you do something like vector find f then you get an iterator and then you remove the element at this position but when you have again a thread save integer vector it's possible that you find the element after you have found the element someone else in a different thread is changing the vector and then your iterator is not no longer valid therefore minor use here again a functional api where you just say for instance with pushback you will add an element and you get the position of the value it can help you and then in the remove to improve the performance when you say okay the last known position of my element was this year i give you a hint like for instance with the map where you can insert and provide a hint and then you have here a callable which returns true if this is the element you are looking for and then it's removed it's similar to the student move and here we again we have a functional api which minimizes the misuse cases of a thread safe vector and it's nearly impossible now to remove or add or change the vector in an unsafe way of course you can still capture some variables here in the lambda you can do some okay and reduce some bugs but i think in my opinion the probabilities of bugs is reduced here with this functional approach and here's something we have to keep in mind when you create a thread save constructs you have always to face two challenges the first challenge is to create the actual construct and when you master that challenge the second challenge is you have to design an api which allows the user to really use this construct in a thread safe way and when you now provide methods like empty size or an operator which returns a reference to an internal element you make it extremely easy for the user to misuse this you have to be really careful then as usual you have to read the documentation has to you have to really consider all the side effects which can happen here maybe to use this correctly why not provide a functional it's like when empty do this please or when size has this size for instance then do this please or like with the operator here you can have the four methods next thing that's the name fit this is something where the c plus plus developer or the developer in general i have some kind of issue because it's hard to find the right name and here i've come up where i came up with some certain rules and the first thing is that a class should always reflect the purpose as a class name or the structuring should always reflect the purpose of the object for instance if you have an object which has a particular role in a design pattern for instance you have a factory which produces receiver it could be a receiver factory or if you for instance implement the visitor pattern you can also use the the names which are stated there and so on they can print the receiver visitor whatever it does then and if you say okay i cannot really provide here the purpose because the object has so many purposes i cannot come up with a right name then maybe it's an indicator to split the object up to come up with a better name the next thing is how could i name functions and methods yeah they should reflect the task the function where the method is performing and when you say okay i cannot redefine the task the method or the function is performing and you have to require the words end and or maybe again this is an indicator to split the function up but it should not be a strict rule but sometimes you it really makes sense to have a little bit a bigger function when you write the first implementations of your first use case or you write a proc you should not start with over abstraction but when you try to finalize your design harden your software these are some kind of indications that you have to do here's some maybe something a bit of more refactoring and abstraction and the variable name should reflect its content what it's containing for instance here we have a sender and the sender has a list of receivers it could be the receiver list for instance and when you have problems with naming maybe the course is the design idea is not completely clear in your software maybe you were not aware that you're here using a factory or that you could use here a visitor pattern or that you could lose a facet pattern or a builder pattern or whatever also sometimes a single responsibility principle is maybe broken all the separations of concern so maybe this helps to come up with better names and also bad naming can lead to bug bugs as you can see here and in ice works you implemented also stl types like string but with the restriction no heap no everything resides on the stack the capacity has to be known at compile time and its exceptions are not allowed and we try to be as compatible as possible to the stl but we aimed explicitly assigned to unsafe assign the reason here is that the reviewer should really know when he when won't reviews the code that this string which is provided an unsafe assign has to be now terminated if it's not now terminated we have here a potential problem with memory issues and therefore with unsafe assign something like a keyword which you see in the review or when you write code okay i have to pay attention here but this is something which we do not have to do for instance when we assigning another string to a string because here we have guaranteed that everything is now terminated and we do not have the problems with the memory safety if you would like to look at the implementation of the string here's the link or later on you can find it also in my github repository can one produce readable code with this api let's say you review code and encounter this a little method here it has five booleans they are nicely described you can read them easily it's a perfectly readable implementation so from this site would say okay thumbs up you can merge it but now the question come comes in can i actually produce readable code with this api and let's take a look at an example we can for instance produce code like this which is absolutely not readable because you will see just random booleans and then you laters have to use such a piece of code you have no idea of what to do and even then when you just use your ide and try to figure out what argument is standing for what it's that you for instance see that the third or fourth argument is yeah standing for do receive history or blueprint messages even then you can yeah make a mistake then you maybe yeah say in a review okay you have to do better than this you have to you are not allowed to introduce magic numbers and then you come up with an implementation like this and this is still error prone and this seemingly a perfectly readable implementation we have two bugs the first thing is we state that we are using tcp but actually we are not using tcp and the second thing is that do not lock messages and do print messages are switched here and this is extremely hard to spot but the solution is also very easy just use enums and then you can write code like this it's again very readable the user has to write less code to produce readable code and here also something hicks in it's a strong type safety of c plus plus let's say we would mix up here the order of some arguments we would get a compile time error because these are different types and with c plus comes strong time safety and the next thing is enums are extendable booleans are not booleans have only the value true and false but let's say for instance you want to extend the protocol you would would like to support tcp udp and whatever kind of p you can think of you can just add this to the protocol and have a list of nice protocols and this is extendable with booleans you have to rewrite the code and you have to change this api can the api be used without documentation let's assume again our good receiver now gets a constructor where we have these four arguments we can set the history cache size which means that we when we connect we receive the latest 10 samples which we are sent out in this connection for instance and whenever we receive something we want to have that a certain callback is called also the same thing is when we establish a connection a certain callback is called and the last thing is should we acknowledge every sample which we receive to the center and these two arguments here are optional which is described here in the documentation but this arp api should also be usable without documentation so it's clearly states to the user what is going on because when one sees just this api one may think okay when i provide here an empty function maybe an exception is shown somewhere or maybe i get some kind of error because it's not really stated is do i have to really provide here some kind of callable or not because the function itself is nullable but when we introduce here an optional around this we say to the user this is optional you do not have to provide this you can provide this and this makes it clear for the user it uses also the error handling because maybe when you think okay this has to provide to there has to be a callable provided and when you create again an abstraction around the receiver you want to make sure that the callback is always there and so on and this makes the code future-proof and also provides additional insights for the reviewer when you take a look okay now let's take a look at what box does an api allow and we take a look at our callback and let's say for instance we have the on receive callback and we just call it and here we can easily throw an exception for instance when we use a stool function but this function does not actually contain an object the better way would be for instance when we call this object optional on a receive and then the reverse it ah it's optional we have to verify that this actually contains the value and then we can call the the stored functional but we have here also some drawbacks to rename every variable optional whatever is also some kind of counterproductive because sometimes you just do some kind of code refactoring and you turn an option into non-optional and you forget to adjust the names and then you have an inconsistency with the with the actual type and the name therefore sometimes it's it's yeah you have to to verify or have to check out if it's suitable for your use case but a cool new feature of simpler plus 23 will be the monatic optional let's see in the good old days if c plus 17 and 20 we use an option like this we define here an optional value and when it contains a value we use a d reference operator and just print out the value otherwise we do something else but new cool world you can use the functional approach and right and then and this callable here is only called when the option contains a value here you provide a reference to the conte to the underlying value of the optional and then we just print it out again or else if there's nothing contained we do nothing and when we only use this api it's extremely hard to use an option a misuse an option or to to run into any kind of bugs just for instance think of other types like a unique point or sharp pointer maybe we should in a safety environment say okay we try to restrict the access to such types only via via be a functional approach this is maybe not the perfect way to maximize your performance in your application but it's maybe the the best way to minimize the probability for bugs in your code just take a look at this you have here you a unique point and let's say you would have here also a mononic approach and cut right just and then and then whenever the integer part contains actually a value you just print it out otherwise you do nothing and then you have clear defined behavior and then you for instance this is very strict and maybe also not perceivedly critical my environment is adjustable but just for instance when you would forbid to use the arrow or the star operator then you cannot really misuse this a unique pointer anymore okay you can of course capture something in the lambda and then transmit the the address of the inside value out and then do crazy stuff but this is yeah cumbersome and i would state easy to use and hard to misuse and here the counterpart is you have a classic unique part and then you can easily access it without having any kind of value and then again you have undefined behavior and now let's apply this for instance to our callback let's say for instance we have still our option on receive callback and we here on this line call it maybe it doesn't contain a value and then we have again undefined behavior but then we would have for instance a functional approach you could say okay if the object on receive contains something then please call the underlying quality but here i assume that the callable the function is never null and it makes sense for instance that you try to risk when you say you have an object which is nullable to enclose it in an optional and try to avoid to use really the nullability of a type because it can lead to bugs and if you want to take a look at an optional which already supports such an api you can also again look here at iso xuv's where the optional is implemented is the api easy to use here let's assume again our receiver with our four arguments the history cache size on receive on a connection and acknowledge get some kind of default values because it makes stuff easier and it's easier for the user to create a receiver and therefore we come up with some kind of default values like 10 because on receive no connection option l therefore we say okay in the beginning we do not need to set anything and every time we receive a package we send it out and acknowledge and now a user comes to us and say okay i would like to change the first and the last argument one approach would be we just try to change the api and overload the constructor so that we have one constructor which starts with the history cache size and one constitutional acknowledge and then we have 10 variations of constructors so that every kind of optional use case and so on is covered and this is just as extremely error prone and we can actually do much better the first thing we have to do is you just pack all these arguments into a struct this is something which i would recommend whenever you have a functional method which contains more than two arguments let's say just to make it more readable it's not always a usable or useful but this is something you should keep in your mind and now let's say we have our history cache size we assign it again 10 and all the default values we had before and now we use it in our constructor and how does it help us now we can use c plus plus the z plus 20 feature aggregate initialization and only is that the first and the last argument how does it work we use just the uniformity civilization and here for instance we have in this example a struct called struct name and it has two members or maybe it has five members and we just want to initialize a member name and another member and member name with value 1 and value 2 and this is how it looks like and when you write and apply this to our constructor and write code it would look like this you would state here we have a receiver my receiver we construct the receiver info and state that the insta history cache size has to be 20 and we do not want to send an acknowledge and we may do a comparison we see here on the right side we have again magic numbers it's not completely readable because you have no idea is the personal upload now further on receive or for the on connection callback and this is more or less readable you know what it's doing but the other arguments are somehow a little bit you have no idea and here again the user has to read some variables to avoid the magic numbers and make to it to make it really readable or use a different approach with the c plus plus 20 aggregate initialization and just state here explicitly the history cache size is 20 and acknowledge yes we want to discard it and this improves the readable readability a lot okay is the task the code performs clear again we stay at our good old receiver and let's say someone says yeah my typical use case is i either have one connection and whenever i have this connection that i want that the receiver in the constructor that i can add this connection and then the receiver connects automatically because it makes life so much easier for me or the other use case is i have a bunch of connections then i want to add all these connections to the receiver but i do not want that the connection that the receiver connects automatically i just want to add these connections maybe later add some more connections and so on and then you write a receiver which looks like this in the interface and you write code like this the only difference here is one curly brace which changes the behavior completely here in this case we connect automatically and when we add a curly brace we do not connect automatically and here we have universal initializer list which initializes a vector of connections and we do not connect this is not readable at all and this is extremely backprone can we do better here and here this is a trick i learned from the implementation of the stood very end here they are an average trick and they define two structs in our case we would define two structs called connect on creation and add connections only so that the the user knows the intention of the constructor and so that we do not have any runtime overhead we just create some constant expressions and say here connect on currently on creation and add connections only and add these two to the constructor we have one construct where i say connect on creation and we have a different constructor we say add connections only and when we now write code we clearly see what the constructor does either it just connect a connects on creation or it just connect adds the connections only and does not connect and when you compare it to the readability of the right side you see a clear improvement and it makes the code much more reviewable and reduces the amount of bugs because you clearly state see the intention and the idea behind this so but something else here when you have the possibility it's not always possible but the best thing to do in such cases would be not to introduce such a struct to just introduce factory methods here for instance we do the following we have a receiver and create two static methods called create and connect and create and add connections they return an optional in our use case and i6 we have also expected on our hands therefore we return an expected which provides also the an arrow value to the user so that the user knows what's going on when the receiver could not be con created and here we just say okay this connection create and connect at it's very readable and have also the the advantage that you can do some banter error ranting and also you improve the testability because you can hear inject also mocks ownership and lifetime do we use drive let's say during a code review encounter test like this add something or remove something or create something and destroy something attach detach allocate free open close and maybe there are some even more indicators and whenever you encounter such an indicator in some kind of api you should think of right right means resource acquisition is initialization this means that we bind the resources lifetime to the object's lifetime very classic examples are the unique point on sharepoint and let's say we have here open and close we have open a file and close the file then the file is our resource and when we return some kind of unique point or whatever we bind this return value to the resource lifetime and whenever this object goes out of scope the resource is closed and now let's apply this and we would like to have a copic in our receiver and whenever the receiver receives the message we have a center object and this sender just forwards a message and sends it out to a next receiver for instance and we could implement this like this we attach on an on receive copy and say okay whenever you some user would like to have some kind of callback attached here you can use this method and when you are done with the callback you can just remove the callback and provide me the copic id which i provided to you when you attach the callback and then someone say okay now i create my sender and this sender has already a callback idea for the receiver and we attach here our it's all received callback and here inside we state okay this copic is called whenever the receiver receives the message therefore we acquire here the message in this line and then we send it out and then we are done with it with everything and we forget here to call remove callback before it's going out of scope because maybe the the developer who used my sender in some kind of other method wasn't aware that he has to do such or that they have to do such of such a cleanup and we have here a dangling reference because my sender is no longer weld after it's going out of scope but attach on a receive call receive callback is again called when the message is received and we access my standard and then we have figuring reference and we try we can can get rid of this little problem for instance the unique pointer can be used in combination with a custom deleter instead of returning just a call big id let's pack the callback id into a unique pointer and into a with a custom deleter this would be then the return value of the method and this is how we would create this return value we would get from somewhere else the callback id would create here the callback id on the heap initialize it with the value wherever we have acquired it and then we would state here we capture this and whenever the unique pointer goes out of scope the first call remove callback therefore the callback is gone it's cleaned up cleanly and then we delete again the callback id and then we now use the same thing again we do not check the code at all we just have to change here the underlying type because it's not a callback id underscore t it's now a stood a unique pointer with a custom deleter which contains this callback and then the center goes out of scope callback id goes out of scope and everything is magically cleaned up and this is another way to reduce bugs and whenever you can just use rice ery because then you have a clear ownership and a clear lifetime of your resources but it also again comes with a drawback let's say our receiver is again stored in a vector and this receiver can be moved or copied and when we capture this pointer here then it can happen when the receiver is moved that this pointer is no longer valid was pointing to the wrong object or a copy of the object and therefore the wrong callback is removed or only partially removed therefore whenever you use the technique with a unique pointer with a custom deleter you have to either make sure that copy and move operations are deleted or you have to make sure that while you are using this approach you do not copy or move the object anymore or the best way would be to not use a unique pointer to write a more complex class yourself where whenever the unique point or the the callback id which is then provided to the user and the underlying object is moved then the copic id is informed that the underlying object where you really address and call remove callback is now moved and that this pointer has to be updated is the code expandable let's say now we take a look at the sender agenda is a simplistic class where we just say we can attach a bunch of receivers and then we can send a message to those receivers and we i want to deliver this message with a method called deliver and to do this we want to have a classroom which contains a vector of all the receivers called receivers and here the chef pointers though to the receivers and then we can do the following attach a bunch of receivers and whenever you want we can send out a match message to all the receivers and then the receiver can handle the message how they would like and the first thing is when you want to implement this you maybe think okay just write some kind of abstract base class we have to define a there that we have to implement the deliver method or maybe provide a default implementation either abstract method or some kind of default implementation and then you can inherit from this receiver based class and can write all the receivers you would like but let's assume you cannot do this you do not want to inherit from receiver because this receiver base class has a lot of overhead or in our particular case for instance because we are working across process boundaries we are not allowed to use v tables and then you can sit back and say okay what's actually object-oriented program object-oriented programming means that objects are communicating via messages so when you think of it in an abstract way and in the end in object-oriented programming every object is somehow a sender or a receiver because you will receive some message from another object this is by calling the method or you're sending out a message by calling a method for some object and can we do something like can we can get rid of inheritance and attach any receiver which has a deliver method okay we could now say okay we just use some kind of template inheritance but then the question is okay what do we store here in the vector of the receivers so the answer is nice and quick we change the attach method a little bit of the sender and make it a template and say here we have a receiver type and we can attach anything you would like as long as it's coming inside of a shared pointer and then you provide us the receiver and what we are doing here is instead of storing the object itself in our vector we store the task the message we would like to send the way the message should be sent and this means we are capturing here the receiver inside of this lambda this means we get a copy of this inside here and whenever we want to send out a message we just say okay deliver the message and out it goes and here we have a nice way to close the gap between compile time inheritance and runtime and you know compile time and runtime normally you have to something like this let's say you want to go or close the gap between compile time and runtime you have multiple types for instance and then you have a big switch case statement and you have to decide what kind of method or what to do with this particular case and so on but here everything is covered via the caller the function because this is just a copy of this you can copy any kind of object in there and then you can call deliver on any object which just has a deliver method this concludes my talk again if you have any questions you or you want to see more source code or something like this or but also if you have questions maybe one or two days from now just go here into this repository create an issue or pull a request if you think there are some questions missing or you want to add some kind of code example or something like this just go there and now i'm open for questions next question for the talk we already have some questions not sure if you are seeing the question slides yes yes okay i think here i just read the question christian kaiser asks if you are using ziploc 20 in productive code do you know of any safety qualified compiler and we do not use c plus plus 20 in productive course we use g plus plus 14 in productive code but what we try to do is to take a look at all the cool stuff from c plus plus 20 and 23 and implement this in c plus 14. at the moment i think the the latest c plus plus standard we have a certified compiler for a c plus plus 14 with q and x jenna are you using cpr perspective productive code or are its features it is yeah okay we use the features of c plus plus 20 for instance with designated initializers you actually can use this with gcc or with qcc the the certified version of the kunix gcc compiler but you have some restrictions for instance if you have four members you cannot use them in an arbitrary order you have to always follow the word as they were declared and you cannot skip any members you have to really define all the members but still it's much more readable than just using metal well okay slide 72 what would you suggest to address the risk that the user will mix up the two optional callbacks like slide 72 okay here the solution would be to use designated initializers or there is some kind of pattern i can add this to the repository in icerice we came up with a husker pattern it's called new type pattern very for instance state or the idea was the following let's say for instance you have multiple fibers and they are returning some kind of indeed says but you do not want to mix them up the indices so that you use a wrong indeed say for the wrong fifo and therefore we used again the type safety of c plus plus and created all types for all the indices and we use the new type pattern for this and this is in the end a kind of bunch of template classes where you can't just state what kind of underlying type this is like integer for instance and here in this case it would be as to function an optional step function then you can state should be copper be a copy will movable and so on and then you have individual type for a receive and then connection and then you then mix them up you get a compile time error could you elaborate on undefined before not being allowed does your compiler define the behavior for example integer overflow what happens when you do it undefined you abort things okay undefined behavior our compiler behaves like a normal c plus plus compiler therefore when the c plus plus standard states here this is undefined behavior yes we have undefined behavior there but our software which we deliver we do not want to have undefined behavior therefore what we do is either we wrap the constructs up via which the z-plus delivers us and get rid of the undefined behavior for instance and with some kind of more extensive error handling or we in the end we implement the stl constructs ourselves because we are restricted to c plus plus 14 but we would like to use an optional we would like to use an expected or whatever or variant for instance whatever cool feature we would like to have and yeah that's the way we go okay early slide the pattern used unique pointer but in safety otherwise you don't have heap this is correct this was just an example to illustrate the the behavior and we have in our safety environment we actually have implemented unique partners ourselves but it works a little bit differently we have a bucket allocator and this bucket allocator returns not pointer it returns a point is packed inside of unique pointer therefore with this bucket allocator when you allocate something you get a unique point or sharp pointer out of it and then you can work with it and do not use the heap okay then the next one the lambda requires a lock in the thread save integer vector and chooses a hide that log risk as its arbitrary user code let's go back to the vector i have no idea there was a slide [music] oh i keep seriously okay okay i think you mean this for instance or the other lambdas and the first thing is let's say it's extremely hard to create a log free vector which using such of kind of behavior therefore you are right you have to use a mutex inside of the red safe reactor but it's encapsulated inside of the vector the next thing that this introduces a high risk of a deadlock because someone else could here do some crazy stuff for instance we could capture here something and then inside of the fletcher vector we could again do something with the vector and j just we push back another element and then we have a log which again runs into a log and then we have the deadlock we are mentioning but here we can first hand we can use recursive mutex to get rid of this problem and let's say for instance you would do the following here you introduce here a lambda which it creates a new thread inside of the lambda which again then does a pushback and then waits for the pushback to to to to complete and this is then during the log even then the recursive mutex will not help you but yeah i would say this would be a misuse case this is our samsung you have to face here also in reviews i have no idea how to get rid of this and this is a problem we have to be aware we have to take care of but i would argue that using this in this manner in my opinion improves save usage of a thread safe vector to use a function but it comes with drawbacks and you have to be still very carefully the next question could you repeat why you can't you see that this environment use an alternative how do you allocate memory okay we are not allowed to use heat because we have to guarantee at any given point that for instance when some camera image comes in and requires one megabyte of memory that this one megabyte of memory is available let's say we would use the heap and let's say we have 10 megabytes of feed and we would have 10 megabytes of very fragmented heap this means we do not have one piece of memory which is which has a size of one megabyte we have a lot of pieces which have the size of 100 bytes to 100 kilobytes for instance and now we go to the allocate and say okay we have five megabytes left but extremely fragmented therefore we cannot get this camera image anymore or can we reserve memory for this camera damage anymore and then we just fail and this should never happen in a safety critical system because when your camera detects a tree and you have to break then this memory has to be available our alternative is we allocate everything on the stack or in the data segment and therefore we have a bucket allocator and currently we are implementing a more sophistic kind of allocator the bucket allocator in the end you just state okay i want to have 100 memory samples with a size of one kilobyte 100 memory samples with the size of 10 megabytes 100 memory samples of a given size and then these are stored in buckets and whenever a user comes he can get a memory sample from this particular bucket and we can guarantee then that these buckets are always have obviously samples available which were configured for instance by the software architect and this is how we allocate memory next in slides 35 is it not hiding errors when remove connection does not remove a connection the user possibly had the wrong impression that the connection existed yeah one could say this and this is actually something where we had a very nice discussion on github about exactly this behavior slide 35 and the conclusion was actually yes maybe it can hide some kind of error but here we wanted to make sure for instance if you want to make sure and you see this as an error that remove connection when you call it but the connection was never added we have to add another method to state is connection available if so please remove it and the problem here was actually when we reviewed code like this and we said okay remove connection it failed the connection is still available what do we do now what the hell and what's what's going on and it led to a lot of false impressions and it was just used intuitively wrong the code here then the the error handler and then terminate was called because we thought okay something is really broken here and we have no idea what's happening and then we read the documentation that okay yeah it's just an informative boolean and therefore we said okay we split this up we have a method called his connection connected or is connection available and then we act on this why choose c plus plus for safety global environments at all it's not memory set it's very easy to accidentally trigger you and different areas that exist alternative alternatives that are low level and performance and don't suffer from these issues i think you are meaning rust and i'm on your side i think also that for safety critical systems rust is maybe the future but i will not give up on c plus but i think we can learn from from rust and maybe c plus plus develops in the right direction and then we are compatible or they're competable and again okay i think christian answered all questions i would like to thank christian for this really great talk and yeah i think since since at least the last question got a lot of interest here with seven upwards maybe i can invite you to the launch uh where there is a special a place for for track c we can discuss further on western safety and all the other topics of course offers great stocks maybe more on the great talk and less about bus and services yeah okay then thank you very much and thanks for having me here i enjoyed it a lot and see you there in the lounge