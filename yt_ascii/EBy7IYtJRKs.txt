what we're searching for today it's very simple it's the answer to how do we decode the wonderful code that we created just about what a week ago now something like that let's just remind ourselves where we were with this code it was a five bit code coding theorists will talk about this code which i'm going to write out as being a five two three code i'll fill in the details and then i'll refer what i've written down to this remember also that these are the exact powers of two that's two squared the number two position is two to the power one the number one position well that's two to the power of zero but that leaves bit three and bit five for the actual message bits two bits bit three bit five two bits four combinations possible and those are the four san francisco weather states so i've sometimes referred to these as info bits message bits it comes the same thing that's the message you're trying to get across that's the message that these parity bits are there to check out and make sure it's okay and we ended up with one code word if you remember that's the in phrase for these things the zero zero state in message terms i think we said was foggy this time around and here's the protection of the parity bits there we are all written out again now coding theorists would call this a five two three code how does that work well it's a 5-bit code that's what the first number means it means total number of bits the 2 means the number of message or information bits and this if you remember is this business called the distance how many bits differ between these rows so the distance in the technical usage of the term here the number of bits that differ between that line and that line is three and to get one of these codes working you need a minimum distance of three and what do we mean by working what we mean is that a distance three code can correct a one bit error and for those of you just yelling at me but what's the general formula then for what you can correct for a given distance in that watch carefully it's a one-liner more or less floor of d minus one over two and remember floor of means round down so let's do it for distance three three minus one two two divided by two one round down one it's already rounded down so that's telling you using the floor of function it's saying for a distance three you can detect and correct one error so bearing that in mind if we see things in the future with different distance properties at the end we always apply this to find out how many things they could correct the powers of two and the parity check bits what sequence of numbers were they used in checking up on this first block the one bit checks itself and three and five two bit checks itself and three and the four bit checks four and five where do those come from how do you get those lists and i think last time i perhaps didn't make this quite crystal clear so let me explain that those come from effectively saying for all of the things that aren't powers of two how could you build them up from adding together powers of two one you don't have to build it up that's itself one is one similarly two is a power of two and it's just itself where you really have to start doing this powers of two add them together to build them up thing is with three the most compact way to represent three a sums of powers of two is one plus two what about 4 no problem 4 is itself it's a power of 2. but then when you get to 5 you say ah the most compact way to do this is 1 plus 4 powers of 2. six two plus four seven quite complicated now but if you think about it sum of powers of two that add up to seven in the most compact way you can do it one plus two plus four so really these lists that we had previously about what checks for what is as a result of writing these out first and then say but if we were going backwards where does the digit one appear it appears in itself it appears in the formula for three it appears in the formula for five it appears in the formula for seven so that's where that first list came out here that one checks up on 1 3 5 7 9 11. all the odd numbers because one would appear in the sums of powers of two that build those up two yes two appears obviously in its own list but it appears first of all next door in three has been one plus two does it appear in four no four is all on its own it's a power of two what about five would two appear in five no it's one plus four so the next place that two would appear is six which is two plus four so i hope if you so if you had a six bit code would two have to check on on one extra bit yes it would similarly four checks on four it checks from five it also checks on six because six is two plus four so if you're building up these lists for making them longer to do more complex codes then if you're encoding and decoding in this by hand method you need to keep up to date your sums of powers of two for all the new positions unless they're exact powers of two and then go backwards and say ah but these are my checklists that i build up from that so just to remind you then of what happened was that on this one here let's take this second one the informational message bits are zero and one but what tells us here that's bit three and bit five but it says here that bits one three and five taken together must be even well three and five norton one add them together that's one so therefore bit one which we would be filling in has to be one make it even we're going to say because you all want to know how to decode it and detect errors and correct them this one here is going to be badly transmitted instead of one zero zero one one it is received as one zero one one one so straight away whoever gets that is gonna say that isn't right they're gonna say that that isn't right because there's so few of these there's only four of them you get to know them like old friends but you imagine if you've got 64 of the sound cells can you guarantee that you'll be able to memorize every single one no you need an algorithm and what we do here is a reverse of what we did when we encoded we say let's look at the list that follows on and is checked from 1 1 3 5 and so on that's what we received that one is one bit three is one one on one is zero but five is one zero and one is one it's supposed to be even parity wrong it came out as odd parity bit two checks out on itself and on bit three it doesn't occur in bit five because five is one plus four not two plus four so you look at bits two and bits three zero exclusive order added if you like to one it's a one it's on parity it's wrong okay now you look at the four bit and you say bit four checks out four and five four and five one and one it's zero hooray it passed the test yeah we failed two tests we can work out from that now yes you can very simply because the headers of these lists are the powers of two that they check up on in all of those lists and if the two one has gone wrong and the one one has gone wrong then the wrong bit was one plus two ordinary edition this time not binary edition one and two makes three bit three is wrong so then we flip bit three and we've got the right bit three one zero one one one that's the bad bit it's received as a one it's wrong so it must have been a zero one zero zero one one magic does that look familiar that's what you correct it back to and it's entirely done by getting these lists of powers of two doing another check on them almost like it's exactly the same as when you were encoding it's just you're doing this again you say that's wrong you know don't add up so you see you've simply reversed the process i mean does that always work then yes forever for any of those bits for the price now that's a good thing if you if you're thinking oh but that's a message bit oh no come on something really went wrong there because what was transmitted to zero one that's sunny it wasn't it has turned out as rainy one one wasn't it yeah you turned to rainy oh yeah that's fine but what about if you hit a parity bit surely that messes everything up no it doesn't it's actually dead easy and i want to leave as an exercise for you to do is this time one zero zero one one don't hit a message bit hit that parity bit at position four change it to zero do the checks and you'll find out that the one list passes with flying colors nothing wrong with it the two list passes with flying colors the only one that fails is the four list so if it's the only one that fails that's it four is four nothing to add to it you've done the homework for them i've done the homework but yeah so do it for yourself on any bit you like and convince yourself that it doesn't matter if it's message bit or parity bit this method will come in on it i have built this up and i've explained to you now you can go into a pub full of coding theorists and say hey like i've got this 523 code and they will say well you realize that you derived it using richard hamming's algorithm but it's not a true proper hamming code because it's not perfect and you say perfect what's perfect i think we have to go to another video sean i know they hate cliffhangers but yes real hamming codes are perfect they really are now the only sort of if you like slide health warning to say about this just to round this off now is by all means do it by hand if you want to code it up as a program great you'll learn a lot but don't run away with the idea that this is the most efficient way to do it