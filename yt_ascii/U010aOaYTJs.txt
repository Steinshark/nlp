hello and welcome everybody thank you for joining me today i'm francesco de lafully and we are gonna see how to use the penis injection to write maintainable software before they start let's talk a bit about my background i'm a software engineer building monitoring systems at meta i'm passionate about c plus plus and i use it throughout my career i'm the author of the book c plus plus fundamentals published by pact and in general i like writing and talking about c plus and before we start let's have a couple of disclaimers what we're going to talk about is difficult to get hard data it's mostly based on my experience and practices i see it used in the industry i'm gonna share a bunch of tools techniques and suggestions but it's up to you to decide which one and when to use it and as usual context is always relevant different constraints call for different solutions so don't feel like you must follow these as rules is it the option that you have but i believe this is a good starting point to write good software and if you don't have a good idea of which approach to follow already this can be a good path to start on so what we are going to talk about today we are going to look a bit about dependence injection and what it is then we are going to see what are the types of dependencies how we can pass dependencies around and finally we are going to see how we can abstract components so what is dependency injection let's look a bit at the software that we work with likely it's composed by multiple components and these components interact with each other a component should interact with another through an interface what do we mean with an interface an interface is a clear contract which has preconditions which is what must be true at the time in which you call the implementation and post conditions which is what must be true after their call returns an implementation may have other observable behaviors for example when you call a function this might log into the standard out but the user shouldn't rely on that because this is not what the interface is guaranteeing and since there's an interface there could be multiple implementations for the same interface in this diagram that we have here the interface is represented by the shape and we see that the user is taking a shape and then we have two implementations which are both offer the same shape so which shape should the should a user component use the core idea of the penis injection is that the component shouldn't care which implementation is provided to it as long as interpret matches the interface that it expects but how can we write components which work in this way the idea is that we inject the implementation into the user so we have various implementations we or even see a single one which implements an interface and the user expects this interface and the higher level some higher level code is going to decide which implementation to provide to the user this last part about the higher level decision sometimes can be automated with libraries but we are not going to see this today we are going to just see dependency injection how you would do it by manually propagating your dependencies and the core point then is that you never want to instantiate your own dependencies the dependencies should be passed as a parameter the reason is that to instantiate an object you need to know the concrete type and if you know the concrete type now you're not talking about the interface anymore but about concrete objects and if we follow the pattern defined by the dependency injection we are going to end up with something similar to this picture when we have a component which implements an interface and also uses another interface to implement this functionality and then it does a bunch of implementation code and various components depend on each other and as we were saying earlier there's a higher level part in this picture is called the main which decides which component to instantiate and does all the wiring of the various components the big win of dependency injection is that it's simple to validate the correctness of your component because to validate whether b is correct the only thing that you need to know is where what is the contract on the interface that we implement and what is the contract of the interfaces the b depends on besides this the code of b is going to be enough to evaluate whether b is respecting the interface the fact that it implements the other advantage is this makes it also simple to the couple components and makes testing easier because again we are working with interfaces and not with concrete component so we talked a lot about dependencies and we said that for dependence injection you need to pass your dependencies are parameter and i'm sure all of you know how to pass the parameters to function or classes so what are we going to look at here we are going to look a bit about how we can pass these dependencies around because this actually has an impact on the design of the software so i hope dependencies are passed around in imposes constraints imposes constraint on the user of the interface and on the a component which implements the interface let's see an example here we have a function which take a shared pointer of a dependency and what the sharepointer means is that the implementer of the function now knows that it can store for example this sharp pointer for later use because the lifetime of the dependency is going to be preserved but on the contrary the user of foo so who calls foo now need to provide a shared pointer and potentially they might not have a short pointer in that case we they will need to allocate the the object into into memory to create the shared pointer on the opposite side there's a bar which takes a dependency as a reference what this means is that the implementer of bar now has no guarantee about the lifetime of the dependency except that of course it's going to be alive for the duration of the call so for example if you needed to store it it couldn't but on the contrary for the user they just need to pass the dependency it doesn't matter whether they add a share pointer they added on the stack this is a constant somewhere like a static variable somewhere so there's more freedom on the user and more constraints on the implementer and the thing to keep in mind when passing dependencies around is that you need to impose all of the required constraints for your implementation and only your required constraint you don't want to over constrain your function because you're going to put burden on the user without getting an advantage free and one of the things that we are going to see is about the method for lifetime management of the dependency where i'm going to show how taking the dependency as reference can actually make the code simpler and give more options to the user compared to the typical approach of passing smart pointers and the reason for ease for these is that the component which instantiates the dependency is responsible for the lifetime of the dependency and the same component can also be responsible then for the lifetime of the transitive dependencies of of what we build so we are going to see later on concrete examples on how this works in practice so let's jump into the type of dependencies and when we are talking about dependencies we can roughly categorize them into big groups one is a data dependency and this is a dependency on some kind of information and the other one is a behavior dependency which is a dependency on some kind of action for data we want data to always be read only this is important because we want to avoid action at a distance what is action at the distance let's say we have two components which access the same global variable or even just you know a local variable which is passed to the two components and these are passed as references now component 2 can modify these variables and component one can read this variable and what happened is that we in fact couple the two components because now component one can see the behavioral component too and this makes it very hard to evolve the two components and it's actually very hard to reason about as well because to know whether that component one has a hidden dependency on component 2 and vice versa you need to look at the global code about everything that's shared the moment the data is constant this kind of coupling cannot appear and it guarantees the independence of the components unless they have an explicit dependency between things so data is mostly of two natures one is constant and one is data which might change over time and see again these are constraints one is a constraint which is imposed on the interface so the data that might change forces the interface to write code which is able to handle data with changes while the other one is a constraint on the user because the data must be constant the user cannot modify this data for the duration of the of the dependency the other aspect of data as a dependency is that this shape of the data is the interface this means that for example if you have a sequence of item then the the this is the fact the interface of of the data the other is that we want to use value types so basically types which are represented by their value an example is an integer a string right like if you have a string foo and the string foo these two are functionally the same thing this is just data we don't want to have differences depending on the instance of the object and the other thing is that it's better to make the shape explicit so what this means is using structure type so the vectors structs or schematized types an example can be a protobuf or thrift or any of the schema option which can generate types to interact with these with these types and the important part is that by looking at the type you need to be able to know what you can get out of this data so for example json it's generally best avoided because when you get a json or for example a map of strings to strings or a dynamic in any the user cannot look at the type and say okay i know i can access the key foo right you need to know what is inside there separately and this makes the interface less explicit so let's look over here talking about the shape is the interface so let's say we wanted to get a sequence of items one option for our function is to take this sequence of item as a concrete type for example a vector this gives us the maximum performance assuming for example that the user has a vector and but it limits the freedom for the color why because if the colors as a vector this is just going to work with our function which takes a vector but in the case the user has an array we will need to convert it to a vector and same if you have the set it needs to be converted into a vector if on the other case we have we use a view object for example sd span performance wise it's still comparable with the vector so very very high and but the freedom for the color is a bit higher in this case we can get sequences but which are continuous so for example if you have a vector it's going to work with span and if you have an array it's going to work with span but again in the case of the set when we try to pass it to the span this is not going to work and the last option is to get a polymorphic object for example any range any range is available in boost is available in four in the ranges v3 library and performance wise this is the one which comes at the most cost at the highest cost but it gives the most freedom to the caller because in this case we have really representing any sequence of of data and it works with vector with array and reset so in java there's a common theme that you can go from the most generic solution which works with them in the most cases and that has the highest cost to the more specialized solution which has the lowest cost the thing to keep in mind is a bit also how this thing compose so let's say we want a sequence of sequences in the case of a vector this can work because a vector of vector is compatible of course with the vector of vector and similarly a range of range can take as an input a vector vector where these breaks is with span a span of spans cannot take a vector vector we will need to create a vector of spans so as from the practical point of view what i would normally recommend is just to use the concrete type very often there's some type which makes sense in general in many situations the conversion is not that expensive but it depends on a bit on the on the use cases the other option that we haven't talked about here is to use a template the moment you use a template in that case any type is going to be compatible as long as it has the correct interface and the performance behavior is going to depend on the specific implementation of the of the type so for example whether you pass a vector or you pass a list you're clearly going to get different performances but that is in control of the color so let's look at data that is a constant when we want to pass data that is constants we want to pass it as a constant reference because reference it means that the implementation is not going to modify the data what we also need is that the caller must not modify the data because first it's surprising when a const reference changes so for example you access the ids in in the code here and then you do an operation and then you modify the ids again and now the ids are different this is typically surprising and the second reason is that actually it's a defined behavior if it's done by different threads so the only way to do it safely and it will be through some kind of loops in quarterbacks which make the code quite complicated unfortunately in c plus plus there isn't a way to say pass me a reference which you are not gonna modify but this is a constraint that you it's quite easy to to follow for example if you declare your variables are const this is just gonna work and the use case for passing data as a const it's for example when you have hard-coded parameters timeouts when you're making calls or parameters from a cli flag so you read the cli flags at the start of the program and then these are not going to be changing for the rest of the program so you pass them as a constant and in general should be the preferred way and it's very common way of passing data informations as dependency the other kind of data is the data that might change day-to-day might change is still read-only and it doesn't mean that our component can change data our component never change the data this is a dependency is just accessing the data and this data can change when you have you support when your implementation supports data which might change it's important to make it clear what you can do is using an atomic graph for example this comes at the cost there are some limitations on the types that it can be used with and also copies the type for x-axis another option is using a fully synchronized this is a pair of lock and data which guarantees that the lock is taken for every access to the data and in this case it's a general solution which works very well and but we need to be careful with this content where there's the risk of day of contention and this can happen when for example there are two components depending on the same mutable data and one component takes every block and keeps keeps it for a long time when something wants to change the data because the reality of this data changed and tries to acquire a right lock this right lock is going to be blocked until the read lock of the component is done if after this the second component tries to access the read lock depending on the implementation of the lock it might get the lock or it might block but in any case is not going to see the updated version of the data even if logically his check happened after the new data was ready another option to solve this problem is to use folly observer this doesn't lock the data when accessing or writing and exposes snapshots of the data so the coupling the contention but comes with a higher cost as it stores multiple versions of the same data the advantage of using data that might change with these classes is that it makes it easier easy to test so for example you can just pass a wrap value to the test and compared for example with having to mock whatever was producing the data and the other advantages which makes changing the source of the data trivia because the component is just accessing this data but it doesn't have any information about how this data is produced or changed changing the producer which is whatever sets the value of this data becomes completely independent from the consumer and make it very easy to to change later on the use case for data which might change is a pushing behavior so for example when there's some configuration that changes or for example you want to reload data from a source or if you have information on the file system that you're listening to and then you're when they get changed they get pushed to the to the component for a pool a behavior is often the best solution as it's on demand and guarantees are fresh air freshness so let's look at behaviors a behavior can be for example a stateful effect like scheduling operations sending a request to a service but it can also be getting data on demand like accessing local state or fetching from a db or even differently it could be performing a pure computation so for example you have a complicated rule set that a set of rules that you need to apply to some to perform some action and you want to abstract away this complicated rules from the component which performs the computation and when we are talking about behaviors we might be talking about single actions or bundle of actions in the case we are talking about single action and we want runtime polymorphism we can just use an std function or an sd function with let's see an example here we have a function which needs to get the configuration for a specific path and we can see that we define our configuration loader as a function which returns the config and takes the config path and then we just pass the function to our do staff our component and when we call a component we can just pass the lambda which takes the path and does the load or we could pass the address of a function that we set up somewhere in the case we want to have a compile time a polymorphism we can use the concept and to use a concept we can use invocable and invoke result and and this is can be done i'm not going to go into the details of the how concept work there are other talks which explain how talk our concepts work and i highly recommend but in general we can make sure that our type it's a invocable can be invoked with a an object of type config path let me get the pointer actually okay our object can be invoked with a a config path and the result of calling with the config path is going to be a config and this guarantees we can then take a template this is an inline template with auto which is constrained by the config loader so it's gonna take any function which is going to match that that concept let's look at bundles so bundles are a set of of actions that we want to do as a unit an example for example when we are talking about a runtime a polymorphism is to have an abstract base class like what we generally would call an interface when we have multiple functions into the same class it's very important when using abstract base class to avoid having a concrete base class the reason is that any data member that you put into the base class and any constructor is gonna run when anytime the any the derived class is going to be instantiated so for example if you put logic or data inside your base class even when you're going to instantiate a mock in the test this data and this logic is going to run it makes it very complicated to then do testing especially if there's any kind of side effect happening in those situations so just stick to having an abstract based class and derive from from that in the case we want to use static polymorphism again concepts are the solution we can specify the methods that we expect on the type and what is expected to return the good thing is that when we want to mock the concept we can just use our typical mocking strategy that we would use for runtime polymorphism in this case i'm using as an example google mock and we can validate that our mock sender and notice that is actually not implementing an interface is satisfies the eye center so we actually get both behaviors with the same library without having to learn anything new so this is a summary of what we just talked about when you want to do behaviors how to pass behaviors if it's a single action and you won't runtime polymorphism you can do std function or sd function ref if you have a bundle of actions and again you want to do runtime polymorphism you can use an appstar based class and in the case of static polymorphism you can always use concepts i don't need to a slightly different ways sometimes behaviors are optional so you want to make your depension the dependency optional when possible i would suggest to try and make them not optional if you can provide a no hope or a default behavior for your dependency it helps to not have this optionality and the reason is that you avoid branches in the implementation and it's just more streamlined people don't have to guess is this needed it's not needed what happens when it's needed you just pass the the default or the no op implementation and and it's just more linear than the implementation the other cases in which you actually want to pass you need an optional dependency you can use std optional when we are talking about single actions so for example in std optional of a function or you can use observer pointer or an optional reference wrapper of the type optional reference wrapper is quite ugly to see and people would suggest hey this exactly the same thing as a pointer but the pointer actually comes with a bit of an overload of information sometimes people are going to be questioning does this take ownership can it be do do i have two freed at the end and to avoid all of this question like having the optional reference wrapper it actually just makes it clear when internally in your implementation once you get the optional you can change this to a pointer because you're gonna know that this pointer is just accessing the object and it's not actually owning the data when we're talking about dependency the other thing to talk about is that it's better to pass data as dependencies rather than a behavior and the reason is that data is less powerful so it's easier to understand so if you have an example here when foo is a function which calls some function and get data you can imagine this as being a dependency and once we get the data we do some stuff with it and then we call another function for example a callback with this data this can be changed from the previous example to this one where we take the data as an argument we do stuff and then we return the data to the caller this is easier to test it's easier to compose because once we have the data for example we can call different functions with this data we don't are not forcing to only call whatever it was specified in the initial function and when you're reading the code there's less of a jumping from one place to the other to the other because even in the execution stack you're going to be it's gonna be flatter so you're gonna have to jump in as much it's clearly important that these do stuff with data is actually a bit meaty there's a bit of logic interesting logic going on there because when we might we change a function to be like this at a higher level there's going to be some other function which gets the data passive to this function and then with the return data does something so if they do stuff with data it's very little we are going to end up with something which looks very similar to this anyway all right so we talked about how we can take the dependencies and now we can talk about how we can pass the dependencies to the various components so we have two options we can pass the dependencies to the constructor or we can pass the dependency as an argument to a function the important thing is to not use setters the setters enable cycle they confuse lifetime they force to handle the case in which the dependence is not set they force to handle the case in which the dependency changes at runtime let's let's see an example so we have component a and then we have component b and then we set the dependency of component in a to b but then at this quest at this point my question what happens if component a access the dependency in its destructor we would actually access a dangling reference to the component b and then we have component b which set the dependency on a and at this point we have a cycle and changing this becomes very art so much better to avoid having having sectors so let an example of how we could be seeing the dependency passed in a code base that we might be working on and here we have full which needs a logger and it takes a path of where to log and then instantiate the file storage providing the path when this file is where the log is going to be stored and then we create a structured logger which takes the storage and we set this as a locker and then the class is gonna use the logger but to do this who needs to know that file storage requires a path then this structured logger requires a file storage and that the structure logger is an implementation of the i logger the other thing is that we are forcing the structure logger on taking the storage as a unique pointer and this is a quite there's a lot of coupling here because this class didn't actually care about all of this implementation they just wanted to get the login and the usage of the class is quite simple though we can see that we just install sheet full and we passed the the parameter which makes it appealing but let's say what is the alternative with dependence injection so with dependence injection we just get the logger as a reference we take it as an argument as well because as we said we are not specifying we are not deciding inside the component about what is the dependence that we need to use and we just set the dependency and when we want to use we want to instantiate it's at the higher level that the decision about which logger to provide is made in this case a structure logger and the main needs to know about all of these dependencies and the advantage of this is there's the coupling so the food doesn't need to know anything besides that it needs ai what is the contract with eye logger and the other advantage is that changes to file storage have no impact on food so let's say that for example fire storage needs a new parameter in the previous example the first example we will need to get a new parameter inside full to pass to the file storage but in the second example food doesn't know anything about the file storage and the main would change the other advantage is that lifetime is automatic although to be honest also in the first one it was automatic using unique pointers as long as everything is passed as a as a unique pointers and the other advantage which doesn't come with a unique pointer is actually easy sharing so imagine that you have the logger that you want to use in multiple classes or you have a thread pool that you want to share across multiple classes if you're passing dependencies as unique pointers it becomes very hard to share with dependency around and you might say that this is a bit of a straw man because even in in your code right now you wouldn't be passing the they string to the log but you will pass the unique pointer to the logger and in this case we are still talking about dependence injection it's just done by unit using unique pointer we get the advantages of the of using dependence injection but we are still using we still have the constraint of being prevented from sharing the object around and also it makes creating fixtures in test more complicated let me show you what i mean so here again i'm using google test to as an example but the problem is similar in other testing framework and in our fixture which is instantiated for each test we create our concrete class and we want to pass down our dependency which is a mock dependency and once our tests start our mock dependency has been already moved into the the class under test so we cannot access we cannot access the mock anymore to set the expectations so the other option is to actually use a shared pointer and this works is actually an option which is used in many code bases and there might not be big problems with that it still forces the lifetime management to be a shared pointer so let's for example imagine that you're working with some external library which has its own managed pointer instead of a sharepointer you would need to either in fact your code with this new manage pointer and and then changes later on becomes become harder or you might have to migrate be able to translate from this manage pointer to a sharep pointer or even if you have pointers sometimes classes have and you get references to classes but these classes are already managed by sharepointer so a lot of times you actually need to use the enable shared from this to get the share the original shared pointer and don't have problems with the logic while on the other side references are universal if you have an object you're going to be able to have a reference from it and as long as you manage the lifetime correctly of the reference this is going to work very easily the other thing to be careful about is about piping so a piping is when you get some dependency just to pass it to another dependency and the example is the string in for the logger the logging path which we take it and we just pass it into another dependency instead what we can do is pass this dependency directly before into the original dependency so let's see an example here an example of piping here we are getting the config loader and the path and then the only thing we need to we do is pass the path to the loader the alternative to avoid piping is to have our action my action take a function which just gets a config without any parameter and when it wants to get the configuration it just calls the loader and the higher level function does the provides a a function which caused the loader with the provided path and we'll see something similar to this later as well but this basically breaks the dependency between the specific of the configuration loader and the string so for example imagine that the path will type will change to be a path type you wouldn't have to go and change the action because it never occurred about the path it only wanted to have the configuration the other option to pass the dependencies is to pass them as function arguments the use case for these is for example is when you have functions the fact that we use dependence injection doesn't mean that everything needs to be a class c plus plus supports function functional first class citizens in a c plus plus they're very powerful so use function freely and when you need a dependency you can simply inject it and the other reason to use pass independence as a function argument is when the color of the of the function need to control the dependency instances so for example this instance might be changing every time that we are calling the function and the other reason to do this is in case there's a limited lifetime for the dependency that we need to pass around so we cannot pass it in a constructor because the lifetime of this dependency is shorter than the class that needs to take it as a constructor so instead we pass it in the function let's see a concrete example for this let's say we want to have a functionality which formats a message for a user supporting internationalization so we have our translator interface which is a function which takes an untranslated message and then translates the message and then we have a formatter which formats values a argument which takes in a i translator and returns the formatted message the reason why we are passing the translator into the formatter is because the translator needs to know the language to which he needs to translate and to get the language we need to know the language of the user so let's see concretely what this is in the so we are gonna start with in instantiate our formatter and our formatter is going to be used throughout the duration of the program later on we start processing a specific user and at this point we can get the language of the user since now we have the language we can instantiate the translator for that specific language and then we can call format with the with the translator for the specific user but this is not the only option that we have when we are talking about injecting dependency what is the other option another option is to change the translator to take the untranslated message and the language and then the format we pass the i translator to the constructor so the formatter is only going to have access to a single translator and then when we call the format we will pass the language of the user and this is how we would look our stack we first instantiate the translator which is going to shared federation of the program then we pass it to the formatter and later on we start processing the user we get the language and at this point we can call format but if you notice what we are doing here is that we are piping the information the language to the translator the formatter doesn't care about the language it only cares about translating a message into a the correct language and so let's see then this is going to make harder because for example if you change the language if you change what we need to translate stuff we will need to go and change the formatter which actually was independent from from this let's see what is the other alternative to use the dependence injection to solve this problem we are back to the example in which the translator takes an untranslated message and different matter takes the i translator as a constructor parameter so where's the language here how can this work and the reason is that we can change again the order in which we instantiate dependencies so in this case we first start processing the user at which point we can get the language with the language we can instantiate a translator for the specific language then we can pass it to the formatter and then again we can call format with all the information we used so again in in this example we saw how passing the dependency as part of the constructor or as part of the function can change the order so for example sometimes formatter was instantiated first sometimes translator was instantiated first and impacts the sharing that we can do so in this example for example we are going to use a single formatter for a single user we cannot share across users but in the previous example we could share the formatter across multiple users so again what i wanted to show with this is that you have a lot of flexibility by using the penance injection to pass dependencies into the the various classes and what is the correct solution depends on the software that you are building but the other thing to notice is that when i was talking about this example is we are going to instantiate the class but we said that we won't do we don't want to instantiate classes because then it means that we are programming against the concrete type instead of the interface that we are working with so for that we can solve these using factories so a factory fundamentally is still a dependency is just a function which with from some parameter it constructs a dependency and factories are also dependencies everything that we talked about surpassing them as a constructor argument or passing them as a function argument is still the same and applies in the same way for the function but when we define a factory we need to define the abstract type which is returned by the factory because my factory needs to return an insta an interface which is what the user is going to program about and we cannot return the concrete type so what can we return instead well this is a bit of a lie because when we are talking about the static polymorphism we can use concepts and in this case we can see how the concept is going to check that the result of invoking the our function with the configuration path is going to give us back a type which satisfies the concept config like and similar when we call the function we can assign it to auto so this is going to be a concrete type but which satisfies the the constraint of the concept but except for this case what should we return well we have an option a typical option is actually to return a unique pointer and this works when we are instantiating our dependency for example foo inside the function but how does it work uh when we want to have a dependency for example on some reference that we have already available so this is also working because we can essentially the class and pass the the reference that we captured in the factor but what is the case of how does it work in the case you actually have another factory and you want to call this factory to get back a class that then you use here you cannot pass the pointer as the reference because you will get the dangling pointer but if we just move bar then we are passing a dependency a unique pointer and we saw that there's a disadvantage with this because of shame and as i've talked about this you're probably thinking well this is over engineering what are you doing this is this is not something happens normally but actually this is not very rare imagine for example that you have a buffered file reader that basically needs a buffer where to store the memory and for this buffer you actually want to provide it from some kind of allocator so your allocator is going to be your buffer factory which gives you back a buffer and then you pass this buffer to the buffer reader and you could say well the buffer lever should own the the buffer because for example there's no point in sharing this buffer across multiple multiple classes but for example it's not up to the control of the above the file reader to decide that the buffer needs to be freed after the after it's done using it maybe you want to reuse it so it's not super common but it's not very easy it's not necessarily a very over engineered problem so and we saw that in this case we end up either having to manage dependencies as unique pointers or evidently reference so this is also a solution that doesn't work could we use a sharep pointer well the sharepointer has the same identical problem about what we talked about before you get a shared pointer and either you pass a reference if you're taking dependencies or references or you're passing the whole sharp pointer and you're forcing everything to be manage with the sharep pointer but the advantage of their shared pointer is actually that it supports the aliasing constructor so the alison constructor allow you to create a struct which holds by value at the sharep pointer and foo and in full we just passed the reference to the sharep pointer then we create a share pointer which holds the hole holder and then we create another sharp pointer which stores the holder but exposes only the subset of the holder which is full as iphone this is quite complex but the good thing is that in the normal situations like the cases that we saw before when you don't have these dependency on factories the usual approach for using sharepointer works fine and these more advanced approach can be used only when there are these more complex dependencies the advantages of having a sharep pointer is that it's familiar it's available and operates well a lot of libraries return sharepointers or expect to share pointers as a dependency the disadvantage is that it has a bunch of unneeded features so for example we don't need reference counting we don't need the weak pointer and also there's a dangling reference risk let me explain why so in in an example in which we have a full which calls bar and in bar we create a factory which capture our a dependency and then we call this factor inside bus now b where it provides a factory could be capturing a this means that if you take b and you store it in some other uh storage for example and different thread you might end up with a dangling reference because it's not true that you can just as long as b is alive all its own dependence is going to be alive and so there's a safe pattern that you can follow which is that you take a shared pointer as a and the dependency you'd reference it to get a reference and from there on you forget the sharepointer exists because the sharep pointer is guaranteed to be valid only for the duration for the scope of your function and this is quite similar that to structured programming structured concurrency where this helps guarantee the lifetime of your dependency but this is a drawback that having shared pointer provides the alternative will be for example to design your own type for example in holder pointer which guarantees that it's not copyable and it's not movable and only provides the the functionality that we need although i don't have experience with that because in my code bases we i always use the the sharep pointer and to be honest we haven't had the problems with the lifetime of these dependencies but this is something to be aware especially because people need to know that you cannot just keep this pointer putting into a vector and access it later because it's not necessarily valid another part of this is factories of factories and again you might be talking about this is ridiculous the highs your ivory tower but again this is actually more common than it looks like so for example let's imagine that we have a connection let's create a database we have a company which have multiple database depending on the enterprise as it offers the service with and we have a connection to each different company to each different database depending on the company but our code doesn't necessarily care about which company we are connecting with it just cares about having a connection to a database so in this case instead of passing the the connection the the factory for the connection we can just bind the our factory with a specific company and get back a new factory which doesn't take the parameter and just returns a connection this is conceptually very similar to carrying so we're calling a function with the argument is like a sequence of calls of the function and the advantage is that each piece of the each piece of the logic is going to define the part of information that it knows this is something which can happen for example with one level of under action when one factory generates another factory this is not rare i only saw once when there's two levels and then never so three so if you're doing this a lot start questioning whether your design is makes sense because there there might be other complications that it could be simplified the other thing and testing with factories is that actually you can create a mock function and just return the sdd function to the factory and then in your test you can set the the expectation on the on the factory separately so that you can control externally what these factor is going to return even if it's been passed already into the dependency so we talked about all of these components but there's a lot of wiring that needs to happen to have these components work together and the user might not know how to wire correctly these components or they might not care about wiring these these components all together so how can we make this better for the user and especially how we can create higher level abstraction for these components so that we don't have to have this incredibly complicated thousand thousand lines long mains just to why all of these components are around we need to expose components which abstract over this sub components let's see an example in the image here the round thing means an implant interface which is a provided and these half moon means that we are expecting an infer interface and the different colors represent different kinds of interfaces so we can see that here there's a macro component which is component composed by smaller components which offers an interface and expects two other interfaces and inside there's a wiring of a bunch of different components which have different expectations different interfaces to implement this logic and from our point of view we don't know what's inside a a might also be recursively composed a smaller component and smaller components and this component hierarchy allows us to create higher abstractions for our components so that our software can be more complicated by reasoning about higher level components that interact with each other without having to know the details of everything all the way to the to the smaller implementation so how can we create these components well one thing is the factory we just saw how we can create a components which has a dependency on multiple other components and the other option though is also for example to use a struct and the reason for this is that a macro component you can kind of see it as a new constructor for these components so generally you don't need polymorphism this thing is done inside this component is creating inside the factory or in the main so it's fine to always return the same class so in that case we can use the same pattern as we saw before with the holder struct but instead of putting into sharep pointer and using the aliasing constructor we can just return the older struct directly you see that our making function takes the two dependencies that our macro component has and then returns just the holder which is instantiated with the two dependency and this is how we will be creating our older class you would have the private section with all the internal components for that specific uh for the specific macro component and then you would have a constructor which takes the interfaces that the macro component depends on and then it does all the wiring inside the here it does all the wiring inside the constructor and in the public section section it can have basically the component which exposes the interface the other alternative actually is to also have the a component is in this example be inside the private section and in the public part you would have just the interface reference which points to a so assuming that there was an i a interface you would here have i a reference which points to the a which is in the private section and this is again could be instant could be set up by the constructor for this to work it requires the return value optimization and copy a lesion but this is mandatory from c plus plus 17 anyway the advantage of this approach is that it can expose multiple interfaces and can again mix the lifetime automatic although as i said before if you want to manage everything to share pointers this also can work and the disadvantage is that it doesn't support polymorphism but generally we don't care for that thing but more importantly there's a physical dependency on the implementation details so whoever calls this function is going to have to include all the headers of the of the internal implementation which will not happen if you were returning the factory style with the abstract class this is a great option for testability as well because in the case for example everyone has probably sewn a class where there's a private methods which are actually made public because they are kinda isolated and they are complicated and people wanted to test that method specifically what this gives the option to do is to actually split out this part of the implementation detail into its own interface and implementation put into let's say a private namespace and then we can test this the private implementation independently and you can change your component to be basically a macro component of these indeed implementation detail and then your logic but from the point of view of the user this is not going to matter so the abstraction the component gives us a higher level components that can be composed and also give us a new facility to split out the implementation and aid testing so in conclusion we saw an overview of what the penis injection is how to define the interfaces for data and behavior how to pass the dependencies between components and how to defer decisions with the factory finally we also saw how to expose higher level components and what i want to say this these are all tools there are tools to manage complexity but you need to be aware of it because evolving code which takes parametrized dependencies it's easier but also it's more complex to understand you also need to be careful when applying this concept because you want to make sure that the complexity that you introduce they pay for itself and then i usually there's a trade-off between flexibility and understandability about the solutions that you take i hope that the concepts presented here were useful and they will help you apply them to your code base to make your code simpler to work with thank you foreign