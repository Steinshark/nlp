okay thank you jens for for your words and i'm happy to speak to you first of all you may wonder why i talk about const and constexpr the reason is quite simple with c plus plus 20 we have two only three additional words having const inside so we have to know what each const means const expert const in it constable const is used in constant expression you know there's a lot of consciousness inside c plus plus 20. have a look here cons conscious const expert constant constant and finally is constant evaluated so my first the first part of my talk is about i want to explain you this different consciousness system in the second part which is a little bit smaller i talk about the differences regarding function execution and regarding verbal utilization okay let me start with the more theoretical part and i will show you always or not always but almost always examples which you can use afterwards okay const this is boring you know it's a c plus plus 98 keyword and the reason is quite simple it prevents up const objects from getting mutated okay there's also some points correctness for it which describes this from a more formal perspective and const i want to say explicitly isn't quality attribute of your program so consciousness is a virtue const objects must be initialized of course we know it cannot be modified of course cannot be victims of data races this is a very very very important observations two requirements for dart races are mutation and sharing and when you are cons there is no rotation therefore there cannot be any data rays and const objects can only invoke cons member functions okay this was easy so this is exactly what i said when you declare member functions const you cannot change the state of the object inside such as while okay this is an error but here's the first thing a lot of people don't know we have two kinds of consciousness versatile constantness and logical constructs this is physical constantness kind of the object is const and cannot be changed okay we know it but there's also logical constants the object is const but could be changed this means declared members they can be changed in coins members functions as let me put it another way when you declare a member as mutable you can change it in member functions and we call this kind of behavior logical constants let me show you a classical example here's an example on compiler explorer and almost the same when i invoke this this crashes with clang i don't know why let me go to gcc if not i will switch to a different compiler let me it will not run anyway we have enough time let me go to the to well this is when box i don't know this morning it worked sometimes it didn't work here we are the same program but now we see that the output so what's the what's the program doing i have let me make it a bit bigger i have a main program having vector about g sweat g suite is the improved thread in c plus 20 and each g switch should execute this lambda here you see this is the kind of lambda i usually don't use because it has more than one line but in this case i do it so this number takes the counter by reference increments it displays it and increments it once more and because this is performed concurrently this operation on counters such as inc and get should be protected and exactly this is what's happening here you see get is protected and ink is protected protected by a log guard having a mutex inside and here's the key observation the mutex is mutable because it models logical constants but not physical constants you see it cannot be changed from outside it's kind of constitute sometimes set it sometimes release it therefore i declared it as as mutable so this is a classic example for it okay let me go back to my slides and i promise the next example will work on compile explorer okay a few additional words about concepts which are not so exciting but anyway by default past pointers and references to const you see const const okay this is easy what does it mean to pass something by const i had a few days ago a discussion with a few colleagues this means you don't pass ownership with point and references you only borrow it this is the semantic of a pointer or reference don't passing ownership only borrowing something means it could become a little pointer inside because it's changed outside in a cocoon environment because it could happen you are not an owner and additionally when you have a pointer you have to be sure that it's not not a knight pointer therefore you have to check it and here's a small exception of this rule when you pass it by non-const pointer or non-const reference this means this is a so-called in-out parameter this is a parameter which means it is changed inside okay now the last classical kind of slide and then we become more modern only to to make my point what does this mean we can we can apply constant different places in in the case of pointers what does it mean this means this is a c star points to a char points to a char that is const the pointy cannot be modified but the pointer can when you put const here this means cheese c star is a constant pointer to char and when you put const here and there this means c star is a const is a constant pointer to a char here i should start here sorry c star is a constant pointer to char this means nice the pointer not the point t can be modified and obviously this expression look terrible i use this simple rule read it from right to left without this rule i cannot read it maybe i'm not sure anyway okay this was the boring part but now it becomes a little bit more interesting in particular a quite interesting use case for example conscious allows it to remove or add const or volatile maybe a few of you don't know that you can also use the cons cast to add consciousness or volatileness okay and here comes my key point my boss in my previous company always said it's no issue you can remove the consciousness from a constituent object and modify it all compiler will do that and you know what this is a lie you will see it in a few minutes have a look modifying a constituent object by removing its contents is undefined behavior you betray your compiler to be sure you promised this is const and then you removed it it's not a good idea and the compiler will probably my compiler does it in a few seconds will how should i say it will not reflect this operation next rule don't use c cast such as this one because you don't know what's happening under the hood it starts as a steady cast if this does not work continues as a coins cast and at the end you apply read the precast but from the reading of this expression you have no idea and now let let me show you this how should i say exciting example let me make it a little bit bigger no i cannot do it this way i have to do it this way i hope this is big enough have a look here this is not interesting i'm only interested in the output here's what i have totally boring stuff now you can read here's what i have i have a non-constant int okay i create a pointer to it so far not thrilling then i use this pointer to change the value from 10 to 12 and when i output it you see 12 as i expected and here comes the undefined behavior show it to your boss or to my boss my previous boss i have a constant end with the value 10 i create a constant pointer to it you see now i cast away the constantness and i change the value from 10 to 12 and you know what the value is not 12 it's only 10 the compiler thought nothing can change here i will not do that or what else anyway you have undefined behavior and with a newer compiler you see such how should i say it disturbing behavior okay let me show you next example but you should not do here are a few variations of course you can do it and here's what you should not do i have a function taken in taking a constant now i have a constant with a constant i cannot invoke a function taking in pointer okay this is obvious i have to cast away the constant and then i can invoke it a function taking const pointer can be invoked with a with a const end pointer and a let me look in a non-cons in pointer this is brought up but it works and here's the undefined behavior i have a char initialized with a i create a char pointer to it and now i can cast it with a c cast to end and this is undefined behavior to make it sure now to write an a on the end pointer but in case of a starting task which i use here yeah wait a second in case of a static cast it works yeah could you please increase the font size okay sorry this is always default with please say to me how big it should be i think that's fine enough yes yes okay then i then i remember 70. okay thanks a lot for your mark but compile explorer has a bad default okay let me continue now i come to you see 98 98 11 20 20 20. so i come to c plus plus 11. the next constexpr we have our constant expo expression okay constant expo mean it can be evaluated at compile time i talk in particular only about a function this gives the compiler deep inside why because the compiler exactly knows what's what's happening and this is the most important part for me regarding const expert the most important part for me regarding constexpr is not performance it's code quality when you write a concurrent program and you initialize something with a const expert you have to guarantee that this is initialize the compile time this means there is no mutation at runtime this means there can not be any data race because nothing is changed such as here my double and there's a special rule which many people don't know when you initialize a const with a const expert you see here 5 is a constant expression this becomes implicitly a constant expert this you see is explicit but this is implicit according to export okay as i mentioned it both values my double my are initialized the compile time therefore threat safe and this is what i mentioned about this special rule and once more i don't can emphasize it much enough in concurrent program program as constant as possible when i have to analyze your concurrent program and i do it quite often you know what i do i look at each variable and i and i make a mark to it if this variable is not shared or is is constant because if one of this condition is fulfilled i know there cannot be enough any database issue but when your program only consists of shared state which is mutable you cannot reason about your current program this is way way way too heavy for our for our limited minds you know what i mean okay let me continue with const expert this is a constant function we have with c plus plus 14 and you see it looks quite convenient the rule to remember when you can make a function constexpr is quite simple each dependency must be resolvable at compile time and now then it can become const expert so the rules in 14 are quite easy but in 11 they're quite quite not ugly but quite complicated you can even have variables inside cons inside context for function but they must impli they must explicitly be or initialized with a constant expression the only thing you cannot do essentially is having static or thread local variables and here comes the key observation this function does not mean this function has to run or must run a compile time it means this function has the potential to run a compile time you can use this function at runtime when you invoke it with run time values so non-constant expressions it has to run at compile time when you use it in a constant expression and therefore we might sometimes don't know if the function runs at compile time or at run time in particular when you use it in an expression which does not enforce that it should run at compile time therefore you are you can only hope for your optimizer essentially okay here's a i will come back to this point in a few minutes here's an additional observation this functions are pure what does pure mean pure you know maybe from the from haskell pure function language you may also know it from from template meta programming because it's a pure function language embedded in the imperative language c plus plus pure means such a function produces always the same result when given the same arguments this means when you invoke it with 5 and 10 you always get back the same recite which in this case 5 this this how should i say it this property is called referential transparency a pure function has no side effect a pure function only works in itself you cannot see something which happens inside outside a pure function don't change the state of the program okay and what are the benefits i'm a big big fan of pure functions or constants but to say differently or const invite which will come later they are easy to test into reflector have a look you only have to invoke it once and then you know this function works do you ever try to to test random or time what is the expected value i don't know but with a pure function it's quite easy you can easily refactor this function why because no one outside will see what's happening inside but when you have a global here inside you cannot change it from five to ten some someone may be annoyed afterwards what is awesome benefit of pure function you can change the sequence of invocations of pure functions so you can reorder them why because a pure function returns today the same result such as tomorrow so it doesn't matter when you invoke it they can be automatically paralyzed have a look there is no shared state therefore you can automatically execute this functional separate thread there is no data sharing so therefore there is no reason to protect anything and here's a trick which is heavily used in in python but maybe not so known in c plus plus i say the python terms maybe you know them in titan we have a nice feature which is called a decorator what does a decorator do it adds additional function to existing function and and renames it gives us the old name so it decorates function with additional functionality and you know what this deck there's a decorator which is called memorization what does this decorator do it stores in a function such as this one a dictionary a dictionary is what we call another map and stores the old results of the function invocations and when you want to have a newer site just the old values are returned only when you ask for a new site the functions once more invoked and you store the result this is caching and to apply this kind of caching you need a pure function you don't want to store a a random invocation this would be a terrible cubicle okay a few additional remarks you can also apply constexpr to to your use define data type this means you can initialize my double at compile time when it has at least one context per constructor such as this one this function can be hybrid it can have constex but and non-contextual member functions but when you declare a const expo object of this class or initialize one to be more specific you can only invoke the const experimental functions of course and once more this is by definition sweat safe and now i have a small c plus plus 20 feature which may be mind blowing for you and this is the following one c plus plus 20 supports constant containers and constant exposure string sorry you have to be specific const export vector and constant expressed string what does it mean vector and string allocate their members on the heap this means the member memory allocation must happen at compile time there's a small restriction it has to be a so-called transient allocation so the allocation and the allocation has also to be done at compile time this is of course a restriction but this is a mind-blowing feature for me operating you running at compile time but this is not the end of the story the more than one hundred algorithms the classical ones of the standard template library are all declared now constexpr why can we do that quite easy when you declare a function as constructs for you this function has only the potential to run at compile time but you can even use it at one time now see my have a look at my example i cannot run this example because this example requires a windows compiler and i cannot execute oh i forgot to mention something i cannot execute windows on compile explorer i can only generate assembler code but you see it works believe me when you read my book it works have a look what i do i invoke max element and what is max element a const expo function and i want to have to reside at compile time i enforce it you know i say context but do it i compile time or the program should not work and now have a look i create a small vector one two three four i sorted at compile time all this done compile time this is constexpr and finally i return the last element which is the biggest one which is four this means this result is calculated at compile time and here for you in a different way i do it here with the lambda you see a lambda context for lambda the same stuff such as here and here i display the side once more i calculate the biggest value of invector at com python this is for me a mind-blowing feature and only to to show it to you because i mentioned a few times to make it more obvious let me show you an arbitrary algorithm of the standard template library ah why should i do that let me let me go for search and you see here we are since 20 since 20 all of them are declared as constexpr this is the difference between 20 before 20 and with 20. all of them honestly i will not show you all of them this would be too much for my presentation and too boring for you so let me continue and now i come to the additional c plus bus 20 feature const eval constable is quite similar to const explorer while generates an immediate function but there is one big difference between const expo and const eval a constant error function can only run at compile time you know we have usual function which can only run at runtime we have constable function which only can run at compile time and we have function constructor which can run at run or compile time and constable only at compile time constantly cannot apply to a destructor and it has the same requirements as a constextr function meaning what you can do inside have a look this is a constable function and i can take the result at compile the music construction because this is fine but when i invoke this function sqr with 100 which is not a constant expression this would fail so it can only be executed compiled additionally we have const in it it's constant it is from my perspective of course it's a 20 feature const in it is also kind of mind-blowing you will see in a few seconds consider guarantees that are variable with static storage duration is initialized at compile time and this is what is mind-blowing for me you initialize it at compile time but it is still mutable what are global what does what does static storage mean you have a global something outside of a function or the objects that get the static or extent they have static storage duration and therefore you can apply on them constantly and these objects are located at program start and allo they are located at its end okay and they solve a terrible feature we have in c plus for sources for the future this is a side effect of of how should i say it of a of a strange indeed sensation i don't know how to express it differently first of all you see this sounds not so good static initialization order fiasco what does it mean when you have one static in one translation unit which needs another static in another translation and they depend on each other one needs needs the other to be initialized or some way in this way you don't have to guarantee which one is initialized first we only have to guarantee that elements in one translation unit are initialized in the declaration or declaration of declaration order assume but we don't have to guarantee between translation units a classical example which many people love when they have it is you have a singleton which depends from another singleton and then therefore you don't know which one is initialized first and therefore with 50 probability you will get the wrong or the right behavior why statics are initialized in two steps at compile time there are zero initial life if they are not constant you see it compile them they are zero initialized and at one time they are dynamically initialized mr mr while you you gave them and therefore we have a dependency here or in concurrency i would say a race condition and constantly solves this issue have a look here first i want to show you this issue because this is really interesting and this was really easy to to show you this issue if a file you see it here dot cpp i have a square and you have a static a initialized and you see this is outside of of a function therefore it's static or global i initialized with the square of 5 which is 25 okay quite easy and here after main program it uses the static a from this other translation unit and what it does use it is to initialize b by the way a translation unit is what you get when the pre process after the preprocessor runs this is called a translation unit meaning after for example this header here is expanded okay anyway and here have a look now i compile both programs i compile both cpp files and then i link them in different order you see first main.o then source.o and then source.o and then main.o in this case static b has the value of zero in this case static b has the value 25 this does not mean this is like behavior expected this is of course undefined behavior you don't know it but this is what i get with the gcc and you see this is not too promising you should not do such stuff when the link order and [music] how should i say it has an influence of your instead of the values of your aesthetics therefore what can you do just use constitute have a look here const in it and that's that's all considered here constantly there and now you can do it in both cases this is clogged on windows in any case you get 25. okay now i was maybe too fast let me go back now it's time for questions is it possible to declare a stood string as const yeah i think this has been such a good borderline i don't i don't get you why shouldn't you why should it not be possible to play and stood string as yeah i think this has been solved with a good link we don't know like what the actual code is ah so now i know i have you because you really astonished me yeah that's there's a debate about the difference between const eval and const expression and what what problem constitutes solves now the constable solves no problem but you have to guarantee that this function can only run a compile time this constexpr when you use for example have let me show you something so i want to show them because this makes my point callable at runtime it's callable at runtime let me let me show you something which makes my point here when you use this function here constexpr here yes inside stood say out stood say out you say stood say out and then you want to display the recite of gcc of five and ten maybe and you know what stood out does not enforce constant evaluation therefore you don't have a guarantee if it's one it's compile time if or if it runs runtime i can only say to you by experience windows in this case most of the time runs at runtime and gc done most of time does it at compile time and constable exactly solves this issue when you declare this function as constitutive and you even use it in a non-constant expression it's executed at compile time i hope this was not abstract too abstract because i should have shown to you in a small compile expo example but this is the key difference you have to guarantee only compile time you can even use in a constant constant eval function in a constant eval function a constant expo function and this means now the const expo function has to run at compile time so for me const express hybrid you know run time or compile time sometimes it has to run the compile time sometimes it has to run at runtime sometimes we don't know okay i will maybe this was not so good this explanation or no it was a very good explanation but i want to say it from different perspective i will come to this differences here because these are exactly the differences why i made uh why i made these examples do you what's the mark yes yes there's another question about why constantness is not default in cpr 20 like it doesn't rust that's just not possible this would not work you have to discuss with biany and briyani would say very he would say something like we cannot break oil code yes this is just a simple observation let me let me add a few remarks we are not in python python and guido was small enough to make a breaking change from titan 2 to 53 but it took him only 10 years to make this transition from two to three perfect ten years and the second observation i want to make rust rust could not do the like let's get like c plus plus and be not constant by default rust couldn't do that either so once you decided that that is your language rule and you have an existing large code base it gets very hard to to you know set the defaults correct again and that's the general problem of cpus a lot of our defaults are in today's age are more seen than we should have picked something else but that's this is exactly my second remark i want to make nico yusutu said a very good sentence let me rephrase it c plus plus is the programming language in which we make each time the wrong default something like that maybe the sentence wasn't shown i don't know it but you know what it mean by default variables should be const but now it's too late 40 years too late yeah that's okay if you're totally right your observation is right it should be constant and once more constant is a virtue make your programs as constant as possible let me jump to the differences part and now i hope i make the differences clear between usual function constants per function constantly constant and what this all means because you know you see we have a lot of constants now inside c plus plus okay first of all i didn't mention it so far oh sorry i forgot my last point anyway sorry is constant evaluated afterwards i make the difference is constant error this is the example from cpr reference it's quite really interesting have a look this function is stickered as constructor this means this function could run at compile time but also could run at runtime and here's the code you see when it runs at compile time you execute the if branch when it runs at run time you have executed as branch and applies to power this is necessary because good power is not constant spot which is a pity you see this is kind of crazy stuff you can do in c plus plus 20. you can write a function which does different things at compile time and runtime different algorithm and maybe a different result but i don't know i don't know this expression too good to say it always returns the same such as here this is is constant evaluated this is for me mind-blowing because you have here part which cannot run at compile time and this is possible to be used in a constitutive function but but only when you use it in this kind of logic okay and now to the clearing part let me let me make the difference clearer about function execution and variable initialization function execution here i have three different functions and you see a usual function a constable function and a const expo function all functions do the same map n to n times n so quite boring and now have a look when i invoke the square runtime function with a constant expression i cannot have to reside at compile time this is not possible with a classical function but i can do it with a const eval function or with a const expo function and you see this function runtime compile time runtime or compile exactly the name stands for when it can when it could run and now do let me do it the other way when int sorry when x is not constant meaning each invocation here cannot run at compile time because one dependency x is not resolvable at compile time this means this function execution here constable throws an error i could show it to you here but i think this is not no added value here so let me just explain it here once more this cannot be executed because x is not a constant expression okay this was the difference between these three kinds of function now let me talk a little bit about variable initialization have a look i have constant const in it and here i have a usual variable and i add one to it and make it const and now let's let's see the difference first of all i have to make explicitly said this is a aesthetic called while and consider aesthetics because they are defined outside of main because coins in it cannot be used inside which you will see in a few seconds have a look when i want to increase res it's not possible because it's constant okay this is easy when i want to increase const x per mile it's not possible because it's const you see initialized a compile time and cons but here's the difference const in neutral is initialized a compile-time but not const this is the special feature of const in it you have to guarantee that it's initialized a compile time maybe to fix the static sensation order fiasco but it can be changed honestly when i look at it you have to read it carefully because there's const inside you have to read it not as const in it but it's constant so only stuff which is guaranteed is the the initialization that con compile time but it is not const and here's some additional point when i make this both guys locusts you see they have and yes they are on the stack they have their own scope i can use here my constexpr to initialize it this is to real but i cannot use here const in it now the question may be there's one hole in this feature hole in this area how can you initialize something at compile time which is local but can still be changed you see this is not local so you cannot use cones in it when you initialize it at compile time using const expert here then you cannot change it so the question is how can you initialize something a local scope at compile time but it is still mutable and here's the trick you declare a const eval function and you assign the value to a variable which is not constant and now you can this means this function or this initialization happens at compile time but afterwards you can change it this is the rabbit hole okay i was a little bit more afraid maybe i was not too fast but anyway i'm done with my stuff let me in a few seconds repeat what i said and then i'm open for questions and we see how it goes on i talked about the different frame levels of consciousness in c plus plus from beginning with 98 ending with 20. of course we know const it's a 98 feature we have constant correctness you should make by default or const you can cast away or add constant or whatever tightness to a variable constexpr is a c plus plus 11 keyword and this allows you to declare a function as constexpr which has the potential once more the potential to run compile time and but you cannot be sure if it run its compiler or it's at runtime to be sure you have to make it constant but this is now a c plus 20 feature and the last const keyword here is const in it const in it means you can initialize a static at compile time but this static is still mutable and is const evaluated is a typed rate and this allows you to ask if the function is about it or runs at compile time or runtime and depending on compile-time runtime you do can do different stuff inside the function and at the end i talked a little bit about this three kinds of functions we have we have usual functions they can only run at runtime we have constable function and 20 they can only run a compile time and we have constexpr function which could run at compile time or at runtime it depends on the circumstances meaning if you use when you use a context but in a constant expression it has to run and compile them when you use contextual with a non-const expert argument you can only execute it at runtime and then i talked about variable incisation and about this nice trick which i am happy to show once more this allows you to initialize something at compile time which is still mutable and it's local this is the key observation here okay thanks for listening are there any additional questions okay i see that there is no additional question that sorry yes you wanted to say something yes just giving the child a little bit of time yeah so i don't this far is i see all questions have been answered there's just a bit of chatting in the time yeah seems like everyone is happy and then folks will be able to join you in the lounge [music] but there is okay there someone points out that it's unfortunate that for const eval and constant expression it's implicit const or is there a deeper reason for that do you have an opinion on that no for me i know never thought about it for me it's kind of given first and second it looks for me natural and i was only astonished by const in it because there's const inside and it's not const this you see what i you see what i something strange is happening what is all happening once again you are seeing i see i say what i wanted to say but i cannot show it and this is the example with constant you have a const inside but it's it's not cons this is a little bit crazy for me you see only from the naming perspective there's one question about if we can expect to see compile time debuggers in the future this would be a nice feature but i don't know it but i have another idea but i don't know if this exactly works there was long long time ago a nice template debugger which is also com a compile time feature and i don't know what they could achieve and this was called oh this was created in in in hungary in budapest cpp shell or something like that meta shell meta something like that search phrase template debugging you can debug templates and go back in time so a template in sensation crash and you can debug it this is a crazy feature this is some feature built on the llbn runtime but i don't know i don't don't know anything about compile time debugging regarding const explorer honestly when you ask for such feature right people such as david van der waater in email i think he's the right guy he's also the he's also the the guy who implemented this const expert executed at compile time he was responsible as far as i know for the specification maybe it's also for implementation of this feature so he's a really really expert in this area i'm only a trainer linked to template which is obviously also a tool for this there's some some compile time traces etc and tools available okay i think we're gonna end the stream and then we're going to see you in the launch in a minute okay wait a few seconds and i will be there okay okay