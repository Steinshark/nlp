in this video we're going to be talking about abstract methods how to use them and what they are in python so to demonstrate this we're just going to create a class and first we need to import from abc the abc and that just stands for abstract base class and the abstract method so theoretically an abstract method is there just to act as a blueprint for our classes which means if we tell the current class or the parent class that we need to make sure that a phone can make a phone call creating an abstract class just creates that blueprint so that when we inherit from it we are forced to implement that or it will throw an error so i'm going to show you why we should use this and also the difference between using the not implemented error and using this abstract method because there is a crucial difference that will change how we code so to get started we have a class called phone and it's going to inherit from the abstract base class so abc and we're going to give it an initializer so init and it's going to take a model of type string and we can say self dot model is equal to the model a basic initializer so the class is the blueprint but we also want to have the blueprint of what the class can do and it sounds a bit confusing but i'll show you through the code we're about to type so here we're going to type in at abstract method and we're going to create a function that we want our phone or a method that we want our phone to perform so here we can type in dev call target and that target is going to take a name of type string so you can call your brother you can call some random stranger all you have to do is call this name but we do not have the functionality for that so by using this abstract method we can just add an ellipses inside here as per convention to say that this is a reserved function that we have to implement later on and the abstract method decorator can be used with other decorators such as if you have a property inside here you can use the abstract method as well directly under so here we're going to have a property called power so it's the power of the phone and it has to take self and here we're just going to add ellipses again so this is something we did not implement but we have to implement if we want to use this class and it's important that you use the abstract method decorator at the bottom you can use other decorators on top but this one must be at the bottom of all of them so now we have a phone and because we created it like this if we wanted to create a new phone and we just typed in phone for example and here we said the model is going to be i banana and we run this it's not going to allow us to even instantiate it because this class cannot be instantiated without having a subclass to actually implement these methods alternatively you can just delete both of these and say raise not implemented error on all of them of course you can do that and that will allow you to run the code but without having supplied the necessary code to get this up and running so this might not really be what you want because it doesn't stop your program from running it just says that if you try to call it it's going to raise this not implemented error so let's go back to what we had earlier the abstract methods because again when you run this it's not going to allow you to instantiate this class because you're going to have to create a subclass that actually uses these methods so we still have this that throws an error we can just comment that out for now so let's create a new class and it's going to and it's going to inherit from phone so here we can say class i banana which is my favorite kind of phone and we're going to inherit from phone as i mentioned earlier then we should give it the initializer so def in it and it's going to take the name or the model of type string and we also have to call the super so i'm just going to hover over in it and add the super class call so this is the very basic subclass boilerplate but one thing you'll notice immediately in pycharm is that you'll have these squiggly lines under our class and that might actually also be for the naming convention of ibanana because of course classes should start with an uppercase character but another hint you're going to get is that class i banana must implement all abstract methods and if we don't it's not going to work so if we have eye banana down here and we try to create eye banana and here we add the model of eye banana we're going to have the same error as when we try to instantiate phone so if we run this we're going to say can't instantiate abstract class i banana with abstract methods called target and power because we did not implement those so inside here we can just hover over this we can tap on more actions and we can say implement abstract methods and we're just going to highlight all of them and click on ok and it's going to add it inside our class all of the methods that we need to implement to actually instantiate this object and i don't like that it put this all the way down here so we're going to put it at the top so now we have everything inside here that's actually being used and if we try to create a banana this time the code is going to run because we included all of these methods in ibnana even if we just decided to use pass the programmer did his job and implemented the functions from the blueprint that we created up here but in reality this would be a good place to raise the not implemented error and say code missing for example and for power we can actually implement something and we can say return 50 percent battery remaining so now with ibnana we can print ibanana dot power and if we run that we'll get 50 battery remaining because we implemented that but if we type in ibanana dot call target and add the name of luigi it's going to give us the not implemented error because we did not implement that of course so that's a good place to use the not implemented error but as you could see using the abstract methods allowed us to ensure that whoever is working on this had to include these in the subclasses to actually create an instance of that object which just makes you a lot less prone to error and makes your code a lot more consistent because again if you decide to not include one of these even though you specified it to be an abstract method the program is not going to run it's going to say you're missing some crucial methods that belong to the phone and without that your phone shouldn't work whether it's ibnana or android or something else it should not run unless you implement all of the abstract methods but of course you can't just keep on adding abstract method forever or maybe you can if you want so at a certain point it might be a good idea to raise the not implemented error but otherwise if you're working with a class and you want to ensure that everything's being used correctly or that it's being implemented at least do go with the abstract method approach because it will save you and other programmers a lot of trouble when it comes to creating new classes with functionality it's always nice to have a blueprint in other words but anyways that's actually all i wanted to cover in today's lesson do let me know in the comment section down below whether you found this video useful or you have some other useful feature that you would like me to cover in a future video but otherwise with all that being said as always thanks for watching and i'll see you in the next video