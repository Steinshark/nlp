hello everyone my name is constantinos canorus and today we're going to talk about reflection in c++ and playing experimenting with reflection in c++ so in this talk just to give you an overview of the agenda we will start with the general idea of of what reflection is and some some information about its current status in the language then we will move on with a very common application of reflection which is serialization and deserialization so converting data and structures from memory into another binary for example representation and then we will combine those two concepts so reflection and serialization to create a new library that depends on those modern and and future concepts of of c++ basically and then we will move on with some some thoughts and conclusions now this this talk this is not this is not a reflection talk we will not go into detail about the history the ral the implementation details of reflection we will not discuss about how reflection works and and what kind of and all the things you can do with it because for this there are already a lot of talks that have been have been done and reflection is a topic that's been discussed for quite some time in in c++ now so if if you're interested in learning more about how you can use reflection and some of its more common applications you can watch one of these talks these are some of the more recent ones by the people who actually work on the on the drafts and the technical specifications for for reflection in this talk we will talk about we will talk more about experiment men in with reflection what you can can do as a developer right now with reflection what you can do in the near future and how you might take advantage of it to work on a on a very specific use case which is which is serialization so yeah what gives me the right to talk to you about these things i'm an electrical engineer by trade now i'm doing my phd in the university of luxembourg and i'm working on on very small satellites and with this with these very small spacecraft satellites it's always very interesting to to see new programming techniques that can basically reduce your development time without a big impact in in reliability and safety of your code so i'm technically not a c++ professional but i can go through i can get you through some of the experiences i had while trying to work with with reflection and some some libraries and serialization ations and thing that things that we need to do in our developments which are intended for space flight so without further ado let's get started so reflection is is a c++ feature that doesn't completely exist in the in the standard c++ yet and it's not implemented in in major compilers fully so there are a bunch of of drafts and proposals to implement it in c++ and for those of you who who don't know the term i will give you a definition from from one of the proposals that have been published for c++ and this proposal says that reflection is the process of obtaining metadata what is metadata metadata is data describing some other primary data let's let's let's look at an example in the context of c++ so i have a class here this class is called toast and it has some some values some data members and it also has a function and in the context of c++ i would describe the the primary data the values that that that we are interested in i will describe them as these numbers right here so the values of of the data members the values of the variables in this case and the metadata the data that describes this primary data is pretty much everything else so right now in c++ we have a bunch of ways to access this primary data a bunch of ways to to get the value from variables but it's not always so easy to get this metadata for example metadata here would be that this structure is is a class it has the name toast these are the the types of variables these are the names of variables these are the access modifiers and so on and right now in c++ for example it is easy to get the types of things so you can use deal type and get the type of any variable and play with it you can do conditionals and so on but some things like access modifiers argument lists of functions names of variables maybe it's not so easy and this is what we want to achieve with with reflection we want to get access as complete as possible to these kind of of metadata which are related to pretty much everything that's that that's not a value and we can have metad data for for classes for for types for variables for functions for name spaces modules and so on and this is for example something that you cannot do in c++ right now if you have a class or an object of this type toast a very simple example of of reflection of reflecting on on your types would be to have a function a standard library function called get member variables and this function would return an array of the variable names or variable attributes information of the of this object or of this class so you would call a function and get all of the data members of this of this object here the same way you would do this for variables you could also do for member function so here you would have a function that returns the maybe the public member functions of of an entity and in this case it could return like a standard structure member function and you would be able to get its name its return types its argument types a number of its arguments and you would be able to call it however you want and and this is the idea behind all the all the reflection standards that you want to to to access the the kind of type information type hierarchy and information about other entities in in c++ and you can you can take this concept to the extreme if you want so there are this is an idea we have this class and it has two functions coler and coli and coli print some information so it prints who am i where am i so which in which class have i been called in and by which function have i been called so kind of a back trace thing and maybe with some some an idea of reflection would be that this actually returns the name so i am in i am in coli and you see the function returns its name basically i'm in toast so it tells you in which class you are in and by which function you have been called so in this case coli has been called by color so you would get an output called by toast color and this is the general idea of of what you can do with with reflection and there are a bunch of of either generic or or n applications for it but a a very nice summary was given by andre alex andresco in one of the toxi i referenced earlier and it's it's this quote that we must look at increasing leverage more correct behaviors from fewer lines of code so reflection is basically one of those c++ features that that that promise you that they can reduce your code that you can reduce repetition that you can use reflection to get information about code you've already written and you know about don't repeat your self principle and stuff like that and and there is a bunch of of usefulness here and the thing i'd like to focus on is that we already have a bunch of libraries that would like to do something like this but take a lot of work arounds or do a lot of compiler trickery and having reflection would make some things that are now very complicated they would make them very easy and they might prevent reflection might prevent a lot of duplication especially when you're writing something that that needs to handle the structure of of a class or of an object now as as i said before in general for reflection for metadata in c++ we already have some mechanisms that can work with it and already at run time there's this keyword here the the type id so if you google how to do reflection in c++ you will see a bunch of results and this type id think it might be one of the first results and indeed type id can give you the name the name of a type so something that normally you wouldn't have access to in c++ so you have access to values you don't have access to names of types or or names of variables in your in your binary but with type id you can get you can get the name you can get the h you can get other information about about the type of your variables and we see here the output in in mangled format for for c++ however this thing is is quite limited and and one of the first of all it returns all the the names of types so it's not you cannot not do a lot of introspection on on types if you want to but also it's it's kind of runtime only if you try to use something like this at a conex environment you will probably not get very good results you will get the compiler error and it it also possibly requires rtti runtime type information which is is something that might cause an overhead that you may not want to have in your in your binary files and so this is this is a runtime mechanism it's it might be good for some use cases maybe you have some some type hierarchy that you want to to discriminate but it's it's very limited in terms of flexibility and functionality so if if you move forward in the in the story of c++ you see that with template meta program and with all the new features being added we have a bunch more reflection utilities and methods that that we can use for example we have conditionals on types and we have templates and we have sp and already you can start structuring your code based on how types are defined and this has given us a lot of power especially in what we can do with libraries we have already very generic libraries in c++ right now and then we have con straints and concepts and here we actually start going deeper into how our objects are defined and what they can do and here we can have something like duck typing for example but again all these all all all this implementations and and these standards they talk about conditionals and they talk about checking you still cannot extract for example the number of dat members of a type or the names as strings so the c++ community has been thinking on how to to expand this kind of reflection and how to how to make it even more powerful for some time now and there have been a bunch of proposals on different implementations for for reflection and here i'm going to show just some of the more recent ones but i have a couple of links if you want to look at the at the whole story on on how this thing has been going on and how it has been evolving over time and the first proposal that i'm mentioning here is scalable refection in c++ in published in 2019 and this proposal defines a couple of new keywords for c++ so reflexer and xer id and what reflexer does is basically it gets the reflection of a type and this reflection of a type contains the metadata of this type and as soon as you have this metadata then you can use a bunch of standard library functions that are defined by this proposal to work on this metadata of this type so for example here we have an enumeration and we're getting the reflection the metadata of this enumeration and we can get the members of this enumeration the names of the members of this enumeration the values of the members of this enumeration and so on so we have full access to the to the metadata and the primary data by using those those two keywords and in this example this this function here that i took from the draft this is a very standard example that you will see in a lot of these talks which is how to convert an eneration value to a string this is a very popular stack stock overflow question for c++ something that that people want to do a lot and something that would at least if you use it for diagnostic purposes would might help your development your development process by a lot so yeah what this function does is that it converts an en to a string and en num value to a string and the way it does that is that it's templated it gets the the eneration value and then it goes through all the me the members of the enum and if if one of the members matches the value that you have provided to this function at runtime it returns the name that's given by reflection so that was published in 2019 and there was another draft technical specification published in 2020 based on on this proposal and another one i think and this technical specification also i think made its way into an iso standard which is the c++ extensions for for reflection a few years later we got the second revision of the previous draft which is scalable reflection c++ and here we had a couple of changes more notably more notably a change in in symbolism so now we use this carrent operator and this format to- do reflection and some other changes as well and actually actually just a month ago there was this draft published so reflection for c++ 26 and this proposal is basically a subset of the previous one that's and with slight modifications that actually intended to go into c++ 26 so we'll see whether that will happen or not but there are interesting grs if you want to go into the rationale and the functionality of the proposed reflection mechanisms in c++ and by the way the technical specification the iso technical specification is also available in in c++ reference.com so u most of the most of the links have have articles and have documentation in them so you can get a a more general view of of what this technical specification contains so all of this was intended to give you a general idea of what reflection means and where it stands right now from a formal and c++ standards point of view however reflection is a very often requested feature and there have been a bunch of people of library developers that have tried to to work around the the limitations of c++ compilers and implement at least a subset of reflection on their own and a very good example to show you this is the the eneration to string question this very popular search query and and if you go through the answers to these questions you can find that they usually belong to one of those categories so the simplest way would be to store the strings in a in a kind of container so that the variable name and the string representation is separate so that's that's a similar way to do it you have to repeat the same thing two times but but it works then there is another implementation which is is that some libraries define functions or pre-processor macros that basically store the strings in a container on their own automatically so you don't use compiler features but you don't need to repeat yourself there are some other implementations that do code generation so there is an answer that contains a cake tool that reads your code and then generates another piece of code that contains the strings that you want and there are some some also clever workarounds that use newer c++ features and user defined lits and so on but the top answer that you get here is is a small library called magic inam c++ and what this magic inam library does is it promises you that you can convert an inam to a string without any extra code and without any extra boilet plate so if you have an eneration for example color red green blue values and you want to convert to string what the library tells you is that okay you can define your coral here so a variable eneration type and then you can call this function here so magic inam inam name color and then you automatically get back a string and this is just with just with this single line somehow you can convince the compiler to return to your the name of this of this type basically as a string and this is something that should not normally be possible with with a c++ i know and you can do the opposite thing so if you have a string you can also define your type and it converts it to an inam value an inam type and when i when i saw that this was possible in just a line i was i was very curious to see how it works and the answer is that it does some very nice compiler tickery and it depends on some compiler specific capabilities so in this case it's this magic identifier pretty function from gcc and there are similar things you can do on sank and msbc and what this magic identifier does is that it gives you the name of the function you are in it gives you the signal of the function you are in to be more specific so you could get inam name you could get the return value standard string and you would also get because this is a template function you would also get the template arguments so in this case you would get the exact value of the color and if you're passing in a numeration value you would get the name of this so if you called this function with the red value you get back this you would get get back this signature so standard string and num name and then the template arguments so c equals red and then you can do some very simple string parsing to get this red value and this only works at compile time so you need to have your value specified in a template but the library also does some some trickery when it puts up so it puts all the eneration values inside the map and then you can access everything at run time as well so so this this is how the this is how the magic inam library works and this is how it pretty much does some form of reflection but without using standard c++ and with by doing a lot of tricker behind the scen so there is a lot of of work and code that that needs that is needed to make this actually work and here i would also like to mention that for for many use cases reflection can be considered as a convenience feature it's not something necessary to have it's something that that makes our our development faster in some use cases and if you have a more complex program or some more mission critical piece of say safety critical piece of software maybe you do not want to tie the functionality of your software to the names of of your variables maybe you want to be sure that if you do a refactor and you change this blue to cion your end user will not see any change and this is something not something you you would use the magic num library for but for for many use cases especially if you're doing diagnostics if you're doing calization as we will see later reflection is a very powerful tool to have under your belt so this is one library this is magic inam let's see other reflection implementations there is boost describe so this works based on on on macros so you it defines some pre-processor macros and functions and you can so you have to define your objects and then you have to tell the library that okay these are my objects and these are data members and then again a lot of work behind the hood but you also get access to the names of the data members the sizes the types the counts of the data members and so on and this is completely reflection then there is another approach from from boost pfr which is a simpler more limited version of reflection based on template meta programming which also allows you to get the members of of a type so in this example we have we have a structure with three data members and and you can just simply print these fields and the number of these fields without any extra effort and this is also weird this is not something that should be very easily possible with standard c++ but it actually is and i was also very curious to see how how this can work and the answer is that this depends on on structural bindings in cl class so if you have a simple type maybe an aggregate you can use structured bindings and basically extract the values and the types out of out of your objects and here for example we have the structure and we do a structure binding with three variables then we can print everything quite normally and there is a a blog article you can read if you want more information about how to do this in in c++ 17 but you also need to do a lot of work behind the scenes to find out how many members you need maybe some ca is involved here as well but it is is something definitely possible and there are libraries that do this so yeah the advantages of this thing is that it works with pure plus+ 17 so no compiler specific features needed but it's limited in capabilities doesn't work with all types of objects and the hardest thing you cannot retrieve these names right here a b and c we can still not print them as strings so this is the approach of of the boost pfr library then we move on we have a couple of other libraries that do reflection in current c++ so there is rttr a runtime reflection library again same concept you need to tell the library about its metadata we have refle cpp similar concept here as well and then if you go deeper into reflection you will actually find that some compilers have implemented it as a as a separate feature from already from the compilation stat and if you go for example to to microsoft's c++ compiler you will find a couple of articles explaining that it has very specific functions that can do quite powerful reflection and for example here is the standard example of converting the inam value to a string there's a c compiler another experimental c++ compiler and it also defines some reflection features with its own custom synex but then there are also people that have implemented a reflection from the the drafts and proposals that i show to you before for example this is a popular implementation this is the an llvm fork by the the lock 3 company who specialize in in very new c++ features and they've actually implemented this standard with refle express with a few modifications and if you go on this repository and you check their wiki you will see that they have a bunch of information on how to use reflection and extra features they've added and so on and there is a talk by by andrew saton that explains these concepts so this is very nice to have it means that you can already kind of experiment with reflection on your own based on the standards i think this is also available on on compiler explorer if you don't want to to compile the compiler yourself so there is also another fork of of sank of llvm this one by matusik and this is an implementation of the the technical specification that's an iso standard i think and matusi has done a lot of work behind the scenes to to actually create a lot of examples and the mirror library that makes calling some some standard reflection functions a little bit easier so here you can see the standard in n to string implementation and he has also done a talk in in this conference last year about the the design of his of his api and his implementation and about of examples and use cases for it which i also highly recommend so this is how you can do reflection today now let's talk about serialization and deserialization or sometimes it's called marshalling and marshalling or packing unpacking there are many debates online about which term is suitable for which purpose i will just call it this realization and call it a day so what realiz ation means in in in the context of today is that we have some some data in our program in our memory we have some kind of of structure and we want to convert this data to either store it permanently or to move it somewhere else through a communications channel and then after this data is moved we can get back into our memory our software representation of this data through calization and distalization and there are a bunch of ways a bunch of reasons that you might want to do this for example you might want to store the data because you are a video game developer and you want to store the save files maybe you want to transmit the data or a structure or some information to another application running on the same computer or in a different device over a wired network over a wireless network maybe you just want to look at the serialized data for diagnostic purposes maybe you want to compare objects but it's mostly two categories storage and communication and depending on which field of software engineering you are working on you might be looking at reflection pretty much every day in your daily work so this is something that that's already been done this something that's something very popular let's see how people do it and what kind of of protocols what kind of ways of formats they use to to serialize data and there are a bunch of formats binary formats or plain text formats to do this so if you wanted to use a serialization library just for yourself so a naive implementation would be to just say the names of the variables and then the values so id7 temperature 32 and so on json a very popular format in web development you can define objects and ars in a more structured way and if you want a more efficient binary format there is a bon implementation of this thing if you want to be more flexible we have xml and then some specific serialization libraries from from other languages like python pickle they define their own formats or protuff protocol buffers by google they also define a format and this format has its advantage disadvantages and in some cases especially if you're doing communications radio frequency communications you might be inclined to design a custom protocol custom serialization format for your own specific use case so reflection is so popular that we have a bunch of libraries for it and it's its library makes different tradeoffs and has different use cases and disadvantages or advantage is but i think we can make a couple of important distinctions on how each of these libraries work first of all on the on the data format and on the on the calization format that you define for them so in some libraries like the protocol buffers the library tells you the format that it will store your data in so protocol buffers defines a biner specification it's a very good biner specification you can have versioning and so on but you locked into the specification you give it the structure and it tells you that this is the binary format in some other cases you might want to define the data format on your own you might want to say that okay i want this integer to take four bytes and be big indian i want this float to be stored as an i float i want this string to start with its length and not have an n termination character this is another use case then there's another distinction which is whether you're whether this library can only serialize and deserialize things at runtime or if it can run on a conex environment as well usually for this context we will probably not need to serialize stuff at compile time a lot but maybe it's a nice thing to have then a bunch of those libraries are not technically libraries they you give them a format and they generate the c++ code for you so they compile the data format and they generate c++ code for you but there are also other libraries that don't require this pr preliminary step and they just they just run entirely within c++ and entirely within the binary that that you generate and then a final distinction is that these some of these of these labr these programs have implementations from different for different languages so if you need to interface between different systems written by different people with different use cases you might want this kind of capability which is very very common to see in in serialization or there might be libraries that are built mainly for c++ let's look at a couple of examples so this is the google protocol buffers the way they work is that you define your structure in in a nice file so to. prot some boiler plate and then this is the the type that you want to convey so 32bit integer id float temperature string review and here you assign some some ids to those types and then as soon as you have this specification you run a terminal command and it gives you a bunch of autogenerated c++ code that you can just include in your project and compile things immediately serialize things imm immediately and everything is type checked and everyone is happy so this is the the compilation approach let's look at the runs within c++ approach also used by by a lot of serialization libraries and this is a common approach that you have a structure with his data members and then again you need to tell the library that okay these are my my metadata these are my data members you know about them now serialize them as you know and this is a very a very common way to do this kind of thing so this was for the serial library another example for the bit library again similar concept you define a function that tells the data members the metadata to the library but here i want to show this example because you you specify the the binary types by handun by yourself and and there are some use cases where you might want to have this kind of more fine control over how your data is serialized this is another example from not a c++ library from a from a python library called construct and i found i found this interesting because this follows a slightly different approach so you have your object to be serialized with all the data but then you have another object which defines the the structure and here you don't have the the api of the of the library does not give you a function it tells you to create a new object and then with this object you can compile your primary data and you get back a similar result so this is a fully user defined data format that you can work with and finally there is this sista library and this one allows you to serialize at just one line without giving it any metadata so let's look through this example we have a structure we define it we give it some values we define an object with some values we use a weird kind of string here and then we call just this one line so a buffer equals the result of cista serialize just on line no extra boiler plate and it actually gives us back the the serialized string so these are some some binary non-displayable characters without any other information and the way that this library works it's is something we saw before so it's a similar thing to to boost to boost pfr we have structured bindings and this library does a little bit of of reflection behind the scenes this means that it can serialize your structs but it's kind of limited to to some aggregates and maybe not very flexible and again based on your use case you might be very happy with something as convenient as this or you might be not happy at all finally let's let's look at serialization in practice and this is an example from from a small satellite project and what the satellite needs to do is it needs to serialize telemetry to send back to earth and deserialize telecommands that it receives from the earth and the ground station on the planet needs to do pretty much the same thing and if you look at the code that we wrote for this satellite you can see that we have a little bit of repetition so in this case in a function that that passses that passes the telemetry we might have an event definition id that's the result of a read eneration function and another variable it's a result of a read function from from a string or a buffer then if we want to generate this if we want to to serialize and not deserialize we do the same thing but the opposite way so we append instead of reading but then the ground station we're using a different kind of software which requires those arguments to be given in xml format so we have a different entirely different specification and all of this is based on some external paper documentation and this is already four times that we're seeing the same thing repeated and it's also not easily searchable you cannot do crlf on on this code you cannot the the event definition i this this variable names are used pretty much everywhere in that code base so you need to know as a developer or a reviewer that okay i need to i i need to change this on all parts of my code or have very well structured tests for this so ideally what what i would like is to just have one central piece of one central point of documentation and based on this generate have the compiler generate code have a library generate code or or structures or convenience functions around it and maybe it would be an interesting idea if even you don't write c++ code but you give this kind of xml definition to your c++ library it reads this xml definition at compile time and it becomes able to generate some structures for you and parts and generate the the binary format of of those things completely on its own as a c++ library with everything done at compile time modern c++ conext optimized and so on so today we will try to move forward towards that direction we will not reach the the xml reading goal but we'll still try to see if we can make a library that conforms to some of the specifications so i here define that format compile time that runs entirely within c++ with minimal repetition and a couple of other nice nice to have features as well so let's go ahead and create yet another serialization library now i've been working on experimenting with with reflection and creating a library like this it's called okay serializer you know developers are not very good with names this library is meant not to be used for production or not to be meant as something something serious is just meant as an experiment and as as a as a tool to see how we can improve maybe already the existing serialization libraries out there as soon as we add reflections and c++ 23 to the mix so it's not it's not supposed to be a good serializer it's supposed to be an okayish serializer hence the name and let's let's start with going through the thought thought through the thought process of working with a library like this and first of all we want to use very bleeding ed c++ and we want to use reflection we want to see what what reflection can do so we saw that there are a bunch of implementations of of reflection at compiler level already and when i started working on this the most recent one was by matus h so this is the one that that i started using with a couple of updates i think this was written for sank 15 but i want to use more contemporary s features so i did a small merge with c length 17 so we have our compiler let's talk about the structure of this library let's talk about maybe the the requirements of this library so pretty much what i showed you before almost everything should be possible at compile time another requirement is that ideally this would be used in embedded systems so system with a low footprint so there is a requirement for no exceptions there are a lot of discussions on whether exceptions are okay or not for embedded systems i will not go into this i just avoid all the debate by saying no exceptions instead we will use this new standard expected type also no dynamic memory allocation so using standard liary containers is not necessary using new and malo is something we will not be doing in this library again to support low footprint embedded systems and no fancy compiler features no specific things that are not standard c++ or experimental c++ the end goal for today will be to write a single line and serialize an object into into aj format and this is what we will do but the the long-term goal for this experiment is pretty much what i show you before so we want to take an xml definition and serialize it completely at compile time now this is not something entirely new this is not something novel similar concepts have been done before for example you can find on geub on the mirror repository by matus hli that he has a couple of examples of serialization and deserialization with json and reflection and there was another serialization library based on compiler time reflection that was presented in cbp conon actually last year but here i thought this would be an interesting experiment to go you through the thought process of developing a library like this of experimenting a little bit more and seeing if we can actually get those more specific requirements to work for us so let's get started the first thing that i would like to do for this library is to actually test reflection to get our compiler installed and and see if it's working and that's what i did so we have a a test file here on cion and what i've done in this file is i want to do the classic inam value to string example so i use some code by by matus click this is a slightly complicated way to do the the n to string implementation with with reflection it uses recursive functions maybe you can do it faster but this is this is good enough for our purposes and it uses completely standard technical specification c++ so let's make an enumeration and i can do an inam color and maybe i have mo canan and orange orange and then what i can do is just do standard output and inam to string the template should be deducted so color move i'm getting a compiler error but it's it's printing everything correctly and yeah you can already see that cion does not really like reflection but it it actually works now the question here is we can do this at run time can we do this at compile time so let's try with static static asser and let's see if in am string color move is equal to orange and this comparison should should work and okay we see that the static assertion failed so we have the negative test case let's do the positive test case and we see that everything compiled so we know that the static assert is is working well enough so we we have reflection working this is good we can experiment do a lot of other things with with reflection now let's let's go into making our serialization library and the the kind of api that i would like to we have with this is looks something like this so we have a serialized method the serialized method explicitly takes the the the binary format the serialization format that we want and then we get we pass our output as a reference and the value that we want to serialize so this this design decision here this is intentional because if you're working in in in wireless communication for example you want to be very specific about the kind of format the data sizes that you're using and so on so here i'm making it very specific but if you want it is very possible to deduct the the serializer that you want to use from the types that you are passing here i'm also using a buffer uh as an output so i'm saying that okay this is a dynamic kind of of how dynamically expanding output that's connected to a standard string and if i run this then the string will equal to high and we can do the serialization in a similar way so der serialize here i also specify that i want little nns for for my for my input and i give a string as an input and i get back my value as as an integer now this is a bit heavy to do because you need to specify your buffers if your use case is standard strings and we will focus on standard strings for the rest of this talk you can just call serialize to string and you get back a standard string or deserialize and you can just directly pass a standard string inside now at this point for this library i would like to focus on this a little bit on on on on these inputs and outputs and and how this is done and i'm sorry if this is not perfect c++ code maybe there is a lot of room for improvement but it should give you the general idea and there are also a bunch of u implementation details hidden in the hidden in the source code but let let's see the general idea for for for inputs for inputting binary data to deserialize and in this case for for i have a generic input class that takes as argument an input rate so a+ plus 20 input range which is by default a string which means that you don't really need to mess with iterators anymore you can just pass a standard string or or an array or weird ao buffer maybe inside here and everything should be passed correctly and we can do a similar thing for the output so we can define a a range type of output for the serialization library that works based on an output range and the output range gives us some very fancy stuff that we can do with with iterators that avoid having to handle a lot of a lot of edge cases and this is what we want to do here when we are adding basically a character into our output and again here you can pass standard string you can pass string views you can pass c style strings you can pass buffers and so on so this how we do input and output and i will spend a little bit of time on the binary types that we support so we have unsigned integers in our binary format we define how many bytes they are up to eight bytes indian s big indian little indian signed integers variable sized integ this is google protuff think as well a convenience type for enumeration values floating point values string representations prefixed by the the length of the string or c style strings that have a terminator which is used to the null character and we also have a bunch of compound types actually which means that in the same serialization command we can serialize many different types one after the other or we can serialize an an array and let's actually look at one example of this right now so let's go to here and i will remove everything and we can let's say define a standard array of un 16 and let's say it has 68 elements for for no particular reason and we call it r and let's fill this array so r begin r oops r end let's fill it with 68 69 in hexadecimal format and let's also do a standard output so okay sir serialize and our serializer is length prefix vector and the length p fix vector contains elements that are unsigned integers of a width of two bytes and then we should be able to pass our array just like that sd andle and i forgot to serialize this into a string so i'm using the convenience function right here the compiler is happy let's look at the output and we get back our length prefixed vector so we get back a bunch of highs prefixed by the length in binary representation so in this case it's the capital letter d which represents the decimal number 68 and this is how this thing work it should be able to work at uh compile time at compile time as well and you can work with this library we can already do some very simp calization a very small implementation details iterating for the for the bundle type which can have different serializers in sequence we use duple template arguments parameter pack template arguments sorry and it takes a little bit of effort to iterate over them at at compile time but it's it's it's possible with parameter pack expansion now another smaller side of for return value types we're using standard expected not exceptions and we define a custom a custom alliance in the library for a result so everything you get for de calization gives you back gives you back a result and this result might be the type that you actually want so the digitalized type or it might be an error and there are some very nice monadic convenience functions in c++ 23 for working with with sd expected that make it quite fun to play with if i'm honest and then for serialization for the the reference type of functions we are using an empty result so we either return our or we return an error so similar to kind of returning an error code and if you look at the at what this parse error is it's a structure that contains basically an error type and the error type is an error code and maybe in the future we can add some extra information in there if we want finally there are some some unit tests for this library and if you're making a serialization library it's it's always fun to to see what we call in theimportance so you want what you serialize to be the same as what you deserialize so if you get anything through the process of serialization and deserialization you have the same thing in the beginning and the same thing in the end and the the cat two testing library gives you a lot of facilities to to be able to kind of do that okay so now we have a calization laborate this is nothing really new okay a couple of c++ 23 features used but it's serialization it's fun but it's not something terribly exciting let's add a little bit of reflection to the mix and let's do the very simple thing that we want to serialize structs so we want to serialize the dat data members of a trct more specifically and for this i'm using again the mirror library by by matus which depends on reflex and i'm defining a function serial i struct it takes an object and an output and we have we here we have the reflection of our struct so we call mirror and mirror produces the reflected type and as soon as we have this reflected type we can get some we can call some functions from the mirror library on it and we can get all the data members in the truct we can go we can loop through all these data members and we can get the value serialize this value and get back the result and then you see that my code is not perfect i forgot a couple of sd forward things in here anyway just a little a little point of attention so in the previous examples we had to define the serializer by hand so we saw that here we had define that okay this is the length prefix vector and it contains unsigned integers of sign of of size two in a str we don't really have this we need the the library to kind of guess the the binary format that it want to use and for this we define a configuration object and this configuration objects contain a templated default serializers member which specifies that okay if it's a un 8 it will get assigned to an okay s assigned integer of size one and so on and okay let's let's let's see an example of this actually i think i can get it to work so let's define a structure so struct structure and let's say it contains assigned integer a and let's say a is equal to 104 and an unsigned intezer b that's equal to 26913 and now i should be able to just call okay sir serialize struct i have a convenience function serialize struct to string and oops let me instantiate an object first okay no compiler errors that's a good sign let's run it and we can see that the output is actually high so if you go and put those on a hex editor you will see that these values serialized with a big indian format they should give back high with an exclamation mark in the end so this is this is one way to do it and you can see i also have this this example here we define the structure just one line and we get back our our serialized information now here the library does the specification for us so it knows that this is one bite it knows that this is two bytes maybe this is something that you might not want maybe you want to be very explicit in what kind of type you want to use and what kind of format and sizes and maybe alignments paddings and so and so on so the idea one idea would be that you can change this configuration object that we pass it compile time or maybe an extension to this library would be that here in your structure you have some pairs so a pair of a pair of value type and serializer type and the library kind of sees these pairs and generates everything accordingly but long story short we have reflection working we have serialization working but this is not something completely new already we see with structured bindings we can do this in in c++ 17 however this time the implementation was was very simple it was just a couple of lines in in a small function but in any case let's let's see if we can extend this further let's see if we can reach our our json end result so we can write a json implementation by by hand we will see why that that is in specific and we can add the standard json times a boolean number strings aray object and we can try and and serialize stuff with it and already you can see that celon is complaining in the object structure because inside the object thruster we do we do a little bit of a little bit of reflection so let's see if we can make this work so remember we had our structure and i think i have i can do serialize to string and i can pass a json object and this is our serializer and then i can pass my structure compiler doesn't complain let's execute this and it works and we can already see that with this single line we get back ad representation and the the difficult thing here is that we got these values right here we got the the variable the the member names and this is something that you probably cannot do in c++ right now and this is kind of the the power that reflection gives you and if we want we can get this a little bit further so i can make an an array of you know ins just five members and this is one 2 3 4 minus 8 and let's give the name to this array i can add maybe a sub structure so let's define one right now and they can say float bals 13.6 and they can give it a name and now if i compile it everything should work and yeah i get back all my all my json and nested things as well nice ar i could do strings if i want to do as well so everything works now the question is can we do this at compile time and the answer is probably yes so let's do a static assert and let's actually get this thing here and compare it with actually i need to write this as a string and so we getting an error i need to convert this to a coner and am i missing something probably not and everything works everything compiled celon is still complaining but we saw that this this assertion works and this serialization basically can completely happen at compile time as well and this is kind of the power that that modern c++ can actually give you and as a smaller side if this is something you want to do for if this something you want to do for diagnostics to to look to read that your your objects you can define an o stream operator and just do this so for this example i've just defined the no stream operator for pretty much every object that's not a string and you can see that with this little bit of magic you can just output structures as if it was python so this this is the the kind of power that you can get with reflection and this is just a simple example with the current implementations with a with a very quick work on on on library and right now it's a very rudimentary implementation of json it's it's a manual implementation in order to to get this to make it work with with con texture and it's just the serializer working but you can you can further you can further expand this of course and this brings me to the end of my talk so we saw the ok cizer library it has a couple of interesting features we were able able to comply with the requirements we set earlier and it's quite useful for embedded systems as well so we can work with strictly no dynamic memory allocation and with strictly standard expected no exceptions as well so the embedded people will be happy but there's still a long way to go if you want to get this into a kind of mainstream serialization or martiall link library and there are some also interesting concepts that you can play with if you if you're thinking about the future of how this could work in c++ or what serializer label like this could do ideally for example java php they have comments annotations that the code can actually read and influence its behavior based on that so for for for the library itself how does it its future look like maybe we will get it in in one of the space projects where i'm working and the end goal for all of those things is to have this kind of single source of truth whether it be code or an xml file or or anything else that allows us to define our our telemetry and telecommands and do everything all those things parts in generation and so on around it and and this is an example of how you could do this for example in in python using the the construct library and then you can start thinking about other more complicated things and experiments you could do so those the interpreted languages have this called evaluation you can evaluate new code at run time could we do something like this in c++ for comp for compile time like you pass the name of a variable or a data member as a string and you you get back what you want it's it's slightly possible with the current proposals for for reflection right now maybe it would be interesting to see this expands there are safety arguments on on on this as well but it's interesting food for thought and the the final thoughts that i have is that implementations for reflection exist whether they are for the c++ that your employer allows you to use or the c++ that you can get if you compile llvm on your own or if you use a docker instance to do your own experiments that i will that i will put up in in the library repository so yeah you have the capability to to work and and play with these things there is a a bunch of of references online most of the implementations that are online are for the older slightly older versions of the of the proposals and drafts so not updated with a new operator format and any other changes but we have now this this new this new proposal which is active there are revisions actively being link done on it you can check the the github for the for the proposal and it also adds instead of just reflection it also adds a little bit of of meta programming inside there so there is a way to actually define new structures and uni formats inside so this is a synthetic struct defined by this by this technical proposal yes so that brings me to the end of my talk thank you very much for your time these are my contact details and i hope you enjoy the rest of meeting c++ thank you very much