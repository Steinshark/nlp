today we are doing a code review for a piece of code that one of my viewers submitted oh god why the viewer submitted a program that they wrote called random character generator it's basically a program that you give it a number and a character set and it'll generate a random string for you you can think kind of like a password generator today we're going to be grading this code on four primary categories so functional meaning does the code actually function is the code understandable meaning when i read the code can i easily interpret what the code does does it have good comments does it have good function names and variable names is the code maintainable meaning that if this code were given to somebody else could they keep it alive is there a lot of technical debt in the code and then finally is the code expandable is there an obvious api via a header file or something else that allows me to add features to this code or is it just messy spaghetti code so let's get into the first part and see is the code function now when i get a piece of code i'm looking at basic things like the structure of the repo to give me an idea of code smell if they actually organize their code into multiple files and they put that inside of a directory and it has a make file i'm already getting a good good feeling that this may be a well-structured project when you're writing code in c you want all of your different items that have a purpose to have their own c file so the functionality is obviously separated so someone else reading the code can generally guess what's going to happen in these files but before we actually look at those files i want to see will this code compile the viewer did a really good job of specifying in the readme how to actually go about compiling this so you have the pseudo apt install lib n curses dev and then you get to just go ahead and make the program via make install project is good so far and again we get no errors we get no warnings i put w all which is another good indicator that they maybe tested their code as well so they create all of the output files by either c files and then they compile that together to create rcg so from a building standpoint i didn't have to do anything special to build it it just built on its own awesome let's go ahead and run it and see if it actually behaves as intended so enter the length desired let's generate an eight character string let's see select the option specified below generate lower upper and numbers okay cool so i got lower and upper do i get a number okay cool i got lower upper and numbers so i can recreate it again interesting so i don't think the r functionality is working in this programs i'll take that as a note repeat only works once question mark and we'll ask them about that later other than that it seems pretty good so if i do i want to do 10 characters that are only symbols and i'm getting only symbols here so okay from a functionality standpoint minus the the multiple repeats so the multiple recreates it seems like it's pretty functional so i'm going to grade this 8 out of 10. seems good to me it does function so let's actually get into the code review now and figure out is this code understandable because someone else who has to look at this code know what it does i didn't get a huge sense of confidence from the code understandability if it's understandable based off of this the the the the naming of the functions array size array type array cases array output it kind of tells me what's going to happen based off of me running the program but if i hadn't ran the program and i had to read this i wouldn't really know what's going on also there's not a lot of comments here so i'm losing hope on the the understandability piece let's check this out so let's figure out where array size is declared probably in array array size here we go take a look at this code here i'm not seeing a ton of comments that's my only complaint so far other than the naming so what you want to do here is typically like function array size pointer which is a you know a pointer to the array object the reason i want to do these formats is it gives the reader a very obvious indication of what they can expect from the code they wouldn't have to go line by line and figure out what the function does they can just read this here and get an idea of what this function's api is right what the input is supposed to be what the output is supposed to be if you don't have this there are two problems one i now have to go through every single line and figure out what's going on here and also without these headers like this writing documentation for this code is pretty hard right if you format your comments in the right format there are programs like the oxygen for example that will automatically create docs for you just based off of comments now a lot of comments are happening inside the code either like i want to have a comment here that says you know what is the case i'm handling for here if the user supplies zero or something like that and again you may be able to infer this comment from the code itself but just something to think about we print w value unknown and we do this while pointer length is less than one okay so they're making sure that we get out of this function with the array pointer set to greater than one which is a decent way to do it so we go what we do array size and then array type array type so this is us querying the input from the user for the size and then we did the same thing for the type right so we read in a half word pointer type and i know i'm clicking with vim just don't just just ignore me i'm trying to get this code review done array type select the option specified below to generate an ascending order yeah okay so it just takes the type from the user as a number so this depends very heavily on the user putting the number in the right order right so it says specify it in ascending order and then if i put for example if i wanted to have a lower and a numbers but i put 3 1 it likely wouldn't work and we're going to figure out how that works here in a second okay so we go through that we do type and in cases yeah oh god okay so this piece of code is where i start to have a little bit of issues right so the problem here is that there are a lot of magic numbers so for for a couple a couple of reasons i don't like this and i'll explain why the first reason is as a reader of this code i don't really know what any of these cases are for and i'm aware that they come from array.c i'm aware now after reading the code and using it a lot that it has to do with the one two three or maybe one and three and they use that to switch what type of pointer we have and then use that to create our array the problem with this is that if i were to change the specification or the api where i want to change how the type variable is handled if i want to change what type number the array needs to function doing it like this with these magic numbers makes it very hard to update this code and then also too more magic numbers right so this 26 is 52 i don't know what they're doing here i think i know from some backhand knowledge like about what this program does this is probably the lower and upper range of like some ascii characters right but again this makes it very difficult to add functionality because if for whatever reason we had to change these numbers the rest of the code would not be correct yeah so another issue with the understandability piece too is i wouldn't be so glued to this array uppercase notation like in your naming i would do like a rage and random character pointer this whole this whole array uppercase word thing it doesn't do a lot for me in describing like what actually is going on with the code let's keep going so we call array creation which i'm assuming is in creation.c and then array creation has right exactly it's you have your range which is the inputs subtracted from each other and that's probably selecting the ascii range of the values you're allowed to select from so we generate an array that is equal to the range minus plus one yeah okay so they're generating a range of characters that you can choose from and then putting that into a array that we can select from and then we use that to actually randomly get a character yeah okay this makes sense so we use array creation to create our selectable array and then from there we do erase size and the right output so that's probably the final function in here all right output yeah so we do oh wait no array output is last array cases all right creation interesting all right random array sort from an understandable perspective you need to use more comments just comment your code please comments and then also stop using magic numbers i'll give this a 6 out of ten you do a decent job of naming your functions and your types but there's just no comments in this code and there's no documentation on the functions and then also the the use of magic numbers is pretty bad so that's just that's the major issue i have with the understandable i know there's one piece they wanted me to comment on they wanted me to see if their source of randomness their s rand was secure so the srand pointer size and they say that pointer size equals ts tv insect times pulling your count minus pointer count why yeah man i think you were better off as doing this if you want to make your your thing random just do ts.tv and sec right because now what's happening is regardless of whatever this math turns into you're seeding your randomness off of the nanosecond time which i think is the right answer because you can't predict the nanosecond time of the processor right whereas if you like for example s rand time right like this is i know if i could figure out what time you made the string i know what the string is but then also there's an issue where like if you're doing any math on the nanosecond time you're adding additional information to that number that is predictable by the user right like if i know how long your string is i can predict a like i could i know information about your seed and can possibly reverse the the randomness so you want to always keep this s rand to a number that's as random as possible so if you can get entropy off of the cpu via w random if you can read the nanosecond time of the processor if you can create the jiffy to the kernel all that good stuff i would say use that so you were almost on the money there i would just say keep it simple and use the nsac time maintainable yeah i mean so i think based off of the number of magic numbers that i saw me adding additional features to this i would know how to do it like i could do it in this function i could add maybe a case you know where i say case two or you know one two three five or maybe five is an additional feature that i added but the magic numbers make it very hard to keep this like a smooth code base what i would want to do instead of this is instead of treating each input as a character and then using that as like an integer you could do create an enum type def enum type t and we'll do lower is one and we'll say type upper is lifted by two right and then so you take this put in your header file and then in the array.c you convert this number here the number that they give you to your type t right so let's say like type t user input and then you you figure you write a function that parses this input into this and then from there all you have to do is check all of the flags in this thing and then add it to your your range right so just a way of making it so that instead of having like case one you would say pointer type and type lower right and then so now what's happening is i'm writing code that isn't using magic numbers if i want to change the type lower to do something else i could just change the number here i create one single location for the type to be defined as opposed to here where if for some reason the number 26 in your code changes it cascades down to the rest of your code it makes this very hard and again if and if there were multiple source files that depend on this code like you are just up a creek because you have to go through and find all of them and change them and figure out which ones depend on each other it's just a huge pain in the ass i would go to a place where you're either converting your numbers into an enum or you're converting your numbers into a define right so define type lower five so maintainable same thing six out of ten use less magic numbers create enums to represent values and then expandable right so this is again is the code in a place where i can take the api that it exposes and add something to it so let's go look at the the array c or the array.h include or h and figure out is there a way that i can add something to this right so again they use comments here which is really really cool maybe i should have read this before reading the rest of the code i would prefer though that the documentation for the functions was done in the actual declaration though this is more that's more likely to be a place where someone's going to audit as opposed to the the dot h file but this is a pretty good job so i'll actually add one point to the understandable there are comments just not where i expected them yeah awesome okay so based on this i would find i could probably add functionality to this pretty clearly they'd have a pretty robust structure and the functionality that tells me what you know each function does so i can go back through and figure out how to add my own function to this i would say this code is expandable so what do we got we got eight six seven eight so it's 27 27 and 40 not bad that's not bad at all 40 out of 40 is perfect code and 0 out of 40 isn't code so 27 or 40 is not bad at all i would say my mage issues were functionality that repeat didn't really work that well it wasn't understandable we need more comments in your code was it maintainable kind of but again the magic numbers up here made it very hard to maintain this code base and it's expandable i think you did a pretty good job defining your api so that's my first code review if you guys like that do me a favor and go watch this other code review that i did it's over there somewhere and yeah we'll see you guys in the next one