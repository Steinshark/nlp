hey software engineering is about thinking not typing i can already feel myself triggered af right now okay i i'm like i'm i'm i am seething i'm coping i am doing all the things at once right now because i can feel that i'm going to hate this talk i'm going to hate it i'm going to hate it and i'm going to rant so dang hard but here's what i'm going to do to respect to respect what they say i'm going to not interrupt them and try to read this straight through okay we're gonna let tim cook weeks of coding can save you hours of planning cassic software engineering best prati best practices emphasize and value the importance of iterative work they encourage working in ways that give us opportunities to make decisions frequently and adapt to changing circumstances these principles are nearly ubiquitous and seem necessary for un for su successful engineering efforts at large scales but the concept is sometimes taken to an extreme that can be unhelpful while it's almost always good idea to maintain the ability to iterate quickly and to change our minds that doesn't mean that one shouldn't take time before they begin to act fair we will be doing that in when we build harpoon live on stream we will be doing that when confronted with the problem rather than jumping directly to thoughts of how can i fix this with code it's often more effective to first carefully consider the universe of potential solutions by the time code begins flowing into an editor there should be a good idea of an overall plan what is it that is actually being built towards what concepts are being programming are we programming oh my goodness what concepts are being programming against uh should new foundational concepts be introduced to this region of code to facilitate the implementation which pre-existing concepts will have been modified without answers to these questions and others like it is very easy to end up with just coding by accident waiting through unforeseen problems after problem will event until eventually solution emerges that seems to work well enough but most likely it isn't implemented as a way it or as well as it could have been yeah but there's so many things in here already that he's not mentioning like how much time is spent building and doing things in which is needed to to just simply understand what the problem is like how much of the time do i spend just writing code that i'm throwing away just to like test out ideas right so you know it is a thing the more experienced an engineer is the stranger this may sound to them after all their job is to write code how can thinking be more valuable than actually doing one of the best explanations can be found in a py quote for which i'm unable to find the source weeks of coding can save you hours of planning the point is that it doesn't really matter how quickly someone is able to write code if they're writing code for the wrong reasons one of the worst possible outcomes for software engineering is to spend days or weeks working on a solution only to learn they've been building the the wrong thing for the entire the entire time of course this usually isn't solely the fault of one engineer alone and agile methodology should help identify problems like this earlier in the process but the fact remains that there's almost always more than each of us can be doing as individuals to make sure that we're do that we're solving the right problems the best oh my goodness sorry the fact remains that there is almost always more than than each of us can be doing as individuals to make sure that we're solving the right problems in the best way available to us i think i see i think okay i either i can't write either i can't read or there's something goofy about the sentence but i totally get that i totally get what what they're saying is that there's there's definitely a time trade-off here which is do you fix the immediate do you fix the longterm and there's also a midterm that exists right there is totally a midterm that exists that's really really good hold on one second i have a work ping i always have this problem which is how much time do you spend solving a problem right because there's the obvious way that you solve a problem like just patching or doing the the thing that needs to just fix this right here then there's like the second question which is how did we get here how do we take that and make it a little bit better right and then the third way which is like what is the core problem here how did this end up being such a problem what part can we change way up here that would never allow this thing to exist in the first place and those are very very different time time constraints and so like you can't always do what is the greatest possible solution to all things and you also can't always just do patch the ship let's just make it to shore right at some point you kind of have to do this undulation between them all and so there's there's something very interesting between all this well i let's see the idea let's see can also be difficult to implement in practice for many reasons if the problem is completely novel attempting to write some code can be a good way to better understand the problem space absolutely i'm always in for this writing code is for many engineers a lot more fun and approachable than sitting around and thinking about problems in the abstract i think i feel about the same they feel about the same to me like a good whiteboarding session okay shut up i know that was a window sound shut up everyone shut up and don't mention it but like a good whiteboarding session to figure out something is so dang much fun okay i stream from windows shut up okay windows is just the superior video and audio platform even beats mac okay i hate it it just is what it is okay shut up there's a lot of uncertainty involved in abstract thought lithium not the 20 gifted subs while i'm reading okay i'm trying to read here just hold on there's a lot of uncertainty involved in abstract thought this nature how does one know if they're thinking about the right things spending too much time thinking and planning ahead of time can be just as bad as not spending enough how does one stop thinking and start doing you get into analysis paralysis pretty easily one approach that i like to use personally is to identify what i think of as the core concepts of the that underly the problem at hand most problems can be decomposed into constituent ideas that are more or less independent from one another this should sound familiar to most engineers as this is very similar to the important software design concepts of coupling and cohesion while decoupling is a mostly technical process identification of these core concepts is a theoretical one the goal is to search for the ideas that exist within the problem itself so that it can build our technical boundaries along the conceptual boundaries that exist within the core of the problem at hand more specifically the best outcome is when the identified concepts are loosely coupled yet highly cohesive i'm not going to lie to you i did not understand a single thing that was stated in there i i honestly just don't get what what they're trying to drive home here it sounds like big words and i'm slightly confused certainly the text you provided discussing a strategy for problem solving particularly within the context of engineering and software design let me break down the main ideas for you core concepts and problem solving when confronted with the problem the author suggest identifying the core concepts or main ideas that the foundation of the problem it's like breaking down a big complicated issue into smaller manageable chunks deep composition most problems can be broken down into individual parts or ideas that stand on their own this is similarly looking at a big machine and breaking it down into its separate components coupling and cohesion in software design coupling refers to the degree of dependencies between different parts like modules or classes and software loose or low coupling is a desirable because it means each part operates independent of the others making the system more modular and easier to manage damn look at how much of an explanation we got out of this look at how much we're getting monads are straight burritos dude monad burrito okay i i that dude history his history is interesting shut up as a practical example considering the command line application that can generate dev containers specifications for users by combining tools together declaratively rather than forcing them to write the configuration files by hand writing dev containers specifications and their corresponding docker files can be a bit of a pain because of the unexpected interaction between the running container and the user's development environment for example the container's time zone should be synchronized with that of the user the uid of the user in the container should match the uid of the external user and the ssh pass through authentication should just work but these are not features that dev containers provide for the user okay yeah these are all complications and annoyances the idea is that the tool should be able to take a simplified configuration file that allows the user to say i want to use rust get vim and oil shell hey i always knew i like this this this one you know i could just tell right away you know i just just a big fan here click a button and get fully instrumented and repeatable development environment i think they call it nx yeah consider challenging yourself to put some thought into this problem what are the core concepts that you can identify that might make sense to construct this tool around once you've done once you're done expand the section below to see what i've identified are your concepts different from mine no we're not even going to wait for it let's see it let's see what you got repository the highest level construct supported by tooling usually verion controlled source repository you can hold one or more projects project a desired development experience assoiated with a subset of repository it has a single configuration at any point in time configuration a point in time instance of a project each configuration generates a single unique dev container spec and associated docker image host the host environment from which the tools being executed used as source information that must be injected into a configuration environment and actively running instance of the configuration usually managed by the editor here comes i'm going to get hit with the window sound any moment the source code editor that will be used in the dev container an individual piece of functionality that can be composed with other tools to provide deployment and deployment environment i normally don't see i normally don't even i don't even break things into these type of concepts maybe i do this automatically but this just seems like a bunch of busy work to me you know i'm just throwing it out there that this feels like a lot of things like do you really need to break stuff in your head at this level you know what i mean it just feels it it feels like this is a lot a lot of things to do what you did i mean for me it's like i i'd rather i'd rather poke around and think of the problems i'm going to face as opposed to the concepts there it is that i'm going to have to deal with right it's more like okay how do we pass through you know like i like to identify each one of the like the things that i will get stuck on you know what i mean someone made falor for typescript in grpc oh gosh why' they do that while this is is a simplified list it should be clear that these concepts associated with the problem itself rather than individual technical decisions nothing in the list above prescribes how the tool will deal with any of those concepts only that they exist and should be considered during de development that's part of why it's important to think before writing code we want to avoid anchoring our thought process to what we have done in the past i just don't think this type is for me probably more technical questions then arise from the considerations should repositories be restricted to containing only a single project how might that affect users monor repos is it possible that running environments will drift from the current configuration if the environment is left running after the configuration is modified does this matter the configuration is likely to have to understand the different editors supported by the tool how should this be accomplished how should the tool deal with different host platforms how can tools compose with one another when when generating a final specification from here the ability to begin itative development usually as usual against these concepts emerges yeah see i i i take such a different i honestly tak such a different approach to this so so very different that it's like it's virtually unfair in the sense that i would build out an mvp right the thing that it takes to accomplish this for one way to do the project and then i take that those learnings and try to say okay what are the points where things are going to change and kind of catch me off guard how can i prepare for each one of those type of items and then i try to do the best to abstract each one of the pieces that may be like okay you want to not use gith hub okay i need to not just like do a github url i need to just do a basic git url okay i need to do this what is an mvp minimum viable product right like could you build this to do a simple thing then how do you make it more and more complex does that make sense from here the ability to begin iterative development as usual against these concepts emerges see i i just completely find the opposite to be true i prefer the mvp into this phase then into because like some of these questions could be completely irrelevant you know what i mean it's so it's like you're asking questions before you even truly understand the problem space and it might not be worth it at all yeah he's he's describing a kind of more of a waterfall process i kind of go from bottom up as opposed to top down it's worth mentioning that explicitly that i'm advocating for designing by committee waterfall development architectural astronauts let's see it's worth let's see that i'm not advocating for designed by committee waterfall development architectural astronauts or any other anti- patterns that frustrate engineers who really want to just get things done waterfall can actually be very useful in some senses thinking before typing is an individual activity something that every engineer can ensure that they are doing and to potentially improve the final results of the work they create writing some code to understand the problem space may be a great idea for example but if you're doing if you're going to get started right away you may do well to remind yourself to consider throwing that experimental code away and think about the problem before you stray too deeply down any single path i also agree with that write it once little experiment throw it away move on honestly such a good way to understand the problem space especially if a problem discovery is the purpose of the prototype the possibility of falling into the xy problem is ever present i don't know what the xy problem is xy problem is asking about your attempted solution rather than your actual problem this leads to enormous amounts of wasted time and energy both on the parts of people asking for help and on the parts of those providing help user wants to do x user doesn't know how to do x but thinks that they can fumble their way through a solution if they get if they can just manage to do why user doesn't know how to do why either user asks for help with why others try to help user with y but are confused because y seems like a strange problem they want to solve now this is this is actually a great the x problem this is a great way this is a great way to describe this this is great i been i have definitely xy i've definitely xwide myself especially if problems if a problem discovery is the purpose of prototype yeah dude i've done that a lot of times in my life a lot of times it's it's i mean it's good to understand i actually think that this was that little xy thing was a great way to describe that i love that oh man i am just like so happy right now reading that this article was worth it for that single reference to the xy problem if there's one thing you can take away from this entire thing the xy problem learn how to make sure that you include x as why you're asking for y you know what i mean another aspect of this idea that i find very useful is that it can be used to help explain some of the difficulties involved in software engineering to less technical individuals especially stakeholders and executives measuring measurement of engineering teams for examples hot topic lately off the tr tales of success of the dora metrics and the relatively recent release of the space framework and then the unfortunate mckenzie system yes that was unfortunate we did read it and it was crazy they're trying to measure everything that has drawn some misgivings from their experienced engineering leaders space in particular does a good job of acknowledging that there is much more to engineering than code than an engineer produces well it can be difficult for many to understand the details of development process it's part of the job of engineering leader to advocate for their teams and help stakeholders understand where time is being spent and why things take as long as they do focusing on the important planning design and thinking can help leaders explain these concepts in terms that anyone should be able to understand regardless of technical acumen yeah i mean i feel like we're kind of leaving the point of this original like talk like i was very excited about i wanted to hear more i i really was hoping to hear more about like some good defense of of some reasons and how they do it i feel like the reasons were way too high the example given was way too abstracted the emphasis on on exploratory problem solving versus actual problem solving isn't really delved into like i feel like all the things that i'd want to hear really argued about haven't been talked about except for the xy problem which is absolute f fantastic absolutely fantastic it's like that's what i really want to hear about is i want to hear more about like how do we reason about when and what is too much planning and when have you hit analysis paralysis in which we haven't even talked about that at all it just mentions it as a issue not pre-read i don't pre-read okay pre-reading ruins the fun because most of software engineering is inherently creative endeavor it's difficult to distill the daily activities of an engineer down to the type of cleanly measurable metrics that many executives partic particularly those with less familiarity with engineer in process would like to see the glue engineer for example may be critical to overall function of their team but any attempts to measure that individual's impact by focusing on their issue completion or commit history is bound to fail in the general case this is why experienced engineering leaders try to focus on measuring outcomes over outputs this is fair prime can barely read in the first place and you think he pread yeah what the what do you think i got hours of time in the day this article yeah there's too much filler content that i don't think was very good and this whole like leaders part it doesn't sell on why i should do it what it's selling me is that leader these these so-called leaders should learn better how to manage software instead of trying to make it like brick and mortar like that's all i'm really taking from this honestly engineering is equally there is plenty plenty of typing that has to be done here's a good example let's go like this let's go to github bun all right we're going to jump on here we're going to look at this for a quick second and we're going to go to the contributors and we're going to look at this over the last year jared has committed 2.6 million lines of code now i know there was a lot of thinking that went into this okay there was a lot of time spent doing things but the reality is if you look at this there was also a lot of time spent typing just a lot okay if you could type one code a second or one line of code a second jared has added 22 or 27 straight days of one line of code per second in the last year so is code about typing or is is engineering about typing yes is engineering about thinking yes is it fair to say to say either or no it's not it's not right you cannot making the these one-dimensional claims is silly like there's a problem i recently had to solve where i had to jump on a whiteboard and like draw it out and i had to sit there and i had to think for like 30 minutes that totally happens but a huge percentage of problems that you're going to end up solving doesn't require that right they're not complex tree operations they're not complex data structures and algorithms they're just simply making out a component if you've done if you've built enough components of any kind if you built enough software modules of any kind you naturally just fall into this idea of like okay i need to abstract at these points i need not to abstract at these points and that is that it's like that simple and so it's just like an experience factor where it's not real so i i i don't know these kind of ar articles really bother me just because i don't feel like they address the core problem which is exploratory versus planning and second this is just so good i feel like i want to do an article purely on this we're going to talk about this at some point okay this is so good jar jared who pushed node modules feels oh dude that's the way to do it that feels good man feels so good hey the name is did you did you hit the subscribe and like button a jen