hi everyone in this episode we're going to be looking at rigid bodies so rigid bodies are objects that are controlled by the physics engine meaning that we can apply forces to them and they'll react accordingly colliding with other objects in the scene if we want to move an object but don't care about collisions we can just move it with transform. translate inside of the update method as we've been doing up until now as you know the update method gets called just before the scene is drawn to the screen so the first update occurs at time zero and then perhaps 15 milliseconds later the update method is called once again it moves the object to its new position and the next frame is drawn now imagine for whatever reason that the frame rate drops and the next frame is drawn 65 milliseconds later the object obviously needs to move a lot further between frames 2 and three than between frames 1 and two since more time has passed as we've talked about before this is why we always multiply our objects velocity by delta time the time between frames now there's another update method called fixed update which we almost always use when we're working with rigid bodies unlike update fixed update doesn't care when the scene is drawn instead it's called at a fixed interval the default being every 20 milliseconds so we'd have our first fixed update call at time zero then 20 milliseconds later it would be called again note that the object's new position will not have been drawn onto the screen yet because fixed update was called after the last frame was drawn so fixed update continues to be called p every 20 milliseconds and the object's position is updated inside of the physics engine finally at the 80 millisecond mark the object's position is drawn onto the screen now all of these extra fixed update calls might seem like a waste of processing power since the player obviously only sees the result when the frames are actually drawn however when dealing with physics these extra calculations are necessary if there's a wall we want to collide with for example but the frame rate drops we still need to calculate all the in between steps so that the object object doesn't simply pass right through it if the object is moving very fast of course it's still possible that it won't collide with the wall even in fixed update to rectify this we could simply increase the rate at which fixed update is called making it say every 5 milliseconds instead of every 20 obviously this would come with a huge cost in processing power though so in later episodes we'll discuss techniques for dealing with very fast moving objects such as bullets but for the vast majority of cases our fixed update every 20 mill seconds will handle collisions just fine let's have a look at how we do all of this stuff inside unity so to start with i'd like to create a player object that i can move around the scene and just have collide with obstacles so let's create a cube object and i'll just rename this to player and then if we go onto the component menu we can go physics and add a rigid body component so that the object is now physics enabled you can see if we press play the object will fall fall down because gravity is being applied so let's create a plane object to act as a sort of floor and we can just move the player above that and let's maybe just scale this out to 10x 10 so if we press play now the the player will come to rest on the ground plane let's create a c script called player and i'm just going to attach that to the player object and then open it up all right so to start with we're going to want to get a reference to the attached rigid body component so up at the top here let's create a rigid body variable just call this something like my rigid body and then we can set that inside of the start method by saying my rigid body is equal to and then we'll make use of the get component method now the get component method is what is known as a generic method and i'll talk more about these in a later video but the syntax diff like l from calling a regular method we start off with a pair of angle brackets and then as per usual we end off with the pair of parentheses and a semicolon so inside of the angle brackets we need to specify a type and in this case we're trying to get a component of type rigid body so we simply write rigid body between the angle brackets so now we'll be moving the rigid body around in the fixed update method but we still want to get our input inside of the update method so let's create a vector 3 and call this input is equal to a new vector 3 so for the x-axis let's get input. get axis raw horizontal zero for the y axis and then for the zed axis input.getaxis raw vertical all right and then we can create a vector 3 direction will be equal to input. normalized and then we can figure out our velocity from that it will be the direction multiplied by some speed value so let's create a speed variable up at the top here and maybe make that public so we can edit it in the inspector public float speed i'll set it equal to six so now we can say vector 3 velocity is equal to direction multiplied by speed all right let's go ahead and create our fixed update method so just like update fixed update is called automatically by monob behavior so we don't need to worry about calling this method ourselves so inside of here we're going to want to be able to access the velocity variable so instead of declaring it inside of the update method i'm actually going to declare it up at the top here vector 3 velocity so now when we want to move our rigid body around we can simply say my rigid body do position plus equals so we'll add to it the velocity multiplied by time dot fixed delta time which is just the time between fixed update calls now as i mentioned earlier fixed update is called at a constant rate so time. fix delta time won't change unless we change it ourselves if we want more or less frequent physics updates or if we modify the game's time scale for cool slow motion effects it's worth mentioning that we can also just write time. delta time it's smart enough to realize that it's being called from inside of the fixed update method and it will return the correct fixed delta time value for us all right so let's save this and go into unity and quickly going to create a new q object to act as an obstacle and we can maybe just spare a moment to create two materials just so we can see what's what call this the player duplicate that call this obstacle make the obstacle a sort of reddish color and the player can just be a dark gray just assign those quickly and then from the top here i'll just duplicate this obstacle a few times and maybe just scale it out i'll rotate this one all right just get a very simple scene set up and then let's enter play mode so we can move the player robot with the arrow keys and if we walk into one of these obstacles you can see that we don't just move right through it thanks to the rigid body and the physics engine we might not want this sort of rotation to happen when we're colliding with things so what we could do is go into the rigid body here open up the constraint settings and just say freeze rotation on all axes you can see now if we collide with something we will no longer rotate let's say that we want to create some coins to scatter around the world that the player must go and pick up now we wouldn't want these coins to physically obstruct the player in the same way that the obstacles do but we would still want to use the physics engine to tell us if the player is touching a coin so that he can pick it up so to see how we do this i'm just going to create a new cube object and i'll just make this nice and small like a coin and let's make a new material call that coin make it a nice shiny yellow color just apply that there it's a little bit hard to see against this white background so i'll maybe make a ground material as well make that dark gray and then change the player to a white all right so on this coin object let me just name that here i'm going to specify that the box collider is a trigger and this will tell the physics engine that the player should ignore collisions from this collider so you can see if we walk around we will just pass straight through it now even though the collision is being ignored it is still being registered by the physics engine and we can ask to be notified of it inside of our script so if we go into the player class we can create a void method called ont trigger enter which takes in a collider variable which i like to call the trigger collider make sure that you spell trig enter correctly with the right capitalization as well otherwise it won't be called automatically so inside of here let's just do a little print out we can print out the name of the object we've collided with by saying trigger collider and we can get the game object that that collider is attached to by saying do game object and then we can get the name of that game object all right so let's try that press play and should see that as soon as we walk through this coin coin gets printed out into the console now just to point out a few things about the ont trigger enter method in order for it to work the script that it is in of course needs to be attached to one of the two objects that is actually doing the colliding so in this case it would be either the coin object or the player object secondly since it is specifically on trigger enter one of the colliders does need to be marked as a trigger so in this case the player collider is not a trigger since we want it to collide with the obstacles but the coin object is a trigger so it works finally at least one of the colliding objects has to have a rigid body attached otherwise the physics engine is just going to ignore it so in this case obviously our player object has a rigid body attached so everything's working fine but in some cases you'll find that you want to be notified of trigger collisions but you don't necessarily want all of the physics that comes bundled with the rigid body component so what you do then is you add the rigid body to the object anyway since you have to for the trigger to work but then you just check the is kinematic checkbox and that will basically disable all of the physics of the rigid body as you can see here if i press play the the object isn't falling down due to gravity and i can just waft through these obstacles whoever moving through the coin the coin collision is still registered now in a typical game of course there won't only be coins there'll be many other objects that make use of triggers as well so inside of our ont trigger enter method we're going to need a way to tell what sort of object we've just collided with so to do this we usually make use of tags and you can see there are a bunch of predefined tags here you can also add tags so let's add a new tag called coin and then if i go onto the coin object can just choose the coin tag we've created from this dropdown and now i'm just going to create a bunch of coins scattered throughout the level and then if we go into the player script let's just delete this print out and we can say if trigger collider do tag is equal to coin then we know we've collided with the coin object and we'll want to destroy that object from the scene to show that we've picked it up so we can use the destroy method and we'll pass in trigger collider and we want to destroy the whole object we get the game object that the collider is attached to and then say we have a variable up here can just call it our coin count then we can just increment our coin count variable by one each time that we touch a coin so let's save that and press play and let's now walk around and collect our coins all right so that's everything for this episode hope you enjoyed thanks to everyone who supports these videos on patreon and i'll see you in the next episode cheers