i'm going to talk about the issue of scalability in bitcoin but before that i will provide some background on bitcoins and then we'll slowly build it up to the point where we can see the issues in bitcoin scalability and what is? being done in current blockchain designs to address these issues in scalability the key metrics that, we are looking at here are the throughput of the system that is what is the maximum rate at which transactions can be handled by the system in terms of writing them to the blockchain and then the other metric is that of latency that is from the point when a client submits a transaction to the system? how long does it take until it's written to the blockchain i think some history, would be nice so bitcoin appeared on the scene in 2008 on an online meaning mailing list by a pseudonymous author called satoshi nakamoto whose origin is unknown and then the next year in 2009 there was a software release of bitcoin and it generated a lot of interest since its inception because it went on to become one of the biggest digital currencies of our times so just today a one bitcoin is worth about $6,000 yet on the other end of the spectrum there are people who have said that blockchain is the biggest bubble of our times the aspect of bitcoin that really gives it its wings is the blockchain which is at the heart of bitcoin now a lot of people have started to become interested in block chains because these can be applied to other scenarios which are beyond its immediate application to digital currencies we did a video with tom scott about online voting and the blockchain was not mentioned at all but lots of the comments of people who watch that video say? why can't we do voting with a blockchain is this one of the applications you're talking about yes exactly if you look at the blockchain one of the key properties of the blockchain that distinguishes it from regular traditional databases is that of public verifiability and public verifiability is enabled by two other properties called integrity and transparency now by, transparency, we mean that anyone can verify how the state of data has been updated and by integrity we mean that anybody can be sure that the data that they are retrieving is not corrupt and it is correct.  i can imagine that it would be a feats an engineer a system for 60 million people living in the uk but never mind how, many people are living in china or india or some of the other nations that have got, many, many more people. is that the sort of scalability, we're going to be talking about well this is the kind of scalability that, we are going to talk about but let's not forget that systems like google or facebook also deal with may, be much greater magnitude of users but the advantage that these systems have, over systems like blockchain is that they are centralized systems that are under the control of a single entity or a consortium of entities while in a blockchain the network is between a fully decentralized set of nodes so what does a blockchain really look like well you can think of a blockchain as a linked list of hash pointers so a hash pointer is simply a hash of some data and now we are going to look at a linked list of hash pointers so in the beginning we need to start from somewhere so we have? sort of a dummy or a padding, data called genesis block and we take the hash of this first block? which is included in the header of the next piece of data so there is a hash pointer which points to the previous piece of data and new data then the next block and it's called st-1 then imagine that you have another piece of data and this is the simplest form of lock chain so as you can see this is a linked list of hash pointers now the hash point ourselves two purposes the first purpose is that it uniquely identifies the previous block of data so a hash pointers identifies the data and the hash pointers due to the properties of hashing functions also confirms that the data has not, been corrupted you can think of it as a temporal evident log and anybody can independently take hash of this data match it with the hash included in the next piece of data compare these two and if these two match then they can, be sure that the data has not been corrupted there are two kinds of operations that can be performed on a blockchain one is a read operation and one is a write operation now as you might have guessed read operations are easy because they, simply, involves retrieving, some data of the blockchain however write operations are more challenging because they can potentially hurt the properties of transparency and intake integrity that we expect from the blockchain so a blockchain has two basic functional components one is to validate transactions and the other is to write to the blockchain we are first going to talk about validation of transactions what is the transaction? you can think of a transaction is an operation that changes the state of data that lives on the blockchain okay, so let's look at a very simple example in the context of bitcoin so a transaction might look something like say ten bitcoins to bob and this transaction has been generated by alice now alice has two things to prove to the blockchain network alice first has to prove that she owns these ten bitcoins so she is able to pay them to bob which means that as input she, also has to provide the id of the block in which alice became the owner of these ten bitcoins say it was zero zero seven and the other thing that alice has to prove is that it's actually alice who is generating this transaction and not somebody else who is pretending to be to be alice for this purpose she takes advantage of a cryptographic primitive called digital signature so she basically signs this whole thing with her private key she then submits this transaction to the network any node that receives this transaction if it wants to validate this transaction it has to perform two checks first to check that alice actually received ten bitcoins at some point in the history of the blockchain so if you remember the structure of the blockchain, was something like this and there is this head of this blockchain? so it will traverse the blockchain and at some point it will reach the block where ellis came into the ownership of these ten bitcoins say it was this one? so the first check has been passed the other check that it has to do is to traverse back in the blockchain and confirm that alice actually possesses these ten bitcoins and that up until now alice has not tried to pay these ten bitcoins to anybody else because then that would be considered a double spend because imagine if alice has already paid out these ten bitcoins to charlie then she's not the current, owner of these ten bitcoins even though she, was at. some point in the past so that's another thing that the node has to confirm that from the point when these ten bitcoins came into the ownership of alice she did not at any point transfer them to anybody else if the transaction passes both these checks then the next step is to write it to the blockchain now this would be straightforward in a centralized system where there are all trusted nodes and they'll just simply perform the right operation? however this is significantly more complex in a fully, decentralized network like that in the blockchain because all the untrusted or semi trusted nodes have to reach an agreement among themselves whether they are going to write this piece of data or transaction to the blockchain or not this is where the issue of consensus comes into picture consensus simply means to reach agreement about a value among multiple nodes within a network now in the case of bitcoin this consensus is done by getting all the nodes to solve a hash puzzle or provide some proof of work this is also called mining and for this reason potential bitcoin leaders are also called miners a miner can, also be thought a successful miner can, also be thought of as a leader because when the miner has successfully solved the puzzle? it can write to the blockchain then there are two main issues in bitcoin? however note that even though i mentioned these issues in the context of bitcoin these are shared by all blockchain systems that work, along the same principles as bitcoin the first issue is that of folks now bitcoin is decentralized system and it's a peer-to-peer network where different nodes communicate transactions and other information to each other using a gossip protocol now the network has its own limitations for example propagation delays or the transactions could simply get lost on its way or a node could be simply bad this could mean that the nodes in the network could potentially have different views of the system what might happen is that a minor builds on top of this block while another minor who has not yet heard about this block builds on top of some other block the blockchain has effectively been forked and some nodes will continue to extend this part of the blockchain while others would continue to mine on top or extend this part of the blockchain this is really bad for the blockchain and it defies the fundamental philosophy of the blockchain which wants to provide a consistent view of the world to its users so all systems need to have some mechanism to resolve such conflicts in the case of bitcoin there is this implicit rule that nodes who find themselves in a fork situation should follow the longest fork you mentioned before what i heard as a gossip protocol is that yes what's a gossip protocol a gossip protocol is most naive kind of protocol where for example if there are five people in the room and they want to communicate some information to each other then i'll tell that information to as many people i know in the room and all these people will also communicate the same information to everybody else in the room so everybody is talking to everybody else the other issue in bitcoin is that of performance now there are two key metrics that are used to assess the performance of such systems, one is that of throughput and yes the other is that of latency by throughput, we mean that what is the maximum rate at which the system can write transactions to the blockchain and by latency we mean that after the point at which a node hears about a new transaction how long does it take to actually write it to the blockchain now in bitcoin the throughput of the system is basically a function of two properties of the system - block size and the other is the inter block interval what is a block we've been talking about transactions so far a block is simply an extension of that idea? you package a number of transactions into a block so what gets written to the blockchain is not a single transaction but rather a block of transactions the size of this block in bitcoin is currently capped at one megabytes the inter block interval sort of relates to a difficulty of the hashing puzzle because that has to do with how fast miners can solve the puzzle currently this is set at about 10 minutes and the idea is that the inter plock interval should be large enough that majority of the nodes in the network have heard about a new block that has been added to the blockchain before another block is added to it to avoid folks with the current block size of 1 megabytes and an inter block interval of 10 minutes the throughput of bitcoin is at is capped at about 7 transactions per second and a client that submits a, transaction to bitcoin it has generally on average to wait about six more blocks are added to the blockchain to be sure that it's block is actually permanently added to the blockchain now this is very slow just to give you an idea main stream payment processing systems like visa can process transactions up to at up to 24,000 transactions per second with a latency of just a few seconds now one might argue that reaper amat rising the inter block interval value and the size of the block maybe these performance metrics of bitcoin can be improved it turns out according to a recent study that even then the best we can do is 27 transactions per second and a latency of about 12 seconds people have now started to look at options to redesign block chains to address these issues of forking and low performance now or that the issue of consensus is not new it has been studied for well over two decades in classical distributed systems and there are well known and well tested protocols that enable? agreement among a group of nodes that can tolerate two kinds of errors there are crash failures and there are bees and time failures the protocols that are well known for crash failures are for example raft paxos and so forth by crash failures we mean that a node simply becomes silent for example because it crashed and is not able to actively participate in the consensus protocol resent time failures are worse in this case the nodes might behave arbitrarily or inconsistently for example sometimes it might exhibit the behavior of crash nodes by becoming silent or? sometimes it might lie about the value on which consensus is required the most popular protocol for tolerating bees and time failures is called practical byzantine fault tolerant protocol or pbft so what do these classical consensus protocols have got to do with bitcoin or block change in general recall that in bitcoin the way to reach consensus, was that a miner? solves a puzzle so basically it receives the transaction it does mining mining mining solves a puzzle and then say this is the blockchain it gets to write the transaction to the blockchain now what researchers are currently looking at is what about if we replace this leader with a group of leaders so instead of having one leader who is a miner we have a group of leaders? we're not really mining i mean the criteria for entering this group, of leaders might be mining but once they enter this committee or group they are not really mining so what this group does is that when it receives a transaction it basically runs a pbft protocol among the nodes and then they reach an agreement whether or not they are going to write this transaction to the blockchain so if they decide to write you to the blockchains then it's a collective decision of all the nodes in this group and it is unlikely for a majority of these nodes to be corrupt and do wrong things with the blockchain instead of if there is one leader who is in charge of this task how is that collective formed you mentioned that mining might be a criteria for entry but how would you how would you put those groups together i mean how would we not know there's some massive conspiracy go here honor suppose? this is actually a very good question and this is one of the research challenges in this area right now because in classical systems the entity that controls the network already knows the nodes so this is not an issue in the first place but with decentralized networks identity is a huge issue who, do you, allow to join these elite group of leaders one way that i mentioned was to sort of create a cost for entering the group by getting nodes to do work whether by mining but more recently this can also be a proof of stake proof of space or anything else but this really is an open research challenge and the the trade-off here really is that we want the nodes who want to enter the committee to show some sort of commitment that they're not going to misbehave either by making sure that they have used their resources for example by mining or they have sufficient stakes in the system that they wouldn't want to misbehave for their own benefit so that's a good way of preventing or maybe limiting the amount of folks that happen so does it make it any faster it does to a certain extent because we no longer have to worry about an interlocked interval to make sure that folks do not happen because once the committee has reached a decision that we are going to write this block to the blockchain then that's it it would be written to the blockchain for sure however there is a limit to how much performance gains we can achieve to the system because this committee is still the bottleneck really every node is handling every single transaction so it doesn't really scale in a scalable systems when you add more nodes to the network it should ideally improve the throughput of the system however the problem with these single committee systems is that because of the way pbft works the because of messaging complexity and the amount of complexity involved in reaching an agreement the more nodes you, add to this network the transaction throughput actually slows down this is an issue and it is an open research area right now a classical way to improve the scalability of a system at least in the context of traditional databases is that of sharding by sharding we mean that you split the state or the? data among multiple committees or groups within the network so basically instead of having a single committee you have multiple committees and then you make these committees responsible for managing transactions that have to do with say, data from a to f and then data from g to k from l to p and so on essentially you have split the transactions among multiple committees so not every node is handling every single transaction right now but it brings its own unique challenges because of its application to a setting for which it wasn't written in the first place so for example the idea is also that each one of these committees have their own block chains for example but what if there is a transaction that takes as an input one piece of data from this blockchain and one piece of data from this other blockchain so which committee is going to handle this transaction now block chains might not end up something quite like the internet however in one form or the other they are probably here to stay but there's still a long path between where we are right now up until the point where they are as widespread as say for example traditional databases i'm so i mean that's about unfortunate is the problem with cryptography is that we couldn't ever use truly random because, we? wouldn't be able to decrypt it again we have our message bits which are you know naught 1 1 naught something different and we xor these together? one bit at a time and that's how, we encrypt and the nice thing is