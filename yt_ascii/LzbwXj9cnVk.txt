don't worry i turned off i turned off alerts what do you think i'm a rookie what do you think i have been doing this for a couple months and i'd mess this up come on there has been a buzz recently in the front end world around the term signals it seems let's see it's in seemingly short order they seem to be everywhere showing up and everything from preak to angular for those that don't know what signals are they're old but they're glorious in fact i would argue that hands down the right abstraction was the constructor function plus signals versus the react render function i think react render function is the failure but they are not a new thing not even remotely if you consider you can trace routes back to research in the late 1960s as its foundation the same modeling that enabled the first electronic spreadsheets and hardware description languages like verilog or vhdl even in javascript we've had them since the dawn of declarative javascript frameworks they've carried various names over time and have come in and out of popularity over the years i know i've never really you know this whole drive for declarativeness i've the problem about declarativeness and i know people love using this term and throwing it out is that ultimately you always have to fall into procedural right everything always comes back down to imperative programming and i just find it really hard to reason about sometimes when you're especially as you mix in these things and it just becomes it can become tough over time they've carried various names over time and come in and out of popularity over the years but here we are again and it's a good time to give a bit more context on how and why disclaimer i am the author of sala js this article reflects the evolution from my perspective of my influences elm signals embers computed properties and meteor all deserve shout outs i used meter when it first came out i even had like a drawing thing with canvases whereas moving circles around on two different things it was super cool but the problem with meteor and the reason why i had such a hard time understanding meteor was that there was like an entire universe around meteor and i didn't know how to control it like it meteor was like the first super opinionated like all stack grabbing technology that i think makes a lot of magic happen that makes it super confusing to reason about yeah meteor was hot in the day but it made it really hard to reason about what was happening unsure of what signals are or how they work check out this introduction to fine-grained reactivity let's see okay in the beginning but in but let's see it is sometimes surprising to find that multiple parties arrive to similar solutions around the exact same time i believe calculus was brought up by more than one person if i'm not mistaken sir isaac newton was taken the court over competing views of calculus and when they arrived at court sir isaac newton also happened to be the judge got up on the chair and been like not guilty my proclamation of the judge right if i'm not yeah yeah i know it started with an l if i'm not mistaken that's approximately how the story went now bequeath to me the honorary role of calculus discoverer and fall bearer and that's what happened right that's actually what happened and that's how the rust foundation was born all right the starting of declarative javascript frameworks had three takes on it all released within three months of each other knockout js backbone and angular that sounded like charlie day yes i know people say i sound like charlie day all the time it's either charlie day gilbert gottfried michael scott or bill burr all of those people have similar sounds right and so i can sometimes get into i can get in a little bit don't hey don't say [ __ ] calculus is really good for the brain okay if you're not hitting six hours of inverse trigonometry substitutions in a girl's baby if you're not doing a little lorenz a little taylor series a little mclaren series you know you don't you ain't got [ __ ] okay okay because that prepares you for what is known as the multi-page laplace transforms okay if you don't have 9 000 s's drawn on a test by the time you're done you don't you've never even done it okay you don't even know all right let's see angular is dirty checking backbones model driven re-renders and knockouts fine grain updates each was a little different but it would ultimately serve as a basis for how we manage state and update the dom today knockout js is of special importance to the topic of this article as their fine grain updates were built on what we've come to call signals they introduced two or initially two concepts observable yeah sorry i have a little post-traumatic stress disorder when it comes to the word observable so just give me a second i gotta i gotta re i i gotta read kind of go you know do that i gotta redo that yeah there was another person i thought it was i thought their name was like rodriguez or something like that i thought there was a third person in the calculus one and i i swear one of them was named rodriguez but i i could be completely wrong on that one that might be the quaternion one but i swear there was anyways anyways let's keep on going so they introduced let's see okay observable and computed side effect but over the next couple of years would introduce a third concept peer computed derived state to the language of forefront okay we have an observable count double the com count okay computed double lock to double the count the wonk that's log plus count lock long all right there's oh is that westworld are we are we looking at a westworld photo right here is that a little season two westworld that i'm looking at right now when i watched westworld anyone like that second in charge guy was a robot blew my mind blew my mind [ __ ] my pants right there on the spot right there and then westworld completely fell off but i loved the first couple seasons anyways let's keep on going bernard is it was it bernard i feel like that's the name spoilers you know what sorry you're seven ten years late to a party you don't get you don't get it okay westworld came out like seven years ago anyways the patterns were in the mix of patterns learned from developing mvc on the server in the past few years of jquery jakiri is one of my favorite jacquerius oh man i was so jaquerius one particular comment was called the data binding which was shared both by angularjs and knockout js although in slightly different ways i believe angularjs data binding was confusing and involved dollar signs and reminiscence of php and knockouts was different data binding is the best is the idea that a piece of state should be attached to a specific part of the view tree one of the powerful things that could be done was making this bi-directional so one could have state updates to the dom and in turn dom events automatically update state all in an easy declarative way really you prefer ah if you do it if you didn't work on early web pages jquery was the way however abusing this power ended up being a foot gun but not knowing better we built our applications this way in angular without knowledge of what changes it would dirty check the whole tree and upward propagation could cause it to happen multiple times and knock out it made it difficult to follow the path of change as you've been going up and down the tree and cycles were common by the time a react showed up with a solution and for me personally it was the talk of jing chen that cemented it we were more than ready to jump ship yeah i get that react was interesting what was the follow was mass adoption of react some people still preferred reactive models since react was not very opinionated about state management it was very possible to mix both mo observable 2015 and later mobx was a solution but more than working with react it brought something new to the table it emphasized consistency and glitch-free propagation that is that for any given change each part of the system would only run once in a proper order synchronously it did this by trading the typical pushback reactivity found in the pre predecessors with a push-pull hybrid system notifications and changes are pushed out but the execution of derived state was deferred to where it was read okay okay okay okay why would you shorten it to mob x that's brilliant mabry observable you know observable rxx reactive people use rx for reactive though i see rx as receive let's see anyways while this detail was largely overshadowed by the fact that react would just re-render the components that read changes anyways this was a monumental step forward in making those systems debuggable and consistent over the next several years as algorithms became more refined we see a trend toward more pole-based semantics consequence leaky observers fine grain reactivity and its variations of the gang of four observer pattern while a powerful pattern for synchronous synchronization it also has classic problem a signal cap keeps a strong reference to its subscriber so a long-lived signal will retain all subscriptions unless manually disposed this bookkeeping gets pro prohibitive prohibitively complicated with significant use especially where nesting is involved nesting is common when dealing with branching logic on trees and you'll find when building ui views yep okay yeah yeah yeah so this is all i remember all these days i remember still this point at netflix when react came out and by 2015 it was hot okay it was hot everyone was saying it was the greatest thing ever and i remember thinking when i saw react it was the greatest thing ever i thought it was the greatest thing ever i thought it was fantastic i was the victim i was a victim in this story okay i what i was okay a lesser known library sjs 2013 would present the answer s developed independently of most other solutions and was modeled more directly after digital circuits where all state changes would worked on clock cycles it called its state primitive signals while it's not the first to use that name it is where the term we use today comes from okay more importantly introduce the concept of reactive ownership an owner would collect all children reactive scopes and manage their disposal on the owner's own disposal or were it ever to re-execute the reactive graph would start wrap let's see start wrapped in a root owner and then each node would serve as an owner for its descendants this owner pattern is not only useful for disposal but as a mechanism to build provider consumer context into reactive graph i remember in like 2009 i was in a class a robotics class and someone built effectively this but for the robot we had to do this challenge right the challenge was this is that you'd get a cmu camera which is really good at detecting colors you'd get some gps you get an accelerometer you'd get a gyroscope and and then a couple other things ir sensors if you want to use ir sensors all that kind of stuff we'd get all those things and then you had to go and go find four points out in the courtyard right and i remember building mine mine was a spaghetti mess of code back then i really didn't know how to program at all and the person who was next to me that was older older fella i can't remember his name but i really appreciate him he was greek that's all i remember about him and he had just an amazing jawline right he was like the original chad i was always jealous like he walked into a room and his jaw would just like start hitting it was just like it was so square it was incredible and he built his effectively like this it was really clever what he did and he'd have like these layers of priority and he was the only person in our class that successfully finished the requirement which was to drive to these various points and then find the cone and drive at the cone all in a single like you couldn't control it it was it was honestly very very impressive and i still look back to it at this day which is you have to realize that there are people that are just so dang gifted out there and i mean he was one of those people that was just so dang gifted it was incredible i still man i wish i could remember his name he was he me and him worked on a compiler as well together we crushed it man i wish i could remember his name it's so crazy how those things escape you anyways view 2014 also had made a huge contributions to where we are today besides being in lockstep with mob x with advanced advances and optimization for consistency view has fine-grained reactivity at its core since the beginning while vue shares the use of virtual dom with react reactivity being the first class meant to it developed along with the framework first as an internal mechanism to power its up options api too in the last few years being front and center in the composition api 2020 wow he's like setting years and everything view took the pull push mechanism one step forward by scheduling when the work would be done by default with view all changes are collected but not processed until the effects q is run on the next micro task however the scheduling could also be used to do things like keep alive preserving off-screen graphs without a computational cost and suspense even things like concurrent rendering are possible with this approach really showing how one could get the best of both worlds of push and or pull and push-based approaches you love you everyone seems to love you i would love to try view one of these days but at the same time i'm not going to lie to you i don't have like a huge desire to do frontend anymore like it's pretty hard to convince me to do front end like if i'm gonna do front end i'd rather try to figure out how to use leptos and just build it in rust and leptos you know what i mean try to have a little bit of fun while doing it do gamedev nah i like building tools i'm a tool straight up i'm a tool okay i'm a tool that's really what i do i build stuff that all i do at netflix is i build stuff to walk and do process management and and build tools and in and outputs and standard ins and outs and blah blah blah blah that's it i'm a tool that's it i'm a tool guy are your tools cli only yeah i mean i technically have a solid.js front for one of them but it's really minimal i don't see the purpose of doing it you're an input importer exporter tool yeah something like that in the world of mechanics i build spanners i'm just a very simple guy okay i love tools i love building tools i love building tools for developers i love thinking about problems i like to think about what's going to make somebody save 30 minutes of their day every day that's like that's why this is why i use vim this is why i do those things it's because i love that kind of stuff and so i will never be a front-end person but i can genuinely appreciate what ryan's doing you know what i mean i i'm very curious about htmx i think it's also very exciting right glorified pipe builder that's really all i am glorified pipe builder data aggregator science maker hypothesis creator i don't even fix bugs i just tell people i think you might have a bug in this region right 2019 unless he's felt three a showed showed everyone just how much we could do with a compiler in fact they compile away the reactivity completely this is not without trade-offs but more interestingly is svelte has shown us how a compiler can smooth out ergonomic shortcomings and this will continue to be a trend here the language of reactivity states derived state in effect not only gives us everything we need to describe synchronized systems like a user interface but is analyzable wow we know exactly what changes and where the potential for traceability is profound i think one of the main reasons why any signal-based approach is better than hooks it enables additional debugging insights which is not possible with hooks like exactly showing you why a piece of state is updated planning to add similar visualization to our dev tools alright awesome let's see if we know that at compile time we can ship less javascript we can be more liberal with our our code loading this is the foundation of resumability in quick and markle yep signals are the new vdom there's an explosion of interest many people are trying things this will let us explore the space try different strategies understand and optimize things not sure what we are going to settle on in the end but this collective exploration is great i love it i'm very happy about it giving out all the technology as it is probably surprising to say there is much more to explore but that is because the way of modeling solutions rather than a specific one what it offers is a language to describe state synchronization independent of any side effect you have performed i again i really do i really do like mice very small amount of signals i've done i love the idea that every signal represents effectively a point of change in the in the ui and how it generates new ui or changes the current ui like values and to me that it just makes it so much more sensible it makes it so dang easy to kind of work with oh one of the first time i saw you i thought you were a computer well i do compute anyways orange signals expensive no they're the opposite of they're the opposite of expensive signals are really fast the reason why they're really fast is that how you can think of a signal that makes signal so neat is that if you go to like excally draw right by the way this is my thoughts of reddit probably being a horrible person and how much karma you have on reddit remember that okay don't forget that here we go so anyways so how a signal works or in the simplest sense is let's just say you have a ui right you have some sort of tree view right here's your view right and it's comprised of a bunch of different things right you can think of all views like trees right blah blah blah blah right there's a bunch of views here let's do a little [ __ ] and ball torture here right well a signal what you're going to do is you're going to generate it for like something specific right here right it's going to be a specific value and you can have access to this anywhere within your application right and so the signal hey thank you for ruining ruining that okay thank you for ruining that i had a nice there you go so this signal's attached here so anytime this thing has changed this little bit of code is re-ran right here now the thing that makes all of this really amazing especially in svelte or not spelled sorry not in svelt but in solid.js is that every time you have like what looks like a render function it's actually a constructor function so you construct how your signals change and then that is it that function's not ran again every single time you re-render only the signal some lightweight amount and so you can imagine you have something that says your name and when you change that it literally just changes that one value on that one html node it doesn't re-render the process then take what has changed and compare to another virtual dom and then when those two things show that there's a difference between the two it maps it to the correct node to be updated and then updates that note right it doesn't have to do all that you call a function the function poops out the value and just changes it right there in the html right so it's extremely it's like extremely tiny it doesn't it doesn't need to do nearly the same amount of work that's something like react would right because react has to do a reconciliation thing you know what i mean so when you reconcile when you reconcile a change you're really doing a tree diff and so that's kind of complicated right tree diffs are not simple that's why something like that's why whenever you look at like the framework stuff react is like an order of magnitude slower than solid because by its very definition it has to be it's just doing way more now you could argue do you think the way more is better like that's that's that's that's the argument right you want more details on pooping out the value go play with solid.js right but that is because the way of modeling oh we already did that it would seem unsurprising perhaps that or then that it would be adopted by views solid preact quick and angular we've seen it make its way into rust with leptos and sycamore showing wasm on the dumb doesn't it let's see doesn't have to be slow yes was him on the dump on the dump it can even be considered by react to be used under the hood we might add a signals-like primitive to react but i don't think it's a great way to write ui code it's great for performance but i prefer reacts model where you pretend the whole thing is recreated every time our plan is to use a compiler to achieve comparable performance see i i don't like this because i do think i think if you pretend like something can be rewritten the entire time i think you're gonna it just leads to something odd whereas with signals you're defining the points of change and i feel like it's just easier to walk through you know i mean i just feel like emotionally it's an easier to walk through kind of paradigm in your brain like this signal maps to this change and this is the potential changes right just me right and maybe that's fitting as a virtual dom for react i've always found just in general i feel like it's easier you know what i mean react is always just the implementation detail signals in the language of recreated or reactivity seem to be where things are cover converging but that wasn't so obvious from its first outings into javascript and maybe that is because javascript isn't the best language for it boom javascript's not the best language heard it right here ryan carniado i'd go as as far as to say that a lot of the pain we feel in front-end design these days are our language concerns wherever this all ends up it has been quite a ride so far and with so many people giving signals their attention i can't wait to see where we end up next really if you haven't tried solid.js give it a try honestly give it a try see what you think try view or solid i'm sure there's other versions of signals they're talking something about preact it's really cool like it's a cool cool thing the difference between signals and observables if i'm not mistake i mean observables they have three states right i mean observables have three callback functions that's what makes observables a little different right so there's on next there's on air and there's oncomplete and so that's an observable whereas maybe this is maybe that's like too much of an extension of observable maybe i'm doing too specific of an implementation but signals are a bit different and they're kind of it's more built into the application to where maybe it is you know technically the same stuff underneath the hood but you wouldn't know that when you're working with it when you're working with it it just it feels different i don't know how to explain it observables also create this leaky abstraction which is a little bit different when you use an observable the things that consume observables have to use observables and eventually your whole thing becomes observables right it's a very leaky abstraction and i find that it just it just it keeps spreading no matter what you do when were you able to write front end with c plus plus you can wasm right view was created by taking the the best of react and angular and making view what's the difference between a signal and an event emitter i mean it's it's fundamentally a very similar concept right oh thanks for everything you do i use vim oh neil bim for five years and i've still learned so much from your videos guess my vim skills are stagnated after one year it's nice yeah spreads like well yeah it is signals are just monads something like that all right hey the name is the primogen