let's get this disclosing keynote on the way as you said i had to choose a topic and i've not chosen a topic probably the topic that is most dear to me so i entitled this talk breaking dependencies the path to high quality software so now i skipped the introduction this is what jins has done and i immediately jumped to the question that you might now have what is high quality software so many of you might now believe that it's another talk about c plus 20 c plus is 23 but not that's not the kind of talk i'm doing i'm usually doing the talks about other topics so for me my definition you might disagree but still high quality software is easy to change easy to extend and easy to test so now for the entire talk this will be my definition of high quality it's about yeah changing things easily and i actually believe this is truly of course fast is important too but for now for this talk let's focus on the three red items and this is just so much the truth in our industry software must be adaptable to frequent change this is it and it's actually in the name already software so the soft actually comes from the fact that people expect that it can be changed easily yeah it is just from the very beginning it was from the very beginning the thing that needs to change but if this would be always true then it would be simple right it's not always true and from your own experience you know that things are not easy to change very often because there is a very basic a core problem in all of software this core problem that keeps us from adapting easily is dependencies now i spent years to actually collect quotes from famous people about dependencies and there is quite a few but i still kind of favored one from kent back the event of tester development is that dependency is the key problem in software development at all scales and this is so such a simple formulation but so true whatever you do it's always about these dependencies it's always about dealing with the little connections the relationships between classes modules little things and big things and so this is what i've done over the years i've talked about dependencies i talked about the solid principles type erasure design patterns as such the visitor pattern and type erasure again i've talked a lot about this and so from these titles maybe a little subtle but you might get the idea that all of these talks about breaking dependencies dealing with dependencies in one or the other way and so well to say it in other words the common theme for me is softer design so i don't talk about features i don't talk about the standards i talk about the other thing i try to talk about the topic that nobody else wants to talk about for some reasons so when it's so see software design should actually define software design real quick because this is the first thing that we now might have different ideas wikipedia itself actually doesn't define software design with just a few words there's no clear definition there's at least two at wikipedia and so here's my definition which you might agree with might not but this is now exactly what i will focus on so soft design is the art of managing interdependencies between software components it aims at minimizing mostly technical dependencies and introduces the necessary abstractions and compromises stop there's a little long i know so i try to shorten it software design is the art of managing dependencies and abstractions and so i really think this is not something that is easy to define because it is an art it's not something that you just do it needs experience definitely and this is why it is kind of hard but it doesn't is always about it's always about managing dependencies dealing with them in one way or the other hopefully minimizing them of course but at least reducing them in order to make us after a little more flexible easier to change extend and test but it's also about dealing with any kind of abstraction any kind of abstraction that helps us to deal with the complexity so yeah i'm thinking okay what what's the big deal why is this something that we should talk about it's so obvious isn't it well okay allow me to tell you a little fictional story which might involve you but we can choose whether you're part of the story or not let's assume that there is a new project so you might be on the project or not and something that is very rare you can actually start fresh you can start on yeah a totally new project which already sounds pretty amazing right oh yes it does and so initially for the first couple of months life is heaven it actually is you can do whatever you want you can write whatever you want it just works it's fascinating there's no problems at all and so of course as a consequence managers feel like you will rule the world in just a few other months and i start promise to any customer that this feature and that feature and this difficult thing will be available in just the next release but it works everything works everything's great and of course after some time after a few months the speed of development kind of starts to decline because nobody really thought about the quality of the code everything was just done rather quickly simply because it worked but eventually things are starting to get a little more difficult to change it gets more difficult to add new things to the code because nobody really thought about the future it was all about the present and while in the beginning everybody was like oh i have a little time left let's do this extra thing now there is less time left to do this there's less time to go this extra mile this this this do this extra work according to this boy scout rule so of course yes less time right there is less time now to actually deal with a real problem and so it's kind of hard to get back to the initial quality so what now happens over time is well of course the quality degrades even further which puts everybody in a pretty bad situation because now people have even less time because suddenly there's more bugs which need to be fixed and this takes a lot of time and it takes even more time to actually change things and add new things deadlines are now at stick you're not as quick anymore as before but you've already promised all this stuff oh my this is a very very bad situation to be in so what for sure happens in this situation of course new people are hired just increase the size of the team make everything twice as fast which of course results in a and another decrease in speed obviously because now that your people have to train the new people they have less time to actually deal with the code it's going downhill and at some point you reach some okay actually your speed might go up eventually a little bit again but eventually you reach a max point of maximum frustration this is the point when many people decide it's not worth it anymore key developers start to leave the project life is definitely not great anymore now now you're totally depressed i know so it was a bad thing to tell a story but i also said it's a fictional story you could decide whether you're on in this or not but i'm afraid that you know phil many of you feel like oh oh i know this and i actually have to admit it's not so fictional at all i'm a freelancing trainer i'm not in any of these projects but i actually tried to help some of these projects and i've seen them degrade even further it's kind of hard once you get there so to the bottom and so quality matters quality does matter of course it matters so much how you implement the code the implementation details it matters that you take care of duplication code it matters that you make code readable it matters that you take care of the little details but though this matters structure on the organization of the code in other words the design matters so much more because this is essentially what what what results in good or bad projects and so again my personal opinion the design plays a much more central role in the success of a project than any feature could do good software is not primarily about the proper use of any feature rather it's about solid architecture and design good software design can tolerate some bad implementation decisions but now that's after design cannot be saved by the hurricane use of features or all the new alone and so software design software quality does matter now unfortunately it's not just my observation that this is exactly what usually is not taken care of so i know quote robert nystrom the author of game program patents who apparently has made exactly the same experience i have to say that he is from the gaming industry games are very time critical so it's kind of the usual thing but it's not just in games but the architecture this code hung from was often an afterthought they were so focused on features that organization went overlooked and indeed i believe this is exactly the problem that find the law of code basis so now you may be in a code base that does not work well anymore so you have ignored software structure organization you don't really spend a lot of time on thinking about design but you don't know it there is good news because of course you can always rewrite the code of course sounds great right but there's a catch there's a catch that many of you may have heard about so you might know this gentleman here jill sportskey is actually the co-founder of sticker overflow and also i think not not so much recently but has written a pretty successful block so joel and software and that's a great article and exactly this particular issue rewriting the code base and this is i believe the key sentence from from this article they this he actually means netscape i mean the single word strategic mistake that any software company can make they decided to rewrite the code from scratch does anybody remember an escape the browser okay this is the the slightly older people it's it's it's not here anymore why well they try to rewrite the code it utterly failed so apparently you cannot just think s everything overnight it doesn't work and so softly design matters from the very beginning and it is a continuous effort it is work now i'll try to give you another example an example that now some of you will not understand you might not be old enough yet but i promise you you will eventually understand and perhaps you haven't intuitive understanding for it already so do you know what this is so it is a messy child's room by definition this is not what what the younger people don't know by definition a child room is messy if you go from the as a width with a blindfold go from the door to the window and you step on something that's a messy child room now if your parents what of course do you ask your child to do clean up tidy the room what's the result of your of course nice requests so the result is a pretty angry childhood absolutely not interested in cleaning up the room so now of course initially i'm also just a young parent i thought they are just lazy lazy kids but later i found out that there's a totally different problem they have just no idea where to get started for them this tidy this uncleanness is is is an insurmountable problem they just don't know where to get started and this is why it's such a big pain for them and this is exactly pretty much what what software is about so keep your room clean all the time there's no problem you know exactly how to clean up the little things everything works so software design does matter from the very beginning and it is although it sounds like a lot of work and it's it is a continuous effort all right so keep your code easy to change easy to extend and easy to test this is now for you the developers this is what you should keep in mind but of course this requires extra work an extra work means that some managers have to agree that there needs to be refactoring etc so what can you tell them to actually allow you to keep the code clean to just not tighten the deadline such that this is impossible well usually there's just one and exactly one argument that it can give is about money seriously it is all about money clean coat good code is cheap because you can actually walk forward quickly you can change and extend things rather quickly this is cheap a mess is absolutely expensive so whatever money you invest later to refactor things it's so much more than to in from the very beginning keep the code clean however now obviously you're asking so how can we keep the software easy to change extend and test so what do we have to do well there is an easy answer and of course all of you know about this answer the solution are design patterns ah design patterns this raises nice memories doesn't it it raises memories and it immediately erases an image of this book ah glorious times the gang of four book gerophobic because of the four authors gamma helm johnson felicidus who in actually it's hard to believe 1994 collected design patterns by the way this is seriously important thing to note these four guys didn't invent patterns never invent a pattern it's never invented they kind of discovered and extracted these patterns they took a look at the code basis at the time and actually tried to find common solutions to the recurring problems and if a solution occurred in many code bases apparently it was some kind of pattern and so all they did was to actually give these patterns names that you can use to communicate some intent when do i use this particular pattern in which situation for which kind of problem and they of course in some way show how to how this pattern helps you to manage dependencies that's what they did and despite the fact that it now sounds like they did not a lot of work this is an absolutely amazing source still despite the fact that some people regularly complain that it's so old okay it's a little boring i admit it's very dry if you read it but it is a fundamental source of the solutions to deal with software so from my point of view this is definitely still some some very important thing because design patterns simply are everywhere but charlie don't really talk enough about software design and design patterns we don't really talk about them despite the fact that i'll try to point out it's so important so fundamental we don't really talk about it and just in numbers and an audience will not like this but still in numbers meeting c plus plus 2022 i now counted the number of talks in a life schedule and so i might be off so it's approximately 47 perhaps it was we're not much one less one more not so important then the number of talks in c plus feature standards was at approximately 16. by my account might differ a little bit i think it was 16. the number of talks on sorry 34 and the number of toxins softly designed four four talks so approximately eight percent and this is the reality that i'm seeing pretty much everywhere so i have another number which i cannot prove because it's not something that was official so for cpibcon we usually submit classes up front usually almost a year up front and have been a 16 classes proposed one class out of 16 was about softly design and architecture but six classes out of these of course we're talking about c plus 20 and 23. and that's the reality that i'm seeing pretty much everywhere we talk primarily about standards features details the implementation details when you're not talking about the big picture we do not really talk about software design so why is that why do we not talk about software design well there may be a lot of reasons but i've identified three the three that i know one to talk about three reasons why this apparently is not interesting anymore reason number one we already know everything about design patterns what's that to talk about reason number two sign patterns are just for object on the program ends after all object and program is not in favor anymore and reason number three simple come on it's just a couple of of patterns it is simple okay let's take a look at these reasons one by one and let me try to make the point that i don't think that any of these is true so we already know everything about design patterns after all they have introduced 28 years ago now almost three decades of course you know them right well i had a lot to choose from but i've not chosen one particular example that is bugging me quite a bit i've not chosen the classic factory method design pattern which is described in exactly this book so let's take a look at the intent that the king of four gives us a short summary which is this one define an interface for creating an object but let's subclasses decide which class to instantiate factory method lets a class defer instantiation to subclasses a simple one right pretty simple design pattern it really is simple because after all it's it's about creating an interface for creating an object special about this well indeed factor method is very often used pretty much as a synonym for creating something and so obviously it's a consequence since c plus was 11 people have more and more made the remark that make unique is a great example for such a factor method it creates something now let's take a look at how it is take another look at the at the definition and let's take a look at what actually else is in there let's sub classes at this side defer instantiation this interestingly is a couple of things that are usually totally overlooked that nobody really curious about my feeling and so this is what the king of fort describes as the the factory method design pattern and of course it's 1994 the one solution they usually have is to have an inheritance hierarchy so there is some creator which has a factory method this is what where the name comes from which is you see virtual and some concrete creator can actually implement this method to create something but again up there's some abstract product something that i don't really have defined yet also some kind of interface so this is how the gang of four describes it now what they unfortunately did not do in the book is they did not draw a line they did not draw a line right here in the middle a line that actually shows something that is i believe fundamental to the idea they did not show some architectural boundary i'll leave this to be the core of what a factor method is up in the high level i'll come back to the terms in a second up in the high level we have all these abstract things some product some creator and we can just use this without having to know anything about implementation details we just don't care but in the lower level we now are able to actually define what it truly means to create something we can define the real products we can define how and when they're created so perhaps there is indeed something special so we separate the use from the implementation details now i have to go back to these two terms for for second high level and low level i know this is two terms that are totally confusing and this usually always discussions when i talk about them so you know unfortunately i have to accept these two terms as they are so high level now in this talk means this is the stable stuff this is the stuff that i want to depend on this is the stuff that should not change at least not often well in low level there's all the implementation details this is all the little details that we eventually have to implement but that you just don't want to know about in the in the high level and so as it is with this high level and low level which by the way indeed comes from the fact that the abstract things are on the high levels yeah on top and the derived classes on the bottom so low right now as it is this is an architecture it is an architecture so it that we could not talk or about what an architecture is but to simplify it quite a bit all the errors all the errors point from the low to the high level all of them so all dependencies run from the bottom to to the top this is what an architecture is about now going back to okay because of an inversion dependencies this is kind of kind of a key here now going back to make unique and in so many other claims about little functions that just create something let's make unique function just does not allow me to customize anything i'm not able to change how this works i'm not able to change the little implementation details so i don't know many mention any relationship in in a make unique or in any little function that creates something does not in word dependencies or break any dependencies between entities and so yeah i wouldn't consider that and then there is one more thing actually making is not a method it's a function and now because i know this from entering classes there is indeed not enough awareness so allow me to give you a quick glance at the index of the c plus plus standard and i'm using the the current draft of the standard so from november 11th this is part of the index of course not the index there is something that you do not see yes you do not see method there's no entry for method there is no method in c plus plus there never was it's a java term that unfortunately was kind of ported to c plus plus behind the system himself actually made a comment about this in his the c plus program language book one sentence very short a virtual function is sometimes called a method that's it that's all about methods in the book but i thought it's a short sentence that is a key word in the sentence virtual now with word surely he'd actually indeed you know we've really refers to just the term but i'm not trying to go to go back to this factor method you know factory method i don't think that's any little function is an example for factor method but something else i know it's a little confusing i think bank unique is a great example for a factory function now some of you feel like oh my the sky is just dealing with little terms but there's a pretty pretty important distinction because factory method from a word alone implies customization and function is not we could not distinguish between these two so please from today on use the term factory function for any anything any use it as a synonym for it creates something but please start to use the term factor method a little more consciously use it for anything that you want to be a customizable factory function and immediately there is value immediately you can communicate your f a factory function and everybody knows okay just create something great but as soon as you know start to say factory method whoa you have actually given somebody else information you consider this to be a customization point you consider this to be something special you can customize this in in whatever way you want that is definitely one of the primary ideas of design patterns the names suggest some solution to a common problem all right so going back to my my first reason i think we don't know everything about design patterns i don't think so we might not even have the same terminology which i personally consider to be a real problem so i think we know a lot about design patterns already but we definitely need to talk more about them we definitely need to talk more about what do we mean when we say because these terms they have so much information if you use them consistently and so i believe this is definitely one very good reason to start to talk more about them all right but this is just the first reason let's go to the second one design patterns are for object oriented programming but subject-orient program is not in favor anymore now i know i know that may have a different opinion and i see this a lot again in training classes and i'm perhaps talking a little bit about this this this inner circle of c plus plus and so you may have as member of this inner circle seen this talk at least heard about this talk given in 2013 inheritance is the base class of evil yeah it it's a funny talk from a title point of view the title is brilliant absolutely and i think this is why the talk actually became pretty famous although the same information was also in other talks but this one perhaps it's special because in the title it already carries information you should not use inheritance i don't think he really meant it this way but he actually shows his talk how he can live without better and this is this is why this is really an important talk but it carries a negative attitude towards inheritance but there's actually people that can do even more perhaps you have heard this title or seen this talk even object-oriented programming is that long-lift data oriented design now just to be clear that i'm not scaring anyone off this is a cpp con talk right cp con every year it is 160 talks give or take and many of these talks run in parallel four five six talks run in parallel so what do you do in order to make your talk attractive what do you do in order to make the people come to your talk of course you choose some attractive title some provocative title and suddenly this is of course this talk was in one of the big rooms no no no no no the object only program is not dead this is maybe perhaps true for the game industry to some extent they were burned by object during the programming a little bit and so this this explains the title and this is where this talk comes from but it definitely is not dead no no no no no no but this is now the attitude that some people seem to have so in 2021 i actually had the honor to talk about design patterns in jens's meeting c plus online group and so he put this online and just within days someone i don't know whether a gentleman or lady i have no idea someone posted a comment really sign patterns in 2021 now as i said i have no idea who this was and so i give it the reason of a doubt perhaps this person was trying to say something like uh why do we talk about this this is super common knowledge i'm a little bit afraid that it's one of the other direction the why do we talk about this nobody needs this anymore we don't do object on the program anymore so this is one of these misconceptions that i definitely went to to end hopefully today so i claim i'll show you that design patterns are pretty much everywhere you use them on a daily basis and i kind of have realized now that this is exactly what people are missing because of the online voting that ian showed us just before where people voted for which patterns to use ridiculous answers because i believe people have no idea what they actually do in this context so i now go back to this book i'll choose another one a very famous pattern very famous indeed the pattern that all of you have to know the so-called strategy design pattern so this is what the gang of 4 uses here define a family of algorithms encapsulate each one and make them interchangeable stratulates the algorithm very independently from clients that use it so how does strategy work real quick you may have some context some class some class that actually has to implement some kind of algorithm now the algorithm is something that yeah maybe quite difficult to do and so there may be a couple of dependencies so you do not just want to have this this dependency in the context and really this is the class where we now want to extract implementation detail from we do not want context to be too big too complex and of course we also might want to have the flexibility to exchange implementations easily and so the one thing that we now do is to extract this information we isolate this concern into and again it's 1994 another base class strategy based class which now represents the implementation details for this particular algorithm context does no longer implement the algorithm itself but instead it now holds a pointer to a strategy this is what the little diamond says i now have appointed to a strategy based class and so silly context doesn't really need to know about its algorithm anymore it doesn't need to know about the implementation details anymore and so i have now effectively separated concerns i'm following the single responsibility principle but this now enables me to actually add any implementation easily i can implement a strategy this algorithm in in form a in form b i can do whatever i want to which is now exactly what the so-called open close principle tells us to do we would like to design such that we can extend the the kinds of algorithms easily now notes there's inheritance yes but still the the strength of this pattern is delegation i now have i pointed to this space it's not direct inheritance this would fail a tilly this would not be a good idea again though they say an architectural boundary i again separated the the use from the implementation details so this is no this is strategy classic strategy 1994 strategy and this is what people see as the strategy design pattern this is how you do it i think nothing could be farther from the truth standard library itself uses hundreds of strategies but have you seen a strategy based class anywhere in a standard anyone not really right it's hardly any base class in the standard so you can use one hand to count them no there's other strategies so unique pointer all of you know unique pointer what is often forgotten that a unique pointer has two template parameters you usually see only one so it's easy to forget but actually there is two there is t type that we want to deal with but there's also the deleted which is defaulted to default delete which we use most often but you can from outside tell the unique pointer how to actually deal with deletion you can pretty much configure and customize this your liking you can inject this dependency so yes this is a strategy it's nothing but a strategy it's exactly the same idea exactly the same philosophy of give me the implementation then i know what you do and that's something that gives you the idea that there's a lot so stood vector also two template parameters it has a t and an allocator so you can configure you can customize the standard vector from outside to deal with any kind of allocation that is a strategy and of course other containers might even have more all of these for none other sets the hash the key called the allocator all of these are strategies compile time strategies you may have heard another term for that and to alex and rescue actually introduced this term in 20 to 2001 policy-based design that's the same idea exactly the same idea one last example is to accumulate now we are in an algorithm so we want to accumulate all the numbers in this vector of integers one two three four five below and we'd like to sum them up easily so we can use the document for this task so we pass the begin the end of the vector we pass an initial value of zero it's a good start for a sum and yes as a fourth argument to accumulate we pass the accumulation rule how do we want to accumulate of course you know that if you just want to sum up you wouldn't have to but this is again the point where we can customize the behavior we can customize behavior and again it's the same idea it's a strategy of course it's a little function programming so we also consider this a higher order function but it's again the same idea so there is hundreds of strategies all of the standard library and that of course is definitely a sign that we're using a lot of these design patterns on a daily basis so design patterns are everywhere indeed we want to deal with dependencies we want to deal with with customizability pretty much everywhere and so especially strategy i believe is pretty much everywhere so design patterns are for oo no i think there are so much more so they're not only for opm becoming many different forms we definitely really should talk more about them you should really talk about in which forms they appear how they help us to make our software more flexible keep it changeable extendable and testable all right there's one more reason why we actually do not talk so much about this might and this is they're just simple come on they're not particularly difficult well let's take a look at an example an example that i used a lot over the years so if you've seen any of my talk then it kind of is familiar and i started to draw shapes and a very common basic idea is that we abstract shapes in general by means of a base class of course it's the most obvious thing to do so it's a base class with of course a virtual public destructor and now we have all the things that we need to implement in driving classes draw serialize and maybe a few more little details that that we need to deal with later a few more virtual functions then there's a circle class one of many possible shapes the circle first of all of course has circle like things like radius other data members and there may be a couple of getters to actually use the circle properly but eventually we'll have to deal with all these virtual functions we need to implement draw we need to implement serialize and potentially a few more of these functions no let this be just that all the thing that we need this is now what we want to properly implement but as it is unfortunately it's a pretty naive approach an approach that might work of course but that also might put us into a problem zone quite quickly because this naive implementation is actually causing a lot of dependencies of totally different nature so the first of kind of dependencies kind of obvious it's the type of arguments we are now depending on screens and byte streams and potentially many many other classes as we don't see all the virtual functions this may be a problem but it might also be okay but entirely depends on what streams by screens byte streams etc however how do we implement the draw function in circle how do you implement it here well honestly i wouldn't implement this myself i would use a library for that of course i would use any kind of graphics library which however means that now our circle is coupled to this graphics library this is kind of a difficult kind of a hard dependency wherever the circle goes we have to bring the graphics library along with us so if the circle is used anywhere the graphics library needs to be in the system needs to be linked needs to be part of the completion this is a kind of kind of a big dependency but it gets worse we always have to deal with serialize so how do we implement serialization by means of a library right so i wouldn't do this myself so suddenly we are also coupling to a serialization library which we again have to drag along wherever we are dealing where we're using the circle so this is going to be quite a quite a heavyweight class which however now also that's a last kind of dependency couples totally orthogonal aspects together drawing and serialization this is things that actually have nothing to do with each other but still i have to deal with all of them there is a lot of dependencies coming in so there may be more this should be sufficient to get to make the point now how do you deal with this and this is now where design patterns come in so we have this naive solution now how do what do we do well we could this is just internal implementation details actually you use a bridge this might actually remove a lot of the physical dependencies this this might work if you have one implementation mostly however probably want more flexibility so perhaps we should indeed use a strategy as shown before but actually we need a strategy for drawing and a strategy for serialization so should we pray to reach for a component design pattern or should he perhaps externalize all of these little details completely should we perhaps use external polymerism this might actually decouple even more strongly but the style still would probably feel like like 1994. perhaps you need a type erasure implementation that very nicely combines a couple of these ideas to create a value type this might actually be the right thing but it might not be because perhaps we actually want to have some kind of hierarchy of of functionality extendable functionality then we should probably reach for decorator but now that i'm thinking about this perhaps you've run in a complete direction at all perhaps it's actually not the implementation of the functions really matters but the functions themselves perhaps this is what i should extract perhaps we need a visitor and then of course there's also the slim possibility that i can resolve a lot at compile time so perhaps i actually don't need these i perhaps might need just something like a crtp pattern so i could now ask the rhetoric question who knows all of these but i save you the trouble my point is there's a lot of choices there is many many possible solutions there is many design patterns to choose from and of course of course there is a lot of important questions to ask so well which pattern should i use what are the consequences of my choice so in other words what are the advantages what are the disadvantages eventually start that ultimately is of course the important questions because every choice that you make will always give you some disadvantages that you will have to deal with later there is no perfect solution but there is an answer luckily there is an answer an answer that it's quite commonly used the answer is it depends it depends which is actually the title of a cpp chat episode episode 80 that had the honor to be in in i think it was 2021 2020 okay a while back so together with phil john tony and tony i actually talked about the solid principles and this was fun this was one hour of talking about structure and code organization it was one hour where we actually could exchange ideas and really it was fun but in the end i asked the question why don't we do this more often this is valuable this is actually good exchange of ideas and experiences and both john and tony actually answered well because it's actually difficult it's actually so much more difficult to talk about this design stuff than it is to talk about features and it is about talking about the new standard this is easy in comparison despite all the specific rules etc design is tough and so no design patterns are not simple definitely not they are difficult the single pattern might not be so difficult indeed but in combination this entire picture this is really difficult so after design in its entirety is difficult very difficult probably the most difficult part of developing software that i'm aware of this might be really the ultimate reason why we don't talk about this often it's just not an answer that's not the answer and so i do think we definitely need to talk more about these dependencies and software decide absolutely and now having said all this of course there's people that talk about self-deters and of course so here's a quick shout out to a few people that i i really enjoy the talks they are really about design so pete muldoon charlie bay and tony fernert sometimes not always and also mike shaw they currently talk a lot about and always do talk about soft design but i definitely want to join this this group and so i actually spent one and a half years too write a book a book on software design which is i believe one of very few publications in this area for that reason it might indeed be something special i really hope i really hope because this is a topic that just does not get enough attention absolutely not so it took me quite some time and i believe that it's actually super important that you buy the book okay no no no not what you're thinking not what you're thinking definitely not no no no i actually checked out kind of the competition i checked out the best sellers fc plus in at amazon de so now this is a german problem i believe and this is what i got not yesterday but a few weeks ago so here number one c plus program german book and number three the xxl wok cooking book so number four is grade two number five the xxl diabetes cooking book come on guys is this the books that you bought to to up your c plus first game if yes then actually here's your chance you can actually change the list by investing in some some real c plus plus book okay now let's let's talk about dependencies and software design at least a little bit and so let's talk about one of the most controversial patterns that we can possibly talk about let's talk about the singleton pattern i know exactly what you're thinking how dare see has he no shame but actually i might not be so wrong just as yen proved this sign kind of seems to be the most popular pattern that we have most people actually know and use singletons so let's talk a little bit about singletons and potentially otherwise it's a problem so first i go back to the design patterns book which also of course designs the singleton a fines and this is exactly the the intent and sure a class has only one instance and provide a global point of access to it so so it's one of the shortest intents it's quite quite simple and i'll there's a simple picture a singleton is say a class that probably has a static instance function this is the one function that i can use to get the instance the unique instance down here now so this is the one function that you need to call if you want to get the one instance everything else that would give you another singleton it's just not able you're not able to call it so any constructors a private copy constructors any in copy operation is is provided deleted or private whatever so you cannot really get access to anything that could give you another one so instances do one thing else it's a pretty regular class you have singled operations whatever you need to do you can get some data you have access to member data it's just special in the sense that there is one and exactly one instance this however and this is please what you promised me now this is not the implementation it will use never please this is one of the reasons why the book is criticized the code examples are just so outdated yeah so this is definitely not what you should do please you promise me okay no seriously this please do not use the code examples from the book there is one common one common form of singleton that people usually considers good that is the so-called meyer singleton which got myers actually defined in his effective c plus first book in the third edition it's item four and it's definitely quite a clever implementation there is the incense function same name which returns the reference to the one database that we have that database being my example this is not a function not creates a static local object this is the one database when i enter the instance function for the very first time this instance is created since c plus 11 even in a threat safe way and returned directly afterwards when i return to the function so if i call it another time i just get the same instance it's initialized exactly once and so it will now always get the same instance again and again and again until of course at the very end of the of the program this dbs actually destroyed again yes so there is no resource leak of any kind because this db object is registered via the ad exit function it's destroyed at the very end reliably you don't have to do anything then of course as i said there may be any operation on the database so i can read and write and please imagine there's a few more but most importantly i want to make sure that there's absolutely no way that i can get another database so any kind of constructor is so it's in particular the copy constructor and something like the default constructor are in the private section not this little detail here this little lead here is is interesting which is now a little technical implementation detailer now i'm deferring from the design perspective but if you actually default the default constructor in the private section fascinatingly you can create databases whenever you want to because until c plus is 17 if you use an empty set of braces you're using value initialization and value initialization considers a database as potentially as a an aggregate type and so aggregate initialization actually doesn't have to call the default constructor but just creates the type as such which is an interesting loophole so until c plus is 17 please indeed defined the the default constructor in order to truly avoid any kind of of database instantiation since it plus 20 however you definitely can default that so let's use this database to for for other so let's keep this in mind for for later our details now honestly and this was the reaction you also had most developers are not particularly fond of that why not well again to quote robert nystrom anytime you make something accessible to every part of your program you are asking for trouble and that is definitely true for singleton's because well you consider an anti-pattern because they represent global state they do and again to quote some famous person michael fedes from his book working effectively with legacy code the singleton pattern is one of the mechanisms people used to make global variables in general global variables are a bad idea for a couple of reasons and so just to give you a few that hopefully are kind of obvious so global verbs are generally a bad idea because they represent mutable state and mutable state on a global level means that anyone can write and read whenever this person wants to it's just so difficult to control in particular in multi-thread environments so difficult to deal with so they're really hard to reason about generally if you sit be a singleton and immediately after you get a call again you might not get the same value back very hard to reason about and then in particular they also are subject to the static initialization audio fias which means that there is a potentially a binding order of things initialization order so the common advice is don't use singletons which is indeed where the discussion usually stops don't use singletons but i've seen that well most people actually use it why do you see many people use singletons if actually we say as a community this is not a good idea well to put it in the words of guide davidson globals are bad okay and i actually talked to myself i was not aware of these little connotations of the british language and k actually means like we understand each other right so yes yeah sometimes perhaps but generally not right so yeah we should avoid them but there is some intrinsically global aspects in our programs that always are like the memory memory is always global we have to deal with this somehow time may be a global resource that's something that you definitely need to synchronize reliably the system-wide configuration many projects this is the one thing that people need everywhere in the code then in computer games in particular the audio the display device this is things that well should exist exactly once the logger and you may have a couple more ideas what what is truly from your perspective intrinsically global there are those aspects but now if we should not use singletons then what what should you do well one thing is of course we could pass these things to functions well we could just have a lot of arguments more arguments but this is not really attractive it's also robert nystrom says there are times when mainly the passing around an object is cretaceously cretaceous or actively makes code harder to read some systems like logging or memory management shouldn't be part of a module's public api and so it seems that sometimes you just need singletons sometimes this is indeed something i should stress sometimes but i believe there's an even bigger problem something that people unfortunately do not see in in that form singletons do create dependencies dependencies on concrete implementation details things that happen in this singleton and as it is usually invisible dependencies some were in some function somewhere in a code base you now call the single it might not be even aware of the fact that it's needed there it's invisible it's not part of the signature of a function it's also artificial in many cases definitely bad it's a dependency that yeah let me show you so yeah okay one slide in between singles make it difficult to change extend and test because of these dependencies so let's return to this database example let's return to this little code that we had abstract from this a little bit let's say that you just use this from some widget and some gadget the widget is here some of the code base the gadget is done here this may read this may write it's not super important but they're all definitely at some point have to use the database now they have to read and write information at some point cool and of course this is what you like to have this is again what we would call an architecture all the errors go from some low level to the high level cool but once again what did i say was high level so high level is stable this is the things that themselves have low dependencies on the low level i said this is the things that are more volatile malleable that's where the high dependencies are okay trick question the standard library or let's just say the esl part of the standard library where in this picture is it is it up in the high level or is it somewhere in the in a low low so it's on top it's here the sl is kind of the highest level we have you have all the dependencies to the sl but the sls no dependencies on you hopefully so it's on the highest level that that we have and now from this picture from this point of view the database is now suddenly something like the stl part of the standard library which basically means it never changes which however is absolutely not true the database of course represents an implementation detail it's something that will change the database is updated we choose a different vendor we rewrite the class it's a big dependency so this looks great but actually this database is at the very bottom of the entire architecture this is the reality everything depends on the database which is itself a very specific implementation detail and so this is not an architecture and i believe this is why people tell you not to use singletons there are architectural destroyers whatever you try to plan ahead in terms of architecture you can very easily destroy this completely fundamentally by implementing singletons in this way so after all then singles are pretty bad we shouldn't use them right but then again we sometimes need them for these these intrinsically global aspects so what do we do well it might be very surprising to learn that there are a couple of single leg instances in the standard library seriously and honestly they work fantastically so let me show you one example of how this actually solved in the standard library so this is now an example that i didn't invent this is from cpu reference somewhere in the realm of memory a polymorphic memory resources pmr so i start with an array of a thousand bytes which is totally enough for this little example yeah it's not a lot of memory but still and this array is totally uninitialized but this is now supposed to be the place where i that i use for allocating memory for instance for the reason because i must not use dynamic memory so i want to use static memory only so now i use one of these pmr classes a monotonic buffer resource i pass all the information of this little by the rate to demonic powerful resource so the pointed to the first byte data the number of bytes the size and therefore make this this raw array ready to be a source for memory and so i now pass this my pointer to a pmr vector which by the way is not another implementation of vector it's the same class but the allocator is dealt with differently so a vector of pmr strings and now what i can do is i can very very easily just add strings and then print them fascinatingly all memory acquisitions in the center program go into this little array that's not a single new chord and still it works quite smoothly nice nice indeed and in fact for me this pmr namespace is an eldorado of design patterns it's really fascinating but now for our purposes there's just one one little thing that i want to draw attention to this little function call here we actually need to configure how a monitor buffer resource what it does when it runs out of memory this might eventually happen by defaults it would just call new get some new memory but this is of course not we want to do so we now configure it with a null memory resource not memories of being another allocator which however never allocates it always fails it always throws an exception now hence the name null memory resource but now this null memory resource is special because what you get if you call this function is the null memory resource there's one so this thing now indeed acts some as some kind of singleton let's take a look at the definition again the intent and sure a class is only one instance and provide a global point of access to it now we have a point of access we have the function not a memory resource and as the documentation says on here the same value is returned every time this function is called every single time it's the only one well try to create a copy of that because all you get is a pointer to some base class you don't even know the type of that fella you have no idea what it is you don't know the name you don't know the type you don't know anything so how could you create a copy so this actually does kind of the same thing as as we expect from a single one but it's different of course cool nice but there's one one last thing right now in this piece of code we still depend on this particular say single this this particular allocator [music] now if this would be some other function that we want to deal with elsewhere then of course we would like to gain a little flexibility we'd like to customize which allocator is used at this point yeah not not this one the specific one so what we want now want to what what we might want to do is we might call get default resource which is the function that gives you the global memory allocator set and set for the system the system why it's default allocator and get default resource might actually give you the idea there is also a set a default resource which you can use to actually define customize the default allocator for the system oh so at some point we can do this up front and so the other code does not have to use a specific format it just uses what is has been defined up front very nice for testing indeed but now when i think about this indeed this gives us the ability to customize this for anything as i said we cannot test quite easily by just using a specific resource that for instance logs or tracks all the allocations it's nice so we have the ability to inject the dependency to the allocator right here in this this default resource does this sound familiar i hope it does yes one more instance of the strategy design pattern different form again but it's the same idea we are actually able to customize the behavior to a liking and this now might be the idea this might not be the way to actually repair the database example so it does not work because database is a concrete implementation detail it is a concrete dependency that we want to get rid of and so what do we now just need in this context to to repair it is some kind of abstraction some kind of abstraction that inverts the dependencies and so let's do that let's actually deal with this by starting to introduce the abstraction which i now named persistence interface which is a little more general doesn't have to be a database it can be anything could be a file it could be any any system that stores data so persistence interface that is a traditional base class so we have a virtual instructor cool we have some read and write function note not virtual because i'm using another design pattern the template method design pattern these functions at this point could just call to read and do write and this is the virtual functions that driving classes now need to implement this is the two and of course it's light aware so assume there is of course arguments of some some sort so this persistence interface is now the base class for all kinds of persistent systems we know in the database.h class make database derived from this persistence interface and we make it just implement read and write which is just a little refactoring to actually get these things so that functionality in the specific form cool not a not a lot of work indeed no we add get persistence interface and set persistence interface now some people have asked why pointers could it be references yeah sure you could also use references purposes is even better not my my primary point of attention right now so we provide these two functions to actually allow people to change some globally set persistent system which might just introduce here as an external burial which nobody needs to know about it is the one global thing that yeah we probably should hide a little bit but now in the cpp file we actually implement this functionality so first of all initially this instance may be null nice and another pointer and then of course we have set persistence that if you're given any kind of persistent system we'll set the the instance to some value cool quite kind of simple but get persistence what do we do here well of course by default we could just return the instance but well initially of course it's null so we now have to by default set it for instance to the database so if this has not been set if the database is not pointer then and only in that case actually create this static database that we've seen in the myers single and we just remember a pointer to that database in our instance variable and return this one okay but now of course every time you call get persistence we will check for now every single time which might not be exactly what we have in mind and also this might later change some settings so if somebody explicitly sets this tunnel at a slater point we change it again so we definitely want to make this initialization once and exactly once how do we do this well kind of in the same way and then thread safe way by just wrapping this in what you call an immediately invoked lambda expression so we introduce a static pool in it which is initialized by this this little lambda here and i know it looks scary but yeah people get used to it i've heard so it doesn't have to be any arguments it's just a little local function that eventually returns true or false it doesn't matter you can return any value that you want to because this is totally artificial thing you initialize this thing once and exactly once but in doing so you deal with initializing the instance if it has been set okay cool then we already have one if it has not been said that we then we create the database and remember that one now i've given this talk before not that this talk the the singleton thing and immediately people jumped at me and said it's not threat safe i know it's not at least the initialization is but set persistence and get persons are not threat safe but actually i seriously don't care it's a global value it is a global thing if you feel like setting the persistence interface or let's go back to the allocators if you feel like setting the allocate at some point in the program where other people have already acquired memory and now i don't actually know how to give it back well then it's your problem i don't care about threat safety here there is a certain discipline that you have to use when you deal with global variables so no this should be done up front start of a test and the start of the main function whatever you call this the set persistence interface function once once in the program and then later you have exactly this one thing that have configured globally and so you fixed our architecture at the top you have this persistence interface based class this is now what widget and gadget depend on they don't know anything about databases they don't know anything about any specific implementation they just depend on this abstraction and a database for still formally on a high level because it's still part of some some database it's totally unknown nobody knows about this little thing and therefore it really is just a hidden implementation detail you however are now able to just implement any interface any persistence interface that you want to for testing purposes for dealing with this particular problem differently you can do that on your end and deal with this this entire thing correctly and again suddenly all the errors all the errors go from bottom from low level to the top in a high level this is an architecture all right i would now call this an acceptable singleton acceptably in quotation marks this is truly an important point it's acceptable because we've actually dealt with this dependency inversion we do not depend on the thing anymore but on some some abstraction so it's acceptable because we don't no longer depend on the implementation details and suddenly we can change how we can extend our implementation at will whatever we need whatever we require in a specific context we can do that and suddenly also as i've already pointed out so we can test this kind of easily we do not have this hidden thing that nobody knows about anymore we now have the ability to inject testing code so this now enables you to cope with the intrinsically global abstracts sometimes against it's a global thing so i have not given you a free pass to use singleton snow no no no no no no the same advice is true do not use singles but if you have to cope with these few and there are few global aspects then then in these few cases you know half a recipe to actually deal with this in a more in a better way so did you now invent something new okay no not really i have to admit that this is not my invention oh my no no no actually there has been this book by robert nordstrom where this this pattern has been described for years i actually think he has written this in the beginning of the 2000s somewhere so this is the service locator design pattern provide a global point of access to a service without coupling uses to the concrete class that implements it the patterns are there the the patterns are there so as i said before hopefully i've not tried hopefully manage to show design patterns are pretty much everywhere we just have to see them we have to realize what is at work we have to see the advantages that you get from them but also we should be aware of the disadvantages and so as a summary software design is not enough to thought it really isn't it is essential absolutely essential for the success of a project i've claimed it's it's indeed the essence that you must not forget but let's start pretending that c plus is all about features and standards there's definitely so much more to talk about so let's start to talk about the really important aspects of software which is software design and in particular let's talk about design patterns they are everywhere absolutely and so we should learn about the different patterns i don't know all of them no definitely not and we definitely need to learn about the advantages and disadvantages why do we use these different patterns in which forms do we use these different patterns to achieve the things that we actually want to achieve and so let's make software easy to change easy to extend and easy to test and so let's start to talk a little about the thing that really matters let's talk about to break dependencies so thank you very much [applause] so i know it's late but are there any questions if it's a singleton related question no don't use singletons no no it's not it's it's a you mentioned a taco oops that the point of that stock is not that much that op is dead as a practice as much as like it's a huge performance problem on modern machines to have bold processing of iterational objects because it's just like tpus are really bad at it yes that's exactly the point of the talk the title however suggests differently it's chosen pretty aggressively but as also said it's a talk from the gaming industry and they indeed suffered a lot in the in the beginning from oop performance yeah but i guess then but my question is how do we adapt all those patterns because again the whole a lot of them are based on virtual and a bunch of like it reduced processing which again is really on performance and if you're doing c plus plus you're here for the performance if i want virtual i'll just use java yep but you've seen that strategy is pretty much everywhere strategy is even in its template form exactly the same idea so i don't think that it's about virtual functions this is one way how you can introduce abstractions one way of many you have templates too we have function overloading i think we just need to explore what options we have to implement these things and i did do a couple of talks about type erasure which i believe to be the superior form of dealing with many of these patterns from an implementation point of view okay yeah thanks claus for the nice talk very good topic but to clarify one thing maybe i'm wrong but if you have methods virtual methods in your interface and you make them private you cannot override them in the inheritance can you oh absolutely you can the private label is an access label it's not a visibility label as soon as the driving class actually sees the functions and they're always visible you can overwrite them easily so this is something i also have to demonstrate in my class usually it's it's confusing but the label is not the hindrance but what you cannot do is you cannot call the functions so the derived class the implementations in the drive class cannot call the base implementation because it's private if you need that then you make the functions protected which sometimes happens for instance in the decorator design pattern and then what's the advantage to make it private in the first place over making it protect it because it's virtual and abstract so you cannot call it anyways i did not explain the template method design pattern which i personally feel is again a huge step in decoupling things decoupling the interface of callers from the interface of driving classes now you have two you have the public interface and you have the private thing that you overwrite this again gives you a lot of flexibility and changes become so much more easily if something changes later that's the reason why i do this but not just me also in the stood pmr memory resource class you'll find exactly this pattern for exactly that reason changes becomes simpler changes for the library implementers but you also get that if you make it protected don't you okay so i cannot just say why this is chosen instant memory resource stud pmr memory source but probably it's not supposed to be caught i guess yeah i'm gonna have to talk about it okay so victor i'm really happy to see yet more talks on software design i think it's a worthwhile our time my thing with design patterns is that the term implies some kind of universally applicable recipe and codifying existing practice in some recipes that we can uniformly apply in our code and sometimes there's value in in uniformity and recognizing and identifying these architectural constructs however they not they're not always conducive to optimal solutions in concrete situations that we might have so how do we reconcile the inertia or the tendency to build something that is recognizable or fits within particular pattern with finding an optimal solution in a very concrete case which might be in conflict with some idealized version of such a pattern and how would you exactly what do you mean but you also said it in the end it's an idealized solution it doesn't have to look this way at all you see that the strategy pattern which i believe is one of the most common ones comes in so different many different forms but it's always the same idea i extract some implementation detail because i don't want to depend on this however you come up with whatever solution you come up with in order to achieve that it will be a strategy so i don't think there is so much a common solution that you should always use i think it's definitely much more about the intent what do i want to achieve how do i want to structure my code that's what i try to truly point out in the book that it's always about the dependency structure what should depend on which in my software what do you know what do i not know and i think this is what we should focus on mostly not about this is how we've implemented this in this sorry in the gang of four book but more on what is the dependency structure i hope this helps so focus on on the goals of the pattern rather in terms of mechanics exactly yes okay thanks so andreas hi thanks for the talk i have a question about singleton oh no next question so you mentioned that like one of the problems with singleton is that it basically creates a global shared mutable state if i have data that is immutable is is that safe to put in a singleton always or do you see problems with that this is a very very good question i know particularly chose a database example also this might not be a great kind of singleton but because you have to read and write and then this makes so much more sense kind of but as soon as you have something that is constant as a global constant or at least uniform in flow direction so for instance a logger only accepts data but you never read from it in that case it might actually work much much better if you have something with a uniform direction this this kind of global might work in your favor but still the idea that i showed might might still help yeah configuring a logger so in test you might not want to write really to file lock the things now just you have other problems and so this might still help so to shorten the answer this might work if it's truly just unif um unidirectional data flow it's not as bad but you have to keep it this way that's probably the thing that requires extra attention okay thank you okay another singleton question okay then you're fine yeah thanks thanks for the talk i have any questions so you mentioned about the myth in the children's room okay he doesn't know how to deal with that maze you you want to know how it hurts if you stick on a lego prick right yeah okay now so since he doesn't have the where to start and how to clear that mess so are there any strategies or something means especially if you are new on some project and there is already a lot of mess how we can improve those things there's no general answer if there would be i would be out of business no but one of the things is usually to identify the pain points the real pain points and start there in a localized environment you cannot change everything right away this is just too much too complex mind-boggling so start in a local point things that hurt most and once this is fixed actually you actually see the the wood again a little bit it's clearer and then you take the next thing and the next thing it's not easy i don't say this is easy it's not obvious what to do but it's the only thing that does work start somewhere and choose the one that the one thing that hurts the most thanks so yeah it's an online question how do you know yeah so indeed an online question why can't we use threat synchronization primitives for the global mutable state with the thing pattern or why did you not do you mean here in so i cannot ask you so i assumed that this was about the set and the get if you call said anywhere in the program if you really feel like this is a good practice then since it's a global thing it is indeed like pulling the rug from so on from some under somebody's feet so for all the program i've used this allocator now somebody sets the global thing i want to give the memory back but it's a different allocated it might not have any clue how to deal with this piece of memory that i'm not giving back so if you truly think that setting a global thing from anywhere in a code and this is where we have to deal with threat safety is a good idea then yes you have to deal with threat safety but i would advise against calling said from anywhere and this is why i don't care about it okay so your argument is maybe it's also out of scope for a keynote but yeah just you could use those like have a mutex there if you if you needed that in your application but exactly your case you say it's better to like do that on the main thread to be honest in the standard library these kinds of signals are protected a little better than mine but i honestly don't see the point it's global okay okay maybe my opinion okay next question i'm just a follow-up to that if you've got any statically created objects which will make in use of like the default could you hear me sorry yes thank you if you've got any statically created objects which are making use of like the allocator surely it's never safe to set it from anywhere in the program correct yeah yep and this is exactly why i just as the in the stat library i say set it right up front at the very beginning of a test or at the very beginning of programming the main function and i never look back this is the thing that you will use but even if you said it first line of main if something's already used it like in a static you know a file scope that's the usual thing that may happen because singleton should always be available that's the exactly the problem that you have to take care of so if you truly have dependencies between singletons then you have of course significantly make your problem more difficult to handle i'm in the you know it might yeah it might not be even be a singleton it might be some global thing that's the usual problem of clothes correct so if you want to deal with this put in a put in your mutex something but i'm not so much thinking about that i'm thinking about the aspect of it okay at start up the applications use this to allocate something yeah first line of main someone changes the allocator program terminates cordons yep yeah you know what's happening right now you're talking again about implementation details that's again exactly what i usually what i said in the beginning very very dangerous to ever use that because you might you might say okay well it's fine we just make sure we don't write any code that depends on that which is ever we ever make any static objects of yeah two and a half years later somebody comes along i didn't you didn't write a big sign on the wall saying never ever use this never make static foo because food's using pmr yeah yeah someone comes along and does it i i don't say you're wrong i said you're absolutely correct it just depends on you want to deal with this or not the flooding conversation is not particularly difficult it's not even it's not even about the synchronization it's about this aspect that you you've changed the allocator under this yes it's like that that's that's the issue you know this stuff's not going to clean up now yep no i get a point yeah thank you okay all right no more questions then thank you very much and have a good trip home [applause]