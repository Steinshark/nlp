what is up guys welcome back to part two of our adventure through the cosmos of developing a driver for the raspberry pi in this tutorial series i'm showing you guys how to make a driver for the raspberry pi that has access to the peripherals of the gpio interface now i know these drivers already exist this is unnecessary work but i think it's a really good teaching point on how to make drivers on the raspberry pi that access things that we may want them to do to provide custom functionality in the kernel in my previous video we talked about why drivers are necessary and then eventually how to get the build system of the raspberry pi's kernel headers to run such that we had a hello world kernel mode module but the problem with that was that it was largely useless and that when we opened it it turned on and we closed it it turned off but from the user space side of the raspberry pi we were unable to use it so in this video we're going to be talking about how we create an interface into a kernel mode driver so if you remember in our previous video we were trying to access the address down here obex 3f20 this is the address of the gpio interface peripheral in physical memory the problem as we talked about before is that by trying to access this address from user space and the raspberry pi we illegally cross two boundaries we legally cross the memory boundary between user space and kernel space and then we also legally cross the memory boundary between kernel space and actual physical hardware to the gpio so to solve that we create drivers and drivers provide this kind of seamless interface where we can close our eyes and go touch that part of the processor and not get yelled at by the processor right so the question is then like okay we have this driver but how does user space actually talk to the driver to get access to kernel space and the way we do this is using two kinds of methods there's one called a device file device files live in slash dev they look like a file but they're not actually a file they're a special file that maps into the kernel and provides read write etc functionality into the kernel that the kernel can then do things with that input from the user space the problem with that is that device files are meant to map to a single physical device right so if you look at like slash dev sda or slash dev tty usb0 they are meant to map to like actual physical things they're called device drivers because they map to devices now there's a different system we can use called the proc fs file system and the procabs file system is actually meant to do more generic things not maps particularly to a single hardware interface but instead more generically used to provide info about the os to user space from the kernel and then act as a control interface for more generic software type things so for this tutorial we're going to be creating a proc fs file in slash proc that we can read and write from and it will provide output and input to the kernel mode driver that will control the gpio interface and just to give an example of what you know the proctors file system looks like i'll pull it up real quick here in my vm i'm going to turn off my raspberry pi for a second it's still on just running in the background so we'll go to slash proc i see a bunch of files here none of these are actual files these are actual all special mapped interfaces to the kernel that do certain things for us if i do like cat proc net tcp that call actually goes into the kernel the kernel parses all of the connections that are running on tcp and then we get this output here that goes to user space so it feels seamless it feels like a file but it's actually not so we're going to go on a raspberry pi and make a low level learning gpio proc fs entry that will take our data and parse it and eventually it'll control the gpio interface via that so what i'm going to do is get out of here and i'm going to pull up my raspberry pi so i ssh into it just like before and i pulled up lx terminal so we'll go to our driver here and i've made some modifications to our gpio driver here i will push these to get at the conclusion of me recording this video so if you remember from before we had the very basic bar bones driver where we had the init function we had the exit function and the init and exit function said hello i'm turning on and then hello i'm turning off and then they would return and then via the module init and module exit functions we were able to hook those into the boot up of the driver so when we did ins mod for install module and rm mod for remove module these two would execute right so what we've done is we've added some additional code that provides the kernel mode driver the instructions to create the low level learning gpio file to the proc fs file system so we're going to start here right we're going to walk through this code and kind of tell you what it does so we have a variable in global called low level learning proc and that is just a proctor entry we use that to track the object that comes out of when we create a procfs file system file right by running proc create we specify the name of the proc interface that we want by saying 0 666 and octo we're able to let anyone use this because i want not only root but other users to be able to access our gpio driver null is just a set of flags that we send to the proc create function we don't want that to have any value it doesn't do anything for us and then we set the parameter here to the address of this low level learning proc fops structure now if you're doing this on an old system by old i mean before linux kernel 5 4 this is going to be a little different this is written for after linux kernel 5.4 where instead of using a file operation structure we use a proc op structure okay so we have the structure here and what the structure does is it tells us when the user reads our file so when they type like cat proc fs low level learning gpio it will run this function and when they write to it it will run this function so now we have the special file that if it's read to things will happen and if it's written to things will happen okay cool so now we look at what actually happens so if the file is read by the user we're literally just going to say you know hello cool here's your data okay we're going to give it seven bytes of hello and the way that works the low level learning read function takes as input a buffer from the user that we're going to be able to put data at right because it's b it's reading so we need to provide it data that it's going to have red and then the size that it asks to read and then an offset pointer into how much it's already read we're not going to worry about that right now so then we run this function copy to user so because we're in kernel mode we need to copy data out of kernel space into user space we're going to use this copy to user function to copy to the user space buffer hello new line and it's seven bytes long and we also have to return the length that we have written which is seven okay this one isn't as important because i don't really care what happens when the user reads our procfs file system what i do care about eventually is i want the interface for our gpio controller to be that i write a pin number comma one or zero and then that turns on or off depending on one or zero that pin right pretty cool so the user is going to then have to write to our proc best file to make that happen so similarly when we write to a procfs file this function gets ran and there are three parameters because it's being ran as a file right it's being tracked as a file there is a a struct file that represents the file as a user sees us there is the user buffer right the user is writing data to our kernel mode driver so this contains the data the user is writing this contains the size that the user is writing and then this again is that offset we're not going to worry about so i actually have a data buffer that i control myself so i need to have somewhere that once the user gives me data i put that data right so every time that they write to me i clear out this data buffer to make sure that the user does not see other data that used to be in there if the size that they write is larger than my maximum size so let's say they gave me 4096 bytes and i only can control i can only take on 1024 i want to cap off how much they give me to prevent buffer overruns in the kernel right that would not be good and then similar to how we did a copy 2 user before we're going to copy from user the destination is the data buffer in kernel mode here source is this user buffer here and size is the now capped off size that they gave us from the function right and what we'll do with that data is we'll say in d message oh hey welcome to the driver you said our data just to confirm that we are able to take data from the user and put it into the kernel and then also we need to return to the user the amount of data that was written so that the new interface for the function right can properly behave right so now that we've set up these two functions to happen when reading is happening and when writing is happening we use proc create when we start up our driver and then also just like in reverse if we exit the driver we want to make sure that we cleanly remove the procfs file system file by using proc remove and then returning so with that being said we've created this driver we can do make here to build it and it does take a little bit of time because we're not including more header files than we used to not a big deal something to be aware of a couple errors here again i'm being a bad programmer i should be checking the output of copy to user and copy from user but i'm not unfortunately that's just something we're going to all have to live with so we'll do sudo ls mod grep for low level learning to confirm that it's not running it currently isn't good so we'll do sudo ins mod on our kernel mode object or ko this should run and not crash the kernel good and just to confirm we are still running awesome so now if you ls proc we now have low level learning gpio in the procfs file system pretty sweet so now we actually can catch this file excuse me we can cat this file and we will get hello infinitely that's probably a bug but it gets the point across great but the more important point that i want to make is that you know we can pump data into the driver from user space right like from the terminal we're still in user mode here we're in bash hello there colonel and we can write that with the carat driver into proc low learning gpio right boom so we'll do that i'm gonna do echo tac n to remove the new line because otherwise my example looks pretty gross so there's no new line here we just say hello there kernel and write it into that file cool now again that file does not actually contain this data because it's not a real file it's a oh excuse me i tried to execute it i tried to cat it it's not a real file it still says hello but what we can see though is that in d message at the very very end you said hello there kernel and that got brought to the kernel mode driver and we printed it out cool so we're one step closer to our gpio driver being complete in our next video what we're going to do is we're going to parse the data that we send to the driver and use it to turn an led on and off via the gpio peripheral so in this video we explored this is how we interface with a driver we use either a device driver file in slash dev or a prock fs file in slash proc and then we set up special functions that get ran when we read or write from that file so that we have you know user data is able to be stored in the kernel guys if you enjoyed this video i really appreciate it if you hit like hit subscribe and i'll see you guys next week when we finish this up in episode three by making the gpio interface actually flip bits on and off that change peripheral interfaces thank you so much guys [music] you