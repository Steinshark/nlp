the new linux privilege escalation is absolutely insane the bug allows an unprivileged process that's able to access the net filter api on the linux kernel which is default behavior to run arbitrary code in the kernel and eventually become root completely compromising the system this bug is wild and in this video we're going to talk about what a privilege escalation is in linux how they typically work and why the techniques that the author of this bug used are so novel so unheard of like brand new technology truly amazing also if you're new here hi i'm l level learning this is a youtube channel where i talk about cyber security programming so if you want to learn about those things or just hang out with me hit that subscribe button i really appreciate it now this exploit goes extremely deep i'm going to link all the information about it including the blog post and the github proof of concept in the description below so go check those out now if you're new to the world of exploitation or maybe even cyber security a privilege escalation is an exploit that allows you to while running as a certain privilege become a higher privilege the classic example is that if you run as user auntu for example and an auntu vm and then you want to become root you don't have the root password by running a privilege escalation you can become that higher privilege user like root without knowing the credential the way privilege escalations work is a lot different than traditional exploitation to get access to a system typically you have some kind of service that's running that has a network facing code that processes data and you exploit some vulnerability in that network code to get code execution on that system the difference between those kinds of exploits that get you the access and privilege escalation is that you're actually exploiting a vulnerability in the kernel itself the kernel being code that runs at a higher privilege level the operating system the kernel is just code and like any other kind of code there can be vulnerabilities in this code for example an oldie but a goodie is the vulnerability dirty cow or dirty copy on right that took advantage of a permissions issue in the copy on right p functionality in linux kernel in about 2016 about 8 years ago that allowed any user to overwrite the data of any file on the system whether or not they had permissions to touch that file that allowed people to do is overwrite the contents of an elf that had the set uid bit that gave it access to root when it ran like ping for example and was able to use that to turn set uid binaries into shells allowing you to become root without having root credentials now you may be wondering if my code is user land code code that runs in user space how am i able to take advantage of a vulnerability in the kernel my code doesn't run in the kernel i can't go and touch kernel code and that's a great question and the answer is actually what makes kernel exploits so interesting now when you write any code in user mode when you write code in c in linux your code is generally pretty boring a bunch of reads and writes in and out of memory using registers in the cpu but eventually if you want your code to do something interesting like open a file create a socket you have to ask the colonel for permission to do this and you do this via what is called a system call or a cis call you set up the cis call with your arguments and say hey colonel i want to access this file can you execute that task for me because opening a file on the file system is a privileged task that only the kernel can do so the kernel goes and takes your parameters you've given it runs out runs the task and brings you the results when you ask the kernel to do something the kernel has to go and run its code and handle your input parameters now the vulnerabilities arise when if the kernel doesn't properly sanitize those inputs or if the memory within the kernel based on your inputs or mismanage you as a user in user mode can pull the cis call levers in the right order to effectively take advantage of vulnerabilities in kernel code and that's just how this exploit works now this new exploit takes advantage of what is called a double free in the linux kernel a double free as name implies is when in code you accidentally give the user the ability to free free the same object twice the reason this is bad is because once an object is put into a memory allocator free list twice you're able to allocate it one time where you now have a use after free you're able to allocate the objects and then still have access to the old pointer with the free data you can then use this use after free to corrupt the metadata of the free list and then in this exploit get arbitrary access to any memory address in kernel space the double free vulnerability arises in the net filter sub system within the socket api of the linux kernel the kernel has a bug where it will free the same packet twice depending on the routes you set up through the net filter by doing this in this exploit they're able to take an arbitrary user packet an ip packet and double free it now by doing this you know you may be trying to figure out okay so we have a double free we have a use after free in the kernel how do we take advantage of this and this is where this bug gets extremely wild now again full disclosure i did not find this bug i did not make up this bug i did not make up these graphics i'm giving full credit to the author who i will link their blog posts or twitter everything in the description below we can kind of go through the basics here using their graphics so here they talk about how they're able to do a double free in what is called the skb or the socket buffer over here they're able to do some stuff where basically the linux kernel will it'll be aware of a corrupted free list and they have some pretty novel techniques where they're able to spray a bunch of udp packets into the socket buffer free list and it will prevent the linux kernel from being aware of the corruption in the middle of the list once they are able to have a double free in the socket buffer free list they're able to use that to arbitrarily overwrite the next pointer that points to the next thing in the free list and allow them to arbitrarily allocate what is called a pmd or a page middle descriptor now a pmd is one of the components in the page table system of the linux kernel right so when you have a virtual address like i said before at as he indicates here in this graphic you have your virtual memory page but parts of that address actually are used as indexes into a series of descriptors that are a lookup table into physical memory right so a virtual memory page will map to a physical memory page you have the pgd the global descriptor you have the upper descriptor the middle descriptor and then a final page table entry which points to a page by corrupting the socket buffer free list he's able to allocate a fake pmd the pmd being the middle layer of this page table lookup system and they're able to double allocate a page table entry that corresponds to the kernel right so now we have a page table entry that it points to the physical address of the kernel they're then able to use this to overwrite the mod probe path which will point to their arbitrary binary that they want to run right so they overwrite the kernel to control mod probe path which is a path in linux kernel that instead of running the mod probe binary it'll run our arbitrary thing so instead of running this ff thing they will be able to run mod probe path which is our program right and it gets executed as root so again truly like one of the craziest techniques i've ever seen ever in exploitation the fact that this author was able to do a double free in the kernel bypass all the detection also they have to pin this exploit to one cpu because every cpu has their own page table lookup descriptors and they have this thing called the translation look aide buffer which will cach all of these translation lookups so if you don't flush your tlb then you can't do this exploit right so not only do they pin this exploit to one cpu they figured out a way to flush the tlb they figured out a way to given a double free in the kernel point it to the page directories of that process inject a fake page table entry to point to the base address of the konel and then hook the kernel to instead of having mod probe path execute arbitrary data which is their ultimate program the world of kernel exploitation is truly amazing i think it's really really neat it's still an area that i have a lot of work to do in but i hope you guys learned something here if you did hit that sub button really appreciate it and then go check this other video out about a crazy new bug in the apple silicon it's truly amazing see you guys there