we are going to look at the countdown numbers game so i used to teach programming and i used to teach the countdown letters game and that worked out quite well i always liked teaching to the to the problem not at all so it was quite nice to have that focus of the countdown latest game and i was always thinking next year i'll do the numbers game because i'll be able to work that out and find a solution to that and over the years i didn't really find one so what i ended up doing was brute forcing the entirety of the countdown numbers game so i've simulated every single possible game that can ever happen within countdown numbers countdown is a television show focused around the letters game predominantly but you have the numbers game as well and what you have to do is you have to pick six numbers and with those numbers you have to achieve a target score by adding multiplying dividing and subtracting it's got to be a three digit number so between 100 and 999 [music] so they actually pick they pick big and small numbers so big numbers are 25 50 75 and 100 and small numbers are 1 to 10 and they pick two big numbers and four small ones and then you have your six numbers and then you have to go and make a target number with those one big number okay we're gonna give you a hundred the rest is small should we one two four five and seven we're gonna make a target this i think go on well i'll pick a number off my screen right now the duration remaining on one of my memory cards is two two six two two six so you've got to make 226 using these numbers i can see that straight away two times a hundred yep and then you've got the six is the one and the seven yep and then you've got four times five is 20 right yeah you've solved it you've done it there so yes this is the basic crux of the games there's some things we can do and some things we can't do we can't concatenate numbers so we can't put two and four together and make 24. we can't ever go into negative numbers and we can never use decimals and one more thing to say the solution doesn't have to use all the numbers i think you used do you use all of them you don't have to yeah and i decided to force this which seems i think a little bit less difficult than it actually was so we hopefully have some interesting statistics at the end of this but so what the goal of what we have to do is we have to mix up every single possible number every single permutation that can happen with every sin single symbol that that can happen to so plus minus multiply and divide which results in a lot of numbers so we've got some of them here so assuming we have just six random numbers and then what we need to do is we need to find a way of putting add minus subtract and divide in here we're gonna also need to use five symbols okay so we'll just tack these on at the end so plus minus multiply plus and divide okay we need to find a way of combining these in every single possible combination so i tried many ways of doing this because if you have for example a sum like this this can be interpreted in many different ways so for example if we put brackets here that means we do this operation first so that means we do five minus three which is two minus two which equals zero if we have the same sum and we put the brackets here we'll do three minus two first which equals one and then subtract that away from five which equals four so we need a way of representing which way we need to go about doing this ultimately when i was programming this i had to solve this problem and make sure things were interpreted in the correct way so what we did is we did we used something called reverse polish notation which luckily you've got a couple of videos on rpn reverse polish notation it saves the interpreter or the compiler an awful lot of effort so just give you an example of how this works which is quite good when it comes to how i've written this at the top this equation here so 5 minus 3 in brackets minus 2 0 would be written as 5 3 minus 2 minus the second equation is written as 5 3 2 minus minus so the actual order of where the symbols come up denotes how the equation is going to be handled once this was solved it means we didn't have to deal with brackets because i did try dealing with brackets and that was just a nightmare this means what we can do is we can actually have our six numbers here and five either five symbols of which what we're going to do with it plus minus all of that and then what we can do is we can just shuffle them go through every single permutation of this list even what you've written there looks like quite a daunting prospect yeah remind the entire numbers going it is daunting it's daunting because you've also this isn't all of the combinations of symbols you can use either so we've got to deal with that as well now there are 11 things here so in order to shuffle these it would be 11 factorial which is close to 39 million but we've got an issue here because we're only using this these symbols and there are lots of possible symbols we could use in here and what i found was there's actually 54 sets of different symbols we use if we only care about the count of each symbol as in how many there are in the set we don't care about the order because everything's being shuffled anyway there were 54 individual sets of these that we could get so when you say that you mean it might be plus plus plus minus minus it might be plus yep exactly and we've got to because we're brute forcing the entire countdown station we want to find every single way it can get every single number the amount of possible combinations we can have is 11 factorial times 54. 11 factorial is 39 million 54 i think i've got it written down here is it's 2.155 billion so you're thinking this is quite big and then we have another issue this is only one set of board numbers we've got here so there are 1300 243 boards so it's actually 2.155 billion times 1300 243 which is a lot this took a long time so on my home pc to do one of these one set of numbers took about two and a half hours two and a half hours times 1300 to 143 is a long time so we ran into some issues here but we got it done so some things helped we have the computer vision lab in nottingham who lent me their cluster for a little bit that's the same cluster that did hashcat with mike pound and also the digital research team without their help i wouldn't have gotten this done in a reasonable time frame and i'm talking like over a year probably of using two cores of my computer and that's just annoying and not something i'm willing to do so yes we did it and having done this and done every single possible countdown numbers game that can ever happen we've got some statistics on some some numbers some good some bad and i can tell you some things about them we can talk about what the easiest and hardest target numbers to make so because we know every single possible countdown numbers game we can work out how many sets of board numbers could solve every single target so some will be harder than the other so the easiest number to make in countdown the target number that most sets of board numbers can make that's available to them if they do the right maths i want to go crazy and say something like 999 but no maybe 100 100 exactly so yep it's 100 there are actually four numbers that can that share the easiest the easiest to make and they are 100 102 104 108. 13 240 of all possible boards can make these numbers there's one absolutely useless board which is one one two two three three which cannot make a number over 100 so not a single solution can be made with that so if that ever comes up you're in trouble and then we're getting on to the hardest one so the hardest number to make is the one that is possible the one that can be solved by the fewest number of boards is it a large primer or something it sounds like it i don't know if it's a prime but i guess it might well be yeah go and just have a guess good enough it's 900 and 947 yep so 947 is the hardest and that can only be that can only be made by 9017 boards one thing i did to choose from this which i think is probably quite obvious but i did check is that even numbers are much easier to make than odd numbers and it's very statistically significant so if you get an even target number you're very much more likely to be able to solve that which is something something nice to know count out exists between numbers of 100 and 999 and for any given board numbers we could be assigned any target number in this range if any at all how many sets of board numbers do you think can make every single number continuously on this line so i can make 100 100 203 all the way up to 999. not very many 100. so when i did it i wasn't sure if there'd be any but there's actually 1226 of them which is about 10 which is a lot more than i thought is there a common factor is there something you kind of need to have the perfect you know like a big number yeah so i think i don't i don't have any exact stats on this but a big number definitely helps you can tell with the file sizes that come up the files are stored or the results are stored as the the board numbers and by looking at them you can see that generally if you don't have a big number there's less there's less data in the files so big numbers definitely help but too many big numbers so four big numbers becomes a bit of a detriment so somewhere in between there's a sweet spot i would imagine one or two we needed a lot of computational resources to do this to solve this problem and one of the things was was trying to move it from my desktop computer to a cluster so it can do more computation so essentially the way my program worked is it created a text file which was the board numbers so six numbers dot text and then inside that it has every single solution that can be made from those six numbers that's generally how it works now when you're running one instance of that program it's fine because everything's just in a loop but iterates through now if you want to split that problem up there are probably some very nice ways of doing it but essentially what i did is i changed it so what it would do is it would have a list of all the files it knew it was going to generate because it knew all the board numbers and what it would do is it would look inside the folder and if a file isn't there it would then start generating that file and put a lock on it so that no one else can can go and do that file and if something did try and access that file another program accessed that file it would say you can't use it so something else is using it so what it would do one of the joys of that is once you've got that program running you can run it once and it will just look for a file that isn't there and then create it and start doing it and if you ran another instance of the program it would just do the same thing and then you can just start adding programs to it until you get i think i use 40 on the cbl cluster and then on the other cluster i was allowed to choose it got up to about 250 which is a lot so i wrote it all in c sharp yeah so i had to run it on linux servers so i used mono to do that which is an open source compiler for c-sharp nothing terribly complicated there were lots of arrays lots of list manipulation but everything was quite straightforward the server's actually restarted a lot because when you use external servers what they can do is they you can pay for priority access or non-projects if you don't pay priority access sometimes they cut it off and say you can have this back in 12 hours someone else wants to use it which is a bit of a pain so one thing i did do when i was running the programs is what i was doing on my desktop is whenever i found a solution i'd write a text file immediately but when i was using the cluster what i do is when i was writing to a file essentially i put everything that i was going to write into a buffer and i wouldn't flush it to write at the very end so essentially the text files it was generating were either empty or finished and what that allowed you to do is if you wanted to say for example if you were you were taking up too much space in a cluster and the admin message you and says you're using a bit too many a bit too too much of resources than you said you're going to you need to clear some of it out what you could do is you would know which files haven't been written to yet because they've got nothing in them so you can just delete those files close the close the processes that are running those files and you won't have any confusion there because if it was writing as it was going along what you'd find is that some of the files would have data in them some of them wouldn't and that was absolutely fine you could of course do things like just write a little tag at the end of the file to make sure that everything's appropriately finished i kept on not knowing how long this was going to take so this has been scheduled for a few times i was just doing things quickly not thoughtfully so yeah it was a series of less optimal solutions to many problems put together in a program which worked absolutely fine in the end which is yeah nice and this one so these two have a little battle and it's this one that wins we've now got our two parents which we will draw here so they were awful lot of effort in actually executing the expressions that you write down let's