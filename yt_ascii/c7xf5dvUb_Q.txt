so guys it finally happened i was writing some code my son asked me hey dad where does memory come from and i realized i didn't have a good answer for him so in this video we're gonna go over how does a program get more memory at runtime right so to talk about that we first have to talk about where does the program get memory from where can pen memory come from in the first place so we have two regions of memory that are broken up into what's called kernel space and user space memory not drawn to scale but basically the region is cut in half or the entire region below hex seven ffff that whole big line there and down is user space that we can actually map into our program for a process to use during execution that all lives right here so when we run a program and we load it what actually happens is the elf is taken apart into a few parts towards the bottom near zero here we have three sections that get loaded up the first is called the text section and that's where your code actually lives your program gets loaded pretty close to zero not exactly but depending on aslr it's around zero above that we have the data section that is constants or variables that are defined at compile time that will not change or can be used as data and they live in this area on you know in the memory and then above that we have the bss section those are uninitialized variables that get loaded into the memory at runtime and then way above that at the top of user space for the very very end we have the stack structure and the stack structure is one that grows downward right so the downward growing means that as the stack gets bigger its top gets more and more negative so the question is then okay if we don't have data in the elf that gets loaded in we don't have data that gets put onto the stack which is already done at compile time where does data come from the answer to this question is that there are three locations we can get memory from the first is going to be a user space allocator like the glibc malloc for example the second is the system break and break system calls talk about that in a little bit and then third is the map system call so first we're going to talk about the user space allocator that creates what's called a heap so a heap is a dynamically allocated structure that grows upwards towards the stack while the stack is growing downwards towards the heap we are going to go into our vm here and i'll show you guys actually how to use the heap and talk about the pros and cons so by calling malik what you're doing is you're telling glib c hey i want to use your allocator and i want you to give me 10 24 bytes right really really easy to use so you pretty much say give me this many bytes and then if we get that value back we can use it and put stuff there so you know we alloc 10 24 bytes and then if we get it i stir copy this value into my heap turn it out and then we have to free it to give it back to the allocator so not really that complicated i would say this allocator is the easiest to use the trade-off here is that the allocator and the back end as you use it more and more is actually a very complicated length list structure so the trade-off here for simplicity and just asking for this many bytes is that it's a little more performance intensive right so if you're looking for very very performant you know if you're constrained about how fast your program has to work maybe sometimes the glibc allocator is not for you so if you don't use a glibc allocator then what is the next step right so second we have the system break or break system calls this arrow here points to the fact that the bss section is the top of the elf and that denotes the system break or what the system defines as the top of your user space outside of the stack by using the system break system call we can actually increase that break value to create more room for us to put variables right so i'll show you guys how to use that here pretty straightforward so using this program we call system break two times no man or not system breaks set break rather the s break function takes the increment value to tell the kernel how many bytes to increment the system break by by saying s break 0 we actually don't increment the program break at all we just say you know give me the program break and we print it out here then we can increment the program break by a certain value in this case we do 40 96 bytes we print it out and then just to prove that we can actually now use that newly allocated space we yeah so first it was this value now it's this value we turn the difference between these two values so first n which is now this many bytes longer into an array put some data there and we print it out right so i'll show you guys that there you go so first we had the system break that was set here and then the system break got moved up to this value you know it went from 6000 to 7000 in hex and we're able to use that space to put these two three and four values there so the tradeoffs here are this is actually the most performant allocator that you have access to in user space right it's way more performant than the gwc allocator but it's not and it's it is more performant rather than the map function i'll talk to you about next the problem is you don't have a lot of granularity here basically all you can do is slide that system break up a number of bytes and then you have to actually internally manage what memory you use right so trade-offs and then finally we have the mmap system call the mmap system call literally says hey there colonel literally give me any memory you have access to it will appear wherever the kernel decides to put it and that's why i kind of put the square in the middle here you know it doesn't have to appear anywhere it can appear wherever you you know the kernel decides to give it to you you can make suggestions as to where you want to see it but you're not guaranteed to get it back there so we'll go back and i'll walk through a map example real quick so here i use the function map a couple parameters here this null parameter means that i don't care where it comes from just give me some number of bytes i want this many bytes i want them to come back as read write protected so previously i wasn't able to control the permissions of the memory that i got back but i can make this you know read only memory i can make this executable memory to put code into i could do a whole bunch of cool stuff here i do a copy on write protection and i make it anonymous which means that it comes back only to my process and it's not mapped into a different file this is the file descriptor that i could map a file to to show up in memory as opposed to just raw empty memory and then this is some other flag that we're not going to worry about so if i don't get memory back this will come back as null and i'll say hey man i had an error with a map i'm not really sure what to do about it and then we'll print the memory here with percent p so once i've gotten the new memory to come back i can then again use it as an array and go from there right so i print the data onto the screen and we're all happy hunky dory so we'll go back and i'll show you guys how nmap works boom so basically we ran the mmap function and i got back memory from the kernel at this address you know two three and four are the addresses that i put into that new chunk of memory yeah so i mean this is a pretty good allocator as well same kind of thing it's a little more complicated to implement than the glib c heap allocator but at the same time you have more granularity in the kind of memory you get back the g-lib c allocator you can only get readable writable memory and then you have to manually m protect that memory to get it to be executable if you want in that or like unprotect it from being writable whereas this case every time you make a call you can tell it exactly what kind of memory you get back this is a little less performant than s break but significantly more performant than the glibc malik allocator the difference being that the allocator is much friendlier to use than all of these command line arguments obviously just like when you have to free memory from the glibc allocator m on map you have to unmap the memory from the kernel as well before you leave the program well do you see that real quick oh and the length we have to specify the length to this function as well cool so then at the end we just clean ourselves up by making sure that the memory was given back to the kernel in a proper way so yeah i mean that is basically the three major ways that you can get more memory into your process while you're doing things dynamically i would suggest always use the glibc allocator i just think it's fun to have access to the map functionality where you can kind of ask for bigger chunks you know and you know have more granularity on their properties and then also just you know a little more for fun too if you want really quick need it right now don't care about the allocator access to memory using the s-break functionality or the brake functionality that the kernel offers you is pretty powerful as well so guys i appreciate it if you enjoyed this video or you learned something do me a favor hit like hit subscribe and i'll see you guys in the next video take care [music]