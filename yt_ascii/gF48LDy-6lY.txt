okay hello my name is fabian ren giles and i'll be talking about reflection without the reflection technical standard i'm been talking a lot these days and i had had a cold last week so if i need to clear my voice i apologize in advance and i'll try to speak a bit softly and i might have to drink a few times in between so i apologize for that in advance anyway why without the reflection technical specification and that's because official reflection support is still a long time away there was a reflection technical specification that was based much on meta type template programming and that's been considered a bit outdated we have constable now and so the reworking that reflection technical specification so it won't make it into c plus 23. experimental versions i've been told may be available by 2023 but maybe not who knows so we need to do deal with what we have right now so this talk is about reflection techniques that you can use today with currency plus plus standards i'm also not going to talk about tooling there's many ways you can get reflection today by using stuff like gcc xml or lip clang this is not what this is about this is just inside of c plus plus with c plus compliant code i'm actually not at all a civil plus reflection expert by all means i usually do talks on real-time programming and log free programming but i love reflection talks and i haven't really seen a good summary of all the reflection techniques that are out there in one talk so i thought i might try to change that why do i love reflection talks i always go to every conference i go to reflection talk and i try to ask myself why i actually do this and i think it has several reasons one is usually in the title already you already understand what the goal is right you say i want to reflect on the types of a struct right everybody every decency plus developer knows what that means what the goal is but usually when you hear something like that you immediately think it's impossible because c plus plus was not made for a reflection in mind right reflecting on the types of the members of a structure how do you do that it just can't be so every time i read a title like that i'm intrigued to go there because i think the author must be wrong and must have made a mistake but it turns out they're always right and but they use some really fun and pure genius solutions and and so i'm in there and i'm just smiling away all the time these are my favorite talks and looking back at all the conferences i went to and i looked at my schedules because i always write them down and take notes on every reflection talk i've learned something really new that i didn't know before and it's usually because yeah i think reflection talks use some of the most advanced c plus plus features so i'm hoping that today you'll learn some new features that you might not have known about before and to keep this fun and short i want to structure this whole talk as little quiz questions and if it's if you're like me i'm always like no this can't be possible this can't be done with c plus and maybe you'll be surprised that it can be done with c plus so the first question very very simple question is can we check if a type is a pointer or not at compile time without the stl right with the sdl would be simple they're stood is pointer without the stl with only c plus compliant code who thinks in this room that it can be done and if you raise your hand please also have a rough idea of how it could be done i mean i won't ask you so but okay we have we have a few so this introduces the first reflection technique which is template function specialization so that's really really easy you create a templated struct up here is pointer and for any type name t that struct will always have a member value that's always false it doesn't matter which t you put in there so if i would leave the code as is then this is pointer down here it would print faults but now i add a template a specialization of this struct and i tell the compiler to consider this struct if it if the type matches that pattern right so that's super super easy so now it will consider this struct and the value will be true if it matches that pattern so if i look down here that instar matches that pattern so this prints true now can anybody see what's wrong with this code and just shout out okay right okay this is pointer is not supposed to consider smart points but that's a very good point yeah i don't consider smart pointers and is anything else the cv qualifiers are missing right so i would need to add const volatile const volatile otherwise if my in star down there would be a constant star it wouldn't work so that's a very very simple reflection technique that you can use just another another example instead of is pointer enough is array again we have a struct which for any type just returns false but now we specialize this and if the compiler can match this pattern here which it could for a raw array then the value will be true so yeah that's very very simple technique a related reflection technique is template argument deduction which you can use for example to figure out at compile time the length of a raw array how do we do this we have a function declaration up here called array length helper and it takes the non-type template parameter n and then we have this global const extra array length variable which just creates an instance of t here and passes it to that function so if we if we we want to check the length of a a raw array of integers of five integers then we're creating an instance of those five integers and we're trying to pass it in here the compiler will do template argument deduction will deduce the template non-type template argument for us this n and then we encode the n in the return type of that of that function so that down here we can with decal type figure out what type this function would actually return and get its value so this is how you would get the length of an array and i always find this really funny because we are sort of abusing function declarations because we have a function declaration but we don't have a body anywhere and we don't need a body right we're we're just using the function declaration to sort of uh yeah use template argument deduction okay next question for for the room can we check if a type is polymorphic or not again without the stl only c plus compliant code at no if it's polomorphic so if it has virtual method for example yeah or an abstract pure virtual class something like that and anything that has virtual methods what do people think is it possible so raise your hand if you think it's possible okay does anybody want to throw in the technique that we would probably use to do this as a version oh that's a really good question huh that might work i haven't thought of that yeah that's that's a really good one yeah i have to think about that so the technique that you would usually use and you use for a lot of a lot of reflection i think almost most of the more complex reflection you'll be using spine right substitution failure is not an error and i probably all of this in the room know what spina is but just as a quick recap let's say i want to write a function called safe get which takes a raw array again and an index and this function checks that the index is in bounds right so that we don't return out of bounds element and you could imagine some code using that function like this here and then one day we want to write an overload though we want to also use the same safe get for a container so we write a container version but now we have a problem if we still have the same safe get here the compiler will look at the overloads that we have and it's now being passed a raw array of five integers so it's going to consider this overload here and it's going to say oh yeah i can deduce you know i'm going to try to deduce this type name it's a raw integer five so let me substitute that in but when we do that right we get ill-form code here right because you know in five is not a name state struct that's the compiler error we'd normally get but due to sweeney substitution feller is not an error we don't get any compiler diagnostics the only thing the compiler will do is ignore that overload completely so that only one overload remains so that's what that's what spinae is and we can use this for reflection because we can write a function that a compile time this check expression which will check any expression for us involving t and checking if that at compile time if that expression involving t is ill-formed or well-formed so how do we do this we write a function check expression that for any arguments just always returns false then we write an overload for this which again is check expression takes a single argument of type size t and then we put our expression involving t we put in there and if it's well formed then their overload will be considered and it's always it always takes a higher priority than the dot dot one so i would always use that overload if it's well formed if it's ill-formed svena will ignore that overload and only use the the second one so this is a really cool way to check if an expression at compile time as well from the ill form then that's of course super powerful because we can basically reflect on you know does this thing produce a compile error or not and the reason we have the size of is it makes it more flexible because in the size of you know size of can take two types of arguments either it can take types but it can also take you know values or instances so that's why it's more flexible to put a size up here our goal is to find is polymorphic right so what do we want we want an expression which is only ever well formed if t is polymorphic so for the room what expression what expression is only ever well formed like what what do you think might be involved in this overload any other idea what something we typically do with polymorphic types yeah casting right any so dynamic casting all right so we want an expression to involve it has some kind of dynamic cast in it but now comes the harder question what should new type be so there's some expression involving t let's say it's t star or t ref but we want the dynamic cast to some new type and it should only work if it's polomorphic any anybody have any idea what new type could be oh good this is something i never knew so this is something i only learned at a a during a post so that's that's very good yeah it's it's actually void star so you need to look at the standard to really figure this out because i i've never used it before in my life and i don't know what the use case really is for this but so let's look at what new type can be when you're using a dynamic cast if we look at the standard option number one is that the expression so the in in the rounded brackets of dynamicast is exactly the target type new type right but it says the c plus plus internet it says it's it's exactly the same as static cast so this is not good because it nowhere says that our expression will be ill-formed if it's not polymorphic right this works for any type right if you're casting between something that is expression of t and you're casting it to t that works for any expression so we can't use this hmm type of itself again yeah but this is exactly that this is exactly this point if you dynamic cast it to yourself i didn't know this either i thought it would be ill-formed if it's not polymorphic but it turns out that the compiler couldn't just replace that with a static cast so and the static cast works if it's polymorphic or not it always works and so that's not good because we want it to not work when it's not polymorphic the second thing that sarah says is something about null pointers with that we don't care we don't have a null pointer here right we have t if you can't use that the third thing is that when the new type is a base class of t right so imagine t is you know child and the new type the target type is is is is is is base then it says again this can be performed by a static cast as well nowhere does this the standard mention it needs to be a polymorphic type so again we have the same problem is that it's never ill-formed so we can't use that and then we have the canonical case of dynamicast it's where you cast to a child that's that's the normal canonical case of of dynamicast that's how we use normally in day-to-day code would use dynamic as and here the standard does require it being a polymorphic type so this is good the problem is where do we get new type from we need some kind of child type the user is only giving us t right so we can't really use it but then there's this last point in the standard which i've never knew if you cast to void star and the type is polymorphic the result is the pointer to the most derived type by the expression so who knew in this room that when you dynamic has the void start actually casts to the most derived type that your polymorphic type can be so we have one person who knew that anybody else okay so i told you you learned something new and reflection talk so yeah exactly yeah crazy yeah yeah it is it's pretty pretty powerful it's then it will return itself it would return right yeah it still reminds to be polymorphic yeah so the expression you would write here is dynamic cast void star and then you know just the decal valve t-star and i know this is right because clang's stl uses this so it can't be that bad okay okay i mean yeah the stl uses it so interesting okay let's so you don't think it's standard compliant i mean we have i have time in this talk so yeah so next question who thinks after this scene is that we can check if a type is a struct or a class type at reflection of compile time nobody else just one person two okay so we're going to use the same technique we're going to use vena again which expression do we want to check to see if it's perfect you want to do a member pointer very very nice yeah we put in a member pointer there right because only if t is a struct or or a class type all this work and it doesn't matter if t actually has a member of type int right it's even it's still well formed even if t didn't have a member in it as long as t is a struct or a class type it will work there's one problem what's the problem what no no no no we don't we just want to see if it's a structure a class it doesn't matter if it's structure class right i mean if it's does any sorry no that's not it no hmm no that's not the problem i think because it's only it only needs to be well formed or ill-formed it doesn't matter if if it's actually possible to do that with with t right it could be that t has no members for example i you know it just it just has to not be ill-form code so this is again this is actually using the stl so the thing is that unions you can also bind to union members so you might want to go one more instead of doing binding to a you know member point or we use a method pointer right why does this not work it's because unions can also have methods so who knew in this room that unions could have methods because this is something i learned in a reflection talk and yeah i i don't know why i've never seen it before but unions can have methods so this doesn't work so anybody who thought that with who answered this question that they think you can reflect is if something's a class or a struct type you can it's not possible the stl actually uses some internal compiler magic there is something that's called stood is class type it can only be implemented either you have to implement is union type with magic or is class type with magic so the client's sdl implements is union is union type with some internal compiler magic and then you can write is class type by checking this and then checking that it's not a union so yeah crazy okay is it possible at compile time with only c plus compliant code to return the name of an enum value as a string at compile time so imagine here this code down here i have an enum called color and it has a value red and i want it at compile time to return the string red who thinks it's possible okay one person who thinks it's definitely not possible okay okay so you have a good intuition right because when i saw this first i said it can't be possible and why because when we're doing reflection we're always using template meta like you know type template meta programming and so we're always using the type system or abusing the type system to do reflection now names of enums are not types right they're they're they're identifiers and the names i've identifiers don't really go into our type system and there is a caveat here because it is possible but it's implementation dependent so it's implementation defined behavior but it is possible and the trick is that source location function name okay c plus 20 states source location function name and why does this work we're going to create a function called enumn name which takes a non-type template parameter which is a will be our enum value now as we know how template functions work every time you use enumn name with a different enum value the compiler needs to create a new function and function name should be unique right so what does this thing print out here for example on clang it prints out the name of the function but then also tells you what the enum value is and it conveniently puts red in there and so with a bit of you know compile time string manipulation magic you can get this to just print out red don't do this at home different compiler versions even will you know that string that it prints out will be different msvc doesn't have a source location function name yet in fact if only the very very newest clang version has function name so for all the clang versions there's underscore underscore pretty function which does the same thing and for msvc use funk sig which does the same thing and don't ever implement this yourself daniel i hope i hope i'm pronouncing his rank name correctly created this library called magic enum which honestly this is the best library i use this on every every project it's the first non-stl library i include in every project and it because it also does the reverse it can convert strings to enum values it can even iterate through enum values of an enum all at compile time it's single header yeah definitely go check it out and he figured this out right so okay now we come to the holy grail part of this talk is it possible to reflect on names and types both names and types of members of a pod class struct pod is not really you know correct anymore with new standards so you know we can for if if we're a c plus plus 17 and beyond we would say aggregate class type but when i was talking to people most people knew were more familiar with the term pod so plain old data so who thinks in this room that it's possible to reflect on names and types of members of a pod class extract okay okay let's leave the unspecified for a moment because we're going to actually put this into sub questions okay and there we can answer this more can we count the number of members in a struct with prc plus plus only standard compliant code so yeah okay and yes we can and we're using we're going to use sweeney again but let me just make this a bit simpler for me and then we'll relax some assumptions so first instead of counting the number of members of a struct we're going to check if a struct has at least n members right and then we're going to limit the struct to only have integral type members which we're all we're going to relax both of them but let's just assume that we have a struct like this that only has integral type members we're going to use this check expression thing before this check expression only involved an expression with t now it's also going to involve this non-type template parameter pack that goes from 0 to n minus 1 what is n n is right we're trying to write has at least n members so if we're going to if we're trying to check if it has at least five members n would be 5 and our template parameter pack would be zero one two three four okay and now we need to check an expression that is only well formed if our struct has at least five members and that expression will involve t and 0 comma one two three four anybody any idea what you could do exactly exactly so we are just going to initialize this thing with an aggregate initialization and right if this thing only had three members the struct then there would be excess elements here and so it would be ill-formed the compiler would ignore that overload and would only use the the false type so we know oh it doesn't have at least five because it only had three if it has enough members then that digitalization is well formed and the compiler accepts it and if you replace the parameter pack back in it looks like this right okay so let's now let's just zoom into this bit of code here i don't want to keep on rewriting all of this other stuff so let's just zoom in let's just take this thing and put it on this on a separate slide we had a struct which is only integral types now let's say the struct has you know pointer types so how do we fix this you know this would be ill-form now because our parameter pack would be zero one two three four you know we can't initialize char with five that would be ill-formed so how do we fix this well we use the comma operator comma operator is really neat because this thing is still expanded but only the last element will actually be used in the in the aggregate initialization so only null putter will be using the aggregate initialization so that's really useful that's how we could expand it to pointers how can we expand it to any type we introduce a new struct called any which has an implicit conversion operator and that implicit conversion operator is templated so it can convert to any type implicitly so it's like this magic thing so we just replace that null putter with any and now this works for any struct right here it would have to be it would have to be constructable but like i'm restricting this to pod types you can do lesser restrictions but then you would need more tricks so i'm doing the simple version here okay so yeah that's that any trick so we're not quite there yet right we want to count the number of members we have now implemented has at least n members so we create a const expert recursive function it starts out at i equals one we first check does it have at least one member if it does we check does it have at least two members and if it doesn't have two members then it must have had one member right so we did it we we counted the number of members in a struct with pure c plus plus standard compliant without using the stl so it can be done now the second sub question can we get the type of a struct member so we got the number of members in a struct and we get their types yeah yeah we can yeah and any what's the what's the magic keyword we need to use what's the reflection technique new c plus plus features c plus plus 20 i think 117 i'm not sure it's okay so let me just rephrase this question just to make a bit more clear like okay we want to get the types of struct members let's just say we want to convert a structures to tuple so right so where the elements of the tuple are the member types of a struct it just makes it a bit easier in the slides that are going to follow so we want to create a structural function right it takes a struct s and then it spits out as the tuple where each element is corresponds to the member type of that struct and yeah the magic thing we're going to use is structured bindings so if we would have exactly five members this is how you would do it right we would just introduce a b c d e and then we we create a tuple with that so it's actually really really simple the problem is it doesn't there's no way to generalize this to any number of members so this is explicitly for five and the reason why it's so hard is structured bindings are are not normal c plus plus code it's just a list of new names that you're going to assign to new variables so the compiler treats us as a list of identifier names it's so you can't put in normalcy expressions you can't put in parameter packs so what we need to do is we need to create a helper function make this a helper function and then create several overloads copy and pasting this thing as many times as we think there might be member members so i made it you know i did it for one here you would have to do it for two three four and then you create a little wrapper function you know which calls the right overload depending on how many how many members you counted now this could change in c plus plus 26 i think there is there's a proposal to allow structured bindings in in to allow a parameter pack expansions in structured bindings so that that would fix this but is there another way to do this without copy pasting there there is and has some other downsides but there's a way to do this without copy pasting at all and for this i'm just going to show my this little my struck thing that we want to reflect on and then we create we want to create a function called reflect struct it takes one template argument which is the struct that we want to reflect on so in this case it would be my struct and then it takes a lambda as an argument which has attempted at lambda and the type of that argument there that underscore argument will then be the tuple that represents our struct okay so this is what we want to implement we have our reflect struct function that takes a template argument which is my struct it calls that lambda with a tuple that you know represents the members of that struct this is not quite correct yet because right that the the lambda needs to pass in a value so we're actually going to pass in an instance of that tuple we don't really want that right we we just want a type basically passed in there so instead of passing in a tuple we're going to pass in us the type identity of that which is an empty struct which just has a type alias inside called type which we then could use so this code for example would just print out you know the tuple in string bull float so this is the thing we want to implement reflect struct how can we do this with pure c plus plus we're going to use the same trick as before we're going to do aggregate initialization where we're actually only going to initialize the first very first member and we're going to initialize the very first member with the same any class that we did before so we have our any class here and we have our implicit conversion operator just as before and now we're just going to add some template parameters to this any so first we're going to add the struct that we're trying to reflect on which is t then we're going to add a lambda because we want to pass in this lambda into the any because we're going to need that later on then we're going to add a recursion parameter i which starts off with the number of members that we have and then we're going to add variatic template arguments to this thing which is u which are the already deduced types of the of the struct which right now if you look down here we don't know any types yet so you will be will be an empty pack so when we get to here we now know one member type the very first one right because this thing where where aggregate initializing the very very first member type so v will now be the very first member type and so we recursively do the same thing again we aggregate initialize we now know the first member types which is you by definition right those are the ones we already resolved we now know one more which is v now we recursively call any again we pass in t and lambda again we decrement the recursion count and now what is u well u is the past use that we've had the ones that we already know but we know one more now which is v right we found out one more so the second time we go around you know u will be something now we know another v and then we're going to try to get the third member and so on and so on right until i equals one until our recursion non-type template parameter is one there we create a specialization of any because here for this last one you know the conversion operator will be called one last time for the last member and now we know all of the types because they are now u now all the ones we deduced before and then the last one v and now we can call our lambda so this is how you can do it in pure c plus plus code it has one huge downside though is that it's not very flexible because there's no way we can get the type out outside of that lambda so the lambda is called with that type but we can never ever return it right what we would really like to do is to make the return type be dependent on that template parameter which you can do with normal c plus and we could get the return type outside of this lambda but then we can't do anything with it because the return type of this conversion operator is fixed it has to be v so this works but it has a huge restriction right and so the structured by anything is actually better there is a way to get this out with older c plus learners there was actually a defect in the c plus standard which allowed you to use friends as a sort of state in the com in the compilation was really really crazy because i mean you know the type system should never be stateful but it was by mistake so there was a way to get it out with previous c plus versions not anymore but this was just a glance of what you know this was a a really really quick run through of how this works this talk does it in much more detail and all of the things i didn't talk about like what if there's an a bit field inside he anthony palukin covers all of this and there's a library called magic get or boost it's actually in boost pfr which does exactly that you know you can convert a tuple a struct into a tuple and the other way around so definitely recommend that library very very useful okay can we get the struck names who thinks we can okay this is a bit of a bad question because it's clang only and it's using a really bad trick but it's possible in very new in the newest versions of clang there's something called built-in dump struct so this is no no longer c plus plus compliant code you give it a pointer to a struct and a lambda which has the same semantics as printf and what this thing would print out is this thing here and it includes the names of the members and the thing is i mean i've tried this if the lambda is cons expert the whole built-in dumb struct is also cons expert and i've tried this you can actually really get out the member names all at compile time so yeah you can use it but i think it's only on clank trunk right now so but it's it's possible okay last questions and this is not a serious one can you check if the author is using tabs or spaces at compile time to be something no no okay the the the trick is split source location column so we put the switch first location column one tab indented and if that thing so the column counts from one it's it's not zero based so the very first character is at index one and so if you have a tablet would be at index two the problem with column is that only clang trunk implements it yet but i found another way to do this which is even more fun what if we don't have source location at all so we don't even have function name i said before that we have this pretty function macro which does exactly the same thing so this will give us the function name it's templated so we have the same thing again for every version of funk name it will tell us which a template argument we have but what if we give it the decal type of a lambda and the nice thing is that gcc and clang they print out this lambda at file.cpp line column number so you can get the column number right now with even pretty old acclang versions by using this trick here but just figuring out the function name and so the full code looks something like this column number of lambda definition you do some processing of that string to give you the column number and then you write you know is using tabs column number of lambda definition you have to make sure that that lambda is exactly one tab indented and if that gives you one and you're using tabs and if if not then you're using spaces and if you want to find a gold version of that it's it's right there yeah so that concludes my talk thank you very much thank you you have time for questions yeah install things i i don't know i didn't really benchmark them i mean it seemed it didn't seem long but yeah timor i yeah awesome yeah it just occurred to me if you go back to 5.1 the thing where you were like seeing if you can initialize an aggregate with like not more than n an argument right yep it's just occur to me doesn't this fall apart as soon as you have a member of an aggregate which is itself in aggregate because then you have brace solution and then you can actually initialize an aggregate with more initializers than the number of members it has yeah so anthony palukin he does he he talks about that there i mean it gets very complicated and meta but you can because you can figure out there is in the sdl somewhere that's called is class or struct type so you can figure out if you are initializing something to a class or a struct type with this any right so this any we know which type it is we can then check at compile time if it is a class or a struct type and then we now recursively count the members of that struct type first so we know how many members that struct type has to have and if that struct type has other structs in there we have to count those first so it's like kind of nested right so that's why i said i glossed over a lot of details here but it is possible yeah it's very very hard so i mean anthony palukin goes through that in his talk and it gets extremely difficult the questions okay thank you [applause]