due to backwards compatibility c++ 
will never become any simpler. but the way that we use it can. welcome back everyone. 
i'm james murphy. and today we're talking about the 
simplest smart pointer in c++ unique pointer `std::unique_ptr` this is a dumb pointer otherwise known as a raw 
pointer or just a pointer. but this is a smart pointer. so what makes it so smart? smart pointers are just wrappers
 around regular old pointers that help you prevent very 
common bugs. namely, forgetting to delete a pointer 
and causing a memory leak or accidentally deleting a pointer 
twice or in the wrong way. they can be used in a similar 
way to normal pointers. and they automate away some of the manual 
process causing some of the most common bugs. let's take a look at a 
specific example. we have a vector 
of pointers to widgets where each widget is allocated 
on the heap using `new`. we're using a vector of pointers 
instead of a vector of actual widgets because we're imagining there might 
be some kind of inheritance hierarchy going on. in actuality, we just have 
a single widget class. it just stores an integer and prints 
something on construction or destruction. let's also suppose we've already written 
code using raw pointers or raw references. in this case we're just printing
 something from the widget. getting back to our example. 
we have a pretty typical workflow. we create our vector and push 
five widgets onto it. then we loop over them and 
do some work. maybe the user closes a widget. 
so we pop that one off and delete it. or maybe we peel some of the widgets off 
and do some different work with it. once we're done with that 
one we delete it. at the end we loop over the vector and
 delete all the remaining widgets. this code works but it is 
very very error prone. let's take a look at just a few of the ways 
this could have gone wrong. first we're calling new in a loop. if the first new succeeds but 
the second one throws an exception, then we just leap the first one. to handle that case without 
smart pointers, you'd need something like 
a try-except and or go to fail. no real issues just looping through 
and using the widgets though. but in this case, say a widget is closed, 
it's very easy to forget to delete it. this is one of the most common 
ways that memory is leaked. most likely nothing will go wrong with
 your program if you forget to delete this pointer. you've just got a very very 
tiny memory leak. this case is even easier to forget because 
the delete has to be after the use. and of course, if all the widgets are closed, it's 
very easy to forget to delete all of them. or instead of forgetting to delete the widget, 
you might forget to pop the widget. in which case, you'll accidentally delete it a 
second time when you loop through the vector at the end. deleting a pointer twice is 
undefined behavior. so if you do this even once on
 accident anywhere in your program, the entire program is undefined. this could result in a segvault, garbage data being displayed 
to your user or worse a silent wrong answer 
in a calculation. the idea behind smartpointers is to 
make ownership of the pointer explicit. an owner of a pointer is an object
 that's responsible for deleting the pointer. so a unique pointer models an object
 that has exactly one owner at any given time. you could transfer or give 
up ownership. but when a unique pointer is destroyed,
 it's responsible for deleting whatever it owns. this completely gets rid of any confusion about 
when where or who's in charge of deleting a pointer. the way we clean up this example
 is by using a vector of unique pointers instead of a vector of raw pointers. so, here we're using a unique pointer
 to widget instead of a pointer to widget. here you can push back unique
 pointers instead of raw pointers. you can construct a unique 
pointer yourself passing in a new widget. but for reasons beyond the 
scope of this video, the factory function make 
unique is a better alternative. all make unique does is make 
a unique pointer by calling new widget and forwarding all 
the arguments that you passed in. for type safety reasons unique pointer will not 
automatically convert to a function expecting a pointer. instead you can use the get function to 
access the underlying pointer. alternatively if the code that you've
 already written was using references, the dereference operator works 
with smart pointers. dereferencing the smart pointer 
will dereference its underlying pointer. so, if you're passing everything by reference 
and you weren't using pointers in the first place, then your calling code doesn't 
need to change at all. in any case, whether using references or pointers, 
this is the recommended thing to do. it's not recommended to rewrite functions to 
take unique pointers instead of pointers. only the code that dealt with 
creating new widgets or deleting widgets would need to be changed 
to use smart pointers. all the code in the middle that just uses
 widget pointers or references shouldn't need to change. then we get to another benefit. we no longer have to remember to delete this 
widget before popping it off the back. popping off a unique pointer 
will automatically delete the resource. in the second case, the compiler automatically 
stops us from making a potential mistake. the compiler now forces us to move into 
this local variable last instead of copying into it. this might seem a bit annoying. but it actually protects you from the possibility of double
 deleting like we had in the raw pointer situation. you can use the arrow operator on a
 new pointer just like you would a normal pointer. and finally we don't need to do 
any of these deletes. the unique pointers handle 
that for us. so overall, the code got 
a little bit shorter. but the main benefit is that we just don't 
have to worry about new's and delete's anymore. why burden yourself with that 
when the compiler can do it for you? and this is where a lot 
of other tutorials might end. you see some flashy code fixing one
 example and a specific case someone that you don't really know tells you 
to use this thing that you don't really understand. but maybe you're super vigilant. and you at least try to look at 
the source code and see how it works. so you go to definition. and you see this. and then you never use 
unique pointer. standard library implementers have 
to write it this way for reasons. reasons that unfortunately force 
the code to be completely unreadable. but the main idea is behind unique pointer are 
very simple. and you could write it yourself. so let's do it. 
let's write unique pointer. we'll start with the class template. for now just assume that `t` is 
a normal non-array non-reference type. think an int or a widget. the real standard unique pointer has 
a specialization for arrays. and it also allows you to specify 
a custom deleter type. but we're just going to keep it simple.
 no arrays and just using the built-in delete. maybe we can add custom deleters 
in a follow-up video. a unique pointer just wraps a pointer.
 so let's give it a pointer member. the main feature of unique pointer 
is that it calls delete and it's destructor. by putting delete in the destructor,
 we ensure that the pointer is eventually deleted. because c++ guarantees that destructors 
are called even if there's an exception. technically speaking, it's okay 
to delete an null pointer which is going to be our 
not-holding-anything value. but i'm setting us up for 
custom deleters in the future. and a custom deleter might 
not support that. that's why we have 
this if check. next, we need constructors. 
the real unique pointer has a ton of them. but you really only need 
just a few. we'll have one to construct from a raw pointer that 
just initializes our pointer to that value. and a default constructor to 
hold a null pointer. now, it's common to have a copy constructor and a 
copy assignment operator to go along with it that make copies of 
your object. but for a unique pointer that 
doesn't make sense. if we made a 
copy of a unique pointer, then we'd have two unique pointers
 that both think they own the same object. and would both try 
to delete it. that would be incorrect. unique ownership implies that copying
 a unique pointer would be a bug. so in this case, we explicitly delete the 
copy constructor and copy assignment operator. next let's define functions for either
 giving up or changing ownership. first up is release
 which is for giving up ownership. we've set our internal pointer 
to null and then return the old one. we don't delete the old one. giving up ownership means that the caller is taking 
that responsibility it's their problem now. also note that this pattern of setting a
 value and returning the old one is extremely common. and it can be written this 
way using standard exchange. reset on the other hand swaps 
out the thing that we own. there's no one else that's taking 
that responsibility we still own the old one. so after we take ownership of the new pointer, 
we need to delete the old one. and once again this could be 
written using standard exchange. so, release and reset are kind of the building 
blocks that we use to change ownership. but so far, we don't have an easy way to directly transfer 
ownership from one unique pointer to another. that's what the move constructor 
and move assignment operator are for. these operators are characterized by the fact that 
their function argument is an r value reference. i'm definitely not going to attempt to explain value 
categories in the middle of another video. suffice it to say that our value
 references are typically temporaries or otherwise about 
to be destroyed. think of a function's return value or something explicitly cast 
to r value using standard move. the whole purpose of this is to allow you to 
steal the guts of another object before it's destroyed. in our case, stealing the guts have
 another unique pointer means asking it to release 
ownership of its held pointer. and then assigning that 
to ourselves. move assignment is similar. we guard against assigning 
to ourselves. ask the other thing to release ownership 
and then take ownership for ourselves using reset. we need to use reset here 
instead of just assigning the pointer because we might already 
own something that needs to be deleted before 
we take ownership of something new. and that's basically it. we just need to define some getters and other convenience functions to 
make this usable like a normal pointer. operator bool allows us to do if checks
 and other boolean-like things on the pointer. the get function just gives out 
the underlying pointer so that people that don't care about
 ownership can just use it. operator arrow allows us to forward 
arrow operations down to the underlying pointer. so that p arrow something will 
result in endpointer arrow something. and finally there's operator 
star or the dereference operator if you prefer. it allows star p on the unique pointer 
to end up dereferencing the held pointer. zooming out. the whole thing fit 
in under 50 lines of pretty easy code.  and if you ignore blank lines, i 
can even sneak in make unique too.   okay, i'll zoom in on that for a sec but
 this is just icing on the cake. just change standard unique 
pointer to unique pointer and standard make unique 
to r make unique. and the whole thing 
works as is. it doesn't matter if an exception is thrown. our used 
widget function didn't have to change   we don't have to remember 
to manually delete anything. if we tried to break unique ownership
 by copying, the compiler would stop us. i mean, it's not like 
a great error message. c++ could definitely use some
 improvement on that front. but it does stop us. it forces us to use move in which 
case ownership is transferred gracefully. and we don't have to loop over the vector and clean up at the end. all that's just taken care of. now of course, smart pointers 
are not a silver bullet. they are but one tool 
in your bag. it's possible that unique 
ownership does not fit your problem. although maybe shared ownership 
and a shared pointer would be a better fit. but even then maybe not. it's possible to accidentally try 
to use a move from object. and it's possible that one of 
your functions tries to keep a reference that becomes a dangling reference
  once the unique pointer goes out of scope. so using a unique pointer doesn't automatically 
protect you or make your code correct. however, the benefit 
of smart pointers is clear. smart pointers reduce the 
number of bugs that you write. and unless you have a good reason
 not to and there are some good reasons. then you probably should be 
using them. as always thanks for watching. and thank you to my patrons and
 donors for supporting me. don't forget to like, comment and subscribe. and if you especially like the video, 
please consider becoming a patron on patreon. feel free to make suggestions of other video 
topics you'd like to hear about in the comments below. and you can also come and discuss
 programming in my discord link below. anyway thanks for watching.
 and see you next time.