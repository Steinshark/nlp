thank you jens thanks for inviting me happy to be here i was catching a few of the sessions earlier today that were very good so for those of you who do not know me i'm a sequel plus programmer since the mid 1990s i've worked on a lot of different kinds of systems i am the author of boost date time i got involved in boost in the early 2000s and was one of the original authors on the chrono proposals for c plus plus 11 and been in and out working on the standardization committee right now i spend my time on the library working group which means that i read every single paper that comes to the library and so part of what i do is i try to take notes and prepare so that when the standard is actually getting to be finished i can make presentations to the community and we can see what's going to happen in sequels plus in future versions of sequels plus so that's what this presentation is for those of you who don't you know live and breathe by what the standard committee is doing on a daily basis you'll know that sequels plus despite the pandemic is going to ship on time and that's just a fundamental part of how the sequels plus committee structures itself since equals plus 11. we call the train model so basically whatever is there on the train ready to go when it's time to ship the next version of the standard will go into the standard now that doesn't mean that there's no thought or preparation put into [music] you know what we want to have in a particular release there is a plan you can read the link there so that's another thing you'll see throughout this presentation i have links to the various papers if you want to dig in but there's a plan and there's a focus and my focus today is on the library but one interesting feature of the sequels plus 23 plan is it didn't really have a big plan for language features which is not surprising given that c plus plus 20 was a very large set of language features including concepts and so anyway 23 was sort of destined to be more smaller in the first place but as you'll see the pandemic is definitely having an effect as well on the library side the big features that people were prioritizing are networking modules support concurrency support and bug fixes so bug fixes may surprise you but oops let's see if i can you know use the slides properly so the thing is of course with plans is it plans our plans and then there's the reality of what happened and of course kovid is the big reality that has really changed things the seaplus plus committee has basically always depended on face-to-face meetings that's been it's real the way that the committee has always worked and so because of the pandemic the last meeting was in prague in february of 2020 which was basically where c plus plus 20 was finally shipped and so the feature freeze for c plus 23 is only a few months away it's in february of 2022 and the committee will not be meeting till at least june of 2022 so the bottom line is that the features for c plus plus 23 have been almost completely developed uh doing virtual work and i think there's no question that that makes it very difficult in certain sorts of features that need a lot of back and forth understanding and under you know working through corner cases and so forth those things are just much easier to do face to face you know than than they are on a zoom meeting in addition to that there's the time zone effect we have worldwide participation and getting time zones you know that everybody can work in and so forth is difficult at times so what's basically happened is many of the subgroups like the library evolution group the library group we're meeting on a weekly sort of basis typically for an hour and a half and we're trying to work through and do features so long story short c plus plus 23 is going to be a smaller release i don't think there's any question it would be hard not to be a smaller release than c plus plus 20 because it was so large and there's going to be a fair number of bug fixes i'm going to talk about some of those today and i think that's probably actually really a good thing we needed to change some of the things that we did in c plus plus 20. so those priorities again yeah so two big library features you know that were shipped in c plus 20 were format and ranges and some pretty big changes have been made and many of those changes have been back ported actually into c plus 20. we'll talk about that at least at a very high level i'm not going to go through all the details of it the good news is if you hadn't started trying to use the experimental versions of things you won't ever notice you'll just get a better product the changes wouldn't have been made if we didn't think that at the end it was going to be a superior product and it was better to break things before we had 5 million users actually you know depending on these particular facilities support for modules we are getting some support for that and we'll see that i'm going to talk about that today concurrency support with co-routines things like standard generator some of the center receiver stuff those are things that you know there's still some work going on we'll see what happens with them i think for today's today's presentation i'm gonna be focused more on things that are more of a certainty to arrive actually in c plus plus 23. those things are still in a lot of work so ranges in format in addition to the bug fixes are getting a lot of additional things and then there's just another whole category here which was sort of mopping up a whole series of features that didn't make it into c plus 20 because we ran out of time and a lot of those things are are coming in sql plus 23. okay so here's the outline of the talk and i know yen's has given me a little bit more time than i had at cppcon but for a variety of reasons i'm probably not going to go too much longer than i went at cppcon and i will give you links here to you know let you guys go explore all these facilities many of these things have open source and so forth that you can go look at and the other thing i'll mention at this point is i'm going to keep this talk updated so you'll be able to go back and as things change as things get pulled out or things get altered in some way i will keep the slides up to date so you can actually use it as a reference going forward in the future so there's a long list of things here just even the categories themselves would make a big talk and so kind of the way i'm going to structure this is i'm going to pick and choose a few things i do have slides for some of the things i'm not talking about i'm not for everything i'll show you things i'm just not talking about at all but i do have slides for a bunch of these things like i say you can go investigate those things if you want i'm not sure yen's how if we can do the audience participation easily but we'll see when we get down a little further in the presentation so some things i'm definitely not gonna cover today and it's not because these things aren't important it's just you know there's a limit to how much you can do in a talk and in addition to that some of these things are still in flight so you see all the things at the top here are still under consideration by the committee and so it's unclear whether those things some things are closer than other things and like with freestanding and flat map and flat set i've give you i haven't given you the references here but there's several papers for those things at the bottom here move only function that's actually done it's actually in the working draft but i'm just not going to talk about it today so as well as in bocar the extended floating point i'll mention that just briefly because floating point numbers are important in a lot of domains that's highly recognized by the committee we understand that there's a large group of people you know machine learning embedded in other spaces that want to be able to use different kinds of floating point types and so this paper here 1467 [music] would open up the standard to allowing that capability there's an additional set of papers the c committee the c standard committee is looking at a series of now sort of small floating point types and other floating point types beyond what c currently offers and we expect those will land in c23 which should come out about the same time as the the next generation sequel plus standard so i'm not quite sure what's going to happen with those i think those might take 26 before those are officially recognized but since part of the c standard they would likely get in your c compilers sooner than later okay so let me see so jens i guess i cannot see the chat here [music] so okay i don't know if if anyone can send me questions or not but if you have questions do what you can to send those and i'll see if i get to see them okay so let's talk about string processing why do i put string processing first well i think the the reason for me really is that every non-trivial program i've ever written of course involves some kind of string processing whether it's secondary or primary to the function of the programs and so it's important for a very large number of programmers and so some of these things are very simple i'm going to talk through the first two i'll just briefly mention that resize and overwrite is a performance optimization for cases where you're going to reuse a strong string and you need to be able to resize it and rewrite data in the buffer it gives you direct access to the buffer the string view constructor is a very simple thing that allows you to construct a string view from a range so i won't talk anymore about those in any detail so let's talk about the very first thing which is just being able to figure out if another string is in a string it's the simplest possible thing you can imagine and it's unfortunately been lacking you know you've written the find commands and used iterators and so forth you'll know that this is a very nice thing we also if as a reminder we got starts with and ends with in c plus plus 20. so this contains is really the bookend to those to those features to sort of allow you to to do some very basic string things in a nice way and of course this is in string view as well and you'll see this is already implemented in all the major compilers so that's an easy one this one is a little bit more it takes a little bit more explanation i guess so this particular code if i have a function do it like this and i have some complex set of logic in here and i end up in some place returning or constructing a string with a null putter currently in sql plus 20 you will get a runtime exception or runtime error which is an unfortunate fact because in this case it's absolutely clear that the compiler can deduce the fact that you're constructing the string with a null pointer so what what's happened in c plus plus 23 indeed is we've made that constructor fail and so you will now receive a compile time error instead of a runtime error if you attempt to construct a string with a null pointer so again these are small things it's a that's one less razor blade you know as part of c plus plus something you know that you might run into okay see how i'm doing okay so let's talk about modules modules of course is a c plus plus 20 feature which was great but with c plus plus 20 modules we didn't really get anything in the way of support for the standard library module module being modular itself so and of course sql plus 20 modules change the compilation model in a fundamental fashion from the way we've been doing it from the very beginning if you think a little bit about what pound include and that model actually entails what it means essentially is a cut and paste of every single include file into your translation unit as you compile it so the inefficiencies of this are well understood and well known you in many complex projects get literally hundreds of files that need to be accessed in a translation unit which basically means reprocessing those files over and over and over again and so that's one of the fundamental you know the fundamental thing that modules is there to address in addition it has extra features for being able to support access control in a finer grained way than we could in the past for example excluding all macros so that you know with pound includes you get macros whether you want them or not with sound with import you will not get macros typically so modules are supported by a non-binary or a binary a binary form translation of the header that's not fully standardized as it were but basically each compiler is going to have their own they're all talking to each other now they're talking about having a shared one we'll see what happens with that but header modules were sort of a special case which allowed you to create a header from a header unit like iostream to create a module so that was one way and this is one way actually you can you do standard library modules today on some of the platforms as you can use header modules in which case you just you know turn an include into an import and you know then you'll be using modules the thing about the headers is is that really the right model and that's really the question that needed to be asked for standard library model modules and there's been a number of different proposals and discussions over the years trying to figure out what the right level of things is and in particular you know how do we want to name things how do we want to divide things up at one extreme you can imagine that you know we would have one module for every single type which sounds like a nightmare to me because then i'd have to say pound import for every single thing that i wanted out of the standard library sorry i keep saying pound import there is no pound on import as you'll see in a minute so we could have one for each type at the other extreme we could have import std which would get you the entire standard library no questions asked and in between there's things you know where we could have things like standard algorithm standard container but the question is yeah how do we make the right size for programmers what's the right divisions there so going along with that consideration of the granularity are things like you know what is it that we want in terms of teachability for example well import std is super easy to understand it's also super easy to move code to that because you know you only need one import in every single file and you can get rid of your standard library includes so that's really a nice feature of that the thing about it is that c and c plus plus have been together for a long time and non-trivial sequels plus programs also have macros in them like assert in particular is one that's commonly used it's also the case that there's a number of c functions that are in the global name space that come from sql plus headers so what do we want to do about that global namespace and ideally modules would not modify that global namespace they would in fact just you know stick to std and sub name spaces of the standard is one of the considerations so it might surprise you learn that in fact the answer that the committee has decided on for sql plus 23 at least there will still be some consideration of other options but for c plus 23 you're going to get two modules essentially import std and import std.compat and that second one is really there for things like f open and some of the other global namespace things from c if you want macros you're going to have to pound include them the good news is modules are completely compatible with inclusion as well so you can still pound include and so i think the goal basically is this is a straightforward way that we can move things forward and get modules being used in practice it's also simple for programmers it's also super simple to teach and understand and to be honest with you i really like the idea of not having to remember what thing is in algorithm versus ranges versus whatever that old model actually doesn't really add any value to my life it just makes me have to remember where certain things are so of course the question you're asking yourself is you know what does this do to compilation times if we import the entire standard library as one single module every single function every single type what does it do well so bjornis drew strip and microsoft and some others got together and in fact did some testing of of this and essentially you can you can afford it so import std is in this particular experiment 10 times faster than a pound include of iostream so that's good news in that the standard library in full can be made available there's some other numbers on these slides i won't dwell on them if you want to see more about the methodology and what they did to do these measurements you can look at p 24-12 but their summary at the end of you know looking at this and doing some analysis of this is they're expecting you know that a realistic real world kind of example would be somewhere in the range of 5 to 25 times faster for in for modules as opposed to pound include so let's hope they're right because that would be fantastic and it would be a fantastic thing for sequels plus programmers uh but it would mean less coffee breaks so that might be a little bit of an issue okay so this one as i mentioned this is a high on the priority list the final wording approval and design approval is pending and so basically these two papers here talk about these things and i expect fully that we will see this ship in sql plus 23. okay so next let me talk a little bit about input and output and so of course in c plus 20 we got std format which is a printf style way to format outbound text into a standard string and one of the additions to this there's some additions and changes to that i'll talk about but then also why not be able to just go directly to the console or directly to a file so that's what std print will bring us and then in addition to that if you've worked at all with the format capability you know that you have to do template specialization not everything that's a part of the standard library has a template specialization for format so that leaves users having to do that for themselves or work around it in some other way and then formatting for ranges this could have gone in the ranges section but i'm putting it in here because it goes with the rest of the i o this is something that's really interesting and really valuable and then the last one here is actually even though we're making a major initiative at least on the output side here to change the way we do output we still have streams and we're going to still have streams for a very long time and spanstream is actually in addition to that and i probably will skip over that the slides are there you know the author of the paper is at the conference i saw peter summerland earlier on one of the sessions so you can chat with him and ask him about it as well but it's valuable in certain particular cases okay so i think i said all of that so let's look at a you know format from c plus 20 example this is a very simple example i have two values a string and an integer on the right hand side here they get passed into the format the problem with this is that my format specifier here for the second parameter is a string and not an integer or decimal value like it needs to be and as a result in c plus plus 20 what as it was shipped what would have happened is i would have gotten an invalid format specifier at run time as a runtime error and that's problematic in particular given in the modern world we live in things like this even in c this kind of specifier mismatch can be detected and warned on at least by the compiler if not giving you an error and so we would really like this since this is a static string you know it's a you know constant static string at compile time we would really like this to not compile and give you a warning and indeed that's what it's going to do this is one of those fixes that was a back port to c plus plus 20 so c plus 20 is going to work this way if you are using the fmt library the fnt library has already implemented this and this is actually output from that library in terms of what it looked like before and what it looked like after and so there's actually a couple of links here you can go and play with that yourself with the different versions and see how how things have changed i'm omitting a whole series of other related issues with the format api that came up when implementers really went to go implement it there were some other issues that meant that that was going to expand the size of the compiled code in a way that vendors thought was unacceptable so there are other changes that went in and that's why it's a complete breaking change all of those fixes are back ported to c plus plus 20 so when you get official c plus plus 20 support from a compiler they will have done all of these changes and you will see them so the whole idea of it being a runtime error will not exist you can still by the way do run time formatted strings you just have to use a different api for for doing that so if you're familiar with the format you know that you could provide a runtime string which would over override a number of those things i'll also give a shout out to charles barto's talk from this year's cppcon 2021. if you want to know all the inside gory details of what happened in format you can go see his talk because he talks about exactly what happened he's part of the microsoft implementation team and he talks about what they went through and some of the issues that that happened as part of format okay so let's talk about print as i was mentioning print is exactly the same as format except for now we're not going to just restrict you to formatting to a string so that first bit of code that's highlighted is c plus plus 20. but in sql 23 there'll be a new header called print and that will allow you to do the same thing directly to the console without any anything in the way it will also allow you to do the same thing into a file or into a file stream so you have the ability or actually any any kind of io stream are sorry output stream so the new spam stream would be able to support this as well so this will allow you to do that directly now there's another thing i'm not going to talk a lot about here but one of the new elements of this is there are some overloads that are part of the whole print and formatting regime here that give better support for unicode for those who work with unicode you know that it's a troublesome area for c plus plus in in many respects so that is also part of this improvement you can go look at the papers and see more information about that this is actually really cool we are using this in the stuff that we're working on that my team is working on currently and i find it to be really nice so we're at a point with the print functionality where you do not need to use streams really for doing output so you know with maybe the exception maybe you're going to use them for files or something like that but largely you don't you don't need to use the iostream formatting facilities you can use these facilities instead so again this stuff is available in the fmt library there will by the way be a print line version so you don't have to put the backslash n in if you want to get a line feed the one caveat i'll mention about this is this is not implemented currently in fmt so if you go looking for print println even though it's part of the standard proposal it's not actually in the library itself so again with the godbolt links you can you can go play with these things after the session on your own and see what they can do so i think i mentioned almost all of this this is in some final design review it has not cleared lewg completely yet but it has a sched time that's scheduled for it to be completed it's had several rounds of reviews so it's in very good shape and i expect it it will get through to c plus 23. so of course it also if you're familiar with format you're interested in the performance this is one of the reasons this initiative is strongly supported and if you look carefully at these numbers what you'll see here this is you know the standard for print the i o stream is approximately three times slower what's interesting is it's it's pretty close so it may just be within the noise of the performance measurement but it's as fast as c's printf it's actually faster in the measurement and you could actually see where maybe c plus has an advantage here because it can do some things at compile time that maybe c cannot with the var signature on printf but in any case it's very fast which i is a perennial complaint with i o streams and so i think this gets you to a place where you know you could do all of your output anyway in this in this fashion so a couple links there for you to go later on as i mentioned at the top of this section specializations for other standard library types that don't have format specializations today some of them will get fixed some will not get fixed they're going to be continuing the big ones that won't be fixed are complex and file system path shared pointer unique pointer so those are going to slip into the next some other things that are like thread id and some of the reg x and error code are should be fixed okay so let me briefly talk about range formatting it would be wonderful right to be able to take a collection or another kind of range of some sort and and just be able to directly put that into the terminal i mean this has been one of those things where you know programmers have had to write their way around this sequels plus programmers have had to write their way around this for decades so right now if you look at the fmt library it has facilities for formatting ranges there is a proposal that will bring that to the standard this is one i'm not 100 sure is gonna make it given the time there's some complexities to it when you consider recursive collections or you know multi layer collections and so forth but in large part it basically looks like what you see on the screen here here's a vector of values and in this case basically i have a format specification which says give me two wide with a hex value and then join them together with a colon and basically i'm this is c equals 20 format so i'm just basically generating that hex string and then i'm putting it out to the console with the print as a string so that just prints out what you see here here's another one where i just take a collection of strings and uh you know i get some output that makes complete and utter sense for for that string now of course you can combine this with other range adapters and so forth so you know take two take five filter all kinds of other things that you can do that are very clever on some of the ranges slides i'll show you a couple of examples of that so you can go to the godbolt link you can go take a look at this paper and see what it proposes it does a lot more than what i showed here including handling complicated things like tuple and pear and some other things so a lot of really interesting work there that would make our life a lot lot easier for doing i o going forward all right as i mentioned i'm going to pretty much skip span stream i will show you this one slide [music] but basically span stream allows control over the buffer that goes into the stream this was a feature that came from the original i o stream in the 80s look up peter he'll love to tell you about it i'm sure there's ice stream and no stream versions of it and it allows you to get spans in and out as for example your primary utilization you can also make your buffer be other things you know within within the span stream itself okay so that brings us to ranges now this talk you know the entire talk could be about ranges there's enough material here that we could talk about this all day which is another reason why i'm going to jump over and do some highlights there's multiple dimensions of new things here that change things so the first thing is fixes to c equals plus 20. we'll talk about that in a minute so and as you know ranges are divided into algorithms and then range adapters and views so there's some of both of those also added in and then one of the fundamental things that was missing is the ranges to capability so take a range and make it into a container now a range is a container in the first place but the idea is that you can take a filtered or you know some kind of processed range and you know have an output container which you would then put the result into this next one pipe support so if you've used range adapters with the pipe syntax you know that's a very convenient syntax it's very nice elegant code unfortunately with c plus 20 the way the standard is written while you could create your own user view you could not create one that has pipe support that interoperates with the standard library so that's something that we definitely want to rectify because there's no way the standard library will have all of the view support that you could ever imagine and of course we want users to be able to write their own you know so and we want them to be able to interoperate with things so i kind of think this is almost just a slight overlook from the c plus plus 20 ranges and you can consider it a bug fix but it it opens up an important thing and also means again we don't have to put every single conceivable view into c plus plus standard itself and you know it opens up the boost and other libraries to provide those things in a way that you know operates well next one [music] interoperation with non-range algorithms we'll see about this one whether it's going to happen or not i'll briefly talk about it but basically this is the ability for non-range algorithms to play with ranges better and then this all didn't you know just happen again there was a subplan here that barry rebson and tim song and some others connor hockstra put together you know to try and move ranges forward so they split the work up into tier one tier two tier three kind of work and try to you know lay out a plan for what was the most important set of facilities to bring in c plus 23. and a shout out to tina's presentation from this morning how to rangify your code if you did not see that presentation and you're just getting started with ranges i highly recommend it it was very good and so definitely take a look at that okay so let's do the one minute review of ranges because i'm going to show you a bunch of code on the next slide and slides and you know just a little tiny bit of theory but basically write a range is just something that can be iterated over it has a beginning and the return iterators the classic collections and so forth we've had forever range algorithms of course then are algorithms that instead of taking iterators they will take a range of course all the ranges algorithms also take iterators but predominantly we want to call the range versions of them when we can because it's simpler and it's better and then views are just another form of range and they have this sort of lazy property it's not given that all of them are that way but for the most part they don't calculate things when they get constructed and they can be chained together with the adapters that's the last piece of it but they're cheap to copy some of the properties on views got changed as part of work for c plus plus 23 and they got back changed in c plus 20. so we used to think about views as never having ownership but that really isn't true because there are some exceptions to that rule for the most part it's true but there are important exceptions where we now actually have an owned view in the standard because when something you know when a view has to own something say a shared pointer to something underlying there are cases that we want to be still able to use views but so we have to relax some of the constraints that were originally there for c plus 20. okay so the simplest ranges code in the world is here's an array of values and i used to call it this way with begin and end and two iterators and now i just call it you know with ranges sort and that's it so you know that's for me again the 90 use case for developers is instead of calling a traditional algorithm that requires you to pass in the beginning end find a ranges variation of it if it exists and make a call to that it will do what you want and it will be cleaner and simpler okay so we got a whole host of new algorithms and some of these you might recognize some of them you may not start or sorry shift left and shift right were actually new regular algorithms in c plus plus 20. unfortunately the range versions of those algorithms did not make it into c plus plus 20. i'm not going to talk more in detail about those algorithms but again there are slides you can take a look at them full left and pulled right i'll talk in more detail about i'll briefly cover starts with and ends with you can pretty much guess what those are going to be about iota as an algorithm and not as a view so in c plus 20 we have iota view but now in sql 23 we're also going to have iota as an algorithm that was missing from the range of id algorithms and then find last is kind of on the bubble i hope but find last is basically a way to quickly look backward through a range if you've ever tried to write code with reverse iterator and so forth it's actually surprisingly difficult to get this code correct and so this is a nice utility and this would be both in ranges form and in non-ranges form as well all right so fold fold is a generalization of the accumulate algorithm and if you have worked with the range's algorithm since equals plus 20 you know that accumulate was not one of the algorithms and that was in part because none of the numeric type algorithms actually came about in sql squares 20. so fold is the first of a few algorithms that i expect to see and this one will should be in c plus plus 20. so it's a generalization of accumulate just like other c plus plus 20 range algorithms it has projections so if you've worked with projections that's a way to filter the range as you as the algorithm processes it and it takes two forms the there well there's the directional part of it which is either go from left to right or go from right to left so in other words forward to back or back to forward and then there's the question of how do we specify the initial value with accumulate you have to always specify an initial value fold on the other hand allows you to either specify an initial value for the actual calculation or it allows you to use the first element of the range instead as that initial value so that's what this first underscore first and underscore last variance of it is those underscore first and last mean underscore first use the first value of the range as the initial value or when you're folding from the right you'd use the last value of the range as the initial value so here's a simple example the signature simplified of course you know looks something like this we get a range we get an initial value and there's the projection which is defaulted to do nothing so a very simple example is you know add the sequence of things in this vector together so it's just like you would expect from cumulate and you'll get a numeric result here okay so i think that's going to be kind of it on algorithms oh yeah i said i'd mention starts with an ends with so starts with an ends with does exactly what you think it's a predicate it's going to evaluate a range in this case i'm actually using an iota view which is interesting and it's going to evaluate that you know this first range 0 to 10 starts with the second range 0 to 5 and yes then you'll do something and so forth and ends with the same kind of concept and so you can do this very straightforwardly all right so views and adapters and here's where we can see a lot of major additions to the library so we have adjacent which was missing in adjacent transform which actually goes along with zip and zip transform so that's the ability to look at you know multiple elements in a sequence as you process through cartesian product which you know we'll i think we're going to skip over that one but you can look at the slides but that one's going to give you basically a an unrolled for loop or a series of for loops depending on how many different ranges you're putting together chunk and chunk by allow you to group parts of a range together and slide allows you to see a part of a range for a time and move that that view along a particular range and then join with you might be thinking well we already have join which we did get in c plus plus 20. but join with allows you to take an additional delimiter and join a range together with that delimiter so i'm not gonna go over that one in more detail you can you can look at it elsewhere so let's let's just go back again and look at some sql plus 20 code here so this is again ranges 101 code i have a standard vector event i have a predicate here which just tells me whether or not a particular integer is an even value and then i'm using those properties i was mentioning previously about copy to cheap to copy and the laziness of a particular you know particular view to basically create you know a view here on the stack so this thing evens is the actual view it is made up of looking at the vector and then filtering it on even values but no calculation is really done at this time of construction that's really just the construction of the references and so forth to the underlying things to actually do something with the view i have to actually iterate over it intentionally so i have a range for a loop here where i just go through and print everything i can do the exact same thing different ways this is a filter view version so instead of using the adapter here i'm just using the filter view and in this case i'm passing the vector and i'm passing the predicate to the constructor these things are exactly equivalent in terms of the underlying facility of how it works they're essentially synonyms for each other i think these days most people are preferring this adapter style where you you construct this now you by the way i could have constructed that right in line in this for loop as well in this particular case i just did it as a demonstration that you can you know capture it on the stack and then use it later okay so that's all just c plus plus 20. and so you know as i mentioned mistakes were made in c plus plus 20. and so actually we had breakage in a bunch of different places nikolai joshudus brought to the our attention inconsistencies in the way i stream view worked that was broken that should be fixed join view had some other similar issues some other issues split view was far less than optimal the way it worked so that actually got renamed to lazy split view and a superior version in particular for string processing is now called split view so this stuff was all backboarded it is all being backported to c plus 20. so if you haven't started using c plus 20 you can ignore it it'll just work the right way from the beginning and you won't have known that it was not in an optimal form prior to fairly recently so okay so here's an example of that other case i mentioned at the top non-range algorithms in ranges so this is i've got you know my standard vector event here and i'm using an adapter to do a transform and so i'm transforming each one of these elements by squaring them you know basically calculating the square here but what if i wanted to actually you know sum that all up well and i wanted it to be parallel well the range algorithms are not parallelized at the moment so you have to use the standard algorithms so it turns out in some implementations this probably does not work currently which is unfortunate right because there should really be no reason why this particular range is is special but it has to do with the requirements on the iterators for these algorithms we will see if this gets in i do not know i honestly do not know this has not been implemented anywhere and that is usually a big problem and so we'll have to see whether or not people can get this implemented in time tested make sure it doesn't break anything else because that's important i think it's a really nice feature in the sense that it you know you'd expect to be able to do this honestly i was surprised when it you know didn't work i didn't come up with this but i was surprised when somebody showed that it didn't work and so it would it would be better if it works because it really should okay so the pipe support for views let's let's just talk a little tiny bit about some of the theory here so if you if you think about you know what ranges do and if you think about my slide two slides ago i kind of showed you this thing of adapters and views they're very similar to each other and in fact they the adapter generates a view and it does that in part by allowing you to have this pipe syntax and this pipe syntax essentially gets turned into a view constructor you know with that looks like this so if if this is a this is called a range constructor closure object and that's really the the meat of what's going on in this proposal and so to be able to do this you need to have a way to access the range adapter closure object and this facility will name that properly and will allow you to do that so then you can make all of this logic work exactly the same if you want to see the gory details of this jason rice i did a presentation in cppcon 2021 there's a link to the paper i think the cppcon stuff obviously isn't fully published yet so there's no links at this point but anyway if you really want to know all the gory details on what that's all about you can go there all right and i'm going to skip cartesian product [music] i'll just show a couple quick slides on [music] things like chunk so here you know i just want to divide this range up into groups of two well except for i have an uneven number so chunk is the case where it will give you as many as it's got and so this is chunking it up and by the way this is this is printing a range so you see here that same pipe syntax of the vector into the view adapter and you know so you can just write this code directly you don't need to put it on the stack you don't need to you know construct it intentionally so this is another one of those things where it very much minimizes the amount of code and again this code working is dependent on that range printing capability being finished slide is a similar kind of situation and it just slides over over the view chunk by gives you a predicate so you don't chunk by fixed size you chunk by evaluating to see whether or not a condition has been met let's talk just briefly about zip and zip transform that's a really important capability if you want to put multiple collections together especially if you're dealing with things like tuple and pair there's actually a huge number of changes to tuple and pair to actually support this properly and again what you're seeing here now is you know this ranges print facility in with a zip so basically we have several vectors this one's you know numeric this one is characters this one again is numeric so if i put one and two together under the hood i'm essentially creating a tuple of these things which is then being printed out as part of this print statement so you can see that this code is extremely powerful this is code that we just simply cannot write in c plus plus 20. and you know the economy of it for what it does and the fact that it's all very quick is is just a very good thing so there's some more here on the slides there's some different ways you can do transformation of course that's you know what the transform piece of things is okay and i'm going to skip up to ranges 2 which as mentioned is just a way to now take that range like a view for example and actually make it into a concrete collection sort of the various simplest form of this kind of thing would be i've got some kind of a vector then i do some kind of range based transformation and the last step here is this ranges to call with a vector notice i didn't have to tell it that it needed to be a vector event it figured all that out on its own so it's pretty smart about that and then again i can just print it out and so forth and you can go see this code work on godbolt it uses ranges v3 because ranges v3 has ranges to in a form that's similar to what's in the standard what is going to come in the standard is more capable of what more capable than what's actually in ranges v3 currently this is another example i won't go through it but it's it's a similar kind of thing with the strings and manipulating it so there's a bunch of ranges resources here i apologize for this table in advance there's a bunch of missing things here it's part of the reason why i'm going to keep it up to date there's more papers for me to put here that i haven't haven't gotten here yet okay so i'm doing okay on time but i probably gonna wrap up in the next 15 minutes or so here i don't know if i can do any questions i'm still not seeing a way to do that in the interface but maybe we'll figure that out oh there's a private chat here [music] let's see okay jen says he'll post questions here when we get there great so concepts for all the things i'm not going to dwell on this and i mean everybody probably knows that many things are being you know made more as much constexpr as possible just to enable more compile-time programming so variant and optional are two big things that got a lot of additional const experts added to them so i honestly have forgotten now if every last function is or there are still a few missing ones unique pointer is one that might surprise you since that's about memory management but the constraints on constexpr and memory allocation have changed in c plus plus 20 actually so that enables this to be possible c math is another interesting area if you ever wanted to do any compile time calculations for mathematical things you're using c math library not everything is there because certain kinds of things and it was a big sticking point what to do about errors in compile time context but essentially it's going to follow ieee rules and if it would give you an error at compile time then it's not allowed so you can go read the paper i believe i have links to that one if i don't have links to that one i should get them shortly but you can also go find it anyway those are some useful ones in two charts and from chars for integer overloads not for floating point only for integer and again the floating point at compile time is a bit of a sticking point to understand exactly how it works but we did get over that i think at least for some of the core cmap things okay [music] the containers i'm skipping and now we are have utilities and i don't know what the best thing is we got a question about hive or colony and the answer with hive colony is that is going to get deferred to c plus plus 26. does ranges to allow you to provide an allocator that should be used for the container to be constructed by that is a very good question i believe it does yes it does it does i do remember seeing that in the paper so yes okay do we have any more questions and i guess i'll also take you know shout out for any particular items that people want to see with respect to this monadic optional was actually covered by phil in his talk earlier this morning so you could actually go see that talk and see a little bit about nomadic optional and that's actually pretty simple it's just three functions expected i'll probably i'll go ahead and go through that because i think that's of some pretty big interest and maybe i'll go through stack trace real quick too so let's do those two any so question is any changes to the standard where exceptions are thrown in the past and where now terminate is called not that i'm aware of there is a proposal that i'm not talking about but we'll probably make it in that's [music] basically allows you to call a function called unreachable and that is to indicate to the compiler that this is a branch of the program that should never be reached but that's not quite what the question is here so i'm not aware of this the only ones i'm aware of are the two that i showed which instead of an exception at runtime now turn into a compile time error which is infinitely preferable all right so skip over monadic so let's talk a little bit about expected field it also mention this in his talk earlier this morning so expected is in some ways a fancy kind of variant that allows you to have expressed a return value and an error return and so like optional as well it's very similar to optional in that it has very much the same interface and in terms of being able to ask if it has a value or there was an error and but the error type is customizable so you can make it a string you can make it whatever type you would like including void and or sorry the void case is is one case here where expected does something that different than than optional so if your return from your function would have normally been void but you still want to process errors you can use expected and void with an error return type and it will all just work which is something you can't really do with optional so here's an example i have some boost date time code here boost date time uses exceptions in its interface so if you attempt to construct a time with a bad value it's going to throw an exception and so instead of that if let's say i wanted to you know go from an iso string to an actual time value instead of exceptions i wanted to make that an error return i could do something like this so in this case i'm just try catching and i'm making unexpected so this is the case where it's unexpected and you see here the type that i'm using for my error is just std string so i'm just catching the exception i'm converting it into an error return and this time expected return then will either have a p time value or it will have an error string in it so here's some code that uses it and exercises the good and the bad cases and as you can see no longer my exception handling here i'm evaluating a boolean to tell you know that this value is is no longer good and i'm not really very happy with this particular error that comes out that is the error that comes out unfortunately so this one is in the final phase of the committee and it's it's been it's been a long slog it's it's a big it's actually a very big facility to specify surprisingly for something that seems simple on its surface but it's in the last phases and i expect that it's going to be done pretty shortly okay and then also for error handling stack trace if you've used boost stack trace you would be so much oh well maybe i'll go back for something because we got a question why would you return expected instead of air i'm not sure i understand that question so yeah i'm not sure i understand the question but in this case basically it again it allows you to have a type where instead of getting the exception you can do that from your point of view how early or late should the trainer show newer features like ranges and format comparing to previous alternatives to achieve the same behavior in common use cases well to be honest with you i think i would not this is kind of like the old question you know should we teach c first and my answer is no we shouldn't we should teach the more modern versions of things first in part because they have superior properties so you know those kind of facilities are better they're safer and they're less error-prone than the former ones especially when you get into views if you watch my cppcon talk from 2018 you know i talked about how you know you know ranges with views versus you know range algorithms versus views and i think even others have made this point as well and some other presentations i've seen that the number of cases of error cases like off by one air cases for example that you can get with a view well you can't get it off by one air case with a view because you know when you use a range for a loop to iterate over it there's no off by ones whereas with a traditional for loop and a traditional set of algorithms you would get that so i think modern c plus plus first and legacy c plus plus later okay okay so i think the clarification of the other one is why would you use avoid of expected versus an air type so i think the the maybe i said something almost wrong there you always need an error type here so there's you can't have a void error type here but you can have a void for the return value of your function so if you imagine that your function just does something and it doesn't have a you know any kind of reasonable return that's when you would make this first parameter a void so hopefully that clarifies that question and lublio converted the brackets so i don't know about that i skipped over a slide with span as a function argument in it is that about fixing stdspan vector etc and [music] not compiling because of restrictions on range constructor of span have those restrictions been lifted i don't think anything has changed with span my span particular span slide was related to uh spanstream stuff so the answer is no i don't believe this problem has been fixed it's possible i'm wrong about that and something happened that i missed because there's a lot of stuff so that's it's interesting i'll i can go check on it but i don't think so okay see if we got any more questions all right i think we're good on questions so we'll do stack trace quickly and then we'll probably close it up i have about 20 more minutes before i have to go so stacktrace if you've used boost strat stack trace you'll be familiar with this capability this has been one of those again things that especially in debugging contexts has been really a challenge to do portably and you know so you can imagine doing this even in production code though with certain exceptional conditions where you might want to get detailed information about what's going on so this is one of those items that was unfinished business from sql plus 20 it was proposed this has already been added into the working paper as i say it's based on boost stack trace there's a ton of details that are complicated here there's going to be dependencies on compiler modes if you if you've compiled your code and stripped your code of all symbols and so forth you're not going to get symbols out of a stack trace you're gonna get you know some information that probably isn't too valuable to you so you know you're there's no universal portability with respect to what exactly comes out of the interface what is portable is the interface is portable so that in a portable way you can include the header stack trace you can snap a stack trace in a particular place in your program and then you can you know output it to i o streams or you can output it to a string or an i o stream and process it somehow later so you can log it do all those kinds of things so you know and again the details of what's in the stack trace are going to be a little different you know this is an example using boost stack trace that was put together and so the synopsis of what this thing looks like you know stack trace is basically a collection of stacktrace entries with a description a source file and a source line associated with it and you know you've got an operator for io streams here as well all right so i'm skipping interfacing with c and calling the add exit function so form and function r1 i think you know obviously this is c plus plus and c plus plus libraries have been getting more advanced more capable and still being fast and still being able to do things very close to the metal and so we've opened up whole new dimensions of design capabilities with the features in c plus plus 20 especially 23 not so much but i think we're getting a lot of nice new facilities that augment our stl2 so that's our new ranges library this is the link that i'm going to keep up to date i'm sorry it's cppcom but i only want to keep one of these up to date so that's the one to go to and i don't know if i can since i can't access the chat directly maybe i can put them in the chat and the ends can put them put them in so these other two links if you have not been to you know cpp reference for compiler support if you want to track closely what's going on right this is now really the go-to place to track what's going on with with features the only one disadvantage of what happens in cpp reference here is that the only things that get listed here for sql 23 or any other feature are things that have actually been voted in to the full committee so i showed you a whole bunch of things today that haven't been voted in by the full committee yet but i'm expecting that they will be assuming that all goes well so here's actually the list of c plus plus 23 compiler features so there are a few language features and you can go take a look at those and then you can see here the actual set of library features that have made it all the way through the process and if you look at this list carefully you'll see there's probably a few things that i again did not even talk about leaving out but when c plus plus 23 is complete in february when you come back to this site in february you should be able to see the complete content of sequels 23. so that's why i link to this because it's the go-to place for finding that and of course if you want to know what ad exit is and you don't know of course go there and with that i think i'll say thank you and i certainly am open to taking questions for another 10 minutes or so here okay hello jeff thank you for your talk let's see if there are any questions to be taken from the chat let's give them a minute to catch up with the stream and there i am so one question i would have is like how complete is the library for super class 23 is there like still a window folder to go in or is this like complete yeah it's the completeness is that the library evolution has looked at its backlog and has set up a series of meetings between now and january which is basically the point at which they have to stop work on design features and pass all of it to lwg for final wording and so there is no room in that schedule for anything more so if it is not in a paper already then it will not be in c plus plus 23. it is also the case that like you know hive as an example it was something that has been you know was something that's been in the process and been worked on and lewg has looked at it but the judgment call was that it probably wasn't going to make it given that it's you know in a medium to low priority so they just took it off the table for sequels 23 for the moment just because of the lack of time to actually process it fully and be sure and confident that it's a good facility in all respects okay so question does stacktrace make specific requirements on reporting stacks containing inline functions and i think that's another one of those examples where your mileage is going to vary i don't expect the i don't expect it to be the case that just because you put a stack trace in an inline function you know that it's going to be a problem you you should be able to do that whether or not you'll be able to see the sim symbols for it you know we'll have to see what the compiler vendors actually do if you look very carefully at that thing i flashed on the screen nobody's actually implemented it yet none of the vendors have implemented it yet and actually if you look at if i go back to this just for one second you know as i mentioned you'll see with a lot of these other things like the string contains some of these other smaller features many of the compilers have already implemented these c plus 23 library features so you can get them if you've got the most advanced version of the compiler and you use you know 2a usually is the flag or depending i think it's latest on microsoft's compiler so any known abi breaks in sequels 23 stl well the known abi breaks in c plus 23 stl would be in ranges which is stl 2.0 as it were and so it's not just an abi break it's an api break in other words it's not just that the binary is broken but the actual what you're going to get from the function called you know split view is not the same as it was when we shipped 23. so so yes those are the only breaks though format is the other thing there's none in the standard you know i dare to call them legacy algorithms the old school algorithms that are just an std there are no breaks there there are really no updates there either except for if find last gets in find last will have a regular algorithm as well all right so i will try and consume that tab so i still have it [music] yes so i think that brings us to the end of your talk okay thank you so much for coming that was awesome thank you for inviting me and i hope we can do this in berlin next year so seven minute talk summer talk yes of course and yeah so