and what was the first programming language if i may ask it this way that you fell in love with hi i think i'll call 60 and after that i remember my arm the snowboard i remember fortran didn't fall in love with that i remember pascal didn't fall in love with that it already got in the way of me and then i just covered a simpler and that was much more fun and from there i went to micro micro code so you were drawn to the he found the low level stuff beautiful i went through a lot of languages and then i spent significant time in in a simpler and micro code that was sort of the first really profitable things i paid for my masters actually and then i discovered simula which was absolutely great simula simulated albert 60 done primarily for simulation but basically they invented object oriented programming at inheritance and runtime polymorphism when they were while they were doing it and that was the language that taught me that you could have the sort of the problems of a program grow with size of the program berlin with the square of the size of the program that is you can actually module arise very nicely and that that that was a surprise to me it was also a surprise to me that a stricter type system than pascal's was helpful whereas pascal's type system got in my way all the time so you need a strong type system to organize your code well but it has to be extensible and flexible let's get into the details a little bit what kind of if you remember what kind of type system to pascal have what type system typing system did algol 60 have basically pascal was sort of the simplest language that niklaus viet could define that served the needs of nicolas viet at the time and it has a sort of a highly moral tone to it that is if you can say it in pascal it's good and if you can't it's not so good whereas simula larger is basically to build your own type system so instead of trying to fit yourself into niklaus pierce'sworld christ knew god's language and early on dallas language allowed you to build your own so it's sort of close to the original idea of you you you build a domain-specific language as a matter of fact what you build is a set of types and relations among types that allows you to express something that suitable for an application so when you say types the stuff you're saying has echoes of object-oriented programming dettol they invented it every language that uses the word class for type is a descendant of simula directly or indirectly christ knew go on all you and al were mathematicians and they didn't think in terms of types they but they understood sets and classes of elements and so they caught that typed classes and basically in c++ as in similar classes are user defined type so can you try the impossible task and give a brief history of programming languages from your perspective so we started with algol 60 simula pascal but that's just the 60s and seven i can try the most sort of interesting and major improvement of programming languages was fortran the first fortran because before that all code was written for a specific machine and each specific machine had a language a simply language or cross emplo or some extension of that idea but it you are writing for specific machine in the term in the language of that machine and marcus and his team at ibm built a language that would allow you to to write what you really wanted that is you can write it in a language that was natural for people now these people happen to be engineers and physicists so the language i came out was somewhat unusual for the rest of the world but basically they said formula translation because they wanted to have the mathematical formulas translated into the machine and as a side effect they got portability because now they are writing in the terms that the humans used and the way humans thought and then they had a program that translated it into the machines needs and that was new and that was great and it's something to remember we want to raise the language to the human level but we don't want to lose the efficiency so and the less first step towards the human that was the first step and of course they were very particular kind of humans business people but there's a difference so they got cobol instead and etc etc and simular came out no let's not go to simulate yet let's go to al gore fortran didn't have at the time the notions of not a precise notion of type not a precise notion of scope not a set of translation phases that was what we have today lexical syntax semantics it was sort of a bit of a model in the early days but hey they're just done the biggest breakthrough in history of programming right so you can't criticize them for not having gotten all the technical details right so we got alcohol that was very pretty and most people in commerce and science considered it useless because it was not flexible enough and it wasn't efficient enough and etcetera etcetera but that was the breakthrough from the technical point of view then similar came along to make that idea more flexible and you could define your own types and that's where where i got very interested first nicole was the main idea man behind simula i was late 60s this was late 60s was a visiting professor in halls and so i learned object-oriented programming by sitting around and well in theory discussing with with christ new goal but christ and once you get started and in full flow it's very hard to get a word in edgeways where you're just listed so it was great i learned it from them not to romanticize the notion but it seems like a big leap to think about object-oriented programming it's really a leap of abstraction it's yes and was that as big and beautiful of a leap as it seems from now in retrospect i was in an obvious one at the time it was not obvious and many people have tried to do something like that and most people didn't come up with something as wonderful as similar lots of people got their phds and made their careers out of forgetting about simula or never knowing it for me the key idea was basically i could get my own types and that's the idea that goes for a lines of c++ where i can get better types and more flexible types and more efficient types but it's still the fundamental idea when i want to write a program i want to write it with my types that is appropriate to my problem and under the constraints that i'm under with hardware software environment etc and that's that's the key idea people picked up on the higher is in the virtual functions and the inheritance and that was only part of it it was an interesting in major part and still a major part and a lot of graphic stuff but it was not the most fundamental it it was when you wanted to relate one type to another you don't want the more to be independent that the classical example is that you don't actually want to write city simulation with vehicles where you say well if it's a buy signal to write the code for turning a bicycle to the left if it's a normal car turn right a normal car way if it's a fire engine and right the fire and in waited out a doubt about you get these big case statements and bunches of if statement and such instead you tell the other the base class that that's the viacom saying turn turn left the way you want to and this is actually a real example they they used it to simulate and optimize the emergency the the emergency services for somewhere norway back in the 60s wow so this was one of the early examples for why you needed inheritance and and you needed runtime polymorphism because you wanted to handle this set of vehicles in a manageable way you you you can't just rewrite your code each time a new kind of vehicle comes along yeah that's a beautiful powerful idea and of course it it stretches through your work lucy bus bosses will talk about but i think you structured nicely what other breakthroughs came along in the history of programming language is it if we were to tell the history in that way obviously i'm bitter telling the part of the history that the surpassed i am one as opposed to or in the past yeah you skip the hippy john mccarthy and lisp one of my favorite languages but let's understand what lisp is not one of my favorite language yes it's obviously important it's obviously interesting lots of people write code in it and then they rewrite it into c or c++ when they want to go to production yes it's in the world i met which are constrained by performance reliability issues deployability cost of hardware i i don't like things to be too dynamic it is really hard to write a piece of code that's perfectly flexible that you can also deploy on a small computer and that you can also put in say a telephone switch in bogota what's the chance if you get an error and you find yourself in the debugger that the telephone switch in pockets are on late sunday night has a programmer around right the chance is zero and so a lot of things i think most about can't afford that flexibility i'm quite aware that maybe 70 80 % of all code are not under the kind of constraints i'm interested in but somebody has to do the job i'm doing because you have to get from these high level flexible languages to the hardware the stuff that lasts for 10 20 30 years is robust yeah operates under very constrained conditions yes absolutely that's right and it's fascinating and beautiful in its own way it's c++ is one of my favorite languages and so is lisp so i can i can embody two for different reasons as as a programmer i understand why it is popular and i can see the beauty of the ideas and similarly with this more talk it's just now this relative thank it is not as relevant in my world and by the way i distinguish between those my functional languages where i go to things like ml and haskell different different kind of languages they have a different kind of beauty in there very interesting and i actually try to learn from all the languages i encounter to see what is there that would make working on the kind of problems i'm interested in with the kind of constraints that that i'm interested in what can actually be done better because we can surely do better than we do today you