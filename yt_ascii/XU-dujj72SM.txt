so let me start yes so so today i'm going to talk about smart porters and i hope you'll enjoy the topic this is not a state of the art syphilis plus not the newest version still i think there's some very interesting things that needs to be considered and sometimes are overlooked even by and experienced developers so i hope you'll enjoy the talk thank you okay so let me start with who am i i'm an embedded developer working at solaredge by the way solar just entered s p 500 this week which is great i'm a core cpp user group organizer one of the organizers this is a user group in israel i'm also an iso cpp director sg9 which is the rangers study group chair lewg co-chair this is the library revolution group and israel and beacher i participate in as a meeting i teach the plus plus i sometimes publish simple class papers and articles and i think it's safe to say that i'm really into c plus plus so let's start so today we're going to talk about the ownership model of c plus plus the syntax and design of smart pointers how to successfully use smart pointers with library code and what the future holds so sometimes it seems like for for ownership of course sometimes it seems like this topic is is off the table so i've entered this slide as well this is a bjarnis talk from the last cppcon 2021 it's not published on youtube yet and the talk is about type and resource safety in more than simple class and i was really excited to see this slide talks about ownership rules i think i think that it means a lot that the creator of c plus plus is talking about a topic that looks like it's been already handled but is still actually have open hope open ends and open topics in it so yeah so i think this topic is going to be changed and modified in the co in the coming years and i of course recommend you to go and watch the talk once it's published so what does ownership mean ownership usually refers to management of object memory usually when people talk about ownership talk about memory and lifetime and i think you can address ownership in multiple levels you can address the value you can address the pointer level so this would be clearly in dynamic allocation and proxy which is a wrapper but also when i address ownership in this doc i also address other than the memory i also address the value so i would i want to give you an example of what i mean by that owner of an object can update the data so let's say i have an int represents a month and the int is from 0 to 11. so i could change the value from 0 to 1 and from january to february actually this is like representing the month i could also valid invalidate or move the data and it doesn't mean that i have to erase the object so if i insert 14 in my in my object it already means that this object used to be month that used to represent month is no longer valid so each ability have different effect on your program and i think this is something generally the ownership of of your object is something that needs to be considered when you design your program so smart pointers are basically created to help us manage this ownership better clearly c plus plus have a lot of abilities and it's it's it's a very rich language and one of the things that we can do with it is manage dynamic memory but when we do allocate the memory straightforward we sometimes lack a few of the ownership topics that i've just mentioned so smart porters are really helping us create the ownership model in our program and i would say they help bridge the gap between manually managed memory and automatically manage memory i'll give an example to that so first i want to just emphasize those two points that are clearly probably being known by by a lot of you but i still want to have just go over them to to emphasize so compile time is what we know about the program when it constructed runtime is what we know about the com program when it runs so if we look at compiled languages for example i have an id i write code sometimes i can import or include the library and then the code goes to compiler i get an executable and the executable is not is is now being transferred into the target machine usually it's not it's necessarily running on the same machine where it's constructed and when the program runs it can ask for additional memory from the os for example on interrupted languages like python for example i write my code i import library and then we pass the the outcome to the target machine but in order to run the program we also need to have a manager to manage our private our heap usually been allocated by the manager so this is once the program asks for memory it doesn't go directly to the operation system it goes through the manager and i think that in some way smart pointers help us go from this to this so we're going to talk about unique pointer shared pointer weak pointer which are which are the three main main ownership model primitives i would call it but there's still a lot of other things that we're going to see and and i'm going to represent a few more from the standard library so let's start with how does this help us we have a simple program we allocate memory for this and and in case we return here we get a memory lick so again i'm sure all of you already familiar with that when we use smart pointer we create an ownership model for the allocated memory so in a way we transfer the responsibility for this object to something that is not in par is not part of the code that's written in the program it's not part of the code written in this level but it's part of a code that's written in a different level so we basically take this part of managing the memory and put it in a different code which i think is a great design other than other than just taking care of the memory so now we have a location and we have something that guards our memory of course when we return we don't get the memory leak and we can also have this at the same time by using make unique and make shared factory functions from the standard library and later i'm going to show you why they also have other benefits and of course we can treat the memory just like we do for a location we can catch the [music] exception and one more thing that i want to show you about one advantage of using make unique is here let's say i use a unique pointer to wrap my allocation so and i do that twice and i call function with those objects so here i will get an unsafe behavior because let's say i allocated this int and then i call this line and the compiler could actually allocate and then move to the second location but now if the second location fail we have we can have a memory leak because it's still not being wrapped by the unique pointer on the other hand in the second example we do the two things at once so once i allocated the memory i'm already i'm already sure that this is going to work as intended and then even if second one fails the first one is already safe so this is another reason so that to use the facilities that the standard library gives us in this case so let's talk about let's talk about unique pointer and single owner model we once we allocate a unique something and wrap it with unique pointer we actually declare to the program to other developers that read the code and and we insert into the design a single owner of this facility so of course you can use auto and if i try to take the ownership of the resource i'll get an error clearly that's why i need to move the resource to the second unique pointer and trying to access something that i've already taken is undefined behavior so i want to emphasize this principle that you're going to see through the presentation and even though a lot of there's a common recommendation to treat smart pointers just like regular pointers which makes sense you still need to remember that the wrapper is not the object and it goes into a nice initials twin two because it is actually a twin to the object it's it's not the object itself and sometimes bugs can come up from assuming that this is the same thing so you always have to keep that in mind as well and because it's not the same thing there's a api that allows you to do to only address one of those the wrapper and the object separately so release for example will return the pointer and terminal terminate ownership so you'll keep the resource where you terminate the owner and reset will terminate the resource but keep the owner alive actually replace the ownership so i think it's an interesting thing to to keep in mind that we can have actually different behaviors for this this thing that is actually being constructed from two two different parts so of course unique pointer can also be used for arrays and you can [music] can have a containers of unique pointer and if you want to have a range a allocated unique pointer of a vector of unique pointers then you have to use make move iterator and take the you first have to allocate the array and then you have to use make move iterator to initiate your object and use initialization list syntax and you can also have a unique pointer of c style arrays so you can call make unique and have a c style array wrapped in your pointer so another thing that that is a relatively new and only entered in c plus 20 is a function called make unique for override sometimes especially when we care about performance we don't want to have the the creation of of an object such that we do in the first line is also is also the instant the instantiation also have initialization but occasionally we wanna avoid that especially if the array is is a large one and we can do that by calling this function that avoids the initialization and last thing is that we can also have a unique pointer of a container so we can have a unique pointer of a vector so notice the difference and of course what we say when we do something like that is that we can't copy our resource which is now the vector so that's also a way to to to tell the other developers our intention and this is exactly what we wanted to do we get the ability to forbid from copying but what about performance so we have this edition and we want to want to use it in our program but if you really care about performance like we do in embedded systems occasionally is this cost us so let's look at unique pointer from the standard library so this in unique point from from lib stood c plus plus of of gcc you have it's a header facility it's a header only which already tells you that this is a compile-time thing you have a part that is responsible for a single object and you have a part that implements a unique pointer for array of objects with runtime length we'll go deeper into the first part but i really recommend you to go and look at the code the link that i've posted here yourself i think it's really interesting and helpful to look at a standard library implementation code so the first part is actually quite what we would expect from from this kind of a facility so we already mentioned we can move we can sorry copy or call operator equal and this is exactly what we get here so we have unique pointer class it have a data member that actually inherits from unique pointer implementation as usually things in libraries do you usually hide some of the implementation in a different structure with this with this mark and then this holds our our type pointer and also the leader the letter type that i'll address later now you have of course the the object itself and you have a constructor the constructor actually gets the type of the pointer and holds it in in this data type that we saw and as i mentioned deleted copy constructor and operator and operator equal and default move constructor of move assignment so that actually makes a lot of sense and as we'd probably expect from this type of facility and of course you have the structure and the the other ap functions that i've mentioned before to allow additional additional things that you can do with unique pointer so going back to ownership let's define the ownership characteristics so as i mentioned i think that there's more to ownership than just the keeping the the allocation and the memory and i the in simplest there's different ways to effect the ownership of the objects in your program so the first one is by moving an object so once you move an object you affect the ownership the second one is passing an object as a function param because we all we know that once we pass an object to a function you get a copy of course with a reference it's different but once you do such an action you have to define how would you like to address the ownership and of course returning an object from a function which again creates a copy in most cases we're going to see later how is this affecting our ownership so let's start with the first event passing an object sorry the second one passing an object as a function param so i have here a library of say a devices library and it knows it actually expose facilities to print a device so i can pass a unique pointer of the device dev and print information on the device let's say in this example it's a serial number of the device i could also expose a function that takes a device by pointer and do the same thing but again don't focus on the on the implementation the i could clearly in this implementation i could use a template function or something like this sort but i intentionally made those functions different and the point is that we probably want to do different things for different types and of course overload will call the proper function as needed so now i have a main function and i want to call my print function but first i asked from the user to give me the unique pointer of the device and then i call the function of course as i mentioned we are creating an ownership event and as we've already seen unique pointer can't actually be copied so we'll get an error so there's two ways to solve this the first way is that the user code will give ownership to the library so we'll call move instead of just calling with the device and the second option is that ownership remains in the user code and we pass it by reference we change the signature of the function now i will go back to that later but currently i'm just addressing that from the technical perspective later i'm gonna i'm gonna talk about how is this be should be handled in a manner of of of design perspective this the third ownership event returning from an object from a function so now we have our devices library and we have a function called getdevice and now we already improved our api and let's say i have a new device that could actually behave create a unique pointer underneath and returns a device and a new device it's a different function that create a device but what it does it's just returning the mac unique from from the function so the question now is what's going to happen so let's say i create a device and then i call the first function which basically needs to return this device and on the first case we'll get an error because we use deleted copy constructor so again as i mentioned we have our ownership event and we try to copy but this time it's not because we pass the object to the function but because we return it from the function the second option even though we would expect this to to happen we actually get the code actually compiles and runs now what what happens here is that we get an optimization that's called a named return value optimization and is mandatory starting from cps 17 and we create an object inside the function and we return it but in behind the scene the compiler is actually discarding this this line and just returns an object it's actually not returning it's again it's implementation detail but it's not returned the object is actually returning the parameters to create objects and the object is just created here so this is the named return value optimization that actually changed the ownership model of our code even though we're doing something that shouldn't have been compiled we still get a behavior that is different and the last one is doing something very similar called return value optimization and here again we have an optimization that prevents us from copying this and actually works not as you'd expect from this from this code so what i'm trying to say here is that it's important for us to address the memory model in and the ownership model in our program sometimes the code will not will compile and we'll think that everything works perfectly well but actually what happens here is is optimizations and changes the compiler is doing and it's okay to rely on that but you have to take this under consideration when you when you write your program and make sure that you're writing it correctly even even when you have ownership events and again the way to address that would be to return and move the resource out of the function or to actually pass this as a reference and return as a reference i'm addressing the first function here and you also need to count on the user to use to to take it back by reference but i've mentioned before we're gonna go back to that because i wouldn't this is not a real example of library code that i'd expect to see in in real code bases and i wrote this code like this to emphasize the technical aspects but i do want to have i do want to show you a bit in next slides how to actually write user code that use smart pointers correctly with the library okay i can see there's a question by ants is there's any real difference between accepting a unique point of function parameter by value or as an r value so i okay so basically when you accept it by r value you you create it in the call and you don't and then and then it could actually work differently but i wouldn't want to i wouldn't want to see code that that calls a function by r value in any case because you get something that is like so usually it probably not compile or probably won't do what you want us to do because the because of the meaning of doing something like that the meaning of doing something like that is creating an object when you call the function and then getting back the object from the function so i i'm not sure if that's what we would want to have in in code so again the point is make sure that the code actually expresses your intention okay so again a shared pointer creates multiple owner model as i've mentioned before and again we need to remember that this is not the wrapper is not the object and it's meant it's managed by reference count so again this talk was originally written for back to basic track so i don't want to go into the details of reference count i would assume that most people in this group already know this but there is one one sentence that i want to emphasize and that is when you use make shared library functions you can also get an optimization for the allocation because as you've seen the object of shared pointer is actually created by two it have two parts the first part is the manager part which is the part that holds the reference count and have its own memory allocation and the second part is the object that you're holding and they don't have to be they usually allocated this way one after the other but they don't have to be allocated this way and the first manager part actually have holds the address to the object so once you use make sure you can also get optimization of allocating both of them at the same time and that's just another reason to use facility library facilities okay so i want to show you a common pitfall and this is the last slide before we'll go into how to really use that but i'm showing here a common mistake for for people that are relatively new to the language and it actually makes a lot of sense though so let's say i want to have some kind of a device so i create a device here a new device and i'm going to wrap it with shared pointer so i implemented the function that's called wrap with shared and i give it a device and i expect to get back a shared pointer so i created a device and then i called rap richard and actually got what i expected because now i get the wrapper wrapping the device that i've passed but now when i call the second time to the to the rubbery chair i get a different object than the one that i've intended to and and the manager that manages the the same resource it holds the address of the same resource have a different ref count and this is a problem that that basically you could easily miss because as i mentioned the wrapper is not the object so to bypass that we're going to see a next slide how to actually have something that is very similar to this implementation but correctly so before that i just wanna talk about weak pointer very briefly weak pointer is non-owner model so it's used to keep handle to shared pointer without claiming ownership so that we can prevent a circular point pointing and and and to be able to free the memory for objects that keep pointers to each other and i'm not going to show it here because this is really the most common use case and you can find it very easily but i just want to go over a few of the functionalities of weak pointer so you can get the reference count you can have you can ask if your weak pointer is expired and you can also lock it in order to return a handle with ownership and i just want to show a very short example but this example is is wrong and again i'm gonna talk about this in the next slide so we have a weak pointer here and i want to check if the weak pointer is expired and if not i want to take a a pointer to the actually what created here is a shared pointer and i want to create a shared pointer of this weak pointer with by calling lock the problem here is that once i end this condition i can't be i can be sure that i'm still in the same state once i enter the scope so we're going to see it a bit later so as i mentioned smart pointers are are a way to manage memory allocation on the hip and of course once we go to multi-threaded program we can have multiple stack objects that all points to the same hip and we can also have multiple stacks because because of multi-threaded implementations and the example that i've shown before if we look at at the example from multi-threaded perspective and it's not that i'm saying that everyone needs to take this under consideration because not everyone are working and multi-threaded environment but if if we look at the code from the design perspective then once we get here with a single thread we check if the condition expires and then let's say we got a contact switch so we moved to the second thread and this friend already knows that he can take the resource assuming some other thread have already got got rid of our shared pointer we'll go back to the thread that originally called the condition and we'll do something that actually we didn't intend to so the problem here is that we're not going to fail what we're actually going to have is a creation of a null shell pointer an empty shot pointer in in case of this have been deleted and this is not what we intended so my point here is that when we do use smart pointers in multi-threaded environment we should take such things under consideration now i'm not going to go into that topic so so one thing to do would be to call the lock which actually checks and retrieve the object but again it doesn't mean that this is the final code we need to make sure that we use them right and and since this is a topic for a complete different session i'm not gonna i'm not gonna go into that in too many details but but that's but that's uh but that's something to consider when you do use smart pointers i just want to emphasize here as well that this is another reason to make sure that you use standard library facilities like make shared and like luck that actually does two things they usually do things better okay so what have been advocate advocating is to consider the ownership of your library code so now we're gonna see examples of how to actually use smart pointers with library code or better ways to do so to avoid the problems that we've seen in a in the previous slides the technical issues so i have my device class here and it have a serial number and a constructor and it keeps the serial number and i have a function called add model to this device so let's say i want to change the serial number somehow in this example just add a character to the end so that i can know this is a device model a so i create my device and then i call add model function and that's great but what happens if i change at some point the library code to use a shared pointer and the user have just created a unique pointer because this is the api that i've exposed so far now we have something that doesn't work and we didn't intend this to to happen so a better way to react with library code from the user perspective would be to have a function called get device just the one that here is an example for it and the user will pass the data that is relevant for this object that you want to create but it will get back an object calling auto and in this example even this is something that's called the factory method and in this example even if i do change the type to sharedpointer the user doesn't have to be exposed to that so this would be the better way to address smart pointers in library code okay there's a question about slide 21 i prefer not to go back to it now i'll go back to that at the end and another facility that is very useful from the standard library to do something that we already saw before in the slides and we know that we should be avoiding is enable shared from this so we saw previously the make a shared pointer function that we already understood why it doesn't work and here we have a facility that is provided by the standard library to do something very similar but actually works perfectly so we have a device here and we and we wanna to use the function get device as we already saw in the previous slide so we basically use a library implemented function factory function to have the object that we want and the device implementation is inheriting from enable shunt from this which is which is a facility from the standard library as i mentioned and it's a template base class so it have to have the type of the of the class that it wants to to create and we have here as i mentioned it's a template class and we have the constructor being hidden so that the user wouldn't be able to create it directly instead we expose a create device static function and an additional function called get handler so first of all we'll create a device instead of instead of a previous example with with our static function and then we'll be able to get handler handle for the device and the get handle will return us a shared pointer now assuming we'll take the same object dev1 we will be able to call this function just like we were trying to do with make shared but but successfully so this is a utility the standard library is providing and is also allowing us to have a better api and infrastructure okay so i'll go back to slide 21 now because we just passed to a different topic shouldn't this function except a weak ptr okay okay so if you're referring to this function the idea is oh right yeah i see what you're saying yeah i think i think yeah i think that could be a weak ptr instead yes you're right sorry for the confusion thank you okay let's jump forward okay so again just a few things that to consider when using smart pointers with library code and user code so once you pass an object to your library you should consider ownership in your in your api so there's another thing that you could do instead of using the factory methods that we did before which is create this manager and and give all the and and and delegate all the different usability to this manager so this is again it's not a solution that fits all cases and we've seen we've seen multiple ways to to address ownership but this is a solution so you could also have a manager and the idea is that this manager exposes the api and the user only gives it in this example the serial number of the device only gives it the the the data that is that needs to be considered and all of the management and allocation and and ownership of the objects is something that is being managed inside this manager object so that's another solution so riai as you've already seen we're addressing quite a lot of that in the presentation and we've seen an attempt to to manage ownership of objects and i just want to show here another way to do it using a unique ptr deleter object that we've seen before so if you if you recall we've seen in the library implementation of unique ptr the deleter if you don't pass the deleter it will be default deleter for from the standard library but if you if you want you can use it in order to manage your ownership of objects so okay so we have here a wrapper and i generate in this example i want to show an example of generating some kind of a serial number from a type of a pool or something other other code that have its it's facilities and usability and i want to have a wrapper on on this serial number that is being allocated and once we reach the end of the function i wanna get this back to the to the thing that's created it so i can get my serial number from this generator pool thing and wrap it with with a unique ptr and once this unique ptr is is reaching the endoscope the f the function that would be called is the release sn function which is actually a functor so the operator will be called and instead of deleting the memory we'll do something for for example erase this serial number from the database so we could manage the ownership of objects not only in the memory sense here we don't free memory we write to a database and then we release from a database or erase from a database which is a different kind of ownership in our program and a very useful tool to do that would be use the custom deleter of unique ptr so again i think it's very interesting and the standard library gives us a lot of tools not not always being used okay so very briefly i'll go over a few of the standard library classes using rai and you can of course see here a string and vector containers j thread which actually rejoins the thread on destructor uniclock and shared lock which are exclusive exclusive music wrapper and shared music's wrappers and low card which managed ownership of mutex in a scope sculpt lock is actually a more advanced facility that allows us to manage the ownership of multiple mutexes for example if i want to lock more than one mutex but i don't want to avoid rest condition there's a there's a code behind the scene of this facility make sure that i don't get a race condition and a deadlock on on my mutexes and experimental namespace also contains scope scope exit which is a general purpose scope card i think it's something that probably need to go into the standard very soon and one more thing that i've mentioned and i've shown i don't know if you've noticed in the first slide bianna in his talk is mentioning jsl gsl which is a guideline support library this is a library that is currently only implemented in msbc but it's a library being written by the simpleplus core guidelines that appears in iso cpp website so i think it's very interesting to go even for experienced developers to go and go over this this library implementation there's some very interesting utilities there one of them is jsl is for the initials one of them is owner it's a wrapper that actually permits multiple accesses to to an object once we know its ownership and this is really i think connected to the main topic of this talk to consider the ownership of our objects is not only to consider the dynamic allocation or the memory ownership it's also to consider who and and in what part of the program we can access and change the values of of the object and the data and as i mentioned i think i think there's a lot to be still be done in this in this field so a few proposals that suggest changes related to ownership model so mixed comparisons for smart pointers is basically allowing the the comparison of smart pointers with our regular pointers etc it's still not in the standard it's been discussed i think it's interesting because it bridge the gap between smart pointers and pointers in our in our code and will allow better use of smart pointers there's a proposal called pointer lifetime in zap this proposal is also very interesting to my i think it it will really open a lot of utilities for c plus plus so for example if we look at garbage collector the way garbage collector works is that you basically allocate memory throughout the program but you don't free it you run this this logic that actually goes and clean all the memory they've been allocated now in order to do this smart management of resources one thing that the garbage collector can do is mark the the pointers once freed with additional data and this proposal is not exactly proposing that but actually goes in this direction and i think it's very interesting to allow those those things in the library implementation and and of course that could affect the library implementation and will open the the window for different smarter ownership managements in our program and additional proposal is called what is the view or the voted into [music] 23 and basic basically defines what so so i don't know if you're familiar with the ranges library i hope you are because this is really great great library and tries to define the ownership perspectives among other things of views and views are things that points basically reference to references to ranges and when you do try to create a view you have to take under consideration the lifetime of of your range so this is i think it's an interesting proposal trying to improve the the ownership of views and ranges in the rangers library and of course as i mentioned already before this year's cppcon had a talk by bianna strausstrup about type and resource safety in modern c plus this is the name of the talk and it's also the name of this paper that been published some time ago and this is one of the reason i'm i'm saying that memory ownership and resource management is not something that is already solved in cpas today and i believe that there are some changes that will occur in the future in this very interesting topic and yeah as i mentioned be honest talk so to summarize consider data ownership in your design ownership is the window to advanced facilities as i mentioned garbage collector is an example for it collecting statistics is another example and changes are coming thank you that's it thank you for giving this great talk found very interesting thank you i'm glad you enjoyed yes um