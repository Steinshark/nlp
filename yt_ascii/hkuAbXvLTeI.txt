yes and there's the first question which directly fits into our topic which on do you think there will be an rv break in the future i think that has to be because the the whole concept of what c plus plus the obvious thing c plus grew from c c has a very simple conventional idea of what an abi looks like historically and so it's it's at a very it's at a very primitive level what is needed to but the thing is that c plus plus is not simply see with classes we've seen the problems with this in trying to get separate compilation for templates in the first time around c plus 98 the template model was not simply just a few generics in a simple fashion it actually changed a lot of language if you've ever tried to debug templates you will know that that is still not satisfactory in 2023 compared to and certainly error reporting because it still most compiler models or mental models people have operate off the idea that it's just a procedural language and errors happen in one place if there is a compilation area happening one place now what's this got to do with apis well quite a lot because the whole thing is what do you need from the language the idea the original idea is if i have a syntax error in a traditional procedural language that syntax error is in one place there is only one thing that could possibly be happening if you're calling something you are calling a function in c plus you could be doing any number of things the language has built on top of this very rudimentary simple idea and what it needs and particularly when we start you know including a proper discussion of things like modules profit discussion of dynamic linking a proper discussion of some of the things that we want and one of those things when people say if we design this from scratch we designed it again we'd do it differently the gap between what is available now and what the language wants to be i mean c has not moved very far from its starting point in this i think we have to have some kind of breakage i think i think it has to be i think we have to have a you know for the various platforms of version one under version two as simple as that or an idea of abi evolution but i i don't think i think the fact that abis are non-standard or rather are set by a particular historical precedent and don't mix well and can't evolve is going to stand in the way of a language that is supposed to be a systems language that's its origin it's a sister's language it's supposed to be portable and that used to just mean source code portability we don't live in that world anymore and so there has to be i think you know i don't think c plus plus is going to disappear overnight that's not going to happen but when people start saying we could do a better job at this level and they choose another language then that obviously will push it down a bit so i think there has to be that if it's going to be serious about being a systems language that people can use for what we mean by modern portability or modern architectures and avoiding the abi question is not helping c plus plus i i do think we need to address that and there was a very interesting paper coming up this standard way to address that that you could define code blocks as interfaces and then basically say this code block is valid from either you could use a standard version like this code block is only valid for c plus plus or you could like define your own versioning like if you're if you like your library and you want to say this co-workers version two now for version 1.1 and that that way you would be able to compile down the same code base into different versions and have like kind of everybody be happy and i think that yeah that would be very something interesting to have on the library i think i think that has to be the way of it because we've seen the language since the language has evolved the hardware architectures and operating systems we work on have evolved what we mean by modern software architecture has evolved but if the abi doesn't move that becomes ultimately a a bottleneck and a work you end up with an abi that is consistent workarounds yes i mean well yes that's it that's that's how it is it's not theoretical of what we're talking about it's this if if you're worried about like caching effects shared mutex on windows are smaller than the nano new text because the nominal texts had in its original implementation and it's stuck in this api forever supporting windows xp and yes it could be a lot smaller on linux so this was gcc it's a lot smaller but on on windows the shared new text is in the memory footprint a lot smaller than the the standard mutex and stuff like that is yeah so we end up being stuck with experiments of the past we've prevented evolution and therefore prevented improvement even though everything else around it is improving the underlying platform could do better there are compilers that could if we broke that you could do everything better so i think perhaps a different way of answering the question is do you think there'll be an abi break in the future i think let's look at it from a different point of view it's like kind of yes but also i think we need to approach it philosophically i don't think breaking one and then moving to another is the answer we should learn the lesson of like oh it's always going to change that's the lesson it's always going to change how do we accommodate change and that idea of being able to target things differently i think is incredibly important because change is one of the few things that is normal yeah and we now know this is a thing we should accommodate that so