hello the fourth task in the sliding blocks project is to get the blocks to move smoothly from place to place only one block should be able to move at a time so if the player clicks quickly on a bunch of blocks they should all just wait their turn so to implement this i'm neatly onto the block script and i'm going to create a kuru teen it's alright iron numerator and i'll call this something like animate move let's see were taken a vector two for the target position and a float for the duration of the movement i'll then start by recording the initial position in a vector two so i'll set this equal to transform dot position and also create a float percent starting at zero and it's just how fun to the movement we are so at 1 the movement will be complete i'll just say wild percent is less than one i can increase percent by time.deltatime divided by the duration all right it's then as simple as saying transformed a position is equal to a vector to develop between the initial position and the target position with the percent as our value there and then we can just say yield return null so that it weights a frame between each iteration of the while loop alright we're now just need a waist who conveniently call this from the puzzle class so i'll just make a public void cold move to position taking in vector to target position and also throat duration let's were to say start co-routine animate move passing the target and duration parameters okay so i'll save that go into the puzzle script and now instead of setting the block to moves position directly i'll just say block to move dot move to position passing in the target position and a duration i'll just say point three maybe okay let me save that and give it a quick try so these are now although smoothly but of course if i click on a bunch of these in rapid succession you can see them overlapping because they're all trying to move at once so let me go into the script and up at the top here i'm going to create a queue of type block chuckle my inputs and then i'm going to just cut all of this stuff out of the player move block input method and replace that with inputs dot nq blocks remove so just adding that block to move to the end of the queue and then i'll make a new method called simply move block taking it block block to move and i'll paste in that movement code okay now i obviously need to know when a block is finished moving so in the block script and groove just copy this on block pressed event and rename this on finished moving i'll take out the block parameter since you don't really need that and when the animate move co-routine is finished running i'll just say if the unfinished moving event is not equal to null then i will invoke it back in the puzzle script can then have a method which i'll call simply unblock finished moving and up here i'll subscribe it to the block dot unfinished moving event by saying plus equals unblock finished moving okay so now i want a rule to keep track of whether or not there is a block that's currently in movement so block is moving and whenever we move a block i'll set that to true and when this method is called i'll set block is moving back to false when the current block is finished moving i'll want to see if there are any blocks waiting to be moved in the input queue so i can say move block passing in the next item the cuso inputs dq but of course inputs could be empty and also the next item in the queue could be an illegal move in which case it won't actually move the block of course so i'll put this in a while loop saying while inputs count is greater than zero and while no block is moving so now if this is empty then it obviously won't be called and as soon as a block is successfully set in motion then the while loop will also terminate now this is all good but of course if there's no block currently moving when the player clicks on a block then this co-chair will never actually get called so i'm going to put this in a method of its own i'll just cut that out there and make a method called make next play a move paste that in and so in this player input method can immediately try to make the next player move and when the block is finished moving we can also try make the next player move okay last thing that i need to remember to do is just to actually initialize this input skew shall do at the bottom of the correct puzzle method just set this equal to a new cue i'll write another unity press play and we should see that if i click on these rapidly they all wait that time to be moved i should definitely turn down the move duration a little bit but it's basically looking good okay your task 5 is about shuffling the puzzle so you should be able to say how many moves you want the shuffle to take and then press some sort of input to say the spacebar and it should do its thing all right so in to shuffle the blocks i'm going to need a reference to them so let me create a two dimensional block array i'll just call blocks and i'll initialize that over here blocks is equal to a new block array with size blocks per line blocks per line and then i'll just add each one to the array after i've initialized it so blocks with an index of x comma y is equal to this new block okay i'm going to have a method called make next shuffle move and in here i just want to pick a block that is above below or to the left or right of the empty block and try and move that so i'm going to start by creating a vector 2-inch array called offsets and i'll just initialize this with a new vector to int 1 comma 0 so that's to the right and then let me just copy this and paste it three times so i can then have negative 1 comma 0 for left 0 comma 1 for above and 0 comma negative 1 for below i'll then create int random index is equal to random dot range between 0 and the number of elements in the offset array i'll now use this random index to get the offset that i want from the offset array so offsets with an index of random index and then i can say that the coordinate of the block that i want to move so move block coordinate is equal to empty block dot coordinate plus the offset now of course this move block coordinate might be out of bounds for example if the empty block is at the top edge of the puzzle and we try get the block above that so let's do a check if move block coordinate dot x is greater than or equal to zero and move la coordinate x is less than a number of blocks per line then we're okay on the x-axis and we just need to do the same check on the y-axis will block coordinate of y greater than equal to zero and move block coordinate y less than blocks per line okay so if that bounds check succeeds i'll call move block and passing the block with an index of move coordinate x comma move coordinate dot y if the move block coordinate is ultra bounce however i don't just give up but rather keep trying until find an offset that works so i'm going to put this code inside of a for loop going from i equals 0 to i less than offsets dot length so let me paste that in here and for the index i mean she say random index plus i and i don't have to go out of bounds so i'll just loop that around by saying mod offsets dot length as soon as i've moved a block though i want to break out of this loop so i'll just add break okay let me go up to the top and create a public int i'll call the shuffle length set that equal to say 20 by default i'll also need an in somewhere to keep track of the number of shuffle moves remaining so they make shuffle moves remaining and then i'm just going to start shuffling when the spacebar is pressed so i'll create an update method here and say if input key down key code got spacebar then i'll call a start shuffle method which i'll create somewhere down here void start shuffle and this will just say shuffle moves remaining is equal to the defined shuffle lengths and then make next ruffle move after this initial call i'll one subsequent calls to be made from the unblocked finished moving method so here i'll just say if the number of shuffle moves remaining is greater than zero then i'll make the next shuffle move and inside shear when i move a block i'll say shuffle moves remaining gets decreased by one all right let me save and see how that's looking so i'll press spacebar and i see that it's not getting very far before stalling so the reason for that is that it's referencing these blocks at a certain coordinate but when i move the blocks their positions in the array on being updated so let me go to the move block method and here i just want to say blocks with an index of block to move and chord by block to move kauai is equal to the empty block and then blocks with an index of empty block to coordinate x and empty blocked a coordinate of y is equal to the block to move so just swap their positions in the array okay should have more success this time so i press spacebar and it's shuffling nicely but the one kind of silly looking thing is when they shuffled back and forth and preferably that would never happen so let me create a vector to end up here and i'm going to call this the previous shuffle offset and now in the make next ruffle move method when i get my offset i'll say if this offset is not equal to the previous offset multiplied by negative one because obviously having moved the block all and i'll be on the other side only in that case will i move that block and then when moving a block i'll just set previous shuffle or set equal to the offset all right another thing i quickly want to adjust is the speed of the block movement so i'm going to have here public float which i'll call default move duration set that equal to maybe point two but then i'd also like to define an even shorter duration to use when it's shufflings that you don't have to wait so long for it to finish so i'll create a public float shuffle move duration set that equal to maybe 0.1 and now i'll have the move block method taking a float in duration and it'll pass in that duration over here and now when i'm calling move block from the make next play a move method i'll pass in the default move duration but from the shuffle move method i'll of course pass in the shuffle move duration instead okay so if i save that press play i can get the shuffling and that looks good now i don't allow players to click on blocks while the shuffling is going on because that could seriously screw things up so i'm quickly going to make a unam which i'll call the puzzle stage and the puzzle can be in one of three states it's solved or it's shuffling all the player is busy working on it in which case i'll just call it in play all right i'll then have a puzzle state variable called state and this will default to the first value in the enum so it will be solved from the outset now i think i'm only going to allow a shuffle to begin when the puzzle is solved so i'll say if state is equal to puzzle state dot solved and obviously the space key is pressed then in the input method i'll just make sure that the state is equal to puzzle state dot in play in order for the input to be accepted and should take this into account in the unblocked finished moving method as well so only make next player move if state is equal to state or in play and only need to worry about shuffling if the state is equal to puzzle state shuffling and if shuffle moves remaining is no longer greater than zero then obviously leaving the shuffle state and transitioning to the in play state alright last thing i need to do is just say he inside the star shuffle method state is now equal to puzzle state dot shuffling okay we can now move on to task six which is the final task and here the goal is just to get the hidden block to reveal itself once the player completes the puzzle okay i want an easy way of checking if a block is that it's starting coordinate so i'm going to go into the block class and create a vector two inch starting coordinate and in the initialization method i'll say this dot starting coordinate is equal to the given starting coordinate and then i can have a public method returning a pool called something like is at starting coordinate and this will just return whether or not the current coordinate is equal to the starting coordinate okay so going into the puzzle script i can somewhere have a method check if solved inhale simply loop through all of the blocks so for each block block in the blocks array if any of the blocks is not at it starting coordinates if not block dot is that starting coordinate then obviously the puzzle isn't solved so i'll just return from the method but if i get through all of the blocks without returning then the puzzle is solved so i'll set state equal to puzzle state dot solved and i'll reveal the missing piece with empty block game object dot set active true okay now if the player shuffles again then i want the empty block to once again be hidden so in the start rifle method i'll just say empty block game object that set active false and since i'm hiding it in there i'm not only going to hide it in the crate puzzle method so i'll just remove that line there the only thing left to do now is to call the check of salt method whenever a block finishes moving so i'll come down here and just say check if solved all right so let me save that and test this out so i'll give this a shot and i'll speed up the video while i solve this but once the last piece falls into place we should see the missing piece revealed one final detail is that if i actually build this project you can see all of the blocks come up pink and the reason for that is that in the block script i am setting the shader over here using shader dot find unlit texture but unity is not seeing that shader being used anywhere in the project and it's currently not smart enough to look for references to shaded find in the scripts so to save space it's leaving that shader file out of the final build which is why the materials are coming up pink so i'm going to work around this by creating a resources folder and as you may know everything inside the resources folder will be included regardless of whether or not it's actually used in the project so here i can create a material just call this my block material and i'll set that to a shader under texture and this will now work fine because you know she is forced to include this unlit extra shader in the final build because the block material references that now it does feel kind of weird just having this block material and it not being used so even though this isn't entirely necessary i'm going to replace the shaded out find with resources load and i'm gonna load a material with the name of block all right i'll save that and the project is now complete so i hope you've enjoyed this little programming practice series and until next time cheers