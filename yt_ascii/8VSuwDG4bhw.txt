my research is on computer security so i'm going to talk today about some applications of information theory in encryption so let's say that i build some sort of fancy encryption scheme i'm sure that you've seen the notation for encryption so can you give me a secret message oh gosh 42 42. it's always 42. so in computer file it's been covered how we can write down encryption so let's encrypt your number 42 with some key some secret key that only you and i know so let's agree on the number 20 as the key and what this gives you is some big random looking string now i'm going to make some modification here i'm going to translate this and say we take the number 20 and we put it in front of so we compose it in front of whatever the text is that you're sending me so like append a text to it or something like appended in front that's exactly right concatenate the number 42 so that means that this would become it happens to be a number again the number 2042 but of course you could do this with text instead of numbers as well concatenation you just put it in front right now why do we do this well the reason we're doing this is because i want my encryption to have a special property which is that i want to be able to kind of verify that i'm decrypting the right thing and not accidentally decrypting something else because this number here corresponds to a large random looking cipher text and so does this number they all correspond to different random looking ciphertexts but i can decrypt it with any key i want and i will get some outcome but i want to be able to verify my outcome and see that i did the thing i wanted to do so in this case when you encrypt 20 followed by 43 f42 i can decrypt it with the key 20. and i get the number 2042 out and i can verify that the first two characters are my key and i'm happy with that i take them off and i keep the remainder if the decryption had some other things in front of it i wouldn't have been happy and i would have said okay i've made a mistake here so this is a form of encryption where you can verify that you've decrypted correctly and that it's not nonsense now why am i doing this well because this shows you a weakness of information theory because i want to describe this bit string here random looking bitstring as having high entropy right that's what it feels like it should have a high entropy that's what it means to be random looking but actually it's not random at all right because if i look at the decryption key 19 and i apply it to that random looking bit string i'm getting a ciphertext that will almost certainly not start with 19. if i'm decrypting it with 21 or the letter a or you know whatever you can come up with the odds are it's not going to start with the right key which means that it's not a valid decryption which means that it's not in our set of possible decryptions so there's only going to be potentially one key that actually works in other words there's only one combination of key and ciphertext that actually corresponds to this so that means that the entropy of this string is zero bits there's only one possible string so applying information theory here says there's only one thing it could mean but that doesn't mean that you know what it means and that's the interesting thing about information theory right it tells you there's only one thing it can mean but it doesn't tell you what that thing is and the whole trick of encryption is of this sort of encryption symmetric encryption is not that there is multiple combinations that they could be but rather that is really really really difficult to find the combination now in the case of 20 and 42 it's maybe not that difficult but if you use proper keys and and messages that are properly padded then it's going to be insanely difficult to fight the right combination so it's not relying on there being multiple combinations but rather there's only one but it's increasingly difficult to find but that raises a natural question can we not have multiple combinations can we not rely on this and the answer is actually yes we can so this is the idea behind a one-time pad and what that is is you have some binary message so 42 for example is 32 plus 8 no 16 plus no four plus a 2 and those one so i believe the binary representation of 42 is 1 0 1 0 1 0 and we then come up with a random binary pad so let's say zero zero zero one zero one and we xor these values meaning if we have a one and a zero we get a one if we get a zero and a zero we get a zero one one one if the values are the same you get a zero if the values are different you get a one that's an xor so you do that with your pad and you end up with a binary string as long as we both know the same pad we both get the same string now the idea here is that any pad is possible so at for every string you get as output there are because this is one two three four five six bits exactly 64 possible combinations in other words there are six bits of entropy so the one-time pad does not rely on your problem being computationally hard in fact your combination your problem is computationally super simple it doesn't get easier than taking an xor of two strings it really doesn't get much easier than that but it relies on there being 64 combinations that we could have done it with which means that if i'm giving you this string and you don't know the pad there are exactly 64 pairs of pads and messages that are in the set of possibilities and every message is represented exactly once for each pair so that means that every message is equally probable meaning you don't learn anything about your message so this is known as information theoretic security now the downside is that you're not actually gaining anything in terms of security because we had to have a secret ahead of time that was six bits so 64 combinations and afterwards we still have a secret of exactly that size and i'm not able to reuse this secret ever again because once i do we're not gaining any entropy so we're stuck right so we have to have some magic way to exchange renderness and this by the way is what's being proposed in some quantum cryptography schemes where you're communicating by sharing a source of of randomness so that's all very interesting but that's a different type of cryptography as the ones that you will typically find in your computer so if i get if i'm going to work you know every day for the rest of my life and i have these these choices then actually having the expected so the average cost kind of makes sense because i get to make this i get to execute the time steps and we add based on our schedule that amount of noise right so we have but all of that