why don't you talk about maintainability hey look is he using some i3 nice job i2 use i3 so i usually don't like to co talk about maintainability right because maintainability is a it has two ends right so the main maintainability of the code also greatly depends on the ability of the person to maintain this this is correct this is absolutely correct the same with readability right so the problem with maintainability and readability is because is that people quite often look at them in a very one-sided way they always assume that it's only responsibility of the code to be readable and maintainable and never responsibility of the programmer to be experienced enough to read and maintain there are two ends to this sc quality it's how read code is readable and maintainable and how skillful is the programmer that's why i don't really like to talk about this kind of stuff right because it's a sort of like a double-edged thing and when you really start to talk about it people really get uncomfortable because that implies that they need to get good and nobody likes to be told that they need to get good right yeah that was fantastic that's absolutely spot-on i have always had a bit of a a problem with this phrase of you know readability readability more so than maintainability i think maintainability is a bit a bit more objective of a measurement meaning that can you take how often are you able to produce features right readability is like a function of your style and the time in your life every time i've ever written code for me it's been readable anytime i've ever looked back on code that's 6 months old i think wow who wrote this ary this is just a pile of terribleness this is absolutely some of the worst stuff i've ever seen oh wait i am that writer this is me oh crap okay well let's back it up code dude first off reading code is not easy especially as your types get more advanced as you have to go through a bunch more hoops just to understand what is the thing that you're looking at you know it there is definitely a function that exists which is the complexity of the problem you're solving and the complexity of how you have to solve that problem followed by how well you can read it right not all code is just easily readable go ahead open up go open up solid js go open up like the spelt compiler go open up react go open up any of those and i guarantee you you're not going to be able to understand it in just an hour and a half to be able to read it will just feel like you can't even understand any of it that's just how it works and and i've tried this so you're saying oh yeah what about like an llm code explainer go ahead toss it in an llm and be like can you explain this to me they'll explain it in a high enough level that that's kind of what you derive as it is you're like oh yeah i get this this is high enough level but there's a huge difference between give me a basic explanation give me a detailed explanation versus what the hell is actually happening right that's very very different the amount of stuff you have to be able to hold in your head to understand what the codes actually doing is huge and as of right now like this project that i'm working on right now i do oh my i love you i forgot to turn off alerts goodness gracious but there's this project i'm working on right now where i honestly do not know how the entirety of the project works at all and i have fixed several bugs i put in some performance fixes i've done some things and yet i cannot figure out why or how this thing works in totality because it's just like it's very very difficult to gain like the actual context for really understanding it and its completeness or what's actually happening it's funny so so to me what i what i kind of see on this is that the code i'm working on is fairly maintainable but i cannot read it right like i literally cannot read the code at all i i sit there and i look at it and i and i i spend so many hours trying to figure out stuff and it feels like it's just absolute waiting through the difficulty and so is it my fault i would say that you know what guess what how can you maintain the code if you can't read it because i can read it in its little individual right like on this line i can understand what's happening i can put in enough print statements and kind of figure out my way through it but i i really don't fully understand what is going on documentation there's documentation but the problem is is that documentation often exists only in one you know one dimension this function is to to be able to maintain the tree of parents blah blah blah blah blah blah okay now when you look at what does it look like to maintain the tree maintaining the tree is complicated af stating what it does is really simple and kind of gives you like a little overview of what's going on inside of there right and so like i can read individual lines but to actually understand it in totality is extremely difficult and that's totally a function of of what the lexity is that you're solving and so are all code bases just simply readable no like you can read individual portions cuz you can follow code like following five lines of code is just not hard they're always readable following those five line of codes in perspective of 100 lines of code which is in perspective of a thousand lines of code is so effing difficult you know and so is it maintainable yeah i'm making features i'm doing things to it is it actually something that you know is quote unquote all these nice code ideas no some of the functions are like there's one function that's like 200 lines long why is it 200 lines long because it really is just doing the thing it should be doing it's just hard it's just complex as it's just really really hard and here's the second thing about readability here's another thing about readability that's totally annoying that people don't talk about if you love functional programming and you're used to functional programming if you are used to o and you love o and you guys try to trade code bases guess what's going to happen oh this is not maintainable oh this is completely unreadable oh this is just the worst thing i've ever seen exactly that's because maybe just maybe just a little bit maintainability and readability is also a preference it just might be a preference and people sometimes make things out to be these like absolute there's like there is this one-dimensional measurement of readability is either not readable or completely readable give each other interfaces and be happy i mean i agree with you readability is a very very subjective so i mean because if you're not used to if you read simple rust it's pretty simple but if you don't know all the little idioms and all the little cool things people can do and all the functional nature of rust it's really really really hard to read rust if you don't know about lifetimes it's hard to be read about rust you got like a whole skill issue gap that is combined have you ever read c++ just in general when it starts dipping in and out of macros and just it just keeps on going some people look at that and they're like oh yeah it's doing this okay that's doing this okay yeah it's doing that it's awesome it's easy this is what's happening me i look at i'm like what the hell is even that like i don't even know what's going on right like what the what the what is this i don't even understand it i don't get it comfort matters i think one of the reasons why that go is so popular despite the bare syntax because all the c system programmers that need the move to the backend network services love it yeah like just last night i tried to write a little client to send a message to a server and then read back that message and send a message and read back that message and just try out some some various things because it's going to get a whole bunch of messages from the a server but it just needs to repick out the own message that it sent and i just tried doing it i wrote this in 8 minutes last night maybe 12 minutes i've never used this library this is just the one that was there i know there's like new ones that you should be using this is just the one that was there i did it literally in absolutely no time and i was just like holy cow this is fairly easy like you can do stuff pretty quickly can you read it now yeah yeah yeah yeah yeah it's it's pretty simple right you got the room joining syntax you got the message sending one where we measure the duration and then i got my little read loop that's waiting to find the one that i sent it's it's it's shocking how simple that was to for me the first time i wrote a websocket in rust it took goodness gracious it took me probably 10 hours to really get to be able to write this program it probably take me 10 to 20 hours to do this first time ever doing in go took me 10 to 20 minutes right so is readability also an experience factor and is it also in the language itself absolutely now i can write this kind of code pretty fast but that's because it's obviously you know i'm more familiar now with rust anyways i love this take i think this take is fantastic readability and maintainability is not on the code itself it's on the person it's on their experience it is partially in the code it's also in the language itself some languages are just easier to maintain read the responses i usually absolutely all right full video by the way you should check out coding if you don't watch coding you're just a jerk the impression let's see i get the impression you believe that these development skill issues are linear that is not the case as codebases live in a multi-dimensional lossy conceptual spaces i've i'm already too stupid to understand this when new developers arrive it's valuable to ensure that there is a diverse array of conceptual entry points for them whatever this means okay so like i know that we're about to get extremely md on next i can see what's about to happen but the the reality is like this sounds great and it sounds like a lot of words but how does that how does that actually happen how do you actually do this how do you actually say how do you actually do this in any real way in any real codebase it's it's this sentence is practically impossible to do this response is the only proper one i get the impression that you don't mind that i spent last night with your mother she was really impressed by my nonlinear development skills we explored the entire diverse array of conceptual entry points in a multi- dimensional lossy space yes i've already liked this one because i already did read this one okay it was fantastic it was a thing of beauty okay it was a thing of beauty you can't get upset about this but this first part it sounds great on paper because i don't know what the hell it even means maybe i'm just too low iq to understand tur code just by the syntax i like the code aesthetics idea of code that explains itself even without comments and deceptive names or descriptive names this doesn't exist it only exists in the world's most simple simple simple things like everybody every there's not a person on earth even if you're completely unfamiliar with go like you would just you would just have no problem here i'll let cod pilot do co-pilot do it there you go like of course this is simple to understand right that's because there's nothing to it there's absolutely nothing to this code of course it's simple but anytime you're doing anything sophisticated the reason why code reading is so difficult is because you have to understand the concept you have to understand the representation and then you have to understand the syntax that's trying to like manipulate those two things i just don't i don't i don't necessarily see you know why people get so worked up over this thing what about the trade between u readability and optimization i don't i'm not fully even on the team of readability okay i know it exists and i've been in some code bases that are genuinely bad but about 90% of it is just people's opinions getting all upset and getting emotionally hurt thank you phenix rising i agree disagree kind of code is created for a community between folks even if the code is good it may not fit mental model of reader so the reader has to change and fit its meal mental model to the code then the question becomes what can i do to lower this tension but as you said it's a relationship rather than objective quality it's interesting how everyone is trying to reduce the friction but the only few let's see but only few explore the idea of increasing the friction for certain kinds of developers you want to keep away from your project which may be a beneficial in a long run but we are not allowed to talk about that that is such a great one oh my goodness oh my goodness let's go and so so how do i take this phrase do do i think that he's just do you i think there's two ways people read this there's probably my camp judo camp and a few other people's camps and then there's another camp and so camp number one is just like oh this guy just you know the elitist camp right i saw someone say oh he's just being elitist which is okay what he really means by that is he just wants nobody that's inexperienced so he intentionally makes his card hold hard and that's that first off again readability hugely subjective so he writes his code that is say pretty standard pretty decency that's my guess about coding and so what i think he means by this is that code and getting into a project is difficult the people we want are people who are going to push into the difficulty take the time to learn it morph their reading skills into understanding how this codebase was written and then try to contribute to it that's the person i want i want the person that's willing to put in the work that's willing to take the time that's willing to actually do the hard things that's the person i want that's how i read it and that's how i'm totally on that team right i'm on the team that is i want the person that's driven and wants to go like and and wants to understand the problem let's see if i let's see if i could increase the friction for people who refuse to highlight the entire word on the stream it would be up the i would up the friction 100x what what i did highlight look i h look i even highlighted the entire word friction like right here i i highlighted that entire word right there when i had the whole thing it could so this could be justified to write poorly written code i i want to hear more about this because here hold on you we're doing it we're debating hopping get in the arena get in tell me how do you how do you measure poorly written code how do you qualify any of these phrases that that you're saying cuz i don't think i see this as any problem with poorly written code like how how how are you going to how are you going to define this problem functions with multiple concepts not using proper patterns etc do you think functions with with multiple concepts is always bad i don't think i don't think functions with multiple concepts is appear bad i don't sometimes you got to kind of do a couple things like that i actually have a zero problem with that the proper pattern  is so unrealistic in an environment where you need the shift it is it's very very difficult like i i get that there are some level of patterns that are good effectively i just don't see what the benefit of that you just don't see the benefit okay that's fine you may not see the benefit the problem is is when you say phrases like code is going to just be written poorly i would like you i would honestly love to see you look at i'd like you to go through any project any project at all on github that you've never looked at the codee's going to look bad of course it's going to look bad it doesn't look like you wrote it it doesn't look like the way you like to write today it looks like somebody weird ass different code that does things in a way that you don't like and that's that like that's just how life works now you can get used to it now you can just simply become good at committing to someone else's code style i'm regularly impressed by code bases i have never been impressed by a codebase i have literally never been impressed by a codebase i've been impressed by how somebody solved a particular problem once like i i've looked at i've looked at how someone solved a particular problem and i went wow that's pretty cool i don't look at code bases as pathetic i just look at him going wow that's not how i'd want to do it and and second okay so then patterns there's like a few patterns that are really really great there's some patterns that are very very fantastic i'm impressed how people make monor repo work i i'm fine with monor repos i think sometimes they're really really nice sometimes they're really really annoying i'm impressed by the lazy vim codebase i'm sure if i were to i am pretty good at neov i am pretty good at the neovim api i'm pretty good at lua and it's still hard like i go into a bunch of code bases trying to figure out how you know configs and things are set and what actual options do i have available and it's difficult shut up tj like it still takes time and i'm like oh i wouldn't have written it this way but this is pretty cool right i'm not impressed i'm just like oh it's another way to do things and i don't i don't i wouldn't want to do that that and then it's like okay whatever like that's just that's just how it goes strategy pattern strategy pattern is the ultimate pattern the rest mediocre okay enough of this crap i actually like this i led this take i think this take is fantastic i think that people will be a lot i think you'll have an incredibly easier time in life if you quit trying to make this code in some sort of aesthetic amazing piece of something but instead just accept the fact that coding is largely comfortable that it's largely not going to be the way you want things to be that it's largely going to be kind of annoying and takes time to get up to speed that readability is going to be an exercise of patience and time and just simply let that happen and then all of a sudden you're just not going to you're just not going to be nearly as pissed right because the reality is that at some point every single codebase had to make trade-offs for delivering every single codebase has to make concessions for delivering that's all there is sounds like the defeatism it's not defeatism it's realism i would love to see some codebase that was able to deliver real value to real people in which they could take all the time they wanted to design the most elegant system okay this is not academia where people get to sit in a room doing uml diagrams for six months there's never a perfect solution there's always trade-offs because even the solutions that are good requirements change and they no longer fit well right they no longer fit well anymore and now you have to make you have to make concessions right like there's just no possibility so you agree with yes of course i agree with him yeah it's it's i let see obviously you haven't seen my 100 line homework for object oriented design this is fact this is a fact this is a fact of life another case if choose your hard in some sense i mean you can i mean not everything can be you know again you just have to make concessions you get to choose your concessions make and sometimes you don't get to choose those concessions at all they're just chosen for you based on timelines and sometimes it completely sucks that's just that all right the name is i'm pretty much in the train that most things are just subjective and in that this large push for some sort of objective code quality is is just really just a lie a jet