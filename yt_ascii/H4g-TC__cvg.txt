hi everyone last episode we created a simple noise filter which allows us to get some fairly interesting terrain however there's only so much variety that we can get with this so in this episode we'll be implementing a new filter for creating terrain that has more rich light features so the basic idea goes like this we start with our noise function which i'll just visualize as a sine wave we then take the absolute value of this which you can see forms these sharp valleys we want the peaks to be sharp though so we can invert it by subtracting from one if we want the peaks to be even sharper we can raise the final value to some power okay so in unity i'm going to start by creating a new c-cup script which i'll call the rigid noise filter and i'll open that up and i'm quickly going to go into the old noise filter i'm going to rename this simple noise filter and i'm just gonna copy the contents of this and paste that into the rigid noise filter because a lot of that's going to be the same don't want the ridgid noise filter to inherit from one a behavior so quickly remove that i'll just rename the constructor here to be rigid noise filter okay now as i was saying a moment ago in order to get the nice peaks and ridges we want to take our noise value and first get the absolute value of that soap acid into the math f dot abs function and then we want to invert it by subtracting it from one we can also then make the riches more pronounced by squaring the value so we'll just say v times equals v now in the simple noise filter we were doing v plus 1 times 1/2 to get v in the range from 0 to 1 but share because we've taken the absolute value of the noise function it's going to be in the range 0 to 1 already so we can leave that out now another feature of this filter is that we want the noise in the ridges to be a lot more detailed compared to the noise in the sort of valleys below the way we'll do this is by weighting the noise in each layer based on the that came before it so up here i'm gonna create a float weight equal to one and then in each layer we can multiply v by that weight after doing that we'll set the weight equal to v for the next layer this way regions that start out fairly low down will remain relatively undetailed compared to regions that start higher up okay let's now save this and go into the shape generator class and we've got our array of noise filters and at the moment these all of type simple noise filter but we want this array to be able to hold simple noise filters as well as rigid noise filters and also any other type of noise filter that we might create in the future so i need to go back into unity and we need to create a new c sharp script called eye noise filter and a another new script called noise filter factory alright i'll start by going into eye noise filter and this is being should be a public interface and in here we'll define the one method that any class has to have if it wants to qualify as a noise filter and that's going to be this evaluate method which returns a float and takes in a vector3 for the point all right so i'll save this go into the rigid noise filter and just say that this implements the eye noise filter interface and do the same thing in the simple noise filter then i'm going to open the noise settings class and this is going to have a public enum for the filter type and here we can just list the different filters we have so at the moment is just simple and rigid and then we can have public filter type and i'll just call that the filter type save that and i'm going to open up the factory class that we created this is going to be a public static class and it's going to have a public static method returning a i noise filter and i'll call this create noise filter and will take in noise settings so the type of noise filter that it's going to create will depend on the filter type specified in the settings so we can do a switch settings dot filter type and then we can just go through all the cases so we've got this simple case where we'll return a new simple noise filter passing in settings and then we've got the rigid case here we'll return new rigid noise filter passing in settings and those are the only two that we have at the moment and if it happens to not be any of those which should be impossible we'll just return null all right so now we can save this and return to the shape generator and instead of an array of simple noise filters we'll have an array of eye noise filters so that it can hold any of the noise filters we might create and then over here where we're assigning to the noise filter array we can set this equal to in wasteful to factory great noise filter and pass in settings noise layers i dot noise settings ok let's save this and head into unity to try this out so i'll go into the planet and once that's finished compiling i'm going to make a third noise layer and i'm just going to go into these first two and just disable them so that i'm just looking at this one on its own and i'm not going to use the first layer as a layer mask which immediately makes it a rather massive i'll just turn down the strength a whole lot and i'm going to change the filter type here from simple to rigid however when i do this i'm getting error complaining of an array type mismatch which is because i forgot to do something earlier and this is we have this array of eye noise filters but we're still initializing it to an array of simple noise filters so it gets very upset when we try and assign a rigid noise filter here so we just need to change this to be an array of eye noise filters okay i'll save that and go back to unity which were to compile i'll just clear this error message as well and then i'll just set this to rigid so it updates and now we can play around with us noise so i'm going to set the number of layers to one and i'll set the min value to zero and you can see we got something that looks like this and you can increase the base roughness and it looks kind of weird but what will happen as we add more layers is it will start to look kind of mountainous now the strength is way too high at the moment so let me change this to maybe and say 0.05 and now you can see we're getting these nice ridges with valleys in between so i'll just play with these settings a little bit more maybe increase the persistence a little bit and increase the roughness decrease the base roughness or maybe increase it i don't know just basically fiddled around until it starts to look good let me look at this conjunction with the continence layer it's a little bit hard to see ashley so let me now use the first layer as a mask and then increase the strength here so that this juts out and okay it's kind of hard to gauge when it's all one color but i think this is starting to look fairly nice okay i'd not like to head over to the noi settings class so currently we have these two noise filters simple and rigid and both of them are making use of these exact same settings but you can imagine that for some noise filters we might want to have a bunch of additional settings for example let me just make a new setting for the rigid noise filter this will be a float i'll call this weight multiplier and i'll give it a default value of say 0.8 i'll save that and in the original oyster i'll say weight is equal to v multiplied by settings dart weight multiplier and just to guarantee that weight never grows greater than one i'm just going to clamp this between zero and one okay so i'll save this go into unity and now now we have this new noise setting weight multiplier which we can play around with but the irritating thing is that for a simple noise filter this weight multiplier value doesn't do anything at all so you can imagine how sort of cluttered and confusing this could quickly become if we start making more noise filters each with their own special settings now i'm not actually planning on covering any more noise filters in the series but i still want to show how one might solve this problem so that if you want to experiment with new noise filters on your own things don't sort of turn into a terrible mess what i'll do is go into the noise settings and over here i'll create a public class called simple noise settings and i'll have all of these simple noise settings inside of there and i want this to be serializable so i'll add that attribute and then i'll have another class call this the rigid noise settings and i want this to also have all of these simple noise settings in it so i'll just inherit from simple noise settings and then it's going to have this one noise setting that is unique to it in there this should also be serialized so let me add that attribute there and then up here we can have public simple annoy settings just call that simple my settings and public rigid noise settings call that rigid noise settings and then we can go to the simple noise filter and just change the settings type here to annoy settings dot simple noise settings and over here as well okay save that go into the rigid noise filter change its settings type to rigid noise settings and in the constructor as well and then in the filter factory will have to pass the appropriate settings type into the constructor so this will be simple noise settings and this will be rigid noise settings and i can save that now going back into unity this is maybe a little bit nicer because now if we open up our simple noise settings then we don't have any of the settings that don't belong to it there and if we open up the original settings then we've got all of these plus the weight multiplier here however it would really be a lot nicer if only the settings type that correspond with the selected filter type would show up over here and to achieve that we need some editor scripting which i'm not going to go into in this series but i'll just supply the scripts you can download them from the description these scripts are largely the work of director cui's i've just modified them slightly for this series there's a conditional hide attribute script and also a conditional hide property drawer script which needs to go into the editor folder once those are imported we can go into the noise settings and add a conditional hide attribute here so we want to hide this based on the value of the filter type variable and we want it to be displayed only when the enum index is 0 in other words it is the simple filter type and we can just copy this for the original settings and there should be displayed when the enemy index is 1 okay so we can save that go into unity and once this compiles we should see that when it's simple we have the simpl noise settings displayed sure and when it's rigid we have the rigid noise settings displayed okay so i think that's quite nice but in the process unfortunately i have lost the planet settings so i'm just going to speed up the video while i enter some reasonable values okay coming to the last thing i'd like to do this episode we obviously always want to preview the planet at the highest possible resolution but this comes with the trade-off that changes to the settings will take a lot longer to reflect in the scene view so i would quite like to add a option to the planet to only render a single face at a time just to speed things up when we're playing with settings at a higher resolution so i'm going to go into the planet script and over here i'll create a public enum called something like face render mask and have the first option be all to render all the faces and then i can render just the top face the bottom left right front or back alright well then have a public face render mask and just call that the face random ask okay now when we're creating the terrain faces in the initialize method sure i will say boo render face is true if the face render mask is equal to all oh if the index of the face render mask so i'll cast to int the face render mask - 1 because the first element is all if that is equal to i then the current terrain face is the one that we want to render so i can then say mesh filters with an index of i dot game object but such active based on this render face pool all right then in the generate mesh method i mean replace this for each loop with a for loop i'm going from i equals zero to i less than six and cheryl say if mesh filters i dot game object dot active self so if it's active only then what i say terrain faces with an index of i dot construct mesh okay so now for you into unity i go into the planet once this compiles you should be able to say just render the top face and then can see that there and now even at a resolution of 256 we should be able to see this updating rather rapidly let me just change this back to all to make sure that that still works and it does appear to so that's pretty nice okay that is going to be everything for this episode so until next time cheers