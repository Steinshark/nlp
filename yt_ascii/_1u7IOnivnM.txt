debugging embedded software is hard with no screen to show output for print debugging and often only equipped with an led to show signs of life finding bugs in your embedded projects is easier said than done wouldn't it be nice if there is a way for you to see your code as it ran on the chip or to be able to even stop your code at a certain point to examine the state of the system enter open onship debugger or openocd a piece of software that allows you to use common probes like the arm j-link or the stm32st link as a debugger giving you the power to analyze your system as it runs in this video we'll be debugging an stm32f103c8 and better referred to as the blue pill in my previous video we wrote our first piece of c code bare metal that ran on the stm32 and today we're going to analyze that code using openocd hit subscribe to follow along with me on our low level journey into embedded systems okay so here we are in our linux debug environment we are in the folder from a previous tutorial put the card here in the video right now where we've produced our blink led.elf and our blink led.bin binary these are the programs that execute this code on our blue pill where we blink an led about every one second it's a little slower than this but it's pretty close step one we actually need to sudo apt install openocd it's in the app repo to get open ocd installed on our computer i've already got it so i don't need to install it but you guys should step two we need to use our st tools and again we can do sudo apt install st link to get those and we'll do st info tactac probe to make sure that we have a st link debugger attached to our computer once we have that we can then start to invoke open ocd commands openocd is a program that takes input in the form of files that describe to open ocd how to talk to the interface which is the debugger that we're going to use and then the target which is the chip that we're going to debug using the interface so what we'll do is specify two tac f's the first file is going to be a path to the st-link v2 configuration file here that's basically going to tell the debugger how to talk to the st-link v2 and then we're going to use another tac f and we're going to do target and then it's going to be stmf1x.config using these two files here the chip will know to go to the st-link v2 and then using the sd-link v2 try to talk to an stm32f1x and remember our blue pill is an f103 so this config file will work there is one slight change you may need to use if you're like me and you accidentally bought a cheap chinese knockoff of the chip i had to actually change this number here this cpu id used to be 1b a0 i had to make it 2b a0 because the chip id that i have is different than the one that the st link actually expects you can also just delete this number in general and make it zero and tell the st link to not expect a particular chip and just accept any chip id that it sees so once you've figured out that issue depending on what ship you have or not we can run openocd with those two paths remember so we have the one for the st link interface and the other for the chip itself and hit enter we run this and we see eventually we got a couple issues with clock speeds but after that it sees the chip using the sq-link api version 2 and it sees a target voltage of 2.54 so now that we have this up and running notice that it hasn't closed what sd-link actually did is it opened up a bunch of ports we're going to do netstat tech grep for openocd we're gonna do sudo here as well so openocd opened up three ports one is for telnet and the other is for gdb so what we can do here actually is opening another terminal we can debug our project we'll go here what we're going to do is we need to sudo apt install gdb multi-arc to be able to debug files that are multiple architectures in gdb so gdp by default will only be able to debug intel programs we need to debug arm programs so you install that i've already got it so don't worry about it once you have that we're going to gdb multi-arc the blink led.elf now right now we're currently only on our computer right gdb is running as a local instance where we need to debug a remote target the way we do that is we specify that the target is extended remote and it lives at localhost port 3333 what this will do is it will tell gdb to talk out to open ocd running locally on our computer on this port and treat it as a remote target that is running this blink led.elf command by hitting enter gdb has now reached out to open ocd and we are now sitting at the reset handler because the chip is in a reset state because of openocd we're going to type lay next a few times and that will get us to the point where we can see the register state of the processor as well as the current line of code that we're in we are going to set a breakpoint at main and then hit c for continue great so now we are actually in the main function on our chip and we have a break point set it's not exactly at main it's a little south of maine but it's not a big deal and we can actually see each individual register and its current value as set on the processor we then can do things like step we take a step forward on the chip give it one second here it takes a fair amount of time and we actually just stepped into the rcc library that does the rcc generation another thing we can do is we can set a breakpoint on a c line number to get the chip to stop at a particular point and use that to figure out what state the chip is in at that time so for example we can type b19 for break on c line 19 and hit enter you'll see here we get a break point that's set at that location now the processor is currently in a stopped state because i hit ctrl c and it sent it a sig in or a sig interrupt and we can actually use continue to allow the chip to go back into a running state it'll run until the delay has occurred and then when it goes to gpio toggle our pin we actually get hit on a breakpoint that was breakpoint 4. if we no longer want that breakpoint to be there we can type d and then 4 for it to go away another thing we can do is we can do info registers to get a better idea of what the register state is in the processor so you can see that r0 is this value in this case r5 of this value and so on also we can see the pc or the program counter is this value here and then one more important thing we can do as well is we can actually do memory introspection meaning we can read arbitrary memory on the chip as we want so we'll do lay next to make a little more room for ourselves here get out of here with this do refresh all right and then what we can do is do examine 32 words in hex at the address ox 808000 and you see now this is actually where the program counter begins for the arm chip and these are the instructions that live there using openocd is extremely easy and pretty intuitive once you get your configuration files figured out and using openocd you can debug remote arm targets and figure out where your code went wrong without having to lean on leds or print statements guys i hope you learned something if you did do me a favor hit like hit subscribe check out my merch store and i'll see y'all in the next video take care you