well hey i love dave's content but his delivery sounds so condenscending see the problem is is that i don't really buy most of his content like test driven development is great when you have a black box way better version of development is this is that you build something you throw that something away you learn from it you throw it away and then you build it again and you make tests that are effective right that's how i like building i don't like testing to determine my architecture but i like to make it a very i like to make it a very concrete or foundational part of my development right that's why again that's why harpoon 2 harpoon one pretty much no test i was exploring i was just trying to understand what i was trying to build harpoon 2 yeah it's going to be good we got everything working i really made sure that we had some good tests so i wasn't just me making up you know what i mean but i really like test build once and notice that i threw away all of harpoon i did not even look at it once because once you start no unit testing is not  there's plenty of great reasons to unit test whenever i hear unit testing is what i think you are is a crud slui developer and that's it you've never developed anything hard get wrecked shambles right when you say unit testing is not is not difficult you've clearly never done really complex dynamic algorithms right dynamic programming is not easy and it's very good to have testing for that pseudo app install get get wrecked yeah 100% coverage iss absolutely hands down absolutely i know you get wrecked kid no real talk like unit testing unit testing makes no sense when people say it's like ah you absolutely don't need to do that you can't refactor on tested code you're just moving around yeah but but unit tests when you refactor code naturally a bunch of them break also all right i do like stable api testing i think it's really really good to do stable api testing the hard part is that you don't test it for if conditions you know secretly inside of your code right you have to treat it like a black box but unit testing can be very very very very very very very very beneficial if and only if you have something that's a very constrained algorithm here's a good example if i had to go and build like here this is from netflix this is something i've had to do at netflix i had to build a video sync player that would take in video frames as quickly as possible and pretend to play them and check for dropped frames and how dropped frames would affect everything and like built an infrastructure to high playay video like at 12 15x normal speed as fast as possible and test for any any problems in within the pipeline and guess what that like moving and playing videos there was even nanocs that would spill out nanc caused caused like drift and so like that's how hard those things were i know i saw that tiff and so that was like a real real thing what data structure did i to use dynamic programming it was just a dynamic programming problem i kept track of everything and had i kept a spill i had to keep track of spill from nanc it was super fun but i had to create unit test for that because it was extremely hard to get right and it was extremely hard to actually test because if i wanted to test it i had to like launch netflix run my program to start shoving things through and then make sure that my sync was doing the right thing and it was getting like you know you would get how many thousands upon thousands of 10,000 frames and so it's like how could you ever do that in any real sense unit test it it makes a thousand times more sense i use unit test as a way to drive correctness and to implement stuff because it's fast you know what i mean it's fast and easy to do i don't use unit test to ensure like it i don't look at unit test as a way for like safety i use it as a way to drive features through right at my work a merge request gets auto rejected if there's no test attach yeah see i think that's wrong too i think that that's also equally wrong i only manually test while drinking my milk damn i also watch netflix at 20 to 30 speed it's actually really hard to play video every single frame at 20 20x like that's a really hard problem if you're playing like say you're at 60 frames a second video 50 frames a second audio that's 110 frames per second so 20x you know that's 2200 frames that you have to shove through like it's actually extremely difficult that's why when you fast forward it's chunky right they kind of you have to swim you have to like go to the next chunk and that's why whenever you hit a place sometimes there's a pause because you know if you have a bunch of video sent down you have to like fast forward correctly through like grabbing you know these eye frames and ensuring the gos right you have to get the gos all correct it's very very difficult i think one of the main problems of with unit test unity testing okay well calm down is that folks don't suggest to remove some code in in the code reviews because more test equals good i do do agree with this take i like this take actually quite a bit eventually you can get to a stage where you have so many tests that they are difficult to maintain and break at every single character a change you make yeah absolutely there's some the problem is is that when you get too low on your unit testing you reach a point where when you change even small interfaces things are just breaking all over the place you got to be careful about exactly where you have your units and what things you think you're testing i try to really hold on sorry this is just absurd okay that's it we're putting them on the big board you're getting on blast buddy i hope i hope you got i hope you got some good messages behind you okay you're lucky you're lucky you have good chat history okay you're lucky you have good chat history you almost just got kicked right out of the startup buddy easy for you to say when you have teach ghost coding for your unit test yeah absolutely test coverage is great for testing if your test if your test execut how dare you challenge a netflix engineer no it's just stupid to say you can do anything in some small small period of time it's it's a very complicated feature i hate manual testing it slows down so so much yes i miss the things a let's see and i miss things a lot but if i'm testing the public interfaces with unit or integration test and it usually catches things i forgot about had this happen recently yeah absolutely so i i mean this is why i that's why i love driving implementation via tests because i just think it's easier like while i was developing harpoon over the charity stream i actually finally just was i got pissed off cuz i kept launching making harpoon launching a instance closing it down reopening it having the new harpoon requiring it in trying to do the operation i was like okay dude this is just ridiculous you know what i need to do i just need to be able to go like this right i need to be able to just take a test create a file create a buffer take my file sync it expect the expect it to be there right like i can't dude crazy to be able to think about anything else right it's just crazy i love driving implementation by that it's very very good wait are you not a public interface to chat jity google $5 a month what is this don't write bugs no need for testing yeah that's fair what is harpoon the greatest thing ever s net beans all right let's let's keep on going i like that little chat though that was a good chat before i end this does anyone have a hardline stance hating unit test all right why can someone give me a reason why you have a hardline hate unit tests and how much of your hating unitest is because theo says so this is fine okay so i love this take right here when i'm figuring out a product i don't want to maintain them while i discover and play around perfectly fair absolutely same team absolutely same team absolutely yeah okay this is also fair i i i struggle with that too right what is worth testing versus what is not worth testing what if i what if i have a different i don't have a unit test okay i hate that they imply and somehow okay first off you got to take another spin at english spyro i know you better than this i know you can type properly whatever you just said there was confusing you know the most about the problem you are trying to solve after you've solved it exactly that's why i do like the write it once and throw it away i do like the write at once throw it away approach i need to test everything because i have a hard time to decide to where to draw the line see i i think that that is also bad right you're i think you're going to end up reaching kind of like these these shitty places where you have too many tests and they just don't make sense and when you need to make a change cuz you didn't really know your product you like ruin half your tests you really have to i i i think the thing is is that i think why most people don't like unit tests is because they've been forced to write unit test for everything and because you're forced to write unit tests you end up writing a bunch of stupid ass unitest for personal projects do you suggest writing unitest not right away and it depends again always dude this is such a huge depends if you're just doing like a crud app you probably don't have to worry about it real talk do you have to worry about it if you're just building a little website to do something you don't have to worry about it here's something that i'm about to do my next project in vim after i finish off harpoon 2 is going to be apm there is no way for you to listen to vim motions and know what motion was just executed that means i have to see the incoming stream of keys and determine what is the state of im are we in insert mode are we in visual mode are we in whatever blah blah blah mode therefore when keys are executed i have to like discover the motion you are creating do you realize how difficult that would be to create without unit test that a very simple and obvious thing you're going to want to unit test the engine to capture keys and to correctly identify that is like a black box of all time it is literally just like here is a black box here's a string of keys what happened output better be this input better be this this is like perfect blackbox this i mean this is unit testing to a t what is good cu to to a to make that correct is really really hard b to test it is really really hard manually testing that would be be a nightmare and see since the input and the output will be known it is super super super simple you know what i mean so that's kind of how i look at it right winchester winchester usually has some pretty good takes in here tad testing after development i'm a big fan of testing after development jordan i think i answered yours like i to me it's just like find a problem that you can make that makes sense to test like that is to me that's obvious it's obvious that you'd want to unit test it i have a different take i hate what unit tests imply and they are easy to manage poorly yes agreed i usually give most focus on integration tests and if there's a function that is a bit expensive complex i do develop a unit test i don't write test while i let's see while i just test let's see hold on i don't write test while i just testing and trying to understand how to build something sometimes i need to build something to know if it's the correct way yes i will even if i if if i'm stuck on something that's hard i will write a unit test for me unit test is that is is driving that really annoying part of development where you have to try to like launch programs and like different things at once to know that you're doing it correct so for me it's like if i can cut that time from 20 seconds plus context shifting to to 20 milliseconds absolute win every single time even if it takes me an hour that that amount of like not having to do that cycle saves so much time it just saves so much time force test coverage is usually accompanied with really bad tests absolutely absolutely so this is where i think i think this is where all the hate of unit test really come from is people are forced to write unit tests i think it's 100% the case is that if you're not forced to write unit tests you will write them for what makes sense for you those cycle yeah those cycles need to be shared exactly exactly because then you then then then you get that you get that multiplier effect build fails yeah in some domains your you let's see your forced to have 100% yeah it's not real though i always give here here's a really simple example of why that's fake okay we're going to write some lua for a second okay i'm going to write it in typescript even though i'm in a lu file because it just makes more sense all right const fu equals this all right let's see add right it's going to take in an r right that's a number array and it's going to return r let's see r 0 plus r1 and it's going to return a number right i can easily get 100% on this and i would not have tested nan right like how simple is that to test nan right boom 100% test coverage ah  right like is it even real right that's the problem about 100% test coverage is it's not real you know what i mean it's not real that's why 100 test 100% test coverage is not inherently more safe than 80% property based testing it can be annoying i mean it's no different than interface-based testing when you have to refactor something if you don't have a proper interface if you don't have a stable interface it it's just as annoying right yeah i agree with this the biggest issue i see developers not leveraging other types of tests eg integration e yeah i do like i do like integration but they can be really hard to set up too you know so you also i mean integration and it depends like end to end tests can also fail sporadically depending on how big your client is and how many services you're using is it all and then you also have this entire there's a lot of complications with end to end that aren't often talked about like another big thing is let's say you have an end to end test and you need it to run in staging you also have to have all your micr services that you're using potentially in staging as well that adds like a whole another layer of complexity you know what i mean it's it's just it's not simple right it's not easy e can e can be very difficult so i i i don't you know i don't i don't fully support any one of those but i do like the idea of them all if that makes sense integration tastes take long after to right yeah they can be very very difficult so you don't want to overdo integration testing you want to try to minimize that should the target be 80% the target should be no percent if you think there's a percent that makes sense you're not doing it right i love this song by the way all right people that's enough that this is good hey this is a good talk about unit testing good talk good talk i liked your guys' questions okay i liked your guys' thoughts like and subscribe these nuts oh got him a genen the name is the p unit a genen