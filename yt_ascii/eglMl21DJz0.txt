go 1.20 experiment memory arenas versus traditional memory management is traditional like managed memory because that would be more traditional right is gar isn't garbage collection modern memory management i don't even know now now you got me all confused dimitri but let's find out what you have to say go arenas are an experimental feature the api and implementation is completely unsupported and the go team makes no guarantees about a compatibility or whether it will even continue to exist in any feature release or future release awesome okay this seems exciting this is exciting this is some cutting edge go people all right go 1.20 introduces an experimental concept of arenas exciting for memory management which can be used to improve performance of your go programs in this blog post we'll look at it what are arenas how do they work how can you determine if your program could benefit from arenas how do we use let's see how we use arenas to optimize our services so this is super exciting because again if you can make go slightly faster like it's already it go as a super simple language to get right get it shipped and move on so if you can make it even slightly more faster like that'd be crazy all right because memory is a huge turn on any system memory is going to be one of your biggest causes for things being slow let's see what are memory arenas go is a programming language that utilizes garbage collection meaning that the runtime automatically manages memory allocation and deallocation for the programmer this eliminates the need for manual memory management but it comes with the cost absolutely the go run time must keep track of every object that is allocated leading to the increased performance overhead yep classic and then it also has to find out which ones can be cleaned up in let's see in certain scenarios such as when an h titty server process processes requests with large protobuf blobs which contain many small objects this can result in go or in the go runtime spending a significant amount of time tracking each of those individual allocations and then deallocating them as a result this also causes significant performance overhead one thing i don't know about go that's true in javascript is that like everything is its own object therefore like a map with maps in it or an object with maps in it are actually two separately tracked items so i'm not sure if that's true in go or not i i don't know so anyways arenas offer a solution to this problem by reducing the overhead associated with many smaller allocations in this protobuf blob example a large chunk of memory and arena can be allocated before parsing enable enabling before parsing enabling all parse objects to then be placed within an arena and tracked as a collective unit once parsing is completed the entire arena can be freed at once okay so this is like effectively in some sense you're saying that this object can only be referenced by a certain amount of items and they're all in one single group so it's very very simple okay this is actually pretty cool this is kind of like a cool concept i like it okay so garbage collector yeah they have all these individual objects versus just have them all in one okay i like this okay so this is what they mean by an arena okay identifying code that could benefit from arenas any code that allocates a lot of small objects could potentially benefit from arenas but how do you know if your code allocates too many in our experience the best way to find out is to profile your program yep nice pyroscope okay pyroscope is one of these cool so they give you like a little arena or allocation allocation i believe they call these icicle graphs because they hang from the top it's just a flame graph i call it a flame graph okay just invert it and boom you got yourself a flame graph i'm not really sure why we decided to flip flame graphs upside down but you know we did we went there and now look at us now look at us now we got icicles okay i don't understand it what the hell's happening here okay the purple nodes in this allocated objects flame graph represent where arenas may be most effective oh interesting i wonder how that works or why they're colored purple what makes them that way oh samples there's a lot of samples objects in ram there's a lot of objects in ram okay okay okay you can see the majority of allocations this many come from one area of code oh okay so it's this one right here or are you talking about this one are you talking about this one i'm not sure which one they're talking about but somewhere in there usually how i read this is this one is the one that allocated all this this one allocated from here to here and this one allocated from here to here right that's how i'd read it given that it represents 65 of allocations this is a good candidate for using arenas but is there enough of a performance benefit to be gained by cutting down these allocations let's take a look at the cpu profiler okay so it does look like you're getting the same kind of area right here okay exciting purple nodes in this cpu flame graph represents potential for performance improvements all right let's go a few things stand out the problem or the program spends a lot of cpu time in the same insert stack a function okay so there could be there could be some gains is it the memory that's causing him if you search for a runtime malik gc multiple pink nodes at the bottom you'll see that the function is called frequently in various different places and takes about 14 of our total execution time so this is typically how i do this for node node i'll look for major and minor gc and i will look for how much of the program's time am i spending in a major or minor gc and that's really your garbage collection win now where this makes a huge win is inside of requests right inside of a server because once your server can can reduce that it actually makes a disproportionately huge effect in how much you actually get done because a single request all the the problem why is that it's like a multiple right so in in node when a single request hits with a garbage collection all other requests that are waiting all get hit with the same garbage collection so a 200 millisecond stop isn't just a 200 millisecond for a singular request it's a 200 millisecond for the 10 requests in there so the amount of speed you gain by reducing garbage collection goes up significant amounts inside of a node application that's why you know that's why garbage collection is a really good thing to think about you know what i mean i don't know if it's the same in go i don't know exactly how go works but if it also has freeze the world garbage collection then you could argue the exact same thing every single one of those will all have to freeze and therefore you're a 14 isn't just 14 it could be a hundred and forty percent right you don't know how much it will actually improve your response time and all that about five percent of the cpu time is spent in runtime big mark worker okay awesome so in theory if we optimize all of our allocations in this program we could cut about 14 plus 5 19 cpu time this would translate in 90 cost savings and latency improvement for all of our customers in practice it's unlikely that we could truly get those numbers down to zero but this is still a significant chunk of work yep okay optimizations we made if you're interested in following along there's a public pull request for pyroscope repository that you can use as a reference to begin we created a wrapper component that is responsible for dealing with allocations of slices or structs if arenas are enabled this component allocates slices using an arena otherwise it uses a standard make function we do this by using a build tags okay i don't know much about build tags and go this allows for easy switching between arena allocations and standard allocations at build time okay perfect so there's no runtime overhead is what they're saying it just chooses one or the other perfect then we added initialization and cleanup calls for our arenas around the parser code after that we replaced regular make calls with make calls from our wrapper component finally we build pyroscope with arenas enabled and gradually deployed to our production environment okay let's see flame graph with the representative cpu time per function is this supposed to be the same as this one i mean it looks like the same right so 13 percent 13 okay the flame graph above represents a profile after we've implemented the changes you can see that many of the runtime malik calls are now gone i couldn't see them before i guess i'd have to kind of run through this is there a way to like easy oh is this one over here yeah okay so it was this one four percent oh is it all pink that okay so all pink okay so all pink is allocation stuff okay so now pink is all in one nice little area and i mean i can't really tell if it's different i'd have to use i don't know how to do searchings i don't know how to use this thing well anyways the flame graph above represents a profile after we've implemented the changes you can see that many of the runtime mallet gc calls are gone but are now replaced with arena specific equivalent you can also see that the garbage collection overhead is cut in half it's hard to see the exact amount of savings from solely looking at the flame graphs but when looking at our grafana dashboard which combines our flame graphs with cpu utilization from aws metrics we saw an approximate eight percent reduction in cpu usage this translates into an eight percent cost savings for our cloud build particular services well that's only if you can technically scale it correctly right i think you have to be at a pretty good amount but look at that that's cool right like that means you can handle a lot more requests what i would really like to see is the latency or not the latency the round trip times what do you do with the 50 percentile what happens to the 50th percentile and the 75th percentile because the the 99th will probably remain near the same right the 99th and the 99.9 those probably all remain the same but like the 50 percentile or the 75th percentile how much do you shrink that back you could actually see a very significant percentage shrink back this may not seem like a lot but it's important to note that this is a service that has already been optimized quite a bit for example the protobuf parser that we use doesn't allocate any extra memory at all garbage collection overhead five percent is also lower end of the spectrum for our services we think that there's a lot more room for improvement other than parts of the code base and so we're excited to continue to experiment with arenas this is actually really cool this is super cool now i want to play with it damn it i'm supposed to be studying for htmx and oh camel and now i want to go play with go all of a sudden right trade-offs while arenas can provide performance benefits it's important to consider the trade-offs before using them the main drawback using arenas is that you use arenas you now have to manage memory manually and if you're not careful this leads to serious problems absolutely failing to properly free memory can lead to memory leaks i know but this is a problem with all maps right so i mean you still have this the exact same problem in any long living map attempting to access an object from a previous previously freed arena may cause program crashes absolutely classic really here's our recommendation only use arenas in critical code paths do not use them everywhere good good call profile your code before and after using arenas to make sure you're adding arenas in areas that they can provide most benefit yep definitely profile your code before and find where the memory is being churned the most right even node has this you can add object pools to node and you can see huge performance benefits by looking where you allocate the most amount of memory and what i found especially with like callback objects is really really good to use like bound functions and all that it's very very good hog stack i know very excited for the hog stack the hog or the gog stack pay close attention to the life cycle of the objects created in the arena make sure you don't leak them to other components yep so you definitely have to have internal implementation details use defer a free to make sure yes beautiful use clone to clone objects back to the heap okay beautiful the other major drawback at the moment is go arenas are experimental feature the api and the implementation is completely unsupported and the go team makes no guarantee about backwards compatibility or about compatibility or whether it'll even continue to exist in future releases i think i think it's really exciting though i i really do hope they kind of pursue this because i really love the idea of having escape hatches to manually manage your own memory because it is such a huge benefit when it is a benefit you know for the most part a lot of the things you do is super ephemeral you don't care but there are those few times where it's just like if i could manage memory right here i could like eliminate half my programs like running time just for this like this one thing i have this exact thing right now and i wish i could just map so what i do in javascript i kid you not what i do in javascript at my job right now is i do this stupid stuff where i'll be like const get you know you know items equals some sort of awaiting and getting this thing right i get some sort of array back right this returns an array of you know something right something yeah yeah yeah yeah and then i have to go through it right i do some sort of while items length right something that looks like this and do items pop because then i'm reducing it one at a time and then at the end i go items equals null because i have to which means that i have to use a let here and it's all complicated in one part because i actually use too much memory and then by doing this and importing gc and enforcing gc i can keep memory down like this is crazy what i have to do but my program goes to eight gigabytes sometimes or i can keep it at 200 megabytes by enforcing manual memory management in node which is totally the worst thing ever and i hate it and i have to write stupid code like this but i do because that's what i have to do and i don't want to do it right i wish i had better off i wish i had more things right anyways the go team has received a lot of feedback about arenas and we'd like to address some of the concerns that we've seen from the community most frequently mentioned issue with arenas is that they make the language more complicated by adding an implicit and not immediately obvious way for programs to crash absolutely one positive thing about go is that go does not want complexity and there's something about that that is very beautiful in of itself even if you don't like it it's still beautiful most of the criticism is well-founded but misdirected we are not anticipating arenas becoming widespread we view arenas as a powerful tool but one that only is suitable for specific situation in our view arena should be included in the standard library however their usage should be discouraged much like the usage of unsafe reflect or seagull our experience with arenas has been very positive and we're able to show that arenas can significantly reduce the amount of time spent in garbage collection and memory allocations the experiment described in this article focused on a single already highly optimized service and we were still able to squeeze eight percent extra performance by using arenas we still think that many users can benefit a lot more from arenas absolutely if you don't have an optimized one you're just creating wild objects you could really get some good stuff in addition to that we also find that arenas are easier to implement compared to other optimizations that we have tried in the past such as using buffer pools pools are very hard to use pools are super easy to leak or writing custom allocation free protobuf parsers this is like ultra duper duper hard and compared to the other types of optimizations they share the same drawbacks but provide more benefits so in our view arenas have a net win i am completely on this one right here this is like totally a w right here because this makes perfect sense because it is so hard to do the other optimizations pooling objects is non-trivial it's easy to get it wrong it's easy to leak memory it's easy to do the wrong thing yeah pools are easy if you ignore exceptions yeah they're simple and also oopsie daisy stale data and some other things that accidentally happen and blah blah blah blah arenas are a powerful tool for optimizing go programs particularly in the scenarios where your program spends significant amount of times parsing large protobuf or json blobs they have the potential to provide significant performance improvements but it also is important to note that they are experimental feature and there's no guarantees of compatibility yep all right awesome beautiful beautiful article thank you dimitri this was fantastic really liked it and i'm actually pretty excited about go to me this is a this just makes go more appealing because what this says to me is that go isn't fine with 95 performance they want that 99 and if you can get 99 you're looking creamy smooth right because with javascript you cannot do this right like this is just not currently a thing for javascript and nor do i really want it in javascript because anything that is done with javascript tends to get wildly abused you know what i mean wildly abused so this is beautiful this is actually really beautiful and i think greg is leptos greg here is leptos greg here greg i'm using some more leptos tonight i don't know if you know that but dude i'm going deep on leptos greg look at this look at this beautiful stuff i'm just about to grab some data from tercel but i'm using a local file client which makes it even better right just grabbing it from that example love it anyways greg you're a great guy great guy greg everybody give great guy greg big claps everybody great guy the name is i really do love leptos and it is solely the reason why i'm continuing to use rust no matter what i think i would switch to oh camel and use o camel for my back ends but at this point i still use rust because of leptos because leptos is that amazing again