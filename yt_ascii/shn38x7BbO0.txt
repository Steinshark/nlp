so today we're looking at software-defined networking and in particular the openflow technology you've got recording this already from richie mortier what i'd like to do though is dig into a bit of the details about how you'd use it how you would actually code this stuff because for me one of the fascinating things about it is you can write your own switch software you can write the brains of you can write the brains of a router or a switch and that's for me one of the big interesting things about it and the other thing is you could get a bunch of software switches running the overflow protocol going just on a humble laptop you can sort of build your own data center you can have hundreds of switches connected to each other and write the controller for the full details you should watch the that's an excellent video already on your channel but i just want to recap about the sort of thing we're dealing with so key for me in understanding this is separating what we call the data plane and the control plane so let's imagine we have some bunch of switches sending data about now switches are often pretty simple minded in what a normal switch can do so they're connected up in a topology now normally you just configure them they go away and do that thing maybe you want a little bit more cleverer control if we've got these open flow switches we can add on top of them the open flow controller so it's it's a software component that speaks to a software component in these switches so if you imagine each of these switches there's a little software component in them and they can speak to a controller up here now if you think about what a switch does it's got two tasks it's got to move the data about so it's got to take packets in and it's got to push those packets out decide whether it wants to keep them or drop them and then move those packets out and decide which of its ports it wants to move the packets out so maybe it knows that the data's got to get to here so it's going to move the packets down here move the packets down here move the packets down here now moving to packets that's the job of the data plane when i think about the data plane i think of it as being very much a manual laborer it's looking at a simple set of rules and it's saying this packet is going to this particular ethernet address so it needs to go left picks up the packet moves packet done this particular packet oh that's not from a trusted source we're just going to drop it this particular packet we're going to send it out we're going to flood it out to all of the switches that i know so i'll send it out to everyone and it's got a simple set of rules it works with that's the data plane the question is where does that set of rules come from now normal switches have various algorithms they work with but in an open flow situation you have the ability to write your own rules than to react to unexpected events so in the open flow situation a packet comes in the switch looks at its list of rules and if the packet doesn't match any it's going to send up a little query it's called a packet in event and it's going to say hey controller just got this packet i don't know what to do with it the controller will look at its software rules so it's software you can write in a standard language like python and it will say what to do with that particular type of packet and then you come up with a rule so you say any packet going to that particular ethernet port or any packet from that sub network you're going to follow this and it replies to the switch with a new rule to meet what's happening with that packet and now the switch knows what to do with that packet and all packets that are like that one yeah so we've got a situation where the controller can responsively see a packet where it doesn't know a rule and give the switch a new rule so it's a bit more dynamic rather than being kind of like card coded or hardwired it can be a bit more fluid absolutely and the great thing is this this can work for switches and routers so if your topology is more complex than this and there's actual routing at the internet protocol layer going on your controller can work with that as well we've talked previously about bowman ford or dijkstra algorithm with routing but those always just work on a destination now let's imagine you have something more complex so you think i've got video traffic which takes up a load of bandwidth but i've got my gaming traffic it's got to be quick but it doesn't take a lot of bandwidth maybe you can devote one part of your network to be in fast and low latency and another part of your network to be a little bit slower but it's got a lot of bandwidth so you could send your video traffic one way your gaming traffic another way then you can add lots of other things so you could add in a firewall so that switch can say this location i trust all the traffic can come through this location they can only see the web server nothing else available to them this location trying to hack me last week and everything from there is going in the bin something like this it might be literally my house where my son's trying to play fortnight or whatever so he needs the faster traffic and every time i hear this knock on the door saying daddy are you uploading a video maybe it would maybe it would make that go away with it if you had multiple paths in your house if your house had a network with multiple paths you could say okay mine's going to go on the slower path his is going to get the priority there i might switch that route but anyway carry on oh yeah yeah it's true actually it depends what you want yeah he shouldn't be playing fortnite got him with his schoolwork absolutely so yeah so we've got there this separation now with the open flow system into the data plane which is just obeying the rules and the open flow system which is the controller which is setting the rules and receiving these packet in events these exceptions to the rules one of the things that's just very easy to play about is a tool called mini mininet and it's i love it it's just a gorgeous bit of software and its job is to create software switches and software hosts yeah so we can set it up in a really really simple way and we can just do the absolute basics and see it working with some simple commands so okay so let's tie it up just in a real simple topology we've got two hosts and a switch and we can see here it's added in some links between host one and switch one host two and switch one so now we've got a really really simple topology host host connected by switch and now we can issue commands as if they've been is issued from a particular host so we can say h1 ping h2 and what that means in minion x language is host one send out a ping packet to h2 not very spectacular but that's using the proper networking code this isn't an emulation this is the real ping command sending real packets through a real software switch it's not that exciting so let's do something a bit more a bit more a bit more interesting so within mininet we can build up our own topology so we can actually write in python the network that we want to produce it is a super simple topology but here's our computer file topology written in python we've imported some commands from mininet and all this says is we're going to add a host h1 and we'll assign it to the variable left host we're going to add a host h2 and we'll assign it to the variable write house so this is setting up some python objects left host right host and adding them into mini net as host h1 host h2 switch s1 and switch s2 and now we can add some links add a link from the left host to the left switch add a link from the left switch to the right switch and link from the right switch to the right host so we've got just a simple line topology but we could make that as complicated as we like and we could do it programmatically so we could use a for loop to make that line as long as we wanted and then there's just a simple command here to start the topology and let me just demonstrate how that starts so i need to stop mininet and i'm just gonna do a little clear up to make sure that all of its all of the software switches is started have gone away otherwise to be problems and now we can start our custom topology there we go and that has obeyed the code i've put in here we can do exactly what we did before h1 ping h2 and we're sending packets through just to be clear so this isn't simulating this is literally doing this but via kind of virtual machines almost is it yeah yeah yeah but virtual switches it's it's setting up virtual switches rooting those switching those packets and genuinely delivering packets so it's not a simulation it's it's january sundance packets now what we can do with this that ties into the open flow is we can ask that those switches are open flow switches that means though that's not going to work unless we have an open flow controller we've cleaned up our controller and now we're going to start again but we're going to this time say instead of using a standard switch we're going to use an flow virtual switch running the kernel so switch o v s k is an open flow virtual switch running in the linux kernel but when i start that off we immediately we have a problem because we don't have a controller so i'll start it off and it's going to say come back there could not find a default controller like i said the the data plane is the manual laborer the controller that's the brains that's the person creating the rules and if we start it like that without a controller it's obviously it's going to complain what we need now is to start the controller so i'm going to use a very very simple demo one this is demo code that comes with the pox python controller the job of this controller is to catch those packets in events and provide rules when it gets a packeting event yeah so it's connecting to all of our virtual openflow switches and listening for those switches saying oh i've got a packet and i don't know what to do with it and this is the software that catches that and decides on what rule goes with it here it's just doing some housekeeping this is from somebody else's tutorial code by the way i should say i did not write this code myself handle packet in so this is the the heart of it we're going to get a packet in so this is an event that happens on the controller when a packet doesn't match any of the rules on the switch so here we've got this packet an event this line is just passing it and switching it into the correct open floor tone and what we're going to do here we're going to say act like a hub so just send it out to everybody just a hub the hub's very very simple if i don't know what to do i'm just going to send that packet onto everybody i'm going to flood it out there so we need the act like hub code and this just says resend the packet so take my packet in resend it and send it to everybody yeah so the packet's just gonna flood out everybody's gonna get it and it's fine that abs that absolutely works on these this type of switch network so just that simple logic is going to be enough to get our controller workings so i've started up that tutorial code and now i'll just do a clean up on the mininet and i'll start with the mini net minus minus controller remote and that's going to tell it you have got a controller it's running on the same computer and here we go and we can see that this has started the topology we programmed and this is passing some of things now we can do our h1 ping h2 and the data is getting through okay so you might say so prove it to me is this really going through the software so i could say packets is zero so set a local variable to keep track of the packets in the class and then when we are acting like a hub self packets is self dot packets plus one print counted packets itself got packets and now start up the controller reset mininet so i start up mininet with my custom topology and now it's counting the packets i'm still throwing some dns errors and i'm not quite sure why i don't know why it's getting dns packets but but you can see it's counting the packets as they come through this is still falling far short of my promise that it can seem like a data center right still seeming pretty basic but we can make more complex topologies now to do this i'm going to step up and i'm going to use a different controller so i'm going to use here the floodlight controller so this is a large bit of software it's getting a bit old now for in terms of these overflow controls so you wouldn't use this in a production network but it's very nice just as a demo bit of software and to demonstrate to to your viewers how we can get a group of switches working on openflow the nice thing about the floodlight controller is it's got a web interface if i browse this web page on one two seven zero zero one my own computer we can see that it's active it's been running for 27 seconds and it sees no no switches and it sees no hosts let's start up a mini net topology and let's make it a tree topology so we're going to run a more complex topology so my command here has started a topology for a tree with a depth of three a fan out of two connected to the remote control using open flow virtual switches and the version 1.3 open flow protocol with this we can see that the overflow controller is seeing seven switches 19 hosts 12 connections and we can see a topology wired up so we can see that this topology reflects the tree that we've set up and we can be more ambitious than that so i can set a a slightly deeper tree have that connect to the controller and hopefully the topology will reflect the increased complexity we've just set it so it's got a few more switches and i can push this quite a long way so let's say we want to be just a little bit more ambitious let's set that those tree parameters a bit more so get more towards what i promised which you can have something a little bit like a data center in our laptops so i'm going to try the tree with a depth of four a fan out of three but otherwise the same things the remote controller the floodlight controller we were using before so now it's starting up all of those hosts starting up all of those switches we've got 81 hosts 40 switches wired up in a tree i can say ping all and this will send ping packets between all of those hosts so here h1 is pinging everything and now if we go over to our topology and refresh that hopefully this should start to catch up and it should work out that we've got a tree topology can take a little while when there's so much data going through so it just take a little bit of a while to absorb all of the topology information it's getting in there we can see quite nicely can i zoom in look at that i think that that's absolutely lovely to be honest i find that quite exciting and just emphasize again this isn't a simulation in a simulation this will be very very easy but this is actual packets being rooted so if i say that's h48 and if i say h48 ping h5 it's going to send genuine pink packets down that topology can we use trace route through it we can use traceroute but these are all switches and traceroute only looks at roosters so traceroute will always be very very simple in this because it's only one hop none of these count as part of the route if we had a layer two a switch based trace route then we could see something real interesting with that but unfortunately we don't well it definitely looks like the data center's taking shape there on that web browser for somebody like me as a researcher this is really exciting because let's imagine i have some new research idea for how switches should work and i want to experiment with that in the old days where switches were just didn't have this open flow capability what i would have to do is persuade somebody i could try it out i could simulate it but i don't have to persuade somebody to build a switch using silicon tremendously expensive and then i go oh you know what my algorithm needs a bit of a tweak could you build me another one that does this here i can experiment just on my laptop i can write new things into the controller i can write new algorithms new ways of doing things try them out see how it goes in these software switches and then buy open flow switches they're just a commodity product you can just say buy me 40 open flow switches they're already there and i can test my new open flow controller in a real network having tested it on software switches within my laptop so it's just a tremendously exciting way to play about and learn about how these open flow switches are controlled and how you could control them in a real network standard computer file question now though if this is all open source i'm guessing people can go and play with this now could they yeah absolutely absolutely i'm go i'm going to put things on github so hopefully people could build this software play with it on their own machines and say if you've got linux if you've got ubuntu you can just installing mininet it's just a single command and you can just play about with it cool have fun cool learn about it or make nice pretty snowflake pictures with your topology oh yeah oh just enjoy the fact that we've got a lovely fractal snowflake like topology and two that routine table is going to arrive with green green's going to say oh you can get to blue in one brilliant i've got a cheaper cost to blue it's going to here for the first time here a little bit longer then we've got 60 possible positions one we've got a two three out of five and then they can all go in any