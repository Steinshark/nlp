in the next 15 minutes i'm going to teach you binary reverse engineering by the end of this video you'll be ripping apart binaries in ida you don't need any programming experience or any cyber security experience whatsoever let's get into it to discuss how to do reverse engineering we first need to talk about what reverse engineering is the art of reverse engineering is taking a binary and reversing it to figure out what it does to talk about this let's talk about what the classical example is of source code that goes from source code to a binary when i write code i have a bunch of different symbols in the binary that are human readable i have the type of the variable i have the name of the function i have the name of the variable etc all of these symbols these human readable strings these labels tell me what the code is going to do i can infer a lot of information from the source code by reading the code so for example i have a buffer that gets passed to scan f and then i call get pass on that buffer because i have the source code i now know generally that i will read in data from the user and i will check that buffer against a known password and if i get it right i get to go to the that is correct block the problem is that if i have just the binary i don't have that source code and instead what i have is this really horrific just binary blob of data that looking at this i can't infer any information about this so reverse engineering is going from this without the source code and inferring the features from what the code does right why do we do that in the first place the number one thing i think is for cyber security professionals the art of malware reverse engineering is extremely important for a few reasons the big one being if you're able to take the malware that you find in your system and triage it by hand instead of depending on the sandbox analyzer you can yourself figure out what the attacker was trying to do and then it from that and for how to defend against it number two i think reverse engineering is just fun i think the art of taking things that you don't know what they do looking inside of them and figuring out what they're supposed to do do is really fun so there's a couple different techniques that we can do to reverse engineer this binary the first one that everyone can do right now on your computer is we can do the operation strings on our binary so we're going to do that all the strings being util does is it looks for a five character or greater string of ascii characters and prints them to the screen if they're found in the binary so these are all the strings in the binary and you can see we have the name of the functions that we import like scanf puts in printf those will always get preserved for the reasons of linking and then we have the strings we actually wrote into our program we have welcome to your first crack me problem what is the password the format string for the scanf and then that is correct the problem with this is that the password itself is not revealed in the binary so we have to go through the art of getting a little deeper reading the machine code and figuring out what the machine code does to get the password from the user going one level deeper instead of strings we can kind of put this into what is called a disassembler the one disassembler everyone has access to right now is going to be object dump so we're going to write object dump disassemble the main sections use intel syntax on our program and pipe that into less now what we have here is it the disassembler is taking the ones and zeros say literal hex data and converting that into a human readable version of the assembly instruction so if we can navigate down to the text section the text section contains the code for our binary right the executable bits that will get ran by the processor and here we have the binary data and then the actual human readable assembly instruction the problem with this now is this is not very human readable we can probably kind of infer what's happening here but there's not a good visualization of the control flow graph meaning the if statements that will either execute or not execute as the binary runs so we're going to go one level deeper and put the binary into a more complex disassembler and my favorite disassembler there are two primary ones there's ida and guidra i would argue for the reasons of learning assembly and learning reverse engineering that we should use ida so we're going to go ahead and we're going to install that i've already installed the downloader i'll put the link for that in the description below from my downloads you can go ahead and run the ida installer and once you've ran the installer you will get a folder in your home directory called ida free and we're going to run ida 64. we're gonna go to baby's first crack me and we're going to import our binary file it's going to make sure that we are okay with us treating this binary file as an elf64 and we're going to go ahead and hit ok what ida will then do is ida will go through and it will disassemble the entire binary and give us the ability to read the assembly here i'm going to zoom in on this and now we are looking at ida's disassembly of the program from what it inferred as the start point so the start point is what is the first instruction that is going to run when the program starts there's a lot of stuff here that we can talk about this is more about the runtime of the libc library initializing we're going to skip all of this we're going to jump right into this label here so before lib c start main gets called that's what the call instruction does it loads the effective address of our main function into rdi so one thing we have to kind of talk about here very basic reverse engineering concept is the is this concept called binary abis or abstracted binary interfaces what these are are the agreement that the computer has made with the processor about the registers that will contain different values and a function is called so for example if i call function foo and numbers 1 and 2 are the arguments to foo before we call foo already i will contain one and then rsi will contain two this is just the agreement that the compiler has made with the processor right this is the way that it expects the data to behave so if we go back and we look at that when we call libc start main we have rdi goes main and then i'm sorry i guess in this case it's rcx actually no it is rsi rsi takes arcv that's the second argument and then rcx gets the next argument which is in it so we're gonna go ahead and we're going to double click on main and this is our function that we wrote you know before we were looking at the lib c start we didn't write any of that code this is the code that we wrote but the assembly for that code right and we can kind of see that if we look at this we see we have the puts function get called and it gets called with this pointer to s in rdi argument number one and that's where it says welcome to your first crack me problem we then have another one that says printf printf is it gets called on the what is the password so these are the two prints that get called to prep us to check our password and then we have a few things happen here so remember how i said that the first argument is rdi and the next argument is rsi well we can look at this move instruction and see that rsi comes from rax we're going to middle click on rex these all get highlighted rix becomes load the effective address of this location here interesting what is that location so because it loads the effective address it actually puts a pointer to this location in rix before it puts it into rsi so that means that this variable here variable 50 is the buffer that we created for our buffer remember we can go back and look at our code here we created a 64 byte buffer so that is the location of where our password is going to go into okay so let's go ahead and we're going to label this we're going to right click hit name we're going to type in buffer by doing this we are starting to infer more and more information about the symbols that we wrote as programmers that the malware wrote the malware author wrote as a programmer of the malware reverse engineering or whatever about what the program does right so we call the scanf function here and then eventually we go down to this next function here and then we have a conditional jump we say jump z or jump zero to either this location that is correct or something else we're going to talk about how how that all works in a second here so again we talked about the binary abi the binary abi tells us you know what the processor agrees on in terms of what registers receive what data in the case of return values and again this only applies to 64-bit intel return values come back through r a x so we're going to keep that in mind so arguments go into rdi and rsi and then return values go into rax i just realized my fat head was blocking i apologize all right so if we go back into the vm we see that we call this function the processor then tests eax which is the lower half of rix so it tests the return value and if the return value is zero we jump the green line is where we jump on a positive test so jump zero we jump around this and if it is not zero jump zero red right the red means we go here it says that is correct what is that coming from if we go back to our code we're testing the return of the get pass function the get pass function will return one if our password is correct and if it's correct we say that is correct so that's how we got that out of the assembly so now you're probably saying okay cool let's get into that function let's let's go figure out that password okay we'll get there step one we want to rename this the get password function right we can just kind of infer that you know it says what is your password if you get it right it says that it's correct we can just infer that that is the get password function so we're going to double click on that and here we have this giant chart you may already see the password starting to appear here but remember what i said before the rdi variable is the first argument that gets passed into a function in this function here we passed our buffer as the first argument so we're going to go into there so if we look at this it does a few things it sets up our stack and then we move rdi the pointer that we gave it as an argument to another variable on the stack it's preserving the argument so we're going to call this buffer as well and this is a pointer to the buffer so now what it's doing is it's going to take that same buffer it's going to put it into rax and it's going to compare the first pointer or the first byte so to say treat rex as a pointer extract one byte and put it into eax that is what this instruction turns into and we're going to compare that al is the lower eight bits of eax and rx these are all the same registers just different parts of it and we're going to compare that to 6 3 h well as ida is already showing you i just showing you hey by the way 6 3 h is the letter c if that is not zero right if they're not the same a zero comparison is also the same as the for the same comparison so if they're not zero meaning that they're not the same jump away and this is the return right we're returning zero so if we go back if it is not zero or if it is zero meaning that they're the same go to the next add one to our pointer right extract the buffer add one to it which means increment to the next character and compare that to the letter a so you can actually just read the instructions here and figure out what our password is so c a n okay that's a word can underscore yeah underscore kenya underscore dig underscore it question mark okay cool so that seems easy enough let's try it out can ya dig it that is correct what did we just do we took a binary that we didn't have the source code for and again we did we weren't referencing that too heavily and we put that binary into first object dump to figure out what it did but we saw this as kind of ugly and hard to read so we put it into our favorite disassembler ida and use that to extract the functionality and eventually the password you may be asking why did strings not reveal the password in that binary the reason was when you look at this the actual hex code for the binary is the instructions at that location the the comparison to the letter g actually gets packed into the instructions if you look at the instruction here you don't get to see the letter g pattern of the binary actually you kind of do you can see the letter g here gets packed to the instruction because we're comparing that byte to the letter g but again you wouldn't know that if you didn't know the functionality of the binary so i highly suggest you go onto my github links down below take the ida link also below and try this out for yourself i'm a huge proponent of kinetic learning using your hands getting dirty and filling things out as you go that is the same reason why i'm excited to talk about today's sponsor brilliant brilliant is an amazing learning platform that features over 70 courses and a variety of interesting topics like math and computer science brilliance computer science course covers a series of bite-sized lessons on the fundamentals for professional programmers like logical decision making interfaces and thinking with graphs my favorite part about brilliant is that their lessons are all hands-on i'm someone who learns by doing every brilliant lesson is filled with interactive examples that let you test your understanding as you go you can go try brilliant for free right now and you using my url www.brilliant.org low level learning the first 200 of you get 20 off an annual premium subscription which gives you access to all of brilliance courses thanks again brilliant for sponsoring this video