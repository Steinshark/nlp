hi everyone let's let this episode out by adding the ability to move these existing color keys around so i'm going to go into the gradient editor script and in this if statement where were checking if the mouse is pressed down before we go ahead and add a new keon let's check if the mouse isn't over an existing key so to be able to do that we're going to need an array of all of the rectangles of all of the keys so let's create a rectangle array up here i'll call this key rekts and before we start drawing all of the keys we can initialize that to a new rectangle array but the size of gradient dot number of keys and then after we've drawn each rectangle we can just add it to the array so key rectangles with an index of i is equal to the key rate that we've just drawn all right so now in this if statement we can do a for loop from i equals 0 to i less than here x dot length and we can say if the current kee-rect so curettes with an index of i if that contains a gooey event dot mouse position then we know that the mouse is of course over there key so let's create a bool up at the top here called mouse is down over key and also an int to keep track of the selected key index so inside of this if statement we can say mouse is down over key is not true and the selected key index is equal to i and then we can just break out of the loop all right so we're only going to add a new key then if the mouse isn't already down over an existing key so if not mouse is down over key okay now to show that a certain key is selected let's just give it a little black background so before we draw the actual key rectangle we can say if i is equal to the selected key index then we can just draw another slightly bigger rectangle bar so editor gui dodge draw rectangle let us create a new rectangle with kee-rect x minus 2 let's say kee-rect dot y -2 and then the width and height will just be expanded by 4 then so here x dot width plus 4 and kyra height plus 4 okay i'll just give this a black color so let's save that and see what happens here so i'll open the gradient and we can see the first key is selected by default and i can click to select these but it's not updating immediately so this is again where we need to force it to repaint so you can see we're doing that over here when a new key is created by calling the repaint method but let's actually just create a bull called needs repaint and whenever something changes we can just say nice repaint is true so i'll change that there and say needs free paint is true here as well when we select a key and then just at the bottom of the on gui method perhaps we can say if needs repaint then we will call the repaint method and say needs repaint is false okay now we need to make sure that this mouse is down over key bool gets set back to false when the left mouse button is released otherwise we'll never be able to add in a new key so let's say if gui event or type is equal to a vent type dot mouse up and that mouse is the left mouse button so gui event dot button is equal to 0 then we can set mouse is down over key equal to false all right so let's save that go into unity and just check that this is working as expected now so if i click of any one of these keys you can see it's getting highlighted and i can click to create a new key but when we create a new key that new key is being selected by default which i think is the behavior we would want so when we add a new key over here we're going to want to get the index of that new key so let's just press command d over this ad key method to hop over to the method body here and let's make this method return an integer for the index of the new key so if we've inserted the key then we can return i which is the index of the new key otherwise if we're just adding it on to the end of the list then we can return keys dot count minus 1 all right so saving that let's go back into the gradient editor script and we can say selected key index is equal to the result of the egg key method and we can say mass's down over key is true okay now to be able to actually move the selected key around we're going to need to handle the mouse drag event so let's say if mouse is down over key and gooey event type is equal to event type dot mouse and drag and this is the left mouse we're talking about so gooey event dot button is also equal to 0 then we're going to want to position the selected color key based on the x position of the mouse now currently there's no way to update the time of a color key so let's go into the custom gradient script and add in a new method public void update key time as well take in an integer for the key index and o let me spell it correctly and a float for the new time okay so we can't just change the time of a key directly because remember were keeping all of the keys in order so i think the best way to do this is to just remove the key at the given index and then add in a new key with the old keys color and the new time so let's start by storing the color of the old key i'll just set this equal to keys with an index of the given index and then well the color of that key that is and then to remove the key let's actually create a method for this because we range want to be able to remove keys from the interface as well so public void remove key and just pass in the index of the key we want to remove and here we can just say keys dot remove at index but we never want to have no keys and algorithms as let's just say that this operation is only legal if keys dot count is greater than or equal to two okay so we'll always have at least one key in our gradient so we can then say remove at the index and then add key passing in the old color and the new time and we want to keep track of the index of this key as it changes so let's actually return the index given by the id key method and change the return type of this to integer okay so if we save this go into gradient editor and then in our mouse drag event here we'll want to get the exposition of the color key based on the mouse position and we already have this calculation over here from where we're adding in a new key so let's just copy that in and then we can say gradient dot update key time passing in the selected key and x and the key time that we just calculated now as i mentioned the key and x might change since it's being reordered so we want to update the selected key index to be equal to the result of the update key time method finally we of course to say needs repaint is true let's very quickly add the ability to delete a color key so we can say if gui event.keycode is equal to key code or a backspace and it's a key down event so gooey event dot type is equal to a vent type dot key down then we can say a gradient dot remove key passing any selected key and x and we want to make sure that the selected key and x doesn't go out of range so let's just say if selected key index is greater than or equal to gradient dot num keys then we'll just decrement it by saying selected key and x minus - finally neither event is true okay just as a tiny bit of organization i'd like to take all of this input code that's up to that and just cut that out and put that in its own method called handle input all right so i'll paste that in there and it needs a reference to this gooey event so let's maybe just cut that from here i don't think this other draw code is using it so it can paste it in there and then we can just call a handle input from somewhere in the on gui method and likewise i'm going to create a draw method and just put all of this draw code in here certainly paste that in and we can call draw from there now the only rotating thing of course is that we no longer have a reference to the gradient preview rectangle since that's now in a different scope so we're going to need to have that wretch outside of those methods rect gradient preview rect and so we'll just assign that there okay let's try saving that and going into unity give that a moment to compile and now we should be able to drag this around and if i click to add a new one in should be able to drag that as well and if i press backspace it should delete the currently selected key and last thing to check is that when we come down to one key remaining we can no longer delete that key okay now just below these keys in this empty space over here we might want to have a couple of settings for example key color and blend mode let's start with the key color setting so let's go down to the bottom of the draw method and i'm going to create a rectangle called the settings rect just for that whole area below the keys so i'll set this equal to a new rectangle i'll inset that by border size on the x-axis and then i wanted to start just a little bit below the key rectangles so i'll just grab one of the key rectangles from the array and take y max and just add border size onto that and then for the width we can have the window width minus border size times 2 and and for the height don't really mind if this is accurate i'll just use the height of the window okay so just to make sure that that looks right let's go edit oqv dodge and draw rect draw a settings rectangle and say maybe colored off-white let's open that up and when it compiles we should see that they're all right so that's great we'll just use the gui layout to automatically layout the rest of our settings inside this rectangle so let's remove that at draw call now and instead we're going to say gui layout begin area and i'll pass in the settings rect as our layout area and we'll end with gui layout dot end area alright so in between these two calls we can draw an element's using the editor gui layout class so i want to have a color field and its color will be the color of the selected key so gradient dot get key with an index of selected key index dot color and we can store the color that we get back from this color field in a little variable here let's call that new color okay now if the color changes will of course want to update our keys color so let's quickly go into the custom gradient script and create a method for doing that public void update key color taking an int index and a color okay so here we can just say keys with the given index get set equal to a new color key passing in the new color and the time of the previous color key so keys index dot time so we can save that and now to figure out if the color has changed we can make a call to edit a gui dot begin change check and then we'll have our color field and then we can say if edit a gui dot end change check so that method will return true if something has changed only then will we say gradient dot update key color passing in the year index of the selected key and in new color alright so let's try saving that game to unity and on this compiles i'll open it up and now we've got this little color field over here and i can press on there to easily change the color all right now below this color field i'd like to have a blend mode option so that we can change between linear blending which is what we're using currently and discrete blending or we just have these discrete blocks of color so let's go into the custom gradient script and i'm going to create a public enum called blend mode and this is going to have two options for the moment linear and discrete all right and then we can have a public blend mode variable and in the evaluate method down here we're going to say if the blend mode is equal to blend mode dot linear then we will return our interpolated color here then if the blend mode isn't linear we can simply return key right color now we are going to have to change this if statement and for loop a tiny bit for that to work properly we basically need to split this up into two separate if statements so and this one will check key left and then in the second one we can say if key is i dot time is greater than or equal to the current time then key right is equal to that key and we'll just remove the minus one from the loop there all right now we never want to have zero keys so let me just quickly remove this condition up there and to make sure that we don't have zero keys right at the start when a new gradient is created i'm going to make a custom gradient constructor here and by default just add one key with a white color on the left and a key with a black color on the right okay so that should work nicely but we do now need a way to set the current blend mode so i'll save that and go into the gradient editor and below the color field we can write gradient blend mode is equal to edit a gui layout and we can use an enum pop-up i'll just call this blend mode and pass in the current blend mode so gradient dot blend mode now we'll probably have to cast this to the correct type of enum so just in brackets before this we can have custom gradient dot blend mode like so i'll save that go into unity and when this compiles we should see our little enum showing over here and we can change from linear to discrete but unfortunately this isn't actually working properly so let's go back to the custom gradient and i think what i need to do is just break once we found the right key so let's save that go back into unity and hopefully everything will work properly now so the linear interpolation is working fine and discrete also seems to be working well all right the next thing i'd like to do is just add a little toggle here to determine whether or not new keys that are added in are added with a random color so let's go into the custom gradient script and i'm gonna make a public pool called randomize in color and then in the gradient editor we can say gradient dot randomized color is equal to editor gui layout dot toggle and i'll call this randomized color and the value will be of course gradient dot randomized color like so okay then in the input method where we're adding a new key we're already calculating a random color here but then we can also calculate what i'll call the interpolated color just by saying gradient dot evaluate at this keys position so key time let me just have these both in the same place so i'll just cut that and put it below that and then we can use a little ternary operator here to say if gradient dot randomized color then we'll use the random color otherwise we'll use the interpolated color okay i'm also quickly going to come down to the on enable method and here i want to set up the size of the window so we can say position dot set and i can keep the current x&y coordinates or just see who's positioned or x and position dot y for those and then for the width i'll say 400 for the default width and i tested earlier like 150 works quite well for the height share and then we also set a minimum and maximum width and height just with these men size maxsize variables so these are vector twos and say new vector2 i'll make the minimum width say 200 and we can just keep the height fixed at 150 perhaps so max size equal to new vector to maybe just make this 1920 by 150 all right the very last thing that i actually want to do is in the on disable method we want to mark the current scene as dirty so that the changes to the gradient actually get saved so we can do this by saying unity editor and dot scene management and dart editor scene manager dot mock scene dirty and then we want to get the current scene which we can get from unity engine dot scene management dot scene manager dot get active scene all right so safe that you're into unity and let me try resetting this to make sure that that default white to black is working properly and here you can see it's opening up in my define size and i can change that from min to max and now with randomized color off you can see it's interpolating the color properly but it as soon as i toggle that on we now get our nice random colors you can change to discrete and that's still working well okay that is pretty much everything that i had planned for the series so i'm going to bid you all farewell until next time cheers