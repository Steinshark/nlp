uh good morning everybody and welcome to my talk about lambadas the title is it's not as ambitious as you can see we are not going to tame lambas today we are just going to tame lambda's uniqueness so it's a bit less ambitious topic but i think it's not enough time in one hour to time lambdas it's an experiment this talk in that sense that i noticed it if i prepare too much for the talk then i'm going too fast if i don't prepare enough then i'm surprised by my own slides so i try to hit the sweet spot and we'll see how it goes this time let's first talk about what this talk is not about i mean let's let's define the terms right so it's not about functional programming despite the fact that we are you're going to hear lambdas all the time it's not about type theory it's not about you know duck typing versus static typing or like empty versus bottom types or whatever we are not going to cover these things it's definitely not a metaprogramming talk no no meta programming this is not about it i'm not going to explain it i'm going to not going to lead you through this and it's also not about performance optimization i i mean i'm not an expert in it whatsoever we are not going to look into the code into the assembly or something like this you know so just you know what what awaits you so what this talk is about basically about this one right it's a clear statement of a problem that's how it works in c++ or to put it more formally it's about that two lambdas that are synthetically and semantically exactly the same and i really promise you there are no hidden zero wid spaces somewhere thrown into it in uni code exactly two same lambdas you deal type them compare them the types they're not the same right and there is a good reason for it and obviously and we'll come to it but it creates all sorts of problems right you cannot for example put a couple of lambdas that look almost the same i mean what what difference does it make where i outut my my strings into a vector it it's not going to work out of the box despite lambdas being the same what's even worse you cannot do things like like that one you cannot deal type a lambda and use this time type for example in your class to deare a data member it's not going to work because you know it's just this one unique lambda there and you cannot have another lambda even with exactly the same function type or corresponding function type and use it there so it's not going to work and as i said there are always good reasons for it and usually we can find those good reasons in the standard right so the good reason in the standard says that basically i mean it's not a reason but it's a kind of an exp explanation of the fact or a statement of the fact is that each lambda expression basically produces a closure type and this closure type is a unique class type also unnamed and that's it so the key word here is unique so to define the problem a bit further this is what you get if you write a lambda that does nothing and this is almost the simplest lambda you can get you could skip the the the the middle brackets right what the compiler really sees is something like not really your lambda but a closure so it defines a closure type that corresponds to your lambda expression and it might look something like this on a modern c++ 17 let's say there will be a default constructor in your closure type and then will there will be a function call operator that does pretty much nothing you write another lambda next to it and again a closure type appears notice the key difference the names there are different names different types right no matter what you try there are different types you cannot exchange them or use them exchangeably this is not the ideal situation and many languages took a different way like if you look at c or java or python or python is duct typing but let's say talk about strongly type languages like c or java you can use lambas exchangeably it's not a problem but they hide it be behind interfaces in c shar they don't do sorry in c++ they don't do it there are solutions as many of you are aware there are luckily plenty of solutions right to the problem like for example simple lambdas behave quite well and by simple lambdas i mean non-capturing lambdas if you have a non-capturing lambda you can just put a plus in front of every lambda and if they have the same function signatures no problem whatsoever right it looks weird and if you if it's the first time you see a plus in front of lambda that i understand the confusion i was also confused when i saw it but basically triggers conversion to a function pointer right so nothing else if you decal type such a lambda with a plus in front of it what you will get is a function pointer with the corresponding signature or with the corresponding type so it's a function it's a it's a pointer to a function that takes string view and returns a void great how does it work under the hood well something like this so when you write a lambda that doesn't capture anything it can be directly converted into the function pointer so let's introduce a simple function pointer type and alas declaration so it's a bit easier to comprehend what's going on and and somewhere in this closure type there will be a conversion operator to the function pointer which will be returning a static function pointer because you need a static function to to to be able to convert to a function pointer right if you have like a member function that's no go that's a different beast so there will be some static function defined you don't see it obviously it's not like all of the things really are there but let's assume they are there and what the static function is doing is something very simple it's creating a default instance of your lum or sorry or your closure type and calls the function operator on it a function call operator on it so nothing really special happens there something you you know easy peasy everybody can understand what's going on this also kind of works when you introduce generic lambdas to the mix kind of because this doesn't work doesn't work because it's a generic lambda so it cannot be directly i mean it can be converted but now there there is a problem with type deduction for the vector the vector doesn't know what what really want from it it cannot deduce the type because the types of the corresponding function pointers are not matching especially the last one there is no function pointer yet there is only a a function template right somewhere inside this lambda in inside this closure type but you can help the vector just define the type yourself type it strongly with the time argument and you're done and in fact you can skip the pluses now because they're not needed anymore right so you can get rid of them and still it's just fine it compiles it works out of the box so that's fine that's those are let's say the easy situations are those are the situations we know how to work around where it gets complex is when you start capturing lambdas are very often capturing lambdas and they're not behaving well and in that sense sense that whatever you try now it's not going to work whether you put pluses minuses or whatever i mean add zero even to it it's not going to work and the reason is that once you try something like this you're going to get an error which basically tells you that there is no match for the operator plus anymore and no match for the operator plus you know you have to interpret the errors of course if you are in c++ simply means that you cannot convert it to the function pointer anymore there is no conversion to the function pointer so the plus doesn't work out of the box why not well it's it's it's purely like okay it's not hypothetical because but that what might happen in the compiler right when you capture something you can imagine then when you try to capture something into the lambda then your closure type will have a corresponding member variable of the same type as you capture it doesn't have to work like this but it might be great there will be a constructor to which you have no access of course but you can imagine there is a constructor that takes this an argument of the type that you capture and initializes the member and now the big question is what do you put in the static member function what do you put as an argument to the constructor in the static member function there is no default value that you can come up with right so this cannot work simply you cannot provide some discon verion to a function pointer just because of this so this doesn't work and i mean it's it's good right it's good because we don't want function pointers anyway right you don't want to declare a reference to an array of function pointers that takes a string and return nothing like this because your c++ persona shakes when it sees it and and that's correct that's a correct response to something like this so we don't want function pointers anyway what we want is our c++ code code that's clear that's simple that's it doesn't have pointers everywhere and weird types so let's dissect it one by one let's imagine a scenario or let's take something like this as a scenario that you have three different lambdas very simple lambdas or at least one of them is a very simple one we know how to work with it right it converts nicely to a function pointer no reason no problems whatsoever another one that captures something also doesn't do much right captures a stream and outputs something to it and the other one that's a bit more complex it captures by by move actually right so it moves an output file stream into the lambda sorry for it that's my voice problems and drinking doesn't help so we'll see it's mutable by the way because it has to be mutable whereas streaming something to the output file stream and changing the file stream and and now we have to think about what we are going to do with it how are we going to deal with such lambdas or this variety of lambdas that seemingly should work together but they don't the question you have to ask yourself then is what am i doing with lambdas or what happens to my lambdas and there are couple of answers right and generally speaking you either pass them to functions or you put them into containers or generally you know pass them around or you put them into containers so there are two scenarios that you have to consider one is the easy one the other one is not so easy let's start with the easy one and this is passing to functions because when you pass to functions you have options there are many options and the number one options which should pop to your mind is just passing through a function template so instead of using functions switch to templates we love static taping we we basically like static polymorphis because it's a form of static polymorphism right when you declare a function template that accepts an arbitrary lambda and you're done and there are many ways to do it you can for example pass by reference which is not such a bad idea considering that our last lambda two logs is a move only lambda you can only move it so let's pass by reference it works out of the box you can also pass by copy if you want doesn't really matter then you have to of course take care that you do it correct corly and in this case it means that this lambda has to be moved into the function because otherwise it's not going to really work and you're kind of done with it there is no other magic to it i mean it's going to work out of the box whatever you do you might hit some you know corner cases but still no problem whatsoever there is another option c++ 11 came with c++ standard function and you can use st function for it right so st function is a a type erase type which drs another cable whatever the cable is it can be a lambda let's use it it's similar easy basically the code almost can go with no changes as compared to the previous one the only difference is instead of having a template a function template now we have a normal function but we have to maybe predefine the type or make a type alas for the readability right some something like this it's a function that or any cable that returns nothing and takes us to string we are good to go so let's go with a small exception or actually a compilation error it's not going to work because s function requires that your type is copy constructable and this lambda is not copy constructable it can be only moved into something right so even despite the fact that you are moving it doesn't matter state function works only on types that are copy constructible luckily if you are on a compiler and a library that supports it nowadays we have move only function which you can use instead and which respects some things that the st function didn't respect even like the con propagation for example a b bit better type if you ask me if you move only function everything works no problems what ever the code will compile and no surprises will await you so we basically have two options either pass by template or pass by st move only function or st function depending on your needs how do they compare because you know you might have heard some gossips that st function is not efficient so let's see how they compare for different benchmarks or four different simple benchmarks the baseline the number one is just you know calling a couple of lambdas so we define 16 lambdas there are easy lambdas on purpose all of them work on long long don't perform any complex arithmetical operations some of them do capture some of them do not some of them mutate the captured values some of them do not doesn't really matter what matters is that generally speaking those lambdas are extremely fast to execute so there is even no division in them so the benchmark the baseline is lambdas and direct call to lambdas the second benchmark just to compare is functions with exactly the same bodies as the lambdas which we call also directly and then the third and the fourth benchmarks are the corresponding things that you've just seen so one calling through a function template or cing through an intermediate st function or st move only function for the benchmarks i was on linux with the 6.2 kernel and i think tiger lake processor i don't know i don't think it's really revalence this in this case but let's keep it like this and unfortunately i couldn't measure it for msvc because msvc was uh protesting about my other things that i'm going to show later on so it couldn't quite deal with some code and and then it would be incomplete so i'm only comparing clank and just see the baseline is 1.0 so it's 100% and you can see that actually as long as you're using templates are good most likely because you know lambdas are con expert by default if they can be con exper and then you pass by template your all your code is going to be inl optimize away it's going to be blazing fast why passing by by template by copy is even faster than direct lambda calls don't ask me it's not an optimization talk i didn't look into it but the lesson to be learned is indeed calling via the st function is awfully slow you lose a lot of performance and you know might be important if you have thousands of lambdas here we only had 16 of them let's move forward because there is another issue that's of importance like what happens when you put lambdas in contain ers this is a much harder issue than just passing around to functions or passing lambdas around and for that one let's expand a little our let's say zoo of lambdas we have very simple lambdas this time we have lambdas that have exactly the same body notice that those two lambdas share the body in a way they only differ in what they capture and then we have the lambdas like we've had before so a lambda that's that's a move only lambda or a lambda that's even not really following your interface in a way right so it takes two different arguments instead of just one as all the other lambdas and with this one we can build you know a nice 2x two table so we have different situations like your lambas might have the same signature different signature same body or different body depending on this there are different solutions and and actually the easiest one is the same type signature and the same body because if this happens if this is your case you can just use a factory i mean obviously you cannot do something like this like what you can see on the slide it won't even compile right you cannot put those two lambdas that have exactly the same bodies they just different in the captures into the vector won't compile but what you can do is create a a very simple factory like this it's a lambda factory right it returns lambda this lambda the make output it can be also a function but notice that make lambda is not a generic lambda or not a function template it's just a simple lambda so the one that's being returned there is a unique one it's a totally unique lambda one of them and only one closure t which generated it's a basically a haug of how to pass different arguments to this non-existing constructor of a lambda this will work out of the box if you do something like this no problems whatsoever you are done for a bit more complex things like per perhaps you have things that or lambdas that capture by move or by copy and especially by move i think by by move is is the worst one here you might tried different approaches because this code won't even compile now anymore and the reason being this vector is initialized from the state initializer list and state initialize list items cannot be removed from so and we have moveed only lambdas right so this this is this is a problem luckily you can solve it either using the old approach which i don't have it because this uses iterators with some deal type or if you are on a fairly modern compiler you can use ranges for it create like a container of your streams and then transform the container of streams into the into the container of lambdas and you're done it's going to work it's really going to work the st s ranges two only works on msvc nowadays but you can write this function yourself or this this view adapter i think it's a view adapter right or something like this so kind of problems solved at least for the very very simple case when we have lambdas that share the body shape the type signature the other one i i mean i included it only for the completeness because it's really no problem if you have totally different lambdas where the differ in the signatures doesn't matter if they have the same body or not we all know the solutions there are design patterns for it right you just make some adapter for it and you're done you adapt one interface to another interface so it's it's really not an issue i would say so imagine like this lambda is a good lambda right it it has the correct type we are good to go but this lambda is not a good lambda it has an incorrect signature or text incorrect arguments you just drop it into another lambda or whatever you want and you adapt it to your interface and you delegate the problem to your colleague basically because once you've done it your colleague has to deal with this problem like we have same type signature and i mean function type signature or the corresponding function type signature and different bodies and we want to put them into a container right we cannot use templates i mean there there is really no unfortunately there is no trick to do it with templates at least not easily but we can use of course the old good solution the st function or the st move only function function right that will work out of the box type eraser no problems whatsoever so let's do it let's do it let's put our lambdas into a vector of st functions i mean obviously not st functions because now i have a lot of move only lambdas so we have to use move only function but it's going to work you don't have to worry about it you don't have to do anything special it's going to work it's going to compile and it's going to do what you intended to do let's benchmark because you know benchmarking is the is the source of our wisdom about how good are things going only three benchmarks this time and the first one is still the same as previously so you know it's still my baseline benchmark in a way that i'm calling the lambdas directly because the compiler can apply lots of tricks then especially clank is aggressively doing con expert so calculations in inline all those lambdas right so that's great the next one is basically introducing an array of function pointers so i convert all my lambdas and those are kind of prepared lambdas because i told you some of them are capturing and you cannot do it so i made sure that they didn't capture they did some other tricks to re reference other variables but what's going on here is that i i have an layer of indirection i have an array of function pointers instead of direct calls to lambdas and finally my third benchmark putting or using the stood move only function and calling the lambdas one by one and by the way i'm using google benchmark for it so i think that yeah a detail but that's what happened okay the results as expected it's a disaster in a way right uh it's a disaster because we are introducing a lot of indirection you can even see i mean clank is still kind of okay right it's it's not that bad but gcc is doing a very bad job and you can even see the slowdown in the array of function pointers it comes from this one level of indirection then instead of inlining your function the address of the co col has to bel loaded and and it has to be c right so that's that's costly operation all those calls returning stock adjustments and so on slowdowns are horrible and you can actually see as especially in the clank case that there is some slowdown because of the array in direction and there is additional slowdown because of the st function it's like almost a factor of two that it's going even slower so what's the reason the array pointer in direction is quite clear right that's the penalty we are paying the other the other penalty we are paying is things that happen under the hood in the st function or stood move only function there might be a hip allocation it's not there by the way are very simple lambdas but what we do is we are either getting virtual function calls or some function pointer in direction because of the type eraser okay just a quick question who here ever implemented a type erase type type that's great that's great for those who haven't don't worry you will will be able to if you haven't heard the talk yesterday of cla because he was talking about type eraser there are two slides about type eraser 101 it's the simplest form of type eraser used for cbles that you can make in my opinion because you know i was ambitious i thought that the implementers of the standard library kind of screwed up with the st move only move only function and i can do it better i was hopeful at least i implemented it in total i think if eight different ways of type erasing even relying on undefined behavior and the simplest one that is easy to show is something like this so there is an in place lambda a structure that will rope a lambda expression what it has inside is a storage for lambda because i have to store the lambda somewhere it's a fixed storage no heap allocation so i have to limit of course my lambda size and then there are two pointers one to invoke a lambda and one to destroy the lambda you have to take care of destroying the lambda because you own the lambda you will construct it in the storage and you have to invoke it so there are two pointers and notice that both of those pointers if you look at the types so so how the types are defined are taking the pointer to our storage as a function argument as the first function argument so this is a type eraser piece there is an operator for calling which basically forwards the arguments to the lambda in the storage and there is a destructor that calls the distruct and that's all i mean that's not all because you also need to initialize the destruct and the invoke and nowadays that's fairly easy i mean before before lambdas it was really not that heap let's say to do it nowadays it's fairly easy you just write a constructor that takes an arbitrary lambda and in initialize the invoke pointer with a lambda expression that's automatically converted to the function pointer it's not capturing lambda so you can do it it takes the pointer to our storage and then basically casts the storage to the lambda type that we are aware of and passes the argument to it for destroy it's roughly the same it takes the pointer to the storage casts the storage to the lambda type and calls the destructor in it which basically means we only have to create the lambda in the body and that's all right so we are creating really constructing the lambda in place into the storage of bites so i was ambitious right i said i was ambitious and that's that's actually the fast implementation i made relying on undefined behavior didn't pay off but this was the fastest implementation so that's the benchmark number four and i quickly learned that standard library implementat us are smart people and all my two weeks effort went to nothing so that's not the way to go don't do it generally speaking this especially the st move over only function is really fast you hardly can beat it maybe in some special circumstance stances st function is a bit slower this one you can beat but st move only function and this is the benchmark of the st move only function it's a slideware so the not the full name is mentioned there it's faster generally speaking don't go this way so what's the solution i mean obviously there must be some way of doing it faster right because otherwise i wouldn't be having this talk three questions mark what can you do about it what we really want is is at least what i would really what i really wanted to have is something like this this kind of syntax that i can for example create a container of functors with the same signatures like in this case put them in and then maybe call all of them let's say for the beginner just call all of them and as a result i expect to get a st array or st tole doesn't really matter right what i get just some result with the calculations so that's what i want and the the way to it is actually not that it's quite bumpy so so let's go through it remember when i told you in the beginning that this talk is not really about meta programming right yeah don't worry don't worry that's unfortunate side effect of working with this kind of things so it's static polymorphism so there will be some parameter pcks showing up but we'll try to get through it slowly who remembers overloaded here yeah it's a favorite type who was shocked when he or she or they saw it the first time i was shocked i i didn't understand it so overloaded is a fancy type that's comes with st visit and with with the tupal right so we can have a visitor pattern and call us to visit only tup and pass the overloaded to it and it will visit your your tuple or variant sorry variant how does it work well it works kind of easy there is an overloaded it's a class type and it inherits from multiple other types this is what the three dots do right so i inherit from some ts and since i am most likely inheriting from things that can be called i also expose their function call operators all of them those this parameter pack means that i am exposing all of them i'm using all of them there is also most likely like a deduction guide for it on the older versions of c++ needed that basically tells you that if i am creating an overloaded from those types please instantiate and overloaded of those types that's it otherwise the compiler couldn't figure it out before right and that's all it allows you to create all kind of code like for example this one an overloaded of two different lambdas with totally different function type signatures and confuse your younger colleagues with code like this right obviously it prints down answer is 42 because first we call the first lambda then we call the second lambda and that's what you get cool stuff to do cool stuff to to work with but we can put it or bring it to a higher level there will be types and ps a lot of them for those of you i i think most of you are familiar with the pack right but this is a parameter pack it means that can be multiple lambdas and that's not the end of the story you're going to see a lot of it because i will be using multiple lambdas so i need parameter packs a lot the other one that you're are going to see a lot is something like our uh parenthesis arc dot dot dot this is a way in c++ or communicating that i have a function type basically that returns r and takes arguments arcs and that can be many arguments you can also see a closure of it's a concept and that i use quite a lot to kind of constrain what's a load with my container so it's not a very complex concept it basically checks whether i'm really dealing with a class type that has a function call operator that has this signature and nothing else so i have to make sure that it's there and with that being said we can move to the functors and to the implementation of the functors how would you do it and how it fares on the on the seas of performance unfortunately we need a bit more than just overloaded so first of all we need a primary template you can see it up there right template type name do do not struct functors with no definition it's needed because later on we are dealing with multiple parameter packs in in one template and that's not that's only allowed for template specializ specializations so we need a primary template somewhere and then you need to specialize it a disclaimer it's also needed because your lum as can be mutable or not mutable right and a mutable lambda means that it's a non-const member function that you get an unmut lambda the default means your function call operator in the lambda is const you should be distinguishing between those two i'm not doing it because it's slideware and that would explode the number of slides so i only take the easy case or my lambdas are by default like mutable i basically kind of neglect the constants of lambdas exactly the same road that stood function to actually and that's why it's bad nevertheless you should do it and that's why you also should have template specializations the next step is obviously constructing right i'm using the concept here so i'm constraining the types that the constructor can take to only the closure types that are acceptable for my r and arcs and then the body is pretty simple i mean this is this is kind of the whole constructor i just need to initial i the base classes nothing else i am noticed that i am inheriting privately from lambdas you are allowed to inherit from closure types so the only thing you need to do is initialize your base classes and you do it like this you just forward the lambdas to the base class constructors you're done and because we are building a container and every good container has a size we are going to put the size there by using the size of dot dot dot lambdas it returns basically the number of lambdas that we are kind of storing here right it's a storage it's a hidden storage great unfortunately because it's a we are dealing with multiple parameter ps arcs and lambdas we also need a deduction guide it's not going to work without it and specifically we have to tell the compiler that when we are calling the constructor with some lambdas passed into it the type that it install iates has to be something like what you can see on the right hand side there are two meta functions used there a forbidden word i know i promise i wouldn't be using them but it's a meta function one that basically picks up the head of or the first element in the lambda list because i need to pick it up and the other one that deduces the type of the functional operator from the lambda expression so it picks the first lambda in the lambda list and and deduces the type i need it because that's how i instantiate my structure functors and then the lambdas with this beautiful piece of code we can already do a lot specifically we can do something like this i mean it's not really much because we could also do it with overloaded just with much less code but it's needed for the functionality that we're are going to implement later on and if you deal type it you are going to see that there is the functors of void string view so this is the argument type and the return type and then decal type to see out deal type to log okay the next step every single container should support adding elements to it right so we need a push back function because otherwise yeah what's the use of it if it's like fully static fair warning it's still partially static we are talking about static polymorphism so you cannot fully make make it fully dynamic and you're going to see why or how in a moment push back takes more lambdas no surprise there because i can push back more than one lambda at once obviously just for the fun of it so again it's a function template you cannot do it anywhere anyway else let's say so we protect ourself against let's say foreign lambdas that don't adhere to our interface and the return type of it will be obviously unfortunately a new type so we cannot just at lambdas we are going to create a new type that's that's that's the only solution to it because notice that we are inheriting from lambdas which means that our new closure has to inherit from old lambdas plus the new lambdas that we are putting to it so it's going to look something like this that's what we are returning that's yeah static polymorphis unfortunately the once we know what we are returning and the only difference is that we are actually adding the more lambdas to the pack right nothing else in the functors the implementation is pretty trivial then first of all or second of all we have to forward the lambdas that we are pushing back to the constructor of the functors and first of all we want to make a copy of the lambdas that we already own or that already are there and the copy is made by statically casting ourselves to all the lambdas that we have and expanding it right so that looks pretty much like this more of this coming unfortunately notice this one who knows what this means like just rise your hands yeah it's not a very common feature like of c++ it basically means that this function will be called or this push back will be called only when my factors i am calling it on is an l value right so why is it needed well because sometimes i am transforming types i want to destroy the previous instance and i want to destroy the previous type or sometimes i also cannot just make a copy you know some lambdas are not copyable so you cannot make a copy of it that's why you overload something like this for the r references this push back will be called when the functors you call it on is an r value and the only difference or the substantial difference here is that now we are moving our current lambdas that we own into the new instance or into the new functors i'm only showing how it works when you move because that's the interesting part so imagine that we first construct these two funs with two lambdas into it and then this crucial part this is basically casting the existing two fun to an r value reference and we push back a new thing and we obtain a totally new type so you have to assign it to a new variable that's kind of a restricting factor but hey that's the static polymorphis for you this will work now the important question is how do you call this thing right because you cannot just call it like with overloaded you you you cannot do this this is not going to work all the lambdas have the same function signatures this is an ambiguity if you try to call something like this so this is not going to cut it you have to bake your own version of calling and let's start with the simple example so calling all the lambdas because this is kind of something sometimes you want to do it like invoke everything that's in your container one by one that's easy and started with the very easy case so i i try to walk you through it through the steps of how it's been done i'm taking the string view not the arguments and i only inherit from l one lambda so that's that's a bit easier that's the starting point first of all you have to tell the compiler that you want to use the lambda and the lambda function call operator you inherit from so you have to cast yourself or your current instance to the lambda that's easy and then you pass string to it and that's pretty much the whole implementation of it if you have a string view and inherit from one lambda but this doesn't end here like first of all we have multiple lambdas not just one which means that we have to do something like this this is an expansion or a fault expression over comma basically what it will do it will call all the lambas one by one there is also this matter of having the string there string view instead of arguments so let's fix it more parameter packs and notice actually there is a design decision i made which might not be the good one and i going to keep it like this i'm always forwarding the arguments might be a bad thing depending on on your use case especially if you're moving from those argument in your first lambda already so i'm doing it like this here because forwarding is not only used for for moving my i mean there are escape roots from it you can have an argument proxy for example to solve the issue of of moving things out no problem anyways this this works like a charm especially if your return type is a void so you have to protect yourself because if your return type is not a void it's something else then you put another overload for the operator when r is different than void and then you just return an array and inside you call all the lambdas this is solved this works now and is it good we'll see in a moment you don't want only this one i guess you also want to be able to call lambdas like any way you want right so you might want want to add onto it with something like calling individual lambdas that's doable but we need an extra function that's i'm not going to go through this function it's a get function that basically returns you a reference to the i lambda that you inherit from so you can directly call it it's a helpful little function right it uses the end type t which picks up the end type of lambdas so we can nicely cast to it and return the reference to it it's easier to call so i'm going to use get a lot because it simplifies code now important thing to remember it just returns you the it lambda or actually the custard version of your current instance to the it lambda reference with this one the rest is easy peasy i mean the calling of any lambdas notice it's again a function template we are still in the static or template territory there is no other i mean we are going to come to it later so what we do here is something like first of all we can take either one i or multiple or i followed by is so multiple indices you might call one lambda or you might call it multiple lambda and you specify them by indices so you check it with if con exper if there is only i passed to this template then it's easy you just cast yourself to the it lambda forward the argument and return it you're done and notice i am only doing it for the cases now where the return type is not void i'm not going to cover the other one anymore in the second case well there is not much difference besides lot of dots what you returning is an array first you cast to the i lambda because this is the first i that you want to get and then you cast by expanding the pc again to the rest of the lambdas and it works like a charm like you can do something like this you want to just call zero and second you're done benchmarks because that's important right so how our newly baked call operators perform especially calling all the lambdas or calling some of the lambdas and by some of the lambdas i actually mean all of the lambdas but one by one right so because that i have to call all the lambdas anyway to compare great they actually do quite okay much much better than st function right you can see that there is like negligible increase in the per i mean decrease in the performers for clank and actually for gc it's also not that bad assuming that it started much better than clank so it's great and now i hope that you cote me on on a lie because i promised you something different that i delivered i basically can do this right but that's not what you wanted really we started with something like this we wanted dynamic fully dynamic dispatch we wanted to dynamically tell which lambda to call at the run time and what you are having here is not runtime this is compile time you have to at compile time decide which you're going to call and that's not always the scenario that's not always the use case right sometimes you just want to do something like this is it possible well there is there is some piece of bad news let's start with the bad news so imagine that you want to just have like f e something like your index access operator right and call the lambas the bad news is the signature or no this is the good news let's say the the first line of the function is pretty easy it's just a function call operator and that's the end of the good news so we are taking an index to the index operator the bad news is that this one actually it's still not the bad news it has to return a lambda because it has to return a cable right we are calling what this one returns so let's use a lambda for this that's going to that you can call on and now the bad news you cannot just do this you cannot just do this one you cannot use piggyback on the get function that we implemented before and the reason is well it's not usable in the as a constant or in a constant context right the i so you have to do something else luckily there is a solution you just use something like this and your problem is solved it works right and with this let's go to the bench no joke let's talk about the invoke map so because this is basically the magic right that happens under the hood you cannot directly call the lambdas but the best next thing you can do is is basically bake out your kind of on dispatch array or something like this at the compile time the whole idea is that this invoke map is an array of the size of your lambdas obviously that inside will have ways of calling your lambdas so it will have like for example 16 elements and each element will call the corresponding lambda notice that i have to pass the this parameter to it right that this as the first argument to it because otherwise it's not going to work the invoke map itself is quite easy it's an array of function pointers that take a reference to functors and the arguments and and that's all the implementation is horrific but i'm going to show it very quickly nevertheless and so let's do with the easy part let's start with the easy part somewhere in the middle because you want to construct a a map of invokers that will be like returning the static cast to the end type of i i mean is lambda so there is some index happening inside i am casting the self which is the reference to the functors to the i lambda and then calling the operator on it that's the easy part the rest is really horrific because this has to be red into a lambda expression with a pack expansion because i am creating a lot of those lambdas inside and there is most likely another lambda on top of it because i need an index se sequence and as i said it's not a meta programming talk so i'm not going to explain the details of it take we can talk about it later on and finally we generate the index sequence the giz of it is it creates like a dispatch array right a static dispatch array for that that calls or your lambda in any way you want and you can use it and it will work with this really it will work you can even extend it to something like this because nowadays we can pass more than one argument to the index access right so you can have something like this is implementation actually it's the same implementation that you've seen before for the static one variant of it a very similar one so you take an index and more indices if there are no more indices we just return what we returned previously you know a lambda that under the hood calls the invoke map and otherwise if there are more indices well then we construct it like a big invoker that can call all the lambdas that you mentioned all of this works and and now the big question is how does it perform right because it's really important and again there is a good news and a bad news and you are going to get both news together together and this is the news right so clank automatically is able to optimize everything away i don't know how it does it because there are multiple level of indirection i think it does it because it's all con exper basically st happens at compile time clank is amazing at it gcc not so much on the other hand notice that actually you are winning a lot on the gcc in all the other cases only when you're really using this like dynamic index dispatch then you're back to the performance of st function so it's not that bad right generally speaking you are winning in many scenarios can you win even more can you use something that will make it a bit faster the answer is yes you can i'm going to back move back to it notice that this is a costly operation like each time i using the index access some lambdas are created under the hood and returned to you so this at run time costs a lots of time you can cach it in a way you can cach it by creating before you go there some kind of invokers and you can do it statically which is not that interesting because the static is already fast so you get like an invokers to the zero and the second lambda for example and you just call it and you can do it dynamically you can get invokers by passing dynamic indices to it and it will return you an object that you can reuse multiple times but it already contains all the lambda which are expensive to construct so let's do it the implementations are actually very easy this time because there is nothing there we are just basically forwarding our calls to either get is for the static case or to the invoke map so it's returning to the lambadas that can be called later on it's in a way the same as our index access operator just named differently and this this will make it work and there is again u actually now it's only a good news when you use something like this either in the static variant static polymorphis or compile time variant or the dynamic variant you are going to see winds i don't know how but clank is becoming faster than direct lambda code don't ask me it's i repeatedly did it i think it's just doing more con exper calculations under the hood so because remember i was doing the long long so that's the reason but also on gcc we are winning a lot of time if you know or if you can cat somehow what you are going to be calling later on you have a win of at least three times as compared to the st function version which is a lot right right this is like a three times win still a bit slower than direct lambda calls but we are now in the acceptable territory and of course for clank it's it's like magic right all of the sudden it inlines everything and don't ask me i i looked at generated assembly and i gave up because it we i mean yeah we don't have that much time right so and so that's it that's the last benchmark you can see basically the takeaways you can program something like a lambda container that will work with lambdas that will be faster than any solutions that you can directly use in the state library thank you with this and that's the end of my talk so thank you for [applause] visiting and there is time for questions yes so i've done something similar really good talk by the way before i say anything else thank you so have you tried or have you thought of that you can convert a pointer to a member of a base class implicitly to appoint to a member of a derive class yeah so when you derive from a bunch of lambdas they all of those function call function call operators are implicitly convertible to a member of a derive class so you can just hold those in an array i haven't but thank you for the t so that will that will clear away all of that stuff you can just make an array of it i like this slide you can make i was proud of it so but but i i will try it thank you for the tip yeah like it it will all be conex for if you do that okay yeah i will try it then and try how it works hey really cool so the gcc problem let's call it have you tried making the function that creates the array const eval instead of const exper it won't work well just the oh the one that creates the array no i haven't cuz it is possible gcc i have i have okay it didn't help didn't really help so unfortunately didn't hi hi hi thank you thank you for the talk very very interesting so this container is still kind of static yeah if you want to have it also dynamically re move things move lambdas into it dynamically or remove them are you back to function or is there maybe some trick maybe you can type erase the contain there are tricks to do it but they're very ugly you can hide the whole container be i think that i came to the conclusion that the only way to do it is hide the whole container behind a type erase type again okay okay and yeah exactly and then it's kind of doable and how it fares against the container a bit worse but then you're still a better off than because you only have one in direction for all your subsequent calls in a way so if you do it smartly but it's really ugly i i don't like it so okay okay thanks so we have one question from the internet have you any comparison benchmark on compile times no it no but it compiles fast on my machine so no but that's a good one especially if you have lot of those right so it might be interesting one day i will try it for sure so thanks again and have a good lunch i would say