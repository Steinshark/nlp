all right so i guess we're going to use arc instead of vec i'm not really sure what's happening here but this feels wrong i don't know let's okay let's find out youtube hey have you ever considered subscribing to logan smith maybe you should give him a subscribe then hit him with that thumbs up pound pound him the thumbs up boys i just said that as an intro to one of my youtube videos i'm getting canceled i'm literally getting canceled today talk about why you might consider using arc slice tea instead of vecte as a reasonable default of a rust code okay now this is i'm just saying right now i'm having a very hard time understanding what's happening i mean i understand all the underlying principles i just don't know why i'd want this over this but okay i'm just gonna guess i'm guessing up front it's because arc you can point to some sort of region so you have this beautiful thing right here right it's beautiful it's wonderful okay you just follow a pointer to a region which i don't see how it's any different than following a pointer to a different region that's what i'm confused about is like isn't it still the same amount okay i'm missing some sort of indirect point enter somewhere i bet you whatever vec of t is doing i'm missing something right i'm missing something and now i'm i'm just stupid that's what's happening just a bit so arc slice tea can be a really good choice over vecti for immutable data so if you build up a big sequence of data that you then never modify again after that you might consider arc slice tea it's really good for data that you're going to be storing instructs or arrays or collections or just generally passing around i'm not talking about a vac that you collect real quick as a local variable in a function or just that you use for some quick scratch space something that you're going to be storing for a longer period of time you might consider using arc sliced i have to know the reasoning because when you pass around an arc you gotta like clone that and cloning is an atomic operation that has to be more expensive than anything else you're doing i'm just so curious i must be missing something i know i'm missing something but by i just want to pause it for a second can we all agree this animation is just very sexy t and especially for data that implements clone now this shouldn't be a huge surprise because clone is kind of the superpower of arc which we'll talk about shortly here it's also the superpower of untalented rust developers am i right am i right it's just absolutely untalented rust developers i also use clone just throwing it out there i'm untalented just in case you're wondering but if you're going to be cloning big immutable sequences of data around all the time arc can really really speed that up [music] now you can do even better than arc slice tea you can use box but we'll talk about that at the very end box me daddy so why am i recommending this well there's three really big reasons the first one we already touched on so arc has an extremely cheap constant time clone so it's true but it still can be expensive no matter how big your sequence is that you're pointing to it's going to take the same amount of time to clone it and it's just going to involve increment printing an integer and mem copying the arc pointer itself which is very very fast and it doesn't involve any memory allocations which no but it i mean to be fair it's an atomic increment and when you drop an atomic pointer to it you're also doing an atomic decrement am i right on that so technically everywhere there's a implicit drop you're also doing an atomic operation and everywhere that you call clone you're doing an atomic operation well i mean if i guess it's just like what what what's the what's the trade-off what's the trade-off you're trying to make like do you want a bunch of atomic copies and copies and drops like increments and decrements in in like very hot hot path code probably not atomics are pretty cheap they are cheap in some sense they're still what is it like hundreds of instructions compared to copying a whole vector yeah i would agree with that compared to copying a whole vector but let's let's see what happens okay sorry i'm not letting them cook i see him put one one little one little ingredient in the dish and i'm already just like what the hell's this meal ain't nobody just eating onions okay sorry it does sorry so this is a huge optimization that you can get very very easily just by switching over to arc slice t another reason is that arc slice tea is only 16 bytes it only needs to store a pointer and a length unlike a vec which needs to store a pointer a length and a capacity we call that a girthy pointer okay some some people tried to call it a fat pointer but we all know they call them a girthy pointer okay the real ones know it's always been a girthy pointer you know we've all wanted a nice girthy pointer in our language and now we have access to one they can get 24 bytes now that's only an eight byte difference it's not huge but if you're storing lots of these things especially in a struct or in an array that extra memory can add up and it can decrease your cash locality and it can make it harder to walk a big series of these things and then lastly the third reason is that arc slice t implements d-ref slice t just like vec does so you can do all of the same read-only stuff on your arc slice tee that you can on your vecte you can ask for its length you can iterate over it you can index into it and this is really important because these first two bullet points are cool but i wouldn't necessarily go out of my way to recommend them if arc slice tea was way more difficult to use than vec is but it's not because it implements draf slice t it also implements a bunch of other traits that you're probably going to want and it makes it so that arc slice t is really just a drop in replacement for vecte in many many circumstances it does feel very very nice in the sense that if you've ever used any sort of arcing like right yet the arc of semaphore also it just feels good just feels good you know y dot rc that's what i want to know why not rc i'm very curious about that because arc means you can pass it between threads but if you don't need to pass it between threads why arc why not rc is rc analogous to using arc in this specific case there must be a reason why arc over rc or no mention he says you should use rc if you can or even box okay so spoiler alert at the end so these first two bullet points are nice performance gains this third one means it's basically not any harder to use arc slice tea than it is vecti so you might as well just reach for it first so i've been talking about arc slice t versus vec i'm actually going to spend the rest of the video talking about arc stir versus string okay which is the exact same dichotomy it's just a little bit easier to talk about and a little bit easier to think of examples of but everything that i'm going to say about arc stir versus string is going to apply directly to arc slice t versus vec now i also want to mention that anytime you're using arc you should always try and use rc first if you don't need the thread safety that arc gives you i how do lifetimes work with this with this how does that work if you have a because obviously there's some underlying string that has to exist and then you have this but you don't have a let the man cook i know i'm just i'm just curious okay they call me betsy clarius okay i just have a couple questions here by the way reference if if anyone gets the reference i'll be incredibly impressed but i'm just curious how does how does lifetimes and all that get figured out with this i'm just saying arc here because it's the most general version of the advice you don't you don't allocate a stir a stir is just a reference to a string you always have to you you always have to have you got to have you got to have a lifetime associated in some sense with these little stirs so i'm just curious how does an arc work with the string i know let the man cook shut up but if you can get away with rc you should definitely try because it has lower overhead than arc now i also want to clarify okay good he did say rc okay great okay i'm on team team rc team rc people find something else i want to point out that i'm talking about arc stir not arc string arc string actually has some of the same upsides as arkster but it also has the very significant downside that you need a double pointer indirection in order to actually get to the data that you care about which is your character data i'll show a visualization of this at the end but arc string is just generally kind of clunky and memory inefficient and do you understand why string is like a vector right so you have to follow the vector is a is a big old girthy pointer and so you're just having a girth pointer to a stir and so if you have a pointer to a pointer you don't really want to do that you don't want to do a pointer to a pointer right this is just a pointer to the thing right so it's less girth it's not a good the girth my js brain doesn't understand double pointer indirection yeah too much girth you want less direction is going to be really bad for performance so i do not recommend using that i'm talking about arc stir the power of rust's wide pointers is that we can point an r you just call them wide pointers okay i've never heard the term wide pointer i'm not going to lie to you i've never heard the term wide pointer i've heard fat pointer and clearly girthy pointer but wide pointer that's that's a that's a whole new one for me i've never heard wide pointer put wide shaming i'm just saying it's a wide pointer thick pointer i want that thick pointer arc directly at a dynamically sized character buffer out on the heap so let's say that i'm working on a game and i have a type in my system called monster id and under the hood is just going to be represented as some text and i want to use the string type to manage that text for me okay so the first thing that i might want to do on my monster id struct is derive a bunch of traits i want to be able to clone this thing around be able to print the debug representation compare it hash it i also want to use it to do some serialization and deserialization maybe from a configuration file or just from some save data so i want to slap all those derives on my monster id struct and i want it all to work and that will work with string next i want to have a method on my monster id struct that just grabs the underlying representation as a string slice maybe i want to log this out to the console maybe i want to use this for analytics somewhere so i just want to access the underlying data as a string slice and that's pretty easy to do with string next i want to have some configuration data somewhere and this is going to be a hash map of monster id to their stats you know you gotta clone it out though and it's going to be keyed on monster id which is why i needed to derive eek and hash and this all works just fine with a string as an underlying data type you just say mellifelous tones and a grasp on pronunciations and and terminology i just do not have i have never once called it eek i would just i've always just called that equal i never once even thought about just calling it eek which is you know i mean i can i can see why we've arrived to this conclusion and maybe i feel a little stupid thinking about the fact i've never done it yet i'm just saying it's just something that's never really landed in my head if he does say mutt i am gonna just rage quit this video i'm just gonna shut this video clean off clean off okay i'll go oh yeah before you go oh well you call char char not car obviously character character char oh you don't help with your little pronunciation there tough guy hey guess what hey guess what okay this is my world i get to choose my own inconsistencies okay i don't like mutt hands down hands down don't like it don't want to like it not gonna like it next i want to store these things in a big list of all of the enemies that i've ever spawned okay notice that i'm using vec here because this is going to be something i'm going to be appending to as the game runs and i'm probably going to be cloning monster ids into here and this list could get fairly large and it's going to be a bunch of these monster ids sitting right in a row okay okay next i need some kind of functionality for creating an actual enemy that i'm going to use in my game based on a monster id so i'm probably going to be cloning monster ids into this function maybe cloning monster ids into the enemy instance so that each enemy instance knows which monster it is and lastly let's just say i'm storing some stats in a b tree map that's my monster id to the number of times i've destroyed that monster throughout my gameplay session and i'm just using b tree map here as a different type of that poor monster just keeps getting destroyed over and over again you're telling me he has to get destroyed repetitively what kind of weird ring of hell is this game that he's designed at least give a fresh new life a chance an opportunity to run around just just destroying the same one over and again this is painful data structure then hashmap and we can use monster id as a key in a b tree map because it implements ord so here's a handful of different use cases there's probably more this is just an example of how a basic type like this can start to proliferate throughout your entire system and you can start needing to clone it around all the time you can start needing to store it in all these different data structures and suddenly the cost of those operations starts to matter it starts to add up so let's look at the cost of cloning this around i do want to take a moment here this is you know that this is the whole argument of pessimized code often you find that things are just kind of slower and clunky but you can't point to any one problem and it's one of the hardest parts especially when like navigating through javascript libraries and and javascript applications is that they can feel slow they can use a lot of memory but there's it's not like there's just one spot that's like ah look at this this is the one spot in which you use all the memory right like it's like no it's just evenly happening all the time everywhere you know what i mean it hurts and just the the overall memory footprint of this when we use string so here's how string is represented so the actual string data in string is represented the goblin deez nuts oh god adam as a character buffer that's out on the heap and string allocates enough memory for your text obviously but then also it allocates a little bit of extra space so that it can grow without needing to reallocate so here we have goblin with four extra bytes of spare capacity these nuts to the in case the string needs to grow anymore although we know that it doesn't because goblin is already a monster next the string struct itself is made up of three eight byte words a pointer a length and a capacity now the pointer just points directly at the string data the length refers to g-o-b-l-i-n so it's six and the capacity includes that that's so stupid i'm sorry i don't know what's wrong with me but i can't help it if there's a possibility of a deez nuts joke i'm sorry i just can't like leave that opportunity up to chance okay you can't just toss out a goblin without it okay i mean come on i mean you even had four characters left you could have been like we could have penned to the string d-e-e-z oh my goodness you could have hit him with the d's right there just meme on the kids okay you just just meme on them so good extra four bites at the end so it's ten so let's look at what it looks like to clone a string so first we need to clone the entire character buffer so first we need to allocate more memory and then we need to copy over all the characters which is linear time operation in other words it takes longer the longer your string is then we need to create a new string struct on the stack and point it at the new character buffer notice that this time we shaved off the extra capacity because strings clone isn't going to over allocate it's going to give you an example oh cool i didn't know that buffer so we just have this extra spare capacity of six which isn't really helpful to us right now because it's the same as the length okay and if we want to make another clone we have to do the exact same thing we need to allocate a new buffer copy all the characters over once again and then create a new string struct on the stack that points at it and again we have this extra capacity field here that's not really useful to us yeah so hopefully you can see that this process of allocating new memory which by the way is very expensive is a little bit cumbersome and the strings trucks are just kind of large and overly bulky just for the simple purpose of talking about goblins just want to talk about goblin deez nuts okay okay okay i think we i think we see some of the issues here i think we see some of the issues here i don't know how fast or slow allocating more memory is and generally it's considered slow but it's you know it's usually the cash misses because you don't know where this is gonna go you can't really guarantee adjacency and all this kind of stuff so i i get that i i understand the general reasoning what's the same situation but using arc stir instead of string i'm still curious about this restaurant we start out with some heap data that looks different so first we have these two eight byte words one of them is a strong reference count the next one is a weak reference count and then we have our actual string data so this already looks bigger and kind of strange but don't worry it gets better so our arcs on the stack are just a pointer and a length they're only 16 bytes because they don't have that extra capacity field that the strings had so it's just pointing at our reference count out here and let's look at what happens when we clone so all we have to do is copy that struct that's on the stack and increment our how do you initialize an arc stir i guess i've never really played yeah i guess i've never really played with one of these i don't know this whole strong and weak business because if they're strong and weak already within the stir why do i need lifetimes unless i get the reference to the stir i don't i guess i don't have any idea what a stir is now that i think about it i've never looked at the underlying representation of a stir because i've only ever used it as a reference oh that's the arc okay okay that makes way more sense i was i i was having some emotional difficulty getting over this because as i was wondering why do we have weak and strong references doesn't this add like a whole run time to dropping stirs but this okay okay this makes more sense reference count so now it's two you notice we didn't do any kind of stir is a verb arc is a noun don't come in here with english okay you know you already know english is like my second language right but i got a question for you are you a strong goblin or do you weak goblin just saying just saying you weak goblin on these kind of memory allocation we didn't do a deep copy of our string data we're just referring to the same string data in two places now so we can very very cheaply make clones of this and the fact that the string data is shared between multiple arcs also increases the chance that it's going to be in cash when we look it up because it gets loaded into cash anytime i use any of these four arcs to read from it versus this does that mean that this pointer to read the thing out of an arc it technically does a pointer plus is that correct it does a pointer plus two u sizes to read whatever data is that what draft does i assume draf just goes pointer plus size of view size times two maybe makes it probably makes that a constant so you don't have to like do a multiplication every single time you want to de-ref something and then throws it in there probably is my assumption strings where the memory that they're pointing to would only be in cash if i had already looked it up recently using that specific string so you can see that this whole thing is just much lighter weight these arcs themselves are smaller so more of them can fit in the same amount of memory and frankly this is just a much smarter use of resources for our immutable string that we're passing around through our program also these two extra words that we're paying for on the heap are divided among can we just take a second here and say that monster id was a bit confusing here just a knit you know do let's do a little knit here monster type might have been a better term here because i'm over here thinking you got like some uuids or some some sh out there and i i wasn't understanding what was happening i was confused every single arc that we have so they're kind of amortized we had to pay for an extra word for every string that we used on the stack these two extra words that are on the heap yeah two is more than one but they're shared among every arc instance we set the same thing much less at the end of the day than that extra word that each and every string had to carry along with it okay this is good though this is a great explanation looks like it feels like if we just plug arkester directly into our monster id instead of string so first of all all of us i literally don't know how to initialize a stir work exactly how they did you can clone an arcster you can debug print an arcster you can compare it you can hash it yeah you can also serialize and deserialize it although you do need to activate a survey feature in order to do that just because who's going to be the first person to write a macro to create a derived macro so i have to quit doing this who's gonna do that who's gonna do that for me i want my own derived macro that derives the proper derivings that i just want give it to me all derive i just am tired of typing all the things right i don't want to type at all i don't want to macroception i don't want that there's some minor small print that you want to read if you want to do that but it's survival i want all of you so all of that still just works like it did this function does not need to change at all because arcster implements d-ref stir just like string does i still don't know how to initialize an arc stir can somebody tell me how to initialize an arc stir i have never stirred in my life i know how to string how to stir no no you can't just say from stir i don't know what that means okay how did you get the stir okay but that's a static reference i don't want a static reference i want a non-static reference does this only work when when you have a a compiled in string into your program because that's my whole thing is how do i do a lifetime right i have that's the only way okay see that no okay that emotionally hurts me okay can you do that can you do a from string for arkster i don't believe you hello or no see that no no that's cheating this is cheating that's not what i wanted i don't think you can do this he got i really don't think you can do this because you need to be able to do a lifetime on this thing and there's no way it can point to something like that right because as sir i don't think so try it you try it i had to like get a rust program up do i even have a rust program rusty arduino rust typescript russ do i have anything with rs okay there we go let's go like this oh my goodness oh let's go let foo equals string from hello world all right there we go and then let's go foo arc foo equals arc from let's see foo as stir now notice here's the deal it's not it shouldn't work it's not gonna work and this the it's simple because what comes out of aster is not right right what comes out of astoria see you got this problem here see because you got a reference you gotta you got that thing you got that that thing's going all effed up i don't know what to do here i don't know what to do with this but something's wrong i'd have to i'd i i know it's going to be more difficulty because as stir is a reference to a string it's not the stir can i can i can i star that son of a bee see then it's just like yo i don't know the size of this thing what's the size i don't know what's the size i don't know so is it purely just because you're you're actually just going like this let foo equals here foo is a static string hello can i just do this foo wait what parque maria what do you mean parque maria oh i need one of those huh can i like star it how the hell how the hell do i get this thing i don't know how to use one okay arc stir equals foo into i got it first try i knew i'm a genius i knew it i knew it i knew it i knew it i was better than everybody here i could just feel it i could feel it can you can you shadow that thing or does it drop it all funny no it doesn't nice look at that thing go look at it go look at it go it's so good yeah i'm pretty much a genius pretty much prodigy programmer here you can just take a reference to it and return i still don't know how to do with the string though i don't think i can deal with the string i don't think it's i actually don't think it's possible doing it with this right i okay first try genius people genius okay i truly actually don't understand how this works real talk i don't understand how this works because how does the drop work how does the drop work on stir does stir have a drop function that clears up the memory i'd have to look into the into implementation to understand what's happening but i don't think i can classic look at that that feels good look at that implementation inline that once you inline that right now inline it just put it in just put that in arc does open that and that turns into a reference to a string slice so nothing about this function needs to change it all works perfectly you've convinced me to never use string again and clone out rcs honestly this is kind of wild this is kind of wild that you can do this i flabbergasted okay flabbergasted next what about our hash map of monster id to enemy stats well our monster id struct still implements eek and hash because arc stir does there's that eek again okay hey i don't i don't know if i like it i'm not gonna lie to you and so nothing needs to change here and in fact i would argue that this is way more appropriate to use arkster for this because string gives you a lot of apis for modifying the underlying string but you can't modify a hashmap key because you might break the invariance of the data structure so representing your key using an immutable type like what arc stir gives you is much more important than using string okay yeah my vec of monster ids is going to be much more cash efficient now because i've shaved off an entire word from each and every monster id and is two-thirds the size that it was before my function for creating an enemy is that true i don't think that's true it's not two-thirds the size that it was because you still have the string i guess it's two-thirds the size for the pointer cost two-thirds the size for the pointer costs and that's that okay that's inside of a monster id is probably more efficient now because i imagine this involves some kind of cloning of the monster id which is much more efficient now that we're using arc yep and then lastly our b tree map is kind of the same i wonder if that's true i wonder is there a is there a size of string that's better to clone is it always better i don't know because arc is still i mean it's fast it's like fast but how fast the hash map it's just more appropriate you know using immutable data as our key type because you're not allowed to modify the keys in a b tree map anyway and this feature map is going to be more efficient now because it's storing data that's smaller and doesn't have to pay for the cost of being mutable when it doesn't make sense for it to be mutable it's not copying the data correct but it is incrementing an atomic integer and so that that that costs something also every single time you drop it there's an inverse cost as well i would assume dropping a string memory is less expensive than dropping a string memory with an it with it with a with an atomic counter as well right i don't know i i'm just saying i don't know this all seems to make sense in my head right but intuition about what is fast and what is fast they often they're different they're cats versus dogs okay ah this feels fast it looks fast on paper it's fast what happened it's slow right it's just like using an array versus a set a set by all by all measures just looking at it on paper instant access to anything you want feels faster but is it faster well it really depends really big depends going on there so arkster wins in all of these examples it's more efficient and it's a drop in replacement so why not just use it i'm curious if that's true i would have been hinting at but i'm going to say explicitly is that vec and string are for modifying buffers of stuff they're for pushing and popping and extending and trying are they are they you'd have to have a mutable reference though they're not technically there's nothing that says they are for or aren't i mean generally you set something up because you have an unknown shape so they are mutated for some amount of time but there's nothing that says that they're they're strictly for for that it's designed to be it's designed to have the ability to i don't know if it's telos is to be mutated can we say that can we say that i think one of its functions is mutability but i'm not sure if it's telos is mutability just throwing it out there locating and if you don't need that stuff don't use them because they have some extra cost that's associated with that so all of the methods on vetcon super interesting you notice that all of these methods take a mute self yeah so they're all about modifying the buffer and mutating it and changing the shape of it and you can have a non-mutable string though right right like we go back to this thing this guy's not mutable right i can't mutate him now obviously i could turn them into something that's mutable but right now it's not mutable right unless if i explicitly say it's mutable it's it's not mutable just saying if you don't need any of these features then don't use that constraint if you just need to look at some data and say ask for its length to see if it's empty index into it iterate over it split it search in it does saturday work with jess on like this i'm actually really curious the saturday work with just on for this because one could argue if you copy a lot of jason would it be nice to swap out these things and use a different type of copy like right you could imagine a bunch of rc stirs as opposed to strings is it better i don't know saturday is malware stuff is provided did you not see their shipping binary and then the guy detolnate didn't care about it despite him actually making my life easier and hundreds of crates and to use the single most prolific contributor to rust altogether he decided he wanted faster compile times and shipped down a binary and that's when we all knew he was actually the faustian bargain handing us something that looks good but at the end will be nothing but malware you know maybe maybe not you know maybe he was just trying to make things faster okay maybe maybe the guy was just trying to make life a little faster he came up with the clever idea and got wrecked by the community is it terrible that he got wrecked by the community i mean i think that it was a bad idea so i'm happy that he got checked i think the more funny part is that one week ago what a sponsor wear or whatever that weird virus of software that went into mock the the library for testing they just got done shipping binaries and everyone was like whoa we don't like big spider [music] surprise edition right and they're complaining about being spied on and all that and it was very funny timing that one week later after everyone losing their about a binary someone else is like hold my beer we're gonna do the same thing except to rust the most authoritarian language of all time everyone will be happy with this one bam so good sliced tea both of which you can get at very easily through an arc and so you don't need the full power of string and vec if you just need to look at some data and you can gain a lot of performance by not paying for string and vec if this is all you need so that's why you might want to use arc slice t over vec or arc stir over string now i do want to show off arc string because i mentioned that it was bad and this is why so arc string starts off the same way as string buffer with some spare capacity but then we also need to put yeah this makes a string itself into an arc so you see we have those extra two words at the front for the reference count and then the string stuff after that and r is going to be pointing at that string and cloning it is going to yeah it's going to clone the reference to the string because we see that if we wanted to get at the actual text that says you'd have to jump these nuts do the string and then jump from the string to the goblin and this whole thing these knots thing is just kind of cumbersome and awkward and this is why arc string is not a good idea when we can do much better lastly i mentioned that if you do not need to clone you can do even better than arc by using box stir and this is essentially as good as you can possibly get assuming you don't need to clone so this does not have any extra spare capacity this just allocates something out but by the way he i mean i know he mentioned it in such brief passing he really should have mentioned a bit more about why i use rc over arc like if you don't have threads to send something to what's in the box what's in the hypothesis what's in your packages what's in the hobbit's packages real talk it feels like the whole thing should have been an rc and then just assumed to be an arc if you need to send it between threads i'm just saying the heap points to it and knows how big it is right so you you cannot do any better than this but when you clone you are doing a deep clone of that heap data so that's going to be a memory allocation and a linear time copy but if you're not supporting clone you can't do any better than this in terms of memory efficiency so consider boxster if that's your use case so that's all i got that's going to do it for this one let me know what you think thanks for listening and i'll see you next time that's great logan that was great that was really really really really interesting i'm actually a little bit shocked that i you know that this i guess wasn't more talked about earlier on and kind of some of the things i know they kind of talk about these things but i've never put them all together very very interesting stuff i really like that logan you make an amazing video i think anyone that's watching it go subscribe to the guy fantastic high quality the name is the goblin these not the gen