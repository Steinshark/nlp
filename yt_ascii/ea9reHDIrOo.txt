this article is probably going to describe a lot of us in this chat okay and and you know what we're not going to feel too good about it no this is not rick i don't think this is brad and i don't think this is tom i think this is you so let's find out you know this face that this ai made that's really creepy and kind of disgusting somehow i make this face regularly this uncanny impossible face to make i make that face pre-read called it after 25 years of my career i came to understand that one particular type of programmers is the source of many problems in our industry here is the story of a project that was nearly destroyed by two such programmers who is it who of you did this one of them was leading frontend development to the other back end while the rest of the team was slacking off because business requirements were in the works these two chaps were working hard the front end le bootstrapped an angular monor repository with nx rx oh why would you choose it why would you choose it oh my goodness you know i can already see the problem coming you know the problem is is that you guys just don't understand the beautiful nature of functional reactive programming okay you need to think of time like an array okay it's an array that you select over time shut up and other trendy technologies at the moment the corporate environment did not lend itself easily to nx but he pushed hard to solve or circumvent infrastructure's problem by working with the domain expert he set up a workflow that while having angular as the base framework bore little resemblance to the official angular tutorial prime loves rx don't let him say otherwise oh i love it please give me that functional reactive goodness okay i was using rx when it used to be called select and select many not map and flat map select and select many the backend lead was no less motivated to bootstrap the spring boot project according to the corporate guidelines while adding a bit of personal touch in the form of the vav library and highly sophisticated higher arch of jpa entities with multiple levels inheritance discriminators and generators you know nothing nothing nothing like a good oldfashioned whiteboard masturbation session that comes out with multiple levels of inheritance like nothing feels better than being able to hit that whiteboard and just ejaculate levels upon levels of classes nothing feels better it is it's pinnacle it's pinnacle programming now some of you are going to say bas i'm going to say based ab it's abstract it's abstract based class you wouldn't get it you probably wouldn't get it you guys are probably over there programming hll telling me how great your monoids are i don't want your mon mons bro okay i don't want your mons you can go end or [ __ ] off okay he then sprinkled it over with hierarchy of validators based on booth spring bean validation and third party validation framework and polished with trendy testing framework hasal mentioned let's go that's always the takeaway hll is just the worst language whoa someone mentioned hll cool yeah hey i love hll hey everybody i'm a h cool guy hey anyone want to talk about a little bit of little lamb to culus with me we can discuss some of the merits of why modules being endo funter actually make a lot of sense when you think about the funter i i can't even i can't even give a good impersonation cuz honestly i don't know [ __ ] about functional programming okay i don't have the words i don't have the lingo all i know is your function that's partially applied will only ever be partially applied by you that's a maiden joke by the way months flew and the business started spewing requirements as best they could the empty shells of both back and in front end were already too complex for team members to work straight on business requirements so both development leads worked hard to split business requirements into more manageable technical tickets while doing most of the grunt work along the way each of them worked harder than the rest of the team combined again does this again is this not just management issues 101 like if you come into a project and a bunch of the people cannot reason about the system and then only the two leads can reason about the system at like what point do you say yo we got to get rick to figure things out here because this ain't working out then suddenly the front-end lead quit for for kener pastures i hope they love angular and rx nothing nothing is better than when some jack ass litters your whole goat base with rx and then you got to go debug it you're like dude why is this thing what what where's this function even coming from going to play the game of like go chase the stacks oh so good the business brought it an expert front-end developer who managed to keep on delivering for a while then another one who lasted a bit longer junior dad kept underused the load on the back end lead was ever increasing he spent long days and even longer weekends delivering what seemed to be simple crud interfaces but they were so convoluted on the inside that little could be done to alleviate his workload by the way whenever you make an abstraction and you find that every time you do something simple and it's exceedingly complex it's always because you got too clever to begin with this is a tale as old as time just program like you're you're an idiot you're stupid it's okay be stupid be like the rest of us and just just be stupid don't be clever don't come up with some cutesy way to generate all the greatest things you've ever done and don't worry this is super flexible and abstract no you're too dumb i'm too dumb john carmack's probably too dumb to do it too it's okay just make it simple one dimensional solve the problem at hand don't solve tomorrow's problems because you don't know what they are and you're not that good at it anyways that's the secret i'm always stupid that's funny i'm always wrecked a few months later the backend lead quit as well and the team continue to work at a snail's pace under the ever increasing pressure from the business to meet the deadlines the quality of code was failing to point that vy objects were used in null comparisons and angular typescript was randomly intermixed with plain js at the end the team barely delivered a product full of bugs the futures looking bleak none is up to the task to rewrite the many thousands of lines of code produced by the initial lead developers turnover high costs are skyhigh you know i wonder how many times this has to happen before this like isn't a problem does every single manager ever either has to live on a project that this happens on or has to manage a project that it happens on before they don't do that again is this where rick started yeah he left earlier in the thing like is that the only way to ever learn from this is this just an evergreen source of just horrifying this does this description of software project feel familiar i didn't even read that and i highlighted it and then i'm talking about it it does for me as i've have seen probably a dozen similar projects in different industries from online media to public services the programmers i described are usually considered to be the best of us but i came to perceive them as the worst here is a non-exhaustive list of qualities of these people watch out for them ooh here we go here we go here we go here we go ability to find satisfaction in solving abstract problems interesting great math skills glorious le code profiles and an aptitude to solve crossword and compose puzzles are signs of a person can work on problems without real life utility they concentrate on the process not on the outcome i strictly disagree agree with this statement i strictly strictly hard disagree with this statement real talk right now apm requires us to build in a where is it a motion tree and to build this motion tree required us to be able to build a tree inverted and nonambiguous okay i think that's legitimate i think it's fine to have those skills you just have to know when to apply those skills here okay so i'm going to actually invert his argument i'm going to go way deeper if you don't have those skills and you don't know when to properly apply li them you are just as bad the only difference is that you make abstractions in your own madeup [ __ ] way as opposed to at least to some sort of standardized way ability to put up many hours of work one has to be healthy and dispose of large swaths of time that they can dedicate to work family kids carpal syndrome are all signs that you are not of their kind this is a crazy take i was following this article hard okay so maybe it's because he's describing me the ability to work long hours is probably some sort of cross-section between pass motivation discipline kind of like life requirement and genetics mild insanity potentially prime was rick all along prime was the rick all along to me this is kind of c i like working you know i like a good 60 hours a week that's a good good amount for me cuz for me for me to be able to learn and understand new things and to be able to get deeper into situations i'm doing i don't know just makes me it makes me happy passion and what the [ __ ] is going on in this list a bright and motivated programmer can always find a way to fit technology he enjoys at the moment inside a project that pays his bills business is dull coding is easy so why not make it slightly more enjoyable by dragging in the latest technology everyone is excited about moreover this will be yet another trendy item on the resume i love this right here i love this one right here i need to spend about 10 hours a week learning stuff or i start to really hate my existence kind of a lot dude this is me if i don't spend some amount of time just learning something i hate it can i try to invert what he's trying to say here can i invert this a little bit what i think he's saying all three of these points point to the same problem is that wisdom not the ability to solve a problem but the ability to understand which problem to solve wisdom is extremely important if you like working a lot that's fine if you like solving abstract problems fine if you have passion for software engineering and you like to learn about new things and best ways to do things as much as you possibly can i think that's a positive but if you don't have the wisdom to know when to apply those and not you you are a fool let me give you a quick example my previous project i wrote it in node because everyone said hey we got to do it in node hey we got to do it in these things hey we got to be using this hey it's the standard path it's all this kind of stuff we'll ended up being millions upon millions of events coming in that are encoded in json and which are done in node which was adding minutes of processing if not hours due to how slow node was well really how slow javascript plus how slow asynchronous operations are in node plus how slow like say a for loop i removed dot for each and replaced it with literally four let i equals whatever it took seconds off of execution time my mistake was i used the technology that was safe i didn't use the technology that i knew i should have used which was probably rust or go that was my fault i made that mistake i'm literally doing it again and guess what language i chose i chose rust because i'm not going to get boned again by node and javascript not being the fastest language when you are doing millions and millions of lines of processing is passion good yeah but wisdom is good too and i chose the right tool i believe i did choose the right tool for the job cuz i chose the tool that people could contribute to no one contributes no one will ever contribute to your tool i chose the tool that would work best with our ecosystem and it did except for i had to make a bunch of stuff that was plainly available in other things you know what i mean anyways okay narcissism and self-confidence ooh this is interesting this is probably related to the dunning krueger effect in that the worst of our kind are usually relatively young bright people in their late 20s or 30s they are consistently praised as overachievers and do not encounter much criticism you keep using the word i don't think it means what you think it means just in case we'll let it go one more time you keep using that word i don't think it means what you think it means can i be real with you guys i know that people often cite dunning krueger as thinking you're smarter than you actually are but i know that the meaning of dunning krueger is supposed to be different and i never remember what it is cuz i'm too stupid to remember and i don't think used it correct here people keep using this this to prove some sort of point and they almost always prove it's the exact opposite i know that i just don't really know what it was he even he didn't spell please tell me that's true please tell me it's two ends oh my goodness let's go let's go oh oh no oh it's so good oh it's so good oh it's so good to misspell dunning krueger oh my goodness that is the that is the greatest thing ever i i would say that from here on out i'm only going to misspell it from here on out i will only misspell dunning krueger it's the only thing you can do mandela effect shazam how not to handle the worst kind appealing to management does not work after all the management in business environment is usually non-technical and the worst kind are the best performers i've never wholeheartedly disagreed with an article more in my lifetime than this i mean i think we got a selection bias problem here selection bias being being that if you've only you you only get to work with so many people and that's going to color your perception of however you think the world of software engineering is and so i've worked luckily with a bunch of people who were really really good and they produced a lot of code and they did a lot of good stuff i at one point produced shitty code but a lot of it and i was i mean i was this person i just happened to be 21 when i was that person i still produce shitty code in a lot of it it's just that i usually make time and have a better idea of how to refactor it into something that's good you know what i mean i usually just only program shitty but put it behind nice module and then refactor when it's time and when i know it's time to refactor it and you know what second off it is literally management's job to make sure that this doesn't happen management's job is to ensure that a that a that a team can work cohesively together one high performing person when no one else can work with them isn't a high performing person this is like management 101 people who should the management listen to if not the best performers their performance is quantifiable and team spirit is not team spirit is very quantifiable how are you doing oh wow you're feeling really confused that's funny cuz jimmy and charlene said the same thing talking directly to the worst kind also does not work they listen and kindly respond to their critique of their engineering choices but the discussion of teamwork falls on deaf ears they cannot adapt their engineering choices to the least experienced team members just like some adults cannot adapt their speech when addressing kids so i've actually worked with the inverse of this i've worked with people who refuse to not use things that aren't widely used and that also causes a lot of problems in an in verse weird sense it's very hard to describe without being hypers specific and i do not wish to be hypers specific i mean i've worked with the opposite side where it's just like we will only use the things that everybody else uses that is the most industry standard and sometimes when you have a bespoke problem and there is a general solution out there or you can solve it with the general tool and it can get you half the way but at some point half the way no longer works well and you have to become bespoke to go all the way what can be done the first step to tackling this problem is to recognize it exists the second is to spell it out most software is written by teams it has to be approachable by every team member the third is to look around for existing ideas to tackle the problem surprisingly many contemporary ideas in software engineering can be viewed as ways to fix the problem of the best of us goang lua and other simplistic languages oo i do like those two languages quite a bit there is broad consensus that goang is simple to the point of being simplistic it is in a way opposed to rust as a means to an end and not let's see and not a subject of discussion golang team strive rust teams rust because the language encourages concentration on itself not on the outcomes of engineering projects it's just skill issues i will agree that rust takes more time to become proficient in i think we can all agree with that rust takes a significant chunk of time to become very proficient in but when i'm doing string processing and command line utilities you know what language i reach for first rust it's the best it's literally the best at command line tools node no shut up always js [ __ ] you nice rust is annoying with the unwrapping a skill [laughter] issue i have never seen such a you that was the greatest that was so good thank you for that thank you for that i i too used to think rust was really annoying with the unwrapping i had skill issues it seems so narrow though to limit it to cli tools yeah that's because that's where my expertise in rust is is in string processing and c tools it has an amazing iterator pattern from and options and results it's really good it can be really really good one largely unappreciated aspect of scrum is the interchangeable nature of team members oh goodness gracious what are we i feel like we're about to say something positive about scrum and i'm i'm i'm about i'm about to be sick well there are many specializations team members are expected to handle any task from the sprint they should lead to simpler engineering solutions which are at the reach of all team members oh gosh i have never felt a more opposite take in my entire lifetime sophisticated programmers usually work on niche environments it is relatively easy to be sophisticated spring boot programmer or a sophisticated c++ programmer that's actually called a normal c++ programmer like i hate to tell you this but if you can program any application in c+ plus you're already more sophisticated than 80% of web developers devops turns everyone into generalists configuring servers or cloud environments monitoring deploying setting up pipelines while coding microservices the sheer number of required skills transforms even the best of us into noobs fostering compassion towards less skilled team members let me get this straight i believe the take here was this hear me hear me out hear me out on this one i believe the take here was that having an environment in which you have production critical services on in which makes you occasionally feel like a noob makes you have empathy for co-workers who have skill issues did i read that correct my take is i'm a noob stop making me look bad i don't think chat gpt wrote this this is two novel of a take for chat gp i think somebody really believes that scrum is good and devops make you feel like an idiot therefore everyone should do it because that way you can have empathy i'm going to throw something completely different out there i think that you should do devops if you're passionate about devops i know point point up here about not being passionate i want you to be passionate about devops i want you to become really good at it i want you to be able to do your own kubernets if you really need to and guess what i don't want to hear about that [ __ ] yeah i can make a docker container you need me to make a little docker container not a big deal nbd i'll throw a little container together i'll use alpine linux i'll throw curl on that son of a [ __ ] but like real talk i don't want to know about any of that okay i want to hand you a docker and you make it you you make it go you just make it happen i don't think about ports i don't think about any of that i don't i i don't know what a node balancer does i don't honestly know how a node balancer works i don't know how it literally works i understand ideas about it and i understand strategies about it i understand that you really want consistent requests like that's one of the greatest things you could have as a node balancer is that when customer a makes a request and then customer a makes another request again it goes to the same machine because if you can have the same machines with the same customers you can actually get a lot of local cash efficiencies but how the hell does that actually work i have no [ __ ] clue and that's okay alta four he should be the devops guy don't make me the devops guy okay you know what i'm good at i'm good at going hey these are all the things that go wrong let's bring some order to chaos that's what i'm good at all i'm going to do is say the word structured logging nine times and then here's some open source sl bespoke tooling we need to create like that's all i'm good at scrum sucks ass devops should be done by people who like devops hot take cold take [ __ ] off i don't know which one it is but this is wild the name did you see this sweet hoodie extra life sent me a hoodie look at that extra life hoodie look how sweet that hoodie is a j