good afternoon everybody welcome to my talk about lambda captures this is my fifth time at meeting c plus plus in berlin actually the first fourth time i am presenting here the third time the talk is about lambdas the second time i have the privilege to do it with live audience because the tula stunts were obviously online and actually the first time i really prepared for it so hopefully it goes well i'm prepared often prepared the timing so i don't go over time and before i start i have a confession to make when i submitted the talk or the abstract for this talk i didn't have high hopes of it ever getting accepted i mean we are talking about lambda captures right if you list like five most boring and uninspiring topics in c plus plus lambda captures will be there you are guaranteed to have there but i made an estimation error the talk got accepted and it was well received so on one day i sat at my desk with the idea that i have to start preparing the talk and it occurred to me that i got myself into trouble we are still at the topic of lambda captures i mean after five slides you are done right there is nothing more there and i had to fill the whole hour with it i met an estimation error again i had to cut down the material and cut aggressively to fit it into one hour so with that being said let's start the real talk when i was doing the research for it and preparing it i came up with a set of rules and if you follow those rules it will be a happy capture first one and the most important one is that capturing is mostly about lifetime and i mean mostly not always i will show you why it's mostly or to put it in other words it's about making sure that the things that you use within your lambdas are within their lifetime an example that's an example and this is a recurring example you will see it a lot of lots of time it's a simple function the only purpose of this function is to add a record to some key value stores or to a database but it adds this record in a peculiar way it generates the key automatically so the function generates the key and it updates the data store using the key and the record provided by the user and now we have a problem how does the user know of this function or the keywords how can he retrieve back the data he stored in the database right there is no way to do it now you have two options here either we return the key back to the user or you return the lambda and this is the case when i decided to return a lambda it's beautiful right you return a lambda in in encapsulates the behavior of retrieving it hides actually the nasty details of a key that's how we should code that's how it should be done we are absolutely safe there is a capture default by copy it means that everything this lambda needs should be copied into the lambda no issues no problems whatsoever you test the code and you get this that's a lifetime issue that's one of the many lifetime issues that happen when you use lambda captures now before we really start talking about the captures we have to talk about what lambdas really are this is almost the simplest lamp down right a lambda it's a square bracket followed by parenthesis followed by braces that simply put a lambda the middle part is optional and there are a lot of other things you could put there but we focus on the basics a simple lambda can just take an integer and return an integer like like in this case it doesn't yet capture anything it doesn't need to capture anything we'll come back to captures in a moment when a compiler sees a lambda like this it does a kind of magic transformation under the hood that's known to some of you and some of you it is not known yet the compiler doesn't see a lamp down the compiler says like a shorthand for a function object and it generates a function object under the hood for you with and knowing a name that you don't know you don't have an access to this name but this function object has one crucial feature it has a publicly accessible function call operator with exactly the same parameter list as your lambda and exactly the same body as your lambda and this function collaborator is what is getting called when you later on invoke your lambda so your lambda is not really a lambda it's an object of some class type that's known as the closure type now we don't have yet a capture so let's introduce a capture imagine that instead of adding 42 you would like to have a 42 as an externally defined variable and you would like to use this variable within the lambda like so replace all the 42s with a k is it possible definitely it's possible now to put more context to it let's say that all of this both the lambda and our variable are within a function so they are local 12 functions are variables with automatic storage duration such a variable needs to be captured that's the only way you can actually have this k within the lambda so within your closure tab it's the only way your closure type can refer to it now how do you capture by simply enumerating things that you want within the claw within the capture list that's how you capture this is a simple capture by copy that's how it's known you enumerate what you want to use within your lambda and it has an effect on the closure type your closure type will get a private member variable of the same type as your original variable and it will be initialized with direct initialization there is no constructor involved whatsoever there is not even a constructor generated it will be directly initialized with the value of your original variable and now it's obvious you can use it within your closure type so your lambda can use the k there are other types of captures we saw a simple capture but the most popular ones are actually capture default like that one that you already saw saw on the second slide of this presentation a capture default by copy generally speaking it means copy everything that's needed into my lambda or into my closure type so i can use it and in this case both nna n and k will be copied implicitly into the lambda or into the closure tab whichever you prefer there is a capture default by reference and that's a tricky one or not a tricky one depends how you look at it it simply means form references from within my closure type or from within my lambda to externally defined variables you only form references you might actually generate member references in your closure type you might not depending on how the compiler optimizer thinks but it's by reference now simple capture 34 edition this is simple this is a simple capture by copy a variable is copied into the lambda in this case only one of them so this code won't even compile because okay cannot be referred from within the lambda expression and of course you can also mix those so you can specify that sum of variables i would like to for example have to capture by reference like k in this case and everything else should be copied that's the mix of a capture default with a simple capture so far so good are there other captures yes there are there are generally sculptures known also as init captures that were introduced in c plus 14 to introduce a couple of problems and they come in so many different flavors that it's impossible to feed them i think into one slide or even into 10 slides but the general guest is is that you introduce a new variable into your lamp down like in this case in the first case it's highlighted there for the lambda l1 a new variable m of reference type is introduced into the lambda and it will refer to the original variable answer so you can now refer to answer which is outside of the scope of your lambda through a reference named m another way to use init captures is actually to kind of automatically create new variables out of thin error so you introduce a new name like in this case it's again an m name an m variable that's referable from within your lambda and it's initialized with the value of the that the function returns that you call in the init capture so those are the init captures those are the simple captures the capture default and the init captures but there is one more important thing that we need to talk about and that's a function called operator that's generated for your closure type this is the last of the basic sync that we have to cover that we are sure that we're on the same page look at this one and it's again a recurring example there is a function with two variables defined in it a string variable and an integer variable now the idea behind the lambda is that it concatenate the string with the stringified representation of the integer but the integer is wrong it's 43 and it should be 42. so you have to decrement it and that's what that lambda does the lambda captures string by reference and a k by value the reason being quite simple strings are expensive to copy so you don't want to copy them right you form a reference to a string and we are good to go now one of the first surprises everybody who works with lambdas sees is that one if you try to compile such a piece of code you are going to get a compile compilation error that you are trying to modify a variable which is a read-only variable it's a closed variable why is that a const variable well the hint is in the function collaborator the function call operator that you generate in your closure type is const qualified by default it's a constant member function and a constant member function cannot modify a member of the object right it's impossible it's totally forbidden you cannot do it we have an illegal mutation here and that's actually what the compiler was trying to tell us there are two ways out of this situation you can either capture k by reference that's possible that would work right if you have a reference in your class you can modify the referent if the reference is not constant and this is not a constant reference so that's totally a load the other way which is something that's commonly done is basically dropping the const qualifier and you drop the cost qualifier so you remove that one by saying that the lambda itself is mutable this is different from the normal way things work in c plus plus in c plus plus by default functions member functions are non-constant lambdas are constant by default you have to tell that you don't want to have the constantness okay so far so good what about this one the same lambda expression it's a mutable lambda expression we capture the string by reference we capture the k by copy we form a copy within the lambda of k but the original k variable is constant it says normal local variable with automatic storage duration and it's constant will it compile who's for it will compile thank you i also thought so it won't compile it won't compile and this is a problem this is something that surprises a lot of people i i was surprised the first time i saw it and it gives us an important lesson before you even start working with lambdas please get familiar with the type deduction rules for captures because they are different than for any other variables any other scenarios that occur in c plus plus in this case or not in this case what we got was actually the last example but before we go there let's talk about those rules you can capture by reference and that's easy when you capture by reference so when you form a reference from your lambda to an external object everything everything is clean and easy you don't drop any cv qualifiers it's impossible if the object was constant and you form a reference to it well you just formed a reference to a constant object you cannot modify it now with captures by copy things are different you can either have an init capture or a simple capture and init capture works quite intuitively it basically works as if you defined a new variable with an automatically deduced type which using the placeholder type auto in this scenario it's quite obvious the cv of whatever your init was is dropped your var is not going to inherit the cv qualifiers it's impossible right it would be crazy if it did but if you use a simple capture or for the matter of fact a capture default the cv qualifier qualifiers are preserved they kind of tag along together into your lambda and that's strange and this is exactly what happens in this case when there was a const variable a local cones variable and we captured it using the simple captured the cv qualifier wasn't dropped we got a const member variable this is a trap and that's a trap that some people fall into now can you get rid of it of the cons qualifier as you can and the hint was already on the previous slide when you use an init capture the cv will be dropped so just use the c init capture and the constantness will be gone a small distinction but makes a lot of difference what's next what about if i want to do something different if my original variable wasn't constant and i want to make it constant within the lambda for whatever the reasons are is it possible now sadly i can already give an answer it's not it doesn't work this way whatever you throw at the compiler whatever you try to make this k into the constant k within your closure type it's not going to work you can try everything i tried couple of things the list is not excelsive there are more things you can come up with this doesn't work for example there were a couple of proposals which propose this kind of syntax it doesn't work it's not there you cannot do it you cannot qualify a capture any init capture you also cannot use a cast something that nico was talking about because in an init capture the constant the constness is dropped so it's not going to work the only actual thing that you can do is a workaround and it's an ugly work around but it works across the board for all the compilers you have to create a const copy of your original variable and capture it using a simple capture and then you're gonna get also a cons member variable now things work different for references for references if you capture by reference you cannot drop a cons qualifier i mean you can but that's ugly and you shouldn't do it right you can use of course the const cost to constable the constance but you shouldn't do it but you can easily add constance for referenced captures and the way it's done is again with an initial capture imagine you have a string like in this case there is a string and you really don't want to capture it by copy you want to capture it by reference and you want it to be a constant reference that's easily done that's easily done you can use an init capture for it now it's quite obvious you form a reference to a constant object using a cast in between but your reference will be to a constant object so you won't be able to modify through this reference now so far so good right those are the basics those are the basics this is how capture works this is how init capture her simple capture and capture default works then you might ask what next the the next step is to learn when you need to capture and when you need not to capture because there are times when you know don't have to capture or when you cannot capture so learn when to capture a prime example is that one we have a function it's a main function that defines an integer within it an integer answer with a value of 42 and it's used in a lambda expression and the lambda expression is quite simple the lambda expression actually the only thing that the lambda expression does it uses the value of answer it doesn't do anything else and it uses it to do some calculations right it also passes it to a function again by value do we need to capture this one who would capture it anybody some people would capture i would also capture it i i would maybe write something like this a capture default and actually it would work the problem is it's totally not needed you also can skip a capture here if you skip the capture the code will still work the capture is in fact not needed the reason is quite simple lambdas are allowed to read the values of constant integral object among other things but this is the prime example they can read but only the values and nothing else so is there is a difference whether you capture or not you might ask yes there is because when you use the capture default some compilers will capture the variable totally unnecessarily one of the compilers that does it is msvc nothing it's not to parse them as we see by the way and you will see in a moment why not it captures it and when it captures it it increases the size of the lambda it even gets worse if you as a simple capture so if you capture answer explicitly then all the compilers will capture it and and that's exactly what you will get an increase in the size of the lambda totally unnecessary now the situation does change if you not only read the value of the variable but do something else with it either directly or indirectly like in this case i change the signature of the square function now the square takes about not a value by a reference which basically means that your lambda indirectly needs to read the value the address of answer in such a case you need a capture there is no way out of it you have to capture it okay so far so good what else doesn't need to be captured well according to the standard lambdas can read also the values of cons expert objects or color concepts per variables if they don't have any mutable members and if you look at this code actually kind of both should work both the one with the capture the lambda with the capture and the lambda without the capture because we capture a const expert variable and we only need the value of this string view nothing else we never mutated we never take an address of it nothing like this now the first one works across the board the second one works only on the msvc and it has of course consequences it increases the size if the capture is needed the size of the lambda is increased to 16 bytes on most of the systems you need a pointer and the size right so it has consequences so msvc wins here when i did this slide i cheated a little because i said that the object object cannot have any mutable members a string view does you can mutate a string view there are two functions that mutated so i even wrote my own implementation of a string view and it still only worked on msvc one that doesn't mutate and doesn't allow any mutation of the members i must say that gcc is sometimes able to not capture such variables under certain scenarios but why and when it's still like dark magic to me sometimes does sometimes doesn't so that's const expert and that's basically integral variables is there anything else we don't need to capture yes there is there is one big elephant that you don't need to capture and those are any object with static storage duration and what i mean static storage duration i refer basically to any kind of a global object that lives in a namespace scope or any object qualified with the keyword static those are objects with static storage duration they are never captured and you cannot capture them and for this one let's go back to our original example right this is the one that i showed on the second slide of my talk where i had a function that added a record to some database using the automatically generated key and it was returning a lambda expression that could retrieve back the record and i said it's a lifetime issue it's partial lifetime issue it's mostly about doing unnecessary work why is that we use a capture default here right so you could say well i am safe i capture everything that i need there is nothing wrong that can go wrong with this code but surprisingly there is something wrong that go can go with this code this code can possibly crush your program the reason is under the hood it's hidden in plain view in a way when you see a lambda like this that uses a capture default you should look what variables are used within this lambda here it's a db context and the key then look where those variables are you can easily identify what the key is so you can be sure it's being copied but what is this db context where does it come from and if you don't know what the db context is then what is copied into your lambda is the db context really copied there or not now as a matter of fact the db context in this case is a member with static storage duration it's a variable with static storage duration it just lives in a global scope such objects cannot be copied into the labda cannot be captured by reference into the labda they are not captured if you don't believe me you can try to edit explicitly you can try to capture the db context by just using a simple capture and every single compiler will tell you it cannot be done and it will tell you in very harsh words by just stopping the compilation process and producing an error telling you that as object with a static storage duration cannot be copied or cannot be captured so if we don't capture the db context or do we capture only the key the db context is an external object with static storage duration now why is it bad it's bad because obviously all the objects that are global variables are bad and in this case the badness seems to be in the fact that somebody on some other threat modified the db context that you refer to from within your lambda totally ruining ruining your retrieval later using this db context is there a solution to it well there is a solution the solution is if there is an object with static storage duration and you depend on its state in your lambda copy it there is one way to copy such an object and it is by using the init captures it is fully allowed to do it you can make a full copy of something like this and store it into your lambda do it it will save you some trouble if you are in a situation that you have to refer to a global object how did we come here how do we count actually to the situation that we were capturing things unknowingly or actually we weren't capturing things unknowingly we came to this situation by using a capture default right there is a capture default there and it gives you this illusion that everything will go right that i will everything will go fine because you are safe it you cannot get any safer than this but this is only an illusion and contrary toward the title of this talk tells you never capture everything or do not capture everything or to put it in other words do not use capture defaults they are tricky and they will hide complexity and they will hide traps from you unless you of course are absolutely sure that you know what you are doing why not besides the examples that i showed look at this one it's again the same function we don't change the function the function stayed exactly the same now the only difference is that the db context now is not an object external object with a static storage duration it is now a member object of the kv proxy so far so good we can use it from within a member function so we can use it inside the lambda and we have a capture default now the question that you should ask yourself is the same as always when you see a capture default and we encounter an error what is really captured there is it like the key is it the kv proxy is it the db context what is captured there or maybe it's some combination of all of those right now in this case the last answer is correct it's a combination of some of those above and in fact two objects are captured the key and the current kv proxy object but there is a surprise awaiting our capture that we saw before the capture default is actually equivalent to that one so with two simple captures of key and the current objectives the surprise is that the key is captured by value but the current object is is captured by reference it's not captured by vario you only refer to it through a reference is it dangerous yes it might potentially create a lifetime issue like in a very simple scenario where you have a function that creates a local kv proxy and directly uses it to other record and return the lambda that this function the add record function returns in such a case you are up for a crash during the runtime of course why very simply when you create when you call this function a local proxy is created and it dies actually at the moment where this semicolon here ends and this results in a runtime error because your lambda that you got back refers to an object that doesn't exist anymore now i'm not saying that there is no solution to it there is of course there is a solution instead of capturing by reference you can capture by copy that's how you capture the current object by copy it's doable do it yes but the devil is in the details it's not as easy as it seems look at those two functions or two actually pieces of functions where we return a lambda one captures by reference y captures by copy so one lambda only has a reference to the current object tr1 has a full copy of the current object now the db context that the lambda referred to is not a local variable it's a member variable of the context that we captured in fact we can refer to this directly we can use the keyword this to signify this fact that the big that the db context is not a local variable it will work it will compile but it creates all kind of problems and issues that you are not that you might not be aware of if you ever capture this current object approach it with gaussian because it can bite you back and to support my statement i want to come back to very simple scenarios we have two structures exactly the same structures they only have one data member an integral data member cannot be simpler and both of them do have a function that returns a lambda and let's skip the problem with the lifetime on the left left hand side i know there is a lifetime issue there we capture by reference right that's possibly a problem ignore it for now because we actually refer to the surrounding object or to its copy in both cases we can refer instead of directly to n we can refer indirectly to n using the pointer this and the member of operator and it will still work but this is a kind of magic this which we are so used to this that always refers to the current object in any other context now can refer to different things it's like a magic disc now to add to it the lambda on the left hand side does compile and the code on the left hand side compiles the one on the right hand side doesn't and i mean when you look into it it's quite obvious why it doesn't the one on the left hand side captures by reference so you form a reference insert your closure type to an external object you still have a const member a const member function the function call operator and obviously it can modify a referend that's fully allowed that a legal mutation and we do modify a referend or a member of the referend right here now in the second case it won't work because we capture a full object by copy we have a copy of it inside and you cannot modify an object that's your member from a cons member function that's not how things work in c plus so this is not going to work you can of course solve this problem quite easily by adding the keyword mutable and things will start to work we'll drop the cost qualifier and it will compile but there is an important detail here depending on how you capture this that this pointer within your lambda and only within your lambda means different things and i know it's the same actually for simple variables with automatic storage duration whether you capture by reference or by copy you have different semantics but this is dangerous because we are so used to the fact that this always points to the current object it gets worse at least in my opinion it gets worse there are prime four methods of capturing the current object in c plus plus you can either use one of the capture defaults or you can capture the current object using the disk or the asterisk this now this is not how you normally would capture by reference and by copy or let's say this is exactly how we would capture by copy but not by reference for any other variable you would have to specify a simple capture in a totally different form you would have to be explicit about that you capture by reference not here there is something even worse lurking and that's this a default capturer capture default by copy captures automatic variables with automatic storage duration differently than the current object every single variable is captured by copy besides the current object this is copied by reference it's actually so bad that it was deprecated in c plus 20. so the idea is to remove it fully later in a language that's a trap and as i said doesn't matter how you capture and what you capture you always refer to either the copy of the enclosing object or the object itself through the keyword is and that's craziness and it will be even more crazy once the c plus plus 23 gets really properly implemented by and supported by all the compilers because lambdas then will start referring to themselves using the explicit object pointer that's been added with the paper deducing this to c plus plus 23 so you will have two different current objects within a lambda is there a solution for it yes there is a solution to every problem of course and i think the corre correct solution to this problem is to use init captures when capturing this we have init captures there were introduced for a purpose that will introduced to make better code and safer code look at this code it's exactly the same as before we capture by reference we capture by copy but now we do it explicitly using the init captures it's readable everybody knows what you captured how you captured and that one is a reference and that the other one is a full object that you copied into your lambda so it's quite obvious why the mutable is needed there right because you mutate your object now i'm going to go even step further and say that not only you might use this but in some scenarios you might go a step further it very often happens that your objects are big but your lambdas refer only to a part of it if you capture by reference it doesn't matter by why copy everything into your lambda do cherry pick what you need if you can cherry pick if there is a lot of data like this do consider capturing only things that you need that's easily done again using an init capture this is the only way to capture a member of the current object using the init capture otherwise it's not allowed do it and your lambdas will thank you for it they will be lighter tech legs less space and become more readable now you cannot always do it i would be lying if i said that you can always do it there are scenarios when it cannot be done and a prime example of such a scenarios where you cannot cherry pick a variable besides of course when you need all the member variables for the functionality is when your lambda calls some functions of your of the class where it resides in like in this case i don't have access anymore to the end directly instead i use two functions both of the member functions one does modify one doesn't modify the member variable so one is cons one is non-cons now in fact i could rewrite this code into this one and it would still compile so i need a capture and i have two options i azure capture by reference or by copy and if i were to follow my own advice actually it would be even better if i did it explicitly write this right so i would say with an init capture that i'm capturing by copy this code doesn't suffer from problems i mean part of this code doesn't suffer from problems and the other part does now the code on the right hand side does compile and the code on the left hand side doesn't and as always it has some something to do with constrapagation comes correctness that's something that protects us but that's also something that we need to be aware of notice that both functions make lambda are constant member functions which means that this pointer within those functions is a pointer to a constant right now when you use a simple capture like on the left hand side this constance is propagated so what you do is you capture a copy of a constant object and this is also a constant object when you use an init capture well this is not the case the constance is dropped and you can use it with references of course it works a bit different neither of those pieces of code will compile the reason is when you capture bireference whatever means you use the constance is not dropped you form a reference to a constant object and and that's the end of the story and the only solution is actually to drop the const qualifier from the mic lambda function be aware of it because it really sometimes gets you those ugly errors that you will never understand cross propagation also works when you capture the current object this now if i were to follow my own advice that i was giving you about how to capture and how to write proper captures for the current object i actually should write a piece of code like this right in my original example when i had the key value proxy i shouldn't be capturing like the whole object i shouldn't be capturing by reference most likely because it can potentially create lifetime issues i should be actually cherry picking what i want to capture so make a copy of the db context into my lambda and this will work fine most of the time except what it won't a common error right everybody has seen something like this once a day at least something cannot be copied because it has an explicitly or implicitly deleted copy constructor on the copy assignment operator it's a move only object it's a solution to this problem yes there is of course that's actually prime reason for introducing the init captures init captures in lambdas were introduced to support move only objects so you could move something into your lambda that cannot be copied hooray we can move the db context into the lambda but this creates another issue and this issue is an ugly one sometimes our lambdas will be now perfect sometimes they won't be in the code in the code that's at the top of the screen here it works perfectly you can move the whole proxy or a part of it into your lambda as a part of the art record function and nobody will suffer from it right this proxy is about to die anyway it's just falling out of const context and out of scope you can safely move a part of it into the lambda now when you plan to reduce your proxy this is not the case like when your proxy has to leave and support multiple additions for example using the db context and if you just moved your db context in the first call to the art record well this is done this is like the ugliest error you can imagine hard to track how to understand how to debug because something happened your code compiles and you might get an error you might not depending on on what kind of code you have and again ask with any problem they're usually as a solution it's not an easy solution but it sometimes happens as i said at the very beginning of this talk capturing is mostly about lifetime or avoiding lifetime disasters in complex scenarios that's one of the reasons why i would ever capture in this case you can support different lifetime requirements by writing different by using different captures or by using different capture modes this is absolutely possible and this is what you should do how do you do it well that's the function we have right that's the function we have and we know it works in certain scenarios it works when we are absolutely sure that we can actually steal from the proxy we can still it's part of the whole proxy if we want that's the function we would also like to have this is for the scenarios when we want the kv proxy tool stay alive and functional can you have those two overloads yes you can of course you can that's a less known feature of c plus 11. i think 11. but since then instead of using cons qualifiers instead of cons qualifying your member functions you can re-qualify them you can add a reference qualifier at the end of the argument list or parameter list and there are many of them there are actually four of them one of them is barely usable but those two will surface for this example the first one were the r value qualifier or the r value reference qualifier basically tells you that this overload of the art record should be called only when the kv proxy is at the end of the lifetime when it's what we call an expiring object like it's almost dead the other one the l value reference qualified will be called when your kv kv proxy is an l value which is a common case right you have a named object it's not a temporary it's not at the end of the lifetime it's a named object named variable it's an l value for those cases this one will be called when you do something like this when you support different lifetime requirements by using different overloads and using different capture modes the code will work it will work almost out of the box for most of the scenarios like it will work out of the box in case of the l values the bottom part of the screen it won't really work out of the box for the top part of the screen because you have to instruct a compiler that actually the proxy is about to die and you will do it as always by using the state move discuss the proxy to the r value and this signifies the fact that the proxy is at the end of the lifetime and you can safely grab from it and the correct overload will be picked and i must say that there is a lot smaller that i could be talking about lambdas but the time is ticking and i can actually only focus on one topic more i think and that's the three dots the three dots that the fun feature of lambda captures why would you ever need three dots in your code well imagine a scenario like this you have a perfectly working code a key value proxy that is a proxy to some database and it supports adding and retrieving records now but the changes are coming and instead of using then your old good database contexts are now many other databases that you need to support so you will template your whole structure it will become a class template so far so good now another issue will arise sooner or later different databases use different kind of updates or need different parameters when you add something to it or where you retrieve something from it like one might use a storage policy additionally to the key one might use also some authentication token why not the possibilities are countless and notice in that in all those cases you actually need to capture all those additional parameters because they are needed when you later on retrieve from the database now you have two options here either you specialize your class template for every single scenario but that's craziness or you add countless overloads but that's also craziness or use parameter packs so the three dots to store multiple to capture multiple object in generic code what are parameter packs for the uninitiated parameter packs are a feature that allows you to define function templates that can potentially take multiple arguments or non-arguments at all so imagine a scenario like this when you have a function take many arguments and the only job that this function is doing is calling another function the consume functions are multiple overloads for the consume and you would like to support all those scenarios now you might write also like three overloads for take many arguments but that silly instead what you are going to do is introduce a parameter pack that's how you do it that basically defines a function template that can take from zero to multiple arguments of some types all of them by const reference that's why the three dots the three dots is a parameter pack now that's capturing that's how we define the signature and later on when you do forward somewhere where you reuse this parameter pack you also have to expand it again by using the three dots now this feature parameter box has been there from c plus 11 and it works great when you use it all the scenarios will work you can call take many arguments with whatever you want this feature also works for lambdas lambdas can capture argument packs or parameter packs sorry how is it done well first of all we need to change the art record signature because we have to somehow introduce the parameter pack so the signature will change to possibly allow multiple arguments of unknown types that's the parameter pack right now this will be also used when you update the database store because obviously you need to forward those arguments whatever their type is this is only cost reference but whatever the type is it used and last but not least you will have to capture them that's how you capture the name of the parameter pack with three dots is a capture and then within the lambda you expand this is a unique feature of lambdas there is no other way in c plus plus to create an object or a class type and saying that it's going to have some data members but i don't know upfront how many you can only work around this problem by using a tuple or building in a tuple into your class type lambdas don't need a tuple to support it lambdas just can capture unknown number of arguments the unknown number of variables and they will create the data members for it so far so good but there is a small problem there with different databases when i work with them and i you know other record i sometimes want to reuse some objects that i pass to my at record function like maybe there is a policy which never changes so i want to keep it around and pass it by a reference and some i only use ones like the authentication token is generated for a short use time and basically i have to use the same authentication token to retrieve my data which i use for storing the data so it's like something that i would like to move i don't want to keep it around i want to move it into the add record function and later on i want to move it into the lambda but now we capture everything by cons or actually we pass everything by const reference which means that we also capture by copy can you move things and can you actually move some things and don't move some other things yes you can in c plus plus 20 this feature has been added and from now on you can capture parameter packs using also init captures what does it mean for our code well it means that instead of capturing by const reference as on the previous slide you can capture by forwarding clever reference or as some people prefer to say by the universal reference this has this magic under the hood that it correctly forwards the value category of your argument so whether you pass an r value reference or a value or an l value reference the value category will be preserved what's next the capture comes next right we need to also capture it correctly and we do it with init captures and pack expansion and forwarding this is supported since three years you can use it and it will correctly work what can be moved will be moved into your lambda what cannot be and should be copied will be copied this is perfect for wording right that's how it works for other scenarios and that's also how it works for lambdas and when you do something like this magically the policy will be copied and the authentication token will be moved into your lambda and everything will work just as you would expect now that's almost the end of this talk we covered a lot we covered the type deduction rules for lambdas we covered different ways of capturing we talked extensively about capturing this and the dangers of it we talked about lifetime issues and other issues associated associated with capturing this and last but not least we talked about how to use init captures to move or forward things or even though lots of things together into your lambda and why it makes sense i said in the beginning that capturing is mostly about lifetime but it's not only about lifetime it's also about writing generic code like in this case and first and foremost because those are lambdas it's also about having fun lambda some fun have fun with them and this is really the end of this talk thank you very much for listening [applause] i'm on time which means that if somebody wants to ask a question this question is very well much welcome hey thanks for the talk you said at some point never capture everything right yeah and i tends to totally agree well you've never capture everything by value but i seem to be fine with capturing everything by reference because i've never seen an unexpected behavior with that like capturing everything by value as you as you've shown as the problem with capturing members and everything and suddenly they became actual references but that doesn't seem to happen with when you capture by reference if you capture everything by reference you need to be careful about the lifetime of what you capture no matter what so do you have an opinion by value essentially i fully agree with you if you capture by your friends and you know what you're doing you you really don't expect any problems especially if you are sure that all your objects are within the lifetime you won't have any problems and that's very common thing to do right especially if you write a function and you never return anything from this function just pass the lambda around to some other functions when it is within this one it's absolutely correct but it would totally ruin my point there so i didn't include there so forget the question then thank you okay thanks again it seems like nobody's asking anything else thanks a lot and see you around have a fun conference then [applause]