and real life with tonight's armor with sean parents i want to welcome the folks in hobilo and this also streaming to linkedin so people will you know slowly triggered in from linkedin to who video or just view this on linkedin i do want to sell it i prefer the questions to be asked on mobidos i will you know prioritize them but if you have any questions on linkedin naturally some people would ask them in the chat and i will also try to cover those and with that let's get started sean parent tonight here to answer your questions and i guess some of you are wondering who sean parent is what does he what is he doing in the recent life of c plus plus so sean please introduce yourself okay so i'm sean parent i'm a senior principal scientist at adobe i've worked there almost 30 years now i did take a short break in the middle to work at google on chrome os and prior to coming to adobe i worked at apple in the system software team working on the transition from 68k machines to powerpc machines ages ago my current role at adobe is running adobe software technology lab so i've got a small team there are four of us all together our charter is to take a long long range view of trying to improve the code that engineers write so we're not so concerned with with process as we are with what engineers type when they actually sit down with the keyboard and so some of the things we're looking at are the challenges of writing correct concurrent code challenges around the complexity of c plus plus and the lack of safety in c plus plus and and challenges around how we educate our workforce and kind of bring everybody up to up to speed so so that's who i am see do we have any questions coming in yes this will be now the time to ask a question so if you have questions in her below i prefer strongly the q a tab so if you ask a question there that's where i will choose from if i see a question in the chat i also will be happy to take that there and of course people on linkedin ask questions see there's already some people saying hello from linkedin yep actually there's currently let's start with an easy question what is your impression about the new c plus standard well i don't know if we're talking about 20 or 23 right now we're internally just moved to 17 after a very long effort and things like the parallel algorithms are still missing from from apple's release of clang so we're not even fully on t plus 17 yet i think there's a lot of potential in c plus plus 20. i'm looking forward to to cleaning up some code with concepts modules have a huge amount of potential we haven't had much time to play with them yet and co-routines i think have significant benefits in structuring concurrency so looking forward to those also oh certainly we've been writing some some experiments and playing with some of these features uh c plus plus 23 i've been loosely tracking it uh you know generally i think the the the feature set is good you know my ongoing issue with c plus plus has just been the the ever increasing size and complexity of the language it's it's it's become very difficult for both new and senior developers alike to kind of wrap their head around it and when you have you know a large company that's growing which is you know adobe's a fairly large company and we've grown largely through acquisition and so we have engineering teams all over the world and and we don't have a homogeneous environment like you would see at google where we have a single set of coding guidelines and and you know from project to project code looks looks very similar instead we have a lot of different teams that have developed their own ways of doing things and then they're trying to share code with each other and and it's it's amazing how different c plus code can can look coming from two separate projects yeah so there's a question from her below on the status of your book status of my book that's actually a pretty high priority for the team right now so i've got uh dave abrahams has joined me and with the software technology lab if you've been around c plus plus a long time you probably remember the name he was very involved with getting boost going many years ago now and then left the c plus community for a while to work on swift so he worked on the swift standard library and is one of the designers of swift and then worked on swift ui at apple and i've managed to snag them and pull him over and i've got david senkel who comes from bloomberg who might have seen some of his talks at some of the conferences and then a younger individual nick demarco who i worked with at adobe a few years ago and he left the company for a little while to try the startup thing and i managed to convince him to come back to join the software technology lab and so right now we are all working on course better code course which the idea is to uh use that as a way to develop the book further so we've gathered up all of my piles of notes and presentations and sorted through those we just did a dry run of the first three chapters with a small internal group of people and i've it was very informative kind of it has us going back and and reworking some stuff but but we're moving i'm i'm adding co-authors and uh a a busy writing and and busy making progress on it finally it's been a very very long time where it's kind of sat on the shelf so so yeah no schedule yet but it is it is it is actually moving so that's good okay let me see the next question what worked best on achieving superfast developers writing better code so far can you share some examples or reasonings what has worked best uh you know certainly the kind of no raw loops thing has resonated and i think had the the broadest impact the the there's an orc to the to the to the book and my talks and and the class that we're developing around relationships and and this is the idea that it's it's it's the the things that happened uh between the objects that don't happen in the code that tend to be problematic in in the system and so how do you go about identifying what the essential relationships are and and uh codifying those and coming up with a system to reason about those within your code so i think as we start to get that message across that's had a significant impact on how people think about their code and and and and approach development so and let me choose a question from nathan what is the future of why does it remain an experiment to try new things or would it become a production ready language that's a good question dave abraham's right now is in kona he just gave a talk yesterday evening to the c plus plus standards committee presenting some of the ideas in val for people who don't know a val is a language that was created by dave abrahams and dimitri butcher's last name recordon and and it's uh in in its flavor it's very similar to swift but it's uh even more safe by default so in that sense it bears some resemblance to rust but it pulls off rust level safety included around concurrency without the need for all the annotations and so we think it has potential to be a more approachable language right now the work has been mostly done by dave and dimitri we've got another external contributor illusion and then my team is is starting to look at how how we can contribute we had a meeting with herb sutter not too long ago trying to inject some of the ideas from val into his cpp2 effort we've also had conversations with folks working on carbon around trying to get uh some of these ideas injected into carbon and i think i think we're having having an impact there we're also stealing one of her sutter's ideas and right now we're working on a a transpiler so that you can compile val code into c plus code and through that we're going to try to work on on c plus plus interop so the you know it started as kind of a purely academic exercise it's been moving very rapidly in the last several weeks rapidly enough that we're trying to get a few more arrows behind it and just see where it evolves uh i'm i'm not committing to becoming you know a a commercially viable system uh on its own at this point they're still still a long ways to go before we get there uh but it's you know the more we play with it and the more we look at it i think there's the ideas there are interesting enough that we're like i said we're investing a little more and and trying to see see where it plays out so and how much are you personally involved in why uh you know well i managed dave abraham so it's kind of kind of his baby to date i've been involved mostly as a as an advisory and helping out with some of the papers and and and things on it but yeah i'm hoping to to get a little dirty especially as we're working on on c plus plus interop and so roll up my sleeves and and write some code okay asked in your cpp north 2022 keynote you mentioned the difference between programming languages that are efficient by definition versus efficient by optimization can you elaborate on this a lot of c plus plus speed come from o2 o3 compiler optimizations yeah so so the the basic idea is is at a high level uh do you have guarantees about things that will or will not happen and for example return value optimization in c plus plus has something that's been allowed for for uh many years you know going back to to c plus plus o3 but it's not till c plus plus 17 that that it's it's mandated and so you can couldn't rely on it before then and when you're developing code uh that's performance critical it's important that that even your debug builds reach a certain level of performance and that you can get consistent performance in a wide variety of environments so right now you know the i work closely with the photoshop team and the photoshop team builds all of their code for you know ios and android and wasm and linux and mac and windows and so it's a fairly broad suite of of compilers and platforms that come into play and so so you need sets of of guarantees so for example many of the functional languages you know present this uh illusion that everything is a copy and then you rely on the copies not happening under under the hood and getting optimized away but what that means is is inefficient code or the optimizer can't see through what you're doing and efficient code looks identical and as a developer you don't have control over that so one of our goals around val is to uh uh even take things a little further than c plus plus which is to make sure that even copies where they happen are explicit and so the model and vowel is is implicit moves are allowed but implicit copies are not and so even if you want to copy an int it's an explicit statement to to copy and int and and uh you know personally i find that that that much much better with concurrency this gets you know much harder if you look at a language like haskell concurrency is really just a compiler flag and in a purely functional system you can just turn it on and the optimizer will try to find places where it can run code concurrently and you'll pick up you know a small performance win in a typical haskell code base and if you're very careful about how you construct your code and you know what the optimizer is going to do you can get significant wins uh by by turning on concurrency and so you know a challenge in a programming model is how do you enable concurrency in such a way that a developer can can reason through it and and get kind of you know guarantees around the scalability of their performance and make that explicit in the code so so that's what i i mean by by those things so yes it doesn't you know completely remove the need for having you know o2 and o3 and letting the the compiler go off and and do further optimizations but you do want to establish a baseline things that i'd love to see in c plus it's uh you know i'd love to see some changes to the destructor ordering rule so that objects can destruct after last use instead of having to wait until they they're at the end of scope and if you did that that would enable uh things like tail recursion optimizations and you know i think that we could do that in such a way that you could have explicit guarantees around where you got tail recursion optimizations and things like that and if you look you know the game community complains quite frequently that debug builds you know where where the debugger or where the compiler is turning off inlining become unusable with modern code because you get super deep nests of of function calls with a lot of the template heavy code like boost or kind of code that's using functional paradigms and the only way that that works efficiently is if you have your optimizer come in and inline all of that code and remove all of those function calls but that makes things more difficult to debug so you know how do we get to a world where you can have your debug builds run at a higher level performance and not generate you know 100 unnecessary layers on your stack that is true speaking of the stack speaking of color teens do you think as is the features production ready i think the feature is production ready it's production ready i mean it's it's it's a well-designed well it's it's a thought through and and and and and in some sense a well-designed system for co-routines i mean certainly in c plus plus 20 the biggest thing missing is the library support to make it actually usable there's you know understanding how co-routines work and constructing them is is a is a challenge my biggest complaint there is exactly what we were just talking about which is that the model for co-routines implies a heap allocation and in that sense i think it's it's an outlier for the c plus language you know uh you know invoking a function usually doesn't imply that there's a heap allocation on that function invocation and and you know for example lambdas don't don't do heap allocations compared to say objective c blocks which do uh there's there's a rationale and a reason for why that heap allocation is there and sometimes your compiler can optimize it away but i think it's very telling that things like uh eric niebler centers receivers code really doesn't use co-routines internally because eric doesn't want the heap allocations and can't rely there's no guarantees about when the compiler can optimize those away and they'll almost always appear in in debug builds and uh so in that sense i think the the feature is a little the design of the feature for co-routines is a little unfortunate i think uh you know it's it's kind of a weird thing in the declaring a co-routine isn't actually declaring a function which is what it looks like it's more again to declaring an object or a struct and and then the the invocation of it i think should be purely on the stack unless you explicitly keep allocated as opposed to it magically getting heap allocated and you're getting a co-routine handle for the for the for the allocated object so yeah i i think it could have been better yeah complicated system it is missing i think at 23 will bring further improvements and then there is it's a new model people have to get used to it yep and it's not like something which was prior like not in the standard but in available of a lot of libraries there's a question on books sean i believe you have advocated developers to look at the work of stepanov and my self-study i've been reviewing functional programming and category theory this is analogous and we're looking at or should we stick with elements of programming both you know i think uh category theory is interesting i think it's very easy to get lost in category theory and you know at the end of the day category theory is looking at at how how things compose but is devoid of semantics and and elements of programming is is very strong on on on on on looking at things by starting with defining what they actually do uh so you know i think there's there's things to be learned from from category theory certainly there's a lot to be learned from functional programming i think you know most developers would would do well to to spend a little time doing functional programming if they didn't didn't do it in school uh it makes you cognizant that there is you know for for any problem there's a different approach that doesn't require mutation and and you get you know immediate guarantees around around safety and there's concurrency benefits and things of that nature at the same time doing something like sort becomes inefficient and and much more complex you know so so studying kind of both approaches you know the eop approach and the the functional programming approach i think will give you some insights into you know what's the better approach for a given for a given operation and you know anything can be written in a you know in an in-situ form kind of where you do modifications in place or a functional form where you return a result and then functional forms can be either lazy or eager and there are our trade-offs with each of those approaches and those trade-offs are different for for any given problem that you're trying to solve so so i think as a developer getting to the point where you're familiar with what those trade-offs are and any of anything you're trying to solve you can approach it in all three different ways and evaluate the trade-offs is is a good thing that is true from the court safety and correctness perspective what is your opinion on error codes versus exceptions i gave a talk on that called exceptions the other way around which is which is available on online so my you know my opinion is that uh you know error codes that need to be explicitly handled even if it's you know through a monotic monadic composition you know where you have a language that's called like a dot question mark or something that can that can you know chain or not chain depending on whether or not you you've got an error error codes are unnecessarily problematic and they just pollute your code base with noise and so i am not a fan of error codes the c plus plus exception handling has some issues of its own uh you know it has some costs that that come in because it drags in in rtti which is not an opt-in system the fact that operator new can throw even though on on most os's it really can't because the os is going to over commit but the compiler still has to generate the exception tables in part because operator new is a replaceable operation which means it could be replaced to dynamic link time when your application is loaded so the compiler can't really determine whether or not operator new will throw or not it just means that the the t plus exception handling is is heavier weight than than it could or should be but you know go watch my talk i really think that that you know going to an an error code environment or uh you know uh you know any of the uh uh proposed kind of you know expected result types that do monetic composition i think are are are largely going backwards and and are brought about by people's just uh own squeamishness around exception handling so you're not you're not a fan of expected i am not a fan of expected no not at all okay so there's a couple of questions about like basically boiling down what do you think about carbon what do i think about carbon you know it's it's it's interesting it's got potential we're monitoring it so david senkel on my team is is attending the the carbon meetings and we've had a a a few larger meetings with the with the carbon team uh i think carbon is is right now a little too hand wavy for for my comfort level it's it's largely trying to tackle the governance issue with c plus plus uh and from a language standpoint it's basically going with the c plus plus ox model of of generics which i think is a is a good move but but it's largely ignoring safety at this point it's i think kind of getting rid of references in favor of pointers even if you have the notion of non-null pointers adds complexity it's it's not a simplification that they that they think it is uh you know and so so we're watching it i'm you know i would say right now i'm i'm not a fan of the of the design as it is or the direction it's going in but you know maybe just a simplification of the c plus plus syntax and assuming they can pull off interop which is a big question at this point they haven't demonstrated that yet uh you know maybe that's enough so so it's got a lot of arrows behind it so it's it's hard to rule out yeah i think from other languages which came into light this year they are more like an idea and other languages already like you know sean mentioned health status approach of you know having the idea to actually compile to c plus plus and not try to to build up on one of the compilers might be the better way for for some people let me see what questions we have oh yeah so like when we talk about herb what's your view on herbs such as cpp2 i i think it's a good piece of work uh that's you know we're having conversations with them uh in fact that was one of the reasons why dave abrams is out in kona right now was to was to spend some time with with herb sutter and gabby discussing cbp2 uh i think buried in cpp2 is a a simpler approach that's actually more capable uh looking at it we think they're just hair away from getting thread safety you know out of their safety model and their current safety model rules out some constructs like sharing immutable data which actually are safe so kind of i think the design goes a little overboard on some edges and not far enough in others but it's uh it's a relatively you know solid design at this at this point so so i'm i'm encouraged by it so yeah yeah i liked it when i saw the keynote but i also like that he keeps working on it that's like what's one of my biggest worries that i hope like you know friends every year a science project at his keynote and where does it go from there yes not always the best track record but i have a question on embedded which c plus plus features should be avoided while programming for microcontrollers you know the last time i did embedded work was programming a z8 processor which had 2k of rom and 128 bytes of ram so so i'm really not the the uh the the best person to to to ask that question uh you know i don't know use the features you can afford to use i guess is the answer any any cpfs feature which you advise against in your own coding guidelines no our own coding guidelines we try not well so the you know things that i think are very problematic are things like dynamic linking which is not a c plus plus feature and that's part of the problem uh and it's especially bad if you're doing dynamic linking and you're trying to do simple hiding with it which puts you immediately in in undefined behavior territory and yet a lot of a lot of teams and a lot of products do exactly that so that's an an ongoing pain point uh you know basically it's an ongoing effort to try to raise awareness of what the rules are for a library versus an application and you know if you're if you're writing an application you could replace operator new delete for example but if you're writing a library you really can't without stepping on on the main application toes uh so you know our guidelines are around things of that nature and not around specific language features that you you should or shouldn't use on on the language feature front we try to educate people as to as to you know what things uh uh do and where are the sharp edges as opposed to making mandates about you know don't do x you mentioned safety aspects of codes what is the approach at adobe to test safety relevant generic c plus plus code a reasonable amount of templates no excessive meta programming yeah you know our approach i think is like most of the rest of the industry which is you know these days which is trying to rely on static analyzers to the extent that we can and sanitizers to get us get us beyond that you know from from an educational standpoint we try to teach people about how to work in an environment where almost everything is a whole part relationship and uh you know getting rid of shared pointers to mutable data and uh getting rid of of of of of sharing data through threads except through explicit communication channels things of that nature which are all you know built around ideas of safety but yes uh you know i think like the rest of the industry in c plus plus it's a it's a difficult net to crack personally what i've been doing is is almost all the code i've been writing lately i actually write it first in daphne which is a uh a language that can output in multiple languages including c and typescript and and and and some other languages but daphne includes a proofing system so you can write pre and post conditions and loop invariants and you can use existential and universal qualifiers and the system will will prove your code is correct to the specification and so so it doesn't have a good c plus plus back end but even my sequence plus code these days i tend to be writing it in daphne first and proving it correct and then just transcribing it into c plus plus so taking a little bit more of a formal methods approach but i know of at least you know one other person that adobe who does a similar thing but but certainly i don't think we're going to get you know an entire company to start proving their code there's maybe a connected question about ada what do you think why it's not getting as popular as c plus plus in other languages you know i i it's a good question i don't know and honestly i haven't spent time looking at ada in in in in many years and it did come up recently in a in another conversation around you know ada has checks some of the boxes that people are looking at for c plus successor languages but honestly you know it's on my it's on my list of things to to research a little more i think the last time i tried to take a cursory look i was surprised at how few of the platforms that we care about it's available for in any in any uh a significant form so that was a little a little problematic at the time but yeah i i don't have a firm opinion of ada there is a question about reflections what do you think about adding reflection to c plus plus should it be a must a nice to have sean baxter in the circle compiler and david sanker have done a lot of progress on this but i don't see the committee much willing to change the language for work on this area yeah you know i'm a sean baxter fan i like what he's he's been doing with circle and certainly he's been doing a lot of interesting experimentation with the circle compiler i i think it's unfortunate that the standard committee isn't listening to him more because he's certainly gained an experience and and his approach is evolving i would really like to to see us have a much better compile time reflection in the language and you know i think if if we have a good compile time reflection it lets us build opt-in a runtime reflection where that's useful so i think that that's high value i think the current state of affairs of trying to figure out what you can declare a const expert and win constex for things actually execute at compile time is is a difficult programming model and the the circle model of basically lets you run anything at compile time you know i think is is is is is is is an interesting and and valid approach you know i i disagree with the with the naysayers who thought that you know having your compiler running on your server being able to execute anything is a security violation because if you're like adobe what do we do we compile a bunch of code to generate unit tests and then we execute all those unit tests on the server so if it's a security hole it's it's already been blown wide open and not to mention the fact that the the current template mechanism is trained complete so you know it you could you can do anything that way too so so yeah i'm a fan i would like to see more reflection i think i think just some of the basic things that we still you know deal with the number of places in code where you have to you know map strings to enumes back and forth and uh just just common things like that i think are are are ridiculous but certainly i would like to be able to do things like you know iterate all the members of a struct and uh you know merge you know right right compile time code they could merge two structs and generate a new struct and do things of that nature so yeah so it was like a very very similar question which we could you know continue now it's like do you think that we will be able to match with java and c-sharp or is it maybe a different language model which allows them to do more i well i hope we don't try to match java and c sharp both of those are are built uh uh with the model that you have a class object which is a runtime object and the closest c plus gets to that is having the v table and and the rtti information which is all all all immutable data and a little a little heavy weighted as it is you know i would like to see us move more towards getting opt-in rtti or at least now an ability to opt out of rtti within a class definition and there are many techniques for building your own v table so i think having direct inheritance and having the compiler generate v tables for you is a is an unnecessary feature of c plus plus uh that said there are uses where you do want you know the equivalent of a class object and i think if you have enough compile time reflection you can you can build that easily i mean you can certainly do it without compile time reflection it just ends up being a lot of boilerplate code or a bunch of macros or horrible copy and paste things i used to uh when matt austin uh was kind of lead on c plus plus at apple years and years ago i used to argue with him that he was he was working on both c plus as well as as objective c at apple and objective c is another language that has class objects and and and runtime reflection and my challenge to him was how could you turn uh objective c into a c plus library that was actually usable and and that would kind of be my my challenge for the folks working on reflection in c plus plus is can you make the job in c-sharp capabilities be edible from a library and you know in a usable form and and i think if we can we can get there and we will have accomplished a lot so and i'm sorry there is of course a question about avi is abi stability holding back the evolution of c plus plus well i there's there's two ways to say that i think if you broke abi compatibility it would it would stall c plus plus for for over a decade right certainly adobe would have a very difficult time moving to a a compiler or a tool chain that broke api compatibility even small breaks and abi compatibility historically have cost us several years uh just because they're such a large ecosystem of of libraries and dlls and things that are outside of our direct control and things that have to be coordinated because we have to build across different versions and different environments of things so so of kind of a full api break would be very painful and i think would stall install the language at least all adoption of the language that said i really think the standards committee should start to come to terms with the fact that you know a lot of development happens in in dlls and a lot of those dlls are built with symbol hiding to reduce their size and that immediately puts you into undefined behavior and and the abi communication between them is may be specified by platform vendors but certainly not specified at the language level is just kind of an unspoken rule that language providers can't break it and i think c plus plus needs to figure out how they have an explicit abi resiliency model something along the lines of what swift did where you have have a set of constructs where you put in the stake in the ground and you say these are for communicating across dll boundaries and you actually define what it means to build c plus plus code inside of a dll uh uh and and you create a a resilient layer which may come at a at a small runtime penalty to use that layer to speak across it so i don't think the the question is as simple as as you know break it yes no it's yes we want to break abi stability so that we can evolve the language but to do so we need to put into place a resiliency layer so that people have some guarantees that they can migrate to and that's probably a many year poll because you want the resiliency layer in place first and give people time to migrate uh to that and then you can go and start breaking apis and and you you have an answer so so that's my answer on apis yeah i this wasn't i think 2021 when price keynoted c plus plus now he mentioned the paper p two one two three which tries kind of to solve this accordion not by introducing interfaces and constructs to say break the api here for that standard but leave the api alone for the standards and i i guess we also you know would like to have this ability for libraries to say this is library version x and we're breaking standard i'll be breaking the api and otherwise we're not breaking the api i kind of like that idea but i think it's also like an idea which needs to be more refined and i'm not aware that vegas paper has no it's still reviewed and under review probably in kona now [music] but i wonder if you have heard about that paper i have heard about it i haven't i haven't uh spent time going through it i was encouraged that somebody was looking at the problem uh yeah and you know apple years ago had a a tech note that they put out which was the unfortunate title was something like c plus plus tips and tricks or something but buried in there was was basically their statement on on minimal abi compatibility between dlls and and what that meant and and it was it was very restrictive at the time and and but i think that you can actually start with a relatively uh restrictive environment right right you just need to let people know what's what's guaranteed to work across the boundaries and you know and you need rules about you know what does it mean to have a single application that depends on say two different versions of boost uh you know that are coming in from dlls right right how does that work i had that problem once yeah yeah we have that that problem in spades so you create a cpp file and only the cpp file is basically acting as a firewall yeah and only that is like then connecting to the library which is using or like connecting to apis connecting to the library which is using the old boost version and you're not sure how to build as a new version yeah and things like you know apple's runtime their their mako environment has has a notion of two level name spaces which means that you know a dll that includes a dependency that dependency is an automatically visible to other dlls and things of that nature but all of that is outside of the language and all of that is is basically you know a implementation defined behavior and as far as the language is concerned it's undefined behavior you know too it's an odr violation technically uh and so yeah i think that that the fact that everybody does it and nobody's working on trying to standardize a way to do it is very problematic and what we run into all the time is people create a system that works on windows but then fails everywhere else and and it's because of things like you know windows does rtti look up by name and every other platform does rtt i look up by symbols and so if you're hiding symbols then on windows names still are exposed through our tti so things like a dynamic cast might work on on on windows but fail on mac or vice versa depending on how you have things set up and so these are all all problematic things and you know the number of times where i hear you know developers complain we don't understand we're throwing an exception and we're catching the exception of the right type but it just blows past and doesn't get caught and it's like yeah that's because you're throwing from one dll through across the dll boundary and and a simpler name wasn't exposed and so an rtti lookup failed and so your catch failed and you you ran off the end of your exception chain termination yep what do you think about having garbage collection on c plus plus i think garbage collection is generally a horrible thing and you know a horrible idea all right it's you know garbage collection is for people who don't know what their pointers are doing uh and so so i'm very much a fan of of of precise lifetimes in fact i would like like more precise lice times than c plus plus offers i would like objects to fall out of scope after last use as opposed to at the end of the scope block objective c and even objective c plus plus works that way which can throw you for a bit of a loop if you're if you're you're used to the c plus rules uh so yeah i mean it you know in general i'm against you know trying to share data i try to make as few heap allocations as possible which means i'm trying to generate this as as little garbage as possible uh garbage collectors tend to cause you know indeterminate delays they're blowing your caches they're limiting your memory basically for for you know every every bite of ram i can give to photoshop photoshop will run a little bit faster you know and do less paging so so it's not a fan i've never been a fan of garbage collected systems we actually have someone asking you look at that question so as the c plus plus begin now what areas should you focus on to improve your own career what area should you focus on wow i improve your own career you know i i may not be the right person to ask i tend to think uh it's it's not language specific basically focus on on understanding programming so we mentioned before you know eop or studying functional programming or going back to some of the classics right right reading uh uh dijkstra or bob tarjan's books or or even try to work your way through canoes i think we'll have much more more benefit kind of an approachable form of that is you can find all of the train award lectures online read them you know end to end it they're not that long they're a few pages each there's some some real gems in there uh so so you know spend your time learning about the the profession and then programming being in c plus plus or or any other language will come fairly naturally i spent you know most of my time in c plus plus but i was working on photoshop web and so i spent time in typescript and i've spent time and and swift and i've spent time in uh you know certainly a lot of time in objective c and objective c plus plus and you know like i said right now i'm writing most of my code in daphne first the language really doesn't matter all that much it's it's figuring out the ideas and and then how those ideas map into a particular language and that usually doesn't take too long to figure out so so that would be my my recommendation i think an interesting question has been asked about energy consumption do you think we would have compiled optimization for that end i i hope so uh in the single threaded environment energy consumption maps fairly well to performance not always but fairly well uh it's as we start to get more language support for concurrency coming into play i think where things get interesting because my canonical example is is is just you know implementing find right if you do find on a single threaded core you're going to search roughly you know half of the items before you find what you're looking for assuming there's one instance of the thing within the sequence that you're searching if you do parallel find you'll split that into half and you'll you know on two cores uh you won't find it in one half but you will search the entire half and you'll find it somewhere probably in the middle of the other half and so it's going to be roughly 13 quarters of the data and as you add more cores you very quickly are approaching searching all the data and so you know a parallel find is doing roughly twice as much work as just a a sequential find and and throw in the overhead of scheduling all those tasks and everything it's it's it's probably consuming a bit over twice as much uh energy to do it so that's you know i i think that's that's going to be be challenging and certainly if you look at a large server-side systems you know google scale type systems uh you find that that it's the energy costs that start driving uh you know end up being the majority of your total total running costs right your energy costs at that scale start to to to dwarf your engineering costs for development and dwarf your hardware costs and all of that and that's you know especially to these days as as energy prices have been skyrocketing this is why you start to see you know large data centers building their own solar farms and and trying to manage their own costs that way so yeah i mean i would certainly like to see it i would like to see like you know dash oe which was compile my code efficient to be energy efficient i think on the other end of the scale we see the same problem like i mean you have talked about you know running code on ios and making you know putting part of of your adobe products to new platforms which are more mobile and more prone to energy consumption than a normal pc yeah yeah and that's a problem and you know it's uh you know macs and windows now you know have a way to kind of drill in and see what what the energy consumption is of various apps and frequently it drives me nuts when you know an adobe product is is listed on the top of that list on my machine and so yeah yeah unfortunately i don't think that that's as easy a fix as just a compiler flag you know usually it tends to be something that's spending too much time staying alive being in a network or or that nature that's the other thing that a computer can never expect what the runtime does so yeah what is your current development environment operating system editors ides and like offline tools anything you would recommend or won't recommend ah i don't have anything too fancy for work i do most of my work on a mac my personal machine is a windows box so i tend to split my time between those two because i still do a lot on on ios and mac development xcode is the ide i spend most of my time in maybe it's probably close to 50 50 at this point between that and vs code uh inside of vs code i i use things like daphne which i already mentioned which is pretty cool because if you write a piece of code in daphne basically the fact that you can compile it means the code's correct so it's kind of a fun fun environment to to develop in i use uh jupiter notebook with the zeus extension which lets you run c plus plus code inside of a jupiter notebook inside the cells it's it's kind of a semi-interpreted version of c plus that can be great for developing a a courseware or just for developing ideas because you can basically be you know writing your notes and have executable snippets of code in there even when i'm working on on a big product i tend to write almost all of my code outside of that product either in just you know main.cpp file uh you know or inside of a notebook or inside of daphne and then transfer it into a notebook or into into a main.cpp file and then i left the code and drop it into the product so so i'm almost never you know writing in a significant body of code directly in the product right right the most most time i'll spend doing that will be pulling code out right it's the put in a replacement and so now i've got a gotta grind through several hundred files and and and you know updated api or pull out a bunch of code so you would not have been you know profiting from the so-called twitter ruler that only the people just wrote a lot of code stay no i think i generally would have been negative so i would have been escorted out i'm pretty sure uh yeah yeah i'm also i'm i'm odd in that i i learned to program taking a lecture and i was relatively young i was in i don't know sixth grade seventh grade something in there and uh about two years before i ever got to touch a computer and so i i i i was obsessed with with writing code in notebooks and executing them in my head and that habit has stuck with me so i don't bother to compile things until i've convinced myself that the code is correct and i i will tend to will you must have a lot of handwritten code then i used to have a lot of handwritten code i mean now it's like you know handwritten i do type it i do i do sit down and type it i no longer you know write it with a pencil and a notebook but like i said i do use things like jupyter notebook and and i will will you know write all the pieces and things like that and uh you know all work for several weeks on on a piece of code before i even attempt to compile it and i'm the only person i know who who works that way it's not a way i would recommend it's just the way i think you know i kind of don't see the point of writing something through the compiler until i think it's right so so yeah i'm not very fancy with my tools which parallel computing frameworks are preferred by adobe why how did opencl fail how often as i lead the better choice compared to when no login frameworks like metal cooler etc yeah so the well a lot of our parallel code is written in a language called halide which is uh a language specifically for doing uh image processing and it can target basically code running in a thread pool on a cpu that's simply optimized or it can execute on gpu or kind of any mix in between and so a lot of our lower level code is written in halide and halide's been a collaborative a collaborative effort to develop between adobe google and mit and so so it's kind of a a parallel environment embedded inside of c plus plus and then uh uh intel tbb gets for fairly high amount of use inside of adobe is probably the you know number two most used system going next to halide a lot of people don't know it but tbb is open sourced and which means like when we were doing photoshop for the browser we did our own port of tbb to wasm and now since then intel's been been has released class of support and so even though it's you know intel tbb it does have arm support and so you can run it on ios and you can run it on android and even run it inside of wasm so so it's a a fairly nice concurrency environment i've been tracking eric niebler's kind of structured concurrency center receiver stuff that's not getting any play that i'm aware of currently inside of adobe i think it will i think it's an interesting library uh solves a lot of the problems i've got some things that i wish it solved that it doesn't but but in in general i think it's an improvement over a lot of the things out there which includes my own libraries which are the the st lab currency libraries those i i gave a talk on currency and i wrote the library basically well i was at c plus now because i thought i would take the code i wrote for the talk and check it into a github repository was basically how that library started and it's it's since evolved quite a bit and i've had some external contributors including felix petraconi who's who's contributed a huge amount to the library and one of the key features of that is it provides portable abstraction for thread pools that will back end into the platform thread pool system if you have one so under windows it will use windows thread pools and on mac it will use apple's lib dispatch and on linux it can use the dispatch if you have live dispatch and it's got it's configurable to use the the cute thread pool so if you're running inside of a cute you can use their thread pool and if you don't have any of the above options it's got a high performance portable thread pool that it will spin up and uh so so for that reason it gets a fair amount of play at adobe because it can it can basically run anywhere and it's also got an interesting future model it's it has futures with continuations and continuations behave like regular types so you can fork computation by just copying a future and attaching continuations to it going in different directions and it's got an interesting cancellation model where it applies raii principles to computation and so if you let a future go if you let a future destruct the assumption is then you don't care about the result of any computation leading to that future and if that was the you know any computation for which for which the the the only dependent is that future will get canceled and so you can view it as you know within your code you end up with a a graph it can be an arbitrary dag of these of computations leading to futures with continuations with more computations attached to them and as you you let things go the right things cancel so so that's been getting a fair amount of play inside of adobe both are our ai team has been using that and there's an effort to rewrite the photoshop vm system that's been using that so well we are now a bit past the hour do you have more time for more questions or shall we close yeah yeah if there's more questions i can answer one or two more okay let me look into there's two questions about gpus one is about pmr allocators use virtual functions and if you write software for low-level gpu hardware then you cannot use these as allocators if you would like to use allocators wasn't a must couldn't they make it optional to have virtual functions in pmr allocators i you know i've never been an allocator fan because allocators invert the whole part relationship so i'm much more a fan of doing kind of explicit data structures into which you you you uh uh construct objects so so if you need to do those things you know i think every every use of an allocator is kind of hiding an interesting data structure and i don't think allocators get much much play in adobe uh could the v table in in pmrs have been optional okay maybe i mean if you know me i'm not a fan of inheritance anyways uh it could have it could have gone with a type erasure approach uh you know i also think you have gpu systems like cuda which are are increasing looking to just run any arbitrary c plus plus so the problem will probably resolve itself over time as we get more more fluid computation models uh executed on gpus which is you know a huge mess right now right i mean you've got you've got vulcan and cuda and dx12 and metal and uh that's one reason why why we have a significant investment in halite it's just supporting all of these gpu environments as a pain so so that's my answer to that one [music] yeah there's a similar question about how efficient and portable gpu programming could be added to the standard like you know how do you support gpu programming in iso c plus plus yeah uh you know like i said the the you know cuda guys are probably furthest along so you know bryce adelstein would probably be a better person to to ask this question of uh and their approach is just trying to get you know all of c plus plus executing reasonably well on on a gpu the biggest problem that you have on gpus is gpus don't like sharing at all and in within c plus plus it's very hard to tell what's shared and what's not shared there have been you know a few attempts and things like uh adding annotations you know for you know restrict or or don't alias or things like that around around arguments and around data which that tends to be somewhat problematic to use my personal thought is that something along the lines of of cpp2 or along lines of val or even along the lines of rust where where if you have sharing the sharing has to be explicit and the default is no sharing uh you know use the direction that will actually get us to to higher performance general purpose computation on on a gpu all of that said uh still you know the gpu isn't some some panacea the the bigger problem is how do you find things to parallelize within your within your code base uh you know i see an awful lot of code that's written in in environments that have you know an async await model where the the code is you know looks like you know a weight to make this asynchronous call which really isn't introducing any parallelism at all it's uh it's you know it's just just a a weighting along along a single thread it maybe is allowing other things to execute assuming you have those other things and you know for a lot of systems it's it's coming up with you know unless you have things that are trivially parallelizable like you're doing image processing operations or you're doing ml or things like that you know it's coming up with enough work that's independent to execute across you know an 8 or 20 or or 64 core machine so so i think that's where the the larger problem is is is is how do we somewhat rethink the programming model to to scale better okay i think that is a great sentence to end this hama thank you for coming sean hey thank you again it was fun oh yes and with that i'm going to end the stream in a second any last words anything you want to say no if anybody has follow-up questions of like dm me and twitter is probably the easiest way i'm at sean parent so i'm easy to reach and thanks thanks for attending