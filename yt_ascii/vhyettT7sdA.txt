i've been saying this since day one learning to write assembly is one of the easiest ways to get better at programming to learn how computers work at a low level and write better and safer code and the best part is learning to code an assembly makes you feel like a wizard the problem is that assembly is hard to learn and for a lot of assembly variants there aren't a lot of good resources out on the internet that teach you how to learn them quickly now whether you're a student a senior dev a pen tester or just somebody who likes to tinker around with code the technique i'm about to teach you is going to save you tons of time honestly when i was a student trying to learn assembly i wish someone had taught me like this back then this would have saved me hours my technique is called the assembly rosetta stone it's a bit of c code that if you compile it and view it in the assembly that you're trying to learn you can learn all of the basics everything from what the registers are called how wide they are how the stack is used the common convention of that architecture and a bunch of other really important things in this video we're are going to use the rosetta stone of assembly to re-teach myself armed 64-bit architecture now i want to highlight i'm not the first one to come up with this idea here is the author tim ferriss's blog and he has an article called how to learn but not master any language in one hour he essentially says that any language can be broken down into a series of sentences that if you can learn to speak those sentences in the language you will be able to understand the grammatical structure of the language entirely so in this example today you can think of all these different clauses in c as sentences knowing how these sentences work in c and then learning how they work in assembly is the fast track to learning the new assembly variant now when we start learning any assembly language we need to learn the basics of the registers what are the variables in the cpu the hyper fast memory that contained the data that we're moving around so let's get into the rosetta stone and see how we're going to learn that i've created three separate values this is 64 bits long this is 32 bits long and this is 32 bits long i want to see what registers that they get stored in in the assembly and how do they get put onto the stack so with the rosetta stone compiled into our target architecture arm 64. we can then object dump it and then look for our main function to get our feet dirty so here we see babe cafe food face and a couple other sentinel values appearing in the assembly it loads the babe cafe food face in reverse order into what looks like the x0 register let's write that down and take that for note i made a weird x i apologize babe cafe food face and put it into x0 in four different parts and then we run this other operation called store where we move x0 into what looks like sp comma so probably plus 56. what have we just done we actually learned two very important assembly ideas in arm 64 in just a matter of seconds learn not only that x0 is a 64-bit register we also learned how store operations work to store values onto the stack so now we know that our babe cafe food face value lives at position 56 on the stack we'll take that down for note as well so we did learn about the 64-bit value but what about this 32-bit value how does that differ we see our dead food value a 32-bit value get moved into not x0 but w0 what does that tell us about the architecture it's actually very common in architectures that have multiple width registers to contain them within each other you have the larger one x0 that is the 64-bit variant and then inside of that the lower half is now your w0 which is 32. this is the same for intel too where intel has the rax which contains the eax which contains the ax which is just a concatenation of al and ah i have that backwards ah and a l but you see the idea so here we have now learned not only the names of the registers it's x0 through whatever the max value is but also that there are two sets of registers that are different sizes awesome so we learned the names and the width of the registers and then how they get used next we're going to go into the calling conventions fish break so what is a call-in convention this is a fundamental piece of computer science and computer engineering if you have two functions let's say function a called funk a and we have funk b and we have function a call func b function a and function b need to agree upon between each other where the arguments go for that function call and also where the return value goes for that function call also they need to agree upon who is in charge of cleaning up the stack is it the caller or the kali that set of agreements that that convention that they all adhere to is what is known as the calling convention and for you to be able to code in any assembly variant you need to know the calling convention that is used by default in that architecture so let's go learn the arc 64 calling invention right now using our magical c code so what i've done here is i made a function called returnifunk that takes a series of values that we can use to identify the column convention before we do this though we need to figure out where our value i lives so we know how the reference is made in assembly so this value here one three three seven is actually 539 in hex so just so you know that's how it's going to appear in the object dump using our sentinel value 539 we see that 539 gets put into w0 and then w0 gets put into stack location 44 so let's write that down our variable i lives at location 44. and then note this is decimal two this will probably confuse you here in a second so again we're looking for the setup for returny func so we've just learned actually a few things by just looking at this piece of code first of all we've learned that the bl instruction which is most likely going to be branch and link is how the computer is doing the function call it's going to be branching to returny funk and then putting into likely a link register the address it has to go back to that's part number one part number two is we are seeing it set up the function call by putting the address of our variable i into a particular register again don't forget in our returning func function call we take the address of i and then some other magic values and don't forget i lives at position 44 on the stack so here it's putting into x0 the address of sp plus 2c which for some reason they mixed hex and assembly but you'll see that 2c is 44. so this is actually the address of i going into x0 awesome okay so we see that x0 is getting the address of i you'll see that w1 is getting 42 w2 is getting 69 and then w3 is getting 3 1 through 3 7 which are all the values we put into our assembly code and then we're doing that final branch and link so we just learned the calling convention of how arc 64 passes arguments into function calls to call other functions that's really important we need to know that to write functions in arc 64 assembly we got the arguments down how do we get the return value let's check that out maybe we can check out the return values actually by going to returnifunk which is right here typically the last move that we get is going to be the return values remember it takes in a character b and a short c so it's loading the byte into w1 it's loading the short into w2 and then it's adding those two together and then it's putting that into w0 so so now we know that the return value for functions in arc 64 goes into w0 that is awesome and again by learning the branch and link instruction we learned that the value for the return address goes into a link register which is pretty common for all arm architectures okay so let's go into branching and conditional branches so to learn that from our c code i've made this control flow here where i say int i equals some value while i is not zero subtract from i so let's go into our c and see how that plays out we move 539 into w0 and we store that onto our stack we branch to 74c which is right here we then load the value into w0 and compare that value to zero and then we take a branch not equal to 740 which is our loop again and then the loop loads that out subtracts one stores it back and then loads it and then we do that all over again okay so we actually just learned a very valuable piece of information how do conditional branches work how do the fundamentals of if statements for statements and while statements work in arc 64 assembly you load a value to a register you can pair that value to some number and then you do a conditional branch so a branch if not equal and i'm sure there is branch greater than branch less than etc that can all be used to do this functionality what do we just learn we learned not only branching we learned conditional branches and dude we already learned calls from our previous return statement stuff so we're almost done learning the majority of arc 64 in a matter of 10 or so minutes insane what this can do for you finally the last behemoth we have to tackle is the syscall interface so all of this code is welding good we can move data from here to there we can do loops we can do function calls all that stuff but none of it matters if we can't talk to the kernel the kernel is ultimately the beast that interfaces with the hardware below us and print things to the screen does network calls file operations all that stuff so we are going to figure out how we do a syscall by calling by going to the syscall function in the architecture if you remember nrc what we do is we call a syscall function again we have not actually invoked a sys call yet this is a c function that wraps the syscall interface of the kernel we pass the sysrite value the operation we want to do into the first argument of our function so at this point in the code this lives in x0 x1 x2 etc remember that for the the assembly breakdown so here after we get to this location and again w0 and x0 are interchangeable one is 32-bit 1 is 64-bit we move w0 the sys call number into w8 and then eventually invoke service zero which is the syscall instruction for arc 64. what did we just learn what we learned is that to do a syscall in 64-bit arm assembly we put the this call number into w8 and then put the rest of the arguments into that register plus one so if it came from x1 it goes into x0 if it came from x2 it goes into x1 all of these things are how we set up assist call and we just learned that in a matter of two or so minutes now okay remember how i said that this technique will teach you the basics of a language but just like learning japanese for example this technique may teach you the basic grammatical structure but it's not going to teach you extreme conversational nuances and things you would use with your family and friends the prologue and epilogue and arc assembly is kind of like that and let me show you why now normally the prologue and epilogue and assembly is extremely simple and intel for example you do a push you do a subtract you're done here it's a little more complicated yeah yeah so so normally it's not this complicated but this is an extremely complex armor structure that unfortunately this technique won't teach you there are just going to be some of those techniques go google it but in this case this is called a store a pair of registers operation and it's also a post indexing operation so what this does is it stores x29 and x30 at the value of sp at the time and then updates sp minus 80. what that does is it stores the link register at the time the register that's going to contain the return address and the current base pointer at the time onto the stack then from there it's going to decrement sp minus 80 make room for our variables again fairly complicated not super important but i want to make sure you guys saw that and recognize that this technique works for certain things but not all the things and again the function epilogue is similarly complicated it loads two register users from sp plus 80 and then decrements sp80 and then returns by jumping back to where the link register is well guys that's it thanks for watching hit that sub button and then go watch one of these videos where i'm sure you'll learn something just as cool all right you're still here click click a video just pick one it's right there what are you doing okay