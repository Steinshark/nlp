what sucks about goang i saw a post this post in r/ russ and wanted to ask about goang too not the basic criticisms the veros verbosity telemetry but what are your personal bug bears the things that let's see the things that are getting better etc i think i have a couple i have a very simple one i hate maps being default nil air wrapping is really really nice but it also can be a pain i'd like to make sure to always have really good stack races sometimes just like you know when you get an air and you don't have it w properly sometimes it's kind of it's going be a you know you do have to rely on the programmer to really be very very very consistent in its air wrapping and so i find that to be really one of go link's r you know what i mean air equals nil doesn't actually bother me honestly air equals nil never has bothered me all right i'm continually editing the list poor interoperability with other code i don't know what that means like you can't interact with c easily if that's the case then i guess i've never had ffi as something i've had to do so i don't really have like i have i it's just a black box to me i've literally never done it myself i've used it obviously like you know when i use lua and i'm calling into vim i'm calling into to see functions like i get that i get the concept i've just never done it and so i don't really understand what it means by poor uh poor interoperability i don't know i've just never had i've never just had that experience right i don't know what seo is means let's see me let's see means something important ppr function it is lost like i understand all those words individually including cpr i don't know seo but i but i don't get that okay unable to prioritize certain go routines go routines that generate no garbage can be be impacted as much as those creating more garbage okay okay i i could see that being it's an interesting take at least can we agree that that's an interesting take you have no prioritization of go routine so therefore you're kind of just you're sub subjugated to the the whims of the scheduler and that's that i'd say that's fair that's fair let's see poor garbage collection performance with specific types of heaps may be addressed by arenas now well arenas have been you know have been largely said no to i really hope they come back with a new proposal i'm curious what this means does anyone know what this means does anyone like judo do you know what that means what is what does it mean to have poor poor collection for certain types of of objects on the heap like is there something that i i don't understand is it just when you have like strs with pointers with strs with pointers isn't green thread prioritization and anti in concurrency my assumption is that it's almost impossible to get right that's my assumption yeah he he means certain allocation patterns okay so i assume what what he means by this one is is going to be a struct with pointers that those pointers are structs with pointers and so then you just get this like if you want to see if you can collect this thing you have this like whole graph walking experience that you have to go on to is is my assumption of what that means is that is that fair i mean i could i could see that being i could see that being a negative but at the same time it's like i don't know you also create i mean what do you want you create an extremely complex data type with lots of pointers and a lot of you know following and then it doesn't perform well with a generic garbage collector yeah and i think adras arenas would clearly address this but still it's like you kind of get what you get you know if you have really complex data structures and you make them really really frequently you can also pull them so they just don't get collected and then you just don't have that problem right like that could be nice many gotu with concurrency primitives closing channels yes i do agree that the channels though wonderful just i feel like a channels v2 would be fantastic gof funk closure data races the attraction for newbies to buffer channels arbitrarily unnecessary use of concurrency mechanism because they're the first class citizens go routines don't require lifetime management i'm not sure what this this means like you don't need a context to be passed into a go routine so it doesn't get killed is that what that means i think that's what they're trying to say is that you don't need reading this list it sounds like something coming from a game dev perspective ah that's very interesting yeah i would say that if you're choosing go playing as as the language to write games in like you're you're you're you're fundamentally in an uphill battle i think that's fair to say because anytime you're in a garbage collected language you get certain affordances which make writing programs easier but that certain affordances mak certain types of programs by definition hard right so garbage collection is a fundamentally hard activity to have when you're writing games you can write pretty solid games but you're not writing starcraft or factorio and go yeah yeah yeah i think there's things that i think there's things to love and go but there's also like the four things that make go or the three things that make uh channels difficult i do agree like one thing i really dislike is that it's very hard to take an io buffer or an io reader and turn it into a channel i don't know the way to do it other than like you have to it's very hard to do the conversion between the two you have to you have to create your own little reader and that then pumps out into a channel and it's just like you know i just don't love it i just don't love it why would you do it because sometimes you just want to you want to channel you don't you don't want to have to do the reader writer i feel like go is stupidly verbose i haven't really hit the verbose level yet right i i haven't i'm writing a very complex program in go and i do not have any problem with the current verbosity it's verbosity and air handling i don't think it's verbose and air handling i think that's just the difference between i think most people that state that are used to tr catch styled air handling i think if you're used to tr catch styled air handling airs as values feel verbose but airs as values are are inherently nicer right they're inherently nicer tr catch is evil i generally think tr catch is evil i i generally think that shiting control flow is really hard i think that it's it's very hard to get tr catch to be right you know also people also people that consider that typesafe code never handles errors properly yes i mean i mean it's the it's like my big gripe about typescript i've said it a bajillion times so i don't need to like beat a dead horse but typescript isn't type safe because it it just isn't type safe but b it also just has really poor error handling because javascript is poor error handling right it's just it is poor it's not it's not as good as erors as value erors as values will always be the best like every single time it's oh it's always awkward it's super awkward in it's okay to fail situations and so what i mean by that is you have a call and if it fails that's okay you can just go to the next thing so then you have this like tr catch where you have to define the variable outside the tri catch scope block and then set it through through it and then on the outside then you have to check it like it becomes these really long verbose like activity what should i try instead of try catch so when you so i can tell by the way you're asking this you could have you could have dropped this as a a newbie programmer and just asked this and i would have actually known try so you have to try a different language you can't really i mean you can technically get the experience in typescript by using effect or other error result handling objects but the problem is is that you have to call every function with it because you don't know when a function like if you use a library you don't actually know if that library will throw you just simply cannot tell you cannot tell in javascript if something will explode you just don't know and so you kind of have to wrap everything in a tr catch because you just don't know whereas when you're using something like go if it airs it airs every time in a certain way and so you like no you're like okay if i call this function 100% of the time i know this function could er therefore i need to handle it and do something about it which is that's why people say that go air handling is verbose it's verbose because it's explicit it's not verbose because it's verbose now rust has kind of better err it's kind of i only say kind of because remember you have to lift out values and so you still have these big decision points that happen zig might be the most convenient of them all i think go is really really good not much different than fpus yeah yeah either mo ads result objects either the same the same same thing right anyways all right let's keep on going many gotas with concurrency i do agree with this there is definitely some of that this i don't really get but i assume it means you you don't have context required so that go routines get terminated when your context is done but that's kind of more of a skill issue but i do agree it'd be nice to just have autom magic handling right i think we could all agree that it'd be nice to have automagic handling of retains flaky test because of assumptions that don't hold up with current current code i mean again that's your own that's that that's just skill issue that's pure skill issue if you write code in such a way that you have flaky test because of concurrent code that's your fault like real real talk here's a good example of it i'm going to jump over here i'm going to open this up and i'm going to go doom test right here so i wrote the doom i wrote launching doom from go and i did this right here you see what this does right here this forces synchronization so all doom programs once they read their header will let you know when they are ready okay i am now ready and i'm running but i will let you know when i'm ready so i have a forced synchronization point so i so i know that rows and columns are now defined i know everything about the program and so it's like yeah i can i can kind of go through and do i i can i can think through the concurrency problem so when i see this thing that flaky test that's appear your bad right it's your bad synchronization blocking during io channels not as performant as people may expect well i mean it's a mutex dog right there's a mutex in a in a channel so yeah i mean i mean i mean you can't use channels for everything right spawning a bunch of go routines is lightweight cheap according to everything you read but really go does have a of again of course but the cost is pretty lightweight it's no different than like say tokyo right or i assume it's much not different than tokyo it it probably it's within the same operating paradigm as tokyo which is just anytime you have green threads they come with a necessary cost because there's always a runtime associated with it and if you don't understand that i i feel like that's i mean for me that's more like skill issue like they're cheap they are lightweight che like that's proper to say cuz what's the alternative to does anyone know in chat i know there's a lot of newer people does everybody know what the alternative is to a green thread os thread yeah yeah exactly and those things are effing heavy like those things aren't lightweight like you're not you're not getting you're not getting a lightweight experience doing those a yellow one right so so it's like when they say lightweight you got to remember that lightweight is is a relative term you know your mom your mom's a thread ch dude chat is a chat chat a little silent today chat's a little weird today chat's always a little weird today you know it just is okay iota use a numer you say when your whole data structure fails to unmarshal on unknown values i mean that's true in any that's true in any strict type language right so rust does the exact same thing if you have if you have missing values and things if you if your definition does not match what comes in it just blows up and it's just like can't do it i guess i don't know what they mean by this maybe they mean that if there's an extra value then it can't decode if that's the case then yeah that' suck i just thought it would drop it i'd have to check that out iota i agree iota and enumerations are largely dumb no ability to have a static map you can create a function that returns a constant map but then you lose control o over it going on the heap often resulting in package level map that can be modified fighting resisting m mutability in general fair fair fair fair take fair take many apis and packages don't give the caller control of memory allocations i mean it's a it's not a managed it's not managed memory you know difficult to constrain memory allocations sure you can benchmark and eliminate hotspots or add telemetry slm monitoring you can also pull i've never found a good way to keep the lid on it at compile time you can pull right pooling is probably one of your best options here some unit tests can be written to check allocations but those rely on existing code paths i mean i'd say that here's what i got to say i'd say that if you have a hard time creating new memory you're probably going to have a hard time creating new memory in any language i i'm not sure is there is there like i don't really get that critique in the sense that if you can't constrain how much memory you're creating in go i don't think rust or any other language solves that right does any does does anything actually solve does any language solve this i i i don't think so because you still if you have to create the objects you're creating them no matter what c does not solve it you still have to free it right it's kind of strange thing to see zig allocators but you're not actually i mean the thing about zig allocators is you get arenas so cleanup is really easy right you could have your own little arena cleanups and all that so yeah yeah yeah i i i get that but it well it can stop it can't stop you from being an idiot exactly like that's what i'm seeing is that you constrain memory allocations by manually constraining memory allocations and whether you're in rust or zig or or c or go if you create a million objects you create a million objects there's not there's not really there's not really two ways around it a nits a foot gun agreed i i don't use it i've never seen anything good from use it yep just never use it nil interface checks are a gotta to almost every single newbie at some point i got got by this one so i think that this is the the the fact that you can call a function on a nil i think is a fundamentally bad decision the error from is absolutely bizarre and it takes you a long time to realize what's happened i think that that is by far go's single greatest mistake yeah i'm confident in that i'm absolutely confident in that right panic i think panic is fine i i like panic i in fact dude dude dude dude last night i decided to do this i got a little frisky okay in my antsy parser i decided to give it the ability to decide how wide you want your bite do you want your bite to be 8 bit 8bit resolution or 16bit resolution for how big it is or even larger 32bit resolution so i made this idea of these bite iterators and bite writers to be able to go through and write at differ sized widths right which was going to cause like a gigant i i got to quit saying the word right it's going to cause like all these giant headaches but i was smart enough s and madams to do this is that i heavily assert my code and i heavily add in a bunch of state to my asserts so i have this notion in my asserts that i can add assert data that prints it out at the end and so what i did here is that i created a single state object and then i passed that single state object into my assert so when i fail it naturally will cause a nice assert pattern so check this out so let's go back to my little writer let's go back to my rgb writer and i have this whole there we go this is what i'm looking for right there i'm going to take this out for just a second and just go like this all right cuz that's what i had at one point and i'm going to go here and i'm going to go go run go test there we go i think this should work out bam look at that we got ourselves a nice little beautiful we we failed on something but i don't think that that's what i want to do is it an parser or is it go run hold on what's what am i trying to do oh yeah i've made changes dang it i made changes can i go like this add add ccz give me that little czz go like this and let's go like that plus one there we go wait hold on sorry hold on i just oh my goodness why are you lying to me dang it what did i do working example of this thing hold on hold on oh my goodness i forgot that i had i forgot that i had had forget about it forget about it forget about it you know what forget about it forget about it i don't even want to show you anyways i it was so good i wish i could show you but it was so good but effectively the get checkout master get stash pop okay anyways the general idea was that i was able to take i was i was able to see exactly where my parser failed because i panicked the program and the idea is that no matter what i do you'll see aerts everywhere like if i try to produce a frame and my current row isn't the length and my current index isn't the length of the data holding it in like if i'm not perfectly at the end my exact data that i expect i should the whole program should just stop working and i'll print out the current state of everything and so it's i find i absolutely love like i love that i love panic panic is fantastic panic is one of the greatest things ever ex that ever exist bad use of panics not good panic is hot yeah there's also the range bug but they fix that one two two yeah a define bad use if you just panick because something didn't go the way you wanted it to that's not good you panic when the when the program fundamentally you panic you panic in code when when the fundamental assertion about the universe is wrong your universe of course right it's like expect well you don't have unwrap you have expect though in rust right right and so like when you're here and you go like this when you go like if you're in rust and i had like food. expect you know blah blah you know let you know let v equals this right like i'm saying something about the universe this could never break right so if fu was a mutex and i did this in rust like this should always work if it doesn't work then you have like fundamentally broken the universe and your program no longer works anymore and you should just crash the whole thing like get the hell out of here it's broken forever right i panicked in my interview today oh don't panic in your interview jeremy let's see mutex in a struct no idea what it's meant to protect yeah i actually like this i actually like this the reason why i like mutex and instruct so this is so you can tell this person does a lot of rust uh the reason so the thing about rust is that rust if you have a value that is shared across threads right whatever this value is you always have to wrap it in an arc mutex whatever this value is so you have to wrap like an entire struct in an arc comm mutex or if or if you want like you always have to wrap the top level whereas with go let's say that you had a struct that almost all of its operations required no mutex anyone from anywhere could call it except one place then you have a mutex that hangs off of a struct definition right and you know mutex sync sync what is it mutex there we go and then i have this one mutex that exists right here right i'm doing an inline one right there we go this thing right here i now have this one mutex that when i call this one particular function i then can lock and unlock which i think is a much better way to do things it's yes it's more air prone for sure but it allows you to choose when lock happens mutex in instruct makes sense yeah i think it i think it's the better way is there a case where a mutex lock being error wouldn't be we would crash the whole program i do not know when that would happen to me if my mutex i got a poisoned lock like that whole thing is just done various readers and a single writer is a good example of this exactly like you don't need you don't need this super complex like i don't need my whole struct wrapped into mutex to access because then if you just want to access a read value and you have rights coming in you have you can do readwrite locks but still you have to like interweave them or you could just have a bunch of methods that that do a bunch of reading and then one than one that does that mutex in a struct feels like a design smell it doesn't feel like a design smell to me at all it feels like you're designing a program you're designing a program that makes perfect sense right and to me that's just i i like that i like it i like it i like it go routine lifetimes are important to manage but go gives you context context and says good luck yeah i mean you already made that you made that point earlier up here i think i'm not sure i i don't know how i feel about context yet i'm still a newbie when it comes to passing around context and really taking that into consideration my program i'm still a noob so i don't have a i don't have like a good feel for that yet seemingless endless pr comments this function method constant struct field return value is unused this is great i love that i also hate it but i love it did you mean to initialize this struct something something zero values are useful are zero values ever useful i don't know maybe don't export this mutch struct field method yeah i mean but you just didn't export it come on something to do with constraining mutability okay that's fair i get it that go lets you have more mutability so it is harder so i i do i do understand that import ordering i've never had that as a problem things from effective go that could be built into tooling okay i mean that's just a a tooling issue maybe but that's if effective go is considered the the deao standard other notables defer almost makes me let's see makes the suck list for me in a large codebase it's frequently cause contributing a contributor to issues i feel like i i want to say i agree with this one i do want to say i agree with this one i do want to say i agree with this one just because it is a pain in the ass to deal with defer why is my cursor flickering it flickers only over hdmi i don't i don't know because i've been bit by the defer many many times s like it's it's weird to me to have a server that you have to close when it's when the program ends like that's one thing i like about rust is the drop like drop closes the server you know what i mean like drop closes the server so it's like why why do i have to deal with with that drop is a trait in rust i know and so i love i i like that defer makes a foray yeah yeah it's not about having to close it it's about clean up since there are no destructors yeah exactly i don't know how i feel about that like destructors are interesting shall we say i i know they're a pain in the ass and there's so many like the the inverse ordering of destructors and all that stuff could be a huge like a huge source of bugs but they're also really nice but defur is used for so much more than closing connections i know it's used for closing files it's used for a lot of things ass mentioned so much ass being mentioned i don't know i'm not sure how i feel about it yet i'm sure there's some good cases that i'm missing but defer i can find that to be it's both really really fantastic and it's a really big pain in the ass go format and go vet could be much better yeah i mean that's a personal opinion thing i do agree like me personally the fact that like something that i will never like about this there's nothing you can convince me to like this like sorry wrong casing to screw off all right like this oh i can't even format right now like that there you go that's the one i'm looking for like that i hate that i hate that i hate that i hate that i swear there's sometimes where it it puts the plus sign right next to it as well but i hate that i hate i hate that it takes away the spacing like it's not that i dislike it it's that i hate it which is much different there's a huge differ a huge difference between me just like it's actually anyways that's like one thing i hate so yes i i i i do agree with that one statement i hope you never need to check the return value of timer time timer stop i didn't even know there was a return value future you will appreciate if you start passing context in time as an argument starting today okay i don't understand the time part but okay a context i know i need to start using it more but i don't but that's more like just creation your time will come where you don't capture a loop variable that's gone that's a gone one you know what i mean this is no longer a problem one 122 solves that one 122 actually properly uses it some of these might let's see some of these things might not be things that suck about ghost specifically i wrote what first came to mind okay i mean i like this list i like some of the lists some of them i don't like overall pretty good critiques the thing is is that every language sucks they just suck it just sucks all the time and anyone that thinks that that there's actually some sort of silver bullet to make programming nice dude someone's selling you something you know what i mean someone has officially someone has officially sold you something wait we got coffee again me this account is such a troll account this is such a troll account they're mean to me anyways you just got to choose what you you just got to choose what you saw dude look at this you guys want to see something that's totally messed up they're now following me again that was nice of them they quit following me for an afternoon just to mess with me look at that it just unfollowed me who does that who does that who does that adam is so toxic i think that's the thing is adam is so nice on the internet because he can be so toxic i did that yeah adam gets to be so toxic via terminal do shop that he that he gets to be nice on the internet and then just alt accounts that was me look there's even adam right here i want the credit turd just a turd okay yeah good list good list overall follow terminal shop they'll probably not follow you back the name the name is the prime engine i do like ghost i still highly recommend go by the way i i've enjoyed it i've had no problems with it i think it's just a fine language i think any i think i i i honestly think the biggest critiques about go they're not they're they're definitely not great it's definitely a language that you learn with exper experience and as you have experience you avoid most of these problems i'm just trying to think of a language where i i i don't have the same thing it just looks different you know like honestly i don't i don't know of a single language that doesn't have the exact same problems javascript has the same things rust has the same thing like rust most certainly has it like you will find yourself refactoring add infinitum like forever you will you will refactor continuously in rust if if you don't if it's the exact same thing you have to know how to do the the the rust thing right so like each one of them is is is this you know each each one of them has their own pain points so whatever the name you know what the name is