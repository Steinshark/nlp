i am looking forward to your talk anyway thank you thank you for having me welcome to the audience i already chatted with some of you in the mingling area of the networking and i when the ins asked me to give a brief talk i thought about several topics and i came up with the beyond the rule of zero it's one of my pet areas where i work in for those who haven't seen or known me i'm i used to be a professor but i'm now independent and work from home consultant and trainer if you like to have your company get c plus was training especially in the area of safety you can ask me for a quote what is the rule of zero and for those of you when when we prepared for an audience told me well my slides are like a professor slides they're very full and complete and too much on them you get a qr code where you can actually download the slide pdf with some additional explanation for some of the slides where i had the time to actually provide some more notes explaining stuff that's are not self-explaining so if you are able to pick the qr code you can find them otherwise you can navigate my github and for talks public repository i try to collect most of my talks at least the pdf of the slides and you also have seen my coordinates i'm regular on twitter maybe too much but you can reach out there and if you don't want if you want something for me so what is my philosophy that is something i more or less borrow from kevin henry a good friend of mine less code is more software so if you write a lot of code it might not be the case that this code is actually easily to understand so my goal is always to say the same thing with the least amount of understandably code that doesn't mean to have just one letter identifiers but to not have let's say elaborate things that the compiler would do for you anyway and this is part of what this talk tonight is about so if you and rule of zero it's all about you design a class type and then you have to figure out what special number functions do you have to provide especially do you need a destructor what kind of copy and move operations should you supply and the rule of zero molar says don't if you look at the options that you have you have a five special member function in that area the destructor the copy constructor the copy assignment operator the move constructor and the move assignment operator in theory each of those could be either be public protected or private gives you five times three options and then if you look at the body or the definition of those things you can either have it defaulted deleted or somebody actually implemented you might even have it not even declared which is actually the good thing to do if you can get away with and that this gives you about 50 options on how to spell those five functions and one of them is actually the rule of zero if you don't declare any of those and the other 50 are not all very same some of them are and this is a talk today and just consider you can spell copy and move operations also differently which i don't want to go into right now now some of you might have seen this table in at accu 2014 howard hill and the more or less inventor of move operations for c plus plus actually provided a talk explaining this table this is about what kind of special member function actually you define and of the six given here which of those you the compiler either provides you or doesn't provide you or will suppress or enable if you define one of the others and if you look at this table there are this reddish part in the middle if you define a destructor or a copy constructor or a copy assignment operator you still get the copy operations or the opposite the other copy operation provided by the compiler which means this is mostly wrong if you have these one of these things that is where scott myers c 203 rule of three came from if you define a destructor or a copy construct or a copy assignment operator you should define all three of them for your class to make sure that your class behaves samely this got more complicated with the introduction of the move operations now we have two more operations to care about and also we have some influence on the default constructor which is either compiler provided or not depending if you have another constructor defined amount now what can we do this table i think i counted 42 entries actually it's 42 plus one line nevertheless it's an interesting number but it's not really helpful so some people know this table by heart but i [music] myself and might know it by hard like working with about three to five years with with it and and explaining things to others and then giving talks about that but i think these this table is not something every ac plus programmer can actually consciously apply every day in in his or her job so if you look at the core guidelines there is a rule of zero in there a c dot 20 says if you can avoid defining a default operations too and the reason it's the simplest and gives the cleanest semantics simplicity is good less code is more software but actually what it means the rationale to me is is a bit weak it doesn't really give you all the insights you might need to get to really appreciate the rule of zero there have been through the school of thoughts who say okay always define all six and make them default if they are and delete them if they aren't and do something special about but that is already complicated almost on the level of knowing all of the table i showed you in the previous slide and apply it consciously so what what can we do about the rule of zero what i say most of the time your classes should actually implement the rule of zero so you make your class in a way that the compiler provided or suppressed default operations just work as you expected because even if you define a special number function as equals default or even equals delete might change the semantics even if that would is exactly what the compiler would do for example if you considering my memory memorization of the table if you have a copy assignment operator and copy constructor and define them as equals default because you know the compiler provided versions are actually okay you make your class pessimization because the compiler no longer provides you with the move operations and that can be an issue or it cannot you don't know depending on the class sub-object so it's members and base classes either it's okayish because it would cop a move would copy anyway or it's not okay and that is a an interesting thing there is some exceptions for default one is we see in a moment and the other one is if you have a have to define a copy or a move constructor you might suppress a default constructor and then using equals default to resurrect the default default constructor is a good thing to do so the question is if i do the rule of zero always then they're somewhere it's got my ass trials out yeah but there are cases where where you you shouldn't scott myers original rule was quite silent about the actual cases when this should happen when you should care about copy operations under the structure and this is where i would like to give more guidance and most of the time except with some small print in the edges you need to deviate from the rule of zero if your class actually needs to define this structure that is the main reason when you deviate from the rule of zero and the question is when does your class need to define a destructor and there are actually two major cases and we will see them in a second the one most prominent case is you're designing a class hierarchy with virtual member function in the base class and if you put objects of that hierarchy on the heap and want to delete via base class pointer you're risking undefined behavior when your base class doesn't have a virtual instructor so the core guidelines says they tell us in c35 a base class instructor should be public and virtual and forgot to forget about a small print i am not sure that's really reasonable and useful most of the time except for some special cases and also the core guidelines tell us okay compiler provide a copy operation with slide will slice objects via base class reference so when you have a class hierarchy then the default operation is provided by the compiler and you will get copy that's a red part in in the table we've seen then you will actually have the problem that your compiler will might take your derived class object that is behind a pointer or reference and silently copy that so to if you have a hierarchy you only want to have your classes referred to by a point is a reference to base class to you actually use the polymorphic behavior and this means you should suppress the copy and move operations now the question is what is the best way to do so if you look at the old ways how to do that we have some old options we can actually in c 203 and 98 it was common to have a private copy operations so declare them and not use them and the compiler would not be able to copy your objects because there's no definition and actually it has no access to the private declared copy operations the other option would be provide protected copy operations still the compiler wouldn't be able to use them directly but there's a derived class could actually provide copy operations based on those and the last thing or the simplest thing without spelling the the easiest to spell out was to inherit from a non-copyable class like boost non-copyable or all your other derived classes that inherit from the base class that is non-copyable will also be non-copy and prevent further slicing down the hierarchy in c blasphemous 11 we got new means on how to define things like we can actually define the copy operation that equal delete and we have a class that should be non-copyable and c we can delete the default the the the copy constructor but that means we have defined the cons the constructor so our default constructor is gone by that that means we have to resurrect them and we can delete the copy assignment operator and so we actually to get rid of the copy operations and still have a default constructor requires us to actually define three special member functions out of the out of the six possible constrain those that we have in addition deleting the copy operation also disables any move operation which is intended in that case and i think that was a reason why this was chosen but again it's a lot of code and it's easy to get wrong what if someone actually changed the delete here to become an equals default accidentally or typo or whatever it's really easy to get things wrong and messed up and it's also hard to review because delete and default are visually very close and really easy to mix up or actually they might be written default and you read delete because you expect it to be equals delete so the question that i ask myself after seeing how it's stable and some ruminating maybe several years is how can can we do that in a simpler way suppress copy operations like for polymorphic based classes and my answer is yes it might not be a common one but i want to make it popular that's one of the reason i'm talking right now so if we look closely at the table if we define in the lower right corner if we define a move assignment operator we get no move constructor we get suppressed the copy and copy operations and we keep the default constructor because we haven't defined any constructor and this means we actually can define the move assignment operator as deleted and get exactly the non-copy ability without losing the default constructor and for a polymorphic base class means we have a destructor defined and still get none of the unwanted operations that we want and i called it nicknamed it the rule of this the mover and that abbreviation because it's close to destimona it's okay the structurally fine you delete the move assignment now if you look at the polymorphic base class in my book if that is the case you always have additional virtual members there might be special cases where you just want to have the type id hierarchy and dynamic passing things but i doubt that this is a very common so you will have some virgin and functions you define an interface by some virtual member functions and then you will have a virtual destructor and because your base class should be kind of abstractish at least shouldn't have too much infrastructure in it so that the derived classes actually can have their own variation of the the interface you might want to have your destructor defined as virtual and defaulted now because this is a base class you want to suppress copy operations and the rule of this the mover allows us to make it very simple it's just a single additional definition of the deleted move assignment operator and you still get a default constructor so your derived classes don't have to hassle around inheriting because you might not have a default constructor or have to resurrect the default constructor and that's the least amount of code to write to get that polymorphic base class i could give another talk on why not to do a polymorphic basis today in modern c plus plus but there are other people like sean parent who have talks on that you can and should follow now the only other means where you have to actually have a destructor defined is when you use a raii resource acquisition is initialization or some more modern we talk about scope based resource management that is when you actually find a structure with the body that does something that releases a resource that was previously acquired in the constructor so we need to care about about their different situations when you do that and one warning if you ever write your own resource management classes and don't just use a unique pointer because you just your only resource you manage is a memory or a file stream object because you have a file as a resource if you ever do do diy resource management never attempt to manage more than one resource in in such a class i tried with the unique resource which is in the p52 paper of the that was moved into the standard library extension paper not in the standard and i can guarantee you it's really error prone it took several people helping me to make it semi or almost correct i'm not sure if there are still corner cases not covered by the implementation where there might be leaks or interesting thing happens especially in the context of exceptions so it's much better if you have multiple resources to manage write an rai wrapper for each of them and then combine them in a class that is a rule of zero class in the end now if you want to manage a resource you manage a single resource as already set there are three options how to manage that resource from simpler to more advanced the most simple one is a scope manager this is a managing class that acquires a resource in its constructor and actually releases in the destructor it might provide operations that operate directly on the resource or it might provide an accessor for getting a reference to the resource to to use later but usually you will have some actual functionality unless the acquiring and the release of the resource is the only effect you actually want like for example a scope block is providing that in the center library to make that actually non-copyable non-movable you might already guess we have the rule of this the mover to achieve that the other the next level let's say of the thing is providing a manager that allows to actually give away the resource to another managing object like a unique point address with the memory you can only have one unique pointer actually managing a piece of memory but you can hand over you can transfer the ownership of the resource from one unique pointer to another one and that is the the benefit of the move operations one of the possible uses of move operation is that transfer of ownership ship semantics provided by move operations this should be used for resources that cannot easily be duplicated but where you actually need that transfer of ownership semantics because for example you want to put these things into a container and and keep them around that is when vector for example requires you to have a movable type otherwise you cannot put it in a vector easily and then there's the the really expensive thing is the the general manager of the manager with the value semantics where we actually can copy the resource and the managing manager type will need to actually provide copy operations that make useful copies of the resource for example scented stringers and vector are resource manager types that manage the underlying memory and they allow the the copy even if it's expensive the copy operations to you can copy a vector and get a new vector as a copy and it's still let's say it has a value somewhat expensive a new vector new object and a new memory source for the copied vector if you go even more advanced you provide also the move operation for these general manager types this can be done to achieve an optimization like the move operations of a vector or string that actually hand over the resource so do the transfer of ownership in the context of a move operation instead of copying to get the efficiency thing now i provide you with the code schematics on how to use how to implement those the scope resource manager will keep the resource at its time as as usually as a private member to avoid let's say direct access it will require the resource the constructor will usually have parameters to actually specify which kind of resource you actually want the destructor will have a body implementation somewhere to actually that actually releases a resource and we the simplest thing to suppress copying is here delete the move assignment operator and then you will get the non-copyability you still can return those things from a factory function if you if you like to for example if it's a generic type and you have a template parameter that you wanted to use and it cannot be easily deduced from just the constructor parameters also you might want to use a factory function if you have let's say an embedded systems exception disabled the only means where let's say a constructor can actually signal that the resource acquisition failed is by throwing an exception if you don't have exceptions you actually would need a factory function to actually return like an optional of the scope resource to make sure that if the the the resource acquisition failed to return an empty optional instead of the actual manager type if you have that case where you might have a resource manager that is empty a unique manager might actually be the better choice a canonical implementation would i could actually use a standard option of the resource type to make sure that you have that extra state where it says oh i don't hold a resource this is required if you move from such a unique manager you actually take the guts and somehow the unique manager needs to memorize okay i'm empty now i don't have a resource i'm not managing a resource my destructor cannot release anything this is to prevent double releases which might usually might be not the thing you want to so we because we have to define a move constructor you will actually have to resurrect the default constructor when the case of optional will actually create as an empty option which is a good same thing to actually define your move from state the standard library tries to wiggle around and they have been in recent let's say even more regular way for moved from object state and not relying on anything but if you define your only your own class you better know what you moved from state is for your class because otherwise you will be very insane need to do it let's say your code might be might be not easily understood or samely used by others so how do we actually implement the move operation well we actually move the other resource and in the case of the opt because we we manage it in optional we have to say that the right-hand side of the move operation is now empty and the standard option allows us to reset the optional to make it empty assignment is similar the only thing we have to take care about is prevent self-assignment because otherwise it might actually assign to oneself and that would be the same as releasing the resource which is not something you easily should should do that so if you're not self-assigning actually reduce release the own resource and swap out the two resources the release operation has to check if the option is actually engaged and then the actual releasing has to be done and the you disengage the the optional so this the comment actually is where the actual resource release is happening and the destructor as is if that operation that you have to define here throws an exception or my throne exception it's better to actually wrap it in the try catch block because you want to make release of the release operation no except because it's used in the move operations and the in the move assignment and the destructor and you better not throw from those operations otherwise your code will not behave nicely in in with the standard library or with other code now the general manager i cannot give you much more of the information but you it heavily depends on what kind of resource you have if you have memory as a resource use a unique pointer or a vector or a string or a similar container if you really need to invent your own take care to mimic their behavior you might copy the idea from the unique resource to use a standard option for managing the resource to have your empty case especially vector or string don't need that because they can employ the null pointer or have a length or a pointer field to to set to zero or null pointer to recognize that they are empty other types might need more here we actually if you want to implement the optimization with the move operation that means you actually take the gut stealing so i sometimes show that with the mailboxes here where you say okay i have a full mailbox on the right hand side of the move operation an empty mailbox of the left hand side if it's not empty you will empty it before you move and then in the end you will have the left hand side will contain the the the actual resource the letter and the right hand side will be empty that is where actual move happens if you not define those operations classes still movable it's just that the move operations will be a copy operation i say expert level coding because copying a resource especially if it's not just memory an operating system or some others you might either not be able to copy or copying might be much more involved than it then you would need to so silently copying might be not worth it so unique manager might be more the thing that you actually implement yourself now to close up is the rule of zero actually rules write all your types with the rule of zero in your mind and very consciously deviate from it only when you define a polymorphic base or a manager class it's really rare to have the rule of th to not apply the rule of zero you might see a lot of examples that don't apply the rule of zero but most of the examples in let's say in textbooks are otherwise are made up examples or not really complete code so they might not actually show the actual situation so you where you would use it that is one of the pity c plus this is too complex it's very hard to explain a lot of the details that might be required sometimes to an audience without showing code that is too messy to actually understand that is a pitfall that's one of the reasons i try to explain the need for copy and move operations with my manager class concepts never ever define an instructor with an empty body i've seen a lot of code doing that especially old code even the master in the the rover code has plenty of classes with an empty destruction with an empty body that's completely superfluous code it's looks strange it's not really providing you with something useful and it clutters your code especially if someone actually puts something in the pretended to be empty destructor and it also suppresses the move operations that might optimize other your code otherwise freely by the compiler so never ever define a destructor with an empty body and the comment doesn't count so that means you only should define the structures with a non-empty body if you actually know what to do then and if you need to release a resource and then consider let's say a scope blogger also be a manager because you more or less manage some output stream by providing a let's say an entry and exit of a scope for example if you have a virtual instructor equal default is it it's very rare to have a polymorphic base class that also in addition is a managing type it's best to separate these issues and it's very rare i know in the standard library we have let's say some some stream objects that are polymorphic but even there the management actually happens in the derived class and like the string buff or file buff and not in one of the base classes and remember there are three kinds of managers and even if you don't like ties and don't wear ties i no longer wear a tie for several years now unless it's a very special occasion but nevertheless managing types are your friend this is where actually c plus shines where the destructor makes sense and with the cleanup the automatic cleanup is the killer feature of c plus that is great and remember the simplest way to have an uncopyable type is rule of this remover or maybe inherit from one use my rule of three for unique managers where you define the destructor and the move operations make the move only and remember the classic rule of three with the copy operations defined for general managers or six where you have all let's say copy move default constructor and instructor for general managers but those case should be rare and should be written by well-educated people not in the first on the first day of the first course c plus this course just there stick to the rule zero and if you go to your own code tomorrow or tonight or later today depending on the time zone look at your code look at your classes figure out where you have manager types where you might still have empty body destructive empty bodies get rid of those simplify your code make your code simpler and get more software out of it i stop now there are many things missing like for example how sub objects like bases or member variables of your type will influence your types behavior even the if you stick with the rule of zero having a let's say a non-copyable base class makes your class non-copyable if you have a unique pointer as a member your class will be move only and the other things that influence your types values types that are copyable are usually always good if you for example empty types can be used for mixing based classes and they don't do any harm unless you use a reference to them we have relationship types and i'm mistyped the list sorry for that with references pointers use bands and we have non-copyable types and move only types already said that and what you can read is usually not important and if you need to reach out for me or still want the slides you can actually use the qr code and i'm sure they will be more q a and discussion later on and i'm hoping jens will chime in and help me how to proceed now