today i'm going to cover the unit of work design pattern it's helpful to learn about this pattern especially if you regularly interact with the database the essence of what unit work does is that it gathers all the transactions and execute them all at once why do we need this you might wonder i'm going to talk about that in this video and not only that you'll also learn that this pattern is useful in a few other scenarios as well if you're reviewing someone else's code you can impress them by mentioning that they should use the unit of work pattern and for other tips on how to more easily find problems in your code check out my free code diagnosis workshop at the link below it's also in the description of this video the unit of work design pattern is similar to the command pattern but the main thing that it does that it serves as a sort of collection point for multiple operations and then apply all of those operations all at once and in particular in databases that's very useful because then you can create a number of changes that you want to apply to the database and then commit all of the changes all at once so that saves in network traffic but also means that if one of those commands fails that you can actually implement a roll back mechanism and especially in very sensitive areas like finance or other things where you want to be really careful with what happens with the data where there's lots of connections between different types of data then it's helpful that you can do this sort of roll back mechanism i'll first show you a very basic example that doesn't have any external dependencies just to explain how the pattern actually works but then i'll shift to a real life example using a database so here i have a simple example that defines a user class but you know could be any type of data that you want to work with and there's another class called unit of work that encapsulates the unit of work pattern and this unit of work class contains a sort of track record of the operations that have been performed so and a new uses that have been added any users that have been updated for dirty users or any us that have been removed and then we have a couple of methods to add these type of operations so we want to be able to register a new user we can register a dirty user use that needs to be updated and we can also register uses that need to be removed and then we have a commit method that does the actual task of performing the work so it inserts any new users it upat dirty users and it deletes any users that need to be removed and currently that does nothing because there is no database connection this is just a simple example but then here you can basically perform the actual operations and because actually committing the changes is a separate method you could extend this method and also add a roll back mechanism so for example if this method raises some sort of exception then you can undo the insert operations that you did here basically you roll back the changes that you made and here i have main function where i simply have some testing code so i create this unit of work thing then i create a new user i update another user i remove another user and then i'm committing those changes so when i run this then well this is what we get right these operations are run all at once when i call the commit method another type of pattern by the way that you'll see used in tandem with the unit of work pattern is the repository pattern so unit of work really focuses on the operations the po story pattern focus on providing an abstraction layer on top of the database so you can interact with the database without knowing all the implementation details a very good example of a library that combines the repost story pattern with unit of work is sql alchemy i've been using this package for a while now it works great and it's also in many of the examples in my youtube videos and typically unit of work or repository that's not something that you're going to implement yourself from scratch but it's good to know that it exists and how it works so here i have a slightly more complete example that uses sql alchemy and in this example it just uses an in memory database because i don't need a real database in this code example i do the standard things like creating a session and creating a declarative base which i can then use as a base for the orm so then i have a couple of classes so i have user class that has an id which is primary key user have a name and there's also some relationship so users have details and there's also some preferences the exact structure of how this is set up doesn't really matter it's more about using sql alchemy and the unit of work pattern that's built into it so have a couple of other tables as well user detail and we have user preference which contains some user preferences and then i have functions to create a user to update the user and delete a user and get a user or get all of the users and then in my main function i call those functions to work with the actual data in the database now the or part of this which is the definition of these classes that provides a sort of repository pattern implementation it's an abstraction on top of the database we don't directly interact with the database we interact with these objects and that results in changes in the database so the way this works in sql alchemy is that for each of these functions that do some interaction with the database i pass the session object as an argument and then i use that to specify what operations need to be run so in this case i've created a user i've added some details and preferences and then i call add on the session object and same for for example deleting a user or forgetting a user so i'm interacting with the session object to perform these operations and session has a commit method that actually does the actual work so before before you do that nothing has actually changed in the database and that's exactly what unit of work does here you see an example of how you can use that so create a session which i then yield so i'm using a context manager here and then after i've completed working with the session i commit the changes but if there's some sort of exception happening here then i'm calling session. rollback so that undu the changes made until now in the session and finally i'm going to close the session and how do we use it well we have have a context manager so i'm creating the session here so then i create the user i update the user and then i can perform the operation so as creating a user so like i said while you work with the session nothing actually changes in the database but if you do need to make a change in the database for example here i'm updating the user but i can only update the user if it's actually being stored in the database then you can call session. flush in between so when i run this code it now does all of this works so first i create the user you see initially this has an id of none because it's not yet being committed to the database but then i do session. flush which actually stores it in the database and at that point when i print the user again it now has an id assigned to it so then i can update the user so that's actually what's happening here and even though this has not yet been committed to the database locally the user is already updated so when i get the user later and then print it then it's actually going to show me the updated user already and then finally what i do is simply delete the user and after all this work i create a new session i get all the users and then i print them which of course after that is an empty list because i deleted the only user that i created so in terms of the flow after all of this has been done then the width statement is finished so the session is committed and then it creates a new session here to actually print the users so let's see what happens if we break this so let's say we erase a value error here and what's going to happen is that these things the updates and the creates they're going to be rolled back so let me run this code and then you can see this is exactly what's happening here so it created the user but we're rolling back so in the end what we're going to print is still an empty list because the creation of the user has been rolled back because this particular unit that we were working in here it raised an error and this happens when i raise an error explicitly like this but i can also for example make a mistake here in the id so there is no user with id3 so if i run it down we get the same thing so there's an error user three not found and it's still rolling back and we get the empty list again at the end what we can also do is take this part and turn that into a separate session so now i'm simply creating a user and then let me remove this and what's going to happen now is that this will create the user that's going to be committed to the database then that let me just remove this then it's going to update the user retrieve it and delete it in a separate session and then it's going to simply list the users in the database so here now i'm deleting us that doesn't exist so that means that these things are going to be rolled back but this is separate session so the user is still going to be created so when i run this this is also what you see will happen so now it didn't find the user so it's going to roll back right it did perform the update here but that's exactly what it's rolled back so the in the end when i print the list of users i'm going to get user with id1 and the name is the original name that was defined in this particular unit of work so unit of work can be useful in particular in database operations where we need to make sure that the database stays consistent it can also help clarify your code because it allows you to group operations and see what each of the transactions includes and that can be helpful in debugging for example and by the way if you like these types of discussions you might also want to join my free newset or simply go to my website arnold.com and you can subscribe there for all sorts of interesting news about python and the software industry in general now you might think okay so great unit of work that's useful for databases but actually it's a pattern that you will also see in other areas as well not just databases in particular in areas where we need to manage some kind of comp complex thing and we want to make sure that it stays consistent one example is a file sync utility like dropbox you know if you sync a large file and the network connection fails then you want to roll the upload so that the cloud storage doesn't contain some sort of corrupt file and services like dropbox do lots of other things of course to make sure to keep things consistent another example of where a unit of work might be useful is in games you know if you need to save a complex game state with all sorts of settings and things and if there is a problem saving particular aspects of the game then you might want to roll back and undo whatever you already saved a third example of where unit of work might be useful is in infrastructure of code to provision cloud resources so let's say you want to launch some sort of service that consists of a database several servers storage you name it all sorts of different things if halfway through the provisioning of all the resources there is some sort of error you want to roll back and undo creating all of those other cloud resources so you don't pay for things that you're not using so committing and rolling back unit of work it's also very common in infrastructure as code systems so i hope this video helped you gain an understanding of what unit of work actually is and like i said you probably don't have to implement this yourself but it's good to know that it's there and that if you're using sql alchemy that you can use committing and roll back to make sure that your data stays consistent here's question have you used the unit of work pattern yourself when interacting with your database are you relying on being able to commit and then roll back the changes in some of the things that you do or do you have any ideas for other areas or the domains where the unit of work pattern might be useful apart from the ones that i already mentioned let me know in the comments now sql alchemy is a big backage that has lots and lots of features if you want to learn more about how to use it in order to interact with your database watch this video next thanks for watching and see you in the next one