ready to go yes we are next now with live with the next talk which will be matt bentley we have a bit of an echo so i just ask you to get started okay hey everybody so title of the talk is performance maners new tricks for old dogs if you're not familiar with the english phrase it's you can't teach an old dog new tricks so that's what we're going to attempt to to do today so all the stuff that we're covering is stuff that i've kind of done in the past or this year or that sort of thing just a kind of collection of stuff really so we're going to go through three algorithms three containers and one issue which will remain mysterious until the end so the first algorithm is pf fre order ray which is a portmanto of reorder plus arrays if you're not sure what a portmanto is it's a combination of two words form a new word second one is plf list which is a more case friendly or unrolled list pf ind sort which is a port manto of indir plus sort p q a faster better q p stack a faster better stack and sectors which is a method for random access in containers with multiple memory blocks and a growth factor that's the literal name of the paper that i wrote which is on the website pb.org all of this stuff is on pb.org now so first thing p free order rays evolution extension of the swap and pop idium most people are familiar with swap and pop idm if you're not basically if you've got a vector or a deck and you want to erase from anywhere but the back of the container or the front for deck and you don't care about element reordering what you can do rather than erasing and then having all the elements reallocate backwards by one which can be quite slow if you've got a very large l or non-trivially copyable type or just a large number of elements is you can swap the back element with the element that you want to erase and then pop the new back element which is pretty fast most people nowadays realize that instead of swapping and popping you can just move and pop instead which saves a bunch of instructions and also means that you don't have to allocate a temporary buffer for the swap so this is basically what that is but templated and it covers all the sort of odd cases so it's only useful if you don't care about element order basically what i found was that this pattern also extends to range rasure provided that you take into account the potential overlap between the range that you want to erase and the back range you've got to try and kate that range and it also extends to sray sray z type functionality basically it ends up being the equivalent of range er asia using the return from sid partition with an inverted predicate as the beginning part of the range but without all the unnecessary swaps and copies that you get from partitioning operation so i'll just give you some performance results so through this talk going to do be giving a few sort of benchmark averages because don't have time for individual benchmarks only got an hour so everything that i'm giving in is an average across numbers of elements ranging from 10 to a million with 4840 and 490 by types for reorder is the performance more or less linearly scales with the size of the type and the number of elements and also potentially for some elements whether they're non-trivially copyable etc so singular erasure averages is about a million times faster than a raise position with a minimum of 10% that's like 10 four by elements for example and a maximum of 25 million which is like 1,490 by elements right ranger ranger not quite so fascinating averages 12,000 faster than standard ordered erasa with a minimum of 20% and a maximum of 77 1000% scan eraser averages 38% faster than cay if with a minimum of 0% and a maximum of'0% so that gives some good reasons to use this over regular erasure if you don't care about order right so range erasure just go briefly into how that's done so we've got the area that we want to erase in the middle there and then we've got the area at the back that we want to move into that place we've got an overl ap and basically the overlap nothing happens to it it just gets erased so all the area that isn't overlapped gets moved into place and the area at the back gets erased so that's basically it so the advantage of using what i've done over rolling your own i mean you can just roll your own templates is fine but just takes care of edge cases like nonmovable and nonno throw copiable types in those cases it will actually allocate a temporary buffer just in case there's an exception during copy processes in which case it'll copy the elements that were going to be erased back into place it's also optimized for deck so it'll move and pop from the front instead of the back where appropriate highly optimized users men copy when the type is trivia or that sort of thing and it also introduces a range based st ra st raise if style order unordered eraser so basically s sas of for when you have a sub range of a container that you want to arrange certain types from rather than the entire container so here's an overview of how that works so you've got the range that you want to raise certain type of element from in this case the 12 so we move elements from the back but there's a 12 at the back so we can't use that one 12 gets moved to where the 23 was and we're pretty much done that's kind of simplifying a but it a bit but it gives the general idea so that's the first algorithm of the day moving on to the first container of the day this is pf list which is a cas friendly linked list i did do a talk on this at pacific c++ in 2017 that's on the website if you want to kind of know more than what i presented here you can go to that talk made one or two mistakes in that talk but it's all right so the first thing you might ask is is okay performance why do you care about a lynch list fair enough lynch lists do have some positive performance c characteristics in some circumstances they have the fastest singular nonb backfront eraser in current stood containers if done during iteration or if you already have an iterator to the location that you're wanting to erase they have the fastest nonb front ordered insertion of stit containers they have the fastest sorting for large or non-trivially copyable removable types why is that it's because sought for st list doesn't move elements around it just changes the values of the previous and next pointers that those elements are attached to so when you've got a very large or non-trivially copiable type it can be a lot faster to just be writing a bunch of pointer values rather than actually moving elements around and that sort of thing even if the elements themselves aren't contagious in memory the next point is something that people use st list quite a lot for including an open source projects like labor office iterates and pointers to non-ar ased elements stay valid regardless of operations around them for example if other elements get spliced in or erased or inserted or emerge happens the iterators and the pointers to the non- erased elements stay valid which can be quite important if you've got for example multiple containers hosting different elements which point to each other which is a quite common scenario in a game engine but you probably wouldn't see still list used in a game engine for performance reasons lists linked lists also give you constant time splicing together of lists and of ranges within lists which can be quite useful particularly if you're returning stuff from concurrent functions and you want to combine the data and it's relatively easy to create c concurrent versions or to use lynch list in concurrent scenarios simply because the arrays and insert operations don't have a lot of side effects so they write a couple of pointers to the previous and next nodes but that's about it so plf list versus stood list performance averages 2 93% faster insertion 57% faster rer 17% faster iteration 77% faster sorting 70% faster reversal 91% faster remove remove us 63% faster unique 81% faster clear about a million times faster for triv trivially destructible types 1,200% faster destruction 63 100% faster for trivially destructible types we'll get to that and 20 to 24% faster performance overall in ordered use case benchmarking i.e when you're inserting erasing and iterating on data in a container over time so just a circle back to clear and destruction so a million perent is a lot so you might be asking yourself why well for a link list if you're wanting to clear then you've got to go through and you've got to destruct all the elements if it's non-trivially destructible but you also have to deallocate each of the elements so you're going through memory generally speaking not contigous in memory unless you're using an allocator and even in that case probably not entirely contagious so it's jumping all over the place in memory and it's just doing a deallocation for every single node plf list allocates nodes in chunks rather than individually and what that means is when you get a clear operation if the type is trivially destructible you don't have to process every node you just say goodbye to all the memory blocks you just delate all of them so that's why it's such a high percentage so how's this faster how do we make it faster as i said it's got more continuious storage because we're allocating elements and nodes and chunks so down the bottom there imagine those smiley faces are elements and so that's how vectors and arrays are stored in memory most hashes maps lists etc are kind of all over the show in memory and unrolled lists decks colony hive etc are all in chunks the second way that we get things faster is having smart erased node reuse so rather than just letting those erased nodes sit there and not be reused we keep track of them and the last thing is that we have an indirect sort techniques so disadvantages there are some disadvantages of this implementation there's no singular element or range-based splicing between lists there's only full container splicing and that's because we're allocating nodes in chunks so if you're splicing with st list you can take all these elements and check them under here and it doesn't matter cuz they're just individual allocations but with pf list you can't split a block in half because then you invalidate all of your pointers and iterators to elements which means that it's not actually a splice operation anymore it's more like a move or copy element oper operation so you do have full container splicing so you can take this plf list and this plf list and combine them and you can also splice within the list so you know taking a range within a given list or an element within a given list and essentially reordering stuff there's also more side effects for operations because you have to keep track of erased notes and this sort of things so it's less straightforward to use an a lock free or concurrent environment so here's the basic structure of it you have a vector of pointers to groups which are basically app pointed to a memory block plus block metadata the memory blx starts small have a growth factor and the maximum size is kept relatively low to allow for better reinsertion we'll get to that later on so raiseed nodes we can't reallocate backwards like you do with a vector or a dick or you invalidate all the pointers to your elements which is one of the reasons we use p any kind of lynch list so what do we do instead well okay start off with if we don't have erased nose here's what we do when we're inserting to some point in the lynch list so doesn't matter where we're actually inserting to in memory where our location is we're just putting the element at the back of the list and then we link up the previous and next pointers pretty straightforward but not ideal because that means during iteration you're going okay this element this element this element in memory and we're going all the way over here to the back and then we go here here here etc so not perfect if we actually have erased nodes then we can make this a little bit better so when erased elements exist first of all we check to see if if there are any erased elements in the same block as the element that we're actually inserting in front of and if they are we insert into that block if not we actually keep a previously stored pointer to the last block that we inserted into that had erases so we check there first and if so we reuse that and if not that then basically we scan from the block that contains the element that we're inserting in front of and we scan out to the right and the left to the different blocks until we find a block with erases in it and you might not think that would be efficient but it is because essentially we have that vector of groups so that means that it's all contigous in memory it's actually a very fast operation and i did try a bunch of other approaches when i was developing this and the this combination of approaches had the best performance overall so now if we've got these arrayed nodes but there aren't any arrayed nodes in the block that contains the element that we're inserting in front of then we basically scan outwards and we find an raiseed node and we insert to that pretty straightforward and that having it scan outwards like that tends to increase case locality because when we're iterating we're going okay this block this block this block so even if we're here and we're here and this block is in a different place to this block in memory doesn't matter cuz during iteration we're going to be going to that block next anyway right so it serves us to have that in the case at that point so even if we're iterating and it goes here here here this block here here here and this then this block still more c friendly right so just just to go into briefly how we organize this reuse of blocks we have a free list head for each block which points to the last erased element in that block and the next pointer for that erased elements points to the previous one that got erased and the previous one that got erased and that sort of thing so that's how we keep track of stuff so that's insertion erasure lastly we'll go into the sort technique which is indirect sorting so it has four phases gather phase we create a temporary array of in pointers and linearly iterate over the plf list blocks rather than following the sequence because l linearly iterating over the blocks is more cas friendly we're not jumping all over the place in memory and we fill the array with pointers to each element that we find in those blocks sort phase we sort the pointers by the value of the elements that they point to via a d referencing functor and stood it's actually stood sort i forgot to correct that anyway by stood sort using stood stable sort wouldn't make any sense because of the way that we gathered the elements in the first place is already unstable so then we have the scatter phase we rewrite the previous and next pointers of each list node following the order of the pointer array and then we delete the temporary array so just to show how that works so the sort phase beforehand we have our array of pointers pointing to each of the elements after sorting the array the array essentially points to the correct elements in sequence so 1 2 points to three points to four points to five etc and then when we get to the scatter phase so we're actually going to move the elements now well not move the elements change the previous and next pointers on each of the elements so we process the pointer array sequentially and for every pointer at index i we dreference to the node and set the previous and next pointers for that node to the addresses in the pointer array at ius1 and i +1 respectively and we just do that right across the array and then it's sorted then we just need to set the node pointed to by array index zer as the front node for the plf list instance and the node pointed to by the last element in the sorry the last index in the array as the back node and we're done which brings us to our next algorithm which is based on that whole thing it's called pend sort and this was basically me going okay this is kind of useful how can i apply this to like all containers and it's very similar we have the same phases but they operate slightly differently the gather phase we create a temporary array of instructs of pointers plus indexes and fill it with pointers to each element we fill each index with its index into the array so 0 1 2 3 4 etc sort phase exactly the same we sort the value sort the structs by the value of the elements they're point po is point to via the d referencing functor and stood sort scap phase we find move chains we'll go into that and swap the elements around until we are complete and then delete the temporary array so again sort phase up the top very similar to what we did with plf list it said that we've got old index there as well after the sort phase same sort of thing so 0 1 1 2 and then next one is four so basically as soon as we encounter an old index that doesn't match its current index into that array so in this case the first one is the four there then we know that we've got something that needs moving around before that point it's fine we don't need to move anything around so this bit is kind of complicated it actually took me a while going back over my notes and over the code to actually go ah that's how it works okay and i've explained it and simplified it as best i can but it's still kind of complicated so you just going to have to run with it anyway so scatter phase now what you'll see here are the move loops so any move operation at the end of the day will end up with a certain number of elements that need to be moved around and if there's only two of them then it's essentially a swap which is what you can see with the two and the four there you know the old index four that one points to the three old index two that points to the five and you can see that those two elements in the actual container need to be swapped around right and each move chain is exactly like that but with more elements in between in the swap process so what do i mean by that well if you go up to the blue move chain there 17 the 15 the 16 you can see that the 17 is pointing to the 15 that's where that needs to go the 15 is pointing to the 16 so that's where the 16 needs to go is into that place and the 16 is pointing to the 17 that's where that needs to go into that place so essentially but you know we can't copy we can't just copy those in we have to actually move them all around and keep a temporary there to store the first one that we moved around otherwise we'll end up overwriting stuff before we have a chance to copy its original value into place so essentially it becomes like a swap operation but with more values being swapped in between so a move chain right so basically what we do if we look at the simplest one that we've got there which is the four and the two so we go to the four we go okay four doesn't match index 2 into this array so this is something that needs to be moved and we look at the value that it points to which is the three we store that in temporary variable and then we look at old index that points to four so we go to index 4 into the current array which is has the old index of two and we take the value that that points to the 5 and point we put that into the area in memory that old index location four points to so basically we put the five where the three is and then we go okay this one has an old index of two so we go back to two in the array and we go ah that's the four that's where we started with so now we know that we're at the end of the move chain and we can take take our temporary variable and copy it into the place pointed to by the last index that we processed which is the one with the old index of two which points to the five so we take our temporary which holds the three and we put it to where the five is and then we're done and then the last part of that process is that we write the new updated old index values to the old index so where it is four becomes two and two becomes four that way as we continue to process this array of structs so after we go past the four we'll go to the five and we go okay that's part of a move chain that needs to be fixed after we've sorted that move chain we'll go to the next one and rather than the old index being two as it was before it'll be four so we know that that one has already been sorted it's already in place and we don't need to process it again so that's the basic rundown in very abstract terms if you want the more rigorous pseudo code interpretation of that it's this so iterate over the pointer array until we find a move loop i the old index is not equal to the current index into the array move the element pointed to into a buffer variable store the current array index as disc and also as start store old index as source move the element at array bracket source. location to array brackets desk. location where location is the pointer to the element in the original container copy source to dist copy array brackets d. old index to source and copy d to array brackets dist do old index keep on doing this until source is equal to start again then move the element in buffer to array brackets disc. location and we're done and go back to step one and continue processing the array until you get to the end of the array so clear as mud great we'll move on so there are some technical optimizations that you can do to this if you're doing this with a random access container you don't actually require the pointer you only require old index because the current index in that array of structs is the same as the index into the actual container old index if you're sorting random access containers again cuz you don't need the pointer old index can be reduced in bit dep appropriate to the number of elements so if you've got less than 256 elements you can use an 8bit old index for example and thanks to b for this one this actually comes from a talk that he did earlier on in the year and i watched it and i went ah so when size of t is smaller than oh i'll just tell you what he said so he was talking about sorting a stood list and he said oh take the elements in the list and we copied them to an array and we sort the array and then we cop the elements back and i thought yeah that's a lot that's a lot more straightforward than what i'm doing at least for elements where their size of is smaller than size of t star plus old index you know if you've got st list of ins or stood list of doubles it makes a lot more sense to just do that copy the elements out to an array sort them copy them back in then it does to do what i've just done but if you've got non-trivially copyable types or if you've got any type that's larger than a couple of pointers basically then my way of doing it saves a heck of a lot of memory and will be faster so i incorporated technique into what i do with desort so it basically checks the size of the type and whether it's trivially copyable or movable and it switches the algorithm based on that so across 1 by 2 by 4 by 48 by and 490 by types and number of elements ranging from 10 to a million 250 c basically what i did was i took a basic bidirectional compatible intros sord algorithm and i tried that on plf hive and pf colony and compared that with indie sort and it's two ind sort is 250% faster than the bidirectional compatible intros sort algorithm it's 28% faster than s list sort when you're using s list on types smaller than 2 92 byes again why is that because if you're sorting very large or non-trivially copyable types it's much faster to just change the addresses on the previous and next pointers than it is to move elements around but if the elements are smaller it's much faster to do it this way it's 146% faster than stood sort with vectors or arrays on types larger than 152 bytes and also possibly some non-vi non-trivially copiable types which are also not movable same sort of thing if you've got reasonable size types you know doubles small structs etc then it's actually faster to just move them around then do this indirect process even though with this indirect process most elements only end up getting moved or copied once at most twice which is with that the first element in the move chain gets copied out to the temporary and back yeah so that's basically it so it can be very useful depending on what your data type is and what type of container that you've got moving on next container pfq a faster adaptive q so why is st q not adequate it uses deck by default and unfortunately deck implementations very wildly because they're a little bit underspecified in the standard you know for example microsoft's implementation and this is not their fault i'll go into that it's has a fixed block size of 16 bytes which means that if you have a deck with any type that is over 8 bytes essentially the deck becomes a lynch list which is not great that's not their fault they inherited that abi from dware i correct me if i'm wrong somebody who was was the original company who supplied their stl implementation before they took it over and started doing it themselves i know that they want to change that or some people do within the company but that would require an abi break but even if you're not using an implementation like that like the other implementations have their problems as well lib c++ that has a fixed block size of 512 which is okay but you know if you've only got a very small number of elements and the elements are very small then it's problematic if you've got a s a size of type that's very large again it can become a link list and lib c++ is one gets around the ladder by having a very large block size but it is a fixed block size of 4,096 bytes which means that if you only have a small number of elements or a very small element type then you get you know way too much memory waste so neither of these optimal in any sense but it's what they've got and it's fixed in ai so they can't change it so pfq adapts block capacities to reflect size so it doesn't have that fixed size it actually changes block capacities over time as the size of the container changes the number of elements so it's more appropriate to the use of a q than de complementations are it also uses blocks from the front to the back unless the sizes changed significantly in which case it'll deallocate one of those blocks and get a bigger one or a smaller one and i know that lib c++ i think microsoft's implementation of deck also kind of does this like reserves a block in place when it's been kind of popped off the front or whatever i don't think libed c++'s one does has iterators for debug in purposes and the user can specify minimum and maximum block capacities so benchmark averages ends up being 20% faster for one by types 10% faster for four by types 15% faster for 8 by types 40% faster for 40 by types and 65% faster for 4 90 by types this is benchmarked against libed c++ so obviously you would get differences and probably quite significant differences when you're benchmarking against micosoft implementation for the reasons i just specified the benchmark is a pump test so elements are pushed and popped consecutively with the total number of elements just sort of fluctuating over time like an accordion so that's that plf list is i think possibly my first container because it was originally developed to be part of colony to be the thing that stored erased element locations before i realized there was a much better way of doing that then it split off into its own thing and most of its code is very similar to pfq which was developed later so again why is stood stack not adequate uses deck by default as the underlying container for the adapter same problems there if you use the underlying container as being a vector that's much worse the reason for that is that stacks only do three things they push back they pop back and they read the top element so vector has very good iteration performance it does have good back erasure you know pop back but it doesn't have as good insertion performance because when you get over capacity you have to allocate to a new block so deck is a lot faster for insertion so deck's lack of need to reallocate elements upon insertion does help vector's iteration speed does not help but again there's no growth factor in blocks for deck so pf stick creates new blocks with a growth factor of two the user can define minimum and max block capacities it also has iterators so basic structure and pf cures very similar to this it's just an intrusive lynch list of blocks a you could also do it as a vector of pointers to blocks as an implementation if you wanted to would be the same sort of thing right bench mark averages versus stood stack basically about 80% faster for all types except for 490 by types and again that's due to libad c++'s deck issue where the fixed block capacity is 512 bytes so when you got a 490 by type or anything that's over 256 bytes it essentially becomes a length list so that's why that one is so much different the benchmarking question is total time taken to construct push all elements read and pop all the elements and then destruct the container now some of you may be thinking yes but couldn't we make a deck with a growth factor in its block and bypass all of this the answer is yes but then the question becomes okay if we want to do that how would we make a fast operator brackets as well as fast iterator operators plus minus plus equals and minus equals and this is where sectors come in so name of the paper that i wrote is random access of elements in data containers using multiple memory blocks of increasing capac capacity and sector is basically the prototype container that i made to test this theory and it works i haven't published the container because i would have to flesh it out more and do a bunch of optimization and for some reason i haven't been bothered yet so sigor is a portmanto of segmented plus vector the basic idea is you have a vector of pointers to element blocks then you create blocks with a growth factor of two and the total capacity of the container as a whole so for example if your first block capacity is eight next one would be eight that doubles the capacity next one would be 16 etc the initial block capacity must be a power of two use these things together to calculate from the sequence index supplied to operator brackets both the block index and the vector of pointers and the subblock index of the element so the index within the actual block itself by using power of two block capacities with the growth factor of two we make the most significant active bit ie one instead of zero of the sequence index that we supply to operator brackets relate directly to the block index what do i mean by that well okay so here's is how it looks in memory vector of poins to element blocks first block capacity is four next one is four next one is eight etc pretty straightforward here's the concepts that you need to understand sequence index is the index of an element within a container block index the sequential number of a given memory block in the vector of pointers subblock index the sequential number of any element within a given memory block bitwise index the index of a bit within a number when measuring from the least significant bit to the most significant bit for example if you have the number three then that is one one and then a bunch of zeros right so the most significant bit that has a one in it would be 01 so location one is the bitwise index so most significant active bit is the bitwise index of the most significant active bit of any given number a the highest bit set to one so in the case of the three that would be one so here is the pseudo code for the operator brackets al algorithm the first two lines only happen once during the container's lifetime so we have m is equal to the most significant active bit index of the first block's capacity right then sh which is is our shift value if m is equal to z then it's z if it's not equal to z then it is m minus one right and we can pretty much get rid of m at that point because that's the last time we use it then in the actual operated brackets algorithm we have j is equal to the sequence index i what is supplied to their operator brackets algorithm bit shifted to the right by sh our shift value then b ie the block index is equal to the most significant active bit index of j and then k basically if b is equal to zero then k is zer if b is not equal to z then it then k is equal to one bit shifted to the left by b the block index plus our shift value and then s i our subblock index is equal to the sequence index minus k okay okay so as an example if we have our first blocks capacity is eight and we have our operator brackets and it's supplied with 15 so we want to get to element 15 in the container now if we think about that logistically so first block capacity is eight next block capacity has to double this the capacity of the container as a whole so that will also be eight operator brackets is measuring from zero which means that 15 will be the last element in the second block right so m is equal to msab index of 8 which is 3 sh is equal to well is 3 equal to z no so it is 1 * 3 - 1 so it's 2 j is equal to 15 but shifted to the right by two which is three block index is equal to the msab index of 3 which is 1 k is equal to okay is 1 equal to z no so it's one bit shifted to the left by 1 + 2 which is 8 and then our subblock index is equal to 15 - 8 so we have a block index of one so 0 1 second block and we have a subblock index of seven 0 1 2 3 4 5 6 7 so it's at the end of that block so that works okay now now calculating msab index cuz i've just sort of glossed over that there most modern processors contain an instruction designed specifically to calculate that so you have the bsrl bsr w instructions on intel x86 cpus but where that's not the case it's very simple to do code like this where you just get your number and you just bit shift it to the right until the result is equal to zero and you add one frid point so pretty straightforward so the number of total number of operations is only going to be as large as the number of bits in that number so here is our actual code for the brackets operator member function so we get supplied our sequence index that is index and we have unsigned block index we supply that as the the return value to our assembly in structure which is bsrl we supply to bsrl index shifted to the right by our shift value which has been pre-calculated and then we return vector of pointers to our blocks and we index into that to our block index which we've just calculated and then we basically dreference to the actual block itself and the subblock index is our sequence index minus is block index equal to zero no then bit shift one to the left by block index plus the shift value so clear as mud so how does this all relate to dex well it doesn't you can just implement a seor by itself and everything will be fine you can just have a sequence container that just expands with a number of blocks in one direction and the only thing that you have to do if you want to turn it into a a deck is basically have two sectors and have them extending in different directions now the illustration that i've got here the seor on the left there i've actually illustrated it kind of backward backwards to show how it would work but actually in memory it would be the reverse of that but this is just easier to illustrate to make people understand it so this is basically bally how you would do it you would start with only one sig tour which is the one on the right and you just have one sig tour until such point as the user pushes to the front enough that it extends beyond the first block so say you've got the one on the right there and you and it's filled up the way that it is at the moment and then you push front and so you know you're going beyond the st part of the first block capacity there at that point you would create a second sigor so the one on the left there and you'd start inserting into that so that much is pretty straightforward and it's actually relatively easy to go back and forward at any point in time there's only ever going to be two sectors in that process or one or two of them right i mean you could start with one over here and then you push front push front push front and you end up with the one on the left there and then you pop from the back pop back pop back pop back and then it gets rid of the right hand one and then you've just got the left hand one and it could go back and forward like that but at any point in time there's only going to be two of these things now complicates things a little bit if you want to use operator brackets but basically what you would do is if there's more than one sector at any given point in time um you basically keep separate size rec size records for both of the different sectors and if the sequence index goes over the left sector's size if the left seor exists at that point then you know it's in the right sector and you do operate brackets calculation from the previous one and basically all of your iterator operators plus equals m equal minus equals that sort of thing can be implemented via the operator brackets operations so you just okay you've got your element you work out what its sequence index is in the container you add or subtract a value from that sequence index and then you supply it back to operator brackets or you can do it a more complicated way but that's that's the that's the simplest way of doing it right okay so that ends that discussion that is how you have a deck with multiple memory blocks with increasing capacities i don't know if i'll ever get around to doing that maybe somebody else can it's a little bit of a complicated operation anyway food for thought so final thing of the day this is the issue that i was referring to somewhat mysteriously at the beginning of the talk it doesn't relate entirely to the rest of the conversation here but it is a different slightly different way of thinking about things so it's not quite a new trick but it kind of is so this is my perspective time complexity is an implementation detail what do i mean by that why do we care about time complexity and it's all practical things like there's no unless you're going into pure mathematics if you are actually operating on a computer which is a fixed bit of hardware with a fixed number of chips and this sort of thing all of the reasons we actually care about time complexity are practical reasons right there's no theory to it per se we care about performance latency and potentially resource use in some scenarios so number of ces or amount of memory use etc as it relates to a fixed number in now we won't go into res resource use that is a valid concern it's not actually one that comes up that often though so we'll focus on the first two there the problem is that you know since the earlier days of computers ram speed is increasingly been dwarfed by cpu speed as almost everybody knows now so that has decreased time complexity's relevance to the first two by making the whole process of what work is and what work the computer is doing a lot more complic at what work the user programs is still you know kind of the same but anyway what we have to look at is what really is time complexity in my view it's meant to be a measure of work done right which is arguably correct from a very abstract perspective but you know this is computer science we're engineers we're working on hardware not something out there in the nether world so it's actually not abstract and what actual work gets done is always hardware dependent so how much work ends up getting done for a given operation that you supply the operation itself may be a singular instruction but it might inadvertently trigger a whole crap load of work right so whether a branch prediction fail forces a pipeline reload is hardware dependent whether a read from non-c contigous memory causes a c mish is hardware dependent has it got a cache most of the time yes some very rare processes don't have c nowadays but the vast vast vast say 99.9% do for those reasons because ram speed is so much slower than cpu speed right and those are much bigger workloads for the hardware than singular instructions so i think when we're talking about time complexity largely we're kind of talking about the wrong kind of work or in my view we are weighing it perhaps incorrectly right so to look at work we have to look at what is typically most important to performance and latency and this is kind of my rough list and it varies a lot based on hardware don't get me wrong but so this is a very rough thing cas locality of data inter memory speed parallelism allocation deallocation branching although that's becoming less problematic as of more recent processes back in the core two days very significant and and lastly i'd say time complexity it's very rough as i said given that that might be the case therefore it's only when the first four are not affecting performance significantly that time complexity becomes a strong concern okay so but case locality parallelism branching are all considered hardware based implementation details and not something that we talk about in the standard or in computer science in general right generally speaking i'm sure some professors and computer scientists universities do but you know the reasons why we care about those things are the same reasons we care about time complexity asides from potentially the resource use performance and latency so it's only typically once they're eliminated that we should be worrying really significantly about time complexity and the fact that we have to consider that based on our hardware whether time complexity is actually relevant to the performance in our scenario is what makes it implementation detail in my view and you know you can go back and forth with semantics but this is the way i'm looking at it currently might change my mind so in examples of this so the performance improvement of reorder over regular erasure improves based on size of not just the number of elements and this is not purely down to the cost of copying but also the case locality of the larger elements so if you have you know 1 million chars for example and they all fit in memory you know obviously ly the reallocation operation caused by regular ria on a vector from nonb is going to be a lot less than if it's a larger element that doesn't all fit in the cache both st list sort and st sort have o in login complexity but that has nothing to do with their performance which is entirely dct dictated by the algorithm and cas locality and that's why with indie sort it can be a heck of a lot faster to just copy the elements out into memory and then stood sort them and then copy them back right even though you're essentially you know you're not changing the pointers you're actually moving elements around p left stack and st deck insertion are both o1 amortized but one of those gets faster over time due to the lower number of allocations because plf stack has a growth factor in the number of blocks more examples p left list insertion is at worst o n in the number of memory blocks in that contain container but it doesn't stop at being 2.93% faster than st list insertion which is01 due to the number of allocations being low and the memory block metadata being contigous in memory for many sets of data it can be faster to do the same operation many times rather than to store the result once in memory due to memory speed i n can be faster than o1 but typically the n is fairly limited strong example of this doom 3 the game the bfg addition of that which they basically rewrote the engine 10 years later after the initial release there's some technical notes for that that you can look up online and one of the things that they found was that they were pre-calculating these meshes and then for each object and then storing those meshes in memory and then you reusing them for each rendering pass and what they found was that it was actually faster to just calculate recalculate that mesh for every single rendering pass and i from memory there could be quite a number of rendering passes than it was to store it once in memory and that's because the processes had changed so much and the difference in performance of memory speed versus cpu speed had changed so much that the pre-calculation and storing it retrieving it from memory was slower than just calculating again and lastly differences between alternative skip field methods in pf colony one of which is o the current one and one of which is o n in the number of elements in that particular block made about 1% performance difference overall so yeah anyway that's basically it so why are we so hung up on time complexity hung up is a bit negative perhaps i should be saying you know why do we put so much emphasis on time complexity and we don't tend to talk about the other ones so much particularly when we're dealing with kind of standards issues and this sort of thing i think the reasons are largely historical you know back when c++ started time complexity was a much much more relevant concern the effects that we've had that have changed over the past 30 years of cpus and memory speed and blah blah blah blah blah have been gradual they've happened over time whereas time complexity is sort of something that stays static but its relevance does not stay static and that's the problem but it's got institutional entrenchment so we kind of have to talk about it and also time complexity is a little bit fun to talk about like i kind of compare it to musical notation understanding music theory and that sort of thing it doesn't make any difference to how good the music sounds at all it doesn't it's not relevant to how good music sounds but it can be fun to talk about and fun to understand so and time complexity is not irrelevant to performance like if you get all your ducks in a row if you get everything lined up if you get a vector which has all your data and it's all contigous in memory and your items are you know trivially copyable and you're not doing a lot of branching and you're not doing a lot of deallocating and allocating this sort of thing then once you've got that scenario then it's all based purely on time complexity and everything just sort of scales according to plan based on that value of n and that's great and that's a very real concern and it's a consistently useful concern but what i'm kind of not okay about is the fact that we spend and waste so much time talking about time complexity as if it's the be all end or or something like that or has this huge relevance compared to the other things and we don't talk about any of these other things so i think either we should be talking about all of these things or we should be talking about none of them because at the end of the day it's just another implementation detail to consider once you've got all the other stuff out of the way sorted thought about etc and that is my talk thank you everybody for listening who listened all of the technologies and blah blah blah that i've discussed are on p.org and i wish you all a great day thanks for sitting through till the end bye thank you for your talk that's been great and if there's any more for disc and question please join the lunch table with and have discuss with about all the things he mentioned great talk thank cool thank you