in some ways there are some awkward incompatibilities between the decimal that we like to use and the binary which is so efficient wonderful for computers to use we've seen one example of this already i think i mentioned in the in a previous video that 0.1 or 0.10 10 cents in other words in decimal your current bank balance is not exactly representable as a binary number you look at what it is in binary zero point three zeros one one zero zero one one zero it just isn't you know it keeps on recurring just as one third in decimal isn't exactly goes point three three three v three forever and binary sometimes don't mix now here's going to be a classic example let's just think this through without even writing anything down if we've got a four bit nibble we know that in hex it goes from four zeros to one one one one fifteen represented as f can't use that full range this is binary coded decimal not binary coded hexadecimal yeah we have got to say that the moment that representation even in one nibble gets to one zero one zero that is ten you can't leave it as one zero one zero you've now got to have two nibbles the left nibble with a one in it and the right nibble wants to look like zero you can't compress it into a single nibble say one zero one zero and i'm sorry folks you'll all have to learn hex because otherwise you won't understand your bank balance this is not going to go down very well the challenge then is if you're using a four bit nibble but only for the decimal range naught to nine you've somehow got to make in all your bit twiddles you've got to make it carry into another nibble on the left at 10 and not at 16 which is what hexadecimal would do for you so how does one sort of bridge that gap probably the best way for me to get into the hard bit about this is go straight away for that magic number 10. let's represent it in binary and then say how do we convert it into bcd and realize that we need that second nibble on the left what i'd like to do here is to draw myself columns and i'm going to restrict myself to things that are at most two decimal digits let's remind ourselves up here that we're going to have a tens nibble and a units nibble and we'll initialize everything to zeros but above here just to keep things very simple we'll use four bit binary representations and i hope you will all agree that one zero one zero is ten in base ten and the reason for that is that the binary in four bits that's an eight that's a two so that's ten this technique which is called double dabble i don't know how it was discovered it's fiendishly clever but the idea is we'd love to convert binary into bcd by as far as possible using simple bit shifts all the time and doing the minimum of mucking about to get it to carry early so the double reflects the fact that we're going to shift this bit pattern across into here and we're going to regard it as one huge great big 12-bit register here walloping great shift register all joined together even though i've drawn it out separately it's just going to move from right across to the left i'm going to move them across and remember every time you shift the thing by one place left you are basically doubling it okay that's where the double comes from but we found we have to intervene to make it look right at the end and that is where the dabble comes from if you look up dabble as i did in chambers dictionary it's one of the meanings is to make a trivial alteration to okay to make a small alteration to something you're dabbling with it okay so that's where double dabble comes okay so it's basically doubling with a little bit of dabbling and the truth really hits you at 10. so let's progressively shift this by one bit left what's going to happen first of all you shift over that one bit you push it across into here because this is a unified register for the moment purists will say ah but when you shift left like that you should fill in with zeros on the right yes that is what will actually happen inside the hardware but i prefer not to pad with zeros on the right side shaft because i want you to see when i finished so we could call this shift number one let's do another one that one moves into that position but you're bringing over another zero out of that part and that's leaving you with one zero in there now notice what's happened on shift one here you had a one at the right in that nibble by the time you shifted it left one place it's in the two's position so you've doubled it let's do shift three and a zero is left so that is shift three now this is where we can begin to see trouble on the horizon we have got one more shift left to do and if you don't do anything about it it's just going to end up with one zero one zero in here i mean all right what's happened here look is that was two you doubled it but because you shifted the one in and not a zero you've doubled it and added one that now says five okay so basically it's doubling but sometimes if the bit you shift over is one and not a zero it's double and add one but essentially it's doubling now the trouble is coming on the horizon because i can see that if i just push that zero bit over here i'm going to end up with 1 0 1 0 i know it is 10. fine but that's hexadecimal it's not representable as a digit from naught to 9. so what should you do then let it happen anyway and then look at it and say oh my golly he's gone to 10 he's gone to 11 he's gone to 15 even i better backtrack and undo it and then redo it no dive in early and reason as follows concentrate everybody okay what we want here is for this thing to come out looking like zero zero zero one zero zero zero zero let's say that's the desired result because that regarding these as bcd digits that's one zero ten that's exactly what you want so how do we make that happen how do we make it carry over into this left hand nibble here when it doesn't want to at the moment so the fiendish clever thing says take a look at what you've currently got because if what you've got is five or more the act of doubling it is bound to get you into a number that needs to carry across so if it is going to cause you trouble at five or more we wanted to carry a 10 it innately would like to carry at 16 and you don't want that what's the difference sean between 10 and 16. six six what's half of that three all right so if we add three the fact that we're then shifting it will double that three contribution to six and we'll make it carry so the rule is on double dabble if what you see in your nibble is five or more then add three so here we go look next stage now because we've seen treble on the horizon it's five so add three and three we agree is one one now here you do have to do as little addition with carries you can't avoid it some carries will have to take place one on one is zero carry one one and one is zero carry one one on one is zero carry one the act of adding three will make it look not like zero one zero one you've added the three it now looks like one zero zero zero magic but what happens when you shift the final zero in that one will shift left into the left hand nibble and you'll end up with not no no one no no no not and this thing is now empty so you know you've come to the end of your conversion it's so cool i love it dearly you could argue though the one problem with all this is that in order to do your shifts quickly you've got this in a sort of unified shift of register full of bits your nibbles in the end end up looking correct but you're going to have to dig them out of the shift registers oh yeah it's clearly that's a four yeah two isn't it magic of course if you're using this seriously you have to try and generate these bcd digits in a way where they don't necessarily need digging out of a bigger representation but on the other hand you're using that behind the scenes i've found for you the ultimate reference that i've taken this example from and used the methodology it's by a guy called chuck falconer it's actually referred to in the wikipedia articles on bcd and double dabble so we've pulled that over it's freely available you can go and dive in there to your heart's content because he covers about how to make them appear in a much more usable way and what he also says is that when you start looking at this you realize you are actually doing the division by 10 and remainders thing that we discussed but you're doing it in a pretty efficient way and only occasionally needing that little addition of three so that's i'm not saying there aren't other ways there's seems to be endless variants on this there's signed b c d there's packed b c d there's all sorts but if you just want to understand the fundamentals i would say go through the 42 example then go to chuck falconer's memo and he does 255 as decimal and boy that needs spotting problems in about three sets of nibbles not two you have to spot one in the middle thing happening and so on you've mentioned two five five so this goes up to hundreds thousands yes yes you just add more you add more bcd digits on the left to cope but you give yourself a bigger problem when examining each of these digits to see if they're about to go beyond 10 when they're doubled by shifting left one more time you give yourself a bigger and bigger inspection task there's no question so like i say the the chuck folk and a memo from which this is derived we'll put a link out to it it is freely available it doesn't explain how the people who invented this actually discovered it and worked out that it really does work it seems almost like magic when you do it and every so often i pull out another number i think i bet it won't work for this but it does it's quite incredible so there we are then i think we've fairly well summarized now what the situation is that for great big engineering scientific calculations even for finding new prime numbers as huge integers you really do need proper binary to speed things up but for some sorts of trivial calculations you might even want to do it in bcd all the time but even if you are basically binary and want to print out your answers you still have to convert from binary through to bcd and that is always a a worry for the people who write the i o routines shall we say for c and so on is is this going to be efficient what we're saying is at the computing end of things you should be able to prepare that bcd digit stream as quickly as possible to finish off with then life the universe and everything would this work for converting 42 yes it will now admittedly here's one i did earlier so