be an engineer not a frameworker this article is a plea for self-improvement you can do this be an engineer i love this take already i'm loving it i can feel myself loving it i always say the statement where there was a time period in life where people would define their role as a software developer by the language they choose i'm a javascript deaf right but that has so much been obliterated that now at this point people say i'm a react developer that's somehow a framework that calls itself a library is worthy of being the type of developer you are it's not it's crazy that you say that you're not a framework developer you are a software engineer learn how software works be an engineer and stop caring so dang much about these these things also use htmx because it's the greatest i'm an htmx developer by the way as always caveat's first engineers definitely should should and do use frameworks there are beautiful bits of engineering that get stuff done in maintainable way frameworks are not the enemy of this article bravo frameworks okay enough of that good take sorry what are frameworks frameworks are software tools that provide a scaffolding to complete software projects of a particular type so if you want to write a single page web app and typescript use htmx because there's there's nothing else you don't have to do it from scratch because there's htmx what do you let's see want to do some machine learning in python allow me to introduce my friends want to write a backup and c sharp i don't what the hell is c sharp i don't even know what what what what an asp is not a highly dangerous snake right like that's don't touch an asp okay you you will literally die you'll die of horrifying poison if you know a framework you can often get a job that has the word engineer in the title and possibly machine learning if you know two frameworks you might get a job that also has the word full stack in the title but your skill your skill set needs to go much deeper than frameworks if you're going to have a success in your next job the one where you get hired because you have three to five years of engineering experience on your resume senior engineer otherwise you're going to be sitting in a very uncomfortable chair at the 90-day review you may need to go on a journey from frameworker to programmer to engineer let's look at each of those phases of the journey i don't like when people do this whole like engineer is different than programmer business okay just pick a term and use the developer engineer programmer i don't i honestly don't give ass wait i just bleep rat i don't give a rat's ass about which words you choose okay they are meaningless to me at this point oh it's obtained in my country sorry i don't i know true i know that's true for you but guess what canada nobody cares okay america's hat nobody cares that you can't use the word oh i can't use the word software engineer because that's illegal nobody's building a bridge on a c sharp okay it's not how it works we don't need some stupid piece of paper that says you can make bad code because you still rely on chad jeopardy anyways okay that's the worst part no one cares anyways sorry i i digress all right the frameworker just because you primarily work in a framework or two doesn't mean you're a frameworker but you might be framework allows a frameworker to build software products in a way similar to how ikea allows me to build shelving units beautiful when but it's totally not true i love the analogy but at the exact same time ikea gives you something that actually will come out with a final product whereas most frameworks come out with spaghetti okay it's more like you've been give you need to cook some noodles when the work is done did i make a shelving unit yes should i be describing myself as a shelf engineer probably not what is a frameworker lacking programming language knowledge frameworkers usually have a fairly rudimentary knowledge of programming language that the framework is written in really well don't do that stop it stop it what's more they may not be aware of the lack of their knowledge because the frameworks are purposely designed to provide abstractions that shield their users from many types of programming so the frameworker gets a lot of experience in solving a handful of problems with a limited programming toolkit i think this is a really good call out in the sense that like if you don't know even the fundamentals of how something like trpc works or how any of these things work you should know how these things work even at the most basic levels because ultimately at the end of the day when there is a bug it's up to you to solve it and you to figure it out and if you have no clue why your stuff is breaking don't be at the mercy of trying to get somebody else to solve your problem you should know something right you should know enough depth of knowledge frameworkers also lack the depth of knowledge and software problem they are using the framework to solve a framework represents a specific way implementation of actualizing the concept of software product the low-level implementation is usually abstracted in the framework users are providing some straightforward ways of injecting code into the underlying implementation by a base classes decorators and auto-generated templates yep this makes sense this makes sense no matter how crazy react may be the basic the basics of it are not that insane solid.js is much easier to kind of imagine how it works in comparison to react but not that crazy frameworkers can become adept manipulators of the framework without ever understanding the underlying principles of the framework frameworks design patterns algorithms cs or ml asynchronous or distributed programming and much more sometimes understanding these concepts these underlying concepts can offer an immediate benefit by preventing some misuse of the framework this is true i remember when i was getting my masters in machine learning ai back when we called it and like either write a bunch of mlps and all that stuff by hand right at the right radio basis functions adaptive neural fuzzy inference systems this was back in the day before all these all these cool new concepts okay reinforced learning was just becoming like a big thing and you know we had to design those things and so when i see people go oh man my learning rate was wrong like i really get that because i had the right you know error back propagation and my learning rate was a piece of crap and i didn't really understand it until i realized what was going on and what was happening to all the little hidden layers you know what i mean it's it's it's neat to know what happens underneath the hood in some small sense you know what i mean even if it's even if now it's outdated i have a general concept you know what i mean it's neat but often one can use the framework adequately with little depth of knowledge all this deeper knowledge however is valuable for one thing it is massively transferable not just with an immediate domain of the particular software product but across all sorts of programming what's more without this depth of knowledge the framework is not well equipped to decide whether or not the particular framework choice can fully meet the project requirements does any of this matter i think i mean i personally think it does i see more and more a lot of these right i see it a lot react you know just because that's like the most popular front-end one just people are react engineers stop being a react engineer right at least learn javascript at least like the most basics of it all becomes so good that you could write the basics of your own framework and then throw it away and then go use whatever you want to use right frameworking has a negative effect on the frameworker's career and on the organization they are a part of the frameworker works in that limbo of writing framework code that is good enough to merge but lacking the level of competency that will pass long-term maintainability and a sensibility test not only that but once you become too married or just you only know one framework work you do something really stupid is it this one is it blessed okay it's not blessed what is it called is it dang it is it is it is it ink ah it is ink it's ink see here's the problem is that when you have a hammer and let's just say your hammers react and you see a ui you may go the only way to write this properly is to use the thing i already know right so inc provides the same component-based ui building experience that react offers in the browser but for command line applications now when i see this i go maybe just maybe you might have jumped the shark here okay you might have just accidentally jumped the shark and now you're just applying this one single way to solve things to everything i understand that a tui is kind of like a gooey that's gonna not you know what i mean anyways stop solving the same stop solving every problem the one way you know anyways that's my one thing about like frameworking is that people that once they start doing this they they start solving every problem in the same way the frameworker works in a limbo of writing framework code that is good enough to merge but lacking level of competency that will pass long-term maintainability and extensibility tests a lot of immature immaturely procedural code just gets dumped into the right slots first off i love procedural code unfamiliar problems are handled with anti-patterns and organizational code quality drifts downward declarative is just imperative baby declarative is just a paradise but from a career perspective the frameworker has a bleak outlook coders with the same set of transferable skills using a framework are being churned out on moss by about 50 new online academies every day yep see this is i do think this is a fundamental problem which is that there is a ton okay so the un problem is that coding is accessible to anybody the problem is is that we hate gatekeeping and maybe just a bit more gatekeeping is good like hey here's some things you really should know here's some things you should really try to pursue maybe it's not gatekeeping maybe it's some other thing some way to help people understand that like what they've learned is not the end it is the most initial seedling of what you need to do stop looking at learning as a six-month one-year two-year four-year exercise but as a 20-year 30-year exercise and if a framework eventually lands a dream job where they get to do more interesting projects they might end up might experience a rude awakening when their knowledge becomes knowledge gaps become evident yep side note they might just be made a manager in which case they'll probably do incredibly well got them so what if a frameworker wants to be an engineer i suggest they start becoming programmers program okay so this is where this distinction i don't really care but anyways i'm going to use the term programmer with a sense that is somewhat idiosyncratic to this article's premise a program or someone who lives in code and by that vague expression i mean two things programmer is reading lots of code a programmer is writing lots of different sorts of code let's take a look at those in turn and heads up i'm going to switch back to the second person here because i believe you deserve that sort of personal touch okay you'll definitely let's see a programmer let's see the programmer is reading lots of code you'll definitely hear it said that reading code is one of the best ways to learn to write good code i think this is really good it's my favorite personal way is not just a read code but to first build something and then read how someone else does it because it's like you get this one chance to be deeply familiar with a topic and see a completely different way you could have thought about it all at the same time which is really hard to do in almost anything else but in code it is something you get to do so solve advent of code day one in a language you're not that familiar with and then look at someone else's advent of code day one solution you'll go wow what is that geez i didn't even know about that well that's super cool then you'll do it again and now you have all this new found tools and then the second time you do it you'll see a whole new set of ways you can do things or just different ways to approach the with the tools you already know about it's beautiful it's so good it is so bang good you'll learn to cover edge cases and handle exceptions like a professional but there's even better reason to read lots of code the best reason to read code has just become really good at reading code the ability to efficiently read and understand new code is probably the most important single skill that an engineer will have and the programmer is becoming an engineer because the technologies languages and libraries that make up core stack are constantly changing plus reading your own code from six months ago is the same exercise okay even if you work by yourself reading the dumb you wrote like three months ago is equal to reading someone else's bad code right well there's no substitute for being able to understand code by reading it yourself and that's especially true when moving into a new job somewhere luckily there's a ton of code out there to be read and it can be encountered while doing the second thing programmers writing lots of different source code oh i have that problem too anyone who thinks i don't write bad code and look back on my own code and go why did i write that you're full everyone does it one of the ways to break free of every now and then do i i do look back and go that's good count one of the ways to break free from the framework or what is to write code that's not typically for you that doesn't necessarily mean that you're writing a different sort of app if you're doing machine learning in python you could have a side project implementing ml algorithms yourself boom bonus points if you do it in cc plus plus but of course it might mean that you're writing a different sort of app trying to write a desktop gui on top of some of the scripts you run every day just for fun you make web front ends try a text-based role-playing game this is great advice this is great great advice because this is so dang good right this is exactly it try something different expose yourself not in the illegal for way but in the legal way the way that everyone enjoys okay not that other way yard users the thing to be mindful of is that you don't simply want to switch from one framework to another you're trying to learn you want to be using your programming language at a lower level than you're used to and then creating your own layers of abstraction on top of that this is a great because even just creating your own abstractions and seeing how far you can take it is an exercise onto itself right you should be learning about things like i o and sockets and event loops and buffers and hash generation and tail recursion last one seems a little strange because that's like one oh okay and as you add layers of abstraction you should be learning about things like polymorphism and inheritance and interfaces and state machines and design patterns and you should be gaining a vocabulary and then immediately never doing inheritance again except for that one problem we all know which is really really valuable which is event emitters and then somehow that just makes way more sense and everyone seems to like that one but i guess you could also provide a property but then you'll have this whole public property problem and then every object has to have the same doesn't really matter anyways so when i do when do i become an engineer the limitations of being a programmer as a programmer you'll find that what you can let's see that you can do things with code that would have been impossible for you as a frameworker but it's possible to do some remarkable things and still be a poor engineer if you think you're a good engineer you're kidding yourself okay i don't know about this this article might derail for me on that one part which is i think everyone should look at yourself as being a bad programmer because you'll always just take an extra step of care imagine that you're building your own car from parts but as you assemble your car every time you need to attach an unmoving part or another instead of using nuts and bolts you weld them together you could potentially build a car that works really well at first but imagine something and it breaks and it's the sort of thing that that's hard to get to you really need to remove some other parts in order to get to it this is probably a better app description honestly this is an app description of programming it's more like welding than anything else like when you have to undo something that's under a couple stuff like a couple couple layers like you just absolutely have to take apart your program the amount of it's actually i actually like this i actually like this a lot i might i might start using that all the welding was a bad choice it may be the choice you have to do though for programming imagine that you want to upgrade one of the parts of your car it would basically be really nice if that one park would be popped off and a new one popped on i'm not saying that being a programmer in this sense means that you've completely ignored good engineering principles but the goals of this programming phase are different from those of engineering phase if programming has been more or less linear journey of gaining capability in certain skills becoming an engineer will be hard right angle okay to switch metaphors you could think of it like language development as a programmer you're getting native speaking fluency with the language that you work in as an engineer you'll start writing academic pros okay at this point this is where i think we fully disagree potentially i i let the man cook but i'm feeling like i disagree so what is the mysterious shift in priorities that defines the engineer the engineer plans and writes software that balances stability and change stability is straightforward concept and many programmers provided in their code planning code that can change is more elusive balancing the two is what makes you an engineer i don't like this definition but we'll we'll finish it off stability the most most people understand the main concepts of stability the first concept is that software should do what is it supposed to do it shouldn't be buggy it should be reliable the second concept is the way the software is used should not change rapidly and frequently that's a true in two senses the interface should be relatively stable over time and the interface should be consistent across software okay it's not going to let's see i'm not going to spend a lot of time on these but i'll just emphasize that we say or that when i say interface i'm referring to that broadly it can mean anything that you've explicitly declared all the headers and cc plus plus interfaces in java c sharp etc it can mean consistent set of types of data and names of objects that are interacted with either in state or in operations all a python scala or it could mean the graphical interface your business users experience defining a stable interface is incredibly important not just for the sake of stability itself but also for the sake of change okay can buy that definition i buy the definition okay i want to get a good i want to get a good song on there we go the engineer writes software or change the engineer writes software in a way that accommodates change more precisely the engineer is able to anticipate the way their software will likely need to change and writes accordingly okay so this is where my disagreement probably goes a little bit harder coming up here soon this ability to anticipate the future is definitely an ability that grows over time but there are several types of changes that are universal enough to mention here so a big thing for me is that i think this is an extremely hard skill in the sense that i think i know why and how software should change or what it should change but often what i will do is not write it that way intentionally and the reason is is that trying to abstract for use cases you don't have often results in code that is brittle right like real talk it often results in code that is brittle i do not like abstractions and i often find that the more abstract the more i plan for a future that may be is i create a future that is a path to hell right it is just awful and so often i don't abstract intentionally because i'd rather feel the pain of not abstracting in the specific way that i needed to change it such that when i write the abstraction for the second time because now i have the two points of change i can create an abstraction that is good for both and likely good for another one because now i can really i can make it more broad more general or more specific in a way that makes sense and i also feel like this is one thing to say that probably doesn't exist in a lot of languages but since typescript is such a touring complete type system i think it also adds a new layer of typing complexity when you use it in the sense that if you use it in too complex of a way a way that allows you to be too specific with what you're passing in and how you use it you can find refactoring and having to now have a new form of abstraction to even be harder and it makes your refactors even longer bucks engineers that assume that every piece of software that i produce has something wrong with it in order to change fix the bug code should be organized by a highly readable and you and use logging love logging i won't go in depth here at the minimum an engineer knows how to organize code into reusable blocks whether they are functions or classes and knows how to loosely couple those blocks of code so that bugs are isolated as possible and require a limited number of changes absolutely that's just that's just seeing that's just programming enough right if you program enough you will do this automatically eventually right when you fix enough bugs this starts to become second nature i always tell people learn how to code and learn how to test your code without using mocs because there comes a point where you start realizing how you should layer your code where you have like external reaching data manipulation side effect producing and then the middle part becomes excessively easy to test because you've built your code in such a way that is testable right and it kind of changes how you think about it i don't know just a personal thought use cases and data and behavior now i remember being on call with a team lead who was being who was completing an mvp targeted for a single client i asked have you designed this software so that it can be used for other clients by referencing a configuration file or would it be required further software development to use this for other clients there was a long pause on the call and that told me everything i needed to know when the engineer gathers requirements for a project even an mvp they are constantly evaluating the required behaviors to determine if these behaviors that are likely to change in a way that can be captured in a data layer so this again you know i have a really hard time throwing everything into a configuration because you also end up with the other side which is that you over configure your software i don't necessarily disagree if you're building a mvp for a single client should you build it in abstract sense that can be used with any client or do you build it for the individual i don't know this example or what it was doing but i you know i'm always a little skeptical there's a few things i prefer to environment variable configuration out dot end out an example client a emails you their data as excel files which get dumped into a shared drive client b as an api client c has you connect the ftp to download the scsv files ignore the problems this implies in your business tech integration for now there are three different behaviors here your software can support all three while depending on a config config files one for each client to identify which behavior to use then when config c finally gets an api or client c finally gets an api you don't have to do software development you just replace the ftp information in their config file with the api information well maybe you store it in a database maybe you have oauth login that you want to do something different i'm not always convinced configuration is great i don't know what the i don't know what the deal is i'm just saying that always just going straight for a json file might not be the right approach i don't know all this is possible because you the engineer knew from the start development that importing excel files from a shared drive was a behavior that was likely to change you planned your software to develop to deal with data importing via abstractions rather than hard coding in a load client from udrive yeah okay that's fair this is again the thing where you this is kind of what i was talking about earlier you have the loading the retrieving the getting of data the manipulating of data the output of what happened the side effect the display like it's just accidentally it just happens right here it's just this just happens it you don't even have to think about it it just happens also yes getting data from google drive is a bad plan you laugh but things i have seen yeah extensions in some scenarios these the use cases changes significantly beyond what you were either expecting or beyond what you're willing to support continuing our example case maybe you don't want to support data loader from blob storage from every different cloud provider naturally if you've clearly defined what interface for loading data you don't have to downstream developers can still use your software to import data from s3 by writing code that implements the interface yep good plug-in support i mean this is just more like again i this distinction between engineering and programming i think goes away if you just go it's it's experience right experience says make plugins right you write it once dumb you write it twice thinking about plugins that's all it is to me so as long as you left the opportunity open for them there are a number of i know but sometimes you don't want to leave opportunity open all the time i've done this and i've made worse software because i left the opportunity open to be generalized and then you have all these weird edge cases that can come up because you tried to generalize too quickly there are a number of ways to to do this and a number of concepts that could help inheritance injection this never helps generics even duct typing the engineer stop it just an interface is fine enough the engineer is able to write software that can extend beyond what they can plan for never use inheritance like every time i use inheritance i regret it i'm using inheritance right now i found one kind of nice use case that's that's working but i rarely use it i try to use it like three times a year i always try to sharpen my inheritance sword because you never know what problem actually could be really easily solved by an inheritance but almost always is it the wrong decision almost always isn't the wrong decision just like always doing some sort of curing higher order function for everything is also the wrong decision you got to know when to do the thing you know what i mean know the thing stop making functions that return pojos that have that have functions attached to them just make an f in class okay stop being stupid so where in your journey let's see so where are you in your journey are you ready to move beyond entry level resume and give some gravity to the word engineer that you may already have in your job title become an engineer doesn't have to be the end but it's a great place to be let's see to go if you're ready to bust out of the frameworks effectively the only thing i have to say is i love everything this article is stating thank you john these are all great things i think you could have never made the distinction with programmer and just said practice the fundamentals as you see more problems the better you are to abstract the more times you build something from soup to nuts you will be able to do it better each time right and i don't really like the reach for abstraction right away reach for abstraction is dangerous don't reach for abstraction careful i i pretty much agree with 99 of this other than the abstraction part and then just terminology who cares right yeah yeah i love this song too that's playing but guess what the name is don't use inheritance agenda unless you're really sure that what you're doing is actually the right time to use it and maybe you should always try to use it a couple times a year to make sure that you know how to use it and where it actually fails so that way you can have strong talks with people and really be able to argue why it's a bad choice in this specific instance other than going inheritance is bad because that is just such a stupid take when you have no way to defend it because you heard someone on twitter say it again