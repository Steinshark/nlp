this is a baby monitor or at least it used to be i wanted to find out if the baby monitor was safe and if the communication between the monitor and the camera were encrypted in this video i'll tell you the story of how we got here how i dumped the firmware and what we found when we analyzed it the results were disappointing in my previous video i did a hardware breakdown and found a uart port on the device this uart port gave me a console that allowed me to dump the firmware but this isn't your traditional windows or linux shell this is a limited shell on rtos or a real-time operating system now this rtos won't give me traditional features like ls or cat or anything else you're used to in linux but there are some interesting features that an rtos gives you specifically the ability to read and write memory directly into the physical flash now at first when reading this command i was very nervous that they used the word asic the word asic means application specific integrated circuit which could have meant there were actually two chips on the device one for video encoding and decoding and the actual cpu itself as a separate chip read asic asic asic asic yeah it's all about the a6 i'm a little nervous about that although they could be replacing asic with cpu right but we actually got pretty lucky oh that looks good that's actually awesome the e the e5 it's actually a really good thing now what i'm excited about at this point is i'm seeing a lot of ease in the memory dump if you're not familiar with the arm instruction set the first four bits of the arm instruction is the condition flag it tells the processor when should i run this instruction in arm the condition always is encoded by the hex value e so every arm instruction in arm mode will start with the hex letter e if you see a string of four bytes that are starting with e you're likely seeing arm instructions which means that we are seeing machine code in the flashdome so in theory i should be able to read from a bad address and crash it then it should throw it into a fault state let's do this address there's no way that's correct data abort yep and then it reset that's [ __ ] awesome okay cool what you just saw me get excited about is pretty interesting i started by dumping the flash at address zero and it gave me those 64 bytes of instruction code but what i wanted to try was if i asked the computer to give me memory at an address that didn't exist so hex one two three four one two three four in theory it should crash the device when i got that data abort it meant that the tpu was programmed to allow me to read any address on the device that means memory that's mapped the flash peripherals anything at this point i was sure that i could get a flash dump off of the monitor so i need to write a script that's going to go into this thing and read the data and then rip the data out so let's go ahead and write a script to do this now the plan at this point was simple all i had to do was write a script in python that used pi serial to send some commands and i can use that to programmatically read the firmware from the flash seems simple enough but this is where things started to get a little complicated i'll do import serial slash dev tty acm zero there we go cool all right let's do it did you see that dude look at this look at this let's go baby we're hacking now as you just saw i was pretty excited at this point i was pulling the data out of the device but at this point i only tried hex 1000 bytes that's 4096 roughly a page of memory the method that i was using to pull the firmware was problematic for two reasons one the data was limited by the baud rate of the device it was 115 200 meaning at a max i could only get around a hundred thousand symbols out of the device per second which in terms of converting that from hex back down to bytes it was extremely slow to rip out the entire flash two the device wanted to turn on the speaker every four seconds because the monitor is not plugged into an actual camera i was trying to alert me this happened in an interrupt and because of that it was interrupting my process to read the memory taking the slowness of this process combined with the constant data interruption made my ability to read the firmware very complicated with my current technique x0 [ __ ] at this point i was extremely frustrated every couple of seconds the speaker on or speaker off message would come into the uart output i would try to base 16 decode that value obviously that doesn't work so my program would crash on day two stream convinced me that i should just dump the entire thing in ascii save that to a file and then do the processing in post using regex i know some of us hate regex but it actually made it very easy and allowed me to get the firmware dump in a matter of minutes reg slash bracket ox 0 through f of eight of those close bracket space space no no colon white space right up until hex zero knot or zero through f you're through f eight of those that in a capture group and then three of those around four of those y'all are so smart dude i swear to god so after two hours of stream essentially teaching me how to do regex and how to use it properly in python i was able to use regex to rip the ascii dump that i got from the uart console and convert that dump into the firmware blob all right so let's execute this file at this point we had the flash image and it was awesome you're probably curious how i knew when to stop there was no encoded information about how big the flash image was at the end of the flash you see me get a series of a5s a5 is a value that manufacturers of flash put into the flash as the default value the sequence of a5 and hex is one zero one zero zero one zero one this value is statistically more likely to do what's called flash wear leveling instead of it being zero or all f's the number of bits will have to get flipped for your data to reflect the data that you want is lower we knew we got to the end of flash when we saw the manufacturer value for the flash start to appear we've finally done it after all these years so at this point i had the image loaded up into ghidro and i was ready to start tearing into the binary but let's remind ourselves why we're here the the story here the reason we're here is i'm trying to see is the data that my baby monitor sends to my camera in my son's room in the future right when he gets here is it encrypted i just want to make sure that the data this device is sending between itself and the camera is encrypted that's it once i confirm that that's happening we're good to go we can stop the video the next thing that i found is a little weird this means that the rtos they shipped it with was compiled with a cipher library but like where like what what are the functions the firmware was obviously compiled with some kind of cipher library in the image meaning that functions likely existed at some point that you could use to encrypt or decrypt things but when i was combing through the code in ghidra i wasn't able to find any allusions to an encrypt function and aes function a des function nothing there was no signs of encryption anywhere also there were no allusions to anything regarding the cipher library that was supposedly baked into the device so kernel h26 this is either in code or encrypt so like it's either that they're encrypting my data which is great that's what i want here or it's encoding it and not doing anything secure anything short of me completely reverse engineering the binary and figuring out what every little function did i wasn't able to conclude this device actually used encryption between the camera and the monitor so with all that being said in the thrilling conclusion to this series in the next video we will be taking an rf capture of the communication between a baby monitor and the camera and seeing is that link encrypted and putting our results here on this channel if you're new here hit that sub button hit the like button while you're at it and then go watch this video about just just go watch it i don't have to tell you it's right it's right in front of you let's click it thank you