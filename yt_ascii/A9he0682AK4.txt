while our minds are focused on programming it's our fingers our muscle memories that are getting slowly marinated in the tools that we use me think about your editor it's there just at the edge of your consciousness for 40 hours a week for years on end it's inevitably going to seep right into your bones i think that's why as programmers we get so attached to our editors they don't just have pros and cons as pieces of software they can actually feel right or wrong and so this week i'm not going to tell you which editor to use anymore than i tell you how to feel but i am going to raise the big question how do you make such an important tool feel good my guest this week tj dev i think would answer that it comes through the ability to mold and shape to gradually personalize our tools until they fit us perfectly and the way that he does that is with neovim it's a fork of vim which even if you don't use it you have to be impressed by it i mean how many times in this industry have you seen a 30-year-old code base get a new lease of life it doesn't happen and yet they've done it successfully i think banks airlines governments would give their right arm for the secret to revitalizing three decade old software so this week we're going to talk about near them both as a major software project and as a personal developer experience and as we talk through it tj makes a really interesting point that i think i'm going to highlight here before we get stuck in for many of us the editor is the first tool where you all tweak and refine and become both the user and the developer in a perfect feedback loop so you can see your editor as a kind of free training ground for developer centric design it might be your first experience of being a product manager and it starts with eating your own dog food as you are the user of the thing you want to refine all from the humble editor that you just can't quit let's get stuck in and learning i'm your host chris jenkins this is developer voices and today's voice is tj dev joining me fresh from the text editor minds tj de tj how are you doing i'm doing great happy to be here and chatting about neovim and wherever else this conversation takes us so way to find out right yeah exactly so i thought we'd start of all the technical things we need to get into i thought we'd start a bit with the personal angle cuz there are so many different projects you could be devoting your time to why and editor yeah i think part of it is i sort of stumbled into doing this as i was like a very you know young software developer i was at my first like software internship and a coworker of mine used vim and i was like he was one of my favorite co-workers to work with super nice and kind and really like helpful and i just saw the cool stuff he was doing so i sort of got interested in the editor sp space more broadly you know like up until then i had like seen eclipse right like i don't know that doesn't seem like my favorite thing to contribute although some people like it that's fine you know but at that time neovim was just starting to come out and i found out about this capability that neovim had which and still has which is the ability to write plugins in any language and all of a sudden i was like my mind was blown i can write code and then when i'm writing code it can do stuff for me you know like i'm my own customer i'm i'm my own you know person i can solve all my own problems with this this is so cool and interesting and got me really you know just excited and so i i was trying it out and i stumbled into a small problem as well that i had where i wanted to be able to center like the file name in my status line and it wasn't like an option that you could do right so i was like i don't know whatever and and sort of my you know my naive propelled me into sending in a pull request and all this stuff right like i barely know git i i messed up the git history they had to like cherry pick the pr you know like i don't know what's going on but you know throughout it just really nice people in the project really willing especially you know i'm i'm very glad looking back at it that i was courteous and i was like valued their time and wrote a lot of tests and documentation and sort of made it a very well-rounded pr not just like a threw a grenade over the wall here's my code like figure it out right and so we worked through a lot of the ideas together and i learned you know so much from from doing that even though i had sometimes very little idea what i was doing at the start and that sort of got me very intrigued in the project and really interested in that space and it's a nice intersection of a lot of the things that i like doing which i just like working on developer tools i like being the customer of what i'm building i think it gives me you know a lot of insight it's really fun to not just solve like other people's problems really solve to fund my solve my own problems i'm like oh it worked it did the thing that i wanted that's great so that's that's i think sort of how i got started in in that whole space and you know related to neovim right with different plugins and and other things like that yeah yeah it's always particularly nice when you're also a user of the thing you're building as a programmer and you you end up with so much better quality cuz you see the problems so much faster right and you actually are very motivated to fix them cuz they bother you every day yeah yeah before the public finds out i need this sorted exactly so there's a lot of stuff already in there we need to unpack and i think i'm going to pick on the first one which was i know when it was first announced perhaps i should go back a step yeah i was a vim user for a long time and the thing that ejected me out of vim was the awfulness of vim script going to go and record saying i hate that language yeah and the thing i found interesting about neovim was this bring your own configuration bring your own plug-in language thing yep which seems to have disappeared so it's still it's still there and there are still some plugins that take advantage of this for sure so neovim has this concept of they're called remote plugins and instead of the vim way that had kind of had it before where you compiled in the feature for language right you would have like vim with the python feature or vim with the pro feature right so if you do like version in vim it'll print off all the features one of the features would be like if it's compiled in with this language right and there's been some changes there and some improvements although i haven't followed that too closely but neovim sort of said let's rip all of those out and instead what we'll do is we'll provide just an rpc and like an api that we promise will will keep the same right so you communicate back and forth with neovim via message pack you send messages neovim says okay i can handle those messages and i can do things and so you can take any language you want and and write plugins with that and there definitely are still some plugins using that quite successfully what's really nice about that is lua also has full access to that same api and so that was a really big sort of like stepping stone for lua integration with neovim was we already had the full api available right and it felt really good to be able to the same tools and tips and tricks you learn how to do it if you're writing a python plugin you were able to do those same tricks inside lua you know the nice thing for lua is it doesn't require any extra installation step or any environment things or oh you have to have you know like cargo installed on your computer or the exact python version right so there is some aspect where i think a lot of people thought of said actually you know lua is good enough for the things that i'm trying to do right it's definitely good enough for this and it's fast enough and and i've got and you know the tooling around it's gotten good enough that i think i can just solve the problem without reaching for something else you know and the other thing is once you start reaching for something else you tend to start think oh it's not so bad to like include the kitchen sink right i'll just add a few dependencies oh i'll just add one or two and suddenly you're like oh h that's actually you know like a lot bigger it's a lot bigger than we set out to do it's a lot more right and so there's some i think constraining feature that people enjoy about just using the buil-in lua sort of experience there but it's still 100% supported in neovim and there are still plugins that that use it in fact recently i was showing off some of those by writing like a random one in o camel which has been the language that i've been playing with and it's like it works just the same as all the other languages right neovim doesn't care what the other language is it's just sending messages back and forth which is really cool so does that mean that lu which is the blessed language is that using that rpc call mechanism internally so it uses the same shape but we don't have to use the rpc so we basically like during build time we create it's not exactly a shared library but it's like similar concept to like a shared library that lua can communicate with neovim directly in process so it's not doing any like it's not doing any transforming it into a message sending the me you know it skips all of that serialization and all those kind of things and run the same but don't write to don't write to a pipe b and you get a couple things where you get some extra special things in lua where you can like directly pass a call back right because you're not serializing so you can like have a function reference and it works just fine you don't have to do any sort of like additional keeping track of oh i sent this message later i want to reply with this you just like send the function over so there's you you' put it in the same spot as you would you know if you were sending over rpc but you get like you get to cheat a little bit compared to that in lua because we don't have to serialize right we can just pass the lua reference around in the c code and and everybody's happy yeah that makes sense it's mostly honest yes right exactly yeah okay so the the obvious question there then is of all the languages you could have picked a bless why lure it's a really good question and people have this question a lot you know they kind of wonder like why didn't we just put you know v8 inside or why didn't we put like wum or why not like python like lots of people know python yeah so there's there's a couple things one some of those technologies were very different when neovim started you wouldn't you know i don't even remember if wm was around maybe wm was around when neovim started we're talking 2016 right they're probably both experimental projects back then yeah yeah right and definitely not like oh you can build it on every platform and everyone gets why it would be a good idea right so but like besides all of the those things neovim in my mind is one of the sort of like perfect use cases for lua lua is a very simple and small language and the features that it has are things like it you can build it practically anywhere it's you know just plain i think like it compiles on c89 or c9 i don't so it's like anywhere with a c compiler you're going to be able to compile lua and it's going to work we use the lua 5.1 version which is set in stone there's no like changes right so anything that you've ever written in lua that you knew of from lua 5.1 always works forever in ne of them there's no sort of like oh well that's not the way that things are anymore we added this new special keyword or something right there's no there's none of that there's no there's no changes there l is also super super easy to embed inside of a ca which neo's written in c and so what's really powerful right is that we can put lua right side by side with where we would have stored like a vim script reference or like a vim script right you just like oh well you just make a union and see you say oh either we've got you know this we've got a vim script thingy or we've got a string or we've got a lua reference if we have the lua reference then we use that and execute it in the lua state or you know do the things that we were normally doing before and then once we're done we tell lua hey i don't i don't need this reference anymore and then if no one else is holding on to the reference lu's you know garbage collects it out and all of those goodies right so it's really really easy to put this sort of side by side with a c program and and sort of like we didn't have to throw away everything right we didn't have to re-architect the whole project or redo all of these other things to get lua running and then sort there's two probably other primary things one of them is that lua has a pretty active you know ecosystem in terms of the things going on in the world people are like writing lua it happens in you know game mods or inside of like engine a or other things right so there exists people who care about things like it would be really good if we had a very very fast json parser and it's like okay yeah well then we just pull that in you know we just we we can grab lou c json we can put that inside of neovim all the json parsing ization d serialization boom it was like i don't remember 30x faster than what we had before that was like inside of themm that was you know handrolled for some stuff right so it's like okay so we just like boosted everything by 30x which matters a lot if you're serializing lots of messages with you know lsp or things like that yeah and so that's really powerful as you get to pull in the ecosystem for some things and then the last sort of thing is a lot of people that are using neovim by default instead of having just lua 5.1 sort of lua 5.1 actually the regular thing we're actually shipping lua jit which is a jit sort of like compiler interpreter whatever you want to say jits are i guess you know i don't some people are very particular about the words for that i guess but okay lua jit is like an incredibly incredibly fast like runtime for lua that's abi compatible with lua 5.1 so you literally can't tell from like edting it in the project which one you're using you'd have to you know ask it what what your version is and it'll tell you i'm luit instead and it's incredibly fast which is nice for things you want to run on every key stroke or every time text changes or right you would be like oh it's it's it's really nice to have that speed running over and over inside inside your editor so sort of all of those together bring it to a place where it's really powerful and easy to embed and then like as an overall summary the language is small and that's good i think for a scripting language inside an editor we don't want it to be like you have to get a bachelor's degree in neovim to like start configuring right like it feels that way sometimes say for like writing a jet brains plugin like i've written a jet brains plug and jet brains are awesome idees but it's really you don't just casually stumble into writing a jet brains plug and like oh something's kind of bothering me i'm going to just whip up this whole extra ide experience i'm going to write a few random java classes and i'm going to come out on the other side with the exper it's it's not it's not like that right you have this whole world of things you have to work on and understand and the space of people using neovim is huge you know all the way oh i'm doing hardware or i'm doing embedded or i'm doing firmware i'm doing software i'm doing front end i'm doing right so you have this huge space so you want to pick a language that like is the quickest for anybody to be able to pick up in a lot of ways right and and is definitely in my mind that you know you want to store data you've got a table that's it doesn't matter how you want to store it you've got tables right one one dat structure to rule the mole right right exactly right and so so lua has this idea it's it's called mechanisms over policies and so this this sort of idea that we it gives you the features that you need to build something like an objectoriented system inside lua but it's not going to say here's five keywords that you need to learn to make those right it's it's all built off of the same same ideas so you master those bas mechanisms and then you can do anything you want in lua instead of like oh i have to go memorize the 100 plus keywords to be able to do those things not that there's anything wrong with languages that do that i i like plenty of languages that do that but it is very different to sort of force people into that to just get started with configuring an editor that's primary one of its primary features is configurability right you're like you you need to get there some and l is a really nice stepping stone to do that yeah yeah i think it's it's like targeting the the habits and the needs of the audience i found that anytime i'm configuring my editor it's probably something i'm just that's bugging me and i fix up in a lunchtime yep so something lightweight that you can just jump in and write a few lines of without thinking too much right yes and l is really great at that and it also scales reasonably well to writing larger things with some improvements people have been making in the ecosystem with some something like if you're familiar with js doc you know the sort of style of writing javascript types in a comment above the function and like yeah so it's it's like in some ways kind of an alternative typescript but it's not it's not in the code right you write some comments and then the lsp will like parse those and say oh i can tell that this type or these types don't actually match if you said so have a similar thing in lua where you can you know write the types of certain functions and and all this kind of stuff right and and the tooling around that is getting really surprisingly good for for lua and so you can still get some of this thing where it says hey you said you were supposed to pass three arguments but you only pass two right even though lua like allows you to do that and all this other stuff right sort of like opting in which is nice for people writing plugins or larger things inside but then you can kind of skip those if you're just writing a random thing for yourself to fix the problem during lunch time so it scales pretty nicely with some of the the tooling that's coming out which is great as well yeah yeah a lot of like plug-in editor things or configuration things they're short and i i often think there's not much to choose between languages below about a thousand lines pick the one you like the most yeah when it it's when it gets large that the different language features really project themselves out right yeah yeah so maybe we should talk about how you've used lure in anger to configure him because you've you've written a few important plugins right yep mhm yeah so i i've done a few i i've written a lot of lua and i i i hesitate to admit it in public i've written a lot of mm scripts okay i'll just put it out there maybe that makes the rest of this podcast you know people people are all done listening to my opinions i mean i just want to know how badly you sinned in a former life exactly i've written many thousands of lines of vim script so not just not just like oh he wrote you know some config i i wrote a lot of stuff in fact i even wrote on our progression of getting lsp into neovim i wrote an lsp client in vim script in sort of in in hopes of you know maybe one day getting that put inside of vim and some other things we eventually wrote that in lua partially performance partially we we just wanted to be able to iterate and make it like our own design and stuff and not have to worry about trying to to get those mixed together and everything but so that was one project i guess eventually that i wrote in a lot of in lua there were a couple other key contributors as well who really pushed the neovim lsp project forward but i've written a lot of stuff for lsp inside of neovim the the other one that a lot of people will know if they use neovim is a project called telescope telescope is a fuzzy finder for neovim and it's built like for ne him kind of it started off as just an experiment between i would say trying to push the barriers of lua integration inside neovim i was much earlier in neo's life cycle and i wanted to sort of see where are our edge cases that were running up against where louis support feels oh that's really hard to do and it shouldn't be right yeah and so i was trying to push some of those boundaries as well as explore like can we write something that is really fast in lua right how fast can it really be can it sort a 100 items every keystroke can it stroke can it do a thousand can it do 10,000 right and sort of explore some of those boundaries and also i was interested to see if we could provide an experience kind of like fcf which i love and think is amazing fcf is a a fuzzy finder that people used inside neovim and also like from the terminal and some other places that searches it's written and go really fast really awesome project i wanted to see could i build a project that's like that but it like is inside neovim in a like built-in kind of fashion right in the sense that like oh it reuses your color scheme can you make it so that it's all your colors right it doesn't look different because you're running it from the command line and piping it in does it does it use your colors can you make it so that it knows about every neovim feature right it knows what key maps you have the commands auto commands color schemes you know highlights anything you know can can we make it do all of these things and so it was kind of just an experiment there but that ended up being very large and and pretty successful it's way more successful than i had imagined starting it on my twitch stream and playing around with the idea that people were gonna really want to use it and so that's one and then maybe like the goofiest lua project that i worked on the project isn't really written in lua it's written in rust actually but you there's a lot of lua going on inside the project which is a vim n script to lua transpiler so it takes in vim 9 script which we can talk about a little bit if you want and turns that into lua that can execute inside of neovim which was also quite a fun project hang on i think back up a little bit there so vim 9 script is not vim script that's correct so vim 8 was the vim 8. something was the vim version that most people have probably used if they've been using vim anytime in the last say 15 or 20 years i think maybe it's not quite that long but m8 has been around for a long time i probably misspoken someone's going to say hasn't been that long but it felt like that for me it was vim 8 for like as long as i can remember basically i think vim forked at about or neo vim forked at about 7.4 okay so maybe eight is like 10 years old or something like that and so one of the things that the community was asking for on the vim side was we'd really like to be able to write plugins that go fast right if you don't know vim script is a literal line by line interpreted like language so if you have a for loop and you have 10 lines inside the for loop it will read the first line read the 10 lines inside go back and reparse eval and run each line line but so it's like you know if you have a tight loop of something you have a lot of extra overhead that you don't need but it's there because of the way that vim script evolved from just x commands into programming language so there's lots of sort of good historical reasons for that so so bram said okay like let's see what he said let's see what i can do to make that happen and so he made sort of an upgraded version of vim script called vim n script that is like you like in some ways it's backwards compat in the sense that like you still can do vim script things inside of vim 9 script there's no like deleading the old vim script right it's like still there but it's like there's all these new language fe on top and effectively there's like a a part of the language now that's like typed it gets compiled into bite code the bite code gets run like it does all this extra stuff right and and and it's like definitely better than vim script like he made a lot of decisions that are much better than than original vim script right which is not you know he got a chance to to revisit some of those so that's that's cool but neovim wasn't ready it just isn't able basically to like port all of those changes maintain all of those keep all of that working inside of neovim so we were kind of at like this impass right of saying like okay we have this new thing that's going on in vim vim 9 script it's like an upgraded version of vim script right we want to be able to still share things like the runtime files and when i say runtime files i mean like oh you load a c file and it's going to run some code to set up vim or neo for c we like share those as much as possible with them we send upstream patches we know something when we see something is missing we pull their patches and update art code okay okay but if they start using vib n script we like lose that right and that's like that's sad we don't want to do that we like we like them we love them you know like we want to work with them we want to make sure like both are the best editors they can be how can we make that happen so kind of did like an exploratory project that turned out to actually work surprisingly well and there's a couple files like right now if you're using neovim you're using a couple files that have been transpiled from vim 9 script into lua and they're like shipped by default inside of neovim and no one's reported any issues that i know of so they must be working yeah yeah that's that's good enough for his a qa report yeah yeah exactly so you actually sat down and wrote rust vim 9 script to lure compiler yes yep i i certainly did yep how did that go so it was it was kind of funny because i had tried before for a few times i i tried kind of a few iterations of the project where i' had written some of it in in lua before but it ended up just getting too unwieldy like the project was really big it was really i i lou is a great language but i wouldn't want to write like a compiler in it right like you you don't have exhaustive matching you don't have you know you like want to be able to like make a sum type and have exhaustive matching on the sum types and pattern match out and do and like okay well you've picked the wrong language then it's like okay we don't need that fora we we just don't there's there's different options you can do that are better so eventually i landed on trying it out in rust and it it it works so like it's just like how you would do any other language right in the sense that like okay i write axir like okay the lexer is a little bit more complicated than some other languages because we have to handle some weirdness around detecting vim 9 script versus vim script blah blah blah stuff like this right and then okay so now we've got our lexer now we just write our parser okay our parser is going to start putting these into vim constructs you know oh i see the autoc command keyword i know what coming next we've got to parse auto commands right so we turn that stream of tokens into an auto command structure oh i see that now we're in a function call okay we're going to put it so you know same thing you would do for any other language and then okay sure so now we need to get to our like compile step basically right but instead of like targeting llvm we we target writing lua code you know like and so the output instead of being like bite code is a big string that we save to a lua file and there you go so in some ways you know that part's easier right because you can you can write some you know lua helper functions and do some stuff and load those in as libraries and you can you know just like pull those in and do you know like runtime analysis of stuff like oh i actually don't know what function i need to call if this is a string versus if it's a dictionary okay well we can just check the type you know and we and we can do that so so there's some parts about that are way simpler than if you're were trying to like actually i would say like basically everything about it is simpler than trying to target something like llvm right you're like it's it's way it's way harder and the other kind of fun part about it right is like since you're outputting to lua i can just read the code and see if it looks good or not right which is kind of funny as opposed to like h okay so i see 0x 073 2221 you like like you know that that seems actually in some ways you know harder than if your if your output is lode and then the the sort of side thing with that is like i don't actually have to do the entire language and every like possibly cursed thing you could think of to do right like our goal for the project was can we take the like normative things that get inside of vim's repo and can we turn those into reasonable lua and like they're great developers they're smart software developers they're not just going to like let someone merge in something absolutely insane that's like abusing all of the features of vim n script right so i can sort of like handwave away some things and say well i know technically you could i don't know construct a function by concatenating two strings and executing and eving those and you okay yeah cool they're not going to do that so i'm safe you know like and so there's some aspects where you know at least up until now i you know i've been able to sort of handwave away those problems we don't have to worry about that our primary focus and like the constraint that we have is we want to be able to keep sharing code between vim and neovim where we can and and like how can we solve that and that turned out to be at least for now and for some files like a viable way to do that yeah yeah i can see how that's a much more tractable problem it first seems cuz you're you're dealing with a not the whole source language but a sensible subset of it you've got control over whether it suddenly goes wrong you don't have to immediately be able to support every feature that's out there and i do you know i often think the the dividing line between what's a compiler and what's a transpiler is would you like to write the output language h that's a good it's a good definition yeah yeah yeah and lua is fun to write so it's like then in that sense it would definitely be a transpiler and the other thing that's sort of like interesting about it is for some features that are exactly the same between vim script and vim 9 script i don't have to do any transpiling i just tell neovim run the vim script code which is sort of another funny thing right i have already this vim script evaluator in neovim yeah right so there's some aspects too where we got to do even easier hand waving of being like oh i see a syntax command okay well those are the same so just tell ne of him to evaluate and move on you know was like got to got to wipe my hands clean and move on from handling those which was another sort of funny funny aspect of it and it was a it's a fun project like it's it's pretty fun to try and basically write your own language you know i didn't get to control the syntax but everything besides that i sort of get to contr and you know some of the things but like it actually is getting used by someone you know like it's always been something i'd like to do is write a language but i'm like who's going to use my language you know but this one people are using it's you know it's shipped to at least you know dozens and dozens of people's computers you know yeah i've never thought of that as a selling point for writing transpilers but they will it will be won't it yeah totally that's cool so we're getting into this cuz on the surface that sounds like a very niche unique situation for you to face compiling name script to a language that already supports a subset of it yes but there's a much bigger issue here at play which is weird languages and maintaining and forking and i'm wondering looking at vim as a 30-year-old project and forking it in a way that works and brings some new life to the project and is successful is there anything we can learn in general about like bringing life to longstanding legacy projects yeah i mean one thing that's nice is like vim it still has a lot of life in it so it's like it's it's good to you know be forking a project that is currently successful and people enjoy and use so that's like a nice starting point and definitely not to be underestimated in a lot of neovim success i don't say anything against vim but no definitely that's i yeah i was more saying like that's a helpful starting point if you want to have a successful project finding the project that people already like is a good starting place and then i think really important to this is you really need to sort of decide what are what makes you different you know from a project either that you're foring or that you're doing and can you sort of constrain your vision to to a targetable and achievable goal and can you make sure that that goal doesn't like expand for no reason and that all the things that you're doing doing both like process and technical decision projects you decide to do projects you don't decide to do that they're in service of that but then also you need to i think really important thing is communicate what those are so that the people who are coming to your project aren't surprised right when they when they you know why does a neovim have x well if x clearly contradicts the stated goals of neovim right of being like this hyperextensible modern editor leveraging you know technologies that are useful in the world around us right if if that x doesn't make sense then okay then that's clear we can just say no and we can sort of say we're not going to do that because it doesn't it doesn't match up and that's really powerful and i think that vision shared both between the people working on the project but also the people using and contributing in the community is really really important for for the success of like an open source project yeah yeah i can see that but then again i i'm i'm going to push you up this cuz i i'm thinking of like bank projects right that's the classic you've got 30y old software absolutely works today for for a given value of works yes everyone once and you get two projects that come out of that one of them says we're going to we're going to redo this in a way that adds in all these new features we wanted for years and that fails because of scope creep the other one says oh no we're not going to do that what we're going to do is sure we're going to rework the existing infrastructure and that sort of gets there but it sort of turns into a naval gazing project that never actually launches anything that's different from what's already there yep how do you avoid going into those two pits yeah that's a really good question so i think neovim has been able to avoid that i would say a huge reason is neovim has a lot of tests a lot of unit tests which is good for small units of code where we can verify that the behavior that you know before we refactored it is the same as vims which is really helpful but also we have a lot of i think really impressive like functional test you know sort of end to end it's weird to call them like integration test because it's not integrating anything it's just neoven but like functional tests are usually what we call them where we can run and do stuff in control the ovm and we can like assert stuff about what the screen looks like afterwards so you run it on like you know an 80 by 24 screen right or whatever and then you can literally like write out what the screen looks like and say the cursor should be here the highlight should look like this because you're screenshotting it as a but not as an image as actual it's just text right so they're just they're just columns and char you know columns and rows with characters in them with you know attributes associated with them so you can literally like literally write this oh it should be in this mode it should be showing this mode right you know all that sort of things and the testing for that is really really good really really powerful and like a key thing that e of him does for a lot of stuff so particularly for you know the second kind of project you said we were saying oh well we actually can't rewrite this no one can effectively like rewrite it what you're going to do is you're accidentally going to miss the reasons why a bunch of this we'll say cru exists right you're like oh this this if statement must never happen why would this even be here why is this 80 lines of code even here and then two years later you get the bug you add the same if statement back in and find out the hard way right and now it's not designed to be able to handle the if statement that way so it's three times as much code and you broke your perfect abstraction right which is fine if you don't need to replicate any behavior maybe right but if you're trying to be a proper fork which neovim is right in the sense that like if you open up vim and you open up neovim you really can't tell the difference out of the box right and but all the simple things you do in vim will be the same as neovim you need you you need some way to do that and make that easy and there was so much work especially done at the beginning of the project to just build out this whole testing infrastructure build these tests asserting the behavior you write the test before you're making sure that it's going to be able to do the same thing as vim does except for when we're like calling out that we want to change your behavior oh we're going to change this default because we think this default is better or something right you know then it's like okay well then the test change and we can confirm that like the default change that's good yeah you know so so there's sort of like there's a lot of things like that but i think for us for the kind of project that neovim is this sort of end to end and functional test which like if i was in charge of redoing some bank software oh man the first i don't know how long would be we got to figure out what the behavior is before we before we try and replicate it or change it right because a lot of the times it's not clear and i think people sometimes have a like a predisposition to say well i can just read it and i can know what the behavior is and then i can just write the better version and it's like well i'm not good enough as a developer to do that i need to write something down to to confirm what it is and then the other problem is you kind of want to be able to keep that behavior so even if you do it on the first try you got it right it'd still be good if in a year you could still count on your bank handling you know case xyz correctly and your money not disappearing right like so i think i don't know that that's honestly probably one of the things that i think you know you can go and look and neov them's just got folder after folder of all of these tests and all these different platforms and everything right because we want to make sure we're not you know degrading any of those things and then after you do that it really sets you free to write a big refactor of stuff right like when i i i i don't remember a year or year and a half ago i rewrote a lot of the autoc commands code in neov which is kind of like event listeners event listeners for those people who don't are familiar with on on file opened hook that kind of thing exactly yep so i rewrote a lot of that code to let you pass lua like lua deep into that stack so you could just pass lua functions directly into into that like sort of area right and as i was doing that i just took every test that vim had if we hadn't poured them all yet for auto commands and every test we had for auto commands and i ran it every time i saved i saved my files and if something broke as i was changing stuff then i realized okay i've broken behavior for autoc commands we need to fix this or if i stumbled onto behavior that i thought hm it really looks like if you run three separate autoc commands in a row they run like they're right after each other you know so you're like okay so it looks like that's the case i don't know vim and neo have been around for a long time someone's probably depending on that behavior right even if it's even if it's not documented even if we're not like making a promise about that if i can make it so that it doesn't break that that's really good and so you know iterating on that adding lots and lots of tests adding lots and lots of ideas and the nice thing for the neovim tests we make them run really fast i think that's another sort of core requirement is if you can make them run fast then people will run them and if they run slow people won't yeah yeah so yeah that's that's what i would do you know if i'm if i'm trying to revitalize some legacy project you know at work or whatever i'm going to be starting with building out this fast test suite that's going to be telling me am i able to make the same make the same behavior because that's really important yeah because the danger is with big rewrites is that you think you know what you're getting into whereas writing down a lot of tests says you know precisely what you're aiming for mhm yeah i don't know if you've ever if you've ever experienced this where you see a chunk of code and then you're think oh it's so ugly well first off i usually wrote it right so you're like oh it's so but besides that case right besides that case you know you you look at anything oh it's so ugly like i can definitely rewrite this and make it better like i'm smarter now or we know more now and then you like you know you spend a few days hacking or whatever on it you're writing it and then you get done and it's the same exact code that you had before yeah that can happen and so you know rewrites tend to suffer from this problem there's so many places along the way whether it's forgetting some behavior or not solving the original problems or adding some new behavior some adding pathologically bad case that you didn't know and yours ends up slow there's like all these things that without measuring and without actually you know putting the science in computer science i guess you know you could say like you're you're just sort of going off of your gut and like sometimes that works good i mean some people are really good at this and they're just able to sit down like i don't have this i don't have that gift that's okay you know i like to write the tests i like to make sure i'm doing what i want and then and then i can iterate on it just like i would iterate on you know any other project and i find like fast iteration tends to beat like full rewrites right and that like that's been my experience in ne them is that we're able to iterate really quickly on a lot of these features with confidence because we we have good you know test i don't like saying test coverage because it makes it sound like we're counting lines we're not doing like line you know but like test coverage of feature in the feature sense and it makes you feel really confident that like yep i got green on ci i didn't mess anything up sweet let's merge it and we'll we'll keep moving and that's really really powerful to like push a project forward and allow people to explore and try new ideas even if you scrap a pr and you're like that wasn't the right way had a few prs where i've scrapped them you know for neovim or whatever right it's still like oh i was able to find out it was a bad idea instead of like living with the regret of never shipping that feature like it was actually a bad feature you know it was i was wrong that's okay moving on yeah this raises the question then of all the obvious possible choices what are the what's the test suite written in that work lu yeah lua i was wondering yeah that was actually one of the ways that lua started cuz like even before lua was like properly the scripting language we had a lot of like tooling and some other things built around neovim that was using lua and like the nice thing is you can really easily hook into the ffi and all this other stuff right so you can like load out constants from vim or you can call functions or you can you can like do stuff at that sort of abi level in that like se level that like is very difficult sometimes to do otherwise or requires a lot of maintenance oh we've got you you know 10,000 constants over here we need to make sure they're all the same between these two languages o painful right yeah and we even i don't actually know exactly when this started i'd have to go check some of the history because i wasn't involved with this part but we were even you know doing some simple things where we would generate some code from lua so that we could have like some introspection into something like generating docs based on like a lua table and then you would generate some like very simple c file right with with those things as comments right but then you get those you can like put those into the documentation you can like save those off somewhere do other things like that so it's like lua was kind of used in some of the build and testing stuff before it was even sort of like the official scripting language of neoven which is really powerful right so if i want to do this at the bank i need a lightweight scripting language that's really fast that has good ffi with cobalt yeah which would probably be lua cuz i'm sure cobalt has like good ffi with c and so then you're already done basically you you just like you just could pretend probably in the middle or something like that so you want to talk about neovim but you're also proving to be an ambassador for lua too yeah i am i am a huge i am a huge fan of lua i think it's a really elegant and beautiful language that composes lots of little small things together you know and makes it in makes you able to build big things which i think is just super cool so yes huge fan so i'm going to ask you this is a bit of world card but one of the things so i used vim original one for like 10 years got dis got disillusioned by vim script and switched using emac in vim mode because it has a really good vim emulator right one thing i think emac does really well as an editor that you want to tweak is you can do kind of interactive writing of code so you can write some code and evaluate it and it's already running in the editor what's the support for writing l in neovim to change neovim as you're writing it yeah it's actually i think really good so lua has this concept of sort of like packages or modules they're just files basically right and like files are just a big chunk of lua code they're like calling a function right and so you can actually just tell lua hey reload this file and it will just do it and in the current execution state right or you can just re-execute the current file that you're in if that's all you're doing right but if you want to sort of like update all the references you would need to tell lua please reload the file like properly right and you can do that interactively and that's how i develop most of my neovim like plugins that i write is i just reload it live as i'm going i resource either the file or tell it to reload you know like five files or something like that it'll just it'll just do that and besides for a few sort of like edge cases i mean if you want to test like does it work when neovim starts up you you kind of got to like you know you kind of got to go do you got to go restart it right i mean it's nice cuz usually like mind of them starts in like 50 milliseconds or something so it's not like it's a super pain to close and close and run it again but but i think that the support for that in lua is really good it's very interactive there's no sort of like state that you can't reset especially if you're sort of setting up your your plugins or your in your things to be done like this you know maybe if you're doing like a million globals and you're like doing this complicated web of like references you'll have a really hard time solving that but if it's sort of like i just want to reload easy peasy no problem at all real really easy to do in lu cool then i mean because you're coming across as a power editor user obviously you're falling down that rabbit hole yes i'm just thinking if we're talking about customizing your editor we should probably talk about why you'd want to if someone's there using i don't want to pick on a particular editor but the editors that you wouldn't do any more than set preferences on y what are they missing out that you as a power editor hacker feel you have so so this is like a common question i get you know like i stream on twitch and i'm doing other stuff like that and so people are like convince me why i should use neovim you know what i mean and and so my answer always is no that's not my point you know that's that's that's not what i'm i'm trying to do and i think so one of the ideas sort of that i've been working on and trying to sort of think about is is why do i like neoven you know like i mean obviously i like it yeah and other people like it too right it's one thing for just me to like it but like lots of other people seem to like it so and the concept sort of that i i have coined i guess with this this idea of like instead of an integrated development environment like an ide right we have this personalized development environment a pte and that there's there's sort of like a few i would say characteristics that define whether something is ide versus pte and like one of them would be that the average user configures the editor by writing a programming language right so they they have to like write code to configure the editor right and that's sort of like in a sense sort of the key defining characteristic of of what makes a what makes a pte and and in the average user is an important part because there's tons of people writing plugins for vs code and jet brains yeah but the average user doesn't even know that that's like possible they just know that there's like a storefront and i don't know they probably think like they're just for microsoft or something right you know what i mean which is totally fine and so so my thought with this is that there are c certain like personalities effectively that are interested or like attracted to this idea and it has no you know it's like it's orthogonal to whether they're a good developer or not it's just completely orthogonal to this i think curiosity in general probably correlates with how good of a or like how effective of a software developer you are but it does not have to be curiosity in the realm of your text editor you can have you can be super curious about network protocols or like how does the browser repaint things or like what's the best way to make this thing look good with css and you're like things to be interested in right exactly right so i think curiosity probably correlates with like effectiveness but i don't think curiosity of your text editor right that's like an additional add-on that comes in but a lot of people i think do enjoy this idea of being curious and interested and tinkering with the tools that they're using every day and then in in addition to that i generally find that people really like and this is this me for me as well they really like removing those small annoyances that like are only possible when you can make it yours there's no possible way for me the maintainer of neovim to predict every way people are going to want to use neovim i'm constantly surprised i'm constantly surprised how i use neovim i'm like i didn't think i was going to do that and then i do it right so if i can't predict my own thing i definitely can't predict everybody else's but if i can make a system that allows people to customize and personalize it to themselves then they can find the way to make that their own right and i think that doesn't appeal to everybody some people are like oh the reason i code is because i want to ship this product then you're probably like really bored with thinking about your editor and you don't even really care right or oh the reason i write code is because i really like you know whatever it is collaborating with other people and solving big problems then you also probably are like can i get this editor out of my way i want to do the other thing right but but like some things they just probably irrationally probably too much they just bother me you know like i had to click three times and i'm like oh my goodness my day is ruined i have three clicks today you know like i can't believe i have to do that every time i want to submit something you know and then and so i'm like well why not just write a function for that why why can't i just do that and then that's what neovim lets me do so that's that idea of like the personalized aspect plus code i think it really appeals to some people and i think a lot of people much you know much smarter and better at this than i am in the neoven project have helped sort of maintain that ability to have a system that follows this sort of lua idea of like mechanisms over policies right in the s we give you the tools that you need to construct the stuff that you want to do we're not going to like prescribe these are the 50,000 different like keywords you need to know or special classes you need to know or you know whatever it is like you don't have to do those things you can just like right le so that's sort of that's at least my current like hypothesis or theory about what's going on why i enjoy it and why other people do and also why for some people it just looks like the biggest and lamest waste of time you know you could imagine right which i i totally i totally get although i will say i do think i've become a much better developer by using neovim not because i use neovim but because i've been able to be my own customer and i've been able to iterate on that and like the feedback loop for me being my own customer and making my own thing is as fast as i can write the code the feedback loop for me iterating on a design and getting it shipped to customers at like a day job you know at at my first place that i worked was a large medical health records company so the my feedback loop for that was like a year and a half that's when i'd find out what customers thought about the feature i made right was like okay it's really hard to iterate on api design on taste on you know performance on on style on all these things right when i don't hear anything back for a year and a half and then if i fix something i don't hear anything back for six months right as opposed to like i'm doing something in neovim i didn't like it okay let's fix it and it's like bo right so you get to like move you get to try a lot of things and so i think it is possible to take some of the struggles that people normally sort of associate with wasting all of your time inside of neovim and turn those into sort of like effective learning opportunities for debugging or reading code or collaborating or contributing to other projects right all these sorts of things oh well i can do those inside neovim and neo neovim is sometimes just like a vehicle for doing those things and i think it's an effective one so it is kind of fun i think people sometimes look past that but i wouldn't do any of them if i didn't think it was fun so i get why they think it's stupid you know like i get both sides i'm with them you know i get it yeah there's also the aspect there of like when making it possible right you couldn't if you're working at a healthc care provider where the feedback loop is a year and a half you can't suddenly decide you want to customize this software right yes and it's the same with editors if you make the bar to just tweaking this little thing very very low and very very easy you might find that your users actually are those personality types and they didn't know yes i think there's probably like some doctors that wish they had the neovim of healthcare records you know what i mean they you know they probably wish that they had that instead of sort of getting a top down you know top down mandate for some of those things or whatever and so yeah there's that's definitely also one of the aspects of like a pte that sort of i think the important bit is your configuration is the code it's the same code that you use to write plugins and do larger larger modifications later right it's like i write lua to configure something small then i do a little bit more lua and i have something big and then eventually i just like accidentally wrote a plugin and you're like oh i could like share this with somebody and it like might be useful to them right and so there's this really cool aspect i think as opposed to the way you configure like vs code is usually through like the settings bar or something json file that's not how you write functionality right so there's a disconnect from there's not a good onramp from zero to plugin as opposed to like for a pde which i made up so i get to choose how it's fine there's that onramp is like it's there right so you have the same on-ramp all the way along and those that language and the way you do it is all the same yeah yeah there's not this sudden w where you switch from the configuration language to the programming language yeah yeah i'm not sure i'm prepared to let that that barrier disappear in my next banking project yes for banking we probably want to configure yeah the wall's really good yes yeah yeah okay so if somebody wanted to if somebody wants to take the plunge and see if maybe they got the tweaking the editor bug i know you have a good place to start so tell me about this yeah so there's a project that was you know sort of started and kicked off initially by some other people in the community but over the last year or two i've sort of taken taken on more of a role in called kickstart en viim and the the goal of that project is very different from say like a neovim distribution not that there's anything wrong with those but different constraints right just like we had talked about before yeah and the goal of of kickstart is like okay it's pretty daunting to go from the editor that you see when you open up neovin with no configuration right to something that you feel like oh i could see myself being productive in this right that's a big there's a big gap there and yeah you kind of have to make a few choices up front which can seem too much yeah yeah and you know if you get unlucky and you stumble onto an article from a year and a half ago and you didn't recognize it then you're going to like set it up in some way and then hear someone else talking about it and everyone's doing something different now or whatever and you're like oh i things ruined even though you probably still gained a lot of valuable information and round two should be easier but regardless of that right so the idea is kind of like kickstart is this is this project that primarily is just this one file we have a few other files in the project to sort of show next steps how you could do other things but they're ancillary they don't actually matter you you don't need those you could just literally copy the anit lua file and paste it into the right spot on your computer and it will work just fine so is this one file and it the goal of that file is to start from zero and tell you either a few places you need to go read like if you've never opened vim or neo before you need to go do vim tutor so that you can like learn that the arrow keys aren't the best way to move around and how to exit the editor right you're like okay so like those two things you kind of like need to you need to get right and like a few tips of where you can learn about lua but but after that it shows you all the basics from setting options like how do i set options how do i change basic configurations how do i start doing key maps how do i start doing auto commands right how do i make that so it's like keymaps are like how do i make the do the editor do something when i do something right then autocommand is like how do i make the editor do something when it does something oh that's a nice way to look at it right and so so you're like expanding the scope of how you can do it and then after we've done those and you're sort of introduced to those we introduce a package manager for for neovim called lazy and it is just like an easy way to get projects from github put them in the right spot get them updated or anywhere you can download now just from github to and like get those installed and set up and we show you the different ways that you can get those projects installed we install some of them and then we show you moving from zero configuration for plugins to some of the more advanced ones the sort of skeleton of how you would set them up right and the project is about last time i checked when i was finished it might be just over it was 299 lines of code and about 400 lines of comments and that's all the setup so so i wrote a lot of docs i tried to explain like literally every line right so you can start at the top of the file you read down to the bottom and when you're finished you're like oh okay so this isn't as o overwhelming as i thought right and when you're done you have you know an lsp so you can do autoc completion and go to def and go to references and you see all the key maps that set that up so you're not like lost you're not like okay but how do i do anything it's like okay well you do it by pressing the buttons that you read as you were going through right it has a fuzzy finder for telescope right so you can search through files or you can search through your workspace or you can grp for stuff it has tree sitter setup which initially is just for like doing highlighting and some indenting and things like that and it has autocomplete setup and then it has a few other things you know color scheme and a few other sort of small small aspects going on and so it's like when you're done you have effectively this mini like editing environment that you should be be able to understand i'll say all of it right all of the important bits you understand after reading reading through the file and you're like oh i i can i can compose this with other things i know oh i want to switch the color scheme easy i go to the part where i read about color scheme i switch which one all done oh i want to change the key maps for to cuz i don't like pressing g before i gd for go to definition i don't like g i want to press control enter or something okay well i just go to the spot i i change the spot where it said gd and now it says control enter boom i understand it right and i know everything right so the idea is that it kickstarts this journey right because it is definitely a lot to start with and and we've been trying to think you know how can we solve this problem you know in the ov in general because what we don't want to do is sacrifice the extensibility right you don't want to say oh we're going to close off extensibility and the abilities to make it personalized but that doesn't mean that we can't do anything to make it simpler to start right and like kickstart is an attempt that i've been sort of doing for a while and ongoing to help make that first step of your journey right like giving you a kickstart on the journey it's not supposed to be the end goal i'm not saying i told you everything that you need to know i'm hoping that i'm giving you the tools to start being able to do that and then i recently released a video about sort of me walking through that and sort of explaining it out loud some people i think prefer hearing especially at the beginning you know some thoughts about it as opposed to to reading it so those are sort of like goals of how we can do that onramp right and and like in in the way that i structured the project itself is an on-ramp right in the sense that we start with here's the things you know outside of neovim you need to know these then you need to know about this about neovim and then here's the simplest thing you can do little more advanced a little more advanced plugins simple plugins more advanced plugins big plugins right and so it's sort of that same onramp so ideally you're not sort of like bombarded with 80 concepts at once you can do them one at a time yeah yeah yeah and i do think there's like there's a difference in between tools that cater for beginners or occasional users and tools that cater for people that are going to use this 40 hours a week for the next 10 years yes but that doesn't mean it has to be a binary choice between these people get a good experience and these people get a sucky experience yes 100% yeah it's nice i will as as a parting thought so i thought i should probably let you into this secret a week ago i thought i'll watch your kickstarter video as like prep it's half hour video i thought i'll watch that quickly as prep for this podcast and i still haven't got all way all the way through it because every few lines i go like oh you can do that and i go down my own little rabbit hole yes nice so it's more of a meal than it looks so thank you for that no that's great that's that was definitely we actually had a ious time i recorded that like on my stream so we were live and i you know was doing multiple takes and i was trying to ask people like did this land like did everyone get what i was saying here and so we had to do a lot of tak so it ended up taking like you know i don't remember eight hours or something like that straight of just recording to get down to to the 30 minutes so i'm really glad it came across as like feature packed that is that's you know i'm like sweet mission accomplished i think you may have given me more than 8 hours of work so i'll put a link in the show notes for anyone else that wants to slip down that rabbit hole awesome cool thank you and i should probably go and get the next few snippets of wisdom from there now so tj thank you very much for joining me yeah no problem i had a great time and hopefully everyone gets to have more fun while they're coding whatever however you know you find fun that's what it's all about cheers uhuh thanks thank you tj if you want to get started with neovim take a look in the show notes for links to that kickstarter config we talked about and the walkthrough video that tj made which is really interesting if you vly disagree with my opinion on vim script i will of course respect that but i've put a link in the show notes to vim script's definition of true and false values you can agree or disagree with me but that is the moment it lost my heart my opinions on vim script not withstanding i'd like to dedicate this episode to bram mullinar the creator of vim i think it's such a generous thing he did to spend all those years working on a fantastic tool and a tool that's been with me in one form or another for most of my career bram thank you and rest in peace you're a legend and with that i think it's just time to say if you've enjoyed this episode please take a moment to like rate and share it and make sure you're subscribed because we'll be back next week with more for now i've been your host chris jenkins this has been developer voices with tj dev thanks for listening