the author of this code not me managed to pack seven bugs into this code and the code is only 52 lines long these bugs are all related to memory safety and i've taken advantage of can lead to the program crashing or even worse getting them hacked i want to use it as a talking point to talk about how c is not a memory safe language but first what is memory safety let's talk about memory safety using some pictures i like pictures because i'm kind of a dummy if i am given a pointer that points into some memory location like an array of ins for example here are my array of ins and memory safe language will not allow me to create code and run code that indexes outside of this array or for example if i have a pointer that points to a chunk on the heap and then maybe this chunk gets freed if i'm able to still use this pointer it's referred to as a use after free or a uaf conditions like this were a pointer that you have access to points to memory that you don't act actually control or own leads to your code being not memory safe who really cares you know my program might not crash it's not really that big of a deal the problem is if you give a hacker the ability to arbitrarily write somewhere you're giving them what's called the right what where primitive which is a primitive in hacking that allows a hacker to use that ability to write somewhere to take over your program there are different structures in the elf binary on linux for example called the global offset table that's just a list of function pointers to functions in lib c one of them being printf for example if your code is able to arbitrarily write somewhere they can overwrite the got entry for printf to point somewhere else that may have malicious code that they want to run on your system this code here has a pretty good example about how c is not type safe it may be glaring out to you to some of you more senior c programmers here the vector new function is inherently broken why is that we create a vector structure on the stack we assign some values to it and then we return a pointer to the that structure on the stack however because that variable is stack allocated if any new memory occupies that space that pointer is now dangling to new data that is not the structure you originally intended if you don't understand that example let's go to a more simple example here we create in this program a set of structures that are called points points have attributes x and y we create an array of 10 points and then we say which point would you like to edit and then we index into that array and then set the x and the y coordinate to 69420 obvious the problem with this code is that the index can be any arbitrary length it could be zero which is within that array but it also could be a hundred and ten thousand let's see if we can use this to prove this program is not memory safe so like i said before the program does compile but for right now we're going to run the program what point would you like to edit i like to edit point two because i'm a good user who's not going to abuse the system boom and there's no issue but if i'm a bad user and i want to put in an index it is not in this program i can do this now number here and we have crashed the program if this program were a little more involved with a couple more features where i get to choose x and y i could write an exploit for this program to give me full control of the system the problem that i have with both of these pieces of code is that they both compile while the first program does throw a warning the second one compiles with no error at all c inherently as a language allows the programmer to create code that is unsafe now you could argue that that is a problem that you should lean on the developer to fix and not the programming language itself but the problem is humans are flawed so when they write code they're going to make mistakes a language like c gives the developer too much trust and empowers them to make errors that it otherwise should not allow them to make there's no reason why i should be able to access outside of the point structure and therefore the language is not memory safe rust does not allow these bugs to occur so here i have a structure called point same idea and i implement the new function on the point type and then that new function all it does is it creates a point structure on the local stack for this function and it's mutable and it returns a pointer to that object and we can use that to allocate a point if you think about it the memory dynamic is exactly the same as our original vector problem where we create it on the stack we set some variables and we return it what rust is going to do is russ is going to use the concept of borrowing and say at this point p owns this point structure we're going to return a pointer to p to a function outside of it the pointer is going to live longer than the attribute that actually owns the point structure and because of that the rust compiler will not build this code and not allow me to run it because i've violated the concept of ownership in borrowing by trying to return a pointer to a structure that is not owned by the person outside calling it based on this the idea of ownership and borrowing in rust is the concept that makes rust a memory safe language do want to highlight that it is possible in rust to write code that is not memory safe however to do so you have to explicitly use the unsafe keyword let's talk about what that does i've written two functions here the first is a function read where you can specify the parameter address and then use that address as a pointer and then dereference it to get data if you specified a bad address in this function you would get the data from that address but you also could crash the program just like our c example this is a snippet of rust that is not memory safe but you have to explicitly say that it is unsafe therefore you're directly violating the language and what the compiler requires and the same thing is said here in rust we have ffis that's foreign function interfaces i can link in other libraries that are compiled by other languages like here i have lib c where i can link in the c puts function it prints a string and returns an i32 but to use that function because it's thought to be unsafe i have to wrap it in unsafe it is possible to write non-memory safe rust but you have to do it very intentionally which is not direct use case for the language i do want to highlight that memory safety does not directly imply security memory safety can lead to memory security but all because your program is memory secure does not mean that it's wholly secure if for example you're implementing an unsecure spec your program may be memory safe and memory secure but the idea of your program may be broken in general regardless of that i really highly recommend that anyone who's new to program or even a veteran that's been doing it for 10 years try a memory safe language my favorite is rust and use that as you go forward more and more and more into your projects i do see a world where c and c plus plus maybe not in one year or 10 years but in the future will be replaced by languages like rust that don't allow the programmer to make mistakes that have led to the major security vulnerabilities in the world before we go i want to tell you about a long time supporter of this channel and the sponsor for today's video brilliant what do the world's most successful and productive people all have in common they all learn something new every day and if you think that's too time consuming or over overwhelming or hard to do well then i don't think you've tried brilliant.org brilliant is the best way to quickly learn new math and computer science concepts brilliant is built for busy people designed around bite-sized lessons that break complex topics into understandable parts you won't sit through hours of lessons on brilliant instead you'll be able to master complex topics in as little as 15 minutes a day instead of just sitting through a presentation or watching a bunch of slides go across the screen brilliant lets you try things out and gets your hands dirty as you go you can try everything brilliant has to offer with a free 30-day trial with my url here www.bruary.org low level learning and the first 200 of you to sign up get a 20 discount off your first annual subscription thanks again brilliant for sponsoring this video