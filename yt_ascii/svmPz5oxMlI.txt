lisp is a language that was invented back in the 1950s. it is capable of doing functional programming, but it's actually often misattributed as being a functional programming language. in general, it's a so-called metaprogramming language, or a symbolic programming language. it can be used for any sort of task that you might want do. it's a general-purpose language, lisp. it's been said that learning lisp just helps you be a better programmer in general. it opens up a lot of different ways of thinking that are sort of locked away in languages like java or c++ or what have you. it has a few interesting ideas, such as this idea of homoiconicity, where the language itself is written as a data structure that you can represent in that language.. this idea of metaprogramming, where not only are you programming in the language to solve a problem, but you can program the language itself. you can change the structure of the language itself to make it more suitable for a particular application. and even if it was just for learning those concepts, you'd become a better programmer in other languages. nonetheless, it still remains a language... common lisp, in particular remains a language that's very, very good at solving modern real-world problems. i actually would draw an analogy to physics a little bit. like, good ideas, ideas that are fundamentally good are usually ones that stand the test of time. now, computer science and computer programming is not a very old art, so to speak. it's, you know, less than a century old. however, there are lots of theories in physics, for instance, that were sensible, they allowed you to make predictions. for example, the sun going around the earth. it seems reasonable. you see it. but there's a kernel of an idea later that the earth goes around the sun. and that is a physical theory that, one, turned out to be true, but also stands the test of time. there are good ideas in it that are fundamentally good. and so i think that just the fact that lisp started in the 1950s and still has something, still has some kernel of an idea that's good, i think makes it worth learning, even if it's not used day to day. (off) you do use it day to day, don't you?
(smith) yes. so, lisp, even still, going back to this kernel of an idea, is good at building a language that i want. i can't think of anything that's better than using a programming language that allows me to build the language that i need to express my problem. the stuff that i work on day to day is quantum computing, where there isn't a lot of literature on how to wrangle the problems that come up in quantum computing. quantum computing uses quantum mechanics, which is a very, very different mathematical language than just addition of numbers, for instance. it is a very strange world, where things have all different types of rules. so, modern programming languages don't support expressing these constructs in a very fluid way. often, i need to sort of build my own sort of language in order to express solutions to problems that i'm having. now, you can do this in a language like c++ or java. you can build your own parser, you can build your own compiler, you can build all of the things you need just to be able to write solutions to problems. but in lisp, it allows you to grow the language ever so slightly in a very easy way, so that in lisp directly i can express these new constructs. and it's very helpful for these types of new domains. we're actually extending the syntax of the language. so, one example that i like to bring up is, back in the days of programming assembly, if you wanted to do something like a "for" loop, you wrote down this structure where you'd have this explicit "jump" statement, and then you'd have a separate counter somewhere, and it's all just a bunch of lines of assembly. nowhere in the assembly code are you actually saying, like, "for i from 1 to 10", or something like that, but you know the concept is there. you know as the programmer what you mean by these instructions is a "for" loop. what lisp does is allow you to take that idea of a "for" loop and actually syntactically be able to write a "for" loop. so it's not just a library of functions. it's actually new syntax and new functionality in the language. (off) but it all does come down to assembly in the end, doesn't it?
(smith) yes, absolutely. yeah, it all gets compiled to assembly in the end. (off) so this is a way of organizing your thoughts as a programmer.
(smith) correct, yes. that's, i think, ultimately what it's optimizing for, allowing you the programmer to organize your thoughts. most of the time in programming is spent thinking, so that's the progress that i want to optimize in programming. not necessarily the efficiency of the program, although you can do that, and other things. it's being able to even get the solution to the problem out on paper or on the screen in the first place. (off) and would you say you're faster doing it this way? (off) there might be somebody out there going, "yeah, i could do that in haskell, i could do that in c." (smith) so, instead of taking my word for it, we did this little program where i work where we had college students, interns, come in and try the language, then try to use it for solving some of these quantum problems. and the first reaction is, like, "whoa, there are lots of parentheses." if you look at lisp code, there are lots of parentheses. and then it's... well, the documentation is sometimes a little bit shaky in certain places. but once they kind of got through that first bit of the learning curve, the feedback that i got is that they could think about their problems in a more fundamental, or more structural fashion, that the language itself wasn't getting in the way of solving their problems. it's that now they could express what they think in a more direct fashion, without so much of an impedance mismatch. fortunately, lisp was originally defined in, like, half a page of code. like, the entire language. and in that page of code, they had very few concepts that bring to light all of these things that i'm discussing. namely, the notion of s expressions, which is how the lisp language itself is built, how you write it. and following that, this notion of macros and metaprogramming, how we can extend the language. and i think these two things really bring to light how all this stuff works. the special thing about this is that we can interpret it in two ways. it can be looked at as code. it looks like we're doing 1+2*3. but it can also be looked at as data. remember that in lisp we write out a list using parentheses, here. we write out symbols just as their names here. so in lisp, actually have this explicit bridge...