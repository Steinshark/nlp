what orms have taught me just learn squeal i've come to the conclusion that for me orms are stop with the for me business everyone always just wants to make everything so palatable for everyone else to hear i've come to the conclusion that orms are more detrimental than a than benefit in short they can be used to nicely augment working with squeal in a program but they should not replace it some background for the last for the past 30 months i've been working with code that has the interface with a post glee and to some extent squeal light everyone loves that squeal light file testing tell me you don't love squealite file testing tell me you don't because you know it's fantastic you know it is oh what are you doing point it at a local file this little htmx app that i'm building this is just a local file it's just a local file right there that's all it is okay all i have to do jump in here cat out temp contacts contacts and good look at that a little square light file right there big fan big fan most of that has been with a squeal alchemy which i quite like and hibernate which i don't let's see i've worked with some existing code and data models as well as designing my own most the data is event based storage timelines with heavy emphasis on creating reports interesting there's like specific databases that are for timeline generation right and and timeline type stuff i wonder how well i mean i i do a lot of this as well surprisingly enough for the last six months i've been working on a bunch of stuff when it comes to netflix's new initiatives you can go try to find out what netflix's new initiatives are there's some little there's some little rumblings out there in the news and it always is a huge pain in the ass getting out data and doing it right so i feel for them much of this let's see has been written about the object relational and impotence impotence mismatch it's hard to appreciate it until you live it a new word in his well-known essay lays out many cogent reasons why orms turn into quagmires in my experience i had the deal directly with a fair number of them entity identity issues dual schema problems data retrieval mechanism concerns and partial object problem i want to talk briefly about my experience with these issues and add one of my own okay this is good all right partial objects attribute creep and foreign keys perhaps the most subversive issue i've had with orms is attribute creep or wide tables you know some of us like wide tables you know i think it's kind of like you know i'm just saying just something i've grown to appreciate that is tables that that just keep accruing attributes as much as i'd like to avoid it sometimes it becomes necessary although things like post greece histor can help for example a client may be providing you with lots of data that they want attach to reports based on various business logics furthermore you don't have much insight into this data you're just slapping it around this is this in end of itself isn't a terrible thing in a database it becomes a real pain point with an orm specifically the problem starts to show up in any query that uses the entity directly to create the query you may have a hibernate query like so on a project query foo class add restriction on x value this may be fine when foo has five attributes but becomes a data fire hose when it has hundreds this is an equivalent of using select star which usually is saying more than what is intended orms however encourage the use and often make writing precise projections as tedious as they are in squeal i have optimized such queries by adding the appropriate projection and reduce the run time from minutes to seconds all the time was spent translating the database row into java objects i think he means a column i assume when he says attribute it means column in this case i came here for some fun not ptsd well guess what everybody i remember when i thought because i did squeal for so long and then i was just like you know what i've learned about  right or not mongoose it's like a orn this was years ago and i used mongoose and i was like this is fun and then about like a week into it i'm like i hate all raps this is like 10 years ago or something crap like that dude i just i i lost i literally lost my which leads to another bad experience the pernicious use of foreign keys in orms i've used links between classes are represented in the data model as foreign keys which if not configured carefully result in a large number of joints when retrieving the object a recent count of one such table in my work resulted in over 600 attributes and 14 joins to access a single object using the preferred query methodology that is crazy what attribute creep and excessive use of foreign keys show me that in order to use orms effectively you still need to know squeal you do my contention with orms is that if you need to know squeal just use squeal since it prevents you to need to know how non-squille gets translated into squeal dude this is always i swear this this is fantastic i i don't understand a lot of the reasons why people use orms i have heard that prisma has an amazing ability to do migrations and if that's the case i could totally get why you'd use some sort of migration utility i'm on that team i'm not arguing that but just general use of of orms it's always like you still have to do select star from this table where are these things but instead of doing it in a language that you can simply google and find out about and read on its performance instead you do the same set of actions but you're doing it in some javascript library and some library we're just like get user with this id i mean you're already typing squeal just type the squeal right just type the squeal and use sub library that just simply sanitizes inputs and then you don't have to worry about it that's why i do like squeal builders i don't mind squeal builders right i think that those are okay where you just don't want to do a bunch of it you know what i mean you're not a big fan of it sometimes it's easier just to be like you know whatever i need this joined with that with this win this and you're just like i don't want to know all this squeal okay maybe we can i can i can kind of i can kind of buy squeal builders because at the end of the day it still turns into a string in which you can expect inspect and understand what you're doing whereas an orm kind of makes that process a bit more opaque you know what i mean if the alternative is a bunch of potential squeal injections the alternative is not that though that is like a false dichotomy and not real the alternative is you use a library that simply sanitizes your input like squeal ax in go squealax and go you use the question syntax or whatever and it sanitizes that input for you it just does the right thing or whatever it is right there's like the thing in which you use to prevent yourself from shooting yourself in the foot but you're still writing squeal at the end of the day right not using an orm does not equal squeal injection exactly yeah it's just like those two things aren't the same there is no alternative you can use an orm and i'm pretty sure you could figure out how to break it or do something naughty just like if you did if you just did raw dog and squeal i'm sure you could also do something naughty and just figuring it out all right let's see yesterday i saw when i saw how to write a joint and gorm i rage quit and moved all my stuff back to squeal x there you go it's a good move just use squeal x squeal x you will more than likely be happy in two months that you did and you will likely be not refactoring it right people seem to like drizzle i saw some drama developing with drizzle this morning i don't know if you guys saw that but i saw some tweets people looking pretty upset something about i don't know it doesn't it doesn't look good orms often generate n plus one queries absolutely there's some real things there data retrieval knowing how to write squeal becomes even more important when you attempt to actually write queries using an orm here's another thing i want to actually throw in here say you have like a portal at your job we have one for our big data i can go on to the big data portal and just portal i can just query any table i think without pii and i can do a bunch of stuff on it and kind of go through it right that means if i just know squeal i can go there and figure out the query i want to make to retrieve the data and then go and look at all the column definitions figure out which ones have been partitioned in hive and i can go do all that and then when i figure out the queries i need i can then just bring them directly into my application whereas if you don't have that and you're doing this orm there's no one-to-one translation there i then have to take this squeal query and rewrite it into a library right and if they get a major version update then i'm stuck on this version because they've changed things you know i don't know check one two three yeah let's see this is especially important when efficiency is a concern when it comes to data when it comes to squealing efficiency is always a concern 100 of the time just because this is like classic bottleneck 101 on your database this is classic how how to add latency and lose friends is i don't know how squeal works but here's my application i built from what i've seen unless you really unless if you have a really simple data model that is you never do joins you will be bending over backwards to figure out how to get an orm to generate squeal that runs efficiently yeah most of the time it's more obfuscated than squealth yep and if you dude it's this is so true especially reading about prisma and some of the things they're doing with joining and in rust met like in memory rust joining tables for you programmatically stuff like that great great talk and if you elect to keep the query simple you'll end up doing a lot of work in the code that could be done in the database faster windows functions are relatively advanced squeal that is painful to write with orms not writing them into the query likely means you will be transferring a lot of extra data from the database to your application which means all other concurrent requests are going to be affected by that in these cases i've elected to write queries using a templating system to describe the tables using the orm i get the convenience of an application level description of the table with direct use of squeal it's a lot less trouble than anything else i've used so far let's go i like this this article is great so far dual schema danger so i don't know this one what they're trying to say maybe i don't get it maybe i do this one seems to be one of the of those unavoidable redundancies if you try to get rid of it you only make more problems and add excessive complexity the problem is that you end up having a data definition in two places the database and your application if you keep your definition entirely in your application you end up having to write the squeal data definition language ddl with the orm code which is the same complication as writing advanced queries in the orm if you keep it in the database you'll probably want a representation of the application for convenience and to prevent too much string typing facts of life facts facts facts i much prefer to keep the data definition in the database and read it into the application it doesn't solve the problem but it makes it more manageable i found that reflection techniques to get data definitions are not worth it and i succumb to managing the redundancy of the data definitions in two places you can also have like a build process i've done this before because i was using a mongodb with absolutely no schema and so what i did is i actually had a build process where i would take yesterday's data or whenever i built it i built it like once a week i take that like i take like 15 000 sessions pipe them all in and then build a schema definition based off all the raw dogged json objects and then updated my schema definition committed it released it internally at netflix so i always had up-to-date definitions without having to worry about all the other crap that goes with it and so you can kind of have the best of both worlds if you put it into a build process and especially if you have squeal if you're using squeal not mong you will have a definition already there and you will be able to generate those definitions but the damn migration issue is a real kick in the teeth changing the model is no big deal in the application but a real pain in the database after all databases are persistent to whereas application data is not or i'm simply get in the way because they don't help manage data migrations at all i wonder if that's true about prisma everyone i've heard multiple people say prisma's data migration stuff is really nice i work on principle that the database's data definitions aren't things you should manipulate in the application instead manipulate the results of queries so that is the queries are your api to the database so instead of thinking about objects you think about functions which return types thus one is forced to ask should you use an orm for anything but convenience in making queries i just don't even think they make convenience of making queries a drizzle does it well okay it seems let's see it seems to be on it can i get a tldr of what he's working on i'm reading about stuff identities dealing with entity identities is one of those things that you have to keep in mind at all times when working with orms forcing you to write for two systems while only about only have the expressivity of one okay when you have foreign keys you refer to related identities with an identifier in your application identifier takes on various meanings but usually it's the memory location a pointer in a database it's the state of an object itself these two things don't really get along because you can really only use database identifiers in database okay okay okay okay okay i think i see what he's trying to say here he's not really stating like i feel like this is more just like a definitional thing i want to know what what is what is the problem leading to he was talking about how he had like 14 joins that were being made due to foreign keys what this result is having to manipulate the orem to get a database identifier by manually flushing the cache or doing a partial commit to get the actual database identifier i can't even call this a leaky abstraction because the work leak implies small amounts of content escaping relative to the source huh huh i don't think i strongly get that one i don't think i get it i made five microservices prod application without any orm for postgreat yeah you did basic you learned how to do basic squeal i'm not a programmer i produce electronic dance music i am i gay i don't know that's a question for you to answer i can't answer based on that statement yeah yeah what is the on about something that new new art alludes to is the need for developers to handle transactions transactions are dynamically scoped which is a powerful but mostly neglected concept in programming languages due to the confusion they cause if overuse yeah they're very nice they can be very nice i think he refers to keeping the app data in consistent state relative to the relation between tables yes he means that orms may have forced you to do an insert git id insert b that needs a's id etc oh okay yeah yeah yeah yeah yeah yeah yeah yeah yeah yeah yeah yeah yeah yeah yeah yeah i see yeah you have to do these you have to do these you have to do these serial operations this leads to a lot of boilerplate code with exception handlers and careful consideration of where transaction boundaries should occur it also makes you pass session objects around to any function method that might have to communicate with the database the concept of a transaction translate poorly to applications due to the reliance on context based on time as mentioned dynamic scoping is one of the way to use this in a program but it is at odds with lexical scoping okay interesting i agree with that the dominant paradigm thus you must take great care to know about when of a transaction when writing code that works with the database and can make a modularity tricky here's a useful function that will only work in certain contexts okay that's actually a really cool kind of concept to think about i guess never really thought about it is that you have like a time-based scoping versus like a lexical based scoping yeah i can see why that can be difficult no where do i see myself going at this point i'm starting to question the wisdom behind the outright rejection of stored procedures you know i did go harder for stored procedures for a while i did do this for a while i went hard on stored procedures and i can't say it was the worst experience i've had foreign in some sense it was nice there's some things that are very very nice about it granted this was about 12 years ago in my squeal of course and i really liked them i could see why they're they're they're they're they're they're bad in the sense that once you go too far with them once you start bringing in business logic i think you got some you got you got to be careful you got to be really careful like you got to really make sure that your application does what is right to hand off to the stored procedure and avoid goofing up a little too much you know i'm very skeptical of these i'd be careful i'd be careful it sounds heretical but it may work for my use case and hey the advent of devops the divide between the developer and the database administrator are basically non-existent i found myself thinking about the database as just another data type that has an api the queries the queries are return values of some type which are represented as some object in the program by moving away from thinking of it as objects in my application as some as something to be stored in the database the raison for orms i don't know how to say that word i feel like i know that word and i've said it before but now i can't remember how to say it and instead thinking of the database as a large and complex data type i found working with the database from an application to be much simpler and wondering why i didn't see it earlier fair i think that's a fair state stored procedures are powerful but too much but too much and your db will bottleneck and performance and not scale yeah claymore opening yell yeah yeah i worked at a company that did this too and it was too much that's what turned me off to stored procedures but i realized that there's some parts that are good there's some parts that are good i could see myself liking it and disliking at the same time i think it's a true trade-off i think very few times you can say in programming it's a true trade-off i feel like stored procedures could be it should listen it should be made clear that i'm not claiming that is how all applications should deal with databases all i'm saying is that it fits into my use case based on the data i'm working with regardless of whether i find that stored procedures aren't actually that evil or whether i keep using templated squeal i do know one thing i won't fall into the orms make it easy trap dude don't fall into that i am fully on this team orems mostly don't make things easy people keep telling me that drizzle orm is the the bee's knees i really would have to see this like i really am in such doubt about it they are an acceptable way to represent the data definition but a poor way to write queries in a bad way to store object state if you're using an rdbms bite the bullet and learn squeal facts just learn squeal do you guys like a drizzle my current company requires anything more specific than selects to be made in a store procedure that's crazy as well see like weird rules like that are like the death of software engineering i don't get what it is but something about that is just crazy to me here i want to ask this do you like what just happened there or rams yes orms good only drizzle only prisma squeal builders raw rod raw dog squeal i'm actually curious about this one i forgot keasly i know there's keasley as well but this guy argues pretty well for the business logic and the db okay interesting put it on put it on the prime reactor we may read it at some raw dog the hot dog yeah i'm just curious yes orms are good a lot of people like orms only drizzle only prisma okay so a lot of orammers okay i didn't realize this squeal builders we definitely got some squeal builders i don't think squeal builders are bad i think that they can be okay but again you're still learning an api just to learn you could just learn squeal instead you know what i mean it's like what's the benefit of going from this table where these values with these columns right i don't know if you're really getting anything out of it do you know what i mean raw dog raw dog and squeal yeah yeah raw dog and squeal i'm i right now i'm on the raw dog and squeal train okay so it does seem like i'm actually surprised about this that that many people like orms and then more specifically people like only drizzle slash only prisma i'm actually a little bit surprised about that orams on bad data are the same level as bad data on roswell yes i mean bad data is bad data we're we're pretending this isn't bad data right you can use cases where i'll reach but i'll try to avoid it yeah let's see drizzle is not an orm well what's drizzle or m then why do i not see the poll i don't know i built into my own orm in java okay i built some squeal builders orms are good for simple applications this is how i feel about almost everything in software engineering from every single framework you look at every single thing that shows you how to use it is always showing you in like a really simplified context and it always looks good right you know what i mean and then you use it in bigger things and you hate it foreign if you are concatenating strings dynamically to generate squeal it's time to use a squeal builder i could i can purchase this that's fine with me i'm on this team if you're doing if if you're doing that it's time to move on to the next level totally agreed with 600 columns let's say well with 600 columns it's bad data it doesn't matter if they're using an rm yes yes but no one's arguing that we're all on that team that's crazy but whatever they're doing whatever this person's doing he had a reason to do it and it may not be that easy right you always forget 600 columns we can all agree is bad in sql but we can also all agree that we've all worked in a production environment in which you accidentally get 600 columns okay bad things just happen okay bad things happen you don't mean it to happen but it just happens sometimes i don't have any thoughts on squilcy that it depends yeah see i still am not sure if it really would benefit from an orm i'm still not sure if it benefits from an orm like camping i i don't know if i agree with this because if it's just transactional stuff then why aren't you just writing select star why are you running so much stuff when you could just be like select column a b c from that i i mean that the most sincere way right and then you obviously just have something in which you grab out a few items like what's the point you know more than four tables create a separate michael service problem solved isn't is it type safety you still take the squeal and turn it into a type right you still you don't just like like hand around queries right no one hands around a hanging squeal x query for you to scan in the rows you want no you like you create like even in this thing i just create the contacts one at a time right i still deal with objects but there's no need to bring in an entire universe just to create a contact i i always put it close to where i want it where i generate the objects from it's more expensive sometimes you need to update just one column exactly you don't want to select star what you don't want to i am on that team but how do you hydrate my app objects you get them from the database and put them into the objects you do the same thing that the squeal is doing i'll people off okay so here's my here's my real take on this is that i find that it's there's this idea that using the thing is hard therefore use something to do all the work for you but at the end of the day you still are almost squealing right you're still doing all the select wear from adding all these things in you're doing a bunch you just know less of what's happening are you actually getting anything out of it is it actually buying you anything like anything at all yeah i do agree this row scan it sucks it it sucks in in squeal x right i i get that i'm on your team it's not like amazing and so you just kind of have to you have to ask yourself why do you abstract and when should you abstract and i'm not saying that's why i'm saying like i generally don't reach for orms because i've had too many bad problems with orms right i think i think orms is what is is more of a newbie tool it helps you with auto completion all that you can get auto completion without an orm right you can get auto completion just fine oh right move just rated hey thanks raimu all right hey the name is i don't use an orm but i'm sure that there's a case where using an orm is fine i just don't i just personally don't like it school builders are also pretty nice oh jen just run dog squeal already