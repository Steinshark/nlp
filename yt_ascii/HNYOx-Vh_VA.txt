hey everyone, i'm james murphy. and you're watching mcoding where we try to take credit 
 for the achievements of the compiler. today we're talking about what i consider 
 to be the most important c++ compiler optimization. it helps your code go so fast 
 it would make sonic the hedgehog jealous. this optimization is so important 
that all major compilers do it, even in o0 mode. yes, common misconception, 
 o0 doesn't turn off all optimizations. just most of them. for example, just returning 
 the sum of two literal constants, the compiler will still just compute 
 the answer even at optimization level zero. this is called constant folding and it's also 
 important but not the most important, in my opinion.   my vote goes to return value optimization. otherwise known as rvo and/or copy elision. here we have a simple 
 struct s that just contains an int, but it also prints to standard out 
 whenever you construct it or copy it. in main, let's just construct an 's' 
 and then print out the x data member. there we go, construct s of 21, 
 then the answer is 21. now, what if instead of directly 
 constructing s, we got it returned from a function? functions are incredibly important. they're the building blocks of abstractions that allowed the early greats of 
 programming languages to ascend above the spaghetti code and write code that other 
 people can actually understand. surely, pushing the construction of s 
 inside a function won't slow down my code. otherwise, there would always be that 
 incentive to devolve into our primal spaghetti nature.   and indeed, no change, 
 even at optimization level zero. but in fact, that's only because return 
 value optimization is still turned on even at o0.   so let's manually turn it off. we do that with this '-fno-elide-constructors' flag. and now we see copy, copy. not just one, but two copies of our s. and if we had a more complex stack
 of operations to put this object together, say 'make_double_value' calls 'make_value'. now we see copy, copy, copy, copy. that's four copies, two new copies every time we try to return our struct.   get rid of that flag. and again, they disappear. now, this is just a simple struct. copying it is just copying an int. but still, four copies to return it up two levels. and imagine if this is how it was for all of your code. strings and any other objects 
 containing real data would be basically unusable, forcing you to pass pointers or 
 references instead for anything but trivial data. that would be annoying because 
 pointers are a bit trickier than just values. and also referencing everything through 
 pointers means paying for dereferencing all over the place. not to mention the 
 slowdown from all the memory allocations needed to get the memory underlying all those pointers. but luckily, that's not the c++ world we live in. in our world, no copies. i hope that convinces you of what this 
 copy elision can do for us in terms of performance. but now, what exactly is it doing? where are all those 
 copies coming from in the first place? and why are we allowed to get rid of them? okay, we've got four copies 
 here. where are they all coming from? we call this function. that calls this function. that ultimately constructs the s. the memory for this 
 temporary s is allocated on the stack in the space made 
 available for the 'make_value' function. at the call site, we need space 
 for another s, the return value of that call. the return value is another temporary. its space is allocated on the stack made 
 available for the 'make_double_value' function. so basically, we need 
 to copy it from here to here. but we don't want to just throw away the value. we want to store it in this variable s. so we need to make another 
 copy from this temporary into this little s.   when we return our little s, we make 
 another copy into the return value at this call site. which we then copy again into this little s. return value optimization and copy 
 elision allow us to get rid of all of those copies. but at this point, 
 something might feel a little bit off. my constructors had print statements in them. so copy elision isn't just 
 making more efficient assembly code. it's changing what my program does at runtime. if i made 'hello world', the 
 compiler can't just remove my print statements. and say, "oh yeah, i made your 
 code faster by just not printing hello world." the print statement was part of the program. you can't just remove it. but clearly, copy elision is 
 removing my print statements. and that's because return value optimization and 
 copy elision are blessed by the language. these optimizations are so 
 important that in the standard that defines c++, it specifically states that "the compiler is allowed and sometimes even required" "to omit calling a copy constructor" "when returning from a function 
 or when copying from a temporary." "even if the copy constructor has side effects" "like printing, setting a global variable, and so on." this is why you should not use your copy constructor to do anything besides copy. because it might not happen. and it's why you should use 
 the copy constructor to make copies. because if you write your own copy function, it can never be as efficient as a copy constructor. because the compiler may not be 
 allowed to get rid of calls to your copy function. so in short, be careful. but copy elision is awesome. it lets us just return things by value and still go fast. so in what situations is the 
 compiler actually allowed to do this? well, this is c++ i mean, if you want the 
 real correct answer, it's complicated. you need to know all about value categories, 
 prvalues, xvalues, glvalues, which i'm not going to cover here. but i can give you a rule of  
thumb that's correct in a lot of situations. basically, the compiler is allowed 
 to do copy elision in a return statement. or when initializing from a temporary. if the types match, so 
 no conversion is required. and it can uniquely determine 
 where the memory should end up. for example, where should 
 the memory for this s of x live? well, it's just immediately constructed and returned. so instead of living in the stack 
 space for this function, why don't we just put it 
 in the stack space for its caller? this is the situation that's 
 technically referred to as 'return value optimization'. and where should the memory for 
 the temporary of this call go? well, it's being immediately used 
 to construct another s. so let's just put it in that space. and where should the space for this s live? well, we always return that s. so why don't we just make 
 it live at wherever its caller is? and where should its caller live? well, once again, that temporary 
 value is just being used to initialize another s. so let's just put it in the storage for that s. that s is never returned. so 
 its space just lives in the space for main. so when these are created, all five of these 
 are directly created in the space for this s in main. on the other hand, take a look at 
 this example where we can't get rid of the copy.   here we make two s's. and then depending on whether x is 
 positive or negative, return one or the other of them. could we just put the memory for s1 
 at the spot of where the return value goes? no, we can't do that because we might return s2.   and just the same, we can't put 
 s2 there because we might return s1. so the memory for this s1 and s2 has to live here. it can't be pushed up to the caller. that means whichever one gets 
 returned, it has to be copied into the caller's memory. on the other hand, here's an unexpected 
 situation where it can actually go the other direction. this time we put the print 
 inside a function and pass a temporary. where should the memory 
 for this temporary in the caller go? just construct it directly into 
 the space for this function parameter. no copy. copy elision can also happen when you 
 throw or catch an exception and inside coroutines. but i'm not going to talk about those. as of c++17, in some instances like this basic 
 case of return value optimization, eliding the copy is not even a choice anymore. it's not an optimization 
 the compiler is required to do it. in these required cases, this "not copy copy" 
 can happen even when the copy constructor is deleted. that's right. you can return something that's not 
 even copyable like a unique pointer or a mutex by value. and this is allowed because in 
 c++17, technically the copy was not elided. technically, due to this guaranteed return 
 value optimization, it was never there in the first place. as you can see, in c++11, 
 when i try to return this s of x by value, since the copy constructor is deleted, it's not allowed. but in c++17, due to 
 guaranteed copy elision, there was no copy. the s that's being returned is 
 directly constructed wherever it needs to go. you can even write what looks like a 
 bunch of manual copies, and it doesn't matter. all of those copies are required to 
 never exist in the first place because of this. because of this, you would have 
 what i might call a language lawyer say that return value optimization in 17 and 
 onwards is technically not copy elision. because the standard defines 
 that there was no copy in the first place. but colloquially speaking, 
 no one's going to be confused if you say that return value optimization is copy elision. everybody knows what you mean. now until now, i haven't 
 said anything about move operations. if you know what those are, and yes, 
 copy elision works in a similar way for moves. the compiler is allowed and 
 sometimes required to get rid of moves. but honestly, me just listing out more cases 
 at this point probably isn't going to do a lot of good. so what i recommend is to 
 just open up compiler explorer. and try a bunch of cases for yourself. hopefully, now you agree that return 
 value optimization and copy elision are awesome. without them, c++ would be much, much slower. thank you for sticking 
 around to the end. that's all i've got. if you especially enjoy my content, please do consider becoming a patron or donor. and don't forget to subscribe. and of course, don't forget to 
 slap that like button an odd number of times. see you next time.