one of our most popular techniques for building really large software systems has always been the actor model there's no shortage of people in the erlang world or the scala world who tell you how flexible and reliable it can be and i think one of the things that really appeals about the actor model is that the core ideas are pretty easy to understand and the core ideas stay the same as the system grows right there's really only two pieces you have actors independent state machines focused on doing one thing really well and then you have this communication system between them that does have some subtleties but it doesn't seem to care whether you're talking on one cpu or across multiple cores or across a network or across data centers or across an unreliable network that covers different countries the system grows but the pieces stay the same so this hope that the design will still fit in our completely unscalable brains bit like chess right the rules are simple but it can grow to emergent complexity and that brings me to the two questions i've always had about acta systems the first is emerging complexity how do you ensure that as your system grows the complexity of those actors interacting with each other is the kind of complexity you were hoping for and then second if you're starting with a large system in mind how do you break that down into individual actors are there design patterns are there good ways of thinking about it is there someone who can navigate me through the actor model well joining me this week is h m i met him recently at a conference where he was talking about designing actor-based systems and we got chatting about that and we got chatting about the parallels between actor-based systems which he knows and event based systems which i've always been interested in and yeah i immediately invited him in to come and answer my questions and hopefully some of yours so let's get asking i'm your host chris jenkins this is developer voices and today's voice is humor [music] key i'm joined today by h m here how are you great great thanks for having me chris it's a pleasure you you're you spent a lot of time in an adjacent world to mine it seems cuz mine my world for the past few years has been heavily event streaming yours is actors and the actor model and they are two parallel tracks that almost sometimes meet but aren't quite there it yeah you're right and and i'm kind of surprised that they don't overlap more because you i think as we get into some of the things we want to talk about there is event streaming and the actor model i think really go together u because there's a lot more to the actor model than i think what most people might be familiar with which is typically not a lot well we're gonna get into that but i mean you raised the point we have to start at i think which is give me your person personal definition of the actor model i always like hearing it from the experts because you'll have your own spin on it yeah and there's a lot of spin the one thing i always like to say is if you look at the wikipedia definition of the actor model you just looked that up they i i whoever crafted that opening paragraph or two did an outstanding job summing up the you know what an actor is but fundamentally an actor is very simple mechanically the the idea is that an actor is a it's a unit of software it and it really represents a unit of state of something you know and it so if you're an object-oriented programmer or any kind of you developer that's familiar with objects state is basically an object you know it's a it's an object that has attributes and things like that that's a unit of state yeah so you think of an actor is this representing this this unit of state an instance of an actor is representing this unit of state but where things really get different though is the only way that you can communicate with an actor is to send it asynchronous messages so basically sending it commands so you don't like with an object you have methods on an objects and you invoke a method on an object and that method performs some kind of say state tr state changing transformation to the state of the object that's not the cas with actors that actors are indirectly communicated with you you know it's like and i always like to use the analogy that you know humans texting each other in effect we're we're sending each other asynchronous messages we're having a conversation but i i type a message and send it to you maybe you get it maybe you don't but and maybe you get it but you don't respond immediately or or or maybe you do but it's it's kind of like it's a almost like a fire and forget i sent you a message i can keep going on and doing what i'm doing while i'm waiting for say a message to come back from you so this is how actors communicate with these these messages so that you just there are certain messages that you can send to an actor and then if you look in the definition the actor when it receives a message has has the choice choice of how to react to that message and how it reacts it has a behavior and that behavior is often dictated by the state so as an example say you have an actor that represents a shopping cart and you send it a com a command a message say hey add this item to the shopping cart well the behavior when the shopping cart is not checked out is okay i'll add the item to the shopping card if if everything looks good with the you know the quantity is good and the product is known and all you know everything looks good with the request the actor will change a state add the item to the shopping cart and maybe send back a an acknowledgement or send back a message but this is not required but it sends back a message to the sender saying yeah i did what you asking to do or it sends a command to the to an actor after to add an item after the the cart has been checked out so in that case the behavior of the actor has changed it's not going to allow the the shopping cart to be changed anymore because it's been checked out so this behavioral thing that's is part of it as well it's like a tiny little state machine right exactly it is it's a tiny little state machine then tiny is you know small focused is is kind of one of the the the characteristics of an actor another part of the definition of an actor and reacting to a incoming message could be that it also can send messages to other actors in response to that message so it's it's like say you have an act an actor that's representing the state of a device like a say a a ter temperature sensor on a on a machine right yeah and the the the sensor is constantly sending messages you know they say every second or every minute or whatever frequency what his temperature is and when the temperature is okay the actor gets that message and goes okay everything's fine i don't need to respond but then say it gets a message in and say hey it's hot and the the actor gets that message and goes oh this temperature is over the threshold of where it should be i need to alert somebody so it's going to then in that case send a message to maybe to another actor to say hey we got a we got a motor or a sensor that's registering is hot we need you know we need to react to that yeah so and this is a form of delegation as well is like the act the actor say is receiving the the temperature telemetry messages is only there to respond to deviations out of the normal range other actors are responsible for say reacting to hey we got to you know we got to censor this out of range so you're you're kind of delegating and and instead of having like one big piece of code that does everything in say one object or a set of objects kind of a more monolithic type of way of doing things yeah yeah with actor models you tend to decompose problems into smaller units of functionality that collaborate with each other in a very unique way of this asynchronous messaging and things really get powerful and amazing but different this is i think one of the inhibitors for people adopting the react the model is this it's a different approach to computing that's the thing that really interests me right because you you explain one actor and it all seems very simple but you play that out into a network of actors into a large application and it seems like the game has changed the way you do programming the way you build systems the way you think about architecting and breaking down a s single problem and i i've always wondered i mean are there particular sweet let's start there are there particular sweet spots for this approach you've done a lot of consulting and building have you seen companies where it works really well really badly you know i i don't i think it's almost universal okay and i'm getting more bold with this i've been dealing with the actor model since my first introduction to it around 2013 my own personal introduction to it i i came i stumbled across it when i was taking a corser class on scala and then in that class they they introduced aa which is the actor model implemented into jvm and my head kind of exploded because at the time i was looking for something and and the more i looked into it like wow this is really interesting fast forward to now and if you look at what's really interesting that that's happening today is ai right right what's ai based on neuron networks what are those little neurons and neuron networks they're mechanically very similar to what we just talked about with an actor neur get signals in and they theyit signals out the biological neuron networks are this the same principle that you know the way our brains work the way every neural network from insects to worms and insects there there's this study of of a worm where they've mapped the entire neuron network it has 302 neurons in it so they can they know exactly all the connections to all the neurons in this worm and there's massive amounts of study you know study that's gone into this the genetics and everything but the thing that intrigues me is that the neuron network but any case what's kicking our butt today you know the the massive computing models in our heads that are based on neuron networks we you know we came on the scene and we took over the world right yeah now ai is coming on the scene and it's taking over the world you know what's the fundamental unit of computing in that it's fundamentally what we just talked about this ability to do simple things in cascading sequences of of reaction to signals yeah and that's what intrigues me in that case let me ask you this question because the thing with neural networks is each individual neuron is very simple mhm but the emergent complexity is kind of a black box you don't debug a large language model you just not really you treat it as a magic black box i've always wondered if there's a risk in large actor-based installations that so much of the intelligence is in the graph that it becomes very difficult to understand that's it's an excellent question and i i think the answer is a good one is is that it doesn't have to be because the work that i've been doing recently where like in the last year in particular where the programming model that i've been using to do this kind of actor-based programming has become much simpler and much more focused on the fundamentals okay and what was interesting for me as a developer was that once a lot of the complexity that was surrounded this kind of beautiful model boiled away and i could focus on say designing systems using this that you what's surprising it's like the worm that has only 302 neurons it's it moves it it survives it it reproduces it avoids it learns it avoids you know danger and it it searches and and finds you know sources of of food those types of things all this behavior is in just 302 physical neurons and so what i found is like you like i one of and when i do my talks and a demo that i've done and other demos that i'm working on i have a like a demo with 10 different types of of these actors basically that m task yeah and it's just processing orders right and with these 10 different units of computing that each one is relatively simple this system is taking in orders it's allocating stock to the orders and it's not just decrementing counters it's actually tracking physical units of stock you know it's exact it knows exactly where the stock came from you know say in inventory you know by the boxes or you know by the units that are being shipped to us say a customer and what orders they were allocated to so it's a very detailed level of tracking it also has the ability to sense when stock is getting low and trigger ordering more stock and when that stock comes back when new stock comes into the system the new stock comes in and hunts down say orders that couldn't be fulfilled because they you know there was insufficient stock and they go into back order state and then they hunt them down and give them stock and so the orders are ready to go so there kind of a emergent behavior came out of 10 10 simple types of neuras that i could easily grock as a designer of this system once i wrap my head around this different way of thinking about decomposing complex problems into these smaller units of computing okay so are you saying it needn't necessarily become a black box because you can get quite complex emergent behavior from a small from a actually small colle ction of parts yeah that's what's really interesting then in that case you need to tell me as a as a novice actor model designer what the right way to slice a system up into actors is because i think mine are more complex than that it there's yeah okay so what was really interesting and and and i had to i i use this term there's this quote that i use in almost all my talks at the end of my talk but it's i want to use it now it's from a guy called alvin toffler and he said the the litter of the 21st century would not will not be those who couldnot read and write but those who who cannot learn unlearn and relearn ah and i really love that because what i was going through when i came across that quote was i was having to unlearn decades of training and experience in the way i have been traditionally developing systems you know implementing and designing and implementing systems into this new way of how do i solve a problem with the constraints of the the programming model that i have with these you know relatively simple units of computation and one of the surprising things that came out of it was that in a a business system the the messaging that occurs say between one actor and another actor has to be reliable and that's a solvable problem but when it when you get that reliability it comes with a cost and what i mean by that is that it's at least once message delivery so what that means is that the consumer of the message has to be able to handle duplicate messages and if you can't handle it you could get you interrupting your state because you'll have to be because you can't guarantee that when you send the message will be received you have to be able to send it more than once right yeah right so the consumer you it's like when actors are messaging each other one is a producer of a message and the other is a consumer of the message so in between you put some kind of reliable messaging which is like i say that's that's an e relatively easy problem to solve but it means that the consumer may in some cases get the the same message twice so when i des design and implement say one of these actors and i write a unit unit test for it one of the tests that i always write is every command you know the commands are known that are going to come in is you know you def you define exactly what commands that that give an actor can consume when you write the test for it often what i not often but almost all the time i'll write a test where i send the message once make sure that the message was processed correctly by examining the the result of the the message you know the change in state the events that that thing emitted and those types of things but then i said the message again and it's supposed to be item potent meaning that the state should not have changed the the data you know the the the the data should not be corrupted and the consumer should react correctly that poses a very interesting challenge to the design and i'll give you one quick example in a when you the stock allocation typically the way that's implemented you're just decrementing an inventory counter yeah and that's notoriously difficult to do in an item potent way because you have say a product in your inventory and that product has a stock on hand count and it's getting requests to you know decrement that count give me three give me five give me one you know each order coming in right so the consumer or something has to dup duplicate messages when they come in that can be extremely difficult so the you know does the consumer have to you know fundamentally the consumer has to remember every single thing that asks you know like have an auto trail of everything single thing that's asked for stock you know to to give me give me three give me two navely i'm going to stick a uu id on every stock request i send but then the stock manager has to have a complete history of every uu id it's ever seen right but now you've got two things because you've got the stock which is a thing it's an actor with some state and maybe an inventory count in its state but those uu ids those that could be a you know is it going to be an internal list inside of the state of that actor probably not because the list is unbounded it can get huge it could be years long when when you get rid of an entry in your d dup list all this kind of complexity comes in yeah so you run into these kinds of item potent problems and in a way it forces you to rethink how should you solve that problem and with again within the constraints of you you don't want an actor that has unbounded memory because you know the state of the actor has to fit in memory you it has to fit in an object and if it's millions and millions of previous order you know stock requesters are in your list that list just keeps growing and growing and eventually you you you can't fit that anymore so it's like okay that's designs out now what do i do right yeah so and this is what was to me what was really interesting and this is really controversial when i talk to people within my company as well as externally the the solution that seemed to just emerge was what i call reduction tree okay and a reduction tree is a tree of actors where the leaves of the actors say have units you know bits of stock in them it could be a single unit of stock or it could be a bundle of stock but it's just a finite amount of stock and that's the leaves of the tree the branches of the tree which are other actors and they have the each of their own state know how much stock each of their sub branches or the leaves that are attached to it have okay and it's a recursive data structure so the trunk has the total count of the available stock for a given product the trunk of the tree the leaves have the detailed information so when you're consuming stock the the the way the process works is you're consuming a part of a leaf or an entire leaf and that leaf can remember who consumed the stock so it's a finite amount of memory you know who who consume my stock it has its own small auto trail in it okay and so you've solved the item potency problem but it comes with the overhead of this tree you know that instead of it like a single entity but then it comes with a benefit that in the case of a single counter that's being decremented that could be a hot spot lots of requests are coming in you know say say you're selling a very popular product and it's there's a run on it you know you're getting lots of orders on it they're all queuing up trying to get to that counter you can only you know that's a critical path yeah only one request at a time can decrement the counter so everybody has to get in line to decrement the counter when you have a tree you you've provided a a more concurrent solution you more requesters can come in because they're not all coming into the same leaf on the tree they're coming into differ and tree to consume available stock so you saying that if if i'm an actor and i've got three available umbrellas and i get a request for one umbrella i will now fork two children one of which has one allocated umbrella and one has two free umbrellas you could do it at that level or you could say say you have a a 100 umbrellas right and you create a small tree where some of the leaves have like five umbrellas each so now you've got say what 20 leaves on the tree yeah so now somebody comes in i want an umbrella they go to one of those leaves and say give me one so that leaf remembers oh i gave an umbrella to you and another leaf remembers i gave an umbrella to chris right so if chris comes back again and say hey give me an umbrella i give you an umbrella you know right yeah so so you still got that i maintain a list of you ide but it's very strictly bounded right right and if i as the ordering service say hey i need three umbrellas i talk to the top level parent but that's sharded by product id are we saying yeah yeah okay okay i can see how that works so what's really interesting is this concept of a reduction tree came out it's just out of desperation you know i was think how do i solve this problem this potency problem you the counter thing won't work and i was trying different you just this was just a thought exercise yeah on my part because this was new to me and it was i maybe i do this and i' go and i run into something go no no no that doesn't work you know scratch that design do this one no no no no this doesn't work you know that and the item potency thing kept beating me up until it kind of forced me into this this more of a of this reduction tree concept then all of a sudden as i was i got that wrapped into my little brain how to make this work yeah this was a solution that popped up in other s other situations so in that demo i was telling you about that that i used to talk about these things of the 10 uh actors four of them use a reduction the reduction tree pattern i call it for okay yeah and for different things and as another in another design which is not it's stock related but it's uh payments so what's happen this is a design where there's there's a a large volume of of consumer transactions are coming into a system and those transactions are being processed by a processing you know entity and the the systems supposed to delic you take that those monies and do merchant payments is called so everybody gets a little cut of our you know our starbucks purchase right you know you know the the starbucks gets big cut the credit card processor gets one the company processing the transaction gets one maybe somebody else gets you know some money so the this the money coming in from that transaction flows to different merchants yeah basically and so in effect what's happening is the transactions are doing depositing funds in the systems and these merchants are doing withdrawals so it's similar patternislamic yeah yeah are there any other big patterns like that yeah there's there's that's the biggest one the another one is the i call it one to many so it's one event and but it ends up sending messages to multiple other actors yeah so as an example you have an order that comes in and that order has a list of order items so so we're classically trained to process the order we write out code to process the order you know we process all the items it's all like one microservice or monolith or whatever you know type of thing but it's like you know here's here's the order processing flow could use a lot of different objects and whatever but it's kind of a monolithic flow in this case you're breaking down that process so there's a finite amount of processing that's directly related to the order but there's also a f fin an amount of processing that's directly related to the order items each one individually so here then what it a pro an approach that you you can use is that there's an actor that that has the functionality for handling an order but just the order it delegates the responsibility for handling like getting stock for an order item to each order item so if an order comes in with say three order items that actor creates three child actors one for each order item okay right yeah do you go ahead so do you find that you're in that scenario and maybe you've got to send a message off to several different services let's say 10 the message has to fan out to 10 places you get halfway through you sent five of the messages and the other five and then something goes wrong and you miss the other five when you come back would you try and reconstruct from that point or would you just say it's all em potent so just refan out the whole 10 you're that's a excellent question and this is where this is where we haven't talked about it yet but this is where event driven comes in and reliability so the idea is that you have an actor that's omitting you know commands are coming in but instead of thinking of it as emitting messages it just emits events right so for example with the order a command a message comes in that's but think of it as a command create an order and that message contains you know the information about the order including the list of the order items you know like you know product one quantity of two product two quantity of three and so on so that that order actor gets that message and then it emits an events that says order created and that order created contains that list of order items are in the order well something picks up that event and uses that to communicate messages to other actors so it's it's a bit indirect instead of the more imperative flow of you know one actor gets this command and then then it sends messages to other actors and say it's in the middle just like you're saying it's it's trying to send 10 messages but it's three in and it and it fails so how do you recover from that so to mitigate that and to to harden it the you simplify it as well the the actor simply emits an event that event gets persisted into a database right right so we are this is going away from the what i seems like going away from what i think of the pure actor model it is it is to to a certain degree in the messaging piece because you're you it's dealing with the the the realities of the harsh realities of running in a distributed environment running you know in a an environment that can turn off stop at any moment right you have to deal with that so you still have the heart of an actor you right you still has represent state it's still messaging but in this case what it's messaging to is it's m messaging to a persistent slayer please save my event because until that event is saved the you know the actual change the it didn't happen until it's permanently recorded you know it's like you know i mean event journals were invented thousands of years ago when as soon as we started playing with money right yeah yeah and and the avent j was there it it almost it just fell out intuitively pretty much in our human brains because we had to account for every single you know change to a pile of money if money's being added who added it if money's being taken away who took it you know so that event journal is is that we've been doing like i said we've been i don't know how many thousand years we've been doing it but as soon as we started trading shells and whatever other things we found valuable you know to kind of kind of reached its perfect model i think in the renaissance when suddenly events with money weren't just happening here but they were shipping around the world too right you needed to keep track of what was happening to your accounts across the ocean right with the inherent risks and delays and latencies and all those asynchronous messaging of  exactly right so so what's happening is that the event is stored and then something picks up that event and that's the thing that's used to communicate so it's in the middle of it says yeah i got an order with 10 items i need to send 10 messages off to other actors it's in the middle of that and it blows up so now when the system recovers it that broadcasting of messaging that process recovers it comes back up and it goes all right i'm going to pick up where i left off this is basically exactly how kafka works for example right when when it's messaging so it picks up where left off and then goes okay i need i got this order i need to send 10 messages so this is where the item potency kicks in right right yeah three or five of them already got the message they're going to get that duplicate message so they need to behave properly when they see that duplicate message the other five didn't see it so that you know it's new it's a new message to them but it'll keep doing that until that process of you know reading that event from an event journal broadcasting off to say 10 other actors is all 10 of it successfully acknowledged then it goes okay this event has been process i'll go to the next event and and process that one yeah okay so let's briefly look at the implementation detail of that because i think when people think of actors they probably either think of erlang or aa right and you're in the aa world are you saying that this messaging persistence is something that i have to write as an application developer or are you saying that these days we should be expecting our actor frameworks to include persistent messaging it's should be you should expect it to be included i mean you can invent your own of course but it's a lot of work right it's not for the fans of heart it's a and there's there's a lot more to make that that work a lot more to it but conceptually this is the model that's emerging that is that we're you know my company and others are are i think are so excited about you know i call it it it's fully event driven and but it's also it's not just this is not thinking like your classic microservice type of thing because a microservice to me at this scale that we've been talking about for the last few minutes is too big it's too unbounded it you know they're like basically microservices are chunks of monolist in a way yeah right small and and they're built typically as using same model thing programming approaches this is a fundamentally different programming approach in that you're driven to small units of computation you know these the you so the act the heart of the actor is still there these small units of computation like an order is an object an order item is another object the units of stock are other objects you know and and and these or other object you know so you have all these fine grain things collaborating together in these event streams basically of reliable event streams once you have that foundation it opens up this new world which kind of circles back to your question bit ago about where does this fit and i mean you could think of me as i might be a hammer and everything's you know a nail so and my hammer is you know the event driven actor thing but i haven't seen a problem that couldn't be solved in this way which and the reason why i feel more confident about that statement is that when we look at the computing models that for thousands and millions of years you know the the the neuron network which we now see is kicking our butt with ai yeah it's that fundamental comp computing model that is so powerful with and it's different than the classic computing model that we've been doing since we've invented computers and i i really think that the the way we have been programming was dictated be by the hardware that we've been using and now we're getting to the point where the hardware is powerful enough that we can visualize you kind of have this virtual u environment even though the hardware is still you know we kind of stuffing this virtual model into the the weird hardware that we have to use but it's that this fundamental computing model that seems to be so powerful that that and it blows my mind like things like you you you do something with a few of these different types of entities you put them together and wire them together and you start to get a little bits of emergent behavior and it's like you my head explodes when i see some of this stuff so are you going to say then that because i mean every every approach has projects that go wrong you're going to say then that if a project that uses actors doesn't work it's probably because the design the design for an actor-based system is hard not that actors wouldn't work in that domain it's yes but it's i wouldn't say it's the reaction is that it's hard but i think it's just different and the problem has been that we're not trained on this you know we go through we quickly go into whatever you know approaches for for computing that we've been introduced to it you know when we start our careers and we basically take that trajectory and go with it forever and that trajectory really hasn't changed fundamentally forever you know we almost never get trained at work to do it because right they they're so wedded to the one approach that takes a lot for them to say let's let's train everybody to think a different way right there's a tremendous amount of dogma in involved in in the way we compute which prevents us from and puts a roadblocks basically into looking at alternatives for computing which is yeah i mean it's it's a cold hearted reality right the economics of the whole thing because it it is different you have like i said i had to that's why i really like learn unlearn and relearn but i i think that what is starting to happen that that could happen is that we'll get more and more literature material information more of us talking about these types of things that it'll become maybe more common i don't know it's hard because there's so much momentum in the traditional ways we've been building systems that it's hard to overcome yeah and i've been dealing with this for the last eight years and you know in my role at light bin we have a fundamentally different way of doing of computing that u when pe like like my reaction when i i got it it's like wow okay this is really cool i'm gonna fight through to learn it because i i i see what what's cool about it so i'm gonna i'm going to really put in the the work to get on to the other side yeah yeah that reminds me my journey with functional programming yeah like i thought this is cool i'm going to learn it but could i think of how to could i think of how to solve a problem without an object without a stateful object no i couldn't for a long time and i eventually beat my head through it right so that's something i want to circle back into is like how do you think about solving problems in this way when it's unfamiliar and coming from a cfa world the starting point would be well think about your messages think about your events is that also true in the actor world is it useful to start by thinking about the messaging between sis between actors or do you start by thinking actor first messaging later it's a bit of both but it i think it that is a good way to start thinking about it because it's the interactions between different parts of the system and you know so it's like event storming with domain driven design right you know that was kind of an aha that came about i think a bit after domain driven design came out i think event storming appeared a bit later as a result of it and it turned out to be a very powerful tool thinking of the events in the system first and then seeing well what what are the objects or what are the things that are on each end of the event flow you know who created the event and who's consuming those events so that that is a is a good way to think about it and then then the next stage is the you can start with say the course grain flow like you know you have a flow between consuming funds and producing and depositing funds or or consuming stock and and you know building up inventory those types of things yeah but then you start decomposing say that cor grain flow into the more fine grain flows that that are actually needed to to do the computing that needs to be done and so yeah i think that is the approach but then sprinkle in that item potency piece and that really kind of drives you i think a lot into a more fine grain solution you know because it's like a naive solution is yeah oh yeah i'm just going to send a message to that counter that inventory encounter and and get it right everything's good and you go in production and all of a sudden somebody goes hey that invent inventory counter is way off what's wrong you know i don't know everything's seems you know look at my code everything's fine you say well no you know what happened was you you had duplicate messages that were consuming too much and now you look at it then when you finally realize oh crap we got a big problem here fundamental design flaw you know that's kind of the naive approach because you didn't consider the atom potency piece and when you face that head on that's the thing that seems to really drive it this is what's driven me into more realistic designs and it usually involves decomposing something that i was a little too big and too heavy into something that was smaller and more lightweight and and delegates you know work out from say like i say delegating from an order to order items to to to units of stock that are needed for the order that's you know that kind of an approach yeah some i mean sometimes in computing you get those problems that force you to rethink your design and you end up with a more elegant design and sometimes you get problems where you're just working around the fact that there's a mismatch between what you're trying to achieve and the tools you're using mh and i almost wonder for for devil's advocate sake how confident are you that the system you end up with once you've dealt with a problem like item potency is better than the one you would have started with that's that's a really good question because one of the things the p big push backs is that you know each step takes time each step like persisting an event it's going to a database that's one of the slowest you can do in computing right is right to a database yeah and so like when i you like when i started doing these designs and i started showing people internally in my company as well as externally one of the horrors hor oh my god you're doing all these events it's like yeah make it faster you know events are mechanically very simple it's way different than a database trans transaction you're just depending a you know you're just doing an insert you never do updates you never do deletes you just you know you're just inserting so it's it should be fast and i and the database that theoretically the database that you need to do that can be very very simple very focused on just just venting yeah so but the the the negative reaction that people have is all this eventing that's going on so you know that's the one of the things that gives people probably the biggest pause initially when when they're looking at this and but at the same time surprisingly you it's opening up opportunities for more concurrency because often the traditional approaches for that we're using for handling data we're delegating all the concurrency control to the database yes right and the database they're magnificent invent inventions right i mean there's the complexity of databases are just you know spectacular but when it all said and done it has critical paths right that only one thread at a time can go through this is why we have locks in databases yeah and so there's a lot of concurrency controls and we're delegating all this concurrency control like with stateless systems we're get delegating that into the database the database is ultimately responsible for for keeping state of data consistent that comes at a cost and you can have a horrible cost to it because you can run into a point where the database simply can't go any faster because it it can only do one thing at a time so fast you know you have these choke points that where things are pushing through regardless of how big and powerful the database is you got traffic that's going through one one you know single file thing and and different places in the database and so it's like how's that working out for you right in this approach you don't have that kind of you don't have the locks you don't have the the the the monol and the transactions the typical transactions that are doing create you know crud create read update delete types of things to multiple tables in a single atomic transaction i would say we're hooked on acid we're spoiled right you know the the acid transactions because they're incredible incredibly powerful and useful and they take a lot of burden of responsibility off of us in a great way but comes at a cost this approach is fundamentally different it's doing you know a lot of these little more fine gr events but they're simple database operations and they're highly concurrent database operations and things like that and and one thing i want to mention that this is a relatively recent and it was staring us right in the face is that an event journal is also a topic so when so all you have to be able to do is read the events that go into the event journal by offset just like the way kafka does so you have a natural message producer in an event journal so you don't need to say write an event to an event journal and then push it out to kovka so like messaging from one actor to another reliably using the event journal could be done using the event topic and then you can you can partition that right that's how you know you get the the concurrency flow well guess what you can do that at the persistence layer as well so one of the recent innovations that you know my company's doing is that we're we can take an event journal and split it in instead of one say database we can do two databases or four databases or eight databases and we're getting near linear performance not totally linear but you know so it's we're not choking on say one database it can only do so many io operations per per second type of thing yeah we you we can go to two and four because we're partitioning the traffic to the persistence layer and the same we're partitioning the traffic to at the messaging layer out of curiosity what is the underlying database is it custom or is it something i'd know it can be it can be cassandra you know it could could be no sql it could be sql it could be a an event specific data store so bring your own you can bring your own yeah okay or you yeah because that's kind of at the code level your code is really only concerned with emitting an event how that event is actually stored can be kind of abstracted away under the covers and because you're not dealing with transactions you're not dealing with you know you know object relational mapping or anything like that you can kind of hide all that complexity is gone and you just so you can switch out databases whatever you want that gives you the most performance and the best cost to it as well this makes me think then about monitoring because presumably if you can access the database you can look into the message stream are you also persisting the state of each actor so i could look at the list of messages that went in and the state it had and the messages that came out yeah and but typically what happens is that there's there's this concept of snapshotting and the the idea is that periodically not every time that an event is stored but periodically you're saving the state of the actor in a snapshot store so maybe every hundred events or every day or some you know whatever frequency you want but it's relatively infrequently you're saving a snapshot so you want when you want to recover the state of a you know of a actor you go to the last snapshot first get the state at that time and then replay every event that happened after that so if you have a actor that has a very long history of events who say goes back months or years you don't have to replay every single event to get back to like your current balance of your bank account yeah yeah you go to a snapshot and then any deposits or withdrawals or you adjustments that were made after that that last snapshot so it optimizes the recovery of the state so there's kind of the event store which is basically just every single event is stored in it and then there's a snapshot you know for every instance of an actor you know for a given id and and this the last snapshot that that's saved there it's really funny to me that i mean i could almost say that the the kafka rting world got persistent message cues persistent message logs right about 10 years ago mh and has been gradually realizing that it's going to need state machines on top of that to actually build a system and then you've got the actor world which had the state machines and is gradually realizing it also needs persistent logs yeah do you think we're going to end up in the same place eventually you think i we're already there in effect because the this this is where i kind of think of event driven is two forms and the one form is i call hybrid event driven and another form i call fully event driven all right so hybrid event driven is say and i see this a lot is that you you're doing your normal database operation you say you have a microservice and you're doing your normal database transaction you have multi- tables you know type of thing you know normal stuff you perform that transaction and then you push a message out to kafka so that that action can be communicated to some interesting consumer of that you know of that operation that that operation occurred so ka is you perfect for that right you because it goes into a database which isn't a natural you know message cue it's not a topic it's a bunch of tables right that are that are being adjusted based on the result of a transaction yeah so you you just you you push a message out to kafka in a fully event driven you're writing events into an event journal which functionally is a topic so you're just consuming the consumers are going straight to the event journal to get you know to consume those events as quickly as possible so you're not there's the act of producing a event is basically publishing a message the act and then you just have the consumer that's that that's consuming it so mechanically it's it's a bit less complicated because you're not doing like these you know typical classic database transactions you're just doing these simple kind of event operations that are going into a vental yeah and and then those things are being consumed the other thing i like about fully event driven is that when you do update you know like if you're another common thing is you do the the database log you're scraping the database log you know as things happen in the database you're using that to trigger messages going into a you know message bus like kofka but those things are some those things are fairly ambiguous it's like yeah i updated this row or i i you know i i inserted this row or i you know updates are the most ambiguous delete is is obvious but but it's it's those ambiguous changes versus when you're fully event driven the event says i added an item to a cart another event says i removed an item from m cart another event says i changed the quantity of an item m cart or another event says i've checked out you know that type of thing so very unambiguous statements of fact that's what events are you know unambiguous statements of fact historical facts things that have happened so there's there's a precision to your data which is what's required in messaging you want unambiguous messages so the consumer knows what to do with those kinds of messages so that's where i really like fully event driven versus the the more or kind of hybrid event driven where you're you're bolting aent venting onto a kind of classic design patterns yeah yeah yeah i can see that so that makes me wonder about like where we introduce this model because if i say you've convinced me that this is a universal model and you've convinced me that you can just use a central database as your locking mechanism and that will work for a long way but eventually you're going to hit hit this ceiling where you have to re architect right so if i'm convinced that eventually we're going to need something like this when it gets large how small would you go how small a project you say i'm not going to bother with actors i'm just going to monolith it well first you need to find good tools you know good like good software vment kits and good and there's there's not a lot of them right you know out there there they're out there so you need to you need to pick the right one and that that you feel comfortable with and then i would say yeah like we always say like with microservices start small you know and so one way to think of a microservice in this paradigm is that it's it's not like it's it's not say one block of code that you know that does everything the microservice is supposed to do you've decomposed the functionality of microservice into collaborating units of computation these different actors right so the order processing in instead of like like i said earlier one you know like one routine that handles all the processing related to an order it's delegated out to a collection of these actors they run independently of each other they're running in different space and time what i mean by that is that one actor could be running on one machine and another actor could be running on another machine and they're talking to each other through these asynchronous messages so the activist producing those events doesn't care who's consuming those events all it's all it's responsible for producing those events the other act pick them up when they can and process them as quickly as possible but as a whole they're all working together collaborative collaboratively to say get the order process type of thing so your microservice is composed of say this little community of different actor types that are functionally together collectively performing the bigger operation yeah that's your unit of deployment but you know so pick a microservice and try it but what i'm thinking is like okay here you are humor key you are you've got a favorite tool set that you're well versed in you're an expert in thinking and implementing in these systems is there a system you would sit down to write where you'd say actually i'm not going to bother with an actor-based approach this is too small or do you think that it's so useful that it's just your default way of writing anything no it's not in the case of like applications where it they're simple and you don't have any concerns about traffic that you know that the the existing you've done this before and the existing approaches that you've used work fine and there's no concern about performance there's no concern about costs it's a you know there's and there's thousands and millions of these kinds of applications right and you just bang it out you banged out these things before and you can bang them out again and you can use you know ai to help you bang them out even faster these days knock yourself out right it's the it's the the applications that you know are going right out of the gate that are going to be more involved in in als al are intended to grow you know maybe today you know just say you're in a startup or something and and it's you know your your customers are modest at this point but you you know you you're expecting that this could really spike you know pretty quickly yeah that you need to be able to scale up quickly then it's those kinds of environments where you've got an application that maybe starts simple but will grow into something bigger and complicated where there's more pieces to it it starts at modest performance levels but you know will grow into some areas of the application could goow into more exciting levels of performance you know that can you know either rock your world because you're making a lot of money or ruin your life because you're spending all all your time trying to keep the thing the damn thing running you know because you have reliability issues and performance issues so it's those things so this is really for those you know more kind of bigger enterprise types of applications where you want a programming model that initially because if when you're unfamiliar with it there's going to be a learning curve that you have to go through like i say it's not i don't think it's huge there's a lot of reward when you get on the other side for sure it's i love it now but and once you get on the other side it's going to be hard to go back to you know thinking about the other old ways but once you get on the other side then you can really start to move fast because you're like i say it what blows my mind is the capabilities of the system that emerged from relatively simple composition of these of these different the the way you're kind of guided into the design of the system you know the ultimate outcome of that and you know and things like where it really blew my mind was i was working on this the demo and i and like again was like my first big push into this kind of pattern design pattern and implementation and i was realizing well okay this system has to have stock i oh crap i'm gonna have to you know for demo i'm to pre-load all this this stock then i realized all of a sudden i said part of the system knew when stock was running low and i said oh all i got to do is why are the events coming out when stock is running low to send a command to order stock now this is a demo system so i don't have to worry about the stock actually showing up i can just you know the order getting created that triggers the flow of detailed stock information coming into the system it's like wow and then then i realized that this could actually have a bit of learned behavior because the part of the system knows when it's running low on stock but it also knows when it's run so low that orders are coming in that can't be fulfilled because we don't have sufficient stock in effect that's a pain signal coming into the system which can cont trigger learning behavior i don't like pain so let me write a actor that won't feel pain right when it when it gets a back order it's like you it's a little flick on the ear you you you failed me you you you let stock run out don't let that happen so it it should adapt it's you know order cycle so that kind of learned behavior simple but minimal learn behavior could be implemented in this relatively simple type type of of a flow you processing flow yeah yeah i can see that so it's that kind of reward i think is there on the other side that i hope might inspire some people to check this out because it's it is pretty interesting and i i keep thinking going back again i i think that all this emphasis on neural you know neural networks taking our jobs and you know transforming how we work and all those types of things it's this what we've been talking about the fundamental unit of computing is what's doing this and i'm and it's like this is right here for you to to take as a as a backend developer building backend systems you could be doing your own little you know relatively simple but reasonably interesting power little neuron networks basically so so while people are getting excited about chat gpc writing documents and creating images you are more excited about the architectural underpinnings and what we can steal from that yeah yeah absolutely absolutely very excited about in that case leave me with two hints if someone wants to get started right from scratch and this where should they go and if someone understands actors but has struggled with the design side where should they go well well my company you know i'm at light bend and aa is and there's two things aa and kix are built on all this so this is where i've been learning all this stuff and they're products so you know so but that that is one resource to to check there are other versions of the actor model out there that you can look into and as as a start and but then there's also the just the the idea of what like i said the fully event driven where you're using an event you know you're doing event sourcing that's another approach look at look for solutions that are they're fully event driven because in a way you can think about the things that are producing events are these little kind of neurol like actor like things that are that are producing events you know small units of of computing that collaborate with with each other so it's theoretically possible to just have an under a foundational piece that gives you event sourcing and things like cqs you know the command cter responsibility segregation for because event event journals are not queriable so you have to have some you know like views that are queriable but the views are consumers of events by the way yeah so if you look at event sourcing in cqs there's more and more things happening there if you're looking at var various offerings for the actor model there are things there but with the actor model it's this it's that direct relationship between the actor model and the kind of a event fully event driven type of approach that makes it enterprise reliable basically yeah yeah i have i've been looking around at combining the world of erlang and the world of kafka whilst there's no chance of me becoming a competitor to light bend that i think is a rich seam of this hybrid not hybrid this synergized if i can use that word actor event based model yeah earling got a long history right i mean they they're the ones that really introduced the the actor model initially and and they did it for the reason that they wanted to bu you know they it was used to build reliable phone systems yeah right way back right what 15 years ago or something like that the actor model has been around since 1975 yeah it's almost 50 years old i sometimes wonder if they maybe i'm oversimplifying but i'm sometimes wonder if because they're dealing with phone calls they don't quite have the same long running monitoring transactional worries that we have that we're now trying to solve with things like persistent logs yeah that exactly you know there's just like the pure actor model which the messaging with actors is asynchronous but it's what what's it called i forget you know there's at least once at at most once is what's it's called i say it's it's maybe once you know the receiver might get the message and can you build a system doing that well the phone system you could in an enterprise system maybe once i don't think your your managers or your business sponsors want to hear anything about maybe once you type of thing they want it to happen right they want you know guarantees so the model is evolving for new constraints and that's always nice to see in the computing world yeah yeah cool on that note the hope that the future will evolve while we still have time to enjoy it yeah you mck thank you very much for taking me through it oh it's great thanks a lot for for the conversation i loved it cheers thank you hugh there is hope isn't there i mean we're a bit prone to taking sides in this industry but we are at our best and our future is at its best when we're learning from all these different approaches and synthesizing something new that has parts of each if you're interested in learning more from hugh he was too modest to name drop it during the podcast but he does have a book called designing reactive systems i'll put a link to that in the show notes if you want to go and read it as you begin to scroll down towards the show notes please take a moment to like this episode if you liked it rate the podcast if you haven't rated it already or if you click the share button you could send a link to this episode to a friend asynchronously and then you can pretend you're in an actor model how was that for a link i should go i'm going to go i've been your host chris jenkins this has been developer voices with hum key thanks for listening