i wanted to talk about psychic signatures you know signatures digital signatures that just get you in any door right that's the idea it's called psychopath it's out it's after doctor who isn't it right so it's been a while since i've watched doctor who but the idea is that doctor who keeps showing people this blank piece of paper and it's psychic paper which means that they see some identification that means something to them and that's the idea you provide a signature that is invalid but the java implementation thinks it's valid and lets it in right and that's a really really big problem a security researcher called neil madden has disclosed the vulnerability in some of the implementations of java that is very very serious it basically allows you to approach a website with a fake signature and be let straight in right and you know these are used for things like one-time authentication mechanisms they're used for java web tokens lots of reasons to be using this kind of technology there's nothing wrong with it but if it's not implemented correctly can cause a real problem this was a bug introduced in java 15 and has existed up to java' and it's now been patched right so if you run any kind of java server you need to be patching really really quite quickly this is quite a serious serious bug it was introduced when they ported the code from c plus plus to java and essentially did a slightly botched implementation where they didn't perform some of the necessary checks in the elliptic curve digital signature algorithm right that's the algorithm at play here so it's the elliptic curve digital signature algorithm now we've done elliptic curves before very very briefly just to remind everyone your elliptic curve on a set of real numbers would look something like this it looks slightly different when you're modulo some large prime and the idea is that you can add points together on this curve so you can take a point here let's say g and then you can add g to itself to itself again to itself again and end up somewhere over here with point a times by g so that's g plus g plus g plus g a times and the the interesting thing about elliptic curve is when you do this it's very difficult to say what a was right if i say here's a g here's g what was a you don't know right and so a can be my private key an elliptic curve dsa is based around this idea right i could give you a message and you could use your private key to sign that message and send me back a signature and then i could look at the message i could look at the signature and i could go yep or no that's the idea we'll look at elliptic curve dsa sort of a little brief overview right we're not going to prove any mathematics here today but just so we can talk about what the actual implementation bag in java is and then we can talk about how that actually manifests itself if someone was actually attacking a system we're going to use two people having a conversation cryptographically got to be alice and bob right let's not i'm not going to be that person to step step outside the mold right now bob is the one that's going to be signing something to alice so bob has previously calculated a private and a public key right so he calculates a private key b which is a random integer right and he also has a curve right the curve says he has a curve let's call the curve c big c and he has n which is his number of points on a curve now different letters will be used by different you know if you've got a look on the wikipedia page for this they'll use n but if you look in textbooks they might use q it's not we're just i'm going to try and be as consistent as i can on this piece of paper right so bob calculates an integer private value b and then he calculates a public key which is the generator point on this curve times by b so capital b is b g right capital means on the curve does it yeah so this would be a this would be a curve point yeah capitals on the curve one of the reasons elliptic curves get a little bit confusing is because often your private keys and some of your values are integers and some of them are points on the curve so g here is a point on the curve and this b multiple of g is a point on the curve b is obviously just an integer actually this video is not really about dsa in some sense so i you know we're not going to go too much in detail about what everything everything does exactly right and i'm going to skip over some details so now let's imagine that alice wants bob to sign a message so maybe alice sends bob a message m right now this message you know could be a challenge token it could be you know some documents you need signing it doesn't really matter for this example what bob's going to do is now generate a signature for this message he's going to first calculate an intermediate value of the message which is going to hash the message right into a shortened form that's z then he's going to choose a random k right and that random k is what we call an ephemeral key we talked about this a bit with diffie-hellman but k essentially makes this signature probabilistic it makes it different each time bob calculates its signature it's actually extremely important that k is random each time and different each time now this is where the math starts coming in right we're going to calculate r right this is the first half of our signature r is k times by the generator point so that's a point on the curve and then you're just going to take the x component now what i've done there is i've mixed mathematical notation with programming notation and i'm going to say here no more about that that's absolutely fine as far as i'm concerned right and then you calculate the second part of signature s right which is k to the minus one so then the multiplicative inverse of k multiplied by z plus r times b and for those who are not mathematically minded the multiplicative inverse is one over that is it well it's so yeah yeah very good very good question so in normal maths yes right if you wanted to multiply the multiplicative inverse of x is one over x when you're doing modulo n which is what we're doing on this elliptic curve you actually have to calculate the multiplicative inverse it will just be some other number between one and n minus one and you could use the extended euclidean album to do that you can use fermat's theorem to do that there's a few ways of calculating this but it's not immediately obvious what it is right you can't just say oh it's this you know you have to we have to calculate it but we're not going to worry about that too much bob will then respond this is it he's finished right bob will then respond with a met with the message m yeah i mean maybe alice already knows it doesn't he said it and the signature r s and this is where alice now has to verify this signature so we did a video on digital signatures already but in this case it's not too difficult for alice to verify so first of all she needs to check that r and s are in the range one to n minus one right so then she needs to check that r and s are both at least one and less than or equal to n minus one all right then she's going to calculate the intermediate hash value of the message again all right and then she's going to calculate a couple of equations so the first one is u1 is equal to z times by s to the minus one mod n right now it's not important actually to understand this attack to understand follow exactly what this math is doing right because we're going to talk about the problems that the java implementation has u2 is equal to r times s to the minus 1 mod n again right everything's mod n so again we'd use the same algorithm we used for k minus 1 on s minus 1 to get the multiplicative inverse of s and then this is the actual test alice needs to check that r is equal to or congruent to u1 times by the generator point g plus u2 times by bob's public key capital b and then just the x coordinate for those of you thinking well how does that work right that involves the proof okay it's very very clever but we won't write that out because that's not really what this video is about alice's process of verifying the signature basically if she takes m and the pair the signature pair r and s and calculates this equation and if the two sides match then this is sorry this is mod n and mods that thing where it's a bit like a clock face yeah it's a clock face so if you divide by n and you take the remainder right so n mod n is back to zero again right and n plus one mod n is one you know now just just to not completely skip over what ecdsa is doing here how does alice know that bob signed this message right well basically because the fact that this works means that bob must have been in control of the private key b right because it was used as part of this equation the other thing is that u1 and u2 include both parts of the signature and the hash of the message so it's also checking that the signature matches the message which is very very important so alice knows if this is true if the left hand side equals the right hand side alice knows that not only does this signature match this message but also it was bob that signed it right as long as no one's stolen bob's private key it's a different video for a different time all right now what's wrong with the java implementation well one of the problems with ecdsa that you have to be careful if you're implementing it is for example i mentioned you have to choose a random k you can't choose a cave that's been used before right so actually a truly random k could be a bit risky because you might accidentally generate the same one twice so sometimes they have ways of deterministically generating k such that you can be absolutely sure you never repeat it right another big problem is if you don't do this check in here i'm going to i'm going to put this in red this is very important right but you check this if r and s are not in the range one to n minus one you can't guarantee the security of this scheme in this particular attack the issue is that java doesn't check but rns are both not zero right that's a real problem so let's work through what would happen if r and s was zero well the hash comes out exactly the same z is the hash of m right u1 is that hash multiplied by the multiplicative inverse of s which is zero multiplied versus zero now that that mathematically doesn't actually exist but it does in this case because the java implementation happens to just spit zero back out at you right so it is z times zero is zero right u2 is r which is zero times by s minus one which is zero is zero all right so we've got zero and zero and zero times g plus zero times u both of those are unfortunately the point of infinity which is essentially zero on this curve the x coordinate of that is zero it's zero equals zero question mark and that's the test that alice will perform to decide whether this signature is valid and it is because zero does indeed equal zero as far as i can see i can see i haven't noticed anything wrong with that so let's talk a bit about you know let's let's move away from the map and let's talk a little bit about what practically this means right essentially this is an implementation bug this is very clearly defined in the spec that you make this test you also have to check that this is not the point of infinity right there's two checks that you have to make here and they have not been made so as you say this is implementation so that basically means that the theory sounds but it's not being put into practice right what's the implication here what actually happens in reality it's it's really serious right this kind of technique is used all over the place on the web but it's used in a couple of core authentication mechanisms which is where this is the real problem like immediately right it's a problem everywhere things like banks well yeah it could be used by banks to you know verify messages from other banks for example you don't want a situation where a bank can send a transaction signed by xeros and it be accepted and you know i mean maybe he's an attacker i might quite like that but you know another example is one of these you know one-time password or login two-factor authentication devices so for example i have one one of these ubi keys like there are lots of devices like this and what they often will do is they will respond to a challenge from the server by signing something with the private key using elliptic curve dsa so suppose there's a server here and here's me with my key that's the world's worst key isn't it and what happens is the server sends a challenge challenge m and i sign that challenge using elliptic curve dsa and i send back m and r s right now the server will verify against my public key and that would have been the first time i registered my device so maybe at some point i logged on to the system and said i'd like to register one of these devices i plugged it in and it went great your device is registered you can now use it for two-factor authentication what will then happen is the server will verify this signature against the challenge message and check whether it's correct right now the reason it has to send a challenge message is because of course otherwise i could just send this all the time right if it always sent the same message like sign the number five then everyone will just get a copy of that valid signature and just send it on and pretend to be me so it has to be random each time but the issue here is that an attacker can just send m zero zero right and if this server is implemented in java versions 15 to' it will go yep brilliant and let and let you log in right so literally you just take this and you just write zero zero and then you can just start waving your way through different different servers right and no no questions asked so you know if you're running a java server i can't stress enough that you really need to be patching it before this video began but really get on with it now 3g plus g would be it goes along here like this intersects the curve somewhere else flips over and it's over here so this is 4g now we won't look at it anymore right the actual formula for this is just mathematics to do with line and when that space what it's doing is it's looking for extra areas where it can add the nodes to build that graph up