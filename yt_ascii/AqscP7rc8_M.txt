one of the things you can do an image [posting] package is resizing images or rotating images and so on and when you do this in any program paint on there photoshop the gimp and so on you have an option to choose how you want it to scale the pixels so do you want it to be [nearest] neighbor or by linear or by cubic? so today, we're going to cover image transformations but mostly rescaling because it's a simple one, and [we'll] look a bit at nearest neighbor and bilinear and so on let's imagine we've [got] a three by three image. so there's a three by three image it's you know high quality, and i want to scale this image by a factor of let's say three, okay? which is going to mean a nine by nine image, so cut to a long shot of me going like this frantically, so [this] isn't going to be nine by nine because i've gone that i've gone to were not important. it's not important [i] don't know. how many this is i'm counted. it doesn't matter right? i'm scaling this and it extends this way for some indefinite amount of time depending on what my scaling factor is okay? let's leave it at that now if i wanted to scale this the obvious [way] to do it is just to multiply these values by some pixel coordinate amount so let's say x becomes 3x and put them in this image and then problem solved right so that would be might you first get how it work let's say it has 120 this is 121. this is you know grayscale let's say 115 and so on we say right well this one stays in this corner because this is naught naught naught times a scaling factor of 3 is also naught so we say this is going to be 120 okay? that's my first guess at this 121 is at 1 0 so it becomes 3 0 so naught 1 2 3 and it becomes 121 if this is 100 then 100 goes down here and this is 110 and that goes over here and these are all 0 right which is about the worst scaling ever this isn't going to work like this approach it would just look like a black image if you zoomed really far out you might see some colors in it but really the majority of this image is black and completely useless so this isn't i have scaled this image but not properly right because the problem is that there is no pixel in this image that maps of this one, right? this maps are somewhere between [2] pixels, so that's the problem. we need to solve all right, and that's the problem being solved by nearest neighbor or by linear or by cubic so natural fat when we want to scale an image? we do this process in reverse. we create the bigger image and then for each pixel we look back and see where are we supposed to be getting our sample from it is between two pixels we have to think about what we do if it's on and pick a little great. we'll just take that pixel value, so i'm up my instinct here would be that your 1/20 would would be [x] 3 so all those 9 would be 120 yes, that's pretty close to newest neighbor. [so] what we do here [we] say well, but this is a value of 1 0 which is going to be a [third] zoom it when we scale back so we're closer to 120 than we are to 121 so this becomes 120 right this one goes down to 2/3 down here so it's closer to 121 then it's to 120 so we say that's 121 this probably gets 121 and so on this is why when you make your image bigger using nearest neighbor it continues to look pixelated because that's exactly what it's doing it's preserving all that information by [just] duplicating a bunch of pixels in these gaps right now that doesn't seem like a very good way [of] [doing] it but of course that might be what you want to do if you're a pixel artist who's doing you know pixel art then scaling it and having it all blur will be edges. [it's] completely useless for you, so depending on what your situation is you might want to do that the other thing? is that strictly speaking then we haven't in? essence made up any data this pixel value is still one of the pixel values that was in this original image because you could argue we don't know for sure what's going on between these two pixels it could be anything it's just that the camera isn't high enough resolution to capture it with bilinear interpolation what we're assuming is but the thing that's going on between here is entirely obvious it's just a line between the two okay so we're going to take an average. let's have a look at some of these, so we've got a value of 120 and we've got a value of 121 all right and this is [a] pixel zero and this is a pixel [one], and we're going to be filling in these two gaps here so this one here is going to be a value of 1/3 or [not] [0.3] recurring and this one's going to be at a value of 2/3 already people can probably see what's going to happen here for this one we're going to take 2/3 of this in a furnace and vice versa okay, so the formula is [actually] essentially a weighted sum of these two things, but the weighting depends on how far along this distance between them you are okay, so this is what linear interpolation does so in this case. we would say 120 to 121 isn't a very helpful example because we're going to have to do some rounding at some point and then kind [of] defeat the whole object of what we're doing, [so] let's let's pick it more obvious one, okay? so let's say that this pixel value is a hundred and this pixel value is two hundred and we are trying to sample the pixel position a third of the way along this is very straightforward [so] all we have to do is we have to do 2/3 times by 100 plus [1/3] times by 200 all right and if we sum them up, what do we get this is 66? ish, okay? this is also coincident lis 66 ish, and so we add them up and we get about 132 or something like that well
we've got a [hundred] thirty-three [the] coding don't we we get a value exactly 1/3 of the way along from the scale of 100 to 200 okay, so that's linear interpolation so the only the only thing we have to worry about now [is] how do we extend this to two dimensions and again not very it's not very challenging so if i just take away this piece of paper instead [of] having two endpoints. we now have four okay, so we have one here. we have one here we have one here and we have one here now. this is x1 y1, and this is x2 y1, and this is x1 y2 and x2 y2, [and] we're trying to find some position here x y and more often but not if you're scaling in image or doing a rotation or something along these lines you're going [to] find yourself sitting somewhere in between two pixels. what we do is we first interpolate these intermediate values here okay, so we do what we just did along between this line? so we find this is just about 40% is it so we we do the formula that [says] what's the value? 40% along from here to here okay, and we get some value here, and then we do the same here so what's 40% along here? we do some value here, and then we interpolate between these two values to get this final value output, and that's how we can map between [four] values to some arbitrary position in amongst them and that's basically what happens when you click bilinear? when you want to resample you image, so any kind of scaling any kind of? rotation anything that is going to involve a scale it doesn't fit exactly on the pixels from the original image and remember we're doing this in reverse so we go from our new image back we look back into our original image and find out where we need to get the color form so back to our original example this x1 y1 is going to be 120 and x2 y1 is going to be 121 and these two are going [to] be 100 110 and we can have any position in between these pixels depending on what we're doing tor image we're making it a factor of 10 larger then is going to be 10 increments between these things if we're making it smaller there might be fewer than [1] you know it might it you know does that work as well? yeah, so if you'll make it? so actually the scaling you're doing makes no difference right if the scaling is smaller than 1 then you're still going to have pixel values that sit in between the original pixels. it's just not going to be very many of them anymore because you're actually making the image smaller and the same with a rotation all that changes is the transform we used to get from these positions in our destination image to these positions in our source image the only other thing to remember about linear interpolation is that it is just that linear if we looked at a row of pixels? sidon, then you might get a value if this is 0 you might get a value here and here and here and [here] and [here] and [here] like this, right? so this could be our image different intensity levels right so just for a grayscale image we might have something that looks a bit like this if we look [sidon] now if we were just scaling 1 to 1 we're going [to] be getting [this] value and getting this value and that's fine if we're scaling somewhere refer it away along, or 2/3 of way between this one and this one we're going to need to interpolate these values which corresponds to finding positions along these lines here and this is what linear interpolation is doing? it's fitting straight lines between these objects and finding the positions along it that looks like a very pointed feature that you've just done with those lines so is it i'm guessing that we can start drawing curves right that's right [so] the problem [with] by linear interpolation and it's not much of a problem if you're just let's say we stomping by a factor of 2 or something so vit you know you're only creating one intermediate value it comes down to what our assumptions are about what's happening in the image between these points it might be more reasonable to say well, maybe given this underlying data member these two are part of it it might be something a lot more like that you know a bit smoother so that if we sample here, it's closer to this one but it is to this one, and so on okay. that's what bicubic interpolation does but that's what if in video that's 66 ish, okay. [this] is 66 again rights, we've done what we get 120 okay? so [420] something recurring yeah, let's start that again. so we go, so this is 60 60, okay. this is also