typescript 5.2 new keyword using which is also apparently as i've been told reliably by chat the least degenerate group of people in the universe that this actually is a javascript feature it's in stage four it's using sparkles using there we go typescript 5.2 will introduce a new keyword using that you can use to dispose of anything with the symbol dot dispose function when it leaves scope which is kind of interesting right away i started thinking this is like drop light from rust and i wonder what it means by leave scope are they actually welcome costco thanks for leaving alerts on okay i left alerts on i left alerts i left alert effectively it's like you get a destructor to be called when something leaves scope i'm very curious what they mean by this because it's kind of crazy to think that we would ever want this in javascript i'm gonna be real here i'm extremely skeptical that this is a good idea we'll see we'll see this is based on tc39 proposal which recently reached stage three indicating that it's coming to javascript using will be extremely useful for managing resources like file handles database connections and more yeah i figured this would be the use case right because this is just destructors destructors available in javascript we'll see let's see is a new global symbol in javascript anything with the function assigned a system.dispose will be considered a resource an object with a specific lifetime and can be used with the using keyword okay a weight using you can also use async dispose and the weight using oh this beautiful to handle resources which need to be disposed asynchronously get resource async some await function beautiful await using resource this seems exciting this will await the symbol of sync async dispose okay so actually i do have a little bit of a hard time here what what exactly goes on in this code i'm having a hard time kind of walking through this in my head so when i see the term await i assume that this will stay until whatever is happening is finished get resource is not async right it's a function that returns something i'm having a hard time trying to understand this meaning that when does this thing when does using get kicked on using must get kicked on at the end of the scope but why is the await word here which makes it hard because i assume you'd go await using resource equals resource then you do some code then at the end of this little at the end of this scope then it would dispose it which would also be awaited am i correct on that the problem is is this example is just not big enough for me to understand no no text heavy that makes less sense because you don't need to wait that yeah the dispose is automatic no i trust okay i understand how get resource works if you look at the code it's right here it's a function see that first off this is why i hate i i despise that this is like current javascript style this this it feels like the most try hard annoying feature of all time why don't people just do this i don't understand it why are you just not making it clear i don't i just i don't i don't get it right like i just don't understand why people have to do that i don't get it i i just i mean sure why don't you just make this a reality in javascript okay make fn a function if you want to it just makes no effing sense that you do this the amount of symbols and the fact that you have to wrap this thing with the parenthesis to tell you it's actually returning this thing i like arrow functions but they have meaning okay they have actual meaning second off every single yes a class would be better here because every single time you call this function you actually generate a new object plus you generate a new function right you're generating new items this isn't nearly as optimized as a class can be because classes are obvious what you're attempting to optimize right whereas this isn't oh i have always hated this pattern so right now i don't understand i don't understand the execution order because here in my head here let me go like this here whoopsies like don't get me wrong i do love arrow functions when they're used properly okay so i see this my question is can i do things here then does a resource get disposed here there we go right so what it looks something like this then i'd go something like a resource dot you know do something right oh thank you thank you co-pilot and then i could await that right which actually what's happening here okay so this is what's actually happening here then which code i i don't they should have used the term defer something so what's actually happening here is this const resource equals get resource a way to do something await resource dot async disposal that's what's happening and there could be more they're actually well you're right there actually could be more there actually could be a hidden try catch somewhere in here that we're missing as well right they're they're very well could be a a hidden try catch that's going on as well it disposed in the correct order yes and disposed in the correct order but i i just this line sucks and what i mean by this line sucks is that this await doesn't happen where you think it does what i would much rather see in something is something like deferred resource dot dispose right and then if your dispose is async you can await that right this on the other hand is very clear what's going to happen right you know for a fact that this gets executed at the end of the item whereas this await is actually in a weight further down the chain i feel yeah if you went like this that means this function would have to be async right oopsies right that's what that means i just don't like the lot i mean yes it won't it's not hard to understand what's happening i just like better words here me personally better words here okay i like better words that's a me personally kind of thing i don't i don't like what i see i don't like what i see because i don't like it right i would rather honestly i'd rather because i don't like that a weight doesn't have an effect here but later on it looks confusing in my head what i had honestly what i'd rather see is something like this using that's a function that you have to do like get resource and then yeah then you have this whole then you have this and then it manages it at the end right it does and then you can await that because now i can read this from left to right if we're not doing defer i can read this from leftover left to right i can i can tell right away that i will await the end of this thing and we'll get the resource and then we'll do our async stuff and when it's done with that function it will actually await the results and await the disposal to me this makes 10 times more sense than having you know i can't you have to you just have to have that knowledge i don't know i don't like i'm not sure if i like okay me personally okay it's a me personal thing i understand you may love it anyways let's see yeah okay use yeah file handles yep these are great you always want to do this right this is just like such a great thing to do people forget how useful this is and sometimes you forget to close your file handle which is also a little bit surprising i just assumed that the moment this thing is g-seed it also gets closed but you probably don't want it open that long right i i understand why you want this in the sense that you don't want to have to wait for gc to close your file handle you would much rather have your file handle close right away correct so instead you'd have something like this right i really am not loving this pattern yeah i don't really love the pattern i don't love the pattern but i get it gc doesn't close the file handle when the really so it's just permanently opened huh interesting okay yeah okay interesting that's why you should just always close your files huh huh huh database connections yeah this also again this makes sense i understand why people want this not i'm not arguing that i like the idea of defer i'm arguing that this is a strange way to say defer right this is just a strange way to say defer not sure if i love it this is also i mean this is really kind of crazy syntax as well that you're actually lifting out the value of connection while having the dispose be a part of some outer thing it's i mean it's pretty wide it's pretty wild the idea is nice i like it i don't mind it thank you matt for throwing this i like how matt has a signature on his website look at that matt has his signature on his website i don't have a signature on a website js getting stranger i'm not sure if js is that great but i do like that he has a async function main look at that he has a main function in javascript look at it go look at it go huh yeah i don't like the look of it but whatever i'll just get used to it you know i'm gonna use it i'm gonna use it you know i'm gonna you know i'm gonna be using it right i'm gonna use it it's gonna be great i'll be happy that i have it i'm just not stoked about it you know what i mean i'm just not like i i'm just not in love with it you know the disposed symbol is defined by libraries yeah i will defer judgment on it i will i will be async using judgment on it it's extremely useful absolutely because then you don't have to do try catch i am oopsies hey unless hey unnecessary dick riding buddy with your extremely useful okay it's nice i'll give it to you i'll give that to you okay it's nice but that's all i'm giving to you okay they're they're saving the defer keyword for the unavoidable unfortunate future where they introduce the fur and the and they make a typo oh they oh d ref would make it yeah let's see okay what about dick's riding use using beautiful it looks like resources don't compose it doesn't well yes it really looks like well in this example all resources are like inlined which probably isn't a great way to go about things i don't think it's great i wonder if classes are more performant than just objects like this i've never actually done any sort of testing to find out the differences but it'd be kind of interesting to see what is the consequence of programming like this versus the consequence of programming differently they should be yes it typically that's how i would think because you're signaling to the compiler that this shape is like well first off you don't have to ever recreate a function right you're recreating functions here you only have one function ever created so you would assume that it's better but you know it's javascript you can't you can't it's not that minor there's some crazy things that will destroy there's crazy things that will destroy your performance in javascript it's nuts it's crazy it's crazy it's similar to the eye disposable yeah it is but still still kind of hard i want to avoid the monkey and banana problem okay i'm not sure what that means but i appreciate you for saying that you know what i mean hey guess what the name is the disposal jet