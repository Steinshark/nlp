there's no such thing as clean code everyone seems to be striving for clean code at the moment you can't read a blog post without the author telling you how clean their approach is engineering teams get together discuss which the possible solutions is the cleanest other developers assure you that they practice clean code you know i really want to coin a term and i really want people to use this more often i think we should drop clean code at some point and i think we should adopt the phrase whiteboard masturbation i really feel like that this is the wave okay this is truly what programmers want to do okay they want it they want it so bad they just want to do it all day and that's it it is it's just so good no i don't want circle jerking because that's not quite as good as whiteboard masturbation right whiteboard masturbation perfectly describes it i've come to to a realization though there's no such thing as clean code yup clean isn't a measure of anything useful let's go code can't be cleaned simply because clean doesn't describe anything about code so there's two things that i think is really fantastic it sounds like this this article steve on stuff you don't know that clean code is like literally like tm right there's like a tm clean code uncle bob clean coat clink like there's a strategy right but second he's also completely correct no matter how much you try to make a clean code your code is just it's just as horrible every time what a hypocrite i'm not innocent myself i use the term clean plenty of times in the past i also want to make it clear that i'm not trying to disparage anyone who uses the term oh i hate prefaces as a marketing term or a description of a of a vision or ethos clean is great as a technical term though i got some issues yeah your title already said that clean code is good code right when people describe code as clean they usually mean that the code is good in some way the thing is code can be good for a variety of reasons it could be readable understandable simple performance safe elegant testable encapsulated elegant is definitely eye of the beholder a scalable maintainable reusable easy to delete i love this last one neat and tidy non-invasive systematic okay now i'm now you're just using words i don't even understand consistent and any a number of things okay okay but these traits are in some way at odds with each other the most simple code is probably not the most testable code is that true i would argue the opposite all those interfaces and injected dependencies make for convenient testing but have a cost in terms of simplicity this is where i think the clean code movement did everybody a disservice depends the injection doesn't fix a lot of things okay javascript was a mistake is what i'm trying to say your heavy reliance on singleton's may make things easy to understand but it might not lead to maintainable application hell yeah hell yeah it could be argued that some of these things are fundamentally opposing forces that can't be satisfied simultaneously engineering is about trade-offs so we've got to be aware of trade-offs we're proposing and able to discuss them as a team you know i feel like this is the catch-all argument of every article you read every article by every engineer always uses this as a way to avoid actually saying something do you know what i mean it's always like well you should be able to discuss the trade-offs that's not actually saying something right you're not actually saying anything you're literally saying this code is clean but in a different way you didn't say anything if the code is good we've got to say why okay now there you go but it depends i know it depends but then you gotta say the depends right when someone says it's like you gotta say hey you know what dependency injection nine out of 10 times bad idea throw that in there throw something else in there do something right make a statement give your reasoning make a hill stand on it when somebody says a solution well i gotta crack my back oh yeah oh yeah when someone says the solution is clean they're often touting it as the superior option without being able to rationalize why i love that i want to have a constructive discussion around technical solutions then we've got to be able to articulate to each other why one solution is better than the other honestly i don't want this real talk i don't want this you know what i want i want you to write a library i want you to have an interface that you don't break and if you do break it you have to have a good reason why and i never want to think about what stupid ass code you wrote i don't care you know why because when it comes time to do something with it we all know what's gonna happen anyways you're going to add something realize you're completely wrong rewrite the entire damn thing anyways probably in rust and we're gonna move on and nobody cared nobody cared then nobody cares now stop arguing over the dumbest things in the universe on pull requests and just try to think of the system as a whole i just i just can't handle the dumbness in these things okay it's no good arguing over which solution is the cleanest as if there's let's say as if we should get our clinometer out in a way up at each solution according to this mysterious metric it's actually quite difficult to express sometimes why one approach is better or worse than another it's a skill that is worth honing sure yep it's really about your interface i really don't care what the code looks like on the inside at the end of the day like if i'm maintaining it i want to look kind of the way i like if you're maintaining it and you like how it looks and you can maintain it i don't it's not i i don't i don't care i like solution x it decouples the error message presentation from the core logic it's easier to understand because you don't have to consider both at the same time the separation also unlocks some testability as we can mock either object mocking is you're already you've already literally lost your life wheels testing the other it does not come at the expense of requiring the parent objects to inject the dependencies but it's worth it's a worthwhile trade-off for testability mocks more like scoffs the second statement is actually conveying something tangible about the pros and cons of the solution we're discussing terms like clean allow us to cop out rather than working under approve our ability to articulate our ideas i like that that's great good job we need to use precise terms let's go coding is generally a team sport if you're hacking let's see if you are hacking away on your own then you can do what you want but when we are working with a team then we've got to discuss our ideas being able to have discussion about technical solutions using a language that is specific and has a common understanding throughout the team is invaluable in understanding one another you know i remember i there's the i recently got attacked on the internet by somebody promoting some library to do to do a lot of like you know his monoid got stuck in some endo functor we're not really sure what happened anyways this library reminds me of rxjs and he got really upset and one of his counterpoints was oh yeah well why don't you create a throttled function that has exponential back off it's just like hey man i've done that once in my lifetime that's not a reason to use this right that's not a reason to use this what are you talking about right it's like one of those things where where people think something looks clean or good or great and you want to use it everywhere because that solution is the thing that makes you feel good and then you have these weird justifications for why you like this one solution and i don't understand why you want that one solution okay i'm sorry it just it doesn't make it doesn't make a whole lot of sense to me to use everything for this one theoretical case that could be pretty difficult to solve i'm on your team you're right creating a throttled bleeding edge value debounced function not super easy right takes a little bit of time takes a little bit of thought what does that mean when you use that hammer everywhere right clean code means that a different thing to everyone absolutely because that was the argument was made to me which was this makes clean code and i'm like i don't know if it makes clean code to me it makes the unclean code so some developers code is clean because it has a well-defined architecture to other developers code is clean simply because it uses consistent formatting style okay i mean that's just crazy get a formatter you know i use prettier when i have to do typescript and i set my own things like 80 line max and stuff like that because that's what i like and if you don't like it right like i don't care words like encapsulated testable mockable reusable odd mock your mockable have meanings that we can all agree on when we use more specific words that describe the various code traits that affect our projects then we can be sure that we're all on the same page i prefer the term like cringe i can't think of anything else because my small meme brain can't think of any other words other than cringe okay either your code's cringe or it's not cringe okay i don't i i'm a no cringe code guy okay that's just facts clean has the same level of precision as good you can unbaste it's either based or cringed what do you got you got cringe code or base code you can say that code is good just as you say that it's clean but that doesn't absolve you from having to justify which is which more concrete rationale yep i love that what is clean code so i think that one thing that i think is kind of funny in this whole thing again i mentioned it earlier i really don't think this person realizes clean code is a style right is a is a book is a style it is a thing right i've come to the conclusion that often we describe code as clean when we think it's good but we're not entirely sure why it just feels like the right solution sometimes we do not know why code is good we can we can't find the words to articulated and somehow the conclusion of our blog post just reads see look how much cleaner it is it's good to build that intuition but it just but we can't just stop there we need to dig deeper beyond those feelings okay so i actually do want to take something really really quickly here so for me this is like web web development reality right now which is what i see in a lot of articles is that you see this final product and it's like one line to do something one line to display something and like that's it and the final product looks so good and you're like wow i get that but then on the back end it's like 200 000 lines of code of state management tools that are abstracted over every possible solution for your one single little to-do list item that needs to either be deleted or completed like right like it's just like an enormous amount of all these things put together for you to be able to have like two lines of code right here and it feels clean it looks nice but in reality is like there's so much going on it's the facade pattern god wrong you really feel like you're just like oh look how nice this is i often find that when i get into that solution when i'm striving towards that in a personal project or in a tool i'm making for netflix by the way i work on netflix by the way i i know for a fact that i have done something wrong right that's always actually an indicator for me that i'm doing the wrong thing like i truly am doing the wrong thing because often what that means is that when i want to refactor i've created an abstracted mess that when it comes time to refactor my life is miserable the only time you should see one line or two lines or three lines is in your main function your main function goes give me the cli args it into the thing the end literally the homer simpson meme yeah i know developers love it i don't know it's crazy i really like this the idea behind this which is that let me sum up this this article a little bit better for you figure out a way to start articulating why one code approaches is better than another and the thing is is stop using the words dx dx is the modern clean code right that's the new that's the new version okay so this is 2022 in 2023 we use the term dxdx has been gaining steam over the last few years and now it is like the pinnacle right you just can use d x you know always like watch this i bet you i could tweet something like dx at all costs and people are gonna agree with this dumb thing why i don't know why they would do that why would you agree with that okay it should be customers because at the end of the day no one cares how ergonomic your code is they care that you build something people actually like okay that's what happens at the end of the day okay and so it's just like you see this all the time and it's just wild to me right it's just wild to me i don't know anyways stop trying to use terms like dx and all that crap instead do something simpler right describe why something is good or why it's not good dx equals developer masturbation that's true it's very very true directx is losing that seo i know they're losing it so hard yeah and that's how it works hi by the way first time chatter well hey warner how you doing the name is well i mean it's kind of funny that we just got done reading an article about being able to use your terms better and then you're also accidentally using a term and then imbuing a different meaning upon it not realizing that clean code has a specific meaning and actually has an entire ethos around it but i do really like the idea of what you're trying to say and so therefore i do appreciate the article again