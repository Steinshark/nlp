hello my name is farid and today we are going to take a look at c plus plus functions by functions i do not mean the strict traditional definition of functions but rather i'm going to point out the concept that is best described by callables in this session we will take a look at c free function pointers then try to implement the observer pattern using these function pointers then we will take here review of steady function on both c plus plus 11 brings to the table after that i will try to show a different usage of function pointers and then i will introduce a few functions and classes that i would like to have in my utility for functional programming just like declaring a function in order to declare a function pointer we need to specify the types of all of its arguments as well as its return type initializing and assigning to a function pointer is just as simple as an ordinary pointer but we can also remove and omit the address operator for syntax clarity in order to call the target of a function pointer we can de-reference it using the reference operator or we can omit the reference operator for syntax clarity i couldn't find an accurate and strict statement about the relation between the size of a function pointer and its argument types or its return type but there are two guarantees first all function pointer types are castable to each other so we can cast the function pointer to other function pointers and back to the original pointer type without loss of precision or information moreover we can cast to and from avoid pointer so we can store every function point as a void pointer when necessary and cast it back to the original type in order to call without losing any information examples of usage of function pointers in standard c library include the signal function which is supposed to register a user defined function as the handler for specific interrupts another example is the q sort function as the generic sort function in the c library this function expects a pioneer per decade in the form of function pointer the parameters to this function are type erased through use of void pointers the only information available about the type of array elements is the size parameter used to iterate through the array and the compare function moves the types completely similarly the b search function performs a binary search over an array to find the element matching a specific key in order to do that it needs a binary predicate again in the formal function pointer and use of void pointers again erases the types of the arguments the type information is again transferred through the size parameter and the predicate comparator function point errors are widely used in ui events management applications as callbacks fltk is one of those ui event management libraries the callback function of nfl tk window can be used to register a function as well as the data it needs to respond to it to an event originating from user interaction similarly in photon ui from the qa next artist we have the ptr callback function this function adds a specific function along with its data and the event queue of a specific event for a widget the callback system of qnx photon is a good structured implementation of the observer pattern this is the pattern of choice in designing many event-driven libraries for ui applications the subject or event handler is eventually a collection of observers attached by user code at runtime upon the occurrence of an event the subject notifies its observers with parameters describing the details of the event an observer can be required regarded as a pair of a function and its associated data this function is then called through the notification using the extra data provided by the notification mechanism the notification syntax in c plus plus ui libraries is generally a function called the challenge in c plus plus used to be to find a mechanism to implement a template class for the event handling mechanism this class should have been able to instantiate observers of user chosen number and type of parameters we can use vector as the implementation of the collection class in implementing the subject class we talked about we will focus on implementing the notification method which is the function call operator therefore we leave the callbacks data member public for simplicity defining the special case was not a big deal but once we want to generalize it we're getting to be trumped prior to c plus plus 11 we had no good solution to provide a generic implementation there are several bleeding points in our simplistic class and you can't see them providing variative arguments to the class and the function call operator was a great challenge no good solution was provided the only solutions available were had hard tricks and micros and greedy micros that most of them were not portable moreover overuse of pre-processor was not satisfactory eventually mainstream providers took their own directions microsoft actually implemented the feature as a chord basic type using a non-standard keyword named delegate on the other hand cutie chose the path of code generators code generator is actually an extension of c plus plus preprocessor with more abilities and customized capabilities cutie calls its preprocessor or code generator meta object compiler or contracted as moc mark in this snippet q object and q signals are too cute you have qt macros that the meta meta object compiler uses to inject its generated code the pair of an object and its signal function pointer serves as the identifying handle for the actual subject and the observing objects must register a member function on this subject but none of these solutions satisfy the library developers these solutions lacked extensibility and scalability this was the ground on which that gregor made his revolutionary proposal in this slide you can see some major library utilities using very addict templates in their relative impactfulness order integer sequence library emerged a bit late but it made the implementation of other libraries much simpler it made the non-recursive implementation of these libraries possible which led to shorter compile times purple was a successful fundamental yet growing library a variant library took a very long journey before adoption into the standard library institute function was one of the major reasons for adopting the verity template proposal it is a very elegant and useful library but i usually think twice before recommending it to newbies because of its memory demands stood pint is another useful library which is normally used in conjunction with three dispute function it's a very well defined library but the cryptic message is when an error is detected it's a major problem the reason is the problem with constraining such variety templates functional programming finally the boost signals library is the implementation of the observer pattern we were seeking one of the major contributors of this library is the original proposal of the very big templates proposal although the boost signals library covers the agenda that we were following in our simplistic example we will still push a bit more on the example for the sake of illustration we want to show how to use the syntax and semantics of variety templates the generic definition of our event handler doesn't do anything functional are useful it just provides a default value for the second argument which will be the only acceptable value for that argument of this template and that argument is a function of the given signature the specialization actually implements our class using the readable syntax of periodic templates we can see the usage of parameter packs and pack expansions in this implementation since we are not going to use the return type of our functions this implementation is rejecting the non-void functions through the static assert c plus plus 17 version is just a bit better optimized in terms of compiling because our values are not good arguments for our signature because our values are single shot by nature but we are going to use our parameters several times passing them to multiple observers stored in the vector so our values are not good candidates and signatures that use r value arguments are not acceptable eventually this class will fail with signatures that have r value arguments but we want to get a fast fader in such cases so that compilation stops faster finally we can instantiate our event handler class we are targeting functions accepting one single integer and returning nothing we can use a function with exactly matching signature or we can decorate non-matching signature functions using the bind library the bindfront utility is actually a c plus plus 20 extension but there are workarounds that can work with previous versions of the standard we will keep point front because of its simplicity we can use the bind library to decorate member functions too in this example we have bound an object and a false value to the extra parameters of the update function from the observer class this update function is actually incompatible with the signature we were targeting but with both we but using the bindfold function we have actually decorated the type of dysfunction we will be in trouble if we change the type of elements stored in the collection class of our event handler if we change the element types from standard function to an ordinary free function pointer we will face compilation failures actually the only case that compiles is the exact match signature free function pointer we used in the first pushback we cannot add any other forms of functions to our event handler class we have last generality using the function pointer syntax that's because function pointers are not institute functions we will see different kinds of functions in c plus plus in the next slide the stood function is capable of erasing the types of four general classes of columns the first type is free function pointer the c style function pointers as we have discussed earlier these type of pointers can be stored in the memory required to store a single void pointer one way or another through casting to white pointer or not we can find a way to store this type of columns in a single void pointer the next class is the instance member pointer instance member pointers are entirely different pists from the previous species these kind of pointers have a size depending on the defining class their size depends on the hierarchy of the class they're defined in they're not castable to void pointers neither are they castable to static function pointers the next class is user defined function objects these type of classes are signified by the existence of function call operator in the class a specific case of function objects is the lambdas these type of classes can be cast to void pointers if the capture list is empty actually they can be casted to function pointers and then to avoid pointers because of empty capture size the last input to the stud function is the self-type this type of functions normally needs more than five times the size of a normal void pointer as memory however on some platforms i have seen twice as much as this number that is i have seen platforms where storing a stood function takes 10 pointer sizes there are design decisions behind this size and we will explore some of the obvious ones in the upcoming slides and again this huge size is one of the reasons i hesitate to recommend stood function to new programmers because the memory demands are generally too high the student function is supposed to store two items first it should store information about type eraser that is it should remember the type of the object is storing so that it can call the function call operator or other functionalities necessary when the user demands there are two ways to implement this functionality the traditional way is through using a virtual function and the hierarchy of classes the second way is the way that stood and used to type erase its store objects stored objects this strategy doesn't need the virtual keyword doesn't use the traditional oop style polymorphism and can be beneficial in some embedded environments or environments where using the rtti or virtual keyword is prohibited or restricted or there are reasons to not use it again type eraser without rtti can be achieved through to strategies we can store a pointer to metadata function or a store pointer to metadata structure whichever is more efficient on our platform or uses less memory the second item stored in a stood function is the small value optimization buffer and as with many other stood classes this class 2 uses small value optimization these buffers should be large enough to hold the most obvious cases of usage of stood function for example a free function pointer with exactly matching signature should not be put on the dynamic allocated memory it can be stored in the small value buffer another example is binding a member method to its to its object via reference this is a very obvious case especially for programmers coming from other languages a third case is binding a shared pointer to a function pointer for this case actually we don't have the library facility needed we don't have the direct function in the in the in the standard library the derived function is a function that i wish i had in my library tools to bind a smart pointer to a function or a member function because we sometimes need to worry about the lifetime of the object we bind to the function now we are going to review the list memory demanding category of caller built in c plus plus but before that we should take a look at mono state category of classes instances of a monostate class do not carry object-specific data and all the instances of such class are equivalent therefore such a class is not supposed to have instance data members or virtual functions this means that such classes should satisfy the conditions of empty classes in c plus plus and trivial classes that is their special member functions must all be trivial and none of the member functions should not should need to use the this pointer empty capture lambdas act very much like a mono state class instance specifically these type of functions do not even have a disk pointer to begin with the user also can define classes which are most mono state and function objects that is they both have a function called operator and they have no data members and they have no virtual members and don't use the this pointer it is simple to wrap the call to any function or member function inside a mono state function either an empty capture lambda or as an user defined function object class can we have a generic wrapper for the call to any function pointer or member function pointer the answer is yes we can use a template variable in c plus plus 14. i call that template variable mono state from overload these template variable needs that type of a function pointer or member pointer as well as its name as its parameter c plus plus 17 enables us to use the deduced non-type template parameter so long as the function is not overloaded we can create a mono state function from that function through use of the mono state from template variable by passing the function name to this template variable so in short words we can use the monostat from templates variable for functions which are not overloaded and mono state from overload to disambiguate overloads for overloaded functions thus you can see that we can reduce the memory requirements of storing function pointers and member pointers to zero because the monastery trapping of the functions and member methods is empty we can type erase mono states functions of a specific signature in two ways we can define a template function that converts the mono state function into a function pointer of that specific signature this method has the habits of generating uob because it's possible to forget to initialize a function pointer or invoke a function pointer which is set to null pointer we can also define a short function class which is capable of type erasing and storing any mono state function since the mono state function is an empty class this short function is not supposed to store any data about the specific object it only stores the eraser data about the type of the function therefore it is no more expensive than an ordinary function pointer in terms of memory but it also has the advantage that it can be defined so that it doesn't generate any sort of uob or exceptions because as a class we can prevent it from having a random uninitialized state and we can have this class to default construct the resulting value in case of a call to an empty function object that is if the short function is default constructed and is in the empty state and and an invocation request comes the short function can return a default constructed value if the return type is not default constructible then the short function class cannot have an empty state and cannot be default constructed and trying to default construct short function for such signatures will result in a compile error that behavior is well defined no exceptions no uv generated due to the definition of such class we can use function pointer literals or member pointer with laws to the short function through user of previous dimension mono state from and mono state from overload template variables that is a short function can actually store function pointer or a conversion of the member function pointers the signature of stored mona state function is not supposed to be exactly the same as the signal specified for the short function can store any monostatic function provided that distort mono function is actually invocable with the rpms required for the signature of short function and its return type is convertible to the return type of our signature as mentioned earlier this short function class removes any windows to generating uv through calling any member of the short function if we have to use a short function to a class that doesn't that doesn't provide a the first constructor for its return type and we need to have a to have one empty state we can use the optional standard library class as mentioned earlier the memory demands of a short function is no more than a void pointer it is easy to define a conversion function from a short function to a pointer to its signature since a short function can be initialized from a function pointer literal and can be converted to a function pointer it can safely replace the free function pointers used in old codes this class is less generic than stood function it can handle fewer cases it only accepts honor state functions as its inputs but at the same time it is more optimized and less memory demanding than a steady function this class can be used in scenarios where we don't need to capture any data or bind any data to the function next we can define a line function it is a counterpart to the current steady function which is supposed to have less memory footprint in order to achieve this less memory footprint we should let the size of a small buffer and its alignments be controlled by the user code it is better for this class to have default values for size and alignment of its small buffer according to the platform this class is supposed to store any color belts that steady function can store with one set of exceptions that will be mentioned later like short function the line function class should not be source of any uv or exceptions that means this class has an empty state only if it's result type has an empty state default construction produces that empty state invoking an empty lung function results in default construction of the result type if we need a line function with an empty state whose result type doesn't have a default constructor we can use a stood optional return type instead because this class 2 can accept compatible signature functions we should prohibit foreign functions and function pointers as inputs to the like function class we need also prohibit bindings of function pointers and member pointers as inputs to the line function class otherwise we might end up storing a null pointer or random value inside our line inside our line function function pointers and member pointers should be fed through use of the mono state from and mono state from overload template variables it is also possible to perform an optimization when converting a short function to a line function that is instead of erasing the type of a short function into the line function we directly erase that underlying monostates function stored in the short function our line function class has the same abstraction level and genericity of this two function so it can replace suit function in most use cases the only difference is that this line function class cannot store direct bindings on function pointers and member pointers as well as directly store member functions and function pointers it needs to store mono state from function pointers and member pointers but that's not a big deal it can handle all cases that the student function does in many functional libraries like stoodmind library we have a problem with the level of abstraction we're dealing with when defining such function objects we normally define the function call operator as generic as it can be i'm constraining this function collaborator is a major difficulty for us we normally use the universal very addict argument list for the function call operator this pattern has the benefit of simplicity and using perfect forwarding to optimize out the unnecessary copy move operations but at the same time it has the downsides of defining unlimited number of overloaded function call operators as well as cryptic diagnostics when an error occurs in the program and also the case of copier lesion which is the newest optimization adopted into c plus plus language is disabled we're gonna need some trades to overcome this difficulty foreign basically provides us with two generic tools one of them is the is invocable trait to test for the invocability of a callable with the set of arguments and the second is the invoke results that gives us the return type of using a collable with a given set of arguments but that is not enough for constraining the functional libraries as efficiently as we need the challenges on defining a properly working trade library includes the level of diversity caused by qualifiers and functions and member functions for a member function we could have more than 16 variations according to existence or absence of cv qualifiers our value air value our value and value qualifiers and the no except qualifier at least free functions are no better than member functions because we have a nameable abominable functions as weird as their prototypes may look and as rare as their use might be that is close to zero they are part of the language and declaring such functions is not prohibited so the trades classes need to consider all these cases which is tedious and a major setback for designing such a trade library but are on unbeatable open source community that boosters have provided us with the color wheel trades library since version 1.78 it has a bunch of useful tools inside it the two that might catch my eyes are the return type and rxt if a callable or a function or a function pointer or a member pointer as one single function called operator which is not overloaded then return type gives the return type of the function given its type no more arguments needed under the same condition the x t gives the trooper love all arguments a function needs basically this tupel is the tuple that can be applied to the function or callable there's more to this library but these two tools are sufficient to show the elegance of this library in order to avoid a complex pattern whenever we need to define a generic function object class we can do the hard work inside the function based crtp class this class defines the unit function call operator that accepts the exact set of parameters as the collie of the function this crtp based class also can define the traits necessary or related to the signature of our function the function call operator of this base class eventually forwards the parameters to the invoke member of the drive class they're doing invoke member of the drive class can be an ordinary generic variety template the function called operator of the function based class chooses the proper version and instantiates it in the drive class we do not need to worry about the signature of our function call operator the task is handled inside the function base crtp class like our event handler sample class this function based crtp class as a generic definition that doesn't do anything special and is therefore disabled with a static assert the actual definition is defined inside the inside the specialization of the class in the specialization of the class we can define the signature of the signature of the function as well as the return type and the argument tuple the argument tuple is the tuple that we can fit to the apply for this function type then we can have the count of the elements and the argument type by index of the argument and of course the unique function call operator that uses the exact signature of the function that we need this operator is supposed to forward the parameters to the doing work member of the drive class which we already have defined as a generic variety template in this implementation we haven't considered the case of const function or maybe r value or l value function call operators because we just need to advance demand a single function call operator if we need to consider all those cases the definition of this crtp class may become a little bit more complicated with maybe extra parameters and we may have to define to up to four specializations or four distinct classes but the basics are just the same as we have illustrated here during preparation for this talk i came to the conclusion that core language could be improved in two ways that helps functional programming first of all we missed the tail hall optimization in c plus plus programs as we know copy origin and perfect forwarding or exclusive due to the reliance of perfect forwarding and universal references which are which are in turn instances of references that is every argument of the function is converted to a reference using the perfect forwarding syntax and that prevents copier lesion in cases where it is possible a tail call is actually the combination of both perfect forwarding and copy illusion it forwards the references and edit copy and move if the signature of the kali and the invoker are the same a tail call actually consists of two stages it unwinds and cleans up all the automatic objects created during the execution of the function but keeps the parameters and arguments of the function intact because we need them for the tail call then unconditionally jumps to the target function that we are trying to call via a tail called request in my opinion the tail call request shall need a specific syntax a little bit different from a normal return and i think assigning to the return keyword is the proper way to do it so if we could device such as syntax we could ask for a tail kind in our generic function object libraries next i discovered that the context for every veridium in standard library can actually become problematic in some cases because the context per keyword put the top level cost on the return of the function it defines and if the function is a forwarding or a generic function like invoke or apply for what's its parameters to the actual quality then the return type is actually changed to the const version of itself this is specifically problematic for return types that are non-const references by adding the cons to size references we will fall into trouble and we have to play some roller coasters to cast them back to their mutable states the solution can be to define two overloads for the invoke or apply functions or functions like them but since the implementations are similar that would lead to code repetition in order to avoid that code repetition i think the best solution is that the const expert itself becomes a conditional keyword just like the explicit and no except keywords so that we can rule out the cases that we don't want the function to be constable inside the condition here you can see a summary of what i wish to see in the future of the functional programming with c plus plus i would like to see a syntax for tail call requests that can optimize the definition of our generic functions and we can make the context per keyword conditional just like the explicit or no except keywords which makes our generic code more flexible we can have a derf function that enables us to use bind libraries with pointers to parameters of functions that is we can bind functions to smart point pointers of their parameters and manage the lifetime of bound parameters by using correct smart pointers alongside the uf function and we can have the function base crtp class for generic function libraries that simplifies defining a unique function call operator with exact signature and provides the traits for our functions we can have a mono state farm template variable that converts its only non-type parameter which is a function void pointer or a member pointer to a mono state empty trivial function object that can be used to optimize memory usage of functional libraries we can use monostat from overload instead of the mono state from in cases where we have a if we have an overloaded function or member function and we can disambiguate the overload using the type of the function pointer as the first argument to the mono state from overload and the name of the function pointer as the second parameter and we won't need to use the casting and casting syntax foreign we can have a short function class that erases the types of all mono states functions or trivial empty functions and can accept any trivial empty functions as its inputs it can be a good replacement for traditional freestyle function pointers in c plus code and we can use a line function template as a successor replacement for stood function which enables the user to customize the size and alignment of its small buffer and the only difference the only functional difference with still function is that this line function doesn't allow naked function pointers or member pointers or their bindings as its input it should use mono state from or bindings of instances of mono state from variable template instead in order to avoid exceptions generated from null pointer and traditional empty state management thank you for being with me up to this point i'm ferried from iran and i'm very lonely and alone in my journey with c plus plus here so what i've done so far made maybe very far from perfect because i'm too alone i need pals to help me fix my mistakes i need some mentors to tell me whether or not i'm in the right direction or which direction i have to take in developing c plus plus libraries then i need peers to constantly correct my errors and give me hints about the bugs in my library and in my efforts i also need some friends that can help me document what i've done so far or what i will be doing because i'm really terrible at expressing what i think and what i do so i need people with experience and ability to help me create correct and understandable documents about what i do my gmail address is gmail.com and i'll be happy to hear from you thank you for being with me have a good time