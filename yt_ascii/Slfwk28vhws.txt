hey guys welcome back to another low level learning tutorial today we're gonna be talking about shared object libraries in c by the end of this video you'll know what a shared library is why do people use shared libraries and at the end you should know how to make one yourself before i forget if you haven't already please hit the like button hit subscribe i put up videos every week learn something new and keep your mind fresh by going into a new low level learning topic so we're going to start out with what is a shared object right a shared object or a shared library those terms are interchangeable or a dot so file in linux is an elf file that contains pre-written code for your program to use the most common library you've probably already heard of and used maybe without knowing it is libsy libc is a library that contains the code that provides the basic functionality in the linux posix programming environment right you need libc to do pretty much anything on linux so a good example to explain shared objects would be to look at this hello world code we've written so the programmer me uses the printf function but doesn't have to write the code for printf or even define it i don't say anywhere into printf right it's just it's just there where does printf come from what was actually happening is under the hood your code makes use of libc libc makes available to the programmer or when you're talking about libraries it's called exporting it exports the printf function so that you can use it in your code without using the libc library you would not be able to use printf because you don't have the instructions in your code to execute the printf function right so when you compile this code the compiler at link which means when it looks for libraries attaches libsy to your program right and we'll explain a little more in depth when we get to programming a library how that works the next question becomes why why do it this way right why would you want to make a shared object that sounds pretty complicated there's actually a couple of really good reasons why people over time have evolved and use shared libraries at large right so step one or i guess problem one that we're solving is disk space preservation right so let's say in the previous example for printf every time you wanted to use printf functionality like you're trying to print something to the screen instead of using a library like libsy you wrote printf into your program manually you defined a program called printf you wrote the code and each time you wanted to print something to the screen you had to rewrite that function well when you compile your program each time that you would compile it and write that code to disk you would have another copy on disk of the printf function over time as you wrote more and more programs every program that had printf in it would balloon you know the the used space on your disk so instead if you write it into a library the printf function exists in one location and you don't have to you know have your your disk be eaten up by thousands of copies of the same code and this goes for ram too right so at runtime if i'm if i'm running 30 different programs that all make use of printf you know that code if i statically compile it if i don't use a library will exist 30 different times in ram which will eat up all my ram if i use a library there's actually functionality in the linux kernel to allow libraries to use the same ram for 30 instances of a library so you're actually preserving ram in this method and then finally ease of maintenance right so let's say that in your previous example you wrote this printf function you compiled it hard coded into your program 30 different times and then you realize that your printf code was inefficient and you wanted to modify it well to modify it without a library you would have to go to your program source code change the make the change that you want to make and then recompile every program separately very hard to maintain very inefficient as opposed to the library method where if you wrote it into a library you would just change the library recompile it as a library and then every program would use it and you'd only have to make one change in one location so those are at a very high level the reason why people use shared libraries it just makes things more efficient less size and easier to maintain in the long run so finally we're going to go into how do we make a shared library right so to do that we first need to really talk about how gcc works right how we go from source code so you know this example to an executable with regard to the link process so what a lot of people don't know about gcc is actually when you compile your code you're going through this two-stage process you're going through first a compilation process compilation is a process of bringing your c code your human readable c code down to assembly or machine code right and what it does is the compilation process outputs this intermediate artifact called an object file and in this case somewhere that you don't get to see based on my flags you produce hello world.oh and if you consider this code right hello world relies on the printf function so we are left with this intermediate object that has this little tag on it that says hey at some point i'm going to need printf and then once all of the object files are created the gcc invokes the linker and begins the linking process and what the linker does is it goes through all of the libraries the linker knows about and it looks for a library that exports printf right so eventually the linker will locate printf in lib c and it says oh okay cool the intermediate object required printf libc exports printf that's a good one for one match now i'm going to tell the loader that every time you run hello world you need to bring up lib c otherwise we won't have all of our symbols resolved right and then you eventually get the final executable elf cool so now that we understand at a very high level how linking works with regard to libraries and what we're kind of looking for we're going to define a spec and we're going to develop this library called my math and my math is going to export two functions my add and my subtract let's let's dive right into the code i've written no code so far we are starting completely from ground zero so let's let's get into it so let's make our function that is going to invoke this library right so we're going to write main.c and we're going to include standard io and we're going to say that there are two functions my add which takes into a and int b and my subtract oops subtract into a and into b and we're going to say that the function itself says that one plus one equals the result of my add one plus one printf one minus one equals percent d my subtract one return zero obviously this is a very contrived example right like if you wanted to do this you would just use the add and subtract operations but what i'm trying to convey is the idea that you can expose functionality in a library so let's compile this and what's going to happen is we're actually going to get an error because the compiler or the linker rather doesn't know where my ad and my subtract are and we can actually look at the compilation output of this so we're going to output the main intermediate object and there's no errors there right and we can see with nm on main.o that main.o relies on a few symbols so there's a symbol main in the text section that's its own symbol but there's also three unresolved symbols that we don't know where they live printf like we talked about in the example will come from lib c but it doesn't know where this my ad and my subtract are right because we haven't produced it yet so we need to write that library so we're going to make a new directory call it my math that's going to be our library and we're going to write it so we'll call it vim mymath.c we don't really need to include standardio here but we're going to anyway and let's let's define our functions so the function we talked about was my add which takes into a and into b and it returns a plus b and then my subtract into a int b and it returns a minus b great now how do we go from the c to a shared object that other programs can can use right it's actually really easy just a few gcc flags so we say gcc tac o and we have to call this there's a there's a spec for libraries where they have to start with lib so it's taco lib mymath and they have to end in so if you don't do both of those things the linker won't know how to search for your library so we have to output it as that name we have to say fpic which means we make the code position independent right so it can be loaded anywhere in ram at run time tak shared so it's a shared object and then finally the code we want to compile so mymath.c great so we've produced libmymath.so and we can look at it and it is a 64-bit shared object rather we can do the same thing we can mnm on it and we will see that it exports these two symbols it exports my add and my subtract great so now we need to use this library against the compilation of our main program right so let's move this back directory cool so we've been given this library right we need to write some code yeah we need to write some code that uses the my math library we've already done that it's in main so we are going to use the my ad and my subtract functions from this library and the way we do that is with a couple extra gcc flag it just made things easy i'm going to rename because i don't trust the underscore i'm going to move lib mymath.so to lib mymath.so right so we did that so great so to do the compilation process we have to do a few things the first one is to run the compilation so we need to produce compile main.c and output our main.o intermediate object right that's step one step two we need to link main.o against our library so that is done by doing gcc tac o this is gonna be our output program we're going to produce it from main.o we need to link it against the library math remember i said before the lib at the front and the dot so at the back are assumed so you just say you want to link against m my math or math and then finally you need to tell the com the linker where to find this library and we say that by saying it's in the current directory so we say the we could say dot too that should also work great so now we've produced main and we can look at main and look at the dynamic symbols and we can see that main is a program that depends on my ad and my subtract and we could do ldd on main and you can see that it's looking for the library mymath.so and libc 6.06 you'll see right here we actually the the loader right now doesn't know where to look for lib mymath so if you actually try to run the program you're going to get this error that says error while loading shared up shared libraries libmymath.so cannot open the shared object no such file or directory and the reason that is because the ld library path is not set and by default it's user lib user share lib user lib share so we need to specify as an environment variable to our program that ld library path equals here and then run the program and what that's going to do is that's going to enable the loader to look in this directory first for all required libraries it will encounter this library and then we can run our program sorry no dollar sign there great see so what have we done right it ran our program it used our library functions and it said that one plus one equals two one minus one equals zero math so what is the takeaway here right we are able to very easily and very rapidly write code in a way that is more ram efficient more disk efficient and in the long run will be easier to maintain and make our projects less spaghetti code like if you enjoyed this video please drop a like hit subscribe i drop a new video every week and keep on learning have a good one bye