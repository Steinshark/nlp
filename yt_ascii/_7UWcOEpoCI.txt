the rise of worse is better by richard p gabriel of lucid incorporated this feels like are we gonna get lisped do you like the coloring of this article what the hell is this okay i think i think this one's better what do you guys want some light turned brown or p yellow i think i'm gonna go with turd brown it's just easier on the easier on the old eyes the rise of worse is better i and just about every designer of common lisp and cloth has had extreme exposure to the mit stanford style of design the essence of this style can be captured by the phrase the right thing to such a designer it is important to get all of the following characteristics right simplicity the design must be simple both an implementation interface it is more important for the interface to be simple than the implementation see a really good statement this is a great [music] i stream on windows and when i receive a slack message from my boss it makes that sound flip can you take the previous port out can you take that i don't want people to not use windows okay because if they know i use windows you know how many stupid comments i'm going to get in the youtube section flip if you don't take this out it's gonna be like oh heels as windows he won't dye his hair blue oh he uses windows where's the blue mustache prime shin hey prime gen when are you gonna dye your hair blue hey well you use windows what a rookie i use arch by the way the design must not be inconsistent let's probably just say it the other way a design is allowed to be slightly less simple and less complete to avoid inconsistency consistency is as important as correctness okay i i can buy that completeness a design must cover as many important situations as is practical all reasonable accepted cases must be covered simplicity is not allowed to overly reduce completeness oh these are actually really okay so this is probably the greatest definition i've ever seen for things you should consider when writing a library right this is like the best advice i've i've heard of for writing a library i love this i love this i believe most people would agree that these are good characteristics yeah i will call this use i will call the use of this philosophy of the design the mit approach common lisp with klaus and the scheme represents the mit approach to design and implementation the worst is better philosophy is only slightly different simplicity oh interesting okay it's like it has the exact same it has the exact same names in the same order but different the design must be simple both in implementation and interface it is important for the implementation to be simple to be simple than the interface simplicity is the most important consideration in a design correctness the design must be correct in all observable aspects it is slightly better to be simple than correct consistency the design must not be overly inconsistent consistency can be sacrificed for simplicity in some cases but it is better to drop those parts of the design that deal with less common circumstances than to introduce either implementational complexity or inconsistency completeness the design must cover as many important situations as is practical all reasonable expected cases should be covered completeness can be sacrificed in favor of other quality in fact completeness must be sacrificed when other whenever implementation simplicity is jeopardized consistency can be a sacrifice to achieve completeness if the simplicity is retained especially worthless let's see especially worthless is consistency of interface the worst is better philosophy i wonder where he's getting this philosophy from right because in some aspects i see some modern web design in this one but i also see a lot of modern web design in this one earlier unix and see examples of the use of this school of design and i will call those use of this design strategy the new jersey approach new jersey kids it's always them new jersey kids you know it's always ken wheeler that that can wheeler i have an intentionally caricatured the worst is better philosophy to convince you that it is obviously a bad philosophy in that the new the new jersey approach is a bad approach ken wheeler however i believe that worse is better even in straw man form has a better survival characteristics than the right thing and that the new jersey approach when used for software is better approached than the mit approach okay this this has gotten interesting okay okay let me start out by retelling a story that shows that the mit new jersey distinction is a valid and the proponents of each philosophy actually believe their philosophy is better two famous people the one mit and the other one from berkeley ethan berkeley sockets but working on unix once a mets to discuss operating system issues the person from mit was knowledgeable about it's its the mitai lab operating system and had been reading the reading the unix sources he was interested in how unix solved the pc losering a problem the pc losering problem occurs when a user program invokes a system routine to perform a lengthy operation that might have significant state such as i o buffers if an interrupt occurs during the operation the state of the user program must be saved losering what a loser get in loser we're going losering it's because the invocation of the system routine is usually a single instruction the pc of the user program the program counter i assume is what they mean by this of the user program does not adequately capture the state of the process the system routine must either back out or press forward the right thing is to back out and restore the user program program pc to the instruction that was invoked the system routine so that the resumption of the user program after they interrupt for example re-enters the system subroutine it is called pc losering because the pc as being coerced into loser mode where loser is the affectionate name for a user at mit okay okay losers let's go to mit get in loser we're going to mit the mit guy did not see any code that handled this case and asked the new jersey guy how to the problem was handled the new jersey guy said that the unix folks were aware of the problem but the solution was for the operating for the system routine to always finish but sometimes an error code would be returned that signaled that the system routine had failed to complete its action a correct user program then had to check the error code to determine whether to simply try the system routine again the mit guy did not like the solution because it was not the right thing the new jersey guy said that the unix solution was right because the design philosophy of unix was simplicity and that the right thing was too complex besides programmers could easily insert this extra test and loop the mit guy pointed out that the implementation was simple but the interface to the functionality was complex the new jersey guy said that the right trade-off had been selected in unix namely implementation simplicity was more important than interface simplicity i think i see now i understand more user versus not arch user the mit guy then muttered that sometimes it takes a tough man to make a tender chicken but the new jersey guy didn't understand i'm not sure i do either i think i'm gonna i'm gonna try to use this at everyday talk and see what people say what this article is riddled with platitudes i think i see what they're trying to say here now i want to argue that worse is better is better c is a programming language designed for writing unix and it was designed using the new jersey approach c is therefore a language which is easy to write a decent compiler and in required requires the programmer to write text that is easy for the compiler to interpret some have called c a fancy assembly language both earlier unix and c compilers had simple structures are easy to port require a few machine resources to run and provide about 50 to 80 percent of what you want from an operating system in programming language fair and half of the computers i mean audio working is not one of them that ever works on any machine i've ever used in my lifetime half of the computer is that exist at any point are worse than median smaller or slower unix and c work fine on them the worst is better philosophy means that implementation simplicity has the highest priority which means unix and c are easy to port on such machines therefore one expects as if let's see that if the 50 functionality unix and c supports is satisfactory they will start to appear everywhere and they have haven't they unix and c are the ultimate computer viruses i mean you know a further benefit of the worst is better philosophy is that programmers programmer is conditioned to sacrifice some safety convenience and hassle to get good performance in modest resource use programs written using the new jersey approach will work were will work well both in small machines and large ones and the code will be portable because it's written on top of a virus this is the saltiest lisp programmer i have ever read in my entire lifetime it is important to remember that the initial virus has has to be basically good if so the viral spread is assured as long as it is portable once the virus has spreaded there will be pressure to improve it possibly by increasing its functionality closer to 90 but users have already been conditioned to accept worse than the right thing therefore the worst is better software first will gain acceptance second will condition its users to expect less and third will improve to the point that it is almost the right thing in concrete terms even though lisp compilers in 1987 were about as good as c compilers there are many more compiler experts who want to make c compilers better than to make c of the lisp compilers foreign this is a great this is a great statement by the way everything that was just said right here this was a great statement okay this is great the good news is that in 1995 we will have a good operating system and programming language the bad news is they'll still be they'll still be unix and c plus plus what foresight this guy has this is great this will this is there is a final benefit to the worst is better because a new jersey language and system are not really powerful enough to build complex monolith software large system must be designed to reuse components therefore a traditional a tradition of integration springs up how does the the right thing stack up there are two basic scenarios the big complex system scenario in the diamond-like jewel scenario did this guy predict micro services this article is from 1991. 1991. and he's over here just giving us facts about our day today what the hell's happening here dude okay you know how sometimes people say you know the previous generation was better and that the modern generation lacks blah blah blah blah yeah well okay in this case they might be right because this is incredible the big complex system scenario goes like this first the right thing needs to be designed then its implementation needs to be designed finally it is implemented because it is the right thing it is nearly 100 of the desired functionality and implementation simplicity was never a concern so it takes a long time to implement yeah this is waterfall and why waterfall is always really really hard it is large and complex it requires complex tools to use properly the last 20 takes eighty percent of the effort and the right thing takes a long time to get out and it only runs satisfactory on most sophisticated hardware this is an incredibly great statement it is yes the diamond like a jewel scenario goes like this the right thing takes forever to design but it is quite small at every point along the way to implement it to run fast as either impossible or beyond the capabilities of most implementers two scenarios correspond to common lisp and scheme the first scenario is also the scenario for classic artificial intelligence software the right thing is frequently a monolithic piece of software but for no reason other than that the right thing is often designed monolithically that is the characteristic is happen a happenstance the less lesson to be learned from this is that often undesirable to go for the right thing first it is better to get half of the right thing available so that it spreads like a virus once people are hooked on it it takes time to improve to the 90 of the right thing [applause] i mean honestly this is like an incredible statement man invent he clearly predicted i mean he he's predicted react he's predicted zig he's predicted rust he's predicted like every like this is how it works a wrong lesson is to take the parable literally and conclude that c is the right is the right vehicle for ai software the 50 solution has to be basically right and in this case it isn't but one can conclude that the lisp community needs to seriously rethink its position on lisp design and i'll say more about this later why is ocamel coming back oh camel's in a great spot oh camel is really in a good spot people are starting to desire more functional programming languages it's becoming a very mainstream thought to think more functional and javascript is just not a functional language i know we want it to be it has all the appearances of being functional but it's just a garbage fire underneath the hood and rust has all the appearances of being functional while maintaining extremely high brows dislikes the common person and has a borrow checker that sometimes becomes really frustrating but ultimately writes really nice software so oh camels like this weird middle ground where it is functional it feels like rust in some aspects and it's even getting things about rust like lifetimes but they're really really simple lifetimes they cause really really simple items and it actually just is is shockingly good so i think oh campbell is truly making the greatest resurgence because it is one of the most it it somehow meets all the things and i want to dive significantly deeper into it but we'll see what happens the name is maybe the worst is better because it's kind of like a virus again