as soon as you start writing concurrent code there are a lot of potential issues that you can run into related to delays and timeouts deadlocks etc etc now one way to make sure that your asynchronous code your concurrent code is a bit more robust is by also making your test asynchronous so that your test actually take that aspect of your code into account so today i'm going to show you a couple of ways in which you can do that now before we dive in if you want to learn more about how to review code and detect problems faster in your code check out my free workshop on code diagnosis by going to iron codes diagnosis it's a 30 minute workshop with lots of practical tips using actual production code some libraries that you may even use yourself in your projects so earn c/ diagnosis the link is also in the description of the video in order to write tests for code that is asynchronous i created this little example it's a main function that uses ioh http and it uses a function fetch event that gets a session and an event id sort of simulating a database and then printing the information about the event and fetch event does nothing more than simply reading the data it does that asynchronously so i just added some sleep to kind of simulate interacting with the database which you will typically want to do asynchronously and then fetch event uses that function so when i run this main file then this is the result that we get titled description and a location and that's coming from these print statements right here and this is all done with the asyn koo package which which is python's built-in package for handling concurrency now before i start showing you some tests just to recap what async and concurrency actually is so async koo is python's built-in library to write concurrent code that also use the async and a weight syntax that's exactly what you see here so if you want a function to run concurrently you write a sync in front of it and if you need need to wait until some task is completed before you can continue then you use the await keyword so it's a pretty straightforward way of writing your code and to be clear this is something else than parallel code where you have multiple processors doing things in parallel concurrency really means that you're allocating your resources more effectively and your especially if you have io bound things like for example you need to wait for a server on a network to respond so while you wait for that request to get a response you can then do other things that's what concurrency is and it can save a lot of time because instead of waiting for one request to resolve and then doing the next one you can send them out concurrently and then you get the results all at once which is overall a lot faster when i write python i'd like my test to be simple that's why i like to use py test because it just allows me to write test functions and it has a lot of functionality for fixtures mocking and things like this now the main issue with asynchronous code is that you need to have an event loop in which you can put tasks that are executed asynchronously and you can do this in two ways either you can use a fixture to build that or you can use a plugin that does that work for you here's an example of how you could test a synchronous code using a fixture so i have two fixtures here one that creates a mock ictp client session and another a fixture that creates an event loop so you see that it creates the loop here and it use it and then after that it also closes the loop again and then when you write your test you can see here an example of what that looks like we have test fetch event so that gets them the fixtures the client session and the event loop and then we can call run until complete on the event loop and then inside that call the actual function that we want to test which is fetch event and we pass it the session so that it can handle the actual request and finally we assert that the length of the result is larger than zero here's another example of a test function that does multiple fetches using also this same event loop and there we define the tasks which is these various fetch event calls for the various event ids and then we do run until complete for asn ko. gather of all these stu so these will then run concurrently so this makes sure that when we call these functions that we actually await the results and make sure that it has the value that we expect it to have so that's when you use fixtures basically what you do now is sort of create the async testing framework yourself from scratch using existing unit testing features from byest now this works but it does make your test look a bit complicated because you have to call event loop. run until complete which makes it sort of hard to understand what is happening exactly so another way to do this is actually using a plugin that does that work for you for py test there is the py test a syo plugin that you can use for this and if you do that then this is what it looks like so with py test a syn we don't need this extra fixture here that creates the event loop for us that's exactly what the plug-in does for us so we have our same test fetch event function that we had before as well and in order to let it test asynchronous code we just need to add this decorator pest. mark. async iio we can write the async keyword in front of the function just like we would do with actual concurrent code in our python scripts and then we can use the weight keyword to call function so here we get two events and we await the fetch event call and then we can add a search to our test function and this is a very natural way of writing asynchronous unit test same here we have test fetch multiple events we simply mark it as an asynchronous test function at the asyn keyword in front of it and now we're using asyn k. gather which runs these things concurrently and then we can simply add our assert statement to check that what we got actually was what we expected so this is a much simpler way to do it and typically i would recommend if you need to write a test for a synchronous code that this is how you do it using this plugin because that way you don't have to write your own event loop fixture now small disclaimer the pest acn plugin currently doesn't support the latest version of pest but i'm assuming that they are working on this and that it's going to be released pretty soon until then you can still use the fixture based approach but you'd have to create your own event loop fixture so i hope this video gave you an idea of how to write test for your concurrent code if you want to learn more about concurrency and the async ao package i did a video a while ago where i explained the package in detail you can watch that right here thanks for watching and see you soon