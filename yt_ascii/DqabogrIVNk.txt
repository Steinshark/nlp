so yeah we have done this autometer we have done in in python and now we have this ambitious project to do regular expressions in python which is quite a useful little exercise because running regular expression is actually like grab the the unit command which we have mentioned is is sort of a useful application we have done deterministic finite autometer dfas and nfas and we have looked at translations in both directions and we've done this in python beautiful enough and then last session we looked at regular expressions and we have just done them on paper and now today we're going to do them in python okay let's not look at the definition of regular expression which is here so let's not look at it yeah but let's look at an example here's an example regular expression which is sort of our running example so what's the idea so it starts starts with b plus epsilon as b or nothing and then there is a sequence of a bs and then there is an a or nothing and basically what this is it's a sequence of a's and b's always interchanging yeah i mean you can have just an a you can have also nothing it's also okay so these are the words this is the language of this regular expression so now the first question is how do we represent a regular expression what is a regular expression so what's an expression actually so we've done a video about this arithmetic expressions and there are trees if i turn this this regular expression into a tree that's what i get yeah i wrote a pent for the sort of invisible just one after the other which is make explicit here i call it a pent then there is this plus star operation and down there epsilons and and symbols and so this tre is a representation of a regular expression now we have have to to have to to turn this tree into into a python object so i'm going to define python classes and since this is a bit much i'm i'm i'm have done prepared this like you know if you if you have these chefs cooking something they prepare some sources so i have lots of prepared sources today because the recipe today is is a little bit involved let's say okay so here i have the find a class of regular expression which is an abstract class so i'm not giving a way to create aular expression but i have subclasses and each of these subclasses correspond to one way of making regular expression i empty is the empty regular expression epsilon we've seen is the the one which is just the empty word symbol is was one symbol plus we have also seen a pend and star these are the ways to make regular expressions and i also have some boiler plate every regular expression can print itself okay and now here i have i have typed in this tree as a python code let me just run this and now i have e1 for e1 is a regular expression and like it can actually print itself as we can see okay cool so we have a representation of regular expressions but what can we do with it we want to run it i want to have a run function yeah here i want for every regular expression i want to have a run function right so i want to have run and it gets a a word and it returns true or false it returns a a bullion yeah so if this word is is an element of the regular expression i mean of the language say yes otherwise said no now there's a little extra thing we have to supply we have to supply the alphabet because that that's an extra parameter so we we want to implement this run function now what's the idea so if you look at this picture again then i indicated that actually regular expressions and nfa have a close relationship in particular there is a translation from regular expressions to nfa to nondeterministic finite autometer and we have already defined the run function for nfas so let's have a quick look at nfas again we want to implement the run function for regular expression piggy begging on the run function for nfas which we have already defined okay let's have a look at the nfas so that's we have done previously this is very simple an nfa has a set of state an alphabet a transition function set of initial states set of final states and we have a run function which get a word sort of keeps track of the states in which the nfa could be and and at the end it checks whether the set of states and the final states have a non-empty intersection this end here is actually the intersection operator from set theory okay we have two example finite autometer so that's n zero this was the autometer and recognizes that the the symbol before the last symbol is one okay this is n0o i've defined it here so that's basically hacking in this diagram as as a definition of a expression so i can i can do this n z. run and then one z let's say and hopefully it says yes it says yes okay that's already enough and and i have another finite automaton which i call n1 and n1 recognizes whether the last symbol is a one so it has here 0 one it stays in zero but as as soon as the last symbol is a one it goes in in here and that's this i i hack this in as n1 okay this is a two examples of fin autometer which we're going to use in a minute so now back to our regular expressions so we want to define this run function what we're going to implement is this translation i'm going to implement a method nfa which gets the alphabet and returns an nfa so it returns a nona mystic find autom which corresponds to this regular expression that's the idea and and and and once we have this we can implement the run function which gets the alphabet and the word and it returns okay return not red run red run is not right okay it returns it converts itself to an nfa and then runs this on the word okay so still red run and now i can it boils down to implement this nfa function so in the spirit of test driv development i'm going to write some unit tests so first of all write a test function which g a regular expression and the word and now we fix the sigma it prints the expression it prints the word and then it runs the expression on the word and tells you true or false and we do some tests for this this ab example maybe you should also have a negative test okay so yeah so for example the empty ver should be in at a a should be in it ab b should be not in it ab a yes b a b a b is also fine whereas bab aab should be not fine okay so that's that's our test suite right so how are we going to implement so i'm i'm i'm i'm not going to go all the details let's just look at at at some examples okay so let's look at at three examples the empty regular this is too small the empty regular expression the epsilon and the symbol now i have implemented the nfa method which constructs the corresponding nfa but to do this i need to implement some factories which produces produce the nistic finet autometer the nfas is co responding to it okay let's look at these factories i need a factory for the empty nfa so maybe i can draw this what is what is the nfa recognizes the empty language it is yeah definitely an empty language yeah it's the empty nfa but the empty nfa recognizes the empty language yeah okay and and so here when i do this in in python i say out the empty set of states is the empty transition function the empty set of initial states the empty set of final stat that's that's the the empty nfa very very easy so now epsilon what's the epsilon okay let me let me draw some pictures so here this is the nfa for the empty language intentionally left empty now we have this epsilon so this is a little bit more complicated it has got one state which is initial and final so we start here if nothing comes we say yes if something comes we we lose it okay so here also exactly this implementation in python we say okay there is one state and then no transitions the initial state and the final state is just this okay and now the symbol now we have one symbol and we want to define an nfa which recognizes exactly this symbol so so how do we do this oh it's it's we have actually two states initial state and the final state and we have one transition and that is the regular expression a so here i do this we have two states we have sigma as we as as as we get it and we have one transition from zero to sim we have just one consequence one next state which is the state one this zero is the only initial state one is the final state translation so let's let's look at this from the point of view of regular expression so now i'm calling these factories now i have to to do to say this is a class method so i have to say nfa mty nf. epsilon and whatever nfa do symbol okay so we have this un test yeah the empty doesn't even recognize the empty word the epsilon one recognizes the empty word but not the word a the a symbol doesn't say false for the empty string but is true for a it's just as expected okay so now we get to the more interesting one so let me do this plus in in some detail yeah we have to define uh factory which get two automaton builds a new one which recognizes the union of the language yeah so it's it's like know we have to to implement this plus and it turns out on on paper it's very simple so how do we define how do we construct the plus of two regular of two automaton or the automaton which recognizes a word from either language let's see i have here n zero one automatic here and one another automaton and all i do is put it together so here these two i'm just putting them together i have one bigger automaton and this autom will recognize the word either from this language or from this language okay yeah okay so let's do the factory for plus here is a little bit of subtlety because if you look at this automatan so so we want to define this plus plus the factory plus given gets two automat call them a z and a1 or call them a1 a2 and now i need to construct the states of the union aor and the question is how do i do this so i have n zer has got some states 012 and n1 has some states so how can we put two sets together now what's the wrong answer union that's the wrong answer that's the wrong answer so why is it the wrong answer because n0 doq union which is a bar n1 q is 012 is a union but if you look at this picture here we have five states not three and if we if you combine this automatan and and and overlap these states maybe in this example it works in general it will not work because we get into some chaos yeah so there is some some unintended interaction between these automat so i need what's called the disjoint union let me let me just run this and i have implemented it myself but it's not very difficult so i have implemented the method d union so i can now take the disjoint union of two set let's just n the q and1 doq and what it is doing it it it labels the one from the first set with with a false and it labels the element of the second set with a true and then put them together and this makes sure that they're kept separate yeah so this union this this joint union operator is what i then use so i i i have prepared this already okay so here okay for for the alphabets i take the normal union but for the states i take the disjoint union and then i have implemented a little method which can also lift the function the delta to the disjoint union yeah and then initial state final states are the dist union and i get a new automaton and so i can i can now i i can for for example i can do nfa plus of two automaton okay n z and n1 and i get a complicated new automaton which if you look in detail is really a representation of this very simple action putting two pictures together but we have to be take here that everything is kept separate so i can now implement the the nfa method for plus using the plus factory and here there is oh scary thing going on there's some recursion going on because to translate a plus regular expression i now have to recursively translate the sub trees and then plus them together i test plus epsilon a so let's see whether this works so the unit test for plus so if you have a plus epsilon we recognize both the a and the empty word but we still don't recognize a seems to work okay so let's tell the rest of the story we have two more constructors two more yeah two more sub classes here a pen end and star and for each of them we have to find a factory now i'm going to give you the code let's just show how it works so i have to implement a factory for a pent and a factory for a star now let me do this at least on paper how do i do a factory for for a pent so i have one automaton for the first bit let's call it nn1 and one automaton for the second bit and two and i want to run one after the other so i first of all i put them together like for plus i just put big thing around them i put them together but i i only at the initial state for the first and the final state for the second and then here if here is a final state of the first automater and here is an initial state of the second i'm adding a what's called an epsilon transition i can silently go from the end of the first to the beginning of the second so this is n1 and two just one after the other and if you look at this implementation here there are a few things to to comment on but what i'm basically doing is i put these two together then i add the injection of the first set as initial state and the injection of the final state of the second as the final state and then i say for any final state in the first and for any initial state of the second add an epsilon transition and here have a little method what it means to add epsilon transitions to an nfa and star is actually not not very different so you have an nfa you just take it so this n and now we have n star and and and and what we do is we first of all add the empty language so that we not language that's the empty word and then we have to shortcut here from epsilon transition from the from the final stat to the initial states so we add all these lots of extra transitions like we can go around as many times as we like m and that's this few lines of code here and also adding an an epson transition and now going back to the regular expressions okay let me go to my last prepared source so now i have this factory for plus the factory for and i'm using here for pent also recursively translating the expression and for star i recursively translate the expression and then use my star factory and okay i i have the wrong test so that's very bad how that this happen okay let's go to here let's copy the unit test over which i wanted to do let's hope it works okay let's see so here okay oh oh this it didn't work no that's that's a nice thing so here i i i i checked the unit test and the unit test doesn't work it says false for b a b a b and then i realize it's maybe not my code it's i have the wrong test ex sample which i had before let me just copy it from here yeah because it that that's also the wrong one oh okay that's the wrong one everywhere okay so it should it it should it's b plus epsilon yeah and it finishes with a otherwise it's wrong and now i have to change this with b and that's with a this is a problem if you do test based developments your test should be right that's an interesting b test failed okay this time it it seems to work so we have this complicated expression and we what what do we say we say the empty word is true the a is true ab is true abb is false aa is true b a b a b is true and b a b a a b is false so so seems to work so now for entertainment yeah i asked what's the language of this regular expression and now we can resolve the mystery a little bit at least we can play around with it so i have here implemented this expression as a tree as a python expression and now i can run it so it says it says yes for one one it says false for one0 it says also false for 1 1 but it says yes for 1 1 0 and it says yes for 1 0 001 okay starts and ends at one oh no okay everything which end with one you think okay let's see whether this that certainly seems to be justified by so far but if you just had one then it should recognize one right yeah it doesn't okay go then that's that's me go we need more info yeah we leave it i mean i i'm going to okay i'm i'm going to publish this code and then everybody can play around and figure out what is the language i mean there's some binary numbers here right maybe has something to do with binary numbers there's some some property of binary numbers which correspond to this regular expression okay there's a few important properties of hash functions that we care about fortography but the most important one perhaps is that it's essentially pseudo random so that means that we put in abc the literal adding and incrementing and decrementing these counts can become surprisingly punishing in terms of performance