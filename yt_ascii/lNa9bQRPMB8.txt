this is a certificate from the guinness world records. it's for the largest functional microprocessor model which has 42,370 transistors and built by james newman in the uk in cambridge. and this is the mega processor. it's basically a micro processor made purely from transistors. and we're talking discrete transistors, the ones the ones that you can handle, not sort of the ones that are in the silicon chips we know. so it's a fully functional machine. it's made of these panels as you see around the room here. each panel has its own specific function within the processor. so the memory is made of all these little transistors here, as the rest is, but each one has an led on it as well. so the important thing about the mega processor is every single part of the machine, every single gate has an led on its input and output, so you can see all the data everywhere in the machine, and actually how it's working as well. the memory actually kind of then functions a little bit more as a screen. so we have here a game of tetris that's playing on there at the moment, we'll show you that in a minute. so we have the state machine, all computers have a state machine so it knows what it's doing at any one given time. all of the instruction decoding and the branch calculations, all that kind of thing, are done on these ones here. this panel is the special purpose registers. arithmetic and logic control, the alu, again the alu part of all processors. so it has two "adders" in this machine adder 1, adder 2 there. and then the alu control down the bottom. general purpose registers, so as you make a move you would move it to register one, and then out to maybe a special purpose register or memory depending on what operations you're doing. so all of this together forms effectively a microprocessor. so we have a number of leds okay, and you can see these leds are on. but if we focus in on just one little bit here, those five transistors make it an and gate. so all of that lot is just one and gate. and we can see on the two inputs to the and we have one is on, one is off, the output is off. so for an and gate the logic says: both inputs 1 and 2 have to be on. okay, so that's the function, so we haven't, we've only got one of them on therefore the output is off. and this is just multiplied up. the whole system is using this kind of function. and gates, or gates, and xors and various then combination of those. you can use, turn an and gate into an inverter which some of them are done down there. and a microprocessor is just that. what we've got here is a machine that looks like it's not doing very much, it's kind of fairly static. but we have a special control over here, a huge rheostat out of some kind of 40's science film. what we can do, it's actually running at about 19 kilohertz at the minute. but we can slow it down. 13 ... 10 ... 7 kilohertz. and as we slow it down we start to see the leds flickering a little bit. there's a little bit of flicker. so now we're at about 100 hertz and as we come down further ... 10 hertz ... right. and now we're down at about roughly 2 hertz. so now we can start to see the individual instructions being operated. so again, it's running tetris at the moment. it's actually in it's "game over" state. so at first the machine looked like it wasn't doing anything. but when we slow it down we see actually it is doing something. and one of our special purpose registers is the "program counter". so this is the part of the machine that keeps track of what instruction is being executed. [sean] that's the pc there yeah?
[jason] yeah, "program counter". what we've got, we've got the binary: this is what's going on to the computer itself. but for us we've got a little display here that allows us to interpret that a little bit easier. so we can see that the instructions at memory locations 131 to 137 are just going round and round in a loop. so even though the machine looked like it was doing nothing, it's running this little program between 131 and 137. and what that's saying is ... check out the peripheral input, the inputs here. so between 131 and 137 it's just basically saying, "is that button pressed?" so it just sits there in that loop. if i speed up a little bit and i now press that button, our program counter now shoots off. let's slow it down again. so now we're in a different part of memory doing another operation. and you can see on the screen, so if i speed up the operations now, you can see that it's basically very very slowly clearing the screen. so the part of the program that is operating at the moment is just the "clear screen" operation. and i could speed that up, take it up to ... [sean] and now it's playing the game again. [jason] and now it's playing the game again. but again slowing it down, you can see just how long it takes to draw and calculate those pieces. so to update the screen there is a whole load of code that's being operated just to move that piece down the screen. and then we can speed it up, and now we have a kind of a functional game. it is going to slow obviously it's not very playable. and it can look at the inputs. and you can see how the controller here, as we move it, changes the leds. you've got the two inputs there. the button presses cause other inputs, and it is watching those all the time. james newman, the madman that created it, really wanted to be able to shrink people down put them inside a computer just to be able to see how it works. that's really hard apparently. so he scaled up the processor, so allowed us to get inside, it as it were. so the idea is here, that this is an educational thing. this is the best way for anybody to understand things, simple stuff like the "fetch and execute cycle" of a computer. how this stuff works. so this is fantastic because what it allows us to do, if we halt the machine, we can now stop the processor and we can single step through every instruction. so every time we press the step button, we can now see the operations and the data moving around the system. [sean] i'm just going to darken the camera so we can see the leds now but we might not see you. [jason] and it's not necessarily one press per instruction. some of these instructions take a number of clock cycles to operate. so a "divide" could take 16 clock cycles other instructions take less time. but we can see how that instruction is broken up. step it through just to see how that data moves around the processor. you can't do that in any other way. there is no way to get inside a processor and see this stuff happen. i programmed in assembly language on 8031 processors and things like that, and i thought i was fairly low level, you know "programming at the metal" as they say. but actually when you see these things being executed you realize how much extra stuff is going on that even you as a sort of a low-level coder don't even, you're not even aware of it. and it's ... these things work so hard to do the, what seems simple stuff. [sean] i'm imagining this is a processor in some smartphone somewhere. how big do you think the screen would be? [jason] ... ah ... that's ... okay, so that's an interesting question. if this was the memory that you had in your mobile phone today, the average mobile phone with say, i don't know, a gig of ram, this panel as the ram would be twice the size of the united kingdom. so it's fairly low density and fairly impractical. but, you know, you can't see what's going on in your mobile phone. so ... but actually, what we should say that a lot of people just assume this is something like a model of a 6502 or a z80 processor from the 80's. it's not actually necessarily based on any one processor. it kind of uses good ideas from a number of different processors. so for a start it has "hardware divide" built in. it's actually a 16-bit machine as well. so, really it's kind of a ... i don't know, it's hard to equate it. but it's kind of a mid 90's-ish, or early 90's maybe, kind of equivalent processor. so it's really quite a quite a beast when you consider this thing is all just transistors. [ ambient music fades in ... ]