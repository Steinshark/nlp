c's biggest mistake written by walter bright hey walter bright december 22 2009. remember she hasn't changed a lot in the last little bit okay they've added some nice little thread apis but that's about it okay c is arguably the world's most successful programming language i already take offense to this okay i know this was written before rust came out but just think about how much you get to tell people about the fact you use rust right like what is success in a programming language is it a language doing something that's useful or is it the ability to tell people you use the language because like it really in my head haskell's the most successful language ever written because you are able to look down on every other person on earth like haskell's really the pinnacle of all programming languages then you know rust is a really good second you know maybe lisp and rust are kind of tied because in lisp you can be like data is code and code is data and nobody even knows what that means unless if you're already so deep into lisp that makes sense it doesn't make any sense for me i don't even know what it means right and so just a thought just a thought okay just a thought i'm thinking right now all right its success has of course endless tempted people to improve upon it lord that he doesn't even know about zig yet thus c is a probably the patriarch of the longest list of languages notable among these are c plus plus the d programming language everyone loves a little bit of d in their life and most recently go go was in 2009 damn there are endless discussion discussion threads on how to fix c going back to the 80s so this is a well-trod ground what could possibly be added to the soup i posit that most such discussion centered around detail most interesting is what is the largest fundamental mistake we should take into account the context of the times that spawn c the problems it was trying to solve in the environment in which it was intended to be used keep in mind it was developed for 16-bit machine with extremely limited resources available it's a different world right okay y'all y'all running vs code you don't even get to you don't even you don't even have enough an opinion okay you don't even get an opinion on this okay and i did i just see kotlin in the chat when i'm reading a c article okay hey you can kotlin these nuts okay you can kotlin deez nuts if you keep that up buddy all right let's see i'd like to domestic dismiss things like it it doesn't do garbage collection functional programming dynamic typing or oop those aren't problems c attempted to address so the lack of them are not mistakes beautifully written i love that what mistakes has caused more grief more bugs more workarounds more endless hours consumed etc than any other many people would like to say null pointers i don't agree okay he does not think the billion dollar mistake is a null pointer conflating pointers with arrays all right let the man cook would you just just let it let them cook i don't mean them using the same syntax or the implicit conversion of a raise to pointers i mean the inability to pass an array to a function as an array even if it is declared to be an array c will silently convert the array to be a pointer and will rewrite the function declaration so it is semantically a pointer void fuchar is equivalent to void charge car star people called a car star i still call it char star okay why why do i have such stupid opinions in my life why do i think mute mut should be pronounced mute but because it's mutable but char should be pronounced char because it's character why am i wrong why am i right i am right or wrong i'm not sure i think i'm right i think i'm right i think i'm right is it is it jiff or jiff it's jiff everyone knows that okay hypocrite i know i'm just a hypocrite this seemingly innocuous convenience feature is the root of endless evil it means that once a raise leave the scope in which they are defined they become pointers and lose the information which gives the extent of the array the array dimensions what are the consequence of losing this information an alternative must be used for strings the whole reason the zero terminator let's see let's see for an alternative let's say nl oh my goodness an alternative must be used for strings it's the whole reason the null terminator for for the null terminator well i keep thinking there should be more for whatever reason my brain wants more sentence when it gets to this point and i can't have it it just can't have it for other arrays it is inferred programmatically from the context naturally every situation is different and so an endless array of bugs ensue beautiful pun and i agree with this the train wreck just unfolds in slow motion from there the galaxy of c string functions from the unsafe stir copy to sprint f onwards sprint f who doesn't love a good sprint effing is a direct result there's obvious attempts at fixing this such as a safe c library then there are all the buffer overflows because function handles handed a pointer have no idea what the limits are and no array brown's checking is possible i feel like i totally agree with this real talk i first off real talk i feel like i cannot read today like my dyslexia is at the highest it's been in a long time i didn't get great sleep last night because i was up too late and now i feel like i cannot read because i don't know what happens whenever i i don't get good sleep my reading just goes way out the window in my dyslexia just just gets horrifying either way i actually completely agree with this because this was the hardest jump for me going from java to c so at my school when i got when i became a learned man right we started with java programming one and then after that for programming in c the one thing that tripped me up more than anything else wasn't a raise as pointers it was the fact that you couldn't contain the length right you couldn't disambiguate a string from an array even though i mean one can argue that a string is an array i get it not arguing it but it's still it's like one of those but the bound checking i found to be such a disaster and that was always the hardest part other than all the sake faults i got constantly and continuously like i got sick fault after seg fault like con constantly and so that for me that was one of the hardest parts that was one of the hardest parts this problem was inherited inherited in a toto by c plus plus which consequently spawns 10 years of attempts to create a usable string class classic c plus plus eventually the standard string result is comprised by its needs to be compatible with c0 terminated strings c plus plus addressed to the more general array problem by inventing standard vector and many programming guidelines as shoe the the generic t style arrays but the legacy of cras continues in c plus plus with unsafe iterator design c99 attempted to fix this problem but the fatal error it made was still not combining the array dimensions with the array pointer into one type yes the fat pointer was a very good idea which is also like you can use the same concept for typing nums which i really really like like i love the idea of a language to be able to not a typing them but like a type a typed union attacked union like i love the idea of being able to use fat pointers as more of a first class citizen to solve a lot of problems right that's how you can solve the whole length problem on array that's how you can solve also like a tagged union you just have it kind of built into a language in a nicer way and it doesn't suck nearly as much it like takes all the dumb things that i do out of it but let's see but all isn't lost c can still be fixed it just needs a little new syntax oh damn this was suggested in 2009 no way it's actually going to happen meaning an array is passed as a so-called fat pointer i.e a pair of consisting of a pointer to the start of the array and a size t of the array dimension of course this won't fix any existing code but it'll enable new code to be written correctly i love that i would literally love this made by 2109 yeah can now be deprecated by convention and compilers even better transitioning to the new way can be done by making declare declaration binary compatible with older code okay suggesting pre-compiler macros is never like a better this never makes me happy i've never once said hey you know what i want i want more pre-compiler macros you know what i want i would like to be able to conditionally think about my code said nobody ever okay nobody wants to say that this change isn't going to be trans is it going to transform c into a modern language with all the shiny bells and whistles it'll still be c in spirit as well as practice it will just relieve c programmers of dealing with a one particular constant pernicious source of bugs i love this pernicious pernicious i said nacious it's nicest references all this kind of stuff nice acknowledgments for reviewing the draft for this all right this is actually this i i would this does actually seem super cool i'm not gonna lie to you if c got this this would this would really alleviate a huge set of bugs that you just don't need to have because it actually disambiguates the type because in some fundamental way i know we like to treat strings as arrays i mean really they're just memory they're just buffers underneath i get it but there is like this there is a difference between them because they're they just are different so oh no i love this article i think it's a great article uh i always want to love c but every time i use it i don't think i love c but i want to love c like c feels so academically beautiful you know what i mean but practically every time i use it i go i don't like this why am i doing it this way you know what i mean you know what i mean i love c it's a toxic relationship it's abusive every single time i get lured back in by its simplicity and bam hit it with the restraining order quickly afterwards but you know what i will say one thing that's very very important i think i'm coming around to go i think i'm coming around to go i think i am the name is maybe i do love c a gin