this week on developer voices we're looking at the future as we often do but not the future of programming per se we're going to talk about how some very wellestablished ideas in programming are being used to accelerate the bleeding edge of chemistry my guest this week is professor christian schafmeister and he's been working on a new implementation of common lisp to speed up the design of nanotechnology bits of this at times sound like science fiction but it's very concrete the plan is next year they're going to be building enzym sized machines that are being designed right now in a jupiter notebook in a repple in lisp you have to ask why lisp in this day and age and we're going to get into that lisp still has a few features that more recent languages would struggle to emulate and might do well to emulate to get there we're going to have to go back and learn some of the most interesting chemistry i've heard about since school so we better get cracking i'm your host chris jenkins this is developer voices and today's voice is christian [music] schafmeister i'm joined today by professor christian chef meister how you doing christian great doing great glad to have you here you are our first professor oh which which feels very very formal normally we have a lot of people on this show who are whove picked up a lot of knowledge along the way whereas you're steeped in a particular field which isn't our usual wheelhouse it's chemistry yeah and this is so we're going to talk about the language you've been building but we really have to start with why you needed a language cu this is the closest i think we've got to science fiction on this show yeah so i've been developing something for the last you know 30 years where i want to be able to build machines on a molecular scale so i have gone deep into organic chemistry and i now teach organic chemistry and we've been developing these molecules that are programmable that are made out of building blocks that are like rings and when we snap them together it's kind of like lego you can make molecules with different shapes and they're complex and so i i have been developing software since i was 12 i was one of the kids who kind of hung out a radio shock and learned how to program in basic on a trs8 and i knew that i wanted to use software to design these molecules and that it would be very complex and so i've been working towards both of those things in parallel over the last like 30 years this is this is very cool with a different set chips set that's where i was basically starting off in radio shack we have a similar background sure but but so but we're not talking like nano we are talking nanot technology but these aren't nanobots these are different kinds of chemical machines we are talking about nanotechnology the things that we build are on the nanometer scale but this is absolutely from the bottom up we build things from molecules and build them up and we know where every atom is in in space and i'm actually a fineman awarde i think it was in 2005 you'd have to look that up but yeah i have the fineman prize and yeah i've been funded for nanot technology in the past this is cool this is like so this is machines at the level of like taking inspiration from enzymes that kind of thing yeah that that's really where we're kind of focused because enzymes are the key technology that i believe human beings need to develop those are big molecules that can make other molecules molecules that can make feed stocks for industry and fuel and take garbage and turn it into useful things and detoxify you know pollutants all of that can be done by enzymes we have a whole bunch of them that nature gives us but they were evolved for the purposes of living things there are so many chemical reactions that if we could create enzymes for them we could solve every material problem that human beings have for all time to come it's it's a fundamental technology that we need to develop you really see this as like completely changing the world absolutely it's if we could make molecules that could build other mo molecules then every problem every physical material problem we have we could solve somewhere between shrinking chemistry professors down to the nano scale and that would make us simpler i don't know about that but the the the essence is like an enzyme is a molecule that's large it's got a pocket and it organizes groups inside of it so it acts like a little like a little breadboard like a little circuit another molecule will pop into that pocket and there's a push and pull of electrons it's like a tiny it is the smallest electronic circuit and it works for just a you know a few pico seconds and a new product emerges and then another one goes in and that gets repeated over and over again without the enzyme being modified at all so it is it's it's the essence of life and we can't do that in a rational sense right now at all as well as nature has done nature has millions of these enzymes that it's evolved over you know countless millions of years that can accelerate many many reactions and is this i'm just trying to understand for the background right is this you you're going to custom make an enzyme that takes some raw materials and builds a particular flurry of a molecule is it then that you'll have is there a larger structure beyond that are you going to fill a vial with some enzymes that take raw components and put them at level one and gradually the next enzyme in the chain builds up something more complex until you've got something on the physical scale recognizable as an as a thing yeah you've got it systems of these could build complex molecules they can fix you know here's a here's a crazy example one of the theories of aging is that basically sugar glucose crosslinks proteins outside of our cells in what's called the extracellular matrix and stiffens up the tissue i mean that's known that actually happens and the the crossin is called glucosa pan and if we could make a specific little enzyme that could go in there and cleave those cross links you might be able to cure a lot of diseases of aging i i don't know if it turn back the clock but it's one current hypothesis for how aging happens that that basically glucose cross-linking proteins it's called the malid reaction it's the basis of cooking and that's that's what's basically happened to us over 60 70 80 years right so if you can make an enzyme that could cleave those cross links specifically without doing anything else you might be able to treat a lot of diseases of aging and what's the timeline on this because so we can make these enzymes on a small scale right now is that right we can't design good ones and it's difficult to make big molecules that can wrap around smaller that can create pockets and wrap around smaller molecules it's really difficult to do that but we if we had the recipe we'd know we could physically manufacture them yeah one recipe would be based on proteins and there's a lot of people like writing software to design proteins like alpha fold you've heard of that rosetta is a software package that comes out of the university of washington david baker's group that has been developed over the last 30 years to design proteins proteins can do this kind of stuff they are difficult to design with i the my life's work is to come up with a more engineerable building block set so proteins are sort of like bead necklaces or charm bracelets they have they're long string they have little charms on them and the charms some of them are really greasy some of them love water and and nature has put them together in a particular order so they fold up into a into a into like a ball with a little pockets on them and that's how they that's how they create the pockets that can do the work that folding process is a grand challenge of science predicting how proteins fold now uh the rosetta and a lot of other people who have worked on using software to rack the insides of proteins have been tremendously successful but creating the intricate inside of a enzyme is really difficult to get it exactly right because you have to control where groups are within you know a tenth of an anomet alpha fold has been a huge breakthrough in using deep learning to predict the folds of proteins that we don't know the three-dimensional shapes of i've got a different approach i thought let's build building blocks that are just easier to design with in the first place so instead of making a charm bracelet a bead necklace let's make little ladder like rungs of ladders and then snap them together through two connections at a time so you make a bunch of rings that are fused together you make things that snap together more like lego than linking you know beads on the neck neckace right and then they're easier to design with and then write software to design them so your idea is that you're going to have like a a tray full of different building blocks and then figure out how to assemble them to make interesting enzymes and this is where we're getting into is it pronounced can do which is a great acronym for computerated design nano i forgotten the o computerated nan structure design and optimization right so we we're really on the level of cad software for molecules yeah yeah i started i've i've written this like four times and i started out writing a cad graphical user interface sort of software but every time i got something my students came up with chemistry that it couldn't handle and it required a redesign and then i settled on i'm i'm just going to write a language and build a user interface on top of that all right now here's where we get into language design so at what point at what point did you say this is going i mean tell what point did you say i'm not going to be able to do it with the existing software that's out there i need to build something custom i think i was writing it in small talk at that time and i'd had i had a really nice user interface and my group figured out how to put what we call functional groups sort of side chains off of each building block and the way i was building the molecules just wasn't going to work with that and so i just scrapped it and started it over again i spent a lot of time writing most like chemistry requires performance you're always doing things things that on on lots of atoms that requires writing loops that do intricate things and you needed to be very fast so most of my stuff is written in was written in c++ and then i would hook that into other languages for the longest time i was using python but the interop between python and c++ and managing lifetimes of objects became very troublesome so i came up with another way and that's what current can do and the common list clasp that it's built on that's where that came from this is an unusual route particularly these days i think to go from to go from small talk to common list what year are we talking when you did this probably about 2005 2006 that still counts as relatively recent in the grand scheme of things why common lisp so i was looking around at the the time for a language that would allow exploratory programming i knew i needed automatic memory management i needed performance that was the key thing performance and i was i had this core of chemistry code that was written in c++ it's about quarter of a million lines of code at that point and i was had it all hooked into python was running into a lot of trouble this is back in the python you know before python 3 and was running into a lot of time trouble maintaining that and a friend of mine had was at nasa and he worked a lot with common lisp and said you should check out this language i was using xml a lot for serializing data at the time so i started getting into this idea of you know nested scope in the language and i started implementing a lis in my c++ and found that it worked very well with the chemistry ideas that i was trying to implement so i moved on from there i don't want to monopolize the conversation so i'm going to pause no it's your job to monopolize the conversation but so what is it about lisp that lends itself to chemistry though i can't quite see that so it's really easy to express graphs and trees and linear sequences in lisp with the parentheses i don't know it just flowed really well so i had all the c++ code i was writing a lisp interpreter and started to write imple basically implementing my own lisp and i didn't go very far and i realized it was crazy to try and implement my own language because i've i developed in a lot of languages i know how difficult that is that is to get that right so i was i just looked at you know what kind of lisp implementations were out there and there's a scheme there's common list you know emac is based on lisp yeah there's a couple of them out there but i wanted one that was kind of full featured battle tested have been used to implement large programming systems and you know like common lisp is used in the google flights the engine behind that is all implemented common lisp and so i thought you know schemes got this specification that's like 25 pages common lisp has a specification that's like four inches thick i'll go with the 4 inch thick specification not the decision i would have made just on those metrics i i i i do have a tendency of always taking the hard road on on things but you don't become a professor if you don't like reading right i i guess yeah yeah so i there are several implementations of common lisp and one of them is implemented in c this is called embedded common lisp or ecl much of that is written in common lisp itself it's self-hosting and it has a lot of c core to to do the you know to do the lower level stuff right so i just took their it's a that's a a gpl software package it's got a gpl license on it so or an lgpl license so i took the common list code from ecl and just started writing my lisp interpreter so that it would execute that and i just kept going and executing more and more of it and my lisp turned into a common lisp implementation oh i see okay i also have good c++ inner operation so i was doing a lot of c++ template programming and i implemented something like boost python to integrate c++ and the lisp and then i integrated the llvm compiler library exposed that to the lisp and then i started writing the back end to generate llvm using the llvm c++ api and that's how it all grew why why that step i can see why you need c++ access why go into the llvm part performance just performance with lm i can get native code compilation and without that i would always have an interpreter right so you kind of cannibal not cannibalized but stood on the shoulders of an existing common lis implementation yes but we the developer of ecl daniel is you know we hang out on irc and we fix bugs in each other's systems because we share a lot of codebase it's a very it's been great working with that community and and the larger common list community as well so what circumstances do you think this is the right choice i mean if someone else was looking at if someone else is in your position with a large c++ code base when would taking your path be a sensible one well i i would hook it into clasp i think it's it's the it's a great tool for exposing c++ plus code in a highlevel language that has dynamic memory and a bunch of other features i've hooked in dna sequencing analysis libraries like secan and it's it's very easy to inter integrate c++ code with clasp and that gives you access to all the common list libraries i would have thought that i mean anytime i think programming in the science world i think of python are you are you losing something by moving away from python in this yeah you know common lp if you take python code and you take all the functions and you just take the parenthesis for the function call you know fu open parenthesis arguments closed parenthesis take the name of the function move it into the after the first parenthesis remove the commas and that's basically lisp you you know it's it's not that big a change then you have all these functions that give you you know string handling file handling all sorts of stuff like that and you you you have a full language there i mean it's really not that different from working in python it's just that it compiles to native code and it's common list was developed in it's a standard language so has a standard that was developed back in the 80s and it's a forever language like the code that i wrote 10 years ago in lisp i'm using now and libraries that i use some of them have been written over you know de the last couple of decades and they there's a large library base of common list that works because the language doesn't need to constantly change there's a standard and and everyone writes to the standard there's multiple implementations so everyone writes code that works on a large number of standards and it's a very there's a there's a philosophy of writing things properly rather than writing them just so that they work or they work now yeah yeah i i gather a lot of software in the science world suffers from that problem understanda because most science people in the science world aren't primarily programmers right they're not and there's a tendency to write stuff that does what you need to get the paper out and then it wrs then it it writes and dies but i i got to ask you that question again because you take okay so there's an argument that you take any programming language and strip the syntax out and you end up with lisp because lisp is the programming language with almost no syntax but python isn't just the syntax and the core library functions it's this whole ecosystem science packages particularly mathematics are you missing that in your common list world you know some absolutely there is a lot of momentum behind it but if i you know if i started writing this in python i would be really bogg down right now with you know you can't write loops in python and expect them to run quickly and when you write n like we i work with a lot of three-dimensional data you know like i've got a molecule it's three-dimensional xyz coordinates and i need to put water molecules around it so i have to do a loop across x i have to do a loop and wrapped in a loop across y wrapped in a loop across z i've got like three nested loops and then inside of that i've got it doing something really complicated like figureing out if a water molecule is overlapping any atoms in my molecule yeah if you write that in python it's going to take an hour to run in common lisp with a little bit of c++ assistance it happens in a fraction of a second i can't i can't give up performance time time is the most valuable thing to me so i'll invest a lot of time in developing the software if it runs quickly when i need it to and i'm now running things on large clusters distributed computing across large clusters that would take years of time if when it's run on a single cpu yeah i i can say that like python it's more than fast enough for the average web server but when you're folding proteins in 3d space yeah i can see that every nanc counts i i've been around i've programmed like since i was 12 so more than 40 years and you know all the python that i wrote back in the in the 90s is gone dead you know when they changed to python 3 three i didn't upgrade all those libraries and it's now gone so all of that was kind of taken away from me i don't want that to happen again so i'm only developing now in in forever languages languages that are going to be around for till till you know 20 30 40 50 100 years from now it's one of the few languages where i could predict the syntax won't change much between now and then yeah and and i i have the rare experience of writing software that's been used for more than 30 years before i started graduate school i wrote a program called leap which is kind of the front end for amber which is the one of the large academic molecular dynamics packages right it simulates the motions of proteins in dna in research and it comes out of the university of california in san francisco so i was given the job before i started school to write a front end for it so it make it easy for researchers to load in their proteins and set up the calculations to run on this on this at the time it was written in fortran fortran software and now it's got the fastest gpu implementation but my software leap is still being used today probably some percentage significant percentage of the world's biomolecular simulations go through leap every day and have for the last 30 years that thing was written in c and they've tried to replace it like the amber community has tried to replace it i think twice and have not succeeded because it does an essential difficult job really well the downside is it hasn't been improved very much in 30 years because it's difficult for people to get into the way it was written well this so that raises a question of collaboration you're writing this software in common lisp is again to an audience that's probably if they know programming at all probably knows python i'm guessing team of technically astute chemists how are you how are you finding the the user experience and how are you making it usable for people we have there's really powerful tooling based on common lisp tooling software let me re rephrase that so there's a software package in common list called slime which works runs in emac yep and lets you connect into a running common lisp instance and develop code it's got an interactive debugger it's got auto completion it has everything you want it's a really beautiful program pramming environment you know sort of integrated development environment that's all text based working in emac so we fully support slime i use it every day i've got it open right now it's it's one of the most wonderful interactive exploratory programming experiences i think you'll find now i haven't used a lot of modern idees for c++ or python so maybe i'm talking out of my hat there but it is a really fluid programming experience so we have that we've also developed a jupiter kernel based in that that runs a clasp or can do that and so it's got widgets for doing displaying molecules and graphs and things like that okay so you can open a jupiter notebook and type in some common lisp and see your molecule and that kind of yep exactly my usual development environment is to have i've got can do running that can do running i've got a jupiter notebook instance talking to it and i've also got slime running in emac also talking to it i'm developing code in slime i'm seeing the effects the output in the jupiter lab environment and that's how i get my work done do you know if that plays out the way i'm seeing in my head i think a lot of modern idees and more modern languages would struggle to match that if you've got the mixture of the interactive programming experience and the live visualization there aren't many languages that do that well ass that's a good point i i really hadn't considered it i'm i i was really inspired by the sorry what is that new apple language that swift yeah swift so when they first demoed swift they had this sort of interactive programming you know environment i i love that demo i'm really inspired by you know the small talk interactive programming environment slime is really great i i just i i want something where i can be talking to the programming environment add functions change everything about it i want to be able to change class i need to be able to change class definition functions add you know generic functions that will add new functionality i want to do all that stuff interactively and that's what i have with this system yeah yeah i i think to that i can say i think lisp is the only language where i've genuinely felt like i'm having a conversation with the computer you know that that dynamic interactive experience yeah that's that's an interesting way to put it i hadn't really considered it but yeah i would agree it is it is really i really enjoy programming in it that's cool i i have to this is a very nerdy question but i'm allowed to ask those i have to ask so you're looking at doing an interactive lisp with c for the fast bits of bindings did you ever consider just doing an emac lisp when i when i was first getting into list i was a little confused about what was what and i thought that that would be an option but it's it doesn't have the native compilation it's a reference implementation of a language and so i decided no i'm going with a standard fair enough okay in that case let's talk about the this perform performance bridge so i'm assuming you've got c++ where it needs to be really really fast and you've i'm assuming you're as far as possible you're in list bland for the convenience interactivity high level preferred way of programming tell me about the bridge and when you know it's time to put something on this side or that side of the bridge yeah now i usually start i don't know i've got a really at this point i've got an intuitive sense of of when i really need speed and when i can get away with that we've i do all the sort of low-level c++ work in implementing the common lisp so i do a lot of c++ development a lot of c++ template programming and i think i'm pretty good at it now we implemented llvm as the back end so that we can generate native code and that code runs pretty well but i still can't implement something in common list and have it run as efficiently as it would if i implemented in c++ because common lisp does try and make everything safe and everything's wrapped in our you know most of the objects are wrapped in wrappers so that slows things down we've now implemented a bite code compiler in clasp to to sort of deal with the slow compilation of lm which is a great library by the way i'm my train of thought is just derailed could you reiterate the question so there's there's like you've got lisp in in programmer space where it's nice and c in computer space where it's fast right which parts of that go on which side of the line profile profiling profiling profiling so because we generate llvm we can compile everything to llvm down to native code and it all turns into object files and you know basic unix elf mock sort of stuff so we can profile the common lisp against the c++ perfectly using perf or using drace on the mac and we generate flame charts and i can see where time is being spent in the code so it's profiling right and how much work was it to get that working a lot because it's really fussy especially the jitted code the the just in time compiled stuff that you know we're generating all the time to get the names accessible for the profiling tools had to futz around with a lot they they basically they had this solve the same problem for javascript on on the browsers so we use those mechanisms once i learned about them but yeah we can profile everything on an even level and then depending on where time is being spent i will move stuff into c++ if i need to okay it's manual but can you do that all while your same process is is running yeah so you can take a function that's running too slowly and interactively update it with a c++ definition oh or interactively compile it to c++ on demand or no no changing the c++ code means rebuild of the system okay that takes about five minutes and then restart everything and reload everything yeah okay so this is another reason to keep certain things in list space for the interactive reloading without restarting thing yeah which really puts me in mind of crash band cot do you remember that video game yeah it very inspirational yeah yeah that was a good sales pitch for lisp back in the day yeah so i i do most of my development in in lisp and it's only when profiling shows me that i've got a problem that i move it into c++ okay or rejigger it to get things into c++ okay then maybe we should talk a bit more about what's good in list space so what are the poost to children features of list macros are you using the macro system much some you have to use that carefully it's a powerful pointy tool but yeah it it lets you sort of write your own flavors language yeah we we do use it it the macrosystem is is really the basis of lisp all the stuff that makes it really powerful uses the macro system so in that sense we're using it all the time but writing my own macros that's pretty i don't do that that often okay what about the raita system that it's another powerful tool i i have a recent use case for that we have all of our arrays we have specialized arrays so for floats and doubles and integers where they're just representing in compact data in memory okay when i i need to serialize large complex data structures to dis and then load them back in for running calculations we could talk about you know the save lisp and die thing but the saving these large vectors i've i'm using the lisp print and reader to dump these complex data structures to dis and then load them back in and that is fairly slow it's it's like pickle or it's like using json but you can have internal references in the data structure so you can build up circular graphs yes yeah yes and that's an absolute necessity for what we have because molecules are graphs yeah like it or not it's cyclical yeah yep yep and so it handles all that really well but writing out the arrays was taking a lot of time so i what i did is i just turned this 8bit data into six bit data that's human readable you you know just using six bit characters and i write out this stream of characters to represent you know the compact array and i wrote a reader macro that when it detects the reader macro characters just reads in that six-bit data and turns it into a 8bit data structure and memory and took my load times for these things from 10 minutes down to you know 30 seconds nice which must come into play when you're writing c++ and having to reboot the world right so do you have a a do you have a perfect between session thing can you when you're working with you end up with this kind of working memory of where you're at can you flush that entire thing reliably to dis reboot and bring it back and be exactly where you were yes yeah so one of the really remarkable features of lisp is this idea of save lisp and die where you just checkpoint all them you you you do all your work you get a your memory all set up to you load all your files you get everything set up to do something and then you say okay save all this memory and then later on start up the the common list system loading that memory and be right back where you left off yeah so i implemented that feature in clasp and i can load 100 megabytes of of complex data structures to do a complex design calculation and then save the thing to disk and then start that up again in less than four seconds that's a rare feature these days right because most programming languages you can't checkpoint the state of the program yeah how much work was it to implement that you have to have a really good understanding of how the memory is laid out and you know how with how our garbage collection works so we support a precise garbage collection so i know where every pointer is in memory and so it's just a matter of keeping track of all that stuff writing it all into a block of memory dumping that to dis then loading that back into memory and then feeding it back to the garbage collector which will put it wherever it wants to in memory and then fixing up all those internal pointers and that the the memory survives that round trip okay it's pretty complicated and fussy but it's working and yeah what else can i say about it is it reliable it's yeah it's it's working perfectly if you know if one pointer was out of place it would crash the system within moments i have a memory test tool that will exhaustively check that every pointer is pointing to a valid object and that gives me a lot of confidence that everything's fine what what what we can't carry across that are like it's got to shut down all threads all but the main thread and it has to close all file handles but that's not as big a problem as you'd think why not because i would think well for the stuff that i need to do it's not i can i can generate a memory image that we start up the jupiter lab environment where we load all the packages that we need for jupiter lab to run and then start a jupiter lab and it it you know first time to plot is less than two seconds okay okay fair enough that makes me think you mentioned the word threads and i can't quite see i can see how you've got a requirement for parallel processing and threading how does that fit into a hybrid lisp c++ model how does that fit so we have common lisp has a standard it's also got a several libraries that have become deao standards like bordeaux threads is a the deao standard for creating threads taking them down communicating setting up you know locks between them and we use that to do multi-threaded programming built on top of that are convenience libraries like l parallels where you can just do a parallel map you know common list has list list lists and list comprehension so i can map over a list a list classic tongue twister list and list yeah l parallels you parallel map over a list so i can just give it a list of work and it will allocate that to multiple threads and i don't have to think about it i that's what i do again the advantage of working mostly in a higher level language yeah yeah and when i'm doing that i'm doing these design calculations i've got a 28 core machine and it's using 26 of them flat out i i i get like 80 90% utilization of all the cpus when i'm doing this design calculations that must be speeding up the the high level chemistry task a hell of a lot tremendously nice nice okay so zooming back out then where is this tool going to take the research we we are starting to design molecules now to be therapeutics and c catalysts we're doing that now that's where we needed to go so we're we're we're essentially there it has taken a long time and i really just got the high level design calculations working in the last couple of months okay and so does that put you in a place where i mean the people using this are they saying to themselves i think this would be a great model i think this would be a great end zone to build i think it will have these pieces are they working like a lego designer or are they monte caring a number of things and testing which one works or the people who are using this are basically me right now okay okay and what are we doing let me talk to them okay what we're doing is catal a lot of catalysts have metals at their heart like metal atoms like rodium and palladium and platinum and so you say okay i got a plaum atom and i want to have groups that attach to it hold it in place and leave a space near it that another molecule can come in and get you know interact with that metal touch it so you say i need a group here i need a group here and here and here and then you say okay find me a scaffold that can hold those groups in place and the scaffold is built out of our building blocks and so the software goes and tries lots of different scaffolds monte carlo search through design space and tries to find the ones that can hold the groups in the right constellation is this into the realms of things like i don't know genetic algorithms and that kind of stuff you can use those as search algorithms i'm using monte carlo it's the simplest most powerful elegant algorithm to do this you have a scoring function you generate possibilities and you just crank on them as on as many cpus as you can get your hands on and possibly to finish off it's like it's very hard to predict the future it's very hard to predict time scales but at what point will we see a clasp designed molecule being made in a lab i'm hoping in the next year in the next year not yeah not hoping i'm doing it in the next year okay so the other thing is i've i've got i'm funded by the department of defense and i've got a company that's developing this technology and we've developed the way to synthesize these molecules we've made thousands of them in the last three years so we can make these molecules very quickly and easily takes a day to make any like reasonably sized molecules it takes like one or two days to make them and we're doing this on robots the problem now is which ones do we make at my company we're making millions we're putting them together into millions of different configurations essentially at random and then throwing them at the wall to see what sticks right the software those are our hands we can make those things the software is meant to be our eyes so so that we could see and predict what to make so i'm bringing that online now right okay so the search space is potentially so vast that's the problem we're solving vast i mean we have in theory we have thousands of building blocks in practice right now we have 40 you put four of those building blocks together in a sequence that's a very small thing but it could be a drug so then you've got 40 to the yeah 40 to the^ four different shapes that you can make of just that small configuration okay you can either try and make some subset of them and throw them at the wall and see what sticks or you can try and design them in software that's what can do is force to design them right i don't know how well it's going to work it's an experiment yeah well you're you're in the research business someone else can commercialize it and eventually what will we have fields of sha meister wheat or trying to imagine the future that you're heading towards the the the first one is new therapeutics right you know medicines treat disease new diagnostics to recognize emerging biological threats catalysts that can accelerate reactions and create turn cheap starting materials into valuable products i have to ask then if if you've got something like this biological machine that manufactures drugs or manufactures useful things out of raw materials if we see it i mean i'm just trying to think like like war zones for instance aid outbreaks of viruses will these things be able to manufacture things in the field if we find them this this is kind of long-term science fiction stuff i well we're stretching out to the end of the podcast so give me some this is potentially yes we can rapidly build these molecules and if we can rapidly design them then yes you could build things in the field there's a lot of machinery that goes into this it's not the first thing i'm going after the what we're i'm really focused on is the basic capability can we design a molecule that does what we want when we want to make new therapeutics new diag molecules that can wrap around proteins and act as diagnostics or accelerate reactions or create like channels that can purify single molecules out of mixtures like could we pull lithium out of seawater or uranium out of seawater you could imagine membranes that could just selectively pass uranium and keep every all the sodium and lithium and potassium in seawat out and then you could pull metals out of seawater and it would be a lot less environmentally damaging than mining yeah yeah plus presumably like dealing with pollution as well exactly i mean when we can build things on the in the the b in the molecular scale like that with intent with rational design we can solve a lot of our problems that that's where i'm working that's i'm working towards yeah i can totally see the potential and i'm quite pleased that there's lisps somewhere in that future yeah it's it's a fun programming environment to develop this stuff in well i hope it goes well yeah christian thanks very much for telling us all about it chris thank you for taking the time in cheers thank you christian now you'll have only noticed this if you've been watching this episode on youtube but throughout that conversation christian was drinking coffee out of a lab measuring beaker which is brilliant very on brand for a chemist if nano machines turn out to be the future of lisp remember you heard it here first so please take a moment to like and subscribe share with a friend rate post it to the social all those good things i appreciate the feedback and the support it's also worth saying that this particular episode only happened because christian got in touch with me and said i've got an interesting programming topic that you might like so if you have an interesting programming topic that i might like my contact details are in the show notes as always with that i will leave you for now i've been your host chris jenkins this has been developer voices with christian schafmeister thanks for listening