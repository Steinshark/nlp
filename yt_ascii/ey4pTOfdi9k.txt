hello everybody this will be an interesting talk i promised my favorite code examples about c plus 20. c business 20 is pretty new every every week we have a new compiler version out of the major compilers every week i learned something although i have seen all the features right now i hope and so this talk is constantly changing and so this is a this is a version of november 10th 21 and let's see whether you like what i like so the talk will roughly talk about only about how to print elements of a rank and but there are so many interesting things to discuss i think that's enough so let's see where we are we have here a data structure a coordinate with a three values x y and z value let's use it well let's initialize an array with some coordinates since c plus plus 17 we don't have to specify the element type and number if we initialize with the same type and let's sort them and let's print them out okay and how do we print well let's print it the old way not the c plus plus 20 here's nothing from c plus 20 yet so let's use the template let's print the elements of the past array iterate over the array and print out the value good so the first thing we can improve with c by plus 20 as you might have heard yet is instead of writing that this is a template for type t you can just write auto by the way it's still a template and it still follows the rules of templates for example you have to put it in a header file and then we can switch the sort algorithm so before c plus plus 20 we pass begin and end as usual when we pass ranges so now we can just pass the range as a whole and using a sub-name space called ranges okay so but for sorting we need a way to compare the values in this data structure and what we usually have to implement is the less than operator for that or we need to sorting criterion for to pass to sort as an argument well we have something new here you might have also heard about this that's the spaceship operator and the spatial operator is responsible for the comparison operations well at least for four of them but if you declared with equals default even for all six of them so by that you enable comparing coordinates with all the six comparison operators checking for equality and relations and ordering and it uses by the way the members x y and that in that order so we sort according to x as a first criterion then to y and then to z and this will also support cons expert and no accept and type conversions so that's all you have to do and then of course we need some output support because we print all the elements and the elements are called innate so we need an output operator oh an output operator you still have to implement the usual way which in this time as using a hidden front so a friend function inside a class or data structure and so we want to print it out that way so how do we do that okay we could print out x y and z coordinates and it stream them out to the output stream and then stream out the slash in between but we have something new and something new we can use here and that's format sdd format as a library for output formatting so that we can specify field width alignments etc and let's use it just that way that's pretty simple print out the three values as passed here as additional parameters with a slash inside and here we could do a lot of alignment tricks which i didn't use here yet okay so in a minute i have to organize my screens a little bit and that's how so what else can we do well this print function does support rangeless and but in the declaration according to the declaration it can take everything so we can restrict that by saying okay let's use only ranges here ranges where we can read values from and for that we have concepts standard concepts so that are constraints about template parameters remember auto is here just a template parameter a generic parameter and this is a so-called type constraint so we constrained the parameter here that you can only pass input ranges so if you're passing in a good compiler might say oh that does not fulfill the requirement that the argument should be an input range good okay oh let's skip the first coordinate by the way that's another thing we have with c plus 20. so let's skip the first element oh that's easy take the array and drop the first element well what we create here is not a new container let's just skip the first element by iterating over the elements so we have here a mechanism of lazy evaluation we create a view a view refers to the original array that says well if you want to iterate over my elements skip the first one and so the moment print starts in this range base for loop to say okay let's iterate over the elements the first begin goes to drop drop goes to the array and says give me the first element and then rob says oh no i give you the second element because i want to drop the first one and then so from this point of view this view gives you as a first element the second element in the array and that that means we print not the first element which would be 0 0 2 here of this array okay so these are all cool things you might have seen already coming from c plus 20 range support you can use ranges as a whole you can type rangeless interviews so to filter their mouths etc you can put constraints etc you can use auto instead of template parameters so things like that and and to print out your format to define the comparison operators you have the spaceship operator so but let's look into a little bit more interesting examples so first of all as usual in c plus plus not everything works as smooth as it looks like so if i take this program you just saw remember let's print all the points drop the first one well after they have been sorted and let's use this print here oh let's let's use a filter instead so instead of dropping the elements yet let's use a filter but a filter is a predicate well and in contrast to drop it well it looks to each and every element and says oh i pass this through if you ask me for the next element i give it to you or i reject it so this filter is a little bit trivial it says yeah i accept all the elements i always return true but here that would be your condition what elements should be filtered out or what elements should be filtered through but there's a problem now this code no longer compiles there's a compile time error what the hell is going on here well there's a problem and the problem is the following we have here a print statement that takes a const reference to whatever we pass and there's a problem with some views because some views have a state and that means while you iterate over the elements they modify their internal data and filter is one of them so if to iterate over a filter the view can't be caused but we made a const here so therefore this code will not compile anymore that has interesting and dramatic consequences i think for c plus as a whole so here you see some filters work like drop work but others don't work some not always work when there are cons for example for drop dust drop it worked because we were iterating over an array but if we would iterate over a list it would not work to pass it as a cons by const reference here so in general not all views support iterating of the elements when they are const some always some sometimes and for that we have to change this code we have to say okay let's not make the parameter const well we could pass it by value if it's a view it's cheap a cheapest view is cheap to pass so this is a view we pass finally a view to this array but we might also want to use this print for ordinary containers ranges which are expensive to copy and as a consequence we should not pass by value at least not in this case so there's a solution for that we have a type that says let me pass something by reference without becoming cons and a reference that can refer to everything and because a non-cons reference cannot refer to temporary objects that's a universal or forwarding reference it's usually it was introduced for perfect forwarding but more and more it turns out that we need the other flavor of this reference which is to universally refer to something by keeping all its attributes so not being cons is one important point here so therefore i tend more to come back with the old term we had universal reference because forwarding reference sounds like we are using forwarding here which we don't use here we don't use std forward here it's just a universal reference and there are two ways to do that you have to use a template parameter with two ampersand or two ampersand with alto in this syntax so yeah and we can still qualify it has to be an input range so with this declaration everything works fine again and you can of course apply more interesting filters here good so good things and bad things happen when you apply and use c plus plus 20 and the features of c plus plus 20. let's improve the whole stuff a little bit look at this oh look at this here this is a range so what is a range a range is something we can say that as well historically defined by begin and end and begin and then usually are iterators well raw arrays are supported by using pointers as iterators which provide the same api and therefore can be used as iterators but there was one interesting restriction we had before c bus plus in almost all places in c plus plus which is begin at the end of such an iterator had to have the same type so a begin and an end iterator had to have the same time but there are nice applications if this is not the case if the end has a different type than the beginning here's one look at this i want to iterate over these points and my end is just a specific value not an iterator at all it's something i can use a little bit like an iterator but yeah let me let me define a range that goes from begin to this value this should be the end and [music] let's define it as a template parameter and of course this is a type this is a declaration this is the end value of and the value is initialized with this value that's a template parameter that's a fixed end value we are using here so this means let's iterate for all points until we come to this end how can we implement such an n value people have done that before c sub 20 and you can for example do something like this here's a data structure and value that's my type it's templified by the value the value that defines the end and then what else do we need to deal with that well let me first say that there's a terminology a new term introduced with c plus 20 which is the end iterator in general is called now a sentinel so we always iterate with iterators until the sentinel which is a synonym for end iterator but may have a different type and that could be used like such a sentinel so how do we define and implement this sentinel type well that's all that's all you need you need nothing else what we define here is let's compare my value with an iterator that's here the argument is just some iterator and yes we have the end value if we compare with an iterator we have the end value if where the iterator points to has the same value as the initial value passed to here now remember how this range base folder works so first of all there's a remarkable thing that is the range-based for loop already supports beginner and having different types that was introduced by sequels 17 by the way and so but internally please note that the internally the loop here initializes an iterator and says i'm iterating until i am at the end so why i'm not at the end so some code here internally is why my internal iterator is not at the end now what is the end the end is this the end is this object this object has an equal operator and here we see another feature of the new spaceship operator and all the technology around it we have new support to rewrite comparisons so we have defined how to compare an end value as first operand with something else as second operand this is comparing not not equal and the order of the elements is different but there's a new rule that now this can be used because if the compiler cannot compile this it will come use this instead and try this instead so it tries is there instead of a nautical operator is an equal operator defined yes we have it and and is it even defined for the opposite order of the operands yes and then we negate the result and that works so therefore this is enough to make this work and what we do here is we create simply an object a range a ring starting with the begin and ending with this element yes obvious questions will be what happens if i don't have such an element yes we will iterate forever so that's you should only do that if you know that this element is inside but there are other ways to do that we could for example here pass as a runtime argument the array and also here compare the iterator with the end of this array and with this value so whichever comes first that's that's not a big thing to implement then in addition okay here's another remarkable thing i don't know if you see that we use here auto we use a template parameter the template parameter is a value this is a non-type template parameter so what is the type of this well it's a literal type it's a data structure and that's new now we have a lot more support for non-type template parameters now in c plus plus 20. in fact that if you have a template generically templified for a specific value the value can now also be a floating point value and a literal type like here which includes that you might be able to have support for string literals and that does yes lambdas could also be template parameters now because yeah they are they can be literal types they can be data scratches and that works i have some examples in my book about that i have not yet a very useful example to use a lambda as a template parameter but i'm pretty sure we will find a lot okay so how many features are on this slide okay concepts standard concepts nttp parameters rewriting of the equality operator the spaceship operator scd format ranges take ranges as a whole so passing ranges as a whole instead of begin and end helper types and views like sub range drop you have seen filter you have seen these are all views of temporary created views here here the viewers let's define the range from to this array up to this value that's my first example oh oh we have something else the chrono library was extended oh we should try this with craw well something like this okay let's take again my print function i accept an input range arbitrary input grade not making it const so i can read elements from that of any type let's pass something different let's pass an array of dates could the chrono library extension for c plus 20 now supports calendar types a lot of calendar types very type safe with interesting behavior you might have seen the keynote by howard i don't know three years ago or so here you see some ways to define such a date so this is a today the 10th of november 2021 there are other ways to define the date this all could be variables not only constants and please note that we here create use an operator already so we create here an object of type day then we use this operator to combine it with a month the result is an object of type month date and then we combine it with a year with this operator and the result is a object of type year month day and that's also here it's just that the order is different to support the three major formats we have so we can start with a year then the next is always the month or we can start with a month and we have predefined values for the common month we have slow like november 1st 2021. and so i see you can ask questions at q a i from time to time i look there but i might most of things answer at the end but so unless it's just a direct question for the understanding so let's take the dates let's sort them and print them out okay now we know these are dates okay well let's iterate over the dates which are days all this oh let's print them out that's new that would not compile in c plus 17 we have now an default output operator for every duration and time point and other chronotypes so by default you can always see something you don't have to add units whatsoever so it's it's like this this is a day we print out the usual format we have an id which is with the slashes for all the other dates by the way we use slashes but here this is very common in it as a default value yes you can change that with the format commando come on oh i don't like mondays that's a song you might know that so if the weekday of this day is a monday let's print that out oh that's a monday that start let's schedule meetings okay take this as a local date type plus so we have a day here and then we have now to add 12 hours to that so now we have a date combined with an hour and that's some type that works some time type that works fine okay let's apply to the current time zone that's a time point associated with the time zone and then let's iterate over some other time zones like europe berlin and america la and print out the meeting dates so like here printout well here you see format again the format library the format library supports extensions for user specified types we have [music] done that for the chrono library so you see here this the format that is supported here says oh let's take here the next value the next parameter and here are some formatters meaning here and this in this in this scenario the the day in this format and the time and the time zone at the abbreviated time zone here which might look a little bit different depending on your local machine maybe gmt minus eight may make maybe your really your time zone and a depends a little bit on the platform yeah okay good so we have support and all the support you have seen now of course also for [music] the new chronotypes yeah works fine and then i thought about this example and then oh wait a minute let's look at the example i had and can i use this at compile time how much can i use at compile time so look at this this is a compile-time defined array some values and for some reason i have to merge some other values as you see the other values are also known at compile time so think about this as a framework there's user code there's framework code they have their values the framework either has other values whatsoever and so all are known at compile time but in very very different locations of the source code okay so how would we implement a function that merges these two values 42 and four and that's a very added number of arguments we could take here pass here to this array and then come up with a resulting range that we can use in master print and do all the funny stuff we have seen before well okay much the value let's see later what the return type is a traditional way would be to take a template so template parameter for the for the the collection be causing and then an arbitrary number of values we use various templates here so these are multiple types and multiple values of these multiple types and to support move semantics we use two ampersands so we have used universal or forwarding references so just in case well here we have end we don't need move support but you never know so let's initialize a vector with this with these elements a vector declared with the value type of these aligns and then initialized with begin and end so you might say this is some of these things are not necessarily necessary but be careful if you use class template argument deduction here and you don't specify the type here you would have two elements which are two iterators so you have to specify the type or the other option would be in this case to use parenthesis instead of curly braces one of the nasty areas in c plus plus where we have different behavior whether we use for initialization parenthesis or braces but that's a different story so let's initialize a vector with all these elements and the elements are use the value type of the the past container type elements the value type of the container here are as you probably have learned the hard way is because all your compilers tell you is let's use type name here because this is a member type member of this parameter so now let's merge all these values i don't know how how good you are with cpr 17 that's a that's a fold expression so this is a commando as a comma separated list of statements called pushback for all the past values so that way we call pushback for all the past values using move semantics so we forward the unminds into the collection well let's sort them okay and let's return the collection so what we have done whatever you gave me in internally i create a vector initially with these elements and then i added 42 and four sorted all the elements and print out the elements and yes that works if you iterate all the elements you see this result that is yeah that is code that works okay a few things about this so first of all this is so far called not using anything of c plus plus 20 again so how can we improve it and so let's go through it step by step so first of all this this type name is no longer necessary let's skip it that's in a lot of places where it's obvious that the type name is a type that the type member is that the member is a type and you can skip it there are some special rules where this is not possible yeah so it's a little bit funny because finally in visual c plus they really require the type name and now it's no longer necessary but okay so that's possible good then we can hear the sort let's apply the usual things we have seen in the code before okay look here saw let's use a sword for just sort all the elements in the vector the range of salt and let's here instead of taking template parameters with the name let's use auto here so cons auto reference for the range and to have perfect forwarding and move semantics universal or forwarding references for the past arguments the values you want to copy or move into the collection without to to ampersand and then dot dot to signal we have multiple elements of that once again this code is equivalent to this it is still a template it follows the same rules the difference is that we have no specific name for the types anymore that means instead of using the type we have to use deco type of rg or here decal type of valves whenever we need the type of these elements are on the template parameter of these elements we don't have a name for that so we use decal type here that's interesting because that means that in this case i would probably prefer not to use alto here i would probably still use that one because i need these two names t and rx so that would be my code okay so the only improvement we have now is a use rangeless song so let's change the declaration here look at this we have an std array initialized but now let's switch to a raw array and the code suddenly no longer compiles so this code is not as generic as it could be yeah so can we improve that yes because in cbs 20 we have a lot of support to program ranges not only to call algorithms for rangers and have something we have a lot of support to implement code generic code for ranges and so what do we have to modify so that this compiles well we have to declare it like that a week well there as usual in c plus there are many ways to do something but this is one way to do it so this is let's pass ranges begin and range is n look at that here we call a member function of course the null array has no member function beginner there here we use ranges begin arranges end of this range and that's what we call a customization point object that's an object by the way that's that's no longer a function and this supports all ranges and views and it has no adl issues why do i have to say that because there's also an std begin and see the end but they have problems in some situations so we fixed we fixed these problems with these new helper utilities in the rangeless library so please prefer them over std begin and svn there are even more things fixed for example we have const issues with c begin and c n constants is partially broken well or not no longer propagated for views so that c beginner and c end is broken in c plus plus 20 and we will fix that with c plus 23 unfortunately only yesterday there was a vote to put it in the fix and but this fix will only apply to scp ranges c begin and suv ranges cn not to std begin and scdn so please prefer these in range of specific helper functions to deal with generic code dealing with ranges and here you see another helper that is in ranges give me the value type of the range that is programmed in a way that you also can use raw arrays there which don't have a member value type okay by the way this is not perfect you should improve this because this requires because we initialize a vector this requires that begin and end have the same type there's a problem with the traditional con compilers and containers that they require begin and end to have the same type and if you initialize them with a range and to do that and and you've seen one example where we had different types remember the sentinel and value we used this would not compile here but there's a way to come with that you could create a user helper view it's called common you can pass through this view to iterators and they harmonize the iterators give them a common type and then this code will compile i don't have an example for that because otherwise i would have need one or more to start the talk yeah but you will find examples in the book how to do that so that way we would even support in this match value algorithm iterator and sentinel ranges so and now i have said wait a minute everything is known at compile time so can we somehow compute everything at compile time okay const express is the way to say that though oh let me compile this at compile time let me try to compile the z compiler surprisingly this code works although we need a vector because a vector now has a couple of com cons expert support almost all functions have that and but but here we [music] return the vector we create a vector and we return it and here it is used at runtime so here are the news you can use now vectors at compile time but you can't use a compile-time vector at runtime okay so we have support in fact for memory allocation which vectors use and by the way we also have compile time strings now but you cannot propagate these strings and vectors to run time so if i try this code works because finally here at runtime we make this call and we create a vector if i would say here a cons expert in front here this would not compile well we have we also have a new keyboard the new keyboard says it's not optional whether we do it at compile time or at runtime let's only allow to do it at compile time that's called const eval and const eval says this is a compiled time only function and yes this function is fine it works it compiles this is a valid compile time only function let's initialize a vector let's push back some elements let's solve them let's return the background that's okay the only problem is 10. now we are required to compile this at compile time and then we want to use the result as runtime and that's not supported so what could we do well first of all as a proof that this in principle works look at this if we would just compute the resulting size of the vector and then take the return value here and this is not just the vector we return just its size that would compile and work fine so but of course i was thinking i want to have i want to merge all these values at compile time creating no runtime computing at all well we can't propagate a vector but we can propagate an array so we couldn't and compile time take the vector initialize an array now the question is what is the size of the array well it's a the size of the range the given range plus the number of additional parameters so that's that's the resulting array please notice we use here s size that's sign size that gives you the size as a signed value to get rid of these strange warnings that we compare signed values with unsight size values it's also new so let's copy now all the elements from the vector into this array and return this array and that is go that works that compiles this code compiles the only compiler you can try it out now is visual cpus plus but it works this is working code and yeah this is the output so we have it's guaranteed that this call is done at compile time initializing this value it could be constant expo here also and yeah we have initialized an array with the values of the original arrays merge with 42 and 4 and sorted good a few hints here first of all you might say can i initialize the array here with the size of the vector well that's not supported ah i'm sorry before i come to that again now as we use now compile time computing only let's get rid of all the move semantics and and for perfect forwarding because we only have values and it's all computed at compile time so we can simplify code like this now because at compile time it doesn't matter this has no impact on the runtime of the program so and now we come to the problem can i use the size of the vector to initialize its array no you can't that's interesting we have a different a difference between compile time values and compile time runtime values so this is a compile time value size of the number of the additional elements and vectors and areas need a compile-time value here and so what you have to pass here is something known at compile time unfortunately the size of the vector is not known at compile time although this code is only used at compile time we don't have support for that yet we could but we were very very we were very late with this feature and we were a little bit careful so this will not work this will also not work so you could say okay let's here let's initialize a value here because here now you the compiler will say but this is not a compile time value although it's computed at compile time you see the point so that's a little bit of an unfortunate restriction to this code so i thought a little bit can we do it can we do it somehow can we somehow return and use the resulting size of the vector and return it to the caller here at compile time well yes here's a trick and maybe there are better tricks this is just where i was right now 10 minutes before i started the talk and so let's compute here with cons expert the the size we want to have so that's it which is the size of the given range and the additional values that's a maximum size so let's initialize an array with the maximum size we could have which is the number of elements in this area plus the number of additional values we passed to this then in this case now let me reuse let me remove duplicates here so just that we see that we cannot we not necessarily return a vector that has just this sum as a resulting size because here this 4 this 4 here is twice then and we only want to have them once so it would mean that depending on the values we merge we have a different size which we return so unique copy data this is the unique copy version of ranges passing the range and the begin of where we copy the values while we removing consecutive duplicates and now let's return two things two things the array and the size and the size is here the unique copy gives us indirectly the position of the end and we have to deduce the position of begin and so that that way we have the size so this returns array and its size as a pair so what we get here is not just a collection it's an array and a size because the array might be too big because we have removed duplicates at the end so what can we do well use a view we have so many views so here's one view one view is give me the begin of some range and a number counted does it for us and by the way count is implemented in a way that it creates a different type if the elements are in continuous memory than if they are not so so that means counted gives you the best performing run time thing you can use here so counted takes the begin of the array so that's in the pair the first element and here the second element is the size yeah i should probably use here in the next version structured bindings to have better names for my elements in the pair but i hope you see the point and voila this is the result this is we have a compile time collection this collection is passed to a compile time function initializing a vector and dealing with that not knowing what is the resulting size because we assault and we remove duplicates but what we can return we cannot return a connection with that size because the resulting size is a run time value known at compile time and for the size we would need a compile time value and we can't propagate a vector to runtime but we can use this error trick with a size so we have the area and say but only the first n elements are valid or should be used in this area and that is the way you can use it right now so we now have here the array by the way has 10 elements one two three four five six seven eight nine about the or nine no yeah nine i think and the first we have twice but because we initialized this range this view we can use that and now we can here use our print function that deals with the elements and yeah i could put together everything and say oh and these elements are chrono types because chrono types are compile time types if the values are known at compile time and that would also work but that's something i give you as an exercise ah by the way if you do that and try it out don't forget these two empty curly braces well if this is code that compiles with visual c plus the latest version by the way it does not compile with the c plus plus 20 flat you have to use a c blaster's latest flag and if you don't do that you return from compile time to runtime some value is not initialized properly in this area and that is at least an error with with a c bus bus not sure about whether this is an error according to the standard or not but it's a good error in any case so please don't forget to pass empty curly braces here so that this all the elements in this area are guaranteed initialized because we pass them to the runtime that's it so as i told you just printing some elements maybe we compute them at compile time and you have seen a lot of different features here in this talk i think not all we have a lot more but we have seen that so that's it hope you enjoy and let me now go through [music] let me go through the questions you have okay so the first question is yeah so should i continue yes i give you assistance if you need thanks for the talk okay so where does it where does it get the current zone from in chrono okay let me go to the chrono slide well current zone is supported by the operating system so you need support for this library you need obviously you need support by the operating system so to detect what is the current zone also the operating system has to have the ana time zone database to know which time zones are supported you can't use here any combination that's pre-fine combinations so you can't use europe munich i think that that's not a valid option so these are the the official names in the so-called iana time zone database which are supported and we have an api for that so we either require that the operating system has a current version including offsets of time zones etc but we even have support that these time zone databases could be updated in case i don't know some country decides that that's daylight saving time or summer time as we say somewhere in europe it's changed a little bit things like that happen usually they happen with the operating system update but we have in c plus full support so we could even run c bus bus programs 30 years including updates for time zones that's that's there okay so slide 20 or 21. does decotype rg not give a constraint type which won't have a value type member 2021 you might be right and i didn't try it out wait a minute range is a reference i have to check that yeah you might be right thanks so in that case the code would become even more complicated so that we had to say remove cvr from this rg parameter on slide 19 you speak of compile time vector i thought compile time dynamic memory allocation is only permitted if it's dedicated without leaving the time context but you never call in a compile-time context i think that was answered later or i think yeah i think i answered that i think so in which case would you prefer to call the printing logic directly into an operator less than instead of using formatter which is the customization point for stood format okay let's hear when we had introduced here the output operator for this type yes there's another alternative we could say we define and formatter for our own type that's pretty straightforward pretty easy to do the simple things you can do you have just need a helper function create a string out of this data and then pass it as a so-called formatter to format and then you have support and we could just call format for a coordinate c when should you do that why not i don't know if you need it often as usual if you need it often then if you have an obvious implementation so those who design this data structure might come up with a standard formatter to do that yes i would see we i support for more and more types we will see that in future depending on the success of format but i use it already a lot and i really i really wait eagerly that gcc does support format and fought it unfortunately it doesn't do it yet and because it's so much easier to print data around with field width etc so yeah i have no clearance on that if it's worth it if it's worth it it depends converting answers always it depends yeah could you please publish the code yes i will do i will tweet it and i will publish two examples or three of this code yes please look at my twitter account i will yes of course this is nice to do so i you will you will try you will see the example with the runtime computing you will see at least the final example with with card and maybe we had two other interesting versions please look at my twitter account i think nico you can take the last two questions that are new and then we you we can move to the lounge we we have a room for you is called track c so is the q a truck c in the lounge and but we have two two last questions here appearing in the q a what's a real example where the complexity of writing something like the compile time list method is worth the reduced runtime i have no idea we are discussing that so the reason we have compile time computing for vectors is we are preparing reflection we are we are preparing reflection which will come with c plus sooner or later and reflecting means that at compile time we create containers which lists for example the members of a data structure and the names and the members of the parameters etc and we decided that we want to use vectors there instead of creating our own internal compiler specific helper type and so that that's why we have this technology as well i think this the example i gave you is as close as as it could be i mean think about some more complicated computation my usual example of compile-time computing is hash values hash compute hash values at compile time and so there are some things you can do at compile time but yeah some maybe sometimes people think too much about it yeah but yeah let's see we will find out also here and [music] the last one nico is because basically you are sorting the questions from the recent ones you can you can answer it you can answer but we get then we we move to the lounge yeah is it possible for future versions to allow compiler makers to be transferred to runtime yeah we are discussing that the problem is the problem is simple a compile-time vector type might not be a runtime vector type because the runtime vector type is part of the library now if you exchange the library you have a different type for vectors and strings than the type you had at compile time that's our major problem there and i have no idea where where the clarification and discussion is about this issue that's it thank you very much i don't know yeah good now to the launch and the the name of the the table is q a truck c so other people can can follow up with you and okay so thanks a lot thanks nico thanks everyone enjoy the rest of the conference and see you these days cheers thank you bye