i feel compelled to do a coding demo today because we recently had an episode with oscar wickstrom on property testing and while it's fresh in my mind i can't resist doing a quick demo for you because there are two things i really like about property testing that i think i can demonstrate the first is it's much more thorough at testing software than human beings are it's much more thorough than i am and i like that i like giving work to a computer when it's better at the work than i am the other is that property testing has a terrific return on investment in the places where it's a good fit it does so much work for so little effort you know the bang for buck is fantastic and i think i can show that to you so my number one use case of property testing is serialization i've often got some data that i'm sending back and forth over a network probably as jason and i would like to be certain that whatever i write out i can read back so i'm going to do a demo of that with property tests so have a look here we'll start with a fresh directory and i'm going to use one of my favorite languages for this called pure script it's one of those languages that compiles to javascript it's a very nicely designed language it's got a great type system and it works really well in the browser and on the back end so it's kind of become my go-to full stack language which is great i can write one language for both sides but it does mean a lot of json wrangling so this is a really useful technique so let's get started you can skip in the chapter markers if you don't want to see the whole thing but let me install some packages first so if i do mpm install at development time i want pure script i want pure script language server which will give me lsp support and i want my favorite code format pery and then i need the build tool for pure script which is called spago i assume because it's the australian for spaghetti i'm not quite sure why it's called spago but if i download those that should give me the environment i need to write p script and i'm going to say spago and knit for a new project and that gives me a base p script project now i need some p script libraries i want to install my favorite testing library which is called spec i want to do property testing so i'll need spec quick check for that and i will also need simple json which is my favorite json serialization library and one more i think i'll get debug i think we're going to end up using the debugging tool so i can show you some extra stuff under the hood that should be enough if i do spago test that will compile all my libraries down and with a bit of luck y you should add some tests yes i really should but the tests i don't have succeeded great okay so some coding why don't i leave the test suite running in the background like that and have a look at the two default pure script libraries i've been given okay the one on the left is my main the one on the right is my test so i'm going to take everything out of main and define a new type called user and the user type is going to have a name which will be a string and an age which will be an int let's get one more primitive in let's have gender which everyone knows is a number there we go so that's the type i would like to serialize and reliably read back let's have a look in my unit tests i want to describe a test suite that says json round trips always work and then i want to say we're testing main user in real code i tighten up some of these labels but for the demo that is fine my test is going to look like this i'm going to say it's the property testing library why don't you go away and give me a user which has the type user that i've already defined on the left i'm not going to tell you how to do it just go away and generate me a random user and then with that user i ought to be able to say no matter what user you give me if i write that user out as json and then i read that back as jason the thing i get back should be exactly equal to the original user right that's the definition of proper serialization so how do we make that actually work that's the shape i need to do a bit of tightening before this will actually execute so the first thing is that describes a test suite to actually run it there's some magic words you need to say to run the test suite this is in the documentation for the spec library say launch a run spec with a console reporter like that that should do it and then the other thing is writing jason always produces a string reading jason could say well i couldn't read it there was a serialization error so i need to say either this was like successfully decoded as a user or it was an error message right i need to do something like that it's going to come back wrapped in some kind of error or not structure and the name for that in pure script is write so i need to wrap it in a right constructure which you can read as like okay or success that's pure script syntax going to try and go light on that so we can see the shape of things with that i'll just do the code formatter over it and let's just see see if we can get this to compile and i'm probably going to go through an import dance here let me race through that hopefully it won't take too long if it does i'll fast forward but if you're hearing this it didn't take too long and i think it's nice to see the entire process so let me just import all of these yep almost there as we go through this can kind of see how the abstract syntax tree is constructed yeah there we go okay so that test compiles i just take out that warning let's have a look at the test suite json roundtrips always work main user one test passed it works but i don't think on its own that's very convincing so let me do this i said we probably want to use the debugging library if i do import debugs spy this is a very useful p script function i can wrap this right json call and i can change this so it says take the user write it as json but before you do anything else let's just have a peak let's have a cheeky peek at the raw json if i write that then the test case runs and it's much more convincing i think you can see here we're generating loads of different unit test cases all practically for free we've got name we've got genders we've got ages we've got those corner cases like empty names or negative ages or utf16 characters in the name or unprintable characters in the name all sorts of stuff and it's just testing i think it's testing about a 100 it's tunable i think it's a 100 out of the box a 100 different users randomly generated and checked that they serialize in both directions that's a pretty good test that's a lot of work for four i'm going to call that four lines of actual test code that's cool but i think we can go further i think we can go further with this so let me come along a couple of weeks later in this project and say actually we need a new field on users we're going to keep track of whether someone's an adult and i'm going to add in a boolean how much work do i need to do to bring my test suite back up to spec if i write this file absolutely none i get all the generation of the new kind of user and all the serialization tests absolutely for free i think that's cool but we can go even further than that so if i now define a new type called let's say department and a department consists of a title for the department which is a primitive string and some members of the department which is an array of user so we've got all the things in here we've got primitive string a collection of a custom type and now i'll go over here i'll copy and paste that user test and i will say change all the users for department y so i got four new testing lines i could abstract this out into a helper function i won't for this video i won't yet but in real code i probably would now if i write that and make sure i've imported department and make sure i've written both files so i can import department there we go now look at that i've got department tests too and they all serialize nicely and i'm starting to get random things like emojis in there and what else have we got and interesting things like the edge case where there are no members or lots of members or one member or exotic characters in the title all all that stuff completely for free and i can keep rerunning it and get more test cases and it's fast it's generating loads of different data and checking that they all will serialize successfully that makes me a lot more confident than a handful of handwritten unit tests i like that let's just do one more thing to drive the point home so i am going to now come along and say users were more complicated than we think gender isn't a number it's much more complex than that it's a complex time ty and a complex type as you will know contains a real part and an imaginary part and so i've now made the subtype more complex i don't have any testing for that will i once again get all my updated tests for free yes i will and there we go gender is now a real number and an imaginary number and it's all mixed in there all for free all vastly more complicated and vastly more thorough unit tests than i would ever write by hand and that to me is the magic of property testing a little bit of test code that pulls a lot of weight and sometimes the maintenance of it is cheap and it's often completely free i think that's compelling and that's all i wanted to show you if you liked it click like if lots of you like it then we'll do more coding videos and if you'd like to know how you can take the idea of property testing much much further in much more hairy situations as i say we did a deep dive interview with oscar wickstrom recently there'll be a link to that showing up somewhere on screen now and he goes into some really nice strategies for property testing so i'll leave you with him thanks for listening