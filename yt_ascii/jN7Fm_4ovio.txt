the raspberry pi is a small single board computer built by the raspberry pi foundation out of the uk the pi has become a fan favorite for developers in the maker space doing embedded development now in my previous tutorials i had done many examples on how to do bare metal programming on the raspberry pi pico a sister board to the raspberry pi based off of the rp2040 arm processor in this video i'll be showing you guys how to do direct to register programming and arm assembly on the raspberry pi to blink an led on and off before we get started i wanted to start off by thanking my patreon supporters listed here also to be kept up to date on more low-level content follow me on twitter twitch and come hang out in our discord now to program our pi on bare metal we'll need a few things first we'll consult the data sheet for our raspberry pi's processor to identify where the gpio or general purpose in and out bus lives the gpio bus is the interface we'll use to directly control pins on the processor to blink the led in direct to register programming we write directly to physical addresses on the processor to make things physically happen so here we see the physical address of the base of the gpio interface by writing directly to these addresses we'll be controlling the output of the pins when doing direct register programming it's easiest to have the data sheet for the chip that you're programming at hand the datasheet will have the addresses of various other features of the processor details on how to use them and other useful tidbits that may save you time it is important to note here that while this is a specified address due to memory mapping and other funky embedded considerations the actual base address of the gpio interface is this address here ox3f2000 now now that we have all this information mapped out what do we do with it well we can go into our development environment and set up a project just like any of our other arm assembly tutorials we've done before first we create a makefile that produces a flat binary image with our code in it here we invoke the assembler to put our assembly together the linker to link the assembly together and then we call object copy to copy the flat binary information out of the elf and then we call it kernel seven dot image kernel seven dot image is the name the raspberry pi uses to boot the image into flash when the raspberry pi turns on it will read this image off of the sd card and like usual we set up our underscore global start to denote where the code begins making start a global exports it so that the linker knows how to construct the elf file now moving on we're going to define a few constants to keep our code simple the first constant we'll be using is the base address of the gpio interface as mentioned before the datasheet may be reporting this address but it's actually going to be ox3f2000 now to access the rest of the gpio structure in memory we'll be referencing the rest of the structure as offsets into the base address so for example we'll use numbers like 4 8 etc and add them to this base address to read or write into the rest of the structure later in memory here we set our first constant to represent the base address of the structure which again is a previously mentioned address from the datasheet next we need to set our pin to gpio mode in this example i'll be using pin 21 and that pin will be an output so we'll need to make the pin set as an output in this gpio structure to do this we'll need to put a value into f cell 2 or function select 2 which lives at offset 8 from the base address of our structure again all this information on addresses and values comes directly from the data sheet for our example again we'll be using pin 21 so to set pin 21 as an output we need to set f cell 2 bits 5 through 3 to 0 0 1 or 3. this translates to setting f cell 2 to the value 8. now that we've set the mode of the pin we'll need to actually control it ie turn the pin on and off to do this we'll use the gpio set and gpio clear addresses which limit offset hex 1c and hex28 from the base address of the structure respectively to use them to turn the pin on and off we write the bit position of the pin number we want to control so because we want to control pin 21 we'll set bitposition 21 onto either of those registers to control it to do this we'll write the following value or one left shifted by 21 to gpio set or clear we want to control the pin now we need to write some code first we need to load the base address of our structure into a register again we'll be using this to reference off of to store values to control the pi next we load up the value for gpio21 output to make pin 21 and output and store that value into the gpio function select to register for those of you that are new to arm assembly the syntax of that instruction is store the value in r1 to the address stored by r0 offset by some number so that ends up turning into store into the gpio base plus the offset 8 the value 8. after this line of code executes pin 21 is set as an output pin on the raspberry pi next we will set up a counter this register will be used to hold a high value that the processor will count up to to create a delay now we create a loop this loop will run forever to run our blink program here we load up the gpio valve to enable pin 21 and store it in the gpio set register doing this turns on the led now the led is turned on we have to delay the delay is done by clearing out a counter register and counting up to that high value stored register 2 when they are the same we continue here we can copy and paste the rest of the code and just modify the destination register to instead of setting the led we clear the led and change the name of the label to reduce duplication and then finally we jump back to the top of the loop and start over again this will run our code forever so really quick let's summarize the code we just wrote here we load the base address of the gpio structure into r0 here we set the pin as an output here we make our counter then inside of our loop we turn on the led by setting pin 21 to gpf set 0. then we clear out a counter and we count up to our large number in r2 as a delay to keep the led on then we do the exact same thing but instead of writing the gpio set we put it in gpio clear now after fighting through a couple sets of compiler errors the assembler was not happy with where i put some commas and how i commented on my code but after fighting through some of that i'm able to get my code to compile by typing make we are able to see that the program produces our kernel 7 image and we can use that put it onto our sd card put it into our raspberry pi and i'll show you guys how to set up the circuit so that you can see your code actually run all right guys and as promised here is my raspberry pi setup for the video the yellow cord there is on pin 21 yellow cord comes out and goes to a resistor for the led the led then goes out to another yellow cord which is hooked up to a white cord that goes to the ground pin there so the circuit is just pretty simple pin 21 resistor led ground and now we'll play the video and on the sd card i put that kernel 7 image and put it into the raspberry pi plugged in the usb cord and here we go the led is blinking and our code is running well guys that is it i hope you enjoyed this video i hope this video made it really apparent that direct register programming is available on pretty much any platform that you have and learning to do it is as simple as consulting the data sheet and figuring out where the different peripherals live in memory and figuring out what the appropriate convention is to write to them if you did enjoy this video and you learned something do me a favor hit that like button hit subscribe and i will see you guys in the next video probably in the next week or so so thank you very much for watching take care see you guys [music] you