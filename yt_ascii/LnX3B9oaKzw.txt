functional programming is essentially kind of programming where functions don't have side effects so what does it mean when you call a function you give it some inputs? and it will return some output and that's all that it does it doesn't modify the inputs it doesn't do something on the side people often talk about firing the missiles it can't do that the entire behavior of the function you can see by [looking] at what the inputs were and what the apple was that was generated and if you [program] [in] that style, then functions are you know you know a lot [about] their behavior and many of the mistakes that are easy to make when you program in more conventional programming languages is that [you] forget about some effects that a function has in addition to returning its result and what you forget about those effects then they can lead to very difficult to find bugs and a lot of wasted time? what did i get used for these languages? quite a variety of things they've made a lot of impact on the server side of internet applications. so for example haskell which is the language that i played a part in designing. that's now used for all the spam filtering on facebook now when i heard that first of all i said, i didn't think there was spam on facebook and sally marlowe, the man is now in charge of this said to me exactly that's how good we [are] all of that is running in haskell nowadays another example would be airline that's another functional [programming] [language] which i'm working with a lot at the moment [and] airline was used to implement. whatsapp always everybody uses whatsapp at some point that's all airline code running behind it there are other examples twitter's code is built using scala which is a programming language that i think was heavily inspired by haskell, but integrates very well with java and but it's also mostly functional and so you know many of the services that we use [everyday] are actually running functional code in the background you've just mentioned then you had a hand in the development of haskell. where did you start? [did] you have a big team that you weren't where tell me about that? oh? so that was interesting and so when i first got in functional programming there were small number of people working on it at different universities around the world and in those days you couldn't really get hold of a functional programming language from somewhere else you had to write your own compiler so many of us around the [world] were doing that and then after [a] while we realized and it was a man called paul [hugh] deck yale university took the first initiative to this we realized that we were all working with very much the same kind of programming language but because we each had our own compiler. we couldn't share any code we couldn't share our results and that just seemed [like] a waste of effort so that led to the proposal [tooned] just take the common core [of] what we were all doing put it together and [designer] a programming language that we all use which became haskell what where did the name come from then? it's actually named after haskell curry who was one of the early logicians who work with with lambda calculus the first time that the committee that was formed designed the language got together? then we decided we had to choose a name and nobody really knew [what] to choose so we everybody was allowed to write up one proposal on the blackboard and then everybody was allowed to go round and cross off one proposal now you might think that we would end up with zero names that way, but no there was one name that survived and it was curry named after haskell curry so that was fine. we thought okay the new language will be called curry and this is last thing in the evening. so we all went to bed which meant we had a chance to sleep on it and next morning one of us realized that one of the abstract machines that was very popular at that time was called the tim tim curry oh dear [that] [wouldn't] be good and so we decided to call it haskell instead, so it's still named after haskell curry but his first name rather than second from what i've [seen] when you look at a functional program it is very much like a mathematical equation am [i] right with that. yes, that's right. so one of the things is that like mathematics functional programs will satisfy what we call laws for example in mathematics if you see x plus y you can always replace it by y plus x if that's more convenient and in functional programs then very often you may be able to replace one program by another so you have different ways of expressing the same thing and you can replace one by the other which you may want to do because one of them may be much more efficient than the other and you know that that replacement will not change the overall behavior of your program and so we find that these laws extremely important for reasoning about programs and they can let you rewrite your program quite freely in order to try and improve its performance for example and be sure that you're not introducing bugs [i'm] assuming that the same kind of mechanics are happening somewhere at some level on the computers with any other programming language though is a [repeal] for this is it slow is it faster. what's that? what's the deal? oh, well, so functional programming languages take care of a lot [of] the implementation details that an older programming languages you have to do manually for example memory management but nowadays it's very popular to use languages like even java for example which builds memory management into the programming language functional languages do that too very often there is some kind of performance penalty for this and that has meant that one of the very active parts of functional programming research has been developing compilers that [can] give good performance despite the fact that you're programming at a higher level nowadays code written and functional languages can be as fast as or sometimes faster than code written in conventional programming languages one of the very nice benefits of functional program by the way is that it's always safe to evaluate two independent expressions in parallel and that's because functions have no side effects so you can all the functions going to do is convert inputs to outputs and you can have two of those computations going on at the same time they cannot interfere whereas if you use programming languages in which each function may be modifying data somewhere else at the same time then you can't tell whether or not two functions will interfere they're very likely to and that means that when you want to make programs run in parallel when you want to make them use more than one of the cores in your laptop then it's much easier to do that if you start with a functional program and that can give a performance benefit over and above what conventional programming languages have i've heard as well? there is [a] possibility to make hack-proof code using functional programming is that something you could tell me about or yes, so there is a lot of work in trying to make of the cannot be hacked of for example. can't leak confidential data and there are people who are working on programming languages that will provide some guarantees about that one of the quite successful approaches is to build a library into haskell in fact that can be used for enforcing in particular privacy constraints so yes, there's work [going] on in [that] area we're going to talk about things like your quick check and you know that we've already filmed some stuff on that and what do you up to? what do you do? what's what's next for you? so i'm devoting most of my time to quick check nowadays where the basic idea is not to write tests by hand because because basically it doesn't work software is so complex that to make sure there are no bugs in it you have to try all kinds of weird combinations, and there are just too many combinations to try for people to be able to try them all so really the only way to ensure that you avoid these bugs is to generate tests instead that's what quick check does it lets you write test code that says what your program [should] do and then it generates as many tests as you want to check that it does and i've been working with quick check for many years now [10] years ago i founded a company that is commercializing quick check and that's been huge fun because it means i get [to] apply this technology to all of real problems all kinds [of] different kinds of software, and that's been a huge learning experience for me and a tremendous source of research problems when we find oh, it's hard to apply it in this case well there's a research [property] to solve so [as] a professor and a researcher it's given me all kinds of new ideas for problems to work on which which has been very very stimulating and the value of y at this position is going to be some polynomial that we have to find which is a x cubed plus [be] x squared plus c. x plus d. there are four unknowns here x we know because we're going between no [1] 1