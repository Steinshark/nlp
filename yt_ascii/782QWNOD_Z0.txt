let's just see how we would add together two floating point numbers if we've got 42 and so in floating point representation that would be 100 100 100 times 2 to the 1 2 3 4 5 so let's add on 6 so 1 1 o is 6 and that's times 2 to the 2 so we now need to add these two numbers together now before we would just add them together by going that was that that was that that plus that that's it. we can't do that with floating point numbers because the bit patterns for these things being that these are going to look like very very different things what we have to do is first of all line them up to the bits in the same place. so we need to shift this one down so that the bit here which represents 4 is in the same position as the bit that represents 4 here and so the number of spacing we need to shift this right is a difference between the big one and the little one in this case. it's three places. so 1 2 3 spaces so we shift it 3 spaces to the right and so the first that was rather than just adding them together. we have a step. now what we've got to expand them out of the bit representations because remember that this would actually be 0 1 which is encoded 0 1 0 1 0 and this the 8 bit exponent this is going to be what 127 plus 5 which is 128 plus 4 so that's going to be 1 0 0 one zero zero so it's gonna be something like that so we've got that so that's what that's represented by and this one is going to be similar it's going to be represented by zero. we've got one two, three, four, five six seven eight bits the ones already encoded implicitly zero and zeros down there ignore them for now and we're gonna store. this is 1 0 0 0 0 0 1 so the numbers were actually got in memory in our computer are represented like this so the first thing we have to do is get them to a point we can and we can't just add these two numbers together anymore and we can see that they're simply by looking over here if we had 1 + 1 we'd get 1 0 z answer which mean with the answer to have a 1 here which means something go from positive numbers to any negative number which is definitely wrong. so we need to unpack this representation into a form that we can add together now one way we could do that is just work out how many bits we would need and assign the bits into the right place and do that, but we can actually use some sort of tricks we know for example if we're adding two numbers together with a certain number of bits in this case 24 bits the biggest number that we could add two numbers together and get a result would have a value of two it roughly around two to the 25 the other thing we know is one of these numbers going to have a greater exponent than the other so what we can do is we could say, okay let's keep that one where it is and shift this one or divide this one by two so that the exponent on it would be the same. so if we shift this one place to the left we'd end it was this a zero point one times two to the three another place to the left it would be zero point and so on times two to the four until we end up with that one lined up there and that becomes times two to the five and then we have zero zero point two zero zero 1 there so we did the first step. we need to unpack them from the representations into forms that we can add together and then we need to shift this one so that the exponents are the same. so we take the smaller one and shift it so the exponents alanya now we can add those numbers together so we can now add these because locally we can produce a number one bit bigger than this if we add them together one plus one is two for example. so 0 plus 0 is 0 1 plus 1 is 0 carry 1 0 plus 1 plus 1 is 0 carry 1 1 plus 1 is 0 carry 1 0 plus 0 plus 1 is 1 1 2 to the 5 and then we ended up here times 2 to the 5 as already 6 on to 42 and i've got 48 as a result. so he's done the maps and i could write that back now, but potentially we could have ended up with a 2 here if we added up 1 and 1 for example would get 2 and so we need to do a final step once we've done the addition which is to normalize this back potentially into the normal form which in this case would be 1 point 1 0 0 0 0 times 2 to the 5 so the reason that floating point numbers take much longer to process is that as well as doing the addition which you can do in exactly the same way? you also have to take the bits unpack them from the representation shift them along so they match up things then do the addition and then potentially shift them back to get it back into the normalized form the standard scientific representation the other problem you get is even though we can pack all these numbers into 32 bits the representation when we slide them along we may end up needing more than 32 bits as many as 48 to represent things because if we have to slide this one along to the point here when we're doing the maps that we actually need 48 bits to do the calculation of course that means you don't have to do on the 32 bit cp you've two additions for that half and then that half and carry the value over from one to the other which again would slow things down in hardware, you can build your representations to take care of this if you've got 64 bit doubles you know that you perhaps don't need more than certain number of bits to represent you and you can build the hardware to take all this and it ends up being much faster that must be quite fiddly to do with standard hardware so is that why we end up with this custom hardware this floating-point unit. it's not most much fiddly. i mean most computers preserve the carry when they add two bradleys together so if you had two 32-bit numbers that produces value greater than 32 bits they preserve that bit and let you add it on so you can use multiple registers to do it but you just have to then do two operations to add operations one after the other if you know the operations are going to do this you can build your hardware to do that in one go so we could build hardware that would add these together there are lots of things you can spot where you could early out so for example, if the exponent was such that these end up so far apart that you know adding this onto this where there's all zero bits along here assumed isn't going to make any difference to this you can say, well actually i don't need to do that i'm just ignore it. if you know the number zero you can ignore it and so on so there's this ways you can speed things up when writing the software and i suspect the hardware just some of the things although probably isn't lead to the interesting thing if you think about the way the mathematics work unlike integer numbers where multiplying integer numbers is trickier than addition because you end up having to do lots of shifts and adds into the different things multiplying to floating point numbers is relatively straightforward compared to addition because we just have to multiply the two mantises adding the extra bit back in if it's there and then add the exponents together so multiplication actually becomes much simpler to do with floating point numbers and addition because the addition requires us to unpack everything and push the bits around to get things in the right place now i've got the token so i can load a value in add the valley from register into it and store it back and hand the token and now i've got the token again i can load something into it into my register add something onto it so it back and pass the take it on and i've got it so i can load the value in add the value from a register story back