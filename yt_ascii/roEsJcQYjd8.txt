one of the areas of computing that i'm really curious about and i think the software world has a lot to learn from is game programming i mean probably not on a surface level i've never worked for an e-commerce company that needed collision detection but get below that surface and a lot of modern games especially once they go multiplayer they're dealing with things like global networking issues multi-user concurrency competitive concurrency massive data volumes under brutal latency requirements they have a lot of the programming issues that we're familiar with but under much harsher conditions and being a somewhat separate world they tend to approach the solution from a novel angle so this week we're going to go digging for system design ideas in the gaming world and my guest for this is tyler clutier he's got a background in distributed systems and data science for the gaming industry and he's currently building bitcraze multiplayer open world game and to support it a really interesting flavor of database called spacetime db from which we're going to mine some ideas about concurrency transactions data security query management lots more a lot of juicy ideas solved from an angle that i'd never considered so let's get going i'm your host chris jenkins this is developer voices and today's voice is tyler clutier my guest this week is tyler clutier how you doing tyler i'm doing well how are you i'm very well i'm you're going to take me to a new world for me because i have a long history in programming but one thing i've never done is computer game programming and along with that the one thing i've always wondered is they must have a lot of the same problems that the rest of us industrial programmers have not like they're dealing with graphics and story and stuff but then there are data problems everywhere right that's right actually i would say what i have experienced is that they have the normal problems that everybody else has but times 100 because not only do they have to build the thing but it has to interact with all of it the data in the program besides just sort of individual parts and then it has to go really really fast yeah yeah all our problems except at 60 times a second that's right yeah so your background is originally in game design or data science for games or what's your origin story my original background is actually in chemical and biomolecular engineering which is clearly unrelated to games and then i did my masters in computer science focusing on distributed systems and machine learning okay after that i i did some time at bloomberg and then apple and then a company called machine zone which is a game development company right and what did you do for them so there i worked in their data science and engineering department as a data science engineer and there we were building two things one pipelines for data so making sure that we got the real live data as quickly as possible into a form that we could then feed into our mod models so then the second part of what i did is also build those models which predicted various things about how players are likely to behave so like how likely is this player to turn how likely is this player to spend money will they give us a good review that kind of thing this is a payto playay game this is a free-to-play game actually that is quite expensive ultimately because it's the business model where like most players don't pay anything but some pay for like cosmetics up upgrades that kind of thing and they spend a lot no no it's much worse than that so it's a mobile game and it's the the whole idea of the game is it's supposed to simulate what it feels like to be a king and so what that ends up being is that you have this little city it's called a 4x game which is for the four different types of play that you're going to do and you build the city up you upgrade your buildings and then you can start sending march out to attack other players and ultimately you want to capture a what's called a wonder which will give make you the king of the kingdom and right the process of capturing that wonder is quite an expensive endeavor so the way it works is that they sell you speed ups so upgrades take time you can speed things up by paying for it and some people pay quite a lot there were individuals who spent upwards of several million in that game several you heard that correct if i if i did not see it myself i would not have believed it gee i can't i struggle to compute why someone would do that and how they can be rich enough that that's their disposable income there were saudi princes there were people of that kind i mean it was a global game and so it attracted a lot of people who were interested in simulating what it felt like to be a king there was one person who was rumored to have hired at least one person or a team of people to actually purchase and open the packs because it's actually mechanically a lot of work to open $1 million worth of a $100 packs right that's 10,000 that's 10,000 packs so there's that there was another person who used to fly his entire alliance out to the las to las vegas to be closer to the servers so that they could do the super wonder event more effectively that's i mean a that's really weird but b is it that much weirder than traders putting their computers right by their main exchange i don't know i don't i suppose not i mean these people really cared about the game the the i i asked players you know why are you so interested in this game and i remember one told me i a security guard at a place or something to that effect and i just sat there all day and i downloaded this just to pass the time but over time i found that i had like real actual friends in this game and when i would log on they'd say oh my god this person's here and he felt like somebody whereas in real life he did not really feel like someone and that that was important to him okay i can see that but okay so curious game mechanics but that's not why i want to talk to you the the the thing that's the reason i get into that is because you're there clearly in a background where there's serious amounts of data coming in live and serious money it to be made in understanding the flow of that data certainly yep tell me about that and how it led into what you did next sure so now this is an interesting story because it's sort of obliquely leads into what we actually ended up building because certainly my time at machine zone inspired it but it's not the way i would explain exactly what we're doing but let me tell you i suppose the origin story so while i was at machine zone always we wanted historical data so we wanted to know not only this is the current power of this individual or this is the current set of items that they have but what is the full history of what they have so we can predict for example hey look this person was attacked they got zeroed out and now they left the game and they're not likely to come back we always want to know that data and machine zone didn't have that data because the traditional infrastructure of companies is to have their game data or their really website data in normal relational databases like in this case i believe it was my sql right and the problem is when you update someone's power in those databases the old power goes away so you need to have some kind of a way to actually get that historical data and what they started to do was they were snapshotting their databases every 12 hours and we would then get that snapshot data and we try and piece together a historical data but that was very sad for two reasons the first reason is that the data itself was awful because a lot can happen in 12 hours that could cause you to leave the game right so you don't really have that information and i should also say there was another stream of data which was just event data but it was very loosey goosey event data that was sort of whatever people had slapped together right so you tried to build up a picture of what had happened historically from these two sources and the other reason the snapshotting data was bad was that it was enormous because if you think about it 99% of the data in a database does not change in 12 hours if 99% of your players have churned you're just copying this old data every 12 hours and so eventually they had to purge the old data so they couldn't keep it forever right and they spent millions of dollarss trying to clean up this data and get it into a form we built a system which was on based on the lambda architecture and if you're not familiar with how the lambda architecture works you entally set up a streaming part of your data data pipeline and you set up a sort of a batch part of your data pipeline and you try to weave those two together so you might put all of your big well-formed data in hive which is a a right pendon database made by facebook for large data and then you would have like something like flink or aache spark taking your real-time data and trying to make decisions based on that and and bringing it in with your batch process data as well yeah there's a huge amount of work and i would say 95% of the data science was actually just getting the data into the right form in the right place at the right time yeah familiar statement that span way past gaming right absolutely so when we began to build our own game i decided i'm not going to have it we are going to have the full history of the data so i want to be able to go back to any point in time and actually see what the game state was but more than that i want to actually be able to replay it at that time so that you could hop into the game at that time and actually see it being replayed on that level of granity on that level of granularity right so you're not just storing events but like player thumb stick movements and stuff correct and actually i saw on an earlier podcast that you had i think it was maybe two weeks ago you're were talking about event streaming and the guest there said at the end you know this doesn't always work for for everything it doesn't work for example for games and i thought aha how how wrong you are in fact this is exact what we're doing so event sourcing is is essentially what space dv does okay that's colossal amounts of data very widely distributed user base high response times required because you've got to deal with things 60 frames a second ideally that's a big challenge how do you start to break that down into something what's your approach let i think the best place to start is to first understand what the game is that we're trying to build and then from that you can see why space sb is is a necessary requirement so we have two products we have a game called bigcraft online which is a massively multiplayer online role playing game you can sort of think of it as like a combination between runescape if you're familiar with that and minecraft so there's this very long-term skilling and progression in game but at the same time you can actually change and edit the world and build your own things within the world right so that's the game that we set out to build and in order to do that notably the first thing you you think is well we need to put everybody in a single world logically because you can't have people occupying the same space in the way that you could in a normal mmpg because they actually are editing the world so if i was a normal mmpg i put many many instances all in the same city right doesn't matter yeah in our game it certainly does because you actually need to do that so now you have a very interesting distributed systems challenge on your hands yeah you've got a large global mutable state correct and it has to be persistent so if your servers crash people want to have their buildings that they spent their time building and stuff like that yeah yeah so that's that's the first thing you have to understand about how we came at this problem and so in order to do that we realized okay well we need a system which is built around the persistence right because if we're going to be making these permanent changes to the world and it is everywhere either we're going to be doing the normal architecture of games which i'll take a brief aside to explain so the normal architecture is you have a game server you'd have your databases the game server itself unlike a web server would have quite a bit of state right and you at period at periodic times or when people did important events would write to the database with a transaction and then you you get that back but you as the developer are doing a lot of work to maintain i suppose synchronicity between your database and your game server state because for example if i kill an enemy yeah there's a lot of there's a lot of things you can do that make things u pretty crazy but if i kill an enemy that enemy is probably not their position is probably not stored in the database but they that there was an enemy might be or that you picked up items probably is because as soon as you enters your inventory you don't want to lose that yeah or you could do it periodically and then they could do replays and stuff what you end up getting to is a place where you're spending a lot of your time as the game developer not thinking about the actual gameplay programming and rather thinking about the distributed system environment in which you're actually building this game yeah i can believe that so what we decided to do is say we are going to make that all i suppose opaque to the to the game developer and we're going to put them in a context where they're operating inside a transaction already that transaction is going to be manipulating in memory data and then we are going to do all of the necessary things to persist that data to dis so that the game playay programmer does not have to think about that at all what's that look like for the programmer they just they're treating their local client side instance as though it's a relational database is this what you're saying i that is one consequence but the the main point of what i'm saying is that on the server all things inside of bigcraft happen within a database so let me explain just a little bit about about how space time db works and what it is actually so we we built this game and we wanted to do this in this way so we built a system called space time db which is fundamentally a database so it's it's very focused on on persistence the way it works is you take bitra you compile it to a web assembly module you upload that into the database and then clients connect directly to the database and now i hear a lot of people in the audience screaming oh you can't do that you couldn't do that and it maybe was a bad idea for databases like postgress and so forth but we have built a permissions model around spacetime tob that allows you to do that safely and so the way that works is you as a client call what we call reducers on the database they're very similar to store procedures okay and then those store procedures which are written in whatever language you want that compiles to web assembly will access things from the database and write them back to the database so just as an example let's say we had player move and notably everything in bigcraft including all the player movement all the chat all the trees all the ground everything is stored within the database so if we want to move a player what we do is we call a reducer called move player on the server that updates some rows in the database and then commits those rows and that's it then clients other clients will subscribe to the database state so they'll say i want to select star from player position where they are near me basically would be what that where clause would say and then all connected clients that have subscribed to that when that player moves will hear about those rows and their updates and then automatically updated in the in the database i'm sorry on their local client so hang on where is the database the database is on a server stored in this case i believe in new york okay so how on earth does that possibly work when i'm moving and expecting things to update 60 times a second so okay this is the first thing that's interesting about games you would not have a tick rate on the server that's 60 times per second unless you were making a game like counter strike so typically i'll give you sort of a range u minecraft updates 20 times per second so every 50 milliseconds runescape updates i believe four times a second so every quarter of a second so it's there's a variety of of different levels that you can do generally speaking the larger your game is obviously the the fewer updates per second you want to be doing because there's so many entities to move within a within a time frame yeah but i mean i'm in london i'm not sure i can guarantee four frames a second to you york come back i see so i understand your question now with any game like this you do not wait for the round trip so how long would the round trip be from new york to london i actually happen to know it's about 80 milliseconds or 70 milliseconds something there about so it's it's actually not crazy you can you can play it without what's called client side prediction but the typical way that you would actually do this is you' run client side prediction what does that mean that means that i as a client have some subset of the server state and when a player my player decides to do something i can predict what the server is going to do to my local state assuming that it will work so based on the state of the world as i know it yeah if i try to move i should be able to update my local state assuming the server will agree with me and so i will do that and then i will immediately see the results of that on my own local client but i will send something to the server now if the server agrees we basically come back we reconcile st no problem if the server disagrees let's say somebody exploded a bomb that your client hadn't heard about yet right right on top of you and the thing you try to do is invalidated by that maybe you're dead now yeah what will happen is you will have sent a request to the server that says i want to move the server interjects and says actually you died what will happen is your client will say oh i understand it will roll back to the point which you were going to move and it will then play forward the updates as they actually happen from the server and then try to replay your move so it would go originally before you heard about from the server it would go you're standing here you move you actually move then what happens is you hear about the bomb you roll back to the point at which you were about to move you then blow up because of the bomb and then you find out then at that point you try to move but you can't move because you're dead right and that's how that reconciles this sounds very like transaction on the client side yes it does so is there a database on the client side well i believe basically everything is a database i have more i could talk about that but essentially yes although typically people don't think of it that way so typically the way that people think about it first of all in games is with a tick so on the client you would have a frame essentially that happens they would call it like a server frame if it's not the actual render frame so the render frame always happens at 60 frames per second or sometimes now like 120 or 144 or whatever your monitor actually has yeah a server frame typically doesn't go beyond 60 frames per second and it assumes there's a loop and basically we're going to update all the state once a frame spacetime dv actually doesn't make that assumption you can do that with spacetime dv but it's not a requirement so i'll just say that and there's latency versus throughput tradeoffs with that that's essentially what that that will end up right because if you have something tiing 60 frames per second the minimum latency that you can have is one 60th of 1 second because it could you could have the wrong time you could have tried to do something just as the frame was starting and now you have to wait the full frame time before you actually that effect is applied right yeah so now you asked is the is the client a database what is happening on the client is there's really two ways of doing it and so i want to be careful in the one way of doing it the client has a deterministic simulation of the game world so that means that all of the inputs that are that are going to manipulate the game state are being sent to the server and replicate out to the clients those clients then receive that input and then they run the game forward a little bit like one frame and they'll find out what actually has changed in the game state and they move their state forward that requires having total knowledge of all of the state because if you don't have total knowledge you're you're non-deterministic because you no longer know what you don't know you don't know that that bomb might come in from from out outside and actually oh yeah if you want total knowledge you have to have the entire world so you can see over the horizon this yes this type of server synchronization really only happens with match based games so games with a sort of small state so like league of legends that kind of thing okay or like rtss kind of which is sort of another match based game where the inputs are quite simple but the outputs are quite complex so you might click here to move a group of guys but 500 guys might move and so that's actually a lot of data to say where all the positions of them are but you don't have to do that you just have to replicate i clicked here or this player clicked here and thus when i play my deterministic simulation forward all the guys will move within my simulation i don't have to communicate that data over the network okay yeah i can see that so that's one way of doing it for mmos part of the reason they're so difficult is you can't do that because i cannot possibly have the total state of the world on my client it's too big sort of fundamentally by by design i can't put the whole of world world of warcraft and all its players on every single machine correct alas you cannot so instead what they do is typically the way this would work is you have your game server that game server knows what a game client is and when they connect they know where the player is and they have a bunch of special logic to say okay i know where this player is i know what they need i'm going to send down that data to the client and then i'm going to send down that data to the client uh let's say once a frame so so every frame i will compute okay what has changed on the server and i'm going to send a bunch of messages down saying these are the new positions of of all the players that's the typical way of doing it now notably this means that you have baked in what your client wants to know about into your server code because you as the server need to know what they need to know because you're going to do this streaming update to them yeah so it's more complex than for for example let's say a web site with a graphql query because with a graphql query you can say oh i'm this kind of client and i want to know all about this data and i'm this kind of client and i want to know about this data but because games are streaming and they need to go fast and they have this tick based thing built into it historically people have built them so that you write all the code for synchronizing the clients and you build in some concepts like you probably build in the concept of positions and of players and that players want to know about things that are around them and all of that good stuff so if you were to then go build an ai that doesn't care about where certain players are maybe it's trying to regrow the trees or something and it wants to listen to the data no can do you've already built in the particular query that that wants to be done on that game server state right so so we're inverting the control so the server the server knows what kind of things you would want and pushes those to you correct that really bakes in the the server then has to have very fixed ideas about what kind of people connect and what they might want to do absolutely correct what space time does is the opposite we actually treat it sort of from a formal database perspective and say actually clients are just going to write queries which they're which are going to be executed with a query engine in a subscription-based streaming way so first we connect and we send a query and we say i want to listen to all of these players in this region or whatever we are interested in and then that data will be incrementally stream down so as the data changes in the database we compute that query for all the subscribed things and we send it down to their clients then you can think of their clients as having a replica of the server database now that replica is a subset of the data and it is only prefix consistent so it's not strongly consistent you what do you mean by prefixed consistent you have the database state as it existed at some point in time in the past so you have all of the updates in a prefix of the message log if or of the of the right ahead log okay up to a certain point that's what i mean now it's a subset so it's not i have the whole database i have some set of the data as it was in time so it's not eventually consistent yeah correct i don't see any weird things about it i will see the database state as it was maybe like 5 milliseconds ago or if i'm far away 100 milliseconds ago right yeah and so what that allows us to do is then you can query your local database as though it were the actual database and so you can get this this information out from your local database much more conveniently and faster than you might otherwise do in a normal game server you'll forgive me being really boring here but i'm translating this into a non-gaming world and i can see i can imagine i i as a as a client of let's say client of a bankor trading platform i might want to have all the data relating to my accounts and maybe some of my counter parties but not the entire bank's data and then i want to be able to optimistically make transactions on that data they get sent back to the central server and i get told if that worked but i can progress as though it did yes and that would be exactly the same architecture we're talking about in the gaming world 100% yes so what we are in s sense trying to do is unify across both of those things a lot of people and why why is that important because many people have tried to make a a game service game server backend kind of thing like an like a a game engine but for the server right yeah so there's unity you got unreal wouldn't it be nice if somebody made that for the back end the problem that people have is that when you think about what a game is on the client it's the same across all games if i'm playing chess or solit what i want to do on the client is very similar to what i want to do in world of warcraft right let's say i'm making a 3d solitare right i am rendering objects on a screen and all i have all of that stuff it's all kind of the same across both both games right i want to render a 3d world i want a loop that applies some logic to the state of that world and then i want to yes and i want to turn it into 3d objects and i want to project them onto a screen and i want to do lighting effects and i want to do sound effects and i want to do all of that every game from the client perspective is not identical but they are they rhyme they have a lot in common that an engine could do that we don't have to write over and over and over again essentially yeah yeah on the server if you think about what check versus world of warcraft is those architectures are they share nothing they're they're they might as well one is like a web app kind of right like a chess move i could build that with a web server in node.js and all that and the other one is a very complex multi-user fast move fast changing state thing which synchronizes data persistently the database and updates positions and all of that so what we're trying to do in some sense with spacetime db is close over all of those things and you really have to go all the way back to the database for it to be general enough to actually apply to both of those scenarios yeah okay i can see that sounds like a colossal amount of work to do well though it does nobody knows this better than than i do i'll let me put it to you this way though with respect to that when we decided we were going to make bit craft we were committed to making such a system the fact that it's available as its own standalone thing is not really that much more work every mmo that you have ever seen has an architecture which is at least as complicated as spacetime dv and i actually know that some of them i can't necessarily name them operate in the same sort of stored procedure way because it's the sort of convergent evolution that they arrived at but they just didn't formally call it a database so we it's in some sense an easier problem because if you if you treat it as a database formally you get to use all of the research and learnings that 50 years of database research has brought about you do not have to reinvent the wheel is what i'm saying on a lot of these things and so we were always destined to create a system that's like this as soon as we decided we wanted to to actually create create this kind of thing okay ours is arguably just not sort of sho string and duct tape not to disparage anyone else it's very hard to build an mpg but yeah yeah that's kind of how i would think about it let let's say rather than that it's not an afterthought not an afterthought yes correct okay okay so what we've got here is a system where i as the game programmer am updating a row in a de someone moves the joystick up i update the y position of their players row in a database correct magic cly that's going to be synchronized to the server without me worrying about it and roll back if it turned out it didn't work and then i just have a rendering function that's also looking at my local database and drawing screen that is correct yes that's essentially correct okay let's start with the first objection that's going to be too slow even even if you don't have to do the server round trip every time so let me ask a followup question to your question what specifically would be too slow because there's a what i want to ascertain is exactly what you're talking about there is a perception that databases are slow and perhaps that's what you're driving at i think because okay it's got to be transactional it's probably iterate once you get into things like oh my bullets flying across the screen and hitting people it's updating a considerable amount of data and if collision detection has got to happen a lot of times a second i won't give you the number you can give it to me but that feels like that feels like that's going to grind on a transactional database okay so this is a great question and i understand where you're coming from and you had to we had to be a little bit crazy to think that this was a thing that should be done originally but for several reasons which i'm about to outline i think you'll come to agree that actually that's completely possible and plausible to do within a database context so the first thing i i will draw your attention to is that we're not by no means the first to do things like this in history there is a database called times 10 which was developed in the 90s oh that was bought out by oracle wasn't it it was bought out by oracle correct and it actually has a very similar architecture to space time d so couple of things one it's fully in memory so the whole purpose of that database was that for certain very high throughput low latency applications current databases weren't hacking it not even that current like server architectures weren't weren't hacking it so what they decided to do is to have a database have inmemory state in that database put the logic of your program physically within the same process as that database and then have you access the data within the same process so you're you're literally reaching into your current program memory you're treating your program memory as though it were a database and then what they do is all the updates to that data they append in an appendonly fashion to a write ahead log okay and this was developed for like telecom processing like routing calls these kinds of very very low latency high throughput things yeah that's the almost identical architecture actually to how spacetime to be operates we have just modernized it for use with web assembly and whatever language you would like and some nice things on top of that including subscribing to the database which i don't believe times 10 actually provides that that information okay but that's that rad log that that we've got into persistence which you said is important yes isn't that a blocker to the performance not not typically so first thing i would say is that appending to a right ahead log is actually quite performant on modern hardware so that's actually how kafka works and it's how it's assumed to work right and kofka is known as sort of a low latency streaming thing it's not that low latency because of details but it's relative to what a lot of people use very low latency yeah okay yeah the other thing that's important to know about kafka and systems like that is that you can trade off throughput for latency so in the case of kafka you can batch more things up which will cause the latency to increase but will cause a throughput to go up you can always say i care about latency more than i care about throughput so i will decrease it down to just one transaction so that would make sense for i want a really high fast-paced game yeah where i really want the lowest possible latency or you know i don't really care if things come in late so that's that's one thing the next thing i would say is that for games or really any application choosing the level of durability that you want should be configuration and not code so what i mean by that is i ought to be able to decide that i want to listen to data that might not be persisted to disk because i don't actually care about that right for for a player movement if they if my server crashes and they move back 10t yeah don't really care about that if i'm running a bank transaction and it rolls back the last 10 seconds or whatever of bank transactions could be a problem because i might have already they might have already given away the item that the guy bought right okay yeah yeah is that so when you say that's configuration are you configuring it on a per object type basis so could i make some match levels of persistency guarantees you actually configure it on a subscriber basis so you would say hey i'm going to subscribe to this data and for this particular subscription i want to see the data as soon as it updates i don't care if it's ready like i want to hear about so there's sort of levels at which you can listen in so there's a there's a pipeline of data that comes in my message happens i update the data that changes the stuff in memory i write it to disk i replicate it to other machines all of this and at any point in time you can decide like you know what it's good enough i want to listen in here right so i want to listen in after it's been updated memory versus i want to listen after it's been persisted dis versus i want to listen only when it's been replicated to five machines that's a sort of a different level of listening if that makes sense i'm jumping around trying to get my handle all my hands all over but okay so how does that work programming i let's say the score player score right is gradually ticking up it's not the end of the world if it maybe rolls back a little bit am i writing some code that just subcribes to the score changing and just renders that corner of the screen you certainly could do that typically what what a client will do is they'll subscribe to all the data that they want right up front so they'll say like let's say it's a match chess match you'll say i want to subscribe to all the pece positions or i want to subscribe to it depends on how you program that match but let's say you're going to do it in a certain way i'm going to listen to all the pece positions and i want to subscribe to the score you don't actually a lot of cases you can actually compute the score on the client based on the state the game but let's say you can't for some reason in this game you would subscribe to the score as well and then that will be updated in a row and you'll just say from score table subscribe select all star from essentially am i doing like a am i joining those data sets so select all from pieces union select all from score yes so in this case you're you're going to basically select a subset of each server table we do not yet support subscription joints we do actually so we support what's called a semi- join so you may filter out rows from a table based on a join from another table so for example i might want to subscribe to all players who's who are friends with this other person so i would write a join and i could but i would always get the whole player row and i'm not going to get any like player plus other data if you want to do that you would subscribe to the other table as well and then we union all of those together and send them down okay and are we writing this query in sql sql currently we there's no reason we can't also support other query languages like graphql in the future it's just for right now for building an mmo rpg we need sql okay so as a game programmer i'm writing like you say very much like stored procedures that have a mixture of sql and coding and like what's the language so the language is the the module that you're writing is a web assembly module so it's any language that you want that compiles to web assembly notably we support rust and searp in terms of building a library of nice things for you to use in those languages in principle anybody else could do whatever language they want that compiles to web assembly but yeah those are the two that we support right now okay i i risk framing this all as objections but i'm trying to think there is it is an objectionable idea that happens to work and so it's it's it's quite exciting okay so the the other thing that people always complain about store procedures i mean a lot of people dislike store procedures and i think the reason is i think there's two reasons one is the language can be weird for store procedures personally i reject that one if it's valuable enough you'll learn the language the real one is management of store procedures is is a misery g correct yes it is and i think these are the so i would actually go a little bit further too the permissions model of store procedures at times can be arcane as well so i believe it's really to your point fundamentally a user experience problem not a theoretical or technological problem if that makes sense yeah yeah it's like developer experience rather than this simply doesn't work yes i mean why it's a if you actually think about store procedures as they were it's a nightmare you have data that's in your database operating that's opaque because somebody updated it but you don't it's not inversion control you don't have any idea like yeah what was running did somebody change it oh it's like where is it stored it's just a nightmare yeah so it's a great point what i will say to this is actually we didn't set out to build the database and store procedures what what actually happened is we built a system that had the the right ux for what we wanted our developers to have and then looked at it and said like oh from this angle actually this is just a database with store procedures so it was very much a we backed into it we didn't arrive there right so that's number one developer experience is the most important aspect of spacetime db and if it is bad there's no point to doing it that was why we created it in the first place the way we solve these problems are number one is we put all of the store procedures as like the root of your database it is all in a single module that's based from a single repo in in this case that you can version in version control and then you can see the versions of it the thing i would liken it to from a developer experience perspective and now i'm going to say something that will u maybe trigger a lot of people but is it's similar in principle to smart contracts so from right you and nobody thinks the developer experience of those is bad except the fact that they have to deal with the blockchain but ultimately the programming language can be pretty terrible and the programming language can be pretty terrible but fortunately we've solved both of those problems by removing the blockchain and making it so you can use whatever programming language you' like right and so but it's the same idea right you do not need a devops team to maintain or an operations team or any of that or aws credit or any of that to run your smart contract what you do is you say publish you said it you forget it you walk away like you don't have to deal with that ever again it's running someone's running it for you you really truly don't care and that is the promise of the developer experience that i think we can provide with store procedures and it's very easy in the case of smart contracts to keep them in sync normally actually in a lot of systems you can't update your smart contracts so that's one thing but in our case you can you can update a space time module and it comes from a data database and you can see the version that was up there and the version is stored in the log so the fact that you're updating your whole database and you can do migrations within your uh module and you're doing the whole module at a time vastly vastly improves it then you have your the language that you want to work within which is a normal programming language and then on top of that we have built a permissions model that allows you to have complex logic which is easy to understand by the developer if that makes sense okay let's go through the permissions thing for instance if i've got access to subscribing to data from the server i would very much like i i wouldn't hypothetical black hat me would very much like to use it to cheat on the game absolutely so subscribing to other people's data okay so first thing i'll note all games of the first type that i described were they have a deterministic client and they're replicating inputs must know about all data in those games so league of legends you can cheat in fact they have they're doing like a kernel extension to prevent people from cheating but that's beside the point they require you to see all data so if you see fog of war in an rts you could that data everything under that fog of war is there you could remove the fog of war on your client and see all of the units so sad times so first of all they just write out they they don't provide that to you at all in our case what you can do is there's two types of permissions there's there sort of write permissions and then there's read permissions right so if you're want to update the database clients are only allowed to update the database through the module and so what that will be is like let's say i wanted to move a player but i try to move a player in a way that's illegal like i'm trying to go into this level this place where i need to be level 56 and i'm only level 50 what the server will do is it'll check the level of the player because you just writing the logic and you'll just fail the transaction so you'll just say no we can't do that we roll everything back and we throw it away all right so that's that's the first thing the way that works is each client has an identifier which is called the identity makes sense it's kind of like an ethereum address if you want to liken it to something in that regard you can see who the person is okay and then you can say can you do all the checks all the procedural checks you want in the whole world is this player friends with that or do do they know each other whatever it is and then fail the transaction if it's not allowed so that's that's the right so write is super simple very very easy to do from a read perspective there's a couple layers that you can do so first of all what we implement today is private tables so that's just hey this this table is only viewable by the owner of the of the the module so based of the database creator and we would like to add so we have not yet added because it's not yet 1.0 both column permissions and then column read permissions and then row level security so what that means is you should be able to write a function inside of your module that says well in in case of column you're just going to annotate columns as being private right and that's that's pretty straightforward for row level security means like can this person see this row so if they subscribe to these players maybe this player's invisible and i shouldn't be able to see them right now right so you want to be able to write a filter function on a table so so a filter function that applies to a table that allows you to do arbitrary procedural logic that basically says whether or not this player should be or this row in this table should be visible to this subscriber so if i had like a hypothetical card game of some kind where i have cards that only i can see cards that all my teammates can see and cards that the opponent can also say would i be able to model that you certainly would so you'd be able you what you'd do is you'd say let's say you just have one table called cards and you'd write a a function that says this is the subscriber which like this is the identity of the subscriber do you want to show this row or these batch of rows or however we end up ultimately implementing it for performance reasons and you would look through the row and you would say ah is this who is the owner of this card i am the owner of this card i can see it oh i'm not the owner of this card is the owner of this card my teammate okay i can see it i am you and so forth and whatever conflict logic you want okay and i'm writing those functions in the same language in yes in russ or or whatever language you okay so so the language to define security roles is the general purpose language you the general purpose language and it's it's a procedural language you know not going very fancy obviously you can do you can do what for example super base does which is they have you write those road level security rules in sql so we may also support that i'm not sure right now but boy it is a lot easier to write russ than some arcane sql query about road level security i'll tell you that okay okay right where does that leave us so is my experience programming the server side similar to my experience programming the client side okay this is a fantastic question let me tell you where we are today and the the vision for where we want to be with with spacetime dv so where we are today is you write your server module that runs on the server it's written in let's say rust you write your client we have a rust sdk and what that does is gives gives you a bunch of functions that you can use like sub a subscribe function where you can pass in all your sql queries and then you can get all the data back the rust sdk currently stores that data internally so it has this like data little mini database if you will like an little mini m and you can query that data the querying of that data is relatively rudimentary it's based on code generation that we do so your module has a has a has a bunch of types right and a bunch of schemas all that stuff you can take a module and then you can extract the schema from that module and then you can code generate whatever type of clients you want so for example you can call a particular function from the client you can get the type the so if you have a rust module and a c client as we do you can get the c equivalent type to the rust type on your client if that makes sense okay which is important because that's another thing with with store procedure is that like oh the types like you hopefully the types work cu it's like dynamic who knows it's just crazy the way they do things or you have to sort of like apply a type and you have to maintain the types we are code generating a lot of it's like protuff right so you you have your schema we scoop that out of your module it's like a protuff representation of your schema you can then code generate on whatever client you want whatever types you need so typescript we support four right now typescript pyon russ and c for clients okay yeah but when i call those functions they're still going to the local space to tb client instance okay so they do and then they they get sent up to the server we don't automatically do client side prediction right now that is something that for example in bit craft we have to replicate the the logic of so if you move a player you have to move the them like yourself you have to rewrite the logic in c and then you have to write the logic in rust that's typically how a lot of people do this these things and it is a huge pain they duplicate the logic and they have to do this thing and it's it's a huge pain yeah some more clever people actually i know of some that are developing an rts use web assembly and they run the the server both on the client and the server and they do that so that's ultimately where we'd like to go with this so ultimately we want to run space andb not only in the server but also in the client and have them synchronized between each other automatically based on your subscriptions and then you have a fully running module so the same module that's running the server is running on the client and when you update when you do a call actually we run the actual server logic on your client update that and then that does the whole reconciliation so you automatically get client ey prediction for free really appe how how far away do you think that is it's a good question so in a sense we're already doing it on the what we call space tb cloud which is our cloud offer so we have okay there are two versions of space nb there's space ndb standalone which is the open source version that's on github you can take a look at that everything that'll run like a single node cluster as though it were your own personal instance of space eny we also have cloud which is a distributed system which will run many machines in coordinate between them all and the way we replicate from one to the other is sort of the normal way in which you would replicate a client so they're all just clients of each other is an interesting thing right and that has a lot of implications for strong consistency but i don't think we have time to get into that but either way we're working towards that i suppose on the server and then we will do that as soon as we can on the client we're also building an mmo rpg so we're a little bit busy so yeah i'm not sure exactly when that'll be but it is still useful in the way that it is right now that is to say not automatically doing client side prediction but we will we will eventually do that i envision world so here's the secret here's the real secret to what space time to be is actually it's not really a database at all what it really is is a distributed operating system in the spirit of plan n which has never sort of taken off let me explain okay briefly so space tb cloud as i mentioned runs over let's say a 100 computers right so you've got this this thing that's running from the outside it looks like just one instance of spacetime dv so you can't really tell that it is made up of 100 computers and what you're doing is you're taking a program and you're running it on that distributed computer so it looks again like a single computer and you're running a program on it and we're abstracting away the hardware boy that does sound like an operating system doesn't it and so that is really ultimately where we'd like to go is is a is a place where the cloud is not this collection of hardware and services that you have to piece together in this grotesque fashion but really it is just a giant computer and you're going to take your program and you're going to run it on that giant computer and that's it this is going to be even more blurred when you've got a series of clients connecting into that who are themselves similarly programmed correct and so what you might say is that you're building a gigantic distributed operating system that the whole world runs on top of right you could you could say that if you were so bold and i don't know that we are yet but but one day perhaps we will so the idea would be that you're all operating on the same protocol to speak with each other and that you can't really even tell i mean there's a lot of details in in this one and to be quite honest i haven't thought through all of it but if everybody's speaking the same language you have all of these modules subscribing to each other it's just the actor model you know what it is it's very similar to erlang right it's got the same kind of spirit you've got these actors and they are sending messages to each other and they're listening to messages that are being sent to them and they're updating their state and they're moving on so it's it's very much in that spirit okay let me ask you this and you may not like this question but i'm going to ask it anyway if someone thought this is a great idea but i'm not waiting for you to do it i'm going to build this on ear langang myself sure what parts would they be missing what parts would they find hard yeah so the whole database part right so don't forget about that so i i've thought about this in a sense so let's say you want to build a this on earling cool what is earling missing well it's missing the persistence i know they have persistent actors but the performance of that is key the size of each actor is key so within a space onb actor if you think about them as actors we also do multiversion concurrency control so that we can run as many transactions as possible within one machine as sort of one actor as you might possibly be able to do right so you want each actor to be as large as possible before you start going into other actors because as soon as you go into distributed systems it's complicated and you can do a lot with a single machine it turns out although each actor could in principle be more than one machine but that i i digress that's another direction to go in down in the future and then there's the whole relational model so you need to build on top of earling the ability to do queries on the rows and get the actual row data out all of the type system stuff you want to be able to run in whatever language you you would like to because maybe your programmers are familiar with c because they unity developers and all that let's say also now what about the subscription so actors in the earling model is i understand you can send messages to other clients but that's kind of like the old way of doing it with the game servers where i need to know what this other actor wants to know or build a subscription system where they send me a message which is their subscription and then i run the whole query engine and then i send them what they need to know which is what we have done so you have to build that whole query subscription system up from the ground as well so good luck to you and i would love to see and use your system if you do that because we wanted to make a game we yeah we are doing this because we must okay then perhaps we should wrap it up with the last two questions if someone decides they don't want to do that what state is spacetime db in for me as an as a user can i go play with it you absolutely can so you can go to spacetime db.com you can play with the demo it's right there you can also very quickly go to our cookstar guide install space time db get a local instance of it running space time standalone you can upload a module to that you can connect to that you can call functions on that you can also upload to our test net so our test net is a version of space mdb cloud which is relatively nent but it's meant for you to play around with what the cloud version will be it's completely free we give you sort of a a free amount of energy and energy is sort of what powers these things it's not actual energy to be clear it's just points credit you can think of aws credits we give you aws credits right yeah and you can go go to town on that and then notably for the test net we reserve the right monthly to wipe the data because we're still updating the avi and we don't want to be locked in yet but early this year so we're trying for let's say april to move into 1.0 and the main net so the main net of space mdb will be the version of space mdb where we guarantee that your data is going to be there forever and it will be persisted and replicated and all that good stuff and so you can begin building your applications now for a launch post april okay and this here's another dangerous question because there any really one right answer is your game bit craft going to be running on that test net on that it already is so we yes 100% okay and we are working on so a lot of our focus right now is getting the performance to where it needs to be so bcrafty db which was like space time db but it was the thing that we built first and it was not its own product and that worked quite well but it actually was more like the traditional old servers where the server knew what the client wanted and it was relatively performant and we're now getting back to that point that right around now we have the same performance of jank time db and now as we gear up for the alpha which by the way sign up for the bit craft alpha it's happening early this year as well i'll put a link in the share notes yes and we are getting to the point where we are at that performance level that we need for alpha so that's like well i don't want to i don't know how much i can say without upsetting the bigcraft team but it's many more users than we had previously concurrently running in the game right cool well you've got a busy year busy few years coming up we surely do we surely do awesome well good luck with spacetime tb i hope it takes off good luck with bitc i hope that takes off and if they both take off you're going to invite me to your private yacht for a followup i don't know that i'll have one of those i'll be too busy on the next part of spacetime tv so good luck i need satellite from there yeah you'll be able to afford it if both of those work i i guess so i guess so tyler thanks very much for joining us cheers thanks for having me and that's all from tyler thank you very much you know in among all the things we discussed in there i think tyler must be something like our third guest to reference the plan n operating system and i don't know much about plan n9 except it never took off but it was a huge influence for a lot of people i think we might have to have some kind of retrospective what we could have learned as an industry episode on plan 9 one day so if you're a plan n expert or if you know one please get in touch and the way you get in touch is the same way you send us any feedback my contact details are in the show notes if you're on youtube there's a comment box just down there spotify has a q&a thing for each episode these days and so on and so on check your app on the subject of feedback and of future episodes if you enjoyed this episode please leave a like or a comment if you think other people should find this podcast please rate it or share it with a friend and make sure you're subscribed because we're going to be back next week with more interesting voices from the software development world until then i've been your host chris jenkins this has been developer voices with tyler clu here thanks for listening