what should your code do in case it tries to load a corrupted file or if it gets back an incomplete response from an external api or if your user provides some invalid input different programming languages handle this in different ways but the way russ does this is particularly interesting so in this video i'll show you how rust error handling works and when to use which type of error handling based on my own experience in my opinion it's a much better approach to error handling than how python does it but there are a few situations where i still prer python's way of doing it when you design a new piece of software it's important to think about what possible errors can occur and how they affect your design if you want to learn the seven steps i take when i design software check out my free design guide at r00 gold/ design guide it's practical to theo guide that hopefully helps you get started more quickly before we dive into rost error handling i' just like to go back to how it's done in python so here i have a simple main file with a read file function that does nothing else than read a text file and print the contents to the screen now there's one special thing about this function which is that it only wants to read files ending with dxd so we don't accidentally read an excel file or something like that and in my main function i simply call this read file function with file. xls so when i run the script then obviously we're going to get an error namely we get a value error that file must be a text file so in python that's the standard way we deal with these types of issues so in this case we're raising a value error if the file name doesn't end with txt at the moment we're not doing anything with this error it's simply being raised and the program is stopped and of course in python if you want to handle this error then we can put the read file call in a try accept blck and then we catch the value error and then we can print the value error and do something else when i run this we simply get this error and the program in principle continue so i could write other code here and then that would be totally fine the main issue with this type of exception handler is that if you look at the signature of the function right here there's no way to easily see that this function raises a particular kind of exception and you can say okay well you know that's not be a problem because you can just look at the body of the function and you see oh this one potentially raises a value error but the problem is that other functions that you're calling may also themselves result in exceptions for example this open function call if the file doesn't exist that's also going to result in an exception for example if i change this to txt which is a file that also doesn't exist let me run this then well now we get a file not found error and the fact that it raises this type of error is not clear immediately from the function body so we'd have to drill in deeper and look at the definition of the open function and try to figure out what kind of exception that then potentially raises and maybe the open function calls other functions again that may raise even other types of errors so the bottom line is that it's very hard in a python script to understand what kind of error might occur and especially if you want to develop software that is very robust that handles all of the errors then this is going to be a really hard problem to solve because you're never 100% sure that you did catch all of the different errors now you can of course put this in a try accept block and then catch any exception which will do the job but that also means you may be catching things that you don't want to catch so in short exception if you want to build a robust application are actually not really that great a solution for handling errors now rust does this in a very different way it uses the so-called result object and the main difference between the classic exception handling and a result object is that errors are being handled explicitly in rust the result object is a very simple object that contains basically two possible values it can be a result value the thing that you expect to happen or it can be an error value this also called railroad oriented programming because you have these two tracks you have the success track and the error track and depending on what happens in your application you're going to be on one of those two tracks so here i have an example very similar to the python script but written in rust and there's a function here called read file contents and what that does is that it takes a path and it then reads the file contents and returns that as a result and here you see an example of the result object so that's either a string or it's an io error so those are the two options and by the way next to the result type there's also another type called option that i'll show you in a minute so this result type is used for operations that can potentially fail and can result in an error so whereas in python we have no idea what type of error read file might raise in rust we can just look at the function signature and then we can see that this returns a result object so we know that it either gives us a string or an error and nothing else and the rust compiler actually checks these things so you can't secretly raise another type of error or something because that's going to result in a compiler issue you won't be able to run that program so result is for operations that can fill another type that you'll also see quite often in rust is the option type that's a bit different than result option is for values that may or may not be present i'll show you an example of that later on as well now next to these types rust has a bunch of different syntax extensions methods functions that help you navigate this type of error handling and the most common one that you're going to see is the match statement and in this read file contents function you see a couple of different examples of how i use the match statement the first case is where we use this as an expression so we match file. open path so that reads the file if it's okay we get a file then that's what we return that gets stored in this very variable and if it's not okay if there's an error then we return the error and that's basically going to be the result from this function in the second part i use match as a statement so i've created a variable contents that's going to contain the contents of the file and i'm using the read to string method and if all of that goes well then we're simply going to return the contents and in the result that we do that by enclosing it with okay and if not we're going to return an error and that's what we do with this statement so putting this together means that we as developers in ross need to think about how to handle errors explicitly and then write the code to actually do that and like i mentioned the ros compiler actually helps you with this so for example let's say you don't really understand the error mechanism and just do this right we just call file. open path well now you see let me create some spacer now you see that file actually is of type result file error so if you then try to use that for example do file. read to string so then you see we actually get a compiler error that we're trying to call read to string on a result type so we first need to get to the actual file object that's in the result so the ros compiler forces us to deal with errors explicitly because this simply doesn't compile we won't be able to run the program this way we can't ignore it and that's one of the key things that makes rust a much safer language to use than something like python where we never know if all the errors are hand handles instead in rust we have to handle all the errors explicitly so match is one of the ways in rust that you can handle errors there are other options as well so here i have a second version of this function called read file contents short which is a shorter version of the function here and here you see something interesting i'm not using the match statement in this case but i'm using a question mark so this is a shorter way of saying that hey we're going to open the file and in case of success we're simply going to continue with the rest of the code and if there's an error we simply stop the function and return that as a part of the result object so this allows us to still write relatively short code while still being explicit about what to do with errors in this case we simply saying hey if you call this function then you should be the one dealing with this error and you can because you get back a result object and you can use this multiple times so i'm doing it here to open the file and i'm also doing it here to read the contents of the file to a string and you see that rust also correctly resolves the types for us so file now because we use the question mark is of type file and not of type result if i were to remove the question mark here you'll see that the type is now result file error and that means we need to now explicitly handle that error so the question mark gives us a shorter way of doing that and by the way in this rust example i have a main function that opens a hello.txt file that's not there so if i do a cargo run then you see there a bunch of warnings because we have unused functions because it's a code example but you'll see that we get an error reading the file and that's because this read file contents function is called by this function which then again doesn't match and then if it's okay it's going to print the contents and if it's not is going to print this particular error and that's exactly what you see right here now i could create a hello.txt file and simply write something here and then when we now run the code again you see that it simply prints the file contents so errors are being handled explicitly now in the code which leads to a very nice robust application now mentioned that next to the result type you also have an option type so here's yet another version of this read file function and this one returns an option that simply means that in some cases the value is not going to be present and here i'm again using a slightly different feature built into rust to handle the different cases so i'm opening the file as usual i'm creating a contents string that we're going to use to put the file contents in but then i'm using this if statement to check that the file can actually be read and this is another way in russ syntax to deal with the okay state of a particular result type then we execute the body of this if statement and you can do that with the let okay syntax another way to handle that is by using the is okay method and this is part of the result object so r to string that returns a result type and the result type has a method called is okay so if r to string to the content is okay then we're going to return some contents and some is the way of saying in rust that an option type has a value if it doesn't have a value we return none and that's what you see right here so let's try that so i'm going to comment this and i'm going to read the file if it exists so i will say content equals that so content is now type option string right because read file if exist returns that so match i've showed you before that you can use that with the okay or the error state you can also use that with an option type so let's say we do a match and then we're going to match the content and if it's some so it has a value then we're simply going to print that and if it's non then we're going to print that we had an error reading the file so if i run this so the hello file still exist so we're going to get the file contents but if i change this name to some file that doesn't exist and then let me run this again then you're going to see that we get now error reading file except now that we're using the option type so depending on what you need in your application you can choose whether you think result is more appropriate or option is more appropriate in both cases you can use match now you might say hey aran it's all nice that you can handle errors explicitly like that but i don't need to do that all the time if i want to just write a simple script and i don't want to deal with all these these match statements and whatnot i just want it to work and i don't really care about the arrows is there a way to do that in rust as well the answer is yes you can definitely do that and there's also a couple of options for that so one thing you can do if you just want the program to crash for whatever reason is to let rust panic so if at any point you just want your rust program to crash and burn you can simply call the panic macro and that's very simple just write panic exclamation mark and then something unre recoverable has happened so when we run this we simply get this panic and it also says that the thread main panicked and at which line that happens so that's a very easy way to just grash and burn another thing you can do is use unwrap which is a method part of the result object so if we have this function here read file contents sure so that returns something of type result right that's the function that i showed you just before this one so what you can do is instead of adding a match statement here to handle the okay and the error cases you can simply call unwrap and that's going to give us the content as a string so what happens in that case if there's an error well in fact that's going to panic so let's say i write file example on rep and let me change this back to a file that actually exists let me remove the panic so if i call this function file example on wp and i simply pass it an existing file and i run this code then we get the file content as expected when i change this to something else me run that again now we see we get a panic and that's because of how unwrap functions so unwrap is a shortcut for allowing your program to panic and not having to deal with match statements you simply write do unwrap one thing you see with unwrap is that you have no control over the kind of message that's being sent when your application panics it simply shows you the error well you can also use do expect which does exactly the same thing as unwrap but it allows you to pass a message so in this case i pass a message fail to read file so if i change this to file example expect and i run this then you see now we get the error that we actually indicated as part of the expect method call now unwrap expect panic these are typically things that you don't want to have in production code they're like a shortcut for you as developer to work quickly with some code and not really care about errors too much while still being explicit about it but if you ship this code to customers for example you want to make sure that you handle the errors properly using the result type and the match expressions this is also something that i noticed myself so i started working on a little side project in rust and i noticed that initially i just wanted to quickly write some codes get everything set up and working kind of in the way that i wanted it to and i was using unwrap and expect a lot in those cases because they just allow me to work faster but then as my design started to take shape i started going back to the older functions that i wrote and rewrote them so that they now properly returned result objects or option objects and i think this is a really good way to think about it so it's really a shortcut things like unwrap expect and panic for you to get started quickly but if others are going to use your code you're going to release it as open source for example it's going to be part some sort of production environment then you want to make sure you handle errors properly and the nice thing about this is that because these are explicit still you can actually search for usage of unwrap and expect and then one by one replace them with result objects so that errors are then handled properly by the way if you want to learn more about software design rust python and you like interacting with other people which i know not all developers like to do that but if you do you might want to join my free discord server at discord . ion. cod it's very helpful friendly community so i hope you join so today i started with a python example of exception handling and then showed you a different way of error handling in rust using the result type i also showed you a couple of different ways in rust that you can deal with errors namely the match expressions the question mark and if you want to have something quick and dirty unwrap and expect and or panic now even though i really like this type of error handling in rust and they did a lot of work on improving the syntax so that it's also easy to deal with if you just want to write something quick and dirty i still think in some cases it's nice to have exceptions in python because it is actually typically shorter so in a situation where you just want to quickly write a script and you want just to get some work done and you don't really care about errors or whatnot then i think actually exception handling works just fine in python that is and in that sense i think exception handling also fits better with the philosophy of pyone which is more aimed at being a scripting language on the other hand if you want to write high quality production code that's robust then the rust way of dealing with errors is definitely way way better in my opinion but i'd like to hear what you think do you think python's exception handling mechanism as it is is perfect should we switch to using a result type in python should we all use for example the returns package that provides an implementation of that or is that not really ne necessary do you think the solution that rust offers is good or do you think it's still too for both let me know in the comments another aspect of rost that's very different from how pon handles it is memory and if you want to learn more about how that works in rost watch this video next thanks for watching and see you in the next one