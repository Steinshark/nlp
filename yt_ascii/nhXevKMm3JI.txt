last time we talked about the idea of anthropomorphized is that the right word i think it is robo prored robot proris yes creatures creatures running around anyway doing doing jobs for us doing tasks for us and where where do we go from here then that's right so yeah yeah last time as you say we had i made up this robot thing which really came from like a 1980s book that i had as a kid and lots of us did that that showed how computers worked by showing how robots move around and did things inside and we had this idea of a robot with a little abacus which was his way of doing any arithmetic that you asked of him and he had only a very limited amount of resources available to him he had a little card that he had like the most recent number that he worked on the accumulator and he had a little tag that he could use to say where he was and where he was was in this big set of pigeon holes which it occurs to me most folks these days probably don't know what a pigeon hole is so yeah it's like the male boxes in like a shared apartment you know you've got this big grid of boxes and you know you can say well this number is for address zero and we said addresses last time as well addresses are like the which number box we're looking in and inside each of those boxes we can put one these pieces of card that has a number on it as well and we were we able to use that to build pretty much anything and right at the end we showed that the very program the instructions to the robot could be put inside those pigeons holes itself which then kind of like completes the circle if we like but i glossed over a lot of things and so today i'd like to talk a little bit about how math is done inside the computer and how we can sort of solve the problem of carrying on forever last time we talked about this accumulator where the robot could write numbers on and do maths with his abacus and that's all cool and all but really there's a limited amount of resources that the robot has he can't write arbitrarily large numbers like we were doing last time last time we were sort of adding them up and we were putting thousands and whatever inside each of these boxes and that's not what computers can do they are limited in how the big the number they can represent is and in the age of the 1980s where my my heart still is the most computers that you could get access to were 8bit computers and the 8 bits refers to essentially the amount of data that was natural for the computer to deal with at a time either the amount it could fetch from memory at one point in time or the kind of size of numbers that it could add together 8 bits in my robot world will be effectively two digits so i'm not going to use binary because it gets a little bit complicated we'll talk a little bit about that hopefully if we get time at the end but as a sort of near enough approximation what i'm going to do is use two digigit numbers and so really our little accumulator it can store from 0 oh i can't even write and it can do 01 02 all the way up to 99 so we get 100 different values and that's okay all right similarly our little set of pigeon holes each one of those slots in the pigeon hole can only also store a two-digit number that seems a bit limiting because fibonacci numbers grow if we were sorry last time we write a little program to to generate fibonacci numbers that's where my mind is but they grow very quickly and they get over 100 pretty swiftly so the natural tradeoff is how can we teach our robot how to do maths involving more than one value at a time so that we can say use four digits by putting the numbers in consecutive pigeon holes similarly our robot can only do simple mth with his abacus involving two two-digit numbers now how as humans would we add two two-digit numbers together well actually the same kind of thing that we do when we're adding any kind of numbers together let's say 10 and 33 as a human i start with the right hand this is at least how i was taught to do it the kids these days probably have taught something else column edition i think column edition exactly and we start from the right hand side so i add 0 + three and it gives me three and i add one and three and it gives me four and so my answer is 43 and i could just keep doing this if i had more digits i could just keep adding them on to this side so if this was 1,0 and 2133 this would be 31 43 and so on so we could keep on making that number arbitrary large as large as my piece of paper and patience are but pick these numbers cuz they're low what happens if i add say 99 with another 99 well 9 + 9 is' so how i'd write it is 8 carry 1 and now we've got this is now a 10 and then 10 + 9 is 9 and with an extra one we got one more digit and we had to do a carry operation there was a carry out of there because we got a bigger number than we could write down in in any one column now our robotss got two columns at a time but we need to teach him how to carry so we're going to add some facilities to the robot he's going to have a little bit of extra state so at the moment he's only got an accumulator the index which we talked about before and now we're going to give him a set of flags now that's a silly name but it's what they're called so i'm going to kind of go with the metaphor because they're kind of nice as well and the flags are either raised little flag that's up or not raised or down or clear so we e clear or set or raised or or lowered however you want to think of it like that but if you want to think of them as physical flags they're raised and lowered and the robot has about a half dozen of them the one that we're import we're interested in is the carry flag and so he has a little flag up here this is might with a a c on it which is probably too s small to see other flags the robot might have are zero and negative and overflow and other things like that and essentially every time the robot does some arithmetic he sets the values of these flags according to what happened so if he adds two two-digit numbers together and gets a carry he raises the carry flag else he makes sure it's put down and that's his way of remembering at the back of his head that if he needed to carry on and do some more arithmetic then maybe he has to account for an extra an extra one that we're going to add in similarly the zero flag is set if the result of what the robot just calculated is zero the zero flag is set otherwise it's cleared the negative is if it goes below zero which my decimal setup doesn't work very well with i'll be honest with you but so i'm going of gloss over that overflow again more complicated and there are some other flags the robot might have that are to do with some of the other things that that the computer has to deal with but our carry in this instance lets us write code now that looks a little bit like this so i'm going to sort of go back to writing the assembly code which is the human readbook sort of human readable version of how to add larger numbers together and so if for example in our fibonacci number fibonacci program we wanted to add say four digit numbers together let's make a decision that all of the numbers are going to be four digits what i'm going to do is i'm going to use two pigeon holes for every number that's going to be in the sequence the part before where we were just adding the two prior numbers together to get the next number has to be a little bit more complicated and i'm not going to go over the whole program because it's a lot but we're just going to write a little bit of how you might add two two-digit numbers together so the first thing i need to do is add the least significant that is in our case the right hand digit of the number now we get to a point where computers have schism because there are two different ways of doing this one way is that we store the least significant number first in memory because it's the one you need first if you're about to do arithmetic on it however that has the side effect of writing the number backwards in memory now if you never look at the memory you don't care about that you always read it consistently but if you're debugging a program and you're looking at the bites in memory one after another the numbers look backwards for some definition of backwards and so it's convenient for computers but a pain for humans those computers are called little endian because the little like the least significant part of the number is stored first so the end of the number is like the little end comes first as it happens that seems to have won out so the the the the cpu that we're on here on my my my laptop is an intel one that is little indian most arm chips are a little indian they can be configured but the main frames of of the time were big indian they were the other way around and anyway so that's little indian and big endian as a bonus bit of content in here so anyway we're going to store them little indian so that means that we're going to load the first number so first i need to clear the carry to make sure that whatever had happened before i don't want to add in an extra from a previous operation there is no previous operation and now i'm going to load a value into the accumulator so i'm going actually like let's let's do let's do an actual operation here oops let me get my little index pointer out and i'm going to draw a little subset over here of the pigeon holes and we don't even need to know what index these pigeon holes are because it's all relative to this index that we're about to write so this is the index which is currently pointing to or referring to the first of the two numbers i want to add together and i'm going to put the result over here in these two sections two little slots over here let's go with some numbers that actually are fibonacci 233 and 377 are some fibonacci numbers i think they're 14 and 15 something like that so again in little indian world we're going to store the least significant two digits first so of the 233 that means i'm going to write 33 in this first box and i'm going to write 02 in the second box so again you can sort of see that it's confusing 233 reading sort of right to left two digits at a time and then the next one is 377 okay now we want to add the 33 and the 77 together so what i want to do is i want to refer relative to this index so while we're here i'm going to teach my robot that you don't have to keep moving this index around all the time like we did in the last episode what we can do is just have relative to this index so i'm going to say load the number at the index plus z i.e the one where it's actually pointing out right now so that would have loaded into our accumulator let's get our accumulator 33 so the number in the accumulator is now 33 and our little carry flag is down now we're going to say add and i'm just because i'm changing this to include a carry i'm going to call it add with carry a dc whatever is pointed at x + 2 so rather than moving the index two forward and then two back as i'm going to have to do i'm just going to say relative to where the index is two so that's that's going to get the 77 so 33 + 77 is on the spot 37 is 10 so that gives me a four here so with a zero 4 + 7 is 10 isn't it 10 no yes no oh my gosh it's 110 there we are okay so we get 110 out never do this live i i wrote these numbers down beforehand and i should have like put the intermedi i let all the bits out and it'll look really slck i look i look like i'm clever but no you don't have to edit them out everyone can tell me like this is why we have computers to do this for us yeah yeah this is it so 110 doesn't fit into our two digits so we're left with just the 10 at the bottom but our carry flag is now raised so somewhere and i i meant to make some little cocktail stick flags to stick up but so sean hold up a little flag for me yeah they're going to have to like do this right hang on hang on there we are amazing in fact that's supposed to be a c one stage i had a flag like that on my desk which was an interrupt flag where people would raise it to say i'd like to interrupt interrupt your work yeah exactly which we could talk about another time anyway so we've got 10 carry one so we remember the carry now we're going to store that 10 which is the bottom part of our result in x + 4 which is you know not 1 2 3 4 so we're going to put 10 in this box fantastic but now we have to do the next part of the calculation and add the most significant parts together so so i'm going to just quickly write this out x + 1 add with carry at x + 3 store at x + 5 so working that through we're going to load the two so our accumulator now has 02 in it and now we're going to add the three which would give us five but the carry flag is set so we also increment it by another one that gives us six and is that carry flag does it is it always gna be a one am i being a full here is it always no absolutely yes there's if you if you think about what's the largest two numbers that you could add together it's 99 and 99 and so the the largest amount you could ever carry is exactly 100 into the next yes okay i see i see yeah i know what you mean it feels like you should need more information doing the columns sometimes there was maybe an eight going ac no there wasn't there's always no that was yeah no i was just doing long long ic wrong that's why you were confused it's all right i'm back with you so we've got 06 in here so now we've got 233 + 377 is 610 which i really do hope is the next correct fibonacci number so that's super cool right and you could see how we could extend that arbitrarily to say well i want to have 10 digigit numbers or 100 digigit numbers or so on and so forth but pragmatically we pick one two four maybe eight bytes to make a number together and in modern computers they can store more than two digits at once in fact that's what makes a modern computer so modern is like the 8 bit or the 16 bit or 32 or 64 bit n of the computer is how many digits it can naturally deal with before it has to start carrying and moving around but you can still build these things out using those those operations but the other sort of key thing about this is that finally now if you we we can finally we can stop calculating fibonacci numbers once we've reached the biggest one we can store right because if we teach our robot one more trick so if you remember that in our fibonacci sequence at the end of this route the part where we' added the two together we would move the index on to the next number now we need to move it forward two slots to account for the fact that each number takes up two slots and then we would just jump back to the top and do it again so we just keep repeating that forever and ever and ever and ever and ever and ever which is great right up until it wrote to the the the boxes the pigeon holes that contained the very program that we were executing in which case you know horrible things would happen but what we can do now is we can say if we teach the robot look you can jump conditionally so it's a maybe jump and we say jump back round so i'm going to say branch which is another way saying jump branch if the carry is clear back to the top of the loop which i haven't drawn but the loop is up here somewhere and there's some bits missing here as well it's not important but this means that instead of always jumping this is like only jump if the carry is still clear and the carry would only be clear here if the last piece of arithmetic with the high numbers hadn't also needed yet another bite another another value and so as soon as we get to was it 10,000 it would stop and say yeah okay this is not representable anymore i can't fit it and then we would say you know stop here or i would say rts which would say turn sub routine in this language which means go back to doing whatever you were doing before or halt or something like that and so now our robot can stop yeah and also you know you could understand how if you wanted to do other sort of comparisons you could use arithmetic operations so for example if you wanted to do something until two numbers were equal to each other which is quite common you just subtract the two numbers that you're interested in and then if the answer is zero the zero flag is set and so that would give me a way of discriminate you could say jump branch if the zero flag is set that means the two numbers i just subtracted are the same and then similarly if you want to say if one's bigger than the other if you subtract a from b and b is bigger than a then the answer you get is negative so that negative flag will be set and so you can do all these things all those comparisons and all the other things that you need to do to sort of do some form of control flow can be built out of the perimeters we've got here cool now one last thing i wanted to show and that is to sort of say that like i have been slowly morphing what i've been writing down here from a sort of madeup instruction for a madeup computer into something which looks to most folks a little bit familiar well not some some folks a little familiar and so what i'd like to show just at the end here is if i flick this button over here what we have here is a bbc micro running a very slightly tweaked version of the fibonacci code here okay and in fact i've got it to also print out the the uh machine code that the human readable human readable i mean it's as readable as as we can get so if you can see at the top here the first few lines here are setting up the first two fibonacci numbers are 001 or 0 1 0 i should say sorry getting the right way around and then there is a whole bunch of code here that looks similar load and add and store load and add and store increment and then branch around this is showing you that a 1980s computer works pretty much exactly the way that we described here and the i actually the the boxes that i chose to write the fibonacci numbers in actually are the boxes that correspond to the picture on the screen which is why at the very top of the screen you can see this sort of junky color stuff that is in fact the fibonacci sequence being interpreted by the video hardware okay now being an emulator i can actually quickly pop in and tell tell the system i can go and look directly in the pigeon holes 7 cs i can't see my computer as the screen at the same time so now we've looked at the pigeon hole addresses at 7 c00 now again i was doing everything in sort of a decimal version of a computer these are now in hex so if you just forgive the hexad decimal we can see that 0 1 0 0 0 1 0 0 there's the first two numbers 02 0 0 03 0 0 05 08 0 d that's 13 and so on and somewhere in there we will find the hex representation of 610 if we do it right but there are the actual pigeon holes in a real computer real real from the 1980s computer an emulated real computer in and emulated running in a web browser of all things so yeah you know we've really come full circle here each of these bits has the number associated with it so this would be considered bit zero and this would be considered bit 31 and then we can count down so this is then b so sometimes the way this is done by some in