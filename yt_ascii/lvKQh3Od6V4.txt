all right by the way for those that don't know for those that haven't been a part of it for those that live under a stupid rock this right here is the milk okay the milk baby the milk daddy milk me daddy known by several names a mustache that is both beautiful yet shows a softer side of milky dang dang followup if you don't know anything about melky mky you stream you have youtube videos you actually make really good content i think we've reacted to one of your videos and you've been on the stream once you made some thank good content i am guilty of watching your content offline i i actually just watch your content i watch almost no engineering content like zero and you might be the only person i i watch offline that's an honor thank you like that's it definitely not armor cell no that's a private one that's a private definitely don't watch no never watched it probably not going to watch it that twitch algo not going to happen by the way great work on the twitch algorithm i just love the amount of anime and bobs and vtubers i get really really just reminds me who the people are that watch my stream and that they're all the generates it's just it's just you know daily i'm the ml guy so i i'm respons for that algo so you're welcome everyone you're welcome giving you the content that i know you really want all right anyway so here we go so we found this post you actually found this post and you linked it to me and says anyone who tried to like goang and tried it many many times but still don't like it compared to typescript question mark and this is about to be a pretty big thesis as you can see 32 individual points i would have went with 34 and called it rule 34 of goang they didn't do it though you know i i can understand they're not very good at the internet so the hyp catch on you g interrupt me like that sorry sorry so i'm excited okay it's only second time i'm excited to read the pamplet okay just remember we had the whole timing and all the jokes pre-planned and now they're all ruined every last one of them give the hyper around goang and too many medium posts highlighting so many node python companies are migrating from node python to go and got a 4x and a 5x and all the wonderful things described about it i've been exploring goang since a few years now and even though i know all about it i just don't like the language itself and i'm really really surprised that people say go as a language is better than typescript syntax typ system etc wise to me i feel the exact opposite typescript has super advanced type system with super advanced to which go does not even stand there are many things i never liked in go as a warning long list below okay so before we even address it melky i would love to hear a couple things you do not like about go a couple things i don't like about go okay but so first of all this person the types of community i love them i love how he says you know although there was a 4 x 5x performance go still sucks and it's like i know everything about go and i i just found that opening statement i knew i was going to be in for a treat for this i agree with all these things i definitely when it says i know all about it that's i mean it's pretty tough to know everything he but he knows everything prime he knows everything for me the few things i think go lacks obviously and this article goes through them no enums like that's you can't argue that no enums i you know that one is i stinky one but can we can we just tea out for just one quick second there one quick second granted he is comparing go to typescript it typescript is not known for amazing enums don't add logic into this article okay you're right don't do this right now typescript has moderately better enum support super advanced type system okay you don't know about the type system but the one gotcha that i actually agree with this article and it's actually the first point there is the nil pointers and there's no checking of nil pointers and go that one i've been caught by it and yeah i i i agree i agree my hands are down everything vertical is horizontal i agree okay okay i i think i can actually join you on this one i i'm really hoping that with the generic introduction and all that we can start seeing an option type be put into to go cuz i think that would effectively remove all need for nil you wouldn't have nil anymore you just always have an option type and so i'm hoping that that can somehow exist my my guess is that it still maybe can't we might need a bit more but something like a maybe would be fantastic and i'd absolutely love to see that yeah that would i don't want to get caught with this and there's been times where i've like in didn't instantiate you know a map or something and then try to call a method on it everything looked great and gravy on my side and then once it's deployed it's like wait come on go on what are you calling this method on this doesn't exist you idiot i'm like touche touche z yeah zero so i i completely agree on that maps being nillable i feel like is a very confusing just like initial topic because then my brain's thinking inside like i i have to then ask the question when i pass a map do i copy it like everything else you always pass by reference unless if it's this choice though of interface sl arraymap just feels very arbitrary for me and so i do agree with this whole n problem which is really just more of a problem with pointers in general is that you just have to think about it too much and thus happens it does all the time all right all right so let's go to number two now i i feel like this is a very interesting one which is air handling or lack thereof at every line is insanely painful to see and if you forget to check any error then the code could blow up and the compiler will not stop you at all so give me some thoughts on this one okay please i i i was going to wait till you you if you want to go this but this one this is like the classic why ghost sucks argument the error handling this this anytime you go to like a a super rust dev or a typescript or a front end you know whoever they're like well goh sucks because of the air handing because it doesn't exist my whole philosophy on this is first of all this statement is not true there is error handling hold before you go before you go i i just want to do one quick thing sorry i'm sorry to cut you off right at right as you're climaxing there i was so climaxed oh my god a b i have to take a cold shower now you better you better on there we go i'm going to put bad good okay mh so i'm going to give people three options quickly start going okay melky start saying your opinion so that it will affect this poll go okay by yeah so air handling ino exists i think the main problem people see is twofold one is that it's up to the programmer the engineer to actually you know handle the error value which sometimes you can call a function you can ignore the error value and i think that's the main point that people complain about well i can just underscore and i can forget about it and hence there's no error handling but i think that's kind of like a n like ave point because the error the value exists it's you are making the conscious decision to not handle that error it's not that goal is not providing you the ability to handle the error is you are making the decision the engineer the architect the maestro of your code to make that decision i think that's the argument that people don't really absorb into their you know their sponge follicles and when i write go i like handling my errors the way i want to do i want to panic maybe do i want to log it yeah absolutely it's up to me i like that control i like that granularity of you know doing what i want the error and then the subset of that argument is the if error equals nil and people like well i have to always repeat it i have to repeat it and the argument there is like i i can see that it's annoying but in go errors are values the way the same way you're g to you know handle any sort of constant any sort of declaration whatever that's the way errors are and hey i'm looking at you everyone writes code with lots of errors so you're going to be handling lots of if error does not equal n all right so suck it up it's beautiful it's great and handle your errors properly because it's really good for a good engineer so okay so i'm i'm actually on your team for most of this yes and i thing that i think yes i think the thing that's really missing from his argument is if i jump over here into node for a quick second and i like this json.parse open squirly brace single quote and i'm going to parse that that airs nothing in it says that that's going to air you don't know it's going to air it throws an error and changes your control flow completely whereas if you do the same thing and go do a little bit of unmarshalling marshalling whatever the hell it's called i always forget which directions which i have to read the description it it has an erir as a part of the whole situation so that you know did this thing just not like was i able to even be able to read this thing or not whereas with typescript you don't get any error handling you get error catching which is like the opposite of error handling right it is just like i hope i have a try catch in a place that makes sense for whatever i'm doing right because it just might not yeah exactly exactly and that's the that's the argument i see especially from a typescript form like a subreddit that's it's like you can have the same behavior the same like level of negligence if you will in types with the with not having proper tri catches right it's it's like the same sort of underlying root behavior if if if this person is saying the lack of error handling or lack of you know airor control whatever you want to put like it still exists in typescript you know what i mean it still exists it's up to you to design your system with try catches or handling the error values like if you are a negl negligent engineer you're going to be negligently handling your errors and i think that to me is like the the tldr and i like error handling i it's like i think it's one of the core concepts and core protoc is needed for a good engineer it's like how do you handle these how do you make sure your code your application runs smoothly gracefully does it panic do you want it to that's all like error handling and that's like the branch of thinking that i think people are yeah you know they don't jump in so i'm gonna i know we probably beat this thing to death but i do want to do one last thing which is let's just take something like let's let's take this this line right here right i have this beautiful little piece of template code right here that's going to create a new template it's going to throw a nice little funk map on it and then it's going to going to you know hit it with the parse glob and that thing is going to return my templates if i get it or an error now i get to do this nice little line right here and if i don't have an error i get to keep on going and i have this now if we were to do the equivalent in typescript i'd actually have to do something that looks more like this let temples you know is actually going to be an undefined or you know the type and it equals undefined then i'm going to have to try then i'm i'm going to have to catch the air and then i'm going to have to do all this kind of stuff and i'm going to have to put this in here and you know it's going to look something more like this as opposed to the by having the air as a value i don't have to do this like dance where i have to actually put the value outside the tri catch because it's its own block and its own scope and then i can define it there and then i have to like i i find this to be just the world's most annoying version of handling stuff right like this is super this is like a thousand times more annoying than this and i i got a nice little remap for that so i can just whoopsies i can just hit him with the leader e and boom yep or equals no return it what was that what was that you want another one you want another one you want another one another one another one i dude i can give it to you all day baby girl like i know these things and so for me it's just like that is so much less annoying than whatever the alternative they're suggesting is which is to get tr catched on right yeah and i honestly think the tr catch actually presents more opportunities to not handle the error because you know when you call this templates function if you read a docs you're going to return you know probably an interface and then an actual error value by the function contract definition you don't have that in javascript or typescript you are you actually have to create the try catch yourself but if you read the documentation of the functions you're writing from a library it's going to return an error so you know you can handle that so i actually think it gives you more opportunities to write a proper system yeah yeah judo says global error handling isn't all errors are unique so this is probably where my one thing i will say about tr catch that is nice is that if you have if you want to go like the lazy programming route and you just have that if there is any error i'm just going to respond with my server with a 500 try catch actually makes that very very simple and so i can totally see why you'd like that same with the cli tool i just want a cli tool that the moment i encounter an error i'm going to pretty print out the air and then exit with a one that's totally doable in node very very easy you just do a process on uncaught exceptions or uncaught or unhandled rejections or whatever it is not i'm not talking about like an arch user in dates but i'm talking about like exceptions and and rejections here and so like that is very useful i will say that that is very very useful to have and it's nice for a very narrow band of items but for the most part that's not that's not my experience you know yeah i was gonna say like yeah i i actually completely agree with you but the one thing i and we had a discussion yesterday when we were talking online it's like i haven't faced that situation where something like that makes more sense in terms of handling that you know blanket error handling if you will yeah similar to how like i i i was talking about zod and like i just never faed that particular thing which maybe we can get into in a future time but yeah i i agree with that but i personally haven't seen a situation myself i'm like i'm just g to globally handle all my errors yeah yeah i actually want to make a zod competitor i have a very good idea in my brain i'm very excited about it and i'm going to do it what's the name give me the name it all matters about the name if the name's not i don't have a good name truly i don't have a good name but my idea was either to take protuff definitions or typescript definitions either or and generate validation functions that are all inlined and use a dot separator to look up everything because then you get much better performance and it doesn't have to do these manual crawls and zod is just really really slow and so you define your types and then that generates validation as opposed to generating validation and then creating your types from it that sounds awesome and i think the proto i'm actually excited g do yeah yeah that's i think that'd be a dynamite thing and then you just get that right out anyways just a thought i've been having had it in the shower yesterday not a big deal anyways number three no union or some types is also a big problem i mean they exist it's just super messy the union typing and go is is it's very they typing i didn't even realize they had do they is it just like some version of the sea yeah it's it's not like it's not built in there's nothing that you can actually union you have to kind of hack your way through it okay it's it's not pretty it's doable but not built into the language so in a sense number three is kind of a valid point there is a way to get around it but it's i it's not very intuitive all right so for those that don't know what a union type or why those things are good specifically in strict typed languages or strong typing whatever you want to call it whenever you have a list of more than one type that simply can't be represented or shouldn't be represented as an interface a some type is very very nice you can say hey this thing is a string or it's a number or it's this object right so you can think of whenever you do merge deep merge deep really its argument is a union type it's like it's every type one you have to kind of figure out how you want to handle each typing situation so it can be very very nice to have a nice union type for those kind of things but what they're not mentioning in this whole little this little rant we got going on here is that typescript also handles you i know i've showed people this they handle their crap very bad crappy union right equals string or number okay there we go we got ourselves that's a union type right so that means if i have a const a which is going to be a string array i can take that and i can create a function called add to crappy union and this thing takes in a crappy union and we're going to add something to it okay and i'm going to take a and i'm going to push in one well which is bad 69 nice try co-pilot and that means i can add to crappy union a because a in their book is actually a part of it but it ain't part of it it ain't part of crappy union this is bad why would you allow this to happen right and so this is just a crappy union and so typescript though having some types has the worst version of some types which is a non-type enforcement some type so it's like you can do that and that's totally type safe but i would argue this is completely unyp safe and crazy now every single time i show this people are always like you' never do that yes you will do that when you have a list of more than one object you can totally have this happen and then now will fall into every single thing every single array that is some sub verion of it can fall into crappy union and be used there right so it's like it's i just i don't think they have i don't think typescript has good some types either i think they have terrible some types it doesn't save you at all yep i i i hated that example so much because it's like that just completely throws off like strict typing if you can have that like that just irks me it does i get a little irked myself all right number four poor oop implementation using receiver functions instead of just having proper o op if that's what they wanted to enable in the first place which is not like they didn't want to enable op in the first place this when i got to point 4 i think this is when things start to click i'm like i think this is just like a rant like this is straight up like this person is just like trying to find as many things to to say about go that aren't even true like poor oish implementation like go doesn't have oop implementation that's not how go wanted to be built it didn't want to do that hence it has interfaces hence it has other ways of inheritance and or not inheritance but they have property inheritance but that's it property inher yeah thank you property inheritance th like i couldn't find my way to really agree with this point this is one of those points that i think is like just completely invalid because it doesn't make sense go wasn't built this way go wasn't designed this way and go is not used this way at all yeah yeah and and the thing is is that i love classes when i say class i mean a struct with methods hanging off of it i think that's beauti i don't want inheritance i' i every year i try it a couple times a year and i hope that i i do it right and every single time i've used inheritance in the last couple years i've regretted using it like almost every single time and so i mean there are some situations that people say is really nice like html element for web components you have to inherit from and then create a class from so you can have your own components was that the best way to do things maybe that was the best way to do things i can't say it was the best way or not but nonetheless that just happens and so i don't really care for o that much i like interfaces you can do most o patterns the strategy pattern is just interfaces plus concrete classes right so you can totally do that so it does have an o op design pattern in go without all that you know i it's just this seems like a really weird one to say it doesn't have my version of what i want and by the way classes and pointer receivers are identical other than how they're typed like to say that they're somehow you know that these are these are somehow different it's just a struct with a method hanging off of it like i don't know where going with this one sounds a little it sounds a little funny yeah and i think the the whole aspect of inheritance and like the discuss inheritance versus composition like go the goal wants to be simple go wants to be very very easy to use and i in my opinion when i kind of see that like i think of like not too tight tightly coupled code and so if there's a change anywhere in in the class well i think what go wants to do is like you don't we don't want you to go and change all of that you know definition those methods and go through your code like just slap the interface on it change that and then that's good that's your layer that that you really need to change everything else you can kind of leave the same way your client you can leave it you doesn't need inheritance like for me actually i see this point as like an actual plus for go if i'm being honest like i actually think like hey yeah that's great it doesn't have oop it doesn't have all the struggles with that you just have composition and and you're happy you're laughing you're good all right next one implicit interface implementation means you have to read the entire declaration of the file to just to know which interface is implemented instead of just allowing x implements y and z like every other language i got i'm i'm going to take the lead on this one so first off not every language works that way so every other language is actually just fundamentally an untrue statement but i will say that i think rusts is probably the best version of this and i do agree with his overall point which is there's not an explicit point in the code that says my struct implements this behavior and then you have to implement the following function they can go in any order you're going to have to find them like i agree a little messy not kind of the way i like to do it rust does instead if you want to implement say the into trait which is you know like a golang interface you have to say imple into for class name and so then you then in that little block you implement that interface's requirement and so for me that that feels good right that feels right which also means that if you have conflicting i think if you have conflicting names if you have conf in names it chooses the first trait that's implemented if i'm not mistaken which is also strange but nonetheless i just like that version better it just feels more correct than any other one but i think typescript having to say it implements it at the tippity top is not fun i find that to be super annoying and plus you also don't have to do this in typescript like at all yeah i i i agree it is m especially if you're if you're first coming on to go and you see an interface and then you see like a struck that has maybe not all the methods or like it's not a onetoone map you it can get confusing and i i i've been caught by that you know instancing clients and you know either missing a method or or whatever i can see the point that it's like not convenient and it's not explicit and i think that makes it a little annoying but i think this is like a i'm gna admit this may be a bias wave for me to say this but once you get used to it i think it's fairly easy but i think that's a very bad argument i'm not i will admit like that's not a strong argument on my on my side i've been using go i think i'm just adapted to the methods and kind of that so it's also very easy though at the same time by the way look i just did the exact i i literally did the exact thing that he said sucks right now in typescript i have a class called fu with bar i have an interface named bar i have a function that takes in a bar i hand it a foo fu never implemented bar yeah checkmate atheist checkmate i'm just saying it's not even required in typescript like most people don't even do that in typescript right all right six zero default values do not play well with json serialization and deserialization and are a source of many many bugs workaround is to convert a field to a pointer and then to do a nil check but this means you have to convert all the struct keys to pointers as you can receive an entire empty struct so how will you identify what was set and what was not set without all structs being set to pointer and doing nil checks it just never ends i would just follow up with it's no different in typescript you have to do a question mark instead of a star right okay so i was actually are you confused about this one too i was i i'm actually happy you said that because i was a little confused i was like okay maybe this is a valid point because when you do like unmarshal something you don't have that guarantee that all the fields in your struct are gna be populated right so you will have these like nil pointers potential these n nil values right and i was thinking like okay i could see this potentially being valid but then but then i forgot that this is like a typescript versus go article and so i went back and i'm like well how would i do some typescript and it's kind of the exact same thing you have to have a layer of checking if that property exists you have the exact same thing not only that but that's the whole reason zod exists remember you just said earlier about zod zod checks to make sure the struct that you got out of javascript is the thing you wanted yeah so i was like i was okay good good but now i was like wait a minute what does typescript do again yeah russ has the same problem they they just force you to use options so you have to have an option this thing right all right number seven cannot access keys of a struct dynamically using a variable which is so easy in typescript also very securely as well due to powerful type system okay that second point is completely invalid and in go one has to convert the struct to a map or use reflect boiler plate code just to access keys of a struct using a variable there are a small set of problems where i can understand this is useful very very small kind of set of problems like how about this one here's a good example of it you have yourself a csv you wish to parse and it has say 10 fields so you pass in the 10 fields you want to be parsed and you have five different object types which could which may include some set of those fields you would need effectively a dynamic way to be able to look up those fields and get out those values mhm so that is like there you go there's an there to me is a valid argument for why i like this behavior wait so but i actually i actually think i don't un truly understand this point then because what what does he mean by like asking the value the struct dynamically like so so i i'll give you a quick example right here um so let's just say we have a function that's like print out properties right and i got an object that's an any whoopsies and i have a filter list so now i can do something like this if let's see if a filter or const const prop equals object. propop here const to print equals this thing if if prop then to print push prop and then i can just console log prop right if we wanted to do it all on one line prop there we go or sorry to print there we go oopsies it's not that way it's object. keys there we go and okay okay as key of type of object oh yeah right did i get that right oh my goodness why you got to be like this why you got to be like this advanced types scrip baby team dhh we're going to get there i'm going to get it there we go okay i got it so there you go advanced typescript key of type of object you can't use keys and they don't like when you call object. keys you actually don't get a type out that says these are fine to access you actually have to say this every time it's the very very annoying but nonetheless this is a great example i just wanted to print out certain properties you can't dynamically do that easily and go so i think that that's fair well that seems like a terrible usage of objects i'm on your team i'm just if you had a a struct if you had like i said if you had a csv you need to produce you knew what fields you wanted you just didn't know what objects had what fields and you just had to pipe in dynamically like you could imagine like a database streaming a bunch of events and you need to take a session that has happened and pull out the behavior of whatever right and so what he's saying is that you have to either convert you have to like do some sort of struct to map thing or do reflect i'm onest team i think that's a i get it but there's probably other behavior that i'm missing that could also be done well or use a map no still again that's not a good case again you could just simply have things coming back that are in the object form you may not always get the option just use a map yeah this one yeah i i would just use a map but i'm just saying you may not always get the choice to just use m i agreee there no nothing you got nothing for me that's fine let's move on milk's reading i was reading chat i know you were so intense you were so intense you completely just when you had a nil pointer exception there it was your term i served it to you and you're just like i'm sorry i was reading what c a fellow twitch staff said sounds like the author dr everything is an object kool-aid and and he spelled kool-aid wrong so i was just focused hyperfocused on that i'm sorry i'm sorry is it because he spelled kool-aid with a c yes yes my goodness oh my goodness disgusting all right let's see let's see cre cannot create a new struct by picking sl emitting a few keys from another struct the code is never dry and go okay so i do agree with the second point which is the code is never dry go right right here but i i i normally just think this is probably a bad idea yeah i i i mean honestly when i first read this i i actually kind of see the validation like sometimes it is a bad idea because you don't want to have like two shucks that share like you know three out of the 10 fields of one shuck i i can understand that but there's also i i may see like a perspective where maybe you just want a very very niche struct that you don't want all the other fields you don't want everything else included in you know the the struct that you had you want them separate you want to use them for a very specific distinguished feature and then you have to remake a new struck and instead of just picking out existing fields from you know a bigger struck i can kind of see that but hold on hold on how do how do they then define it right like where they're they're putting it somewhere it's not like even if you do some sort of like exclude key or some sort of magic ty script method that i'm sure exists you still have to say i want this struct without all these other fields so it's either you provide a white or black list trying to say which ones you do or don't want or you use the worst of them all which is you just let typescript return value inference happen and then you just get these inlined objects everywhere that has like 14 fields on them and you have to go pass that around like that that doesn't seem like a w none of this for me this doesn't make any sense this argument i love the code is not dry i get that with go kind of pisses me off i'm really hoping that 122 and 123 really takes a deep look at the the standard and gives all the methods that i need right i want them all contains oh i i want contains so bad i want them all everything everything yeah there is a way that you can make a cop like a you can declare a new struct from an existing struct but i agree you would have to kind of i'm just thinking out loud you would have to filter out all the fields you don't want or somehow have like an empty struct that then you kind of pick the fields from another struct into into the struct but it's going to be the exact same thing like the behavior is it's not a very smooth handling behavior at all no neither handle it well yeah yeah there's gonna be problems both ways you see it all right painful json handling especially deeply nested or dynamic json as the json mapping logic ins side strings string struck string tags where there's no autocomplete or and no compile err i i don't i actually don't i've read this a few times i just don't agree i don't see painful json handling i actually think even for deeply nest to json like i've never had a problem using the built-in like json library and go you can define everything well you can i've just never had an experience where i was like oh man i have to use json go right now it's been fairly easy for me to just take a payload use arm marshall and handle like that like i've never had i i don't understand this point to be honest i've never felt this i honestly am just too stupid to understand the point i actually don't even know what it's trying to say i think with what it means by no auto complete or compile time or or nor compile air i don't know what i honestly are they talking about like importing jon i also don't understand that point from i don't get it at all i think when you said deeply nested i put it like when you like get a payload response from something and it's like nested it's a nested object and you kind of have to define like on go if you want to take that payload from whatever api and put into a struck you have to create like a nested struck to handle that that's the way i read it when it came to the autocomplete and the no compile error that i was just like i don't even i don't even know where to what to know for that one so i just kind of skipped that part yeah i guess i don't quite understand this one because oh i i see a point ch again did you what yeah yeah yeah i could tell right away he's reading chat again people i'm sorry but one point someone did say is like let's say in go you have like your json tags that knows what to un marshall right if you make a typo there like i'm just reading chat because it is i can okay maybe a if there's a typo there or something that's not right so you don't get that field you wouldn't know until you explicit look at that struct after on marshaling right there's nothing that tells you hey like this field wasn't unmarshal or you didn't take this f something like that maybe that's what he means okay okay that that's fair that's fair okay i can p i'm purchasing that one oh yeah all right so okay we'll give nine a little something i i i kind of get that i kind of get that yeah number 10 code littered with pointers non-p pointers slice capacity interface madness everywhere i wouldn't put it as ever i mean there are some there's some pointer pointer non-p pointer doesn't bother me i don't i don't think i ever have thought about it and go just ever slice i still don't even know what that means at this point capacity i'm not sure i've never passed a capacity around so i i i don't know what a capacity is i i don't have the capacity to understand this okay zero zero i'm not passing my capacity at all man you keep that capacity private fred it's a n pointer right now it's just a n pointer interface i get this one it is kind of annoying to see i mean again this just goes back to the sum types thing if you could have a sum type you wouldn't need to have interface and anymore i get it fine it's not really everywhere it's just some places okay whatever no function overloading i don't think this is a problem i don't think there's function overloading in typescript either there's not function overloading in javascript i don't even know what function overloading is if i'm being honest like function overloading so that's like a a remnant of java i think you can do it in c++ as as well maybe i i actually can't even remember where effectively you have a class that takes in a function fu and you can define fu multiple times depending on the argument type so long as the signatures are unique you can have the same function defined multiple times oh elixir has it but they have pattern match overloading which is actually super cool right so you can just say like if a empty array is passed in here execute this one but again no function overloading i don't think this is necessarily a problem what would be the uk case of using function overload like in any language why i think elixir is very much more clear i think elixir makes sense so a good a good version of this is in java okay i'm going java on this one let's say that you have something called like in java of course you have classes for everything called like i don't know quicksort right quick swort and inside there you have your public public void sort and it takes in in interray okay and so this is what you want but but privately you need to keep track of a bunch of information so you're going to have something that's like a private void sort that has this right that actually has your high and your low and all that extra information that you're going to want and so that way you have your public one that behaves one certain way and your private one that actually is the one that you'd call so you'd actually call sort. this right so that's that's what i know of as a reason why you' do that but i don't i don't know of any other reason why the other one people are saying people are saying function overloading for what's it called for ad right so if you had ad or max or any of those ones but you could also just use i know java disgusting dan's game hard java java java scarlet johansson or schola johansson but this one right here you can also just take that and use generics to solve that problem like i don't think that's a problem because generic solves it and so it's not a real thing all right no turner operator i mean i agree like i've used a turner operator in javas i think it's in types in javascript i love i like it but i don't know like in go i i don't know i treat javascript and go very differently no turner operator it it i guess i as far as i know there's no turn operator in go or like explicit one that i'm aware of but i've never been caught by this like and if expression so you can't return it from an if else which is like what does yeah so i don't know like the turn oper is nice when you have to use it but like i don't say it's a necessity for a language you know what i mean i don't think it's really a a if you don't have it in a language it's good it's it loses the value language itself yeah so i don't know to me it's not a huge one i i find it more annoying when i i mean because i try not to use turn aries just in general just because i i always once i start using one all of a sudden it gets a little rowdy sometimes and i'm just like i've made a mistake you know hal and so i just try not to use them in general but i i understand this point a little bit like rust has they don't have turn ay statements but they do have like let fu equals if i don't know bar then you could do like five else else six right so that would work in rust that's perfectly fine and rust and i'm okay with that i think that that would be nice to have and go but if statements aren't they're if statements they're not if expressions and so you can't the way i look at turner operat it's very like i guess my my experience with turner operators comes from two two methods react i use turn operators a lot in react like rend i think that's actually an anti pattern is is is that but keep on going yeah i think i think tj said something like that like that in chat too but then there's another one for like actual types for like cdk code like deploying stuff and it's like depending let's say you have to deploy something to aws and there's two different ways like you can on your beta environment or prod environment i use turner operators that way so like if the environment is prod this is going to be like the address of a lambda function for let's say or else it's the beta one and then you can you know you don't have to have two sets of of code but at at the end of the day it is almost like syntact sugar because it's just an if statement you can just have an if statement that that handles that as well so i don't know the feature is nice but at the end of the day it's not like you don't have the capability of doing the exact same thing in any other language get that out of there get that out of there nobody knows it happened no no no a ain't nobody knows what's going on there hey prime hey hey bisco you calm down yeah i would love to have some types i think some types would be nice but at the same time i always go back to the same thing which is go's simplicity might actually be worth it you know what i mean maybe the fact that there isn't some types and it just forces you to do something everyone just does it the same way and maybe that's okay i love some types though so i'm i have a hard time agreeing with that statement because i always get to the point of just having a list with multiple items in it and i don't want to use interface but i get it all right anyways no enums cool that's typescript known for its excellent enums no option multivalue json keys possible to express i don't optional would be a pointer right so you can say hey this thing can exist but it's a pointer yeah are they saying like you can't like if you had a value like right count count is the a number but count might not be there is that what they mean because can you do a pointer int and it' be nil or the number is that like a thing or am i like too deeply reading into to go on that one if you what if you have a a no pointer to an int well yeah because you could imagine like let's just say you had a you had something you were retrieving and it could have an optional count to it right count may or may not be there so it's a number or it's not there so typescript would be question mark number right whereas would that be like a pointer number is that what you do yeah okay well an in value we don't have like numbers but an end and i think would default to when i say number i just mean in yeah yeah yeah jerk jerk a you want to be specific here okay okay 32 okay i don't need all your bites all right multivalue json keys i don't know what that means and you have to resort to interface okay that's when you so this is a some type argument again and to do type casting later on which is difficult to read in jesson let's see is big and the code is big you know the thing is is that even if okay let's just pretend you don't do this if you have a some type in typescript or a some type in rust you still have the identical if statement going on so that's why this is my whole like go maybe can use interface is that with interface you go you know switch type is it an int but with rust you're like match thing it's an int right like i mean are you really getting around the thing it's safer in rust because rust has a type like a a compiled compiled in you handled all the possible types it's exhaustive in rust as someone saying so i get that i'm on that team but is it much different programmatically like are you really making something less or more complex i think it's the same thing just written in different languages like i i think a lot of these like little issues exist in go in rust in typescript it's just masqueraded by different syntax sugar or different you know language specific ways of handling that issue but i don't think it's nothing you i know tj is that a te meme it's a tj it's a very low quality tej meme i i'm glad tj tj apparently used a photo from'14 nobody knows what happened here the fonts are different i love how the fonts the average tour enjoyer is bigger than the average if expression enjoyer because he had to make it fit just a rookie rookie meing there i expect more from te all right we all agree with this one let's let's let's keep on going let's keep on going okay just beyond json if you if you have to do json validation for incoming request then you have to add more and more validation logic using third party libraries to json struct tags which is a string where there is no type completion or custom functions are just a pain to write okay i mean fair zod is easier to use for this yeah y okay fair we'll get we'll give point5 fair on top of 15 little cowgirl on this 15 here we go i should probably never say that phrase again because there's a there's a lot of misinterpretation in there y on top of 15 if you have also support graph wheel / websocket alongside rest apis and database schemas then it's an absolute hell and code becomes absolute mess with so much logic and the jesson strings tags on top of that validation you know i actually don't mind the string thing as well so i'm kind of if or on it i mean i actually so the when i read this point and it's like the the deb schemas i was like okay well i don't know like i've never like i guess i agree with you it's not that bad there the the strength thing but i i can see that it can be better i think this person uses tools that exist in like the javascript or typescript like ecosystem that make it easier for them and i think that's what he's saying that doesn't exist in go to to handle and that's when he's saying the code can become messy or repetitive or anything like that okay and i'd also say that if you know no matter what you do you have to spec like if you have a field that's named different you know like graph queal requires underscores and your database is in camel case and websocket sends it in camel case but the json if it comes from here is underscore right and so you have to like put in all these things anyways whether it's in typescript in the struct or not in the struct like all the naming still exists it's just exists elsewhere so i don't really necessarily see it as a positive or bad all right no meta framework this i just i don't even care i'm not even gna i'm not even going to address this opinion because hmx is great okay i love this point can we agree that htx is great it is and i love this point i love how he's using it because above he said you know it's just such a javascript thing to say like there's no meta framework that exists you know to me that's such a like okay like that's that's a point they're using against go like again 17 is one of these points in this article that actually strengthen the argument to use go in my opinion because there is no meta framework you don't have to learn a framework on top of go yeah you don't have to learn a first and also meta framework i just hate that term but you don't have to use a framework that uses a framework right okay i heard you like framework dogs yo dogs capitalize to export use instead of us okay yeah i can we agree i don't like that one i don't like i actually don't mind it i see the i this is i don't mind this i see the point of using something explicit that says like export function or public like i get it but like are we really going to complain about just capital m or capital whatever like just capitalize it and then you're good and then you're happy and then that's it like out of all the things to put onist l like i don't know about that one okay copium just saying we are going to complain yes we are i hated this in the beginning yep i believe we all hate this one hold hold on winchester hold on i think we all agree that one's awful and i think you're wrong okay so we'll go we'll go on this i think you're wrong poor generic implementation fair i don't the generics aren't complete i know there last time i looked at them to be fair i only looked at them in8 and and you couldn't do poter receiver generics and so yep fair not arguing that one yep generics are generics are just really really strange in and go and it's weird they're very limited yeah yeah and i i think i understand why i think i do due to like you know because pointers and how functions are called and all that is probably very dynamic so you add a little like a lot of dynamic dispatch on top of it plus then trying to do generics i think it kind of you know i just try to imagine what would that look like in c and i just can't imagine it so anyways no default function arguments no optional function arguments only vartic possible i mean i dis i don't i think it's good that you don't have optional arguments if i'm being honest like yeah i i i kind of like it i like the fact that you don't need to have any op you need to define you need to be explicit and you have to pass things to to to your function you can not pass what you define the contract is very distinguished very definitive between the caller and then the receiver i like that i like that to be honest very brave of you to have such a bad opinion all right no air stack traces as errors are not thrown but returned and you'll have to accumulate and build an entire stack on your own and let's see i disagree with this yeah i don't i don't think this is the same because let's just face it most people that look at a stack trace look at the last item in a stack trace and the only times you ever want more additional information is often when you're doing something yourself now i mean there is the rare case where something happens deep inside the system and you have to go debug a third party library and stack races are really nice then but typically the third party library returns exactly what happened anyways feels pretty easy i don't know not a thing i like how this person just earlier in point7 about the meta framework and i know they're different but said like oh like go doesn't have this meta framework external party and now they're saying oh well you need a thirdparty library tool for proper stack tracing it's like buddy you use javascript and typescript you're using third party libraries to create carousels and and to enlarge an image like come on i i'm i'm on this team all right let's see no try catch finally and throwing named erors is most main like okay so obviously this is just a bad we're gonna all i think we can all just move on that virtually nobody likes throwing errors yes it's the worst design pattern of all time agreed i don't have to say anything okay stir convert stir convert is the stupidest thing ever thought who hurts you i'm gonna say that saying stir conver the stupidest thing ever thought is the stupidest thing ever thought i just want you to know for a second here let's just play a little game let's go play a little game called what does node do okay we're gonna do parse int i'm gna pass it an empty string that's ro about to make a whole new event called what does node do i'm gonna do number passing an empty string zero which one do you want to choose today i don't know all right let's try this again number 07 fu that's not a number it's just not a number okay we can all agree that's not a number parse int that's actually seven it makes sense to me okay i'm just saying stir convert maybe isn't that dumb just maybe there's something to it you don't get it okay this is my favorite one this is my favorite one are you ready for this one parcent 0.05 z 0.005 0 0 point z five okay there tough guy i get it it makes i get it you just don't get it you just don't know how it's used skill issue okay skill it's a skill issue it i i get it and the real ones know okay the real ones understand what's happening whatever but here's the best part are you ready for this one i'm g to take this i'm gonna go like this i'm going to put little parentheses around this and i'm going go like this two string it's still the same answer right i'm gna go to number the threads are going everywhere i it seems like there's just two complete different people created these two methods like two separate teams entirely like departments a ain't nobody ain't nobody understand this one i i i get why it happens but nonetheless it is crazy all right you can shadow global functions and will get surprising results directly in the runtime without any errors as globals are overridden i.e len function can be overridden okay i i fair if that's true big if true big if true okay i you can you can also kind of do this in typescript too like i validated this on stream like that are like keywords that you can overwrite in typescript or javascript and they will be handled as as you know variables or constants not all of them because i'm pretty sure go allows you to rewrite any keyword into a separate variable constant but i tred to do it in typescript majority you can still do it so i don't know yeah yeah i mean to be completely fair i can also just like json.parse equals function whoa whoa so i mean you can you can kind of go you can kind of go wild yeah you know it's not like it's a it's a it's a zero this is not some sort of like one can only do something bad and the other can't okay i can i can edit prototypes i can go deep on the javascript okay we can go deep all right magic ait method i agree i think ait was a mistake because it makes testing really hard i so i honestly the magic init method like why but why does it make testing hard what is what's so bad about it i couldn't if you do it a default value on a module right so there's some default values that are set up and then you start calling into functions and maybe some stake gets oopsy daisi and gets changed a little bit every other method now getting or every other test could have some weird kind of default anit values that they maybe aren't expecting you now have built in a state machine inside of testing and stuff like that i think there's like a little bit of careful when it comes to a knit mhm you know i just a little bit careful i i prefer just a you know just know that it can it can have some weirdness to it okay and sure i do also agree that in the main function a knit is it's nice yeah all right slice capacity gotcha with pass by value versus reference can you explain this one to me as someone who's a layman well what do you mean so like if i'm asking you what do you mean what do you mean when you say this i'm asking what you what do you mean which which one of us doesn't know what the other person is saying no i okay so this is kind of like i'm not i'm not super strong at go so in my head a slice is a pointer into an array in which has a length off that has a length associated with it mhm so you can in my head a slice would be be something that does not have capacity and it does not have okay so a slice does have capacity and length so i think i just have these things incorrect here hold on a pend in the case input and output variable are different slice has both length and capacity okay so slice is effectively the dynamic array an array can have many slices pointing to it okay you don't pass slice as and slice since it passed by ref by default okay the main thing is about ref vers value pass particular method receivers oh yeah but method receivers i get that but he's talking about slices particular with passing by ref versus value so that's what i'm trying to get is i don't really know the terms quite well for go and what they call slice versus what they call an array slice is sugar on an array okay slice is the dynamic array okay that's okay that's what i was thinking so when you do something like length let's equals elements and slice yeah it's a dynamic array all right so if i take a dynamic array i guess this is a question for everybody just so i can maybe better understand this whole thing okay can we can we just agree that maybe i am i'm i can be the dumb one here let's see no i'm the dumb one that's my role here i that's why i'm hired to be here right now right i go like this right so i is that is that not valid go are we not doing valid go int is not a generic type oh come on what's what's what's the way to create this thing do i go like this to create the thing i know there's a way to do a literal isn't there can you not do a literal do i have to do that whole like make in no not map string come on all right right so then if i go a doesn't let's see doesn't b let's see b has some sort of can't i do some sort of zero to five some sort of syntax like that or is it 0 five right is that fair is b a copy or a reference why are you muted you muted yourself milk hello hey hi it's a copy of a copy of a it's a ref oh okay people are confused whether is it a copy or is it not a copy it's a copy okay okay so and then if i pass either a or b to a function it's passed as a reference correct if you pass b into a function oh people are saying bro is sleeping okay people are saying is it a copy or not a copy damn it people why are you guys being this way now we're in a huge debate i think this proves a reddit point that this is messy okay okay reddit point proved nobody knows what it is because i i just simply haven't played with the the array versus slice business okay i thought it was a reference a is a pointer one length one this one b is pointer one length two cap one it's a ref or reverse i forgot okay maybe there's something that okay now i just need to go learn the actual language a little bit better on this one our references into a window of the underlying array correct but then if what happen if you add what happen can does that mean i can append on b can i go b equals append b i'm fairly sure it's a copy like where does a get appended to as well and does this one get appended to does it overwrite part of a that's what i need to know so that's what i don't know which is which one it's doing and since i can't since chat is literally giving me many different takes here we're just not going to do it it's a freaking reference no i okay i think the problem is is that we may be using it's a copy i think yeah i think it a pend is a copy whatever oh we'll we'll figure it out later we're going to figure out later i'm not even looking at you guys anymore okay you guys are all stupid including me i might be the stupid one here easy to shoot yourself on the foot classic on the foot shot on the foot with go channel routine by getting a deadlock or out ofhand go routines the compiler does not does not yes of course race conditions are never prevented this just happens there's no typing like an arc or something that enforces it no send yeah this feels like a user issue like a like literally a skill issue this one reach me like a skill issue without properly setting and closing your your channels like obviously can have some serious like issues and deadlocks but i mean in go like it's the easiest thing to do to do this thing like i think out of all languages go is the easiest one to just define your go channels put data in there put data out close them at the end of function defer all that like it's very baked into language so yeah i don't know this definitely seems like a skill issue i would say that go by far is the easiest async like mental model of all time so i'm i mean the only thing that makes russ a little bit better is that it forces you to use a mutex anytime you want to access or mutate a shared resource so that's nice typescript it just doesn't have more than one it's it's single execution i say that very specifically because it can still be multiple it can still be multiple uh threads going on underneath the hood but it's single execution so you don't you don't there's no such thing as a mutex right you don't what are you doing all right let's see no more on the foot shooting a on a lesser note no map filter reduced that's coming right that's a part of that is either a part of things or is coming right that came out in 21 the bakedin library has methods for slices for maps that have these like quality of life functions which was the same like the version before introduced min and max quality life functions and i think they added standard libraries for handling to this as well okay that's what i thought i thought this was relatively and when i say relatively recent i mean in the last six months which is definitely longer than 17 days ago yes right definitely okay acing communication and interrupting the the parallel operations is not easy no promise all race all settled i mean there's weight groups right that's pretty much what you do yep yep i don't know i don't think that that's very hard i mean it's just like a a function promises areas they're they're not great no but i mean it's stop you can it's a primitive right the weight group is a primitive that you can just kind of control and and stop and pass into into knowledge and i don't know i' say that this is you can't interrupt skill issue yeah yeah okay creating non-trivial higher order function that can satisfy the type system again beyond trivial case you wouldn't understand a real girl is not easy as the type system is too rigid hence curring slp partial functions are very difficult to get right and go even though it is a functional language it's not fun not a functional language it's a first class function functions are first class language no go is officially a functional language now rex like starting after seeven since 17 days ago go is a functional language l plus ratio plus go is a functional language yeah oh camel has some competition officially go promotes imperative and mutable code patterns by passing pointers for a function lang for a functional language which makes code predictably harder first off i love imperative okay i'm going to just throw that out there i'm an imperative fanboy i do wish it was mute was what you opt into versus mute is or read only is what you opt into i do prefer that pattern but to me this is just i mean i'm not really sure where to go with this one other than yep that's the paradigm they wanted yep they just chose they just chose that one it's the same point with the oop and like the porish o implementation that's not how like this one's this this is the way it was designed the other one it was designed not to have that yeah mocking for test is also clunky and not pretty that's second part bizarre first part may be true i guess i haven't done enough testing to know i don't i don't agree with this like there's i think testing well mocking is very very kind of nice to do and handle in go honestly you could create a bunch of mocks for a bunch of function you can pass in where to get the reference for your mocks and then they're easy to use you create fakes all that i don't know but the like and testing is like built in it's very nice i don't know this one it's pretty and it's not clunky so just fully disagree with this testing one yeah the pretty part's kind of funny i don't really understand that one okay anyways let's see and that's it the only good thing are are easy parallelism with foot guns that's a good thing compiled to binary more performance low ram i think and go let's see everything related to go runtime but most things are aesthetic features or missing in the go language itself are peer peer inconveniences which is a shame typescript is just insanely superior to the go type system and it's just very difficult to like go even though i know the language i just enjoy writing typescript a lot more than go and get very very surprised when go developers say that go is the best language syntax typ system no one says go is the best type system no one has ever said that i don't think anyone has ever said that ever nobody no i've never met someone that's like you know what the best type system there ever has been in go go the one that comes with the box of crayola crayons yeah go has like the pass for having type safety but it's like one of the lowest level of implementations like it's like yeah yeah on paper you it is you know you have type safety but it's like it's not too advanced it doesn't have all like the sugar that really make it you know very nice to handle and get very exotic with it just it just has it to be in the club that this a type type safely type language me just tweet that one tweet it all it's a perfect tweet it's a perfect tweet it's a perfect tweet all right typescript just insanely better than go in every way in every way like literally so overall i'd say that this is a great example of when you program a language you don't want to go into the language trying to make it the language you know you use the language you know as a stepping stone right like okay i know what classes are but this thing does these strs plus fun you know pointer receivers okay i see how that okay so it does it this way you know like you use it as a jumping as a as a stepping stone you don't use it as a lens you look at a language in right and so i find that that's you know that's that's how i like to learn though is that i take the languages i know and i try to apply it to the language i'm attempting to learn and then i slowly over time try to do it in their way and try to learn their way of doing things because ultimately that's where you're going to get all the convenience from and so i don't know it just seems strange that you just can't make go typescript i wish yeah i think i wish this person if they went through a different kind of route could have actually made a really strong argument here it's like not necessarily that typ is better than go or even vice versa but like the pros and cons of both languages right and you could have had a list of like these are the great things about go here are the bad things about go you could do the same with typescript and you could have had like an argument like yeah you know what based on this i would use oneing for one purpose or if you're programming and you know you have to use i don't know go routines or whatever you can use go and and stuff like that but this is just very like here's 32 reasons i can just think of that are just programming level like just high level programming points i'm just gonna write and try to spin as cons for go yeah anyways it's it's pretty fun i think it does point out json is kind of a pain and go there's some things that i don't like about json it's not but to be fair json literally stands for javascript object notation it is obviously going to always have the best support in javascript because it literally is javascript yep lit literally it is javascript the jon one the json one yeah the nil pointer the the references and the advanced type safety that you know like the no enums the lack of lack of good generics those are all like very fairly valid points that you can't really argue against but it's kind of like how much of a length of javascript are looking at this right like are you giving go the fair shot of defending itself agreed agreed well melky oopsies i just exposed her chat to everybody i knew i was going to do that i knew it i knew it i knew i should have switched but i didn't your the dick picks are out no no remove this this has end the stream end the stream this is i need to get my pr team on this right now you should right now i hope they're not written in go it's in not i don't know go superior i i'm actually a rust developer so this whole time just masqueraded as a go developer the worst part of javascript is it can't easily use go's in coding job encoding format it is very annoying that they can't easily do that they should just be able to do that all right anyways well hey thank you very much for this i appreciate you thank you prime i appreciate this i liked the 32 point i wish i could tell people the the back and forth we had about like are you coming onto my stream are you coming on to my stream it's like i'll see you wednesday i'm like i'm coming back thursday wednesday i can't wait for wednesday it kept happening i i don't know how manytimes we missed each other all right are you ready the name is the mela jen