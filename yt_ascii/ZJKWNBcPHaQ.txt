hello everybody thank you for coming to this presentation i am john fer i live in stockholm i work for a company named net insight we do network e stuff make network equipment like these for example or or these i have no idea how many computers are on these because on every plug-in board there are at least two cpus and at least one fpj so quite a lot and then of course we connect these in large networks media companies media broadcasters love these and we make everything from designing the mechanics low-level software the electronics lowlevel software fpj programming network stack services network management systems everything so full stack really full stack but let's not let's not talk about that let's talk about jigs puzzles did you know that manufacturers of jigsa puzzles have standard cutout patterns that they use several times over for different jigsa puzzles so that if you buy two different jigsa pule from the same manufacturer that has the same number of pieces and the same geometry the piece is almost certainly fit together these are artist team client who who made this he he certainly knows it so if you go to this website pule mon. cr.com you will see several and i'm going to shamelessly use a few in this presentation because this behavior reminds me very much of the c++ type system you see if you haven't thought about it c plus has a small set of standard jigo puzzle piece shapes that fit together the way you want to or in a number of other ways also but unlike a jigsaw puzzle that you buy c plus allows you to create your own shapes and you can make them as generic or as specific as you want them to and you as programmers you use this you you create types that make up the the structure of the program you have all the monsters here and all the network requests waiting for a response and all the unpaid bills and all the customers they are there they are different types you have these in your program but in my experience programers rarely use the types for the information passed between these pieces and i intend to quite subversively tweak your brains a little bit here so that when you go back to work after this conference you will start rewriting your software because yeah you rarely do this but c++ allows it so i intend to show a number of examples of code that has various kinds of problems and i promise you you will recognize almost all of these in your code and i will show ways to improve matters the things i show you are examples there are other ways of solving the same problems the important bit is to think about how can i use a type system to make my program better so let's dive into one of my favorite examples the wrong argument so we have here some software that reacts to some kind of user input query is a database probably based on that input but we have a problem here so we we get we sanitize the input because we don't trust users they write weird things and we log this sanitized output because it can be good to to have for diagnostic purposes but we have a mistake the query is made with the unsanitized input that is probably not good but the thing is you you don't want your program to become a topic of an ex cas comic you you don't but the thing is the person who wrote this knew this is that's that's why sanitized input is there it's just a a silly mistake that was made that they happened to made the query with the unsanitized input so what can we do well one thing we can do is we can change the signatures of sanitize input and query user data so that they take a a sanitized string instead and a sanitized string must not be possible to just accidentally get from a from a standard string it must be something you you have to you have to actually call sanitize input or make some effort at least to get a sanitized string so how can we create something like that so this extremely advanced piece of code u yeah i should i should have said this in the beginning i know that i have a history of presenting some fairly advanced pieces of code this is not that talk i fully expect a very junior programmer to be able to follow everything but at the same time i think most senior programmers will learn new ways to apply the knowledge that they already have so here's this very advanced piece of code that actually fulfills our needs this cannot be if if you have a string you will not accidentally get a sanitized string you have to make an effort you have to explicitly create it and likewise you will not accidentally get a stood string out of a sanitized string you have to explicitly say that you want to get the the data memory do value so it's not perfect but it's not bad so when we do this and we have this bug we get this compilation error saying that reference of type con sanitized string ref cannot be created from stood string with the normal compiler error message encryption but this is vastly preferable to an angry customer call on the debugging session even if it's annoying to get the compilation error we can do a little bit better though how about creating a a real sanitized string type that does something a little bit more so this thing in the green box here is a a conversion operator if you have not seen those before the way they work is that in this case i have a function work that takes an int and we have a class c and in the function at the bottom we have something that calls work with an instance of c and what happens here is that the compiler sees that i'm supposed to call work with a c but i don't see work takes an int c is not an int but it sees this conversion operator operator in const and this is what is called a conversion operator you almost always want these to be cons you don't want your conversion operator to change your object or to leak it internals normally to be a little bit more safe you can mark it explicit now you now it doesn't just happen to become an int you you have to have this static cost at the bottom to say no i want this int don't just accidentally become an int so we have this explicit operator con string ref we have the string is private so you you cannot accidentally modify it and we also have a constructor again explicit and also if things are too weird to be to be sanitized it throws which means that it it's very difficult to get a sanitized string that does not have that doesn't have a sanitized string that is possible to use because if it's too bad it will throw then you don't have an instance if it if it doesn't throw you have to explicitly ask to get the get the string representation and the api uses the sanitized string so we can write the code like this we create a sanitized string from the input this will either work and be safe or throw an exception we can log the sanitized input and we can make the query with the sanitized input and if you accidentally again use the unsanitized input in the query you will get a compilation error and in in my opinion this is is very clean code it's easy to read and it's very correct and very difficult actually to get wrong so to summarize even a very simple struct just completely eliminates a whole class of runtime errors you get a compilation error instead and private data and throwing in constructor makes the right thing easy and the wrong thing hard which is exactly what we want and almost always use explicit for constructors and conversion operators almost always there are exceptions but they are rare if you have questions just wave at any time don't wait to the end yes con should you mark constructors that takes multiple arguments as explicit maybe the if you don't mark them as explicit you can for example if you have have a function that takes a type you can just instead of writing the type you can just write empty curly braces and the values used to initialize it if it's not marked explicit if it is marked explicit you have to write the name of the type so a resounding maybe other questions right let's go on to the next one this piece is called the osaurus rex which i think is very we have all seen functions like this you have we have a print it takes a string view and a load of bulls should we truncate if this string is too long should we pad if it's not long enough should we add a line feed to the end and i mean the the function signature looks all right this make sense i hate that line it's absolutely horrible when you have when you see your function call and it's just false false true like what is this it's not possible to read it and understand what is the intention it does not give information a technique that is used sometimes is that you create variables that says line feed equals true and then you call it with line feed but since there are all bus if you accidentally reorder them it will compile fine it will look fine but it doesn't make sense so so what can we do well enom clause is great by by doing this and i really mean enom class don't use a c enum they are just glorified in enum cla in this case it creates three unique distinct types called truncate pad and line feed and all of them have members off and on so you can write the code like this print food truncate off pad off line feed on this is clear it's a bit verbose i i admit but it is clear actually i think this is a kind of verbosity that is good because it adds information it adds clarity and since there are distinct types if you accidentally rearrange these truncate off and pad off for example you will get a compilation error because they are they are not interchangeable types although i do agree that there is a problem on in the function signature i haven't actually seen a a good naming convention that makes this not look bad but h i'm prepared to pay that price it's not it's not the end of the world so on bus in function function parameter lists you almost almost never want bull parameters and you especially almost never never never want several bulls in fact i cannot remember a single case where i would want that and enam cla adds the good kind of verbosity that enhances readability you your code shows intent instead of just naked numbers or or well true false in this case beware the we rabbit so we have we have the same code it's it's not great but we all have this kind of things in our code base don't we and it it's been working for quite some time but somebody realizes that hey a this line feed thing is it's almost always line feed so why not default it to make it a little bit easier so someone makes this change it's fine it's working it it's goes on in use for years but one day someone realizes that this implicit field size that we have that that is not actually very good we should we should always provide a a field size for for this string so we add we add a new parameter there this compiles no compiler that i have tried this with warns about it because bu is an unsigned integral type and its value space is strictly within the value space of size t so this is in terms of the language rules this is a perfectly safe conversion so this this calls print with fu a size of zero truncate being false and pad being true and line feed is true by default a few colleagues of mine were bitten by not exactly this line of code of course but a similar thing a number of years ago and this was a fairly large code base a function that was used in many places and had a default and the parameter types for that call were interchangeable and they did exactly this they added a new thing early in the function signature and it compiled they they of course made the the changes that they saw but there were hundreds of call sites and they missed a couple and it took them days to hunt it down because unfortunately the program didn't just crash and burn it had it done that it would have been easily caught but it just sometimes behaved a little bit oddly so beware the dangerous defaults so but what can we do the previous solution actually solves this one too have again trun a pad and line feed are distinct types different types and this makes the call a compilation eror because we cannot convert implicitly trun a off to a size t the compiler just says ah i have no idea what to do here you you have to fix your program this is but one example of how you do it and another example would be to also make the the field size a type of its own that isn't convertible from from bu and probably you should do both but the the important thing is that you really don't want arguments of convertible types next to each other in the call call chain especially when you have defaults at the end because that that just opens the gate for for new problems but and this is a different type of problem compared to the one the ones i i showed earlier the the earlier ones were were problematic directly when you wrote the code this this works fine but it is dangerous when the code evolves so it's working fine as you have it but suddenly you make a change and boom you get a very unexpected side effect but again distinct unique types that are not interchangeable saves the day so as i said default parameters are extremely dangerous over time if the parameter types are interchangeable if they're not it's it's fine and unique and non-convertible types catch this you you get compilation errors if you make a mistake how the west was w if i remember correctly ah this is a this one is a beauty so i work with networking and the networking apis often look like this and you you you get call backs of what or whatever you you you handle network packet data as a contiguous piece of b and very often and you just get a pointer to the beginning and the length the posix apis for example are are all of them are like this so in this case we have some function that receives a packet we po the header and then we want to copy the payload of the packet that comes after the header so copy payload we add the header length to to the start so that we don't copy the actual header again but we should have reduced the length so now we have a read past the end we have a buffer overflow situation this is how your programs make the news but what is actually the underlying problem here so in my opinion the problem is that we have two we have two parameters that together describe one thing the the one thing is this contigous block of memory that can be inspected that that is the thing so let's write a type that represents that so i can write a very simple buffer view where i have i have begin and length the same as before so it's it's easy to initialize i use them as const so that we cannot accidentally modify this into something that doesn't make sense that is wrong and then i can ask for a prefix but i said give me the first len bytes and we create a new buffer view with those now there's a a decision to be made what should you do if the length asked for is longer than what actually remains in the buffer and i cannot say what is the right thing to do i i choose to truncate maybe the right thing is to abort maybe the right thing is to throw an exception it's probably not the right thing to ignore it but these are decision these are engineering trade-offs that you you have to make but just make a decision and document for those who uses what what the behavior is and we instead of modifying this buffer view we we create a new view into the same block of data so this is safe it is difficult to accidentally get this wrong so now the code becomes this receive packet takes a buffer view we par the packet to get the header par the header of the packet to get the header as a as a sub view if you like and then we copy the payload as the packet the suffix of the packet after header length i think this is good code because this instead of trying to read the the arithmetics that goes on you the code actually says what you want to do it expresses intent which means that the risk of error is reduced when you can still of course have a bug in the implementation of suffix after or prefix but i would say it's it's a reduced risk because you you say what you want to achieve but of course we all know that immutable data is problematic for example it means that if we have a vector buffer views and we want to erase one in the middle that will not compile because if you aras something in the middle it shifts those ws the end by copy assignment and there or move assignment but that won't work when you have const members so maybe we should do something a little bit more sophisticated we have our buffer view that has the private members but now they are mutable and i choose we need some way to access the underlying data i choose to have begin and end because that plays nicely with est algorithms and range for and for the love of everything that is sacred please please please please please show restraint here don't don't write more than it's needed right write exactly what you need right now nothing more it is so easy to be carried away and say yes and someone will want a function to calculate a check some and someone will want a function to whatever that is a maintenance bur you have to make sure that these are working throughout the changes of the code and maybe no one will ever use them so john carmack of id software fame said this very good it's it's hard for less experienced developers to appreciate how rarely architecture architecturing for future requirement or applications turn out net positive i'm guilty of having done this but please try to restrain yourself write write what you know that you need right now because i mean you know it it's needed to write it and if it turns out that someone actually needed something else you can go back and change it it's software it's soft you can change it you're allowed to do that it's it's not written by god almighty it's written by robert two de away talk to robert so write small types that exactly what you need right now add stuff if you need to so the thing with coupled parameters is that when several parameters together describe one thing try to model that as one type that describes the thing and from simp plus 20 we got st span that models this start plus length thing this is great but you probably don't want to use stood span in your apis not sometimes you do if you have very generic functions but in this case we are talking about functions that work with network buffers it doesn't make sense to pass a stood string to that or a stood vector that is not that is a different thing and span would take those but by all means implement your buffer view in terms of stood span and if you do you this is something that few people know of you probably want to use st span of const u inate star uate t because the span itself it who watched the victor's talk yesterday about regular types a handful of people so you know his takes on on span and why it's dangerous if you the span itself doesn't own the data it it refers to it and a const span still refers to the same thing and it that if the type it refers to is not const you can still modify that data through a const spam but if you write the span of conent then you will not be able to modify it because it's a con un that it refers to i forgot the name of this one i'm sorry too many defaults yeah so we have some kind of server socket abstraction where for ip and we want to get a which port should we listen to and they are almost always tcp so they're hardly ever udp so it makes sense that we default it and which address should we listen to well it's almost always 0.0.0.0 which is listen to all network addresses that this server has but occasionally you want to be able to change it and sometimes maybe you actually want to subscribe to a multic group but that is rare so defaulted to null opt and should the iu be blocking well probably not so not non- blocking is true but what if i want all the defaults but except that i want it actually to be blocking the rules of the language are such that the if you you you cannot just change one of these it's a you fill them in from the beginning towards the end so if you just want to change non-blocking to blocking you have to add all the parameters which is noisy and error prone so what can we do well we can do something quite simple we we create a configuration struct internally here and we use the the in initializers of the members to to get our default which means that if you just construct a config you get all the default values and then you can modify them to make deviations from the default if you're in c+ 20 or later you can use the designated initializers to to to be very clear about what it is you want to say no it's a server socket on on port 1666 on local host instead of on all networks and in this case i want the iio to be blocking this is nice it's readable before simple plus 21 way of doing this is just start with default constructing and then you make the assignments to to the deviations from the defaults it's it's okay but omitting port is not an error if you have a very recent gcc it will warn clang and msvc will not warn and the reason for this is that this is extremely well defined by the language so exactly what should happen if you if you don't give a value to port it will be initialized to zero [music] so nothing nothing to warn about it's probably not what you want so enter the most advanced piece of code you're going to see today it's advanced because it's a template so must inate must inate of t it it holds t as a value and i don't know if you know the rules for when the compiler is allowed to make make a constructor for you but when you when you have added a constructor that takes some type or several the the construct the compiler is not allowed to generate a default constructor for you so by having this must init that takes a value you don't have a default constructor and then we have these conversion operators to get the underlying data i am violating the recommendation i gave earlier about conversion operators that should almost always be explicit but almost not absolutely always in this case i think it is okay because for example with the with the port i i want this to for all practical purposes just be a un 16 i just want to ensure that it's not default initialized that you you must give it a value so i think it's okay in this case if you would write this code and ask me to review it i wouldn't complain but i also wouldn't complain if you actually did make these conversion operators explicit and i wouldn't complain if you made the constructor explicit either it's it's all right but i don't think it's necessary in this case so with this if we change our struct now to have a mate unit 6nt for port it is a compilation error to to not give it a value which saves some head scratching and debugging time so use this feel feel free to use this example in your code so creating structs with parameters is especially help helpful when many of them have reasonable defaults yeah you can argue about the reasonability in that example but whatever and since c++ 20 with designated initializer syntax it's extra useful because it makes the call site so clean you just write curly brace on the dot dot name equals value. name equals value do name equals value and it's very clear what you want to do i'm going a bit too fast i'm going to end early you're not asking questions okay wrong key this one is interesting so this is a very contrived example we have some kind of controller over networking sessions and it keeps track of both client sessions and service sessions and we have at the top the this server id and client id that we that we use and we have this close server that takes a server id wait a minute that is confusing that is probably not what was intended so what can we do about this well to begin with the root of the problem here is that we use a type al is for client id and server id these for all practical purposes these are in there is essentially a comment that says this int is called client id compilers don't read comments they don't care if you give it a file descriptor if you give it a a random number it will be perfectly fine so again let's revisit the enum clause but in a different way so now i say in cla client id colon int which means that this client id is for all practical purposes an int where it's implemented in in terms of an int it's underlying type is int but note that there are no enumerators there are no names in there this creates new unique typ types they you can use this technique for any integral type and this was added in c+ 17 so when you have this mistake then you you get a compilation error and not a debugging session so that is always nice the way these work is you can initialize them with a value of the underlying type like so and you you can assign them and copy them you you get the underlying value by by a static cost or if you're in c+ 23 or later you you have access to the underlying to to underlying function you can write that yourself if you're not on c+ 23 it's not particularly difficult to write and you also get equality comparisons and ordering for free the compiler does that for you so an enum class of an integral type with no enumerators is is regular and ordered strongly ordered type and therefore it can be used as a key in a map this is a little bit verbose though close server server id server session etc we can we can actually reduce this now if we want to so we don't really need to refer to the server or the client in the names of the functions because the types carry the information so if we want to we can we can do overloads like this close session with a server id a close session with a client id because you can overload functions on different types these are distinct types unlike the type aliases which are as i said they are commons you you cannot overload on the comment whether you want to do this or not is is a design decision that you probably want to discuss with your team but now when they are unique distinct types you have the option before that you did not have that option all right but what if the keys aren't of integer types then how how do we handle this because enum clause only works with the integer types what if i want to use stood string as the underlying type we cannot have an enum colon string it doesn't work well we can write something like this i have a server id an explicit constructor from a string explicit conversion operator to get to see its internals and now i'm on c++ 20 so i use this magic starship operator to get all the all the comparison operators equality and ordering and i can just default it then it will be by member so if you have several members you you will get lexic graphical ordering and that is actually all you have to write if if you or in c++ 20 so that is cool it's it's not a lot of work so you can solve this problem with a with a few lines of code even for underlying types that are not integral so enom class is great for creating new integral types spaceship operators is awesome it's absolutely fantastic it sav gives you a lot of work and avoid the use of aliases in function signatures now type aliases are tremendously useful but not in that context not as in function parameters so we're at the end now i said i would end early because you're not asking questions types reduces a risk of calling functions with the wrong values they reduce the risk of reordering they reduce risk that dependent values diverge like in the case of the uh network packet buffer types make it easier to manage defaults like in the configuration construct where where you had the members are given initialize the values directly in the declar ation and you can use designated initializer list to to state your deviations from the default tbes make your code more expressive because well i will actually get back to the because soon the the important thing here is actually the last two bullet points it is rare at least in my experience it is rare that you know up front which types you need you you discover those as the program evolves and your understanding of the problem domain evolves and when you when you realize that wait a minute this should be a type that is distinct from other types write that type and incorporate it in the code and as you do this over and over the type the code evolves you get what i call inverse cod rod you know this idea that your your design starts beautiful you have this great id and then reality hits and it just degenerates and becomes worse and worse and worse but you get the exact opposite as you learn you write new types you incorporate those types in the existing codebase refactor make new types refactor the code becomes easier to read because the code now starts to communicate in terms of the problem domain instead of in terms of the primitives used to solve the problem in the problem domain so your code now begins to talk in terms that people who are not deeply familiar with the implementation can understand the meaning of i want to refer you to two other presentations on on this topic they are very different presentations the first one shandor dargo did at c+ on c last summer where he looks at the specifics of creating strongly typed containers so that two say vectors of in are are not interchangeable because they are different things and he goes through number of different ways of solving this and talks about their advantages and their disadvantages so it's highly recommended if you want to dive into this more about how you design your types peter somad presentations from cppcon 2021 is amazing what classes we design and how because peter's observation is that you only have have a handful of categories of types and these have different rules for how they should behave and if you if you have adopted that wisdom and you you understand the different categories of types then when you design your new type you can think ah but this is a handle kind of type therefore it should behave like this for example this makes your types less surprising for your colleagues because they follow a familiar pattern and it makes it easier to communicate with your colleagues about how a type should be designed and of course visit this the tim klein's web page for more of these amazing jigsa puzzle mashups they are actually for sale so maybe actually buy one and hang it on on your office wall to remind you of using the type system and with that i am done thank you very much for your kind attention maybe now you're not too shy to ask questions so i understood your load of pools and wrong key examples your solutions to them are effectively defining strong type aliases and some other languages have a core language facility for defining strong type aliases for example new type in hascal do you think it would be a reasonable addition to c++ to have such a syntax yes i do but i'm not sure how how i would want that to look because as i mentioned about peter su's presentation you you have types of different categories so you may want to limit your types to these types should allow these operations this type should allow those operations and i'm not sure how you would want to model that in the language but i but i definitely think that we want some kind of mechanism to be able to do this yes thanks okay well so far we have no questions from the online audience but i have a question and that is the this trick with the the enum for integral types does that mean that all these strong types strong type libraries that i think you and peter have written are defunct at least for integer integral types no they are not because of the reason for the answer for the for the other question so if you if you look at for at my library that is the one i know well the others i have superficial knowledge about you you restrict your type my default is a handle kind of type you you can it's regular you can give it a value you can compare it for equality you can copy it and that's pretty much it and for if you want to model say a file descript that is exactly what you want nothing more if you want to be able to do arithmetics on it that is an addition you want to say no i want this integer to be arithmetic or i want this integer to be move only it shouldn't be copyable or maybe it it should what when can i take some examp ah you get the idea there there are a number of restrictions that you want to make the with with the class thing you you get a regular ordered type that is what you get period okay thank you anyone else right thank you