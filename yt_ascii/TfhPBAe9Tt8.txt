hello i'd like to start this video by quickly fixing a mistake that i made in the last episode which is that if at any point in the past the guard needs to make an anti-clockwise turn you'll see that this won't actually work so once we get to this point the guard just simply won't rotate now that is because in the guard script in the turn to face corrosion the while loop only runs if this delta angle is greater than some small value but what i forgot is that if the channel is anti-clockwise then the delta r angle is actually going to be negative so what you want to do is take the absolute value of the delta r angle in other words just make it always be positive so we just surround this in a call to mass f dot abs for absolute like so and now that should work fine so if i just run this to make sure we should see that it now rotates anti-clockwise great so with that done we can move on to the challenge that i set at the end of the last video which was getting the player controller working since we're not going to be dealing with the guard for a little while i'm just going to go ahead and hide the guard and the path object and just go ahead and create a cube object called slayer and i'll reset the transform on a stand just bring it up to 0.5 on the y-axis its resting on the ground now i'll create a c subscript called player and attach that to the player object and open up the player script so in here i want a public float to control the move speed and i'll set that robot se7 and then in the update method i'm going to create a vector3 called input direction and set this equal to a new vector3 with input.getaxis raw horizontal for the x-axis 0 for the y axis and then input.getaxis raw vertical for the z axis and then also normalize this since it's a direction all right so let's not try using this to calculate our rotation we've seen how to do this before using the a-10 to function so i can say float target angle is equal to methe f8n - of input direction x comma input direction z and then multiplying this by that conversion factor of radians to degrees all right so if we just say transform euler angles is equal to vector 3 dot up multiplied by the target angle then we should be rotating around the y-axis based on the keyboard input so i tried this out that seems to be the case let me just select the player so you can see the actual arrows and that does seem to be working fine so let's now try moving the player with transform translate along the objects on for direction multiplied by the move speed multiplied by time dot delta time and relative to space dot world now as it stands the object will always be moving forward but we don't actually want it to move if there's no input so what we can do is create a float called input magnitude and just set that equal to input direction dot magnitude so that's essentially the length of this input direction vector so it will be 1 if any of the arrow keys are held down and 0 otherwise so if we multiply this over here by the input magnitude then if there's no input it won't move so let's save this and try it out so press play and we can now move around so that's very nice but i would like to smooth things out a bit so that the turning and the moving isn't so abrupt so let's go back into the script and i'm going to start by getting a smooth version of the input magnitude so i'll create a float smooth input magnitude and then we want a public float called the smooth move time sort of that equal to about 0.1 so that's sort of roughly the amount of time it will take for the smooth input magnitude to catch up with this target input magnitude then the smooth damp method that we're going to be using will need to keep track of the velocity of the smoothing so we need to create a flow to course and make like smooth move velocity for to stall that value in and we can then say smooth input magnitude is equal to mass f dot smooth jump from the current value so that's the smooth input magnitude to the target value which is just the input magnitude and then it wants a reference to the current smoothing velocity and so we use the ref keyword that we can actually modify the value in that variable very parsons smooth move velocity and then the smooth time which is just our smooth move time all right so if we then multiply our move amount here by smooth input magnitude instead of just input magnitude then if i now play this we should see that as i move up there is some smoothing applied now one weird thing is happening is that when i let go of the keys the character starts moving upwards because it's invalid keys the angle is being reset to zero so let's actually apply some smoothing to the angle as well and we'll fix that problem so go to create a public float called ten-speed and set that equal to about eight and then we'll keep track of the current angle in a variable over here and then say angle is equal to and we'll use the math f left angle method to learn from the current angle to the target angle with a speed of time to delta time multiplied by ten speed all right so then we just multiply by the angle instead of the target angle and if we say this we should see that there's some smoothing applied to the rotation now but we've still got this problem that when i let go of the keys it resets the angle to zero so what we can do is tell us to stop interpolating the angle when the input magnitude is zero so simplest way to do that would just be to set the speed here to zero when the input magnitude is zero which we can of course do by just multiplying by the input magnitude so if we do that and save and play this should now be working how we want it to currently there isn't any collision detection being applied until if we create some sort of obstacle just make a big qpr like so and we'll make a new material for obstacles apply light there and it may get a red color so if we now move into this obstacle we just go straight through it so it should fix this i've gone to the player and add a rigidbody component well then of course i want to reference to that component in our player script so let's create a rigidbody variable here called simply rigidbody i guess and then in the start method we can say rigidbody that should be with a small r cuz it's the name of our variable is equal to get component of type rigidbody now we'll be using this rigid body to set the player's rotation and position so we can actually get rid of these two lines and remember that rigid bodies need to be updated in the fixed update method so we'll create void fixed update and in here we can set our rigid body rotation just with rigidbody dot move rotation and not once a quaternion for the new rotation of the rigidbody so we can say quaternion euler which is a method that converts a euler angle to a quaternion so our oil angle of course just vector three dot up multiplied by angle and then we want to set our rigid bodies position so to do that we're in tunisian air with a current velocity of the player so let's go up here and create a vector three velocity and at the end of the update method we can set velocity equal to transform got forward that's the direction x move speed x the smooth input magnitude so then we say rigid body move position and the new position is equal to the old position so rigid body position plus the velocity multiplied by time.deltatime all right so if we save this and press play we can still move around as before only now you can see that we're actually constraining to collisions all right so with the player mostly done i'm going to shift them out of the way quickly and re-enable the guard and i want to mess around a bit with the spotlight settings so first of all i don't want the spotlight to be whited out by the directional light that we have so is going to turn down the intensity of that of edge all right so the main thing that we can see is this spotlight and i'm going to bring it up a little bit on the y-axis a little bit brighter and also you need to change the shadow type to hard shadows so that the obstacle actually occludes the light if we rotate the guard or you can see that working fairly nicely it's not super accurate at the moment but if we turn the bias value down over here then you can see it's a little bit more accurate and also going to reduce the range to about 13 but one thing we have to be wary of is that the range of 13 but once you actually get 13 units out the light is very faint so a player playing the game might sort of misjudge how far the guard can see which would be a little bit irritating so we're not going to use this range value as the actual distance that the guard is able to see we'll use a slightly smaller value but we can use this spot angle here for the guards view angle so let's go into the guard script and we get a reference to the spot light so just public light spot light and then also a public float view distance and then a private float called the view angle and we'll set the view and in the start method just view angle is equal to spotlight spot angle all right i just like to have a way to visualize the view distance so we can just draw a line using gizmos so this will quickly set gizmos color equal to perhaps color red and then gizmos i'll draw a ray from the yard current position in the direction just of the guards for direction and multiply that by the view distance all right so let's go into unity and on the guide we can now apply the spotlight and increase the view distance and you can see this red line being drawn here and i'd say that a lot at about 10 that's where the light is still very clearly visible so i'll use that as my actual view distance for the moment okay so i'd now like to give you the challenge of determining if the guard can see the player and that's based on three factors the first being is the player within the view distance the second being is the player within the view angle and the third being is the line of sight to the player obstructed by an obstacle okay so i'm going to start out by adding the player tag to the payroll correct and i'll use this in the guard script to get a reference to the player transform so i'll create transform player and then in the start method i can say player is equal to game objects dot find game object with tag passing in player and then get the transform component of that game object alright and i'm going to create a method that returns a bool called can see player and the first thing i'm going to check is if the distance selector through a distance between the guards position and a player's position is less than the view distance now of course if you wanted to optimize this a tiny bit you could compare the square distances instead since that's a tiny bit faster but we won't worry about that for now so having passed this first check we want to see if the angle between the guards forward direction and the direction to the player is within the view angle so let's say vector 3 direction 2 player is equal to players of position - transform that position and dot normalized and i can say float angle between guard and player is equal to vector 3 dot angle between the guards forward direction and the direction to the player ok so it will just return the smallest angle between the two so we can now say if the angle between the guard in the player is less than the view angle over - then we've passed the second check and all that remains is to see if the line of sight to the player is blocked by an obstacle so to do that i'm going to cast array from the guards position to the player's position with a mask only obstacles and effect ray hits anything then we know that there's an obstacle in the way so i mean to create a layer mask so public layer mask i'll just call this the view mask and then in here we could use physics or a cast but it's probably slightly easier to use physics or line cast in this case which is the same thing it just allows us to pass in two points to cast the ray between so we wanted to start at transformed of position and end at player dot position and we'll pass in the view mask all right so if that hits something then there's obviously something in the way so i made to add a little exclamation mark here to say if we haven't hit anything in that case we've passed all three of our checks and we can return true so we're saying we can see the player but if any of these fall through then we're going to return false okay so now in an update method we can just test this out by saying something like if can see player then i'll just set the spotlights color to color dot red and then as soon as the player is no longer visible i'd like to set the spotlights color back to its original color so that means have to save that at the beginning i'll just create color i call this original spotlight color and in the start method you can say original floodlight color is equal to the spotlight color and then here we can say spotlight color is equal to the original spotlight color all right let's try this out so i'm going to have to remember to add a obstacle layer to this obstacle so let me create that quickly and add that there and then on the guard set the view mask to be obstacle all right let's try this out so i'll walk into the field of view and turns red and then as soon as i exit it goes back to yellow so that does appear to be working as intended oops i fell off the map but otherwise that's all looking good okay yeah so until next episode i'll be leaving you with the challenge of designing a small level and making it so that if the player makes it to the end point then a congratulation screen pops up and if the player is spotted in a game over screen pops up with an option to retry the level i think it might also be nice if when the guard spots the player the spotlight turns red over the course of say one second and if the planner is to escape the field of view on that time then they're still safe and the spotlight color turns back to yellow alright until next time cheers