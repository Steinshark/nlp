um hi everyone i'm victor thanks for coming i have the best slot in the schedule right after lunch everyone is going to fall of sleep now i'm fairly confident by the way if you if some of you know what company i work for or maybe if you if you enter the room hoping for some announcements or latest and greatest and that kind of thing this is not that kind i don't do those kinds of so definitely the things i'm going to talk about today are not official company agenda i don't represent the views of my employer and some of them might not even know i'm here and as always i'm going to have opinions so i'm i'm going to present some facts and i can i have data and and links and references to prove them and i'm going to compare some stuff and i'm going to pepper that with some opinions and and suggestions and questions for you so by all means i meant this as a dialogue so u feel free to interject at any point ask questions share your opinion preferably if you can do it on the mic so everyone can hear and gets recorded for better or worse uh if you're reluctant to do that on on record i'll be here till the end of the conference just find me anywhere i think you can easily spot me and just corner me and say say whatever you think about the topics but i do encourage i i sort of initially i when i when i started working on this presentation i jam-packed it with tons of information and lots of details some of them technically interesting but not really relevant to the bottom line of the idea so in the end i i opted for more of a bird's eye view of things and i've cut some of the ugly details although i reference them but i can chat about them offline maybe because i i want to leave room for people to breathe because i don't want this to be like a a fire hose kind of presentation where i go through a lot of stuff and people are just overwhelmed or have difficulties following and also i want to leave room for discussion and questions and interpretations but first off yesterday during the morning keynote i grabbed two bottles of water while kevn had te technical difficulties with the projector i grabbed two bottles of water out of the fridge here on the hallway so can anyone notice what might be the connection between those water bottles and my topic do you have a good eye shout it out different interfaces at the top yeah yeah so honest to god i grabbed them from the same shelf in the fridge and they i even looked so they're both still water so i thought i grabbed two identical bottles not quite so what does abi really mean anyway can mean a lot of things and depending who you ask depending on at what end of the foot chain so to speak they they spend their time they they might give you slightly different answers if you're asking a compiler engineer or library writer or an application developer or a hardware operating system person so they might give you slightly different answers is it the platform is it the hardware abi are we talking about i don't know exotic architectures calling conventions language specification compilers how implement how do we implement standard libraries and how we share them how we do dynamic loading and so on then all sorts of things they all sort of go on the this abi umbrella that everyone sort of talks about so at the end of the day it's about the you know when you say the devil is in the details well these are the details the implementation things and generally we need to agree when we build stuff we need to agree that stuff we're referring to means the same kind of things and if we're building those caps for those bottles they fit on on bottles even if they have like slight differences there at the top formation of the bottle so we need stuff to just work so abi stability isn't really technically a property of the programming language itself although people usually like to associate these discussions with lang anguage discussions and standardization and it's really more of a property of a system or or its tool chain but because we strongly associate language names with the their tool chains or their systems or their vendors or their platform that they support we usually mix up these things so some aspects are defined by the platform and the operating system some by the tool chain how the vendor choses to implement things or to support already shipped things and there are many situations when the platform owner actually requires you to build with a particular version of the tool chain so that it works on the the target operating system version apple would be prominent example in this in this camp and of course this is a really big deal if you care about dynamic linking and about sharing libraries and even here we have a very wide spectrum of priorities and necessities depending on the kinds of things that we're building for for many application domains dynamic linking just doesn't make sense isn't applicable or isn't a priority whereas for other situations sharing u run times sharing library implementations thinking about code s and how you fit in the system or how you can service those components while they're shipped the ability for example to independently patch security vulnerabilities in in in libraries that are shared across multiple applications the the ability to service operating system fundamentals without requiring applications to recompile or retarget against those patched versions of the run times so those are different concerns so again we have a very wide spectrum of what applications need and usually prioritize what we care about so trying to be more concrete here so layout of types that's the first thing that comes to mind when you think about abi size alignment stride in in some situations this makes a difference when we talk about co inhabitant of types if you think about fanc constructs like enams that have associated types and st becomes important when you think about array so size alignment offsets types of fields and their offsets in composite aggregate data structures vtable entries we if we have any any such things in our types calling conventions name mangling metadata if applicable for for the language or or the runtime in question and yeah name mangling matters because we're actually using 70s era technology for linkers so just to build like a common understanding of what we're talking here we have a a source file that implements a particular definition for whatever types excuse me we're defining there and we we compile this together in in a unit and on some other side someone wants to consume some of this implementation and of course it will compile the source code against the definitions that we provide and hopefully these things should somehow connect together and i carefully plac those gears in in in in in the slides so that they look like they fit and don't grind together so yeah binary compatibility between separately compiled artifacts this is what the kind of thing we're talking about and it's not just about evolving and modifying the type layout for for a particular type it's also about flexibility to upgrade or change your your tool chain for example you might have this separate artifacts compiled with different versions of your of your tool chain or there i said maybe different tool chains and you're sort of trying to mix them together so we have to carefully orchestrate these kinds of things so that they just work and we don't have any surprises and surprises can be really weird it's not like we uh get nice diagnos sticks for these kinds of things or we can easily uncover them sometimes they're really sneaky they can seem to work and then mysteriously fail for some some reasons when you list expect it as usual okay so the idea is we sort of want this predictability this stability so that we can freely mix and match so that we don't have to share source code for a library for example so that we can access the most recent version of our compiler our tool chain be able to upgrade without worry that things might break or i have some third party dependency that i'm i'm going to have to leave behind or u recompile or i don't know maybe the vendor went out of business and can cannot get a newer version of that dll or whatever so upgrading with is don't com don't recompile the world maybe even like a efficiency step in terms of build pipeline like being able to just move forward without recompiling the world every time the ability to incrementally do stuff and yeah i mentioned this earlier the ability to actually patch stuff and address vulnerabilities in in shared libraries vulnerabilities in operating system foundational components without requiring applications to to deal with that burden and size does matter yeah when you're sharing a lot of even for the standard library or the the some runtime that you're consuming or depending on having that payload in every component that actually relies on it statically it's a cost that not all environments can afford so being able to share that code again it's a win so the idea is that if you do want to to have this stabilization and and all these properties when should you look for them when should you opt in if you do this too early you end up shutting a door on future compiler library optimizations miss out opportunities like i don't know implement a better calling convention or change the layout of a particular data structure so that it's more optimal or improve some detailed implementation of standard library facility standard thread and mind you these the these are not impossible things it's they're just tough problems so it's it's not one of these uh six impossible things that kevn mentioned yesterday it it's it's these constitute lots of small little details that can be addressed with enough effort and desire to do so cuz i i will question that not everyone actually cares about these things so yeah we need to invest a lot of time and solve them but there are potential solutions so it's i i mentioned this earlier abi stability is not necessarily a language thing it's i would say mostly a library evolution concern and and how we choose to improve evolve the the libraries that we're building or consuming so developers want to evolve their libraries without breaking api because then they'll have a better chance of their changes being adopted quicker they want to add new functionality fix bugs improve performance problems these kinds of activities can in some situations generate ai brakes and hurt consumers for example adding a field to a class virtual function we use some padding or some reserved fields and so on could have surprising effects sometimes and we've seen for for many years we've seen implementations hold back on different improvement opportunities because they just they're just afraid they they might break their client code so if you're looking like a let's say over the fence when whenever you don't know what to do you look over the fence to see well what what do other people do well i would say a bunch of our usual suspects there they outright claim that this is not an active concern they have different priorities well c++ were always undecided but i'll get into that so for carbon for example they state we have the explicit known goals for carbon including a stable application binary interface for the entire language and library and perfect backwards compatibility so they just don't want to deal with this now they have other priorities when building this emergent new technology rust should be more mature by now they have plenty of facilities maturity tools language means to deal with additions and fairly good tooling still this is by the way this is comment is from 2015 but there's no new since so rust does not care about defining an an abi so they're very much embracing the build everything leave at head sure semantic versioning for crates but build everything for from source so they they have no such priorities at least for now zig natively supports the cabi for things well everyone tries to do that but zig internally does not use an api meaning code should explicitly conform to cabi and all other assumptions are off the table so again no guarantees their focus is completely in other directions go pretty much the same thing by the way these are they're not properly marked on the slides but these are quotes from the pages there's this is are not my interpretations so gobi defines the layout of data in memory and conventions calling conventions this api is unstable and will change between go versions like they flat out said it no no guarante is offered so i mentioned this earlier when deal dealing with these kinds of things you have various considerations various constraints business priorities technical limitations user demands and and so on so you have multiple choices multiple things that you need to consider and prioritize accordingly like what you want versus what you need or can deliver now to customers so when we think about layout and and stability of of type layout this would be the the gold standard for for stability right one level of indirection solves every problem i still feel in the room i have to acknowledge level of indirection in the room so yeah you can indirect everything through a pimple like interface but that's it's it's not a scalable solution it's not nice and it does come with with performance cost even even if you don't really need it so it's it's it's sometimes employed but it's not a pretty solution just erasing every trace of type rigor and performance that's another choice we we can do that i i just heard any mentioned this morning and of course we have the greatest champion of abi stability and dynamic linking out there and by the way that c is not carbon it's the the old c the new carbon doesn't have a logo yet okay so when un sure always go to the roots i started programming in the '90s i live through a lot of com do we have com survivors here in the room yeah okay cool about a quarter of the room i'm impressed so we we all remember the the the comway where you actually want to change something you just have to invent a new interface so you force breakage through api and you force your users to uh use extended interfaces for example if you want to add one more function to your interface you cannot just add one more function you invent a new interface and by the way that two three suffix there that's not slideware this is the naming convention that we used for the folks who are not aware of those historical tidbits so yeah i i i i have vivid memories of using interfaces that had five or six at the end and there were not mine that was windows provided stuff good stuff or you can take the stringly approach uh of things like objective c and go for more of an unstructured data type erasure galore dynamic everything in directions everywhere so that works but it comes with other disadvantages in in optimization opportunities in in type safety in refactoring capabilities and so on so specific stuff when you lose type information so and now i'm getting to the uglier bits by the way you haven't thrown things at me yet but i'm still available so in february 2020 the last prepandemic iso committee meeting that took place in prague there was i was about to say productive but it wasn't productive but was the most vivid discussion on on api stability for c++ and they took a series of polls and we decided not to break abi sort of that not is weird because we also don't offered any guarantees that's not right sorry that's not right what do you mean we didn't we decided not to break 23 yeah i have a slide with with with those concrete things i think it's the next one oh no the next one is ugly but it's coming up yeah so like daniela interjected i would say the the the outcome wasn't a definitive answer like all things c++ it was ambiguous so soon after that committee meeting quarantine wrote this article the day the standard library died and by the way highly recommended if you haven't read it yet highly recommend it that you read it it's not as gloom as it looks in the picture so i i i i had to put this up because i i so very much love that quote from titus so committing to abi is like admitting that the standardized library is aiming to be the mcdonald's it's everywhere it's consistent and it technically solves the problem but it's i think we could agree that's not really good food so that's one of the issues how far do we extend this discussion and not including the standard library in the abi discussion is just like why are we talking about it if we're settling for a subpar standard library just because it's everywhere and makes these stability guarantees without being any good and we have plenty of examples then why are we talking about it maybe we're wasting our time so other two quotes that i loved here i'll i won't read them i'll let you soak them in and sip some water and this one stable c++ api it's useless for the platform apis if it doesn't encompass the standard library so you could have a compilation mode and choose between resilience and performance and i'm going to talk a lot about this choice leave them couple of seconds on screen okay so i i titled this the king of mixed signals and ambivalent behavior that's a weird build i have there anyway i have some slide malfunction i'll move over so c++ does not have an ab res resilience model so there's no official codification there the c++ committee will just outright reject any proposal that could break abi in existing stl components danela is shaking her head but i need proof that that this is happening that proposes that break stuff are accepted i need proof okay they're not rejected but they're not considered am i doing bit this better okay i'm looking constantly at danela to see if she shakes her head so but i need proof that someone got a proposal that breaks something okay c++ will not officially commit to guaranteeing abi stability either so that's interesting so we we frown upon standardizing stuff that could break clients but at the same time we're not committing to stability officially and of course this is the tricky bit where people usually point fingers at implementers and say that they holding back on improvements on existing standardized stuff and implementations that could be improved but implementors choose not to do them because then they will hurt adoption or upgrades and so on so that's another thorny issue okay okay now i'm getting to what danela mentioned so in in in in the prog discussion the committee decided it's not in favor of breaking ai 423 so i i qualify that properly is in favor of an ai break in a future version of c++ but when that will happen we we don't know we'll take time to consider proposals requiring a break as in sure at the same time will not promise stability forever so we're not committing to anything here and of course as always we want to prioritize performance over stability and i often hear some of these arguments mentioned in in in this topic but i i was so pleased to see them all on one slide and this is not my slide by the way it is from herb skot at cpp con this year i put the link at the bottom so the the most frequent thing i i here cited is the standard string implementation where we did maybe i i don't need to spend time on this are people aware of the breaking change that happened in c++ 11 just a few hands unfortunately okay then i need to explain it very quickly so the implementation requirement in c++ 11 when we introduced move semantic into the language was incompatible with a one of the existing implementations in in standard libraries u mainly the gcc one and that one used reference counting and that was a breaking change they were incompatible so in order for that implementation to become standard compliant they had to have an alternative string implementation that was of course incompatible with the other one in many ways not just abi so that introduced a sort of fragmentation in in in the users of of the library because many of the users had to rely on on the old behavior and at the same time others demanded the the standard conform implementation and this was happening for over 10 years i think until everyone just on boarded on the on the new one so these kinds of horror stories are cited usually for what can happen when you mismanage a situation like that and just throw people into a a corner and force them to decide and of course the the implementation let you op in in either of the implementations so you you you could op in for the reference counted string or for the the one with move semantics okay so why do we want to break abi a few examples from the c++ world making standard regex faster also adding utf8 support tweet making hash containers faster or having the ability to swap out the hash algorithm easily in their implementation better conformance twixs to string vector and other container layouts an interesting one if we're mentioning we we referenced calling conventions earlier ability to pass span string view unique pointer through registers rather than memory when calling functions this is more of a language thing rather than library thing but again it's a breaking change improving the implementation of shar pointer improving standard mutex do people know that shared mutex is actually faster than standard mutex on windows does that surprise you it should because it's a more complicated class shar mutex is is more complicated but because it's newer it uses operating system primitives that are are more efficient the old one had to support windows xp at the time and uses some synchronization primitives that are less efficient because they're everywhere and if you change that in the existing implementation it is an api break because we're we're changing some of the internal structures so yeah share m exist faster for now so design choices again languages like c++ rust carbon always prioritize a faster code they usually want heavy inlining they want go for cpu saturation and utilization mostly people in these ecosystems prefer static linking whereas in swift there's a strong tendency to prefer small code and and be iach friendly also fit into smaller devices outlining is the thing by the way how many people know about outlining i know everyone knows about inlining but outlining one hand in the back i won't put you on the spot i won't ask you questions but i have a slide and mostly dynamic linking yeah they they want to share libraries so very quickly this is an interesting one u and by the way i linked two very nice presentations the first one by jessica pocket is a shorter one if you want to get started but it's a slightly older version the one at the bottom is a newer one but it's a longer presentation that includes many other things so you have multiple choices when when opting for an optimization strategy when compiling you can either pri ize speed or size and on on the extreme of sizing this is the outliner where you can actually use an and this is implemented in in lbm by the way you can the the compiler can actually look for similar sequences of instructions and sort of make up functions for them and and move them out of line so that it reduces code when it identifies similar patterns in code it's a very interesting thing i find it just from i don't know nerd point of view i find it more interesting than inlining definitely more newer research domain anyway a side closed so for those who don't understand why i had swift in the name or why i'm mentioning swift or why i'm discussing swift 50 is because it was the only one in the previous slide that had a yes instead of no in the in the bullets with all the programming languages that care about abi stability so swift actually invested a lot of time in how to do library evolution and how to build an abi resilience model so we can have both we can evolve things and we can have a resilience model that works so that we don't break everyone don't worry it's not all ponies and rainbows there are some gas i'm going to mention them so swift who for those who want a primer so it's a compiled language it's not a dynamic thing it was created to replace objective c so it shares the memory model in the runtime with with objectiv c so it has some some legacy it wasn't like a brand brand new thing it had to interoperate with with the existing stuff it has classes and inheritance interfaces generics every modern language facility that you might want it uses automatic reference counting for classes has simple function scoped mutable barrows you can add notate arguments nicely ines own value semantics for structs and primitive types and only classes are considered reference types and are boxed using arc and they have reference semantics because they need to interoperate with the the old universe of the apple u libraries and objective c apis so that was the bridge with the old world and even collections implement value semantics using things like copy on right and arc under the hood so lang the language was designed with library evolution in mind and i think this is essential principles of stable library evolution that they have is to make all promises explicit not imply that something is stable if it's not delineate what can and cannot change in a stable abi very clearly in documentation so provide concrete commitments rather than hand wavy stuff like we do with c+ plus provide a performance model that indirects only when necessary so you don't have so don't pay performance costs when not needing and i'm going to show some of these tricks and let authors of libraries and consumers be in controled by having escape hatches and opting in and out of these things i highly recommend this talk by dog gregor if you want to go deeper so just a very quick example don't worry i won't hit you with swift code that's the only swift code i'm going to have maybe one more slide so let's say we have a a structure and we might decide to reorder the the id field at the top so we moved it up or we might decide to change its type from an integer to u id or we might decide to add an optional by the way the question mark isn't like pondering the universe it means optional in swift so maybe adding an optional color at the end of the structure there so the the structure evolved obviously it changed size when the fields were added offsets of fields changed because we reordered stuff so stuff changed and if we're looking at the other side someone consuming it we have a a member there of that type and we have an array of those things so size and stride come into play there we're directly accessing that field the name field there so we care about where it's in the structure because we're directly using it we're not calling any getter on it so on the library side of things type layout should be as if we had the complete view of the whole program so the the person library should lay out its type without any indirection and the metadata required to expose layout information should be a side thing a non-intrusive thing and we need metadata like size alignment offsets of public field so think about having all these kinds of details on the side like bookkeeping of describing this this type layout and these kinds of things can be automatically computed can and we have two strategies i'm going to show concrete examples there of being able to have them as computed properties swift has the concept of computed properties so they sort of work in a similar fashion so they can be computed at runtime or get this step can be bypassed completely at compile time when no runtime decision needs to be made and i'm going to explain when we can switch between those two strates so on the client external code the the external code indirects through layout metadata so to access a field it needs to read metadata for a field offset for example add that offset to the base object to figure out okay where inside the structure is my name field and cast the pointer to load the field if we want to deal with the stack we have to do a similar thing so we you you can actually do similar things even on the stack read the metadata for the size of the instance and work with api such aloc okay to set up the stack as needed where it's different is on the library side of things the library code can eliminate all this ind direction so you don't have to go through the p pseudo computed properties or to retrieve that metadata size because you directly have direct access to the layout of the the person structure from inside the library code so there's no need for runtime computation and to access that metadata so and this hash actually has some llvm support for example i mentioned laying this out on the stack llvm has support for dynamically sized things on the stack and swift makes use of these so you can have a local variable of some struct defined in a stable library and you you don't have to to know the it size that compiled time you can you can compute these things at low time for example if you're consuming this from a from a dynamic library from a shared library when you load that library the the loader can do all these metadata queries and they it caches all these things for performance so it only does it once when you load the library and it keeps a a side booking table for all these computed offsets because they they don't change once you have the system running so it's not like you're hot patching things but you don't know them at compile time so when you load them in when you do a deal open for example these things are computed and cached at runtime so and and llvm has this ability to to dynamically lay out these things on the stack for example if you want to store them on stack so you're not confined to hi hep allocations you can actually leverage the the stack so how does swift handle this juggling between when i want to be resilient and when i want all the performance so swift does this using resilience domains so these are parts of your application that are where you define some boundaries for example parts that are always compiled together are part of a resilience domain for example the person library there so all the green stuff are separate domains so all the stuff that it's compiled together are part of a resilience domain and inside that domain they have intimate knowledge of their layouts and and they don't need any special handling whereas when you have connection so the arrows between the resilience domains when you cross these resilience domain boundaries then you have to do this runtime patching where you need to compute those exact layouts using the the exposed metadata so you only pay the cost of of abi resilience of this model you only pay the cost when you cross these boundaries so across resilience domains you maintain a stable api so users see a stable version of each other or at least a predictable way of interacting with each other and within a resilience domain all implementations details are fair game you can change stuff you can no no indirections no no performance cost u no guarantees made so it's it's as if no such system is in place and of course op ation need to be aware of these boundaries you can go all the way up so if you to the extreme you don't care about you say okay i don't care about this at all you can consider everything single resilience domain you say okay i'm completely in a bubble i'm i don't care about the world so you can consider everything one resilience domain so everything is fixed at compile time no cost you don't pay for anything so that's the extreme case but that deits the whole purpose by default a type that is defined in a dynamically compiled library has a resilient layout that's the default size alignment stride of that type aren't statically known to the application it might must ask the dynamic library for its value witness table values witness table is sort of similar how to how v tables work or the same kind of thing it's a it's a it's a side bookkeeping information that you query at runtime so it this is where you go to figure out for every type that you deal with to figure out its layout everything all the details required by its layout and i mentioned this is cached information so you you you do these calculations these synthetic values just once when you load that library and then you just have the values precomputed but it is an an indirection but it's the kind of thing that you expect from i don't know vtable access inside the boundaries of a dynamic library where all the implementations are statically known the type is handled as if it's not resilient so no indirections no performance cost no nothing i mentioned that already what i love about this is that it's a default so you have to opt out of resilience if you don't want it and there are some escape hatches a few of them for example you you can choose to explicitly inline a function and that prevents any changes to the function semantics because it's inlined in in in the usage location in the color so of course you cannot change its implementation because then you're going to have multiple versions of of that thing so when you op into this mechanism of course for performance reasons you give out any any future flexibility fixed layout it's another attribute that you can use to be explicit to say okay i want to opt out of resilience for this type i know i'm never going to change it famous last words right but in all fairness this is called pair what else can you do with it but anyway famous last words fixed layout so you'll get a fas fair if you switch members yeah possibly yeah if there are different types you could get that sure that's a good good argument yeah so sorry it's fixed so this is another escape hatch for for a type of course i mentioned this is not all perfect so there are some difficulties and some disadvantages of course you have a fairly large runtime component although it's a statically compiled thing and it's highly performant it's an operating system level language and runtime it's a fairly large runtime it's not a thin thing like the c runtime for example right so you have the runtime type layout you have that those operations that need to happen when you load the library i mentioned those by the way you cannot really safely close a dynamic library because bad things will happen you have handling of the metadata at runtime you have those witness tables and ind directions that you need to deal with generics are particularly hard to deal with and this is the part of the talk that i actually cut but i i'm happy to talk about these things if you want after that so there's techniques because dealing with generics in a resilient matter is very very difficult so there and this is because for performance reasons you generally want monomorph isation for generics that means have stamp out concrete types for for for for particular generic types that you're actually using in the application but that prevents having monomerization commits concrete layout to those generics and those are and there are techniques to to go the other way like reabstraction anyway i won't go into details because i prefer to have more discussion and afterwards so every language featur is harder to design you don't get to escape this one so sure you have the flexibility of having resilience domains but you have to think about when you're designing things you cannot just blindly blast away any any proposal for a change without thinking about the consequences for example reordering a pair for better access so and there's also because of the deployment model because these run times and libraries in swift are deployed with the operating system you have weird limitations where you you're compiling a thing and you want to use the i don't know fancy new language feature but if you're targeting an an operating an older operating system version you cannot really use it because then you'll have an older runtime and so on so there are weird artifacts like that so it's not perfect i'm not claiming to be i want to close on a sort of positive note for c++ there is i think there is a path forward even for c++ it's not swift like but we can learn from from that so leb c++ aims to preserve a stable abi to avoid subtle bugs yeah no surprise there and at the same time you want to make ai braking improvements and the user to be able to opt in so there's ways that you can specify which ai version you want at build time right now this is what you have one means and that's the default means stable two means whatever you have there give it to me and three is for later when two becomes the the stable one so okay it's not perfect but it's it's a way forward and if you always want to use the cut most cutting edge version there's a separate find that you can use this is a nice article if you want to read all about these these details so i have time for questions and comments i do accept comments as well so that's it i have couple of minutes for interaction on on record or afterwards as much as you want [applause] go please if you can please use the microphone so that i don't have to repeat myself hi victor thanks for doing this talk i have a question just about your opinion so i have only opinions nothing else perfect so you probably know about scoped lock and how it is like a different name to lock card because that would break api exactly that seems a bit insane because same thing applies with with the the mutex example i gave yeah i'm not sure i agree because log guard is a type that is specifically designed to be inside the function right so it's not really designed to be on the inside of a class that is provided to you by library so my question is do you think there is some reasonable way to say okay these types we really care about abi and these types we don't care about abi and uh kind of that's a separation or something like that thank you i wish there was but people don't think in in in in such a grandular fashion at least not in in c++ i haven't seen such discussions so we sort of have this idea of break everything or break nothing sort of when eventually we'll decide that we're going to accept the breaking change to the to the implementation and i'm not even talking about a standard stance official stance i'm talking about a vendor let's say a vendor decides to break things they usually see this as a okay this is our opportunity pull in all the stuff that we we've been holding back like open the floodgates like fix all the types fix all the bugs and then we'll freeze it again for 10 years so this is the kind of thing i'm seeing and i this worries me because this whale approach of sure we'll decide next year or the next version of whatever great implementation we're going to do all the breaking stuff and we're going to land all our prs that we've been holding for five years and we're going to fix everything and users be damned and then we're going to freeze it again for 10 years i don't believe that what you say a more granular opin approach and being more explicit on a per type basis it would be much more flexible that i but i've i've yet to hear some ideas in this space what all i see is all or nothing people are all or nothing so you made comparisons with swift and rust for instance which are to my knowledge controlled by single organizations i would also include java in this kind of language and i've i think it's a bit unfair because c++ is a very diverse language con considering platforms architectures implementations and i've heard this from people outside of the c++ so that come from rust for instance that say the standard should say this and this and this and should define all these things and i'm not convinced why is abi not an quality of implementation issue so provocatively you are principal engineer for visual c++ why do you need the committee to tell you what to do i i won't comment for for my employer here okay but i can comment on the hallway [applause] maybe that's fine then let's yeah so my my personal opinions don't necessarily align with the business objectives then then then let's say it's about a different implementation like gcc why does why does the committee need to tell the gcc people what to do or maybe if you don't want to answer that's fine i i don't think they're necessarily tied together i think you are right to some degree it's an implementation quality thing but implementations have users and the engineers working on those implementations would want to ship you the best possible solution they have they just have to think they have to choose right now they have to choose if everyone is going to be able to use the latest and greatest or if they get to ship the the brilliant v2 or the brilliant implementation so you have usage constraints whereas things like you mentioned like rust or swift swift has the advantage of sort of a although it's an open source project it's sort of a single strongand organization right so it has more tight control over over its destiny let's say also traditionally developers in that ecosystem are much more eager to upgrade so they they they usually and and when they make changes that are difficult they also provide extraordinary tooling to help with those migrations they provide excellent tooling for that and they're very aggressive about it they will push their users even if it's uncomfortable they will choose the immediate discomfort for the long-term better outcome so apple will push their users and generally they've that ecosystem of users expect this kind kind of thing where they're okay they might scream they might make a fuss about it they but they know they don't have a choice like they will modernize by force so although they have like a big code base behind them so there it's a big community they they move faster whereas rust has although it's it's a mature ecosystem it doesn't have as much code as swift or c++ so it's it's different you i agree it's unfair to to compare but my my point wasn't to to shame or compare my point was can we learn something from the others can we borrow something right not everything is applicable we cannot op into all the fancy things we see but just ignoring what happens over the fence doesn't solve our problems if we don't have any better solutions so thanks that's my that's the spirit the spirit is not like compare the spirit was can we learn something and we have proof that it can be done sure in a different environment but it can be done these are not unsolvable engineering problems all right thank you sorry victor we we're almost out of time i'm going to allow mark last question last comment comment yes excellent yeah i work on leas and yeah we have this unstable ai but there are really no plans to make it stable in the near future especially because abi issues but there are some people who compile everything from scratch and they use the unstable abi because of performance reasons so yeah so you support my last slide basically right yeah but the problem i always see is that's it's hard to no what did i do this one yeah but there are no conrete plans to freeze it too so i didn't claim that yeah but if you want at least there's a way to optain the latest and greatest there is a way for this implementation not for others so thank you anyway so we have to wrap up officially but i'll be on the hallway so catch me for [applause] everything