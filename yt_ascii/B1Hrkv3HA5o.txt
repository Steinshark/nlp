hi everyone i'd like to spend this episode fixing some problems and making a few small optimizations so first of all if i enter play mode i immediately get this property to id can only be called from the main thread error so if we click on that to get some more info we can track down this problem it's originating with this material. set float call in the texture dat. update mesh heights method and that is being called in the map generator. generate map data method at line 130 so let's head right over there map generator line 130 we can see this update mesh heights call and if we just head over to that method we can see that there are indeed these two set float calls and so those are causing an issue when we try and call them from a separate thread so we're going to to move this update mesh heights call to somewhere on the main thread so let's cut that out here and i'll move it up to the top of the draw map in editor method and then we'll also want it to be called at the start of the game so we can just create a awake method and call it there as well so if we save this and just clear that and enter play mode it is now working correctly all right so we've now good at working in play mode but if i actually try and make a build of the game so i'll quickly go into the build settings just add the open scene and build it's going to fail and it will give us this error saying that the name unity editor is doesn't exist in the current context and this is coming from the updatable datas script so it's basically unhappy that we're using the unity editor namespace outside of a editor script so we need to tell it to only compile this code containing the reference to the unity editor namespace if we're inside the unity editor if it's for a standalone build then it can just go ahead and ignore this code so we do this using what's called a pre-processor directive we say # if unity editor and then all this code goes in there and then hasht end if all right so now this code will only be compiled if we're inside the unity editor now this will lead to another problem in the noise data script so let me just head over there noise data this has got a protected override void on validate but if we are compiling this outside of the unity editor in other words for a standalone build then this method won't exist in which case this override won't make any sense since there'll be no method for it to override so we must also just add that same if condition here only compile this if we're in the unity editor all right and don't forget the end if okay so if i save this now and let me just clear these errors can go build settings and i'm just going to quickly set it so that the default is not full screen i'll set it to be 1280 by 720 disable the resolution dialogue and i'm just going to turn off the splash screen that one all right so before i build this just want to make sure that this rigid body is a little bit higher up all right just so it doesn't go through the terrain while it's still busy generating then i'll hit build and run so just wait a moment for this to complete and any second now should be popping up and much to my horror the terrain is completely gray so that means that i have forgotten something all right so since we don't have any of these unv validate callbacks inside of the standalone build we need to go into the map generator and in the awake method we need to apply all of the information to the texture data so we can just write texture data. apply to material and pass in the terrain material all right i'm very quickly going to build this once more just with command b and this time around we have all of our pretty colors okay so another things are actually working i'd like to focus a little bit on optimization so if you do a bit of profiling you'll quickly see that the biggest sort of performance hit comes from the generation of the collider so if we just dig down here you can see that a lot of time is going into the baking of the physx collision data so that's where we want to be focusing our efforts and the main approach we'll be taking is simply to ensure that we only create the collider if the player is about to step on to a new chunk in other words we only want to generate the collider if we're sure it's actually going to be used okay so we'll get to that in a moment i just want to quickly change how how one selects which level of detail is used for the collider mesh currently you can select one of these checkboxes but i find it a little bit clumsy the way i've set this up because you can have multiple selected or you can forget to select any so i'd much rather just have a single int at the top here just to set the level of detail index that you want to use so let's go into the endless terrain generator here and i'm going to create a public int collider level of detail index we'll then want to pass this value to each of the terrain chunks that we create so let's add it into the constructor call here i'll add it just after we pass in the detail levels so collider level of detail index and we have to add that of course to the constructure itself i'll add a chair into collider level of detail index and we can now replace our collision level of detail mesh object just with int collider level of detail index and we'll set that saying this dot c level detail index is equal to the value that we were given okay so we no longer need to set the collision level of detail mesh and down here in the update to r chunk method where we are actually assigning the collision mesh i'm just going to delete all of this code for now because we're going to be changing the way that works a little bit we're actually going to have a separate method for it a public void update collision mesh and the reason we're having two separate methods is that this update collision mesh is going to be called much more frequently than the update terrain chunk method and the reason for this is just that since we want to leave the creation of the collider as late as possible for the reasons i i mentioned earlier we need to check the player's position every time he moves otherwise we might be too late to create the collider and the player will of course fall through the terrain so we'll be calling this from the endless terrain update method and we'll call it every frame so long as the viewer has moved so we'll just say if viewer position is not equal to the viewer position old then we want to go through all of the currently visible chunks so for each terrain chunk chunk in the visible terrain chunks we'll say chunk dot update collision mesh okay and then up here i want to create a constant float to determine how close the player has to be to the edge of the of the terrain chunk before it will actually create the collider so let's say collider generation distance threshold something like that and i'll set that maybe to five and then in the update collision mesh method we can start by saying float squ distance from viewer to edge is equal to bounds do square distance given the viewer's position all right so if that square distance is less than our collider generation distance threshold which we'll have to square since the viewer distance to edge is squared so just multiply that by itself if that's the case then we want to set our collision mesh so we can say mesh collider do mesh is equal to level of detail meshes with an index of collider level of detail index do mesh now of course we can only do that if that level of detail mesh actually has requested and received a mesh from the mesh generator so we should do a check first by saying if level of detail measures with our collider index if that has a mesh only then will we do this now of course we sincerely hope that it does have a mesh otherwise we might not be in time to create the mesh collider before the player actually steps onto the terrain so what we'll do is check if our distance has come within the threshold for generating that level of detail mesh then we'll request it which is the same thing that we're doing in the update terrain chunk method except we're going to do it more urgently for the for the level of detail that's being used for the collider now i'm quickly going to go down to the level of detail info struct and i'm just going to create a accessor here a public float called square visible distance threshold which simply returns visible distance threshold multiplied by visible distance threshold okay so over here in our update collision mesh we can say if the square distance from viewer to edge is less than detail levels with an index of collider level of detail index dot square visible distance threshold then if the level of detail mesh that we're using for our collider if that has not yet requested a mesh so if that's not true then we will ask it to request the mesh right away just by calling in request mesh and passing in the map data now none of this of course has to happen once we have set the mesh collider so let's just have a little buol up here has set collider and we will set that to true when we set the collider and we'll only do any of the stuff in this method if we have not yet set the collider all right now if we save this and go into unity and i'll just make the game view a little bit bigger this is not quite going to work yet and the problem is just that we're only updating the collision mesh if the player moves so if the player remains still right at the start then that first collision mesh isn't going to be added so what we can do to get around this is make it so that the update collision mesh meth method is called when the mesh data is received for a specific level of detail mesh now currently the level of detail mesh class has got a update callback which is just being set to call the update terrain chunk method but now we want to include the update collision mesh method as well so we're going to have to turn this into an event so that we can add both of them to it so let's create public event all right so we'll no longer be setting this directly in the constructor instead up in the terrain trunk constructor when we're looping through all of the level of detail measures we can just say level of detail measures with an index of i dot update callback plus equals the update terrain chunk method and then if i is equal to the collider level of detail index then we'll also want to add the update collision mesh method so level of detail meshes with an index of i do update callback plus equals update collision mesh all right and let's just remove this from the level of detail me constructor there since that no longer exists and we should now be able to play this and have some success so hopefully we will land on the mesh and if i just run around quickly it appears that we do continue colliding with new terrain chunks so i'd say the implementation is working now even though the colliders are being set far less frequently than before there is still of course that noticeable pause when one is being set the only way we can really cut down on this time is to make the mesh chunks smaller so we'll now be setting up an easy way of controlling the mesh chunk size so the chunk size is currently stored in the map generator script in this map chunk size accessor and raing a value of 95 if flat shading is enabled otherwise 239 now remember that the values that we use here are constrained by two factors first of all they can't be too large otherwise we exceed the maximum allowed number of vertices in a single mesh and they also have to be compatible with our level of detail implementation now we're currently supporting seven different levels of detail and it turns out this means we have very few options for the size values we can use however if we turn the number of supported levels of detail down to just five that will give us a much wider range of options so i'm going to go into the mesh generator which is of course where the level of detail mh simplification actually takes place and i'll define here a public constant int number of supported levels of detail and i'll set that equal to five so that means that we can have a level of detail of 0 1 2 3 or four so in the endless terrain script down here in the level of detail info class i'm going to constrain this level of detail integer between 0 and four using the range attribute so there should be between 0o and mesh generator. num supported levels of detail minus one okay and might as well do the same thing in the map generator on this editor preview level of detail so it's between zero and mes generator. noms supported levels of detail minus one so if we just have a look quickly this means that the editor preview level of detail goes from 0 to four and on the detail levels here these also now have a range of 0 to four now if we look at how our mesh simplification increment is being calculated over here we can see that within the range of supported levels of detail it can have a value of 1 2 4 6 or 8 and our map chunk size + one has to be divisible by all of those numbers in order for it to work and it also can't be greater than 96 if we're using flat shading and it can't be greater than 240 if we're not now i've generated a list of all the numbers that meet those criteria so i'm going to go into the mesh generator and create a public static readon integer array called supported chunk sizes and i'm going to leave out 0 and 24 because those are too small to be useful but i'll add in 48 72 96 120 144 168 192 216 and 240 then i'm going to duplicate this and call this the supported flat shaded chunk sizes which is going to be all of these up until 96 i would of course like to declare these arrays as constant but since that's not legal the closest we can get is static read only now i also want to make a a public const int for the number of supported chunk sizes so that's going to be equal to whatever the length of this array is so 1 2 3 4 5 6 7 8 9 it's equal to 9 and a public const int number of supported flat shaded chunk sizes which is just equal to three all right then in the map generator we can have a public int called something like chunk size index and this will be clamp to a range of zero to mesh generator do number of supported chunk sizes minus one and we can then duplicate this and call this flat shaded chunk side index and just change this to number of supported flat shaded chunk sizes then when we were asked for the map chunk size we can return mesh generator do supported flat shaded chunk sizes with an index of flat shaded chunk size index and over here mesh generator do supported chunk sizes with an an index of chunk size index now don't forget that we need to subtract one from each of these values just like how earlier this was 95 instead of 96 and this was 239 instead of 240 i'm going to admit a terrible thing which is that i don't actually remember why we have to do that but definitely explained it in one of the earli episodes so maybe someone can remind me anyway we save and go into unity and we should now have this tiny little terrain chunk and if we increase the chunk size index then of course the size of that chunk increases accordingly and this should also be compatible with all of our different levels of detail so that's nice let's try this out with a chunk size index of about three actually before i enter play mode i just like to change my distance thresholds a little bit i'm going to bump this up to 400 and 600 and finally 800 and i'm also only now realizing that i forgot to actually remove the use for collider option from the detail levels so i'm just going to delete that variable now and then can enter play mode and as you can see our terrain is is made up of all of these smaller chunks now which should mean that as i run around the physics system is having to bake collision measures with far fewer vertices and so overall should have a much smoother experience okay there's just one last thing that i'd like to do this episode and that is to change the way that this terrain chunks visible last update list works so just to remind you what that's doing at the moment when a chunk updates itself if it finds that it is visible this frame then it adds itself to that chunks visible last update list then when we're going through and updating all of the visible chunks on the next frame we go through all of the chunks that were visible last frame and we deactivate them and afterwards that list is cleared the reason we do this is because we're only updating the chunks in a finite area around the player a chunk that is visible one frame and then out of range the next frame won't get a chance to deactivate itself since the update method will never be called on it so this is an important aspect of our code but it can be handled a little bit better so i'm going to start by renaming the list to simply visible ible terrain chunks and i'm no longer going to clear the list with each update then in the update terrain chunk method i'm going to create a bull called was visible which is just equal to whether or not the chunk is currently visible and we're only going to update the visibility if was visible is not equal to currently visible so if the visibility has changed and then i'm going to say if currently visible only then will we add this chunk to the list otherwise it's actually going to remove itself from the list so visible terrain chunks do remove this okay now back up in the update visible chunks instead of just going through all of these and deactivating them we're instead going to update them now one thing we have to be careful of of course is that when we update it it could no longer be visible in which case it's going to remove itself from the list and we're going to get all sorts of index errors here the trick here is to start at the end of the list and count backwards so that even if a chunk removes itself from the list we're no longer iterating over it so i'll start at i equal to visible terrain chunks do count minus1 while i is greater than or equal to zero we will decrement i by one okay now currently we might update it ter rin chunk and then in this block of code over here we might update it for a second time so i'd like to be able to keep track of which ones i updated here so that i don't have to worry about them again so what i'm going to do is in the terrain chan class i'm going to create a public vector 2 called coordinate and in the constructor i'll just set this do coordinate equal to coordinate it and then at the top of the update visible chunks method i'm going to create a hash set of vector twos called already updated chunk coords so that equal to a new hashset all right and for each terrain chunk that we update going to say already updated chunk coordinates. add that chunk coordinate all right so now inside of these two loops we can say if not already updated chunk coordinates contains the chunk coordinate that we're about to update only then will we actually update it so in other words only if we have not already updated this coordinate will we bother running this code great so if we try this out now just for fun let me try this out with flat shading this time so if we try it out probably won't see any noticeable performance increase but just verify that things are still working that haven't inadvertently broken something and it appears that everything is still fine all right so so that is going to be everything for this episode until next time i guess cheers