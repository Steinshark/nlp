this is actually my fetish mixing programming languages in which make no sense mixing c++ and rust for fun and profit i've also heard that there's d in the article yeah you heard us you heard you heard me right boys this article about to give us the d lang for quite some time i've been bothered by this thought individual programming languages c++ rust go etc are traditionally viewed as waled gardens if your main function is written in c++ you better find yourself c++ libraries like qt to build the rest of your codebase with do you want to use flutter to build your apps user interface get ready to build logic and flutter too do you really want to use rust library to make your application safer you get to either rewrite the whole app in rust or build an ugly exter c wrapper around it that won't fit well into your pro into your objectoriented c++ code okay this is good this is a good start this is a good start this is a good this is a good start this has been this has been the standard view on using multiple programming language is for many years however i've decided that this view is fundamentally flawed because every compiled language used the same set of concepts when it's compiled okay okay or just use zig really you're tell me you're telling me zig is better you're telling me zig is that much better is zig actually that better is zig is that better that you would rather drop everything else and just use zig everything else just use cobal zig is pre-alpha maybe vlang vlang oh gosh oh gosh all right anyways okay cod split up into functions that can be reused functions are identified by a string generated from a function name in the source for example g++ generates z3 fuv as identifier for void fu this string is always reproducible for example both clang and gcc on linux follow the aium c++ abi convention for mangling function names functions are called by storing all parameters to that function at a specific location in memory and then using oh my goodness i'm still effed am i really just we're am i really just hitting that many fs today what what is happening i'm going to have to call i'm going to have to call i'm going to have to call up my my internet service provider let them know that i want to be back i don't want to be down i want to be back i want to be back functions are called by storing all the parameters to a function at a specific location in memory and then using a call instruction or equivalent to move control to the function for example to call void fu from earlier the compiler converts c++ statement fu into an assembly call z3 fu v the assembler then replaces call with the appropriate op code and replaces z3 fv with the location of the first instruction by ident identified by z3 fu v functions return by storing their return value if they have one in a specific location then r instruction or equivalent okay this all makes sense i assume everybody kind of follows this this is just like your basic call frame operation here classes and structs can be boiled down to a collection of primitive types although some classes do have v tables class methods are just another function that happens to take a pointer to a class object as the first parameter in other words you write like this yes okay okay okay i'm excited since every compiled programming languages uses the same concepts to compile why can't they just interact before we go any further i'd like to give you an example of what i want to want to achieve include rust module header header or let's see or ideal c++ 20 world import rust module we all know that c++ 20 is going to be 2020 2032 is favorite feature all right pragma once hit it void fu rust module hit that okay we want to be able to compile those files and get an executable that prints hello from rust to standard out now now let's look at why this won't just work out of the box okay name name mangling data layout and standard libraries all right the most obvious reason that compiled programming languages just can't interact with each other is the most obvious one syntax tax c++ compilers don't understand rust and rust compilers don't understand c++ thus neither language can tell what function or classes the other is making available okay yeah yeah yeah yeah yeah yeah yeah yeah yeah this makes we're all on the same page here now you might be saying but if i use c++ header file to export functions and classes to other cpp files certainly i could make a header file that tells c++ where that there is oh my goodness my camera why does today suck why is today just sucking i hate i hate my life okay i don't know what happened today today is just come out cursed today is a day of cursed okay internet keeps failing camera ain't working new camera's on the way it said it'd be here wednesday but now the one that said it'd be here wednesday says it's arriving thursday i don't know what's happening all i know is this isn't okay all right let's keep on going now you might be saying but if i use c++ header to export functions and classes to other cpp files certainly i'd be able to make a a header file that tells c++ where the rust function fu out there if you did say or at least i think that congratulations you are on the right track but there are some less obvious things we need to talk about okay okay first major blocker to interoperability is name mangling you can you can certainly make a h file with the four declaration of void fu but the c++ compiler will then look for a symbol called z3 fu v while russ compiler mangled fu function into z zn1 rust module 3 fu 17 hd f3 dc gez i wonder what's happened there compiling the c++ code starts out okay but the but once the linking stage is reached the linker will not be able to find underscore z3 fuv since it doesn't exist rip this makes me sad it just does where's the camam the cam died my life died everything about this is just scuffed okay just just deal with it obviously we need to change how the name mangling behaves on one side or the other we'll come back to this thought in a moment the second major blocker is data layout put simply different compilers may treat the same struct declaration differently by putting its fields at different locations in memory yeah if i'm not mistaken c+ or c does like tight packing of strs so if you have a 32bit int a 32-bit int and an 8 bit int it'll be stored at like 32 you know it'll be stored at 0o 0 plus 32 and then one right if you have a 64-bit right if you're 64-bit lines whereas rust will put a 64-bit in place of everything so if you have a 32-bit inte the first one's at one the next one's at two the next one's at three even eight bits are sitting there that's like the general thing i know that i know there's no guarantee on these things but that's generally what happens order is not guaranteed either that can't make sense i i don't believe that order is not guaranteed because you can do i i guess in rust maybe order is not guaranteed but in c it is because you can do a c you can do a c comp a c data layout in rust so it must be deterministic right order is not guaranteed huh crazy okay yeah i don't know i don't know this area okay i i i can buy i can buy it all right the third and final blocker i want to look at here is standard libraries if you have a c++ function that returns a standard string rust won't be able to understand that of course not instead you just need to implement some sort of converter that will convert c++ strings to rust strings similarly a rust vc object won't be usable from c++ unless you convert it to something c++ understands let's investigate how we can fix the first problem name mangling extern c and why it sucks okay okay i like this the easy way to use extern c feature that nearly every programming language has is this right here pragma once this thing extern c fu void okay yeah yeah yeah yeah yeah yeah and then rust module no mangle boom boom pub extern c fu function let's go okay this still works and it's beautiful it's beautiful enough this actually will compile and run assuming you link all the proper standard libraries so why does extern c suck well by using extern c you give up features like function overloads class methods templates okay it's po okay i mean okay it's possible to create rappers around extern c functions to crudely emulate these features but i don't want complex rappers that provide crude emulations i want rappers that directly plumb those features and are human readable furthermore i don't want to have have to change existing source code which means that ugly no mango pub exter c must go all right i love the motivation i'm loving the motivation here enter d enter the d people we got them we got him so good d is a programming language that has been around since 2001 and nobody cares although it's not source compatible with c++ it is similar to c++ i personally like d for its intuitive syntax and great features but for gluing rust and c++ together d stands out for two reasons classic d standing out extern c++ and pragma mangle fu with extern c++ you can tell d to use c++ name mangling for any symbol therefore following code will compile okay okay void bar okay nice nice you just like declare that this function exists you call it and it does it and then this one just puts it in is that what i'm seeing right this one this one fu is defined in in this file fu. cpp and bar is defined in this file and so fu is called which refers to bar right am i am i seeing that correctly the d i mean the d is strong yeah bar is forward declared and then fu is also forward declared right here okay okay okay okay i never thought d would have a usefulness but let's go however it gets better we can use mangle fu to manually override name mangling to anything we want therefore the following code compiles oh no oh no huh oh no that means you have to have something that compiles in between right you have to you have to create d bindings you have to compile your c++ to d this looks cursed dude it's cursed wrong turn bro no this is the right turn this is the right turn rust fu hello from rust unsafe bar calling that bar extern link name bar d function function bar let's go with pagma mangle fu we cannot only tell d how rust mangled its function but also create a function that rust can see you might be wondering why we had to tell rust to override mangling of bar it's because rust apparently won't apply any name mangling to bar for the sole reason that it is an exter block okay fair that is fair in my testing not even marking it as extern rust made any difference go figure all right you also might be wondering why we can't use rust name mangling overrides instead of d's well rust only lets you override mangling on function for declarations marked as extern so you can't make a function defined in rust masquerade as a c++ function okay so now we use d to glue our basic example together look at this thing go look at this thing go look at it go include rust module or an ideal world this function main okay this is in rust all right rust module yes it's right here gluty gluty no gc this is the rust function mangle this oh my goodness void food from rust exter c++ oh my goodness oh my goodness what is this this has to be generated right these gluty files have to be generated this is wild this is wild if this works this is wild and this example main calls fu from c+ dude imagine the tool chain can we just take a second and i just want you to imagine the tool chain of compiling c++ rust and d you got three like what kind of what what the c makes going on around here no i will not im imagine try it out dude trying it out is going to take me hours to probably get it correctly set up in this example when maine calls food from c++ is actually doing a d function that then that can call the rust function it's a little ugly but it's possible but it's possibly the best solution available that leaves both c++ and rust code in pristine condition automating the glue let's go nobody wants to have to write massive dile no a ain't nobody want that massive defile truer statements have never been said in my entire lifetime okay truer statements have never been said in fact nobody even wants to write c++ header files by hand we're so back for that reason i created a proof of concept tool called polyglot that can scan c++ code and generate wrappers for use from rust and d my eventual goal is to also wrap the other languages but as this is a personal project i'm not developing polyglot very quickly and it certainly is nowhere near the point of being ready for production use in serious projects that being said it's really amazing to compile and run the examples and know that you are looking at multiple languages working together this is cool this is this is pretty dang cool like in general it is super cool to see these things run together so smoothly i mean zig zig offers something really similar with c right like you can actually just take c projects and just just call and like you can just import an entire library and things just compile it just works in fact i've heard some people say that it's easier to build a lot of the c programs by simply importing it into zig and then compiling it via zig i'm just saying i heard that it's it's just it's just easier this sounds like a micro front end ziggs defer is goated yeah apply cold water to burn areas i know next up i originally planned to write this on a top let's see on this topic in one blog post but there's a lot of interesting things to cover so i'll stop here for now the next installment of this series will take a look at how we can overcome two major roadblockers okay of interop ability this is super cool great job on mixing c++ and rust and just using the d and and recognizing that nobody wants to write the massive d glue code like nobody nobody in fact i'm pretty sure everything you've written right here all of this is exactly how react hides the dom from everybody this is pretty much this is pretty much virtual dom as far as i can tell it's the same thing same thing virtual dom using d glue code same thing same difference okay you wouldn't understand react mentioned htm x go let's go this was great this was great this is honestly one of the best articles i've read i've read in a while cuz it is just it i love seeing people that write projects that are just nuts it is just simply nuts right would i i mean is this really a great idea in my head no it's not a good idea but is it awesome yes it is awesome d's nuts yeah exactly d also has a compiler so it can run you see libraries okay i like this though i like it c+ plus rust using d my man just made the crud just made a crud app he he dude he just he made a crud app you got to put a little lower case on that u it's just straight up a cr app imagine programming in 50 years totally new stuff that we do nowadays i know it's wild the drust i know it's it's literally de crust it's some de crust well hey the name is the primagen