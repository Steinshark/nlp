all right guess what everybody we got another person coming in saying go nil panic in the billion dooll mistake i don't know about you but i have this book little nice reading 100 go mistakes and how to avoid them good book here let's see what they have to say okay let's see what they have to say at my job we have a few dozen development teams and a handful doing go the rest are doing cotlin with spring i am a big fan of go and honestly you know go it doesn't make sense to me to ever use the jvm java virtual machine on which cot ler apps run again so i started push with within the company for the other teams to start using go to and a few started new projects with go to try it out sounds like a positive nice story by the way also really cool that this guy had enough sway to be able to get some projects started out with go fast forward a few months and the team who maintains the subscription service has their first go app live it basically a microservice which lets you get user subscription information when calling with a user id the user information is fetched from the db in the call but since we only have a few subscription plans they are loaded once during startup to keep in memory and refresh in the background every few hours hours fast forward again this by the way cash inv validation is extremely hard okay whenever i hear this i it immediately i mean at least the gu is realistic about it they have enough subscriptions that they can keep all the subscriptions in memory handrolled reddis easy enough right i feel bad just saying that out loud fast forward a few weeks again and we are about to go live with the new subscription plan it's loaded into the subscription service database with flag visible equals false and would be brought live later by setting it to true and refreshing the cache data in the app the data was inserted into the database in the afternoon some tests were performed and everything looked fine by the way this is what is called a shadow traffic test which should be being performed here if you're creating a whole new rewrite of a service you take a request and you replay it against your new service ensuring that throughout say like a week you return the same results every time or the differentiation between your two services is known and that's expected and that happens i'm back today from my miserable life only to be lightened up by your l takes okay first off that was not an l take what i just said there that was great advice so you can shut the hell up and second off let's see what happens later that day in the evening the traffic is the highest one by one the instances of the app trigger and the background task to reload the subscription data from the db and crash the instances try to start again but they load data from the db during startup 2 and crash again within minutes zero instances are available and our entire service goes down for users alerts go off people get paged the support team is very confused because there hasn't been a code chang in weeks so nothing to roll back and the it team is brought in to debug and fix the issue in the end our service was down for a little over an hour with an estimated revenue loss of $100,000 let's just let that one sit for a second can we get some fs in the chat fs for $100,000 feels a little bad huh so what happened when inserting the new subscription into the database some information was unknown and set to null the app using using a pointer for these optional fields and while transforming the data from the database struct into another struct used in the api endpoints a nilde reference happened loser uh by the way this is one reason why options are single-handedly the greatest there is no greater decision made than to have a nil pointer wrapped in an option with a programmable interface to it and then second that decoding json is validation now go does the first one very very well decoding json is validation but it doesn't have an option options are so good sounds like they kind of did the microservice thing kind of wrong yeah well i mean the obviously they made mistakes but an option is single-handedly the greatest data structure for professional programming ever oh hold on we got ourselves a problem someone's saying we got to do some ban what are we banning who we banning who we banning who who we banning who we banning who we banning who we banning def code okay death code we got it i'm all over it death code bam got him get the hell out of here didn't even look at what you said get him got him yeah so i was like what do he say and people were all like screaming like get him and i didn't even look at him but i did that you know that scene in 300 where kicks the guy the same thing like identical okay he's fall fallen backwards right out the door you know what i said to him as he fell on the ground don't let the ground hit you on the way out the app panicked and quit and when starting up the app got the same nil issue again and just panicked immediately too yeah i mean this is what it goes i really it's sad due to the time period in which go was created in which options weren't like maybe options nonn whatever you call them nbl or whatever stupid phrase you want to speak of them as weren't really part of the mainstream programming world and that's one thing i wish go enforced there's a couple things i wish they enforced like you know maps maps you can't have map's default value being nil is emotionally painful we've all made that mistake and you just have to learn from that mistake you know what's an option it's a monad duh it's a burrito everybody knows about burritos you know i right naturally many things went wrong here an inexperienced team using go in production for a critical app while they hardly had any experience using a pointer field without a nil check not manually refreshing the cash data after inserting it into the database having no runbook ready to revert the data insertion and notify support staff of the data change or shall i say shadow traffic shadow shadow test people okay just do it you should always do that when you rewrite just make sure the thing is the thing but the colin guys were uh very fast to point out that this would never happen in a cotlin or jvm app first in cotland null is explicit so null d reference cannot happen accidentally unless you're using java code together with colin code this is facts i was about to say what do you mean what what the hell do you even mean but also when you get a null pointer exception in the background thread only the thread is killed and not the entire app and even then most mechanisms to run background tasks have error recovery built in in the form of try catch around the whole job yeah this this whole try catch business it's just it's honestly the worst it's honestly the worst to me this was a big eye opener i'm pretty experienced with go and was previously recommending it to everyone now i'm not so sure anymore what are your thoughts on it this is actually a really it's a really good really good suggestion it's really good story obviously skill issues plague everybody anyone who thinks that some other language or some other construct is going to prevent you from having errors is kind of silly right there's so many things you can do wrong with rust like the amount of times i have personally written or have personally seen somebody due to how rust requires you to write things have all these tokyo threads running just for it to all funnel down to a single map with a mutex around it i've done that i've skill issued myself constantly in rust rust is a one giant skill issue non-stop all the time always and forever i still skill issue myself the thing about j script that makes it so squirly even with typescript support so you get warned about the potential of null is that you also have to know that there's a potential of null also json parsing is not validation you can json parse anything and what ends up coming out is an any and that's really important to know because if you return from a function with a signature and it's an any or on the other hand you return a json parse out of a function in which the definition says i'm a foo it will automatically assign a foo and it will be guaranteed to be a foo because it has an implicit any on the json return like it's not easy there's a lot of validation you have to do every single function in javascript that has the word await in it could possibly throw that's also very very difficult there's lots of foot guns in every single language and each one has a different set of foot guns so is go somehow better or worse than cin i don't think so panic only kills the go routine it happened in interesting okay skill issue should have read effective go before migrating crucial microservices yeah okay that's fair i i would definitely say one of the biggest things that they obviously did wrong is they found their one of their most critical services they ran no shadow traffic and they had a bunch of rookies that have never written go write it like did did all the rookies become mid-level engineers afterwards yeah they're probably actually really adept now with go and they probably will never make the same mistake again yes that sounds great let's see we do need to throw an option type into the core and be done with it you can totally write one you just need to standardize also uh don't do the previous 15 fuckups yes most i mean option type would be great you just you will never mess up again a nil right it'll be fantastic if there was some sort of option type you can just guarantee from here on out beautiful right i think we all agree to that fantastic but it's so true you can still there's so many runtime errors that you will make no matter the language what's an option type an option type is really really simple i didn't know what an option type was until i started using rust and so an option type is a very very simple item it's an it's an option with a generic value underneath and it has two values it can either be none or it can be some with that whatever that generic is as its value right we'll call it t right so whatever we'll call it t that's well now we're n thank you everybody we're n so that's its two values that means if you have a nil it is none if you have a sum it is something so underlying in the memory what you're going to have is you're going to have the tag and then you're going to have the space for however big i is which means that if you have a none you're going to have something that looks like this a tag zero plus all the space now and i know this isn't technically true technically if you have a nun first it has this like memory optimization trick but just deal with it okay nonetheless you can never run into a nil pointer because there is no such thing as a nil pointer because everything has a type and this thing is a type so for you to get the value out you have to do some sort of pattern matching or some sort of like accessing and so this is what's something it's it's very very fantastic you there is no such thing as a nil because it has a typed wrap around it to prevent the entire idea of null so good like okay so why would you ever use this very very simple let's say you have some json and you have a a field called a and a may or may not be there well you can do what you do in javascript and have a question mark or you can do what you do in other languages and you have an option with the type inside of it that means you have a type in which you need to handle or in the case of typescript you have a linter that lets you know that this thing could be undefined and so the idea of having it as a type means that it's significantly more strict like you can't access the underlying value without first going through the type and that's called a lift operation or a catamorphism use there are null types you can use when deserializing db records they live alongside a squeal package there's also a version which works with json yaml too again pointers are still widely idiomatic but it's something to investigate mostly i think having years experience helps the cotland team at least as much as the features being new to something is always harder this is such a great point i mean is this surprising at all should you ever be surprised that you can run into dumb problems like unless if the language strictly forbes it right so rust would be a language that strictly forbad a null pointer problem but you can still in unsafe rust you can still null pointer yourself but generally you can't null pointer yourself like it's just forbidden in safe rust and so unless if you have that you're going to it's going to happen do we have any other fun ones as someone who works in a programming language design i have to agree with them nil and generally zero values feel like big errors in the design of go every other language design in the last 25 years have found a solution to this problem so i can't understand why go's designers decided to make this choice i don't know about the last 25 years you know i don't know if 1999 we fixed the null problem can someone tell me what happened in 1999 that made people want to fix the null problem seems kind of wild party like it's 199 to y2k came in yeah i know y2k baby all right hold on someone said something about management maybe there's a management process issue here too do you really start your team's first real experience with a new language by having them code public facing revenue critical app if i say the word shadow traffic one more time i feel like you guys are going to punch me and quit listening to me but real talk just figu shadow traffic if you rewrite a surface oh my goodness it's just like come on people like op mentioned there were other processes checks that would have caught this regardless of the team being new to go or not if this was the first time a new subscription was added it should have been done in a test environment first especially if you're inserting null data where it's available on every other subscription and it's generally a better practice to have non-null defaults in your database to ensure your app handles those default values yes this is a great point null values are just effing dangerous to begin with just don't have null values somebody please what is shadow traffic a shadow traffic is really simple if you're ever building a new service that is a rewrite of an old service why is shadow traffic so important so what happens right now today is you're going to have your old service right here right your old service is going to take in some sort of htp request coming in whatever it is and it's going to respond with some data whatever that data is a shadow request is pretty simple is you take your new service and you actually take this request and you split it off and hit your new service your new service then responds also and it has what it responds with you're going to take this data and store it somewhere and then or you live compare it at the point of completion and you just say hey how is new service doing is new service doing a good job is new service responding the same way as old service it's like a canary except for it's not serving any real world traffic it's not a comparison of real world it's a comparison of is this thing ready for the real world and this is an extremely effective technique to make sure that whatever you've made is the same as the old version okay well i think we've talked that one to death the name is the primagen