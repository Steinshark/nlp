you may have heard of a set of design principles called solid i actually did a video about them a long time ago when my channel was still tiny time flies i guess anyway today i'm going to cover another set of design principles called grasp and i'll try not to make any stupid pawns i'll show you some examples of how these principles work how you can use them to improve your code and also talk about why i think these grass principles might actually be better suited to python code than solid design principles are only part of the story though if you want to write high quality code you need to learn how to quickly diagnose problems i have a free workshop for you on code diagnosis you can get access at ironwood calls diagnosis it's based on my own experience reviewing code trying to do that efficiently while still finding the problems fast contains don't use advice practical code examples that you can apply right away to your own code so ironwood codes diagnosis the link is also in the description grasp is the abbreviation of general responsibility assignment software patterns or principles there will probably by crack larman in his 1997 book applying uml and patterns there are nine of these principles so what i'm going to do today is go through each of them show you a simple example in python to illustrate how that works you can then later apply them to your own code the first principle is the so-called creator principle and this principle helps you decide where you're supposed to create objects and this is actually quite a commonly occurring problem where do you create things and do you pass them along or do you create them in another class how does that relate to testing etc etc and what the creative principle states is that let's say you have a class a and a class b b can have the responsibility of creating a if for example instances of br composed with a so they refer to an instance of a an instance of b keeps track of instances of a this is for example the case if you are maintaining a list or something another reason to give objects of b the responsibility to create instances of class a as if b is the only class where objects of this class a are being used and finally what's important also to note is that b should have the necessary information to actually create the instances of a it's kind of what's happening in the factory pattern so the factory pattern we have a factory class that's responsible for creating instances of something else and the factory class itself it has the information it needs in order to create those instances so the factory is an example of how to apply the creator principle here i have a code example we have three classes we have a product description class so each product has a price and a description we have a sale line item class that has a product which is one of these and it has a quantity and we have a sale which is a list of sale line items and a time when the sale has been created and then here i have a simple main function that creates a headset product and keyword product it creates two line items with different quantities and then it creates a sale from those line items and then simply prints the sale so when i run this then well we're going to get a print out of the sale which contains of sale line items that's exactly what we created here what's happening in this code example is that we create the sale line items in the main function so in order to let's say order a headset and keyword we have to first create the sale line items and that's what we pass to the sale object so if we apply to create a principle here that would actually state that we shouldn't create them here but we should actually create them in the sale class because sale closely controls these line items they don't have any reason to exist outside of being used in the seal class so if you look at this after version well there you see actually that's sale if i scroll down we have here a list of items like we had before but then now we have a method add line item that gets a product and a quantity and then the sale class itself creates the sale line item and that's because you can also see that here in the main function here we actually don't need to know anything about how the sale class is being structured we simply need to know that we can order products with quantities and that's how we want to use it so it makes sense that actually sale is responsible in this case for creating the sale line item so that type of decision is exactly what the creative principle wants to help you make the second principle of graphs that i want to talk about is the so-called information expert principle this principle helps you decide where you should assign new responsibilities for example you want to add an extension to your application and you need to figure out where do you put it in which class and with which method where does it belong that's where the information export comes in and the idea of this principle is that you basically assign that responsibility you write that extension of your code closest as possible to the part that actually has all the information to do that so in principle you assign the responsibility to the information experts to the parts of your application that has the knowledge to fulfill that responsibility here's the same example again we have product description a sale line item and a sale class and now the question is in which class should we compute the total price of a sale well if you look at the information that's needed we actually are going to need all of the sale line items in order to compute that total price so logically speaking following the information expert principle we should then add that computation add that responsibility to the sale class so here i have an after version where again same thing but now the sale class actually contains a property that computes the total price and you can also see that this works well because well here we have all the information we need total price doesn't need any arguments or whatever in order to compute itself sale can simply do it with all the information that it us and that's the core of the information expert i find this actually very useful principle now this is of course a pretty trivial example and it's almost impossible to put total price in any other place although you could actually make it a separate function but there's lots of cases where you have to make this decision of okay where does this make sense where should i put this code and when you think about it in terms of do we have the information that's necessary and in what place my code is it going to be the most simple to get the information that i need and compute what i want to compute and that's the core idea of the information expert it's not always as clear-cut as this for example what if the total price depends on the types of items that are in the list like if you buy three x's you're going to get two y's for free so where do you then compute those discounts because the discounts themselves might be on the line items themselves but they actually depend on the whole of the order so if you don't watch out you're going to end up possibly with a huge class where you just put everything at the top level so you have all the information there but then actually you lose all the advantages of using classes and composition and things like that so skill is not always an easy clear-cut solution and it might also change because when you update your code you change your code you're going to introduce new information you're going to move around things and they might end up at a situation where the current way you set up things to currently organize things is not making sense anymore since you changed to many other things and that's when you start refactoring start moving things around and that's like almost a continuous process if your code is complex enough so you're always sort of fighting with this information expert idea while you're refactoring your code the third principle in grasp is the controller principle which you've certainly also heard of and here the idea is that if you have a user interface specifically that it makes sense to have an object that's not part of the user interface that handles system events for example clicking about awesome and things like that and the reason you want to do this is that the user interface class is actually already quite big because user interfaces are complex and then if you also add the behavior to it like what should happen when you click a button then the class is going to get huge and your code is going to be really hard to read and that's the problem that the controller tries to solve so i have an example here this is a very simple product management tool so i'm keeping it in the products and sales area i'm using tikka enter here with a couple of dialogues there is a product data class there is a model that is responsible for creating a sqlite connection creating a table and then inserting into a table of products a number of products and deleting products that's basically the methods that you see here and a method for getting the products and then the app itself that's a tk application well this has the model and it creates the ui of course and then if i scroll down you see that there is some actions like like adding a product which asks for the name of the price and then adds the product to via calling the model that's basically what's happening here and we have the same for deleting the product and then when i run this here's what you're going to see so i do add products i type the product name so we have a mango my favorite fruit and we have a price in dollars let's say the mango costs two dollars and then this is what we get and we can add another product like well what other fruits have we that are nice banana and a banana is a bit cheaper than a mango i think so then this is what we get this is still pretty expensive fruit collection but it doesn't matter and we can select them and delete these products again and because it's in the sqlite database when i run this code once more you see that it keeps track of the products that we already added now the problem here is that everything is basically in this huge class here which is the app class well at least we still have a model class we don't have we haven't put all of that in the app class fortunately but still there is quite a bit of coupling happening here because especially if you look at the ad product method you see that it's both responsible for all the logic like creating the dialogues and getting information and then adding the product itself and this is then bound to the bottom of the user interface so there's a pretty large class here's an alternative where we've introduced a controller object so what you can see is that now we still have sort of the same things so the app class we still have the the model that we see here but if you scroll down you see that there's now a controller class and the controller class gets a model and it gets a view and then it binds adding and deleting products via methods to the view and that's what's these methods do and these methods are then called by button clicks so does exactly the same thing but this allows us to split the responsibility of it because now this class here is really mostly responsible for showing dui that's why they create ui method is the biggest method in this class but the controller class now has add products delete products etc and it also has run so that it controls the view and this is a really nice way to separate things because now we have a clear view of the behavior which is all in the controller class and we have the user interface which is in the app class and you see when we set this up we create the model we create a few it takes the model and we have to control it it also takes both the model and a few by the way that's not really a hundred percent correct way to do model view controller that's basically what you see here i did a video a while ago about this particular gui architecture that's i've put a link at the top there's also varieties of this a lot of your presenter for example not everybody agrees who should depend on what so this is just a basic example of how you could do it but there are different possible ways of doing this that i won't dive into further today the next principle that i want to show you is called protected variations and this is basically nothing more than making sure that you're introducing abstraction and that helps because that helps you split up certain parts of the application you can swap out something for something else without having to change the other part that's what abstraction does if you look again at this example of the tk inter app you see that in the end the app relies on the model but the controller relies on both where is it exactly the controller rely eyes on both the model and the view so there's lots of connections between all of these things and we're patching all of that up in the main function so what you can do instead is this is still in a single file norm you would also split this up into multiple files but what you see now is that instead of the controller relying on a model and the view app like what i've shown before you could also introduce an interface or a protocol that defines what the view is going to look like so in this case we have a protocol class called app interface and that has three methods bind add product bind delete product and update the product list and these are implemented in the app class it's a subclass of tk and these methods they're right here controller expects something that's an app interface that has these three methods and then simply calls them when needed the nice thing about this is that we're no longer dependent on tk enter for our view because anything that implements the app interface is going to do the job so we could replace it by let's say qt class without having to change the controller although it's also sometimes a bit hard to achieve now there's an issue though in this particular example that you see that's the controller still asks for the name and the price by using the simple dialog which is of course a tk into a specific thing so if you really want to split this out then probably what you need to do is let me copy these two lines what we can do is add to the app a method called ask product name price and that's going to return a tuple string for the name and the float for the price we should have probably used anions here and then this is what i'm going to put in here and then i'm going to return name price as a tuple so then this is what we get and this line of course we then also need to add to the app interface that we have right here so that controller knows that it's there so what i'll do is i'll add the method here like so and then add the three dots since this is part of the protocol class and now what we can do in the controller is that here instead of directly creating the dialogues we can actually get a name and a price from self.view dot ask product name and price now so now control is truly independent of the tk view since that's actually an interface next principle in grasp is called indirection and that basically states that you can introduce some sort of intermediate unit between two other units to other objects so that the direct coupling between those two objects is removed and of course you can combine that with the previous principle which allows you to introduce some abstractions so that there also there is some decoupling going on so the main benefit of this is lower coupling which is another principle that i'm going to talk about in a minute and there are actually several design patterns that sort of follow this approach like the adapter does this so instead of being dependent on a specific class you can modify the class adapt that class so that it fits better with what you need the facade is also an example where instead of relying on a complicated subsystem directly you define line an object in between that subsystem and your code so that you don't have to know any implementation details and other patterns also rely on indirection like the observer pattern for example so code example here is an order class that has a customer we have a get discount method and that gets the discounts from the customer doesn't really nothing in here doesn't really matter but there is some code in here that checks hey how long is the customer actually a customer and we compute the discount based on the customer lifetime so main function we simply create a customer we create an order and then we can see how much discounts the customer got so this is what we get henry got zero percent discounts are too bad henry and anthony goss the 20 discount so maybe henry should work together with anthony to actually also get the 20 discount the thing is that order and customer are directly coupled to each other now this in itself is not particularly a problem of course often an officer has a customer but the thing thing is that getting a discount also needs the customer in order to get the discount so that's sort of an indirection so what you can do here is introduce an indirection object and let's call that a discount that's what you see here so this is slightly different so order doesn't have a customer it has a discount and the discount itself is computed from in this case customer information but we could in principle introduce abstraction make an abstract discount protocol and then replace that by something else and this approach of turning discount as a concept also into an object might actually also solve the problem that i mentioned earlier and when i was talking about the information expert principle in that if you have an order where discount depends on the types of line items that are in the order and having a discount object that solves that for you might be a good approach principle number six in grasp is called low coupling and this is of course something i've talked a lot about local playing is really important because it allows to split up things more and then reuse parts of your easily and then you can also re assign responsibilities in your code a bit better because they're being split off more especially if you have a large class which uses lots and lots of other classes you're going to have a lot of coupling an example of high coupling is that if you have a class that relies on lots and lots of other classes and often these classes are also going to be very big and if you have that then every everything is basically entangled and it's really hard to sort things out to refactor things and to make sure that you can take pieces of that code reuse it somewhere else etc that's where decoupling your code really helps here is an example of that we have a product description class and a sale line item with dollar price then we have a data class for a cash payment method that gets a discount and we have a credit card class for a credit card payment method with attack so if you pay cash you get a discount if you pay with credit card you have to pay a fee and then we have a sale class where we calculate the total discounted price we get a payment method and then well if it's cash then i'm going to use the discounts if not i'm going to use the tax or the fee in order to calculate the total price this is an example of badly designed code because now the sale class actually needs to know implementation details of each of these different payment method it needs to know stuff about credit cards and cash and if you add another option like i don't know paypal then you're going to need to add another if else statement here with an extra instance if it's instance paypal then print please don't use paypal when you see these types of if statements in your code what's often a good way to solve it is by introducing some abstraction and using an interface instead so here's an example if i could do that so again we have the product description and the line item but now i have a payment method which is a protocol class and it has a net price method and then cash implements that protocol using a discount percentage credit card implements that protocol using a fee percentage and the sale class doesn't have to know anything about that because the only thing that's going to get is a payment method and that should be an oh right in there like so so now total discounted price the only thing it does is call net price and provides us the the total price and that's all it needs to do and if i want to add another payment method i don't need to change anything now in the sale class anymore and by the way i'm using classes quite a bit here of course you can do exactly the same thing with functions right if you have a payment method function that could have this exact signature actually then you can also pass around the function instead of that you're passing around objects i'm purely using this as illustration here and of course a cache class and a credit card class are going to have probably more methods than just these things because they're going to need to communicate with payment provider etc etc it's just a simple example to show how what the difference is so that was low coupling another very important principle is high cohesion and that basically means that you want to minimize responsibilities of classes of modules of your code in order to keep things focused keep them manageable keep them easy to understand low coupling and high cohesion sort of work together because if you split off things making cohesion higher making things more focused then often things are also going to be less coupled because you're going to have less dependencies on lots of different things so they sort of go hand in hand and together i'd say local plane and high cohesion are two of the most important design principles that you can learn about and that you can apply if you just do those two things you're already going to save yourself a ton of problems in the future a few concrete things you can do to avoid cohesion issues is avoid classes that have way too many responsibilities so-called golf classes that try to do everything avoid having too many instance attributes in a class maybe five to seven max something like that if it's more than that you probably need to speed up the class avoid having too many methods in a single class and another thing that i also like to do is if i try to make my code a bit more focused and i look at classes or even modules in python i try to make these things either very much data focused so it's mostly about representing a data structure that can have a few methods or very much behavior focused and in that case it's mainly methods and behavior but i try to keep the data structure that's associated with it pretty simple that way it's going to be easier to patch off things at a later stage because it's going to be code that's really more focused so what i did here is that i took a code example of like a really old video of mine this was about vehicles if you've been one of the first subscribers of the channel maybe remember this but what i did here is i have a brand class that has a volkswagen bmw and a tesla we have a vehicle registry that generates vehicle ids and licenses we have a registered vehicle function that gets a brand and then does something so you see here it determines what the catalog price is it determines the tax percentage etc etc and then it prints some information so here the problem is of course that this register vehicle function has a very low cohesion because it tries to do million different things right it creates objects it generates ids it computes the catalog price depending on the brand it computes the tax percentage then computes the payable tax then prints out information so there's way too many things that it's doing so if you want to write code that has higher cohesion what you generally do is then split these things up so here that's basically what i did i created the vehicle info class that contains information about a brand and you can also see that here it's mainly a data focused class right it has the information but there's just a few things like computing the tax for example a view class as well it's pretty basic it has an id license plate and an info object so it's referring to an instance of this class so that's also pretty data oriented and finally we have a vehicle registry class that initialized itself and then we split that up in a couple of methods that do a few different things in a registering vehicle is actually just a couple of lines of code so i've kept this example pretty close to the thing that i did in my old video just to keep things consistent maybe nowadays i would have done this slightly differently more functional with less classes so if you have an idea of how you would structure this with purely functions and no classes or just classes on a very basic level let me know in the comments i have two more principles to code first is polymorphism and polymorphism that's also used quite a lot in the camera 4 book of design patterns lots of design patterns depend on polymorphism and that basically means that you use inheritance to swap out behavior and the way that i generally like to do that is not using really hardcore inheritance but actually use the idea of having an interface and having things that implements the interface and keeping it to that single level of sort of inheritance leads to quite clean code without having to deal with the actually the some of the problems that inheritance can also result in this related to what i've shown before like if you have an if statement where you have to do something depending on the type of something else then having some sort of abstraction or a superclass and a subclass is going to help clean that up here i have an example of conversion so we're converting from different things to different other things and i have converts a class here that gets a conversion type and then converts an input value and then it goes through the different types so if it's inches to centimeter then this is what it's going to do once the kilometer this one is going to do a pounds to kilogram this is what it's going to do so you see we have this long sequence of if statements here and of course every time you want to convert something to something else now what you need to do is you're going to need to add an extra thing here to the if statement and it's going to lead to a huge convert class which is not what we want obviously so with polymorphism you can use inheritance you can use protocol classes to solve that so here i used an abc but they are simply an abstract method that's called flight conversion that gets an input value float and then basically that's the whole idea of polymorphism you create subclasses for each of the different types of conversions now again i generally wouldn't actually recommend you doing like this i purely did it so that it actually explicitly showed that this is polymorphism what i would typically do is not use an abstract base class but actually use functions directly so what i would do is i would create a conversion funk which is gullible and that gets an input value which is say a float and it's going to return none and then i would remove this class i would not use a formula class but i would basically have each of these things be functions so this is inches to centimeter like so and i would do the same thing for all the other conversion types so this is miles to kilometer and of course there's no self and then we also have plans to kilograms like so and then what i would do instead is that the converter class here you could even make that very simple and not use a class at all but have a convert function that gets an input value and a converter and that's a conversion funk like so and probably i want to define this here it's a bit cleaner and on here we're simply going to call the converter function so now you actually see that this doesn't really make a lot of sense because this does nothing else then just call the converter function that's always the problem with this relatively simple examples but you can see that it now actually becomes much shorter and now also calling it is going to be way simpler because i can simply call the the converter function and then i'm going to simply pass it the input value and inches to centimeter right and then it's going to convert it basically and then we don't even need this variable name anymore so i won't change this for the rest of the code but you get the idea that basically by decoupling the um conversion code from how you're going to convert it is actually going to help clean things up a lot the final principle in grasp is called pure fabrication and that means that if you don't have a clear choice where to put something then it might be a good idea to actually create a separate module or a separate class for it an example here is that we have payment class and we want to have some way to store transactions but transactions don't really belong to payments so what you could do instead is then create some sort of object a new object that can contain that information and of course you could also use a module for that instead of an object but you get the idea so here we simply have the payment class but if we want to store transactions what we could do this is another example we could have another class in this case called persistent sources might also be a database and that basically keeps track of all these records that we want to generate whenever we do payments and then the payments refers to the persistent storage so now we have three classes here persistent storage simply stores records that's the only thing it does it stores transactions we have the payment class that's only responsible for handling payments and this actually shouldn't be here and we have the payment handler that's basically governs everything so it gets the payment it handles the payment and then it saves the transaction into persistent storage so we've basically created something new in order to solve the problem of the payment class having to do everything so overall i think the ideas of the graphs principles are actually quite well suited to python program because of a few reasons one is that these concepts especially when you think about things like high cohesion low coupling it's not not so much related to classes and object-oriented design although of course there is a certain basis in there but solid is much more strongly object oriented design set of principles than grasp for example l in solid stands for liskov substitution and that's a problem that's pretty typical when you're using inheritance in the wrong way cohesion and coupling for example are also helpful concepts when you're creating functions and you want to make sure that the function doesn't rely on too many different things it doesn't have too many arguments you don't pass it like loads and loads of data that functions will be coupled nicely via types so i find these terms a bit easier to understand practically now when you're talking about single responsibility or the dependency inversion principle in the end though i mean there's also a lot of overlap in these grasp principles and the solid principles and that's why i think less people know about these principles than about solid and to my mind what's mainly important is that you keep in mind that these principles are there in the back of your mind and when you're writing code you're going to almost automatically start applying them once you realize that hey perhaps i should think about coupling and cohesion where i create my objects and should i introduce some abstraction somewhere and think when you just think about those things that's already going to help you out and so and hopefully subconsciously steer you towards solutions that are simply designed better so i hope you enjoyed this video if you did give to like consider subscribing to my channel if you learn more about software design you might also like an older video of mine where i dived more deeply into the solid design principles you can watch that video right here thanks for watching and take care