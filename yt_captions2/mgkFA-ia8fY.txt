a failed experiment with rust static dispatch are you guys ready for this one initial versions of the end basic service and therefore initial versions of end tracker use dynamic dispatch to support abstract definitions of system search services such as the database they talk to and the clock they used this looks like a bunch of arc dine foo objects passed around and it was done to support extremely fast unit testing this is funny that we just got done watching the old um code aesthetics video on testing and and dependency injection and all this this is kind of like one of those things that could be kind of similar you know in the rust world if you have like a database connection a database item and you need to pass it between multiple threads you end up having some sort of you know but you want to be able to test against it and not actually use the database you end up having these like dying foods these arcadine businesses so this uh let's hear the other side let's see what the other side of this story you ready for this one it kind of started off this thing this article kind of started off just like right in the deep end okay i like it i like it when i generalized the core logic of these services into the three four framework i decided to i don't know what the three four framework is i decided to experiment with a switch to static dispatch the rationale was that using static dispatch better aligns with the design of well-regarded crates in the rust ecosystem and also because i wanted to avoid unnecessary runtime costs in the foundational pieces of my web services this is good obviously dynamic dispatch will never be as fast as static dispatch static dispatch is literally just like go here and go go do the thing right let me tell you that this decision was a huge mistake and that experiment has utterly failed using static dispatch has been a constant source of frustration due to the difficulty of passing types around and reasoning about trait bounds safety uh the situation has gotten so bad that i dreaded adding new functionality to my services whenever i changed to a statically typed struct was needed because that meant yet another type parameter and plumbing through tens of source files oh man oh man it's kind of like the generic explosion you know the moment you need the like or a lifetime explosion the moment you need to do a lifetime the emotional pain that is rust to do a lifetime after you've built something oh my goodness it can it just it just kills you yes oh camel would be the savior at this point um in lieu of the difficulties oh which eventually turned into blockers to implementing new features i made the choice of going back to dynamic dispatch the goal was to gain ergonomics at the expense of supposedly negligible runtime costs let me tell you about the problems i faced the refactoring journey and some measurements i gathered after the rewrite oh this is great okay this is great this is exciting right uh the adaptation of static dispatcher in uh three four started pretty simple uh it did the job well even though it took me days of fighting with the rust type system i eventually got it to work the production binary was statically bound to the postcre database back end and the unit tests were bound to squeal light let's go file testing let's go squeal lights so good um all the while respecting type safety offered by squeal x and without having virtual function calls anywhere let's take a peek at what the sample key value store code pieces look like by going through the architecture layers described in mvc but for non-ui apps at the bottom layer the database was the transaction traits to supply the operations required by the business logic okay cool so trait tx all right uh i don't what what what does this mean is this a trait that requires another trait to be implemented with it what is this does anyone know what that is that's what it seems to me yes extends better okay yeah yeah yeah yeah yeah bear texas oh it's bear texas uh sounds unbearable um okay that's okay that's what i thought it was i just wanted to make sure i'm not a dumb dumb and misreading it myself async function git keys you go through here db resolves beat reset key okay uh the trait was a separate uh separately implemented for postcre uh squeal and squeal light by providing separate post grease texas and squealite texas specific types and both specific transaction types in the database backing it were chosen at build time where the database connection was established moving up from the business logic layer the driver was parameterized on the domain specific texas transaction so that it could have access to those operations and only those derived clone driver d where the d could be uh it can be send it can be sync it's static let's go it has all the things you want it to be uh the implementation of the driver uh you can get keys which will begin await get the keys commit wait okay keys all right cool note how in the above begin the method recalls an instance of the transaction right away ensuring that the callers always issue database operations as part of the transaction this has been a deliberate decision from the very beginning to prevent isil issuing standalone database calls that could compromise the correctness of the data because there was no scenario in which a transaction was not necessary okay okay so that's why we do that so you do the transaction then you do the thing and then you commit and then it goes okay cool finally the upper rest layer uh took a driver as the engine to run the api request through and uh as a consequence the rest handlers all had to be parameterized with the underlying driver handler d state driver is a state driver driver d uh implement into response arrest error where all of this stuff happened to don't you love this wear business doesn't this isn't this just so fantastic every time i start writing rust and i start constraining these traits down a little bit you just get the exact same stuff everywhere it just starts it's just like spreads it just just does not stop spreading everywhere i feel the pain when i see this the amount of times i've written this exact piece of code is beautiful where where where where tx equals trait expression does it i think it equals transaction tx equals transaction dog doesn't equal trait expression right because you create a begin which creates a transaction the transaction does the operation then you commit a transaction there's no way tx equals trade expression you need to get the hell out of here with that kind of talk all right uh ensuring that the callers issue let's see hold on yeah oh man it's i'm actually getting i'm getting ptsd i'm getting ptsd i'm getting flashbacks right now uh this is where things uh start looking uh finicky because the rest layer now had to spell out the internals of the driver yes it does it's a leaky abstraction that's why but it didn't look so bad at the beginning combining this uh the sun can cost fallacy ooh everyone loves the sunken cost fallacy who here hasn't made the worst decisions of their programming life due to this right here this guy right here right this guy yeah just read it out okay just read it out that right there every single time every time it's just the worst i don't know why i do it but i do it every time every time i'm like i've already done the work let's see and the days devised how to make it above work the idea of avoiding unnecessary abstraction at runtime made me plow ahead with this implementation let's go the problems it soon wasn't all roses what you could see above was an extremely simplified view of how things ended looking like in a real service with more than just database dependencies without further ado let me present to you the most monster monstrosity that i ended up with in the end tracker here's the driver definition foreign is is that every single person that takes in a driver has to copy this wholeair statement uh what's the plus it just means these are trait definitions right so clone means you've had to implement the clone interface effectively send means you had to implement the send interface the sync interface the static interface the clock interface and so c is a clock that can be cloned that can be sent across uh a sink it can be sent across thread boundaries it's sync it's static boom boom boom oh but that's not all oh no this chunk also infected the rest layer which in theory should not care about the specifics of the driver layer here's the rest date here's every single endpoint he has to right now all of them all of them get this beauty added upon them there are several problems with the above code a it's super ugly trademark that you should have used the unicode character just saying bro uh there is no other way to put it as much as i like rust things like this are painful and scary but not as painful and deranged as modern c plus plus have you heard of our lord and savior oh campbell um these weird declarations were repeated 44 times in 37 different files oh gosh oh my goodness gracious oh my goodness gracious imagine needing to change one of those you have to go find every single definition i mean i know lsps make this modern lsp approach really easy this is actually okay so this is where a a text find and replace is actually better it is literally better than using an lsp right like this is actually better than using an lsp oh my goodness gracious but you'd have to have the same naming conventions everywhere you went to be able to find and replace like that boy or that is almost all finals this polluted uh source files with details they don't care about any small change in the driver requirement updating all these repeated chunks in sync i'm not even sure why rust requires the duplication and why it's sometimes okay for the trade bounce to diverge among the various info blocks but the duplication was necessary uh three it poisoned the rest layer as i mentioned above the rest layer wants to pass around the rest state oh gosh every time you every time you pass that around every effing time you pass that around dear gracious of all goodness uh object that contains the driver and other data fields are only necessary at that level yet to achieve this rest layer had to replicate all these internal details of the driver yeah see again this is just it's it's per it's a perfectly leaky abstraction right this is a perfect leaky abstraction because it requires you to understand what's happening within the driver to be able to pass around the driver i had to use a declarative let's see i had to use a derivative to remove unnecessarily question mark clone trait bounds uh the need to have clonable driver and rest day comes from how axum http framework dispatches route execution and figuring this out took quite a while furthermore the way this works is still obscure to me let's go it became impossible to compose transaction types this is a problem with my design and not an inherent issue with static dispatch but the use of static dispatch guided me towards this design note that in the above there are two database instances d and qd each with different associated transaction types while i wrote a sum of contortions to support sharing the same underlying database connections between them i never got to replicating those two also share an open transaction the complexity was already at an unmanageable levels to push this design any further but i needed a solution to my problems so this is again this is this is where i this is why garbage collected languages are really beautiful right this is why we all love garbage collection languages because when you hear this term while i wrote some contortion to support sharing of the same underlying database connection between them i never got to replicating those to also share transactions right like sharing a transaction is extremely hard right that's the reason why borrow checker just makes this type of stuff super hard because the reality is it's really unsafe to do it's very easy to get that wrong and so it doesn't like it it doesn't want that where's i mean this is why i love what ocamel is doing i truly do love what ocamel's doing with their local versus global approach to be able to add in lifetimes but not in complicated lifetimes and lifetimes are also orthogonal to the type definition which means that you get this really speedy amazing thing why would you even uh want to share a transaction you could imagine multiple things doing so like you could imagine a function that does each one of these like does each part of the transaction i could imagine someone doesn't want one big ass file one big ass function doing the entire transaction if you have a large one i could imagine that happening right a stored procedure i wouldn't want to do a stored procedure personally uh this complexity was already at an unmanageable levels to push the design further yep all in all the use of static dispatch was slowing me down and building new features as these constructs made me dread modifying each aspect of the code and what's worse certain initial design choices started showing up as true inefficiencies in production like the inability to issue standalone database calls outside of a transaction yep transactions aren't free the original goal of minimizing runtime costs was made significantly worse fixing these issues required a redesign so it was time to a change switching to dynamic dispatch let's go the goal with the redesign was to drop all static type parameters and replace them with a dine and trait objects i've also had some issues with dyn trade or imple uh in this way the driver would encapsulate these details in just one place and all other code would not have to care about the specific field definitions within this type it was easier said than done but the results speak for themselves now let's see this is how the driver simplified key value store looks okay yes because now you should be able to just say hey at the driver level i need to be able to make it send in sync right it needs to be a db that send that sync so it can do this which means that the rest layer doesn't have to know that right the layer the rest layer doesn't have to copy out these keys right here because that definition stays within this dying area and this one doesn't stay within that that's why people tend to use that right it makes it 10 000 times nicer right you don't have to know about that crap you only know about that crap like because of the dynamic dispatch beautiful that's it the way to declare the driver over a generic database the way to write business logic operation on top of this database and the way to write rest api handler that calls into this operation the arcs and the send sync annotations are somewhat ugly but they are nowhere as ugly as the previous disaster in this version there is no noise what's more as part of the redesign i could throw away everything behind a transaction idea and allow the caller to choose the best execution mode for the needs note the text execution call above which obtains an executor from the database and can be used to talk to the database the specific call obtains an executor from the transaction but the same db execute method also exists and obtains the standalone executor describing how the this works is out of the scope of this post though okay show me the metrics let's see some metrics everyone's favorite thing right here do you like am i becoming annoying okay hey can i get a real talk is the o camel shilling becoming annoying tell me the facts okay that way i can look at them and be sad at the end of this we'll look at this okay at the end of this little article we'll look at the ocabel shilling and we'll see if it's sad or not okay yes and knowing no it's not yes it is no it's not um don't worry well don't worry don't worry we'll fix this oh campbell shilling very very soon okay don't worry don't you worry all right let's go to this thing uh the perfect the pervasiveness of static dispatch and rust ecosystem helps leverage zero cost abstraction but it does come with a cost namely programming time cost uh it is a it is great to have a choice and it is great that many general purpose rust crates use static dispatch so that you don't have to pay unnecessary taxes but it was not the right choice for me i might have done things really wrong in my original design and these measurements may not be sustainable for other projects but let's look at the numbers anyway so i do want to make one statement about rust that i think is going to be a bit of a hot take but i think is correct which is the the reason why rust is so popular is that writing a library even despite the the complexity of you know static dispatch versus dynamic dispatch despite all the complexity becomes a very nicely packaged thing because it's a small library a csv reader the runtime like it does not change it becomes the thing it needs to be and that is that and so i feel like you can design this in it's complete like in its in its completeness whereas when you have an application the moving target is where like for me it's like it makes more sense to hit the clone button it makes more sense to just go dine on that right it's just to go more nuts on that and let the complexity remain in the libraries and let the ease of use remain in the applications okay that's how i feel i think that is the correct way to kind of approach go development um oh no personal choice here uh code size this is the refactoring according to get staff difference uh okay okay okay a project so end tracker which one was end tracker by the way uh lines added lines deleted let's see the changes to the uh three four framework are small because the use of static typing within the framework itself it wasn't pervasive yeah exactly like i said like i said it's easy inside right inside of a little framework inside of its own little files it's very simple after all the framework was just exposing the building blocks and not using them on its own but the 11 of code reduction uh in n tracker alone is very significant let's go let's go uh binary size looking at the size of the main end tracker binary in the supporting a unit test binaries both under the release and debug configuration okay this is just sizing right before after main binary common tests okay so they all go up slightly oh this one goes down a little bit but it goes up a little bit it's about the same a little bit down statistically doesn't really matter i was expecting a slight increase in binary size with the move to dynamic dispatch because the compiler and linker doesn't have as many opportunities for inlining and optimizing code while the results seem to be all over the place they seem to agree with my expectation the binary sizes are larger when using dynamic dispatch some test binaries are smaller indeed but this is most likely due to how tests change uh how the test changed and not necessarily because of the switch from static to dynamic yep compilation time i measured an incremental build after modifying the core type in n tracker code base to the change its internal layout starting from cargo clean state uh slate and using the mold linker with static dispatch the incremental build times of the binary and test versus somewhere between 12 to 13 seconds and with dynamic dispatch they drop just below 12 seconds okay so i'd probably say that they're probably irrelevant right whenever you see someone saying they're they're testing the build times just locally just they're this close it probably doesn't make it probably doesn't make a difference right if he would have said like three seconds versus 12 there's probably a difference right uh the difference is minimal and the code base isn't large enough to obtain a good signal out of this metric to be honest i was hoping for a much larger improvement in incremental compilation times my reasoning was that dealing with the type constraints that existed before must have been expensive so removing them should reduce the compiler execution times my measurement did not approve this true unfortunately or if they did the improvements are negligible in this small code base refactoring effort i spent a couple of days figuring out what the best abstraction was and then i spent many hours during a recent long flight doing all of the mostly mechanical changes to the end tracker code base as usual updating the test was the most painful part of a of all and all also the one that gave me confidence to deploy a new build to production with ease nice nice this is great uh runtime cost this one well i haven't been able to measure it none of my web services are cpu bounds so the cost of the virtual function dispatch is negligible boom boom to summarize and not much it seems to have changed with this rewrite binaries are slightly larger indeed but not by a lot however the benefits in productivity uh are massively are massive already so i'm not going to lie to you when i hear this okay i'm just gonna i'm just gonna give i'm gonna render a little bit of a judgment here when i hear all these things put together like a nowhere near cpu bound huge improvement in productivity to me this just sounds like years ago i mean i'm gonna say oh camel but you guys are tired of me shilling out camel so i'm gonna go with go but i i'm just throwing it out there like unless if you just love writing rust like the point of doing this is writing rust which then at that point use ross right but if the point of this is getting things done and you find yourself getting more productive by having to specify less types go for go go for oh camel go for something else right it's just like if your goal is only productivity there's better languages right and you are absolutely under no constraint of cpu like you're running on a nano node and just go for it because js sucks there's a reason why you shouldn't use js and js sucks okay that's why js sucks all right uh there's so many problems with javascript i just absolutely just just it just drives me nuts the amount of rust and typescript compete for who can write the most type definitions okay okay rust and typescript go ahead develop a library even theo did a video about this right he was all about uh you know he he had a i feel like he had to write some library code and realize just like how much typescript can really get in the way stop with the negativity.js it's great no chance it's not great it's okay negativity is not bad okay there's a difference between being a cynical person and pointing out something that sucks javascript sucks it's inconsistent it has a lot of issues there's all sorts of weird guards you have to do typescript makes it better but it also makes some parts a massively more complex right the amount of type definition magic you have to do to write a good library is nuts you can't just say that okay i'm sorry i'm sorry that you feel that way to me whenever i hear someone saying no you're just being negative javascript is actually really great what i actually hear in my head is i've never really tried anything else maybe like a day of java or something and java sucks so javascript's great right that's what i hear right it's just what i hear i'm sorry that's that's how i hear it you know what i mean you know what i mean like that's the i'll always hear it that way and i'm not trying to be a mean guy it's just that's what i hear you know uh like i just get bored right i uh javascript i just i just constantly run into just some of the worst errors ever one of the benefits of this rewrite is uh i've been able to finally resolve a long-standing deficiency and test coverage which i briefly mentioned in the conclusion of the unit testing web server plus ooh interesting this deficiency was uh that the test suites for the driver and the rest layer ran against squeal light unconditionally and i did not want to have to run them against a real post greece squeal instance well i have answered now all it took was to switch dynamic dispatch and was to introduce a helper function like this connect to testdb uh do a bunch of the arc dine blood of the blog get optional test db string must accept that d ref some postcard test utilities weight a squeal light tester and it's schema go uh i use to connect a database in all tests and configure github actions to do with db post to run the test suite against the production database another benefit is that i have finally unstuck something i've been working on and off for months and i've been procrastinating on due to its difficulty that is i've been trying to generalize the account creation in session management pieces for the uh end basic service into three four so that i can reuse those in end tracker this is made really difficult due to static dispatch but now it's a piece of cake whichever means i should be able to add user accounts in n tracker really soon or soon now or in tracker really soon now and maybe finally open it up to the public okay interesting all in all i'm satisfied with the change the code is much simpler now and i do not have to foresee small uh cost at runtime nor in binary size to be a problem at all for my specific use cases boom again uh this is great by the way this is a great article and i think it just goes to show you that there can be some really significant costs when making things as performant as possible right like you should really have a strong reason to do this right like until you get to this point like you should never get to this point without the world's strongest reasons you know what i mean and so i just see this and it makes me sad because at the end he kind of outed himself as being like well this was kind of useless because he was just like um what do you say it well actually i wasn't cpu bound at all so i i did something to make it faster that isn't actually useful at all and so it's like it's a good exercise right he learned a lot from this but at the end of the day you did an optimization for a thing that did not need to be optimized yet right doesn't rust have macros for this sort of thing not like that kind of macro my friend only only sith deals and absolutes uh no that's a dumb phrase there's plenty of absolutes in life okay if if saying child porn is wrong absolutely in all circumstances then call me a sith baby uh the name is i'm probably a sith baby