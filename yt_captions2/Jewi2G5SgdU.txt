i think so if we're doing typescript content we're doing typescript content oh hey it's typescript content okay we don't we don't mess around with that non-stuff okay there we go we're not gonna get fully naked okay but if we're doing typescript content you know we gotta look the part okay hoodies off let's go okay hey next generation typescript are you ready for this i'm kind of excited about this what is next gen typescript hi i'm ethan and this video is an introduction to effect a typescript library to help developers easily create the complex applications of today and tomorrow okay exciting next generation here we're gonna turn up the we're going to turn up the volume we're going to turn up the volume i'm actually at maximum i'm at 153 spinal tap 11 can't get any louder we are stuck with javascript and all of its quirks whether we like it or not typescript has been a really big step but the primitives it's built on are still fundamentally flawed it's time to build with a library designed to handle the complexity of modern development how often i do agree with this i think javascript is a severely flawed language but you know to be fair all languages are kind of severely flawed in their own way you know what i mean you know you know what i mean except for go and rust they're beautiful languages and oh camel uh you know i mean c really is a perfect language um c plus plus is horrifying oh gosh i mean i'm sure elixir is great i've never used elixir i mean haskell's so glorious that you can only write white papers like okay so maybe it's just job maybe javascript sucks have you seen this kind of code yeah what problems might there be here several try catch in so this is like my classic example of why i hate javascript where are the errors like this function doesn't state that it has an error this function does not state that it has an error this function does not like there is three possible places where errors happen the biggest problem is that this function could crash your program but doesn't feel the need to tell you that guy read my mind he just he read it he read it he knew it i knew it if it happens it happens dude pre-watch no it's because i've done this too much it's because i've written too much yeah unsafe assumptions crash our programs at runtime and wake us up at 4am correct handling these cases properly in vanilla typescript is less than ideal it did i we have not gotten to a point in web dev where we say the phrase vanilla typescript right is that a thing now a language that's transpiled to a language that is interpreted ethan i love you this is a great you already have captured my heart with everything you're saying ethan i am on your team but please never say the word vanilla typescript again it i will emotionally be i i'm gonna die i'm gonna die i'm dying on the inside what if you forget to try catch what if you forget one of the possible errors yeah this is exactly as unsafe as the original function but the three places it can crash are now explicitly stated yep if you want it to never crash you find alternatives for those or dies here's what a verbose version of that might look like okay this is good i know this may seem like a lot but this is mostly caused by having to work around existing apis that are designed around try catch it takes a bit of work at the weeds but once you're into the effect world things become much easier so i so right away there's something that really worries me right off the rip uh when i'm just looking at this code right i like this is just a result type but what i'm seeing right now is i'm just seeing effectively an attempt to mix two concepts together some sort of asyncing like understanding of promises and then on top of it it looks like it's it's really also doing uh uh what's it called a result type and so if you're not familiar with result types we'll get your monads in order because i'm about to put my foot in your functor okay so think about that should i put is it my foot in your functor my functor in your ass i feel like the second one just doesn't sound the way i want it to sound you know what i mean it doesn't sound quite the way i want it doesn't doesn't quite sound the way i want it to an idiomatic effect solution looks like this don't worry too much about the specifics here we'll talk about the basic effect types and functions soon i am very worried about memory so i you know i come from a different world right i write on televisions i memory when i write code i think about memory is kind of like a thing i should be worried about right and so when i see this it worries me you know what i mean the love-hate relationship with javascript is something most developers share yeah you can't seem to escape it the language has grown a lot with new modern features and typescript making development surprisingly pleasant but the pain points are still there effect brings typescript up another level providing powerful primitives to make writing safe asynchronous resourceful composable concurrent and observable programs easier than ever before i'm curious about the observable i'm curious if he's going to address that because that's a you know it's one of the hard parts about promises and things like that is that it's it's sometimes it's hard to observe your program in a good in a good manner isn't typescript already safe no it's never been safe it's not going to start with type safety what's the problem with these two types they're only generic over one parameter correct typescript gives us the illusion of safety but once things go off the happy path you're left completely in the dark also uh just so you know optimizations in javascript are often tied to like monomorphic functions and stuff like that so when i see things where you have generics as parameters you're also setting yourself up to get like destroyed in performance you know just a thing just a thing i'd like to throw out there i am here to tell you that it doesn't have to be that way okay the effect type is the core of the entire effect ecosystem although their actual implementation is a bit more complex it can be helpful to think of an effect as a function that takes in its requirements as arguments and returns either a value or an error uh i really don't like this interface right off the rip where air is first and then value i'm more of a value error kind of guy not an error value that's kind of like the old node way which is error value i never been that kind of person more into the whole you know you know what i mean kind of more into that side you know what i mean takes in its requirements as arguments and returns either a value or an error now back to javascript for just a quick moment asynchronous code is everywhere in modern apps that's the promise primitive leaves a lot to be desired absolutely promises are eagerly executed meaning they begin execution immediately on creation this means that they can never be used to represent a computation this is correct i've never really liked that but there is async iterators which are kind of like a neat result of a promise but i do agree the idea of a promise being uh hot is kind of annoying i kind of wish i had like a way to um i kind of wish i i that's why often you'll see things like promise factories where if you try to build any sort of async request queue you kind of have to like make them into factory so you have to have a function that returns a promise as opposed to just receiving promises or else they just all execute right away yeah they're kind of annoying already running computation that might have already completed and produced a value also the value produced by a promise is implicitly memoized meaning that when the promise is settled the internal state of the promise is frozen and can't be changed anymore whether the promise is fulfilled or rejected correct consequently if you correct which means you may hold on to memory longer want to run the same computation again you'll need to recreate the entire promise from scratch effects aren't like this the effect data type represents an immutable value that lazily describes a workflow or a job and all effect functions produce new effect values again worried about the memory of this um the thing that makes promises good is that they are also supported at a syntax level with async await and that's why i like them right if i just had the raw dog promises i wouldn't like it at all and so one of the i always see this this is the same thing i always see people you know like you know ethan i think i love where you're trying to go with this kind of stuff i've seen this also with like options or result types people try to do in uh java or in typescript it's always the same thing which is these ideas are great but if there's no syntax support for these ideas and you have no pattern matching on top of it which is all you know syntax support um these things can be huge pain in the asses you know what i mean like these are not great experiences you know and so until javascript gets generics built into it and all of that like how can this work okay let them cook you're telling me let let bro cook the building's not gonna burn down okay okay let me hear it back to values don't actually do anything they are just values that model or describe effectual interactions and effect can be interpreted by the effect runtime system into effectual interactions with the external world if you're like me your mind is probably racing with possibilities at this point i am now going to give you an intentionally very quick tour of some of the things that the effect ecosystem offers my mind personally is racing with memory and desire that there was better syntax why i still love i i i'll let them cook we're letting them although you're more than welcome to pause on each slide to try and understand what's going on don't get too caught up in the specifics i'll go into more depth in future videos just try to get an idea of what's possible now that errors are in their own dedicated channel and clearly separated by type it becomes trivial to handle errors case by case all at once or to let them bubble up to the i i i'm curious if these catch i'm curious if the catch tag that must use some sort of like name of the function right so that way name of the constructor so it's able to get the thing that's coming out of it correctly it does look like rxjs which is also a leaky abstraction this is also i mean effect is a leaky abstraction uh but i'm curious if it uses some sort of type completing some sort of crazy inference some sort of whatever that's able to infer out these strings or do you have to manually type them in hoping you've correctly type them in for me that's always a big worry whenever i see strings uh if that's the case i'd much rather see you passing a constructor because if you already have the type it'd be nice just to pass in the constructor you know what i mean next effect what's wrong with this snippet well nothing until you want to swap your live database client for a local test one sure we could go full functional programming and pass every possible dependency as an argument but that quickly becomes unrealistic effect provides a better way in effect a tag on oh i'm just looking i'm sorry i'm just i'm just trying i'm just trying to understand this one thing by the way please stop doing this there are libraries of the protobuf generation library does this where they name the type and the constant the same value it totally f's with trying to uh you can't reuse the type easily sometimes and it can be just just very frustrating sometimes anyways uh sorry i'll keep going i'll keep going context tag okay function get users from this db client runnable okay what's happening he's a placeholder for a dependency of some type we can use the tag just as if it was the actual implemented object in rfx without ever actually implementing it doing so causes that type to appear in the requirements field of the resulting effect this tells the effect runtime that you must provide an implementation that matches the defined type before the program can be run this can be done flexible anywhere in your program meaning it becomes simple to swap out the implementation of dependency when required modern app that's cool because that'll i mean at least it airs out it's kind of like some sort of trait implementation you're just you're i mean it looks like a very convo i mean in some sense it's a very convoluted way to make a interface requirement but i could i i mean i can dig i can dig it i can dig it anywhere in your program meaning it becomes simple to swap out the implementation of a dependency when required modern apps are complex often involving complex dependency hierarchies to account for this effect provides a layer a type describing the blueprint for the construction of a set of requirements it takes some requirements in may produce some error and yield some requirements out resources in our application may require lifetime related logic the scope data type is fundamental for managing resources safely and in a composable manner in effect in simple terms a scope represents the lifetime of one or more resources when a scope is closed the resources associated with it are guaranteed to be released modern applications require observability for us i guess i didn't see how they're guaranteed to be released there must be some sort of okay okay so okay okay hold on so that means the effect itself is going to have its own it has its own life cycles that it calls and so a choir does this release so it actually will call and check for these things okay so you have you have multiple life cycles then this is associated with it are guaranteed to be released modern applications require observability for us to know what's going on inside them yep effect provides powerful logging capabilities with different levels such as debug info warning and error as well as the ability to provide a custom logger that can do more than just a simple console.log effect provides a powerful and composable scheduling toolkit for when you want to run an effect more than just once have you ever tried implementing jittered exponential back off if you were to try to implement the snippet without effect how would you do it would it be as flexible or as maintainable this code function that takes in a function but i mean i see what you mean it's it's a non-trivial problem if you haven't done your own throttle your own debounce your own back off you know those things can be kind of difficult i always have a lot of questions whenever i hear these things like should you ever do those things because whenever you do these back offs whenever you do that you can also accidentally create yourself a thundering herd in your own cloud and just destroy your own service people like we did that at netflix we had this nice exponential back off then we had all these different kind of ones and then all of a sudden the next thing you do your clients are all just like ah the request failed we'd better make another request shortly oh the request failed again we we should make it but a little bit longer this time right so your service is just like ouch ouch ouch [laughter] we've definitely done that it works while your meager startup only has five users but what about when it grows to hundreds or thousands that many requests at once will crash your users devices and remember promises are eagerly executed so we'll need to design a complicated async queue with batching an interruption to enforce a level of parallelism or we could use effect concurrency it really is this easy affects fiber-based runtime manages everything for you lightweight threads of execution called fibers power effects runtime think of a fiber as a worker that performs a specific job it can be started paused resumed and even interrupted effect also seamlessly integrates with existing interruption apis such as support controller working with fibers directly is a pretty advanced use case you probably won't need for a while when starting out so when i hear that the thing i don't like about that is that the process of end loop is already a pretty dang good one and you can't actually stop a con like a currently running javascript item you have to wait until javascript goes back to the event loop right you have to wait for the stack to be cleared and so you can't pause it or interrupt it you can only stop it at a certain point which means that you have an event loop which orders things as they come and now you're going to actually have a re-implemented event loop and now you have to have all these tasks that are always kind of calling back and you have to have something that's doing some sort of mega task listening to and then comes in and tries to pluck these things off one at a time um and also i mean javascript is single process execution i don't like to use the term single threaded i i've been recently calling it gnu plus linux i don't like to use the term single threaded uh just because v8 is not single threaded but your javascript only executes one line at a time there's no parallelism and so you know this idea of being able to break stuff and all that you do have to understand what that means is that if you i i can just assume here that if you have a pipe of five events and you febreze this thing each one of those events or effects each one of those you could potentially pause between two of them and it will stop executing at one of them and then it will wait uh what i i mean things that i see right now is that i'm trying to understand a system that you would need this in because what you're going to get is that you're going to get significantly worse performance you're going to get significantly higher garbage collection uh but you are going to have some conveniences some things that i when i when i see some of these things what i realize is that there's a lot of concepts being mixed here there's like the result type that we all want a good result type right we all want to be able to avoid having airs thrown right i think we can all agree on this very very much so like that um but i'm not sure if i want all the other things matched up with it right right like i don't like results because i can't have pattern matching but i also not sure if i want to mix it with the concepts of async it almost feels like they need to be separate concepts right and by having them all mixed into one i feel like this is i'm not sure how i feel about i get the idea this this is this reminds me of rxjs back in the day when i got rxjs i was super excited about it everything became rxjs i got a golden hammer and i solved all my problems with rxjs oh you want to do drag and drop look at this mouse down starts the observable oh mouse drag every 100 sec 100 milliseconds is on i fire an event mouse up stop it disconnect from the observable mouse down reek you know like and just do this over and over and over and over again and i could see like everything became a nail because of my love for rxjs at one point and then i realized kind of what it does and all of a sudden i started hating it and then i realized like how much it spreads and then how much you know it can become very difficult to debug these kind of programs because the reality is is that most the code that execute isn't your code and so when things aren't working the way you think they are debugging can become excessively difficult you know what i mean that's that's where i see some of the problems here application code and typescript often solves the same problems over and over again someone just said yeah observables was cool until you have to debug it it's exactly like literally what i'm saying exactly precisely correct which is they feel amaz like these type of systems they seem super awesome but it's always the debug story that i really really really worry about the thing is that effect doesn't spread uh that much or to integrate well with vanilla code i get that why am i so naked today i'm i'm doing some i'm doing some types provides a rich ecosystem of libraries that provide standardized solutions to many of these problems you can use these libraries to build your application or you can use them to build your own libraries however effect understands it's not always realistic to rewrite your entire application by now you might have thought back to other projects aimed at doing typescript better or even other programming languages the majority of which ultimately fall to the same fate a lack of easy interrupt with a vast and unavoidable existing javascript ecosystem my assumption is that there's probably some sort of like simple exiting item that just converts it into a promise and go that's my guess not effect well it would be awesome to write applications that are affect all the way down you can just start with the pieces of the ecosystem that make the most sense for the problems you are solving do you just want to rewrite a single endpoint that does some complicated parallel asynchronous work or has some particularly nasty error handling you can do it with effect today do you just want to take advantage of one of effect's useful data structures you can do it with effect today well that's good i mean i like things however as more and more of your code base is using effect you will probably find yourself wanting to utilize even more of the ecosystem so that's one of the dangers of course so the underlying thing that he didn't say is that it it also can easily spread right maybe it spreads and maybe start solving things that you don't have to solve it just becomes convenient to solve once you already have the abstraction and that's why i get i get a little bit worried and lastly if you think you could get out of using effect because functional programming is too different and too difficult think again effect has its own form of async or white style syntax powered by generators with generators you can write effectful code in the imperative way that you already know effects concepts may be new to you and may not completely make sense at first this is totally normal learning effect is a lot of fun many developers in the effect ecosystem are using effect today to solve real problems in their day-to-day work as well as experimenting with cutting edge ideas for pushing typescript to be the most useful language it can be i hope you feel inspired to give the effect documentation a read and to explore the effect repositories and api reference pages i gladly at least you said go use go look go read the docs first i like it i like it hey i like it start with the start with the docs consider joining the effect discord server a great community for learning and discussing effect links to all of that as well as the transcript and markdown source code to this video are available in the description and corrections will be in the pin comment finally a huge thank you and shout out to no boilerplate to whom this video takes very strong inspiration from nice his videos are incredible and inspired my passion i most certainly saw the no boilerplate um feel from this video you can see it right away in the sense that this was obviously pretty straight to the point there was not a lot of fluff in this video very well done really like this video great youtube video overall very well done rust just like i hope this video will inspire your passion for effect please check out his channel the link is also in the description thank you so much for watching and i'll see you next time and i'll see you next time come on that's a trust move we all know that um content layer mix working with um very well content later makes working with okay i don't know what just happened there it got me twice uh i really did like that i i really liked the style of youtube video i think that he did a great job i think that everything was good why am i not wearing i already told you why i'm not wearing something the thing i don't like about that again is just i foresee leaky interfaces i foresee high memory i see hard debug ability i know there's observability built in with this whole logger situation you can provide your own custom logger that all i i love that i love that part but i don't love that tech i don't think it's good and i'm gonna i know i i don't often say things in such absolute terms i really try never to say this it's really just rxjs that gets my my ire i will not use rxjs i will not use effect i am sorry uh it it i love the concepts in there i think they're all really really great i just don't think it's great for javascript personal opinion okay i will not use it i don't use effect in react i don't use effect in this i don't use react by the way by the way um anyways there you go rxjs is pretty confusing uh it's not confused i mean once you get it it's not confusing it's it's what it does to your code it's the same thing that happens with the fact it's what it does to your code that can become really difficult appreciate your comments the name is ethan i really liked your youtube video i'm sorry that i'm shooting on effect but hey i really liked your youtube video you should go and subscribe to him because it was actually a very well done video and i'm confident he's going to continue to make some really good videos again