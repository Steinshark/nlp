oh thank you foster all right let's get started i'm turning off the uh you know the alerts because they're really annoying when you're trying to read and stuff like that okay so everybody be on your best behavior this is gonna appear on youtube so don't say anything stupid okay all right so how atomic git commits dramatically increase my productivity and will increase yours too sounds uh i mean okay so dramatically is a big word i feel like that's a little dramatic right now you know what dramatically improved my productivity sessionizer okay that dramatically did this uh this guy right here that dramatically improved my productivity you know it doesn't i'm just down i'm having doubts but maybe i'm wrong atomic or a let's see of or forming a single irreducible unit or component in a larger system also available on my blog uh knowing versus actually knowing okay i like where we're going i like this okay i remember when my first mentor told me about test driven development oh damn we're already getting back to tdd oh no oh not like this okay here we go a great method oh my goodness you just don't understand tdd no which i do it's just terrible uh okay great method of methodological approach to software engineering it took me a few minutes to understand what it was and how it worked then i spent the next six months actively not practicing it got him td is hard when you start you just don't no td is tdd is hard because if you write your test first you're like you're like you're like pretending you have the foreknowledge of the universe it's just annoying half a year later i was hitting my head against a wall trying to build a new feature i forced myself for the first time to actually do tdd by the book the wall that was blocking my progress disappeared instantaneously okay i thought we were talking about atomic git commits i've somehow been bamboozled into using tdd i'm not doing tdd in a previous article i explained how many managers and tech leads often know exactly how to make our industry better yet don't i gotta read that better but uh [ __ ] you and [ __ ] you and uh [ __ ] you and you're cool and [ __ ] you i'm out of here it's just like damn uh there is always a good reason to not uh do things right and somehow we still end up surprised when we're doing things wrong yeah man hell yeah hell yeah um this long introduction is uh here to illustrate a point you can know what you should do but you might not know how important it is to actually do it so many people out there just like i did before know how tdd is great yet still don't use it man this sounds like we're coping here tdd is not great it's not great it's not great it's not great the simplest concepts can often uh completely change the way you work if you would only apply them introducing the atomic get commits all right what's an atomic git commit i might actually like this i'm actually pretty excited about this i actually think i might fall in love with this man i just got done just full full grade a ligma in him and now i might just love him to death with ligma all right working the atomic git commits wait working with atomic working the atomic commits that sounds like something completely different working with atomic git commits means your commits are of the smallest possible size so before we go on i will say that this has led to quite a bit of problems in my past doing it too small because the problem is there is this notion of atomic commit versus what could be done because then you start getting into this whole like what's the difference between a good citizen and an atomic commit i'll give you an example let's say you're working in a mono repo and there's something like csv builder csv builders say is in the main area but what would be really nice is if you moved it say into some sort of like uh other package that kind of can be used in multiple repos blah blah blah blah and you end up not doing it and just taking the more short route you're doing exactly what you're supposed to be doing in that one commit but that one commit then leads people to say hey you should be moving stuff and now you're caught in between this thing where it's like i should be doing the more extensive change or should i be doing the atomic basic change and i've had these problems before where you end up getting onto these really pedantic arguments when you try to be too prescriptive about being atomic do you know what i mean it's just one of those problems yeah quark commit it could be in two locations at once and it's extremely confusing each commit does one and the only one simple thing i could barely speak there that can be summed up in a single sentence in a simple sentence some [ __ ] happened the amount of the amount of code changes doesn't matter it can be uh a letter or it can be a hundred thousand lines but you should be able to describe the change with one simple short sentence i don't know about this uh ideally you want your test suite to be in the green when you commit okay also you want oh i said ideally i think also you want yeah okay you chain your change your changes might be atomic i.e the smallest possible but they should be also be complete means that your test suite hollow fault always follows through okay as a let's see as small as possible but complete this is an atomic okay so where's this productivity at i think we all understood this where's the productivity i want to know there are a few great advantages to practicing atomica git commits and we'll detail them briefly i reread that sense a completely different order but the last one really is important uh it might completely change the way you approach your work increase your productivity by an order of magnitude uh and make your job much more enjoyable okay dude i gotta know this okay reason number one an atomic change is a reversible change agreed we all know the simple truth about software the requirements are always changing but writing atomic commits we allow ourselves to revert any changes by simply commit revert this already increases your productivity tremendously okay so i i'm not sure how much that how okay pull pull time pull time pull tax let's go let's do a pole dance right now we're doing a pull dance dude where the hell does my poll go every time i want to use it it just disappears on me pull manage my pole i swear every single time all right new poll uh revert i revert regularly sometimes rarely never how often are you reverting your code i gotta find out oh manager pulled manage me daddy like really how often are you doing it i'm in like the rarely to never camp being able to revert commence doesn't uh really make you more productive unless you have to do that a lot exactly that's the thing come exactly cub like it is amazing to have the opportunity to revert which is also why i don't do git merges irie base dog uh but the ability to revert or cherry pick is still very important so i do try to keep things as small as possible i really do try to and it's really hard discipline to have because let's just be real here it's really easy to want to keep rewriting as you're moving stuff right have you ever refactored a little bit and then you end up refactoring a lot a bit and then you end up refactoring like the whole damn project and you're like what the hell did i do here how did i end up from moving one function to like 10 000 line change i love when people rebase but i don't know how let's see but don't know how uh to rebase and then lose public branch history yeah i mean it's very easy not to lose public branch information you don't rebase master you know the lord right it's like it's not that hard don't rebase master don't ever need to force push boom you're done yeah you rebased locally okay so most people are on the rarely camp so let's just say that this you do do this and you can revert i would say that an obvious w here is that you can revert but i would also say it's just like it's not i would not put this as reason number one i would just simply never put this as reason number one why you should get into this habit because it's not for me it's not the big reason for me the number one reason why you do this okay so dude okay so i feel like samuel i feel like you had he had a good start well he had a terrible start start with tdd really just kicked me right betwixt the legs and then followed up with this i'll i'll tell you my version of your story when [ __ ] hits the fan a clean gift history makes a difference between pain and salvation it's like insuring your house seems useless until there's a fire examples why why why does a clean history make any sort of sense why is this important i will tell you one reason why it's important is that it's nice to be able to look back or search back for a series of changes to be able to kind of deduce them to a small set if you need to that has been very beneficial for me to be able to search up the word widgets and see the last five changes to a specific widget file in all of uh or a specific set of widget files in all of the netflix seven million line code base yeah that is very useful but nonetheless that's such a rarity again to rely on clean git history again rarely used and i just don't think this is here and anytime you need to find a bug you binary search can we all be real here you binary search number three pull requests are much easier to review absolutely okay so this yes this this i completely agree but the hard part is again there's a difference between commit and pull request a commit can be logically small but a change may need to be a set of commits now personally i'm under the opinion that a pr should try to be under 150 lines every single time every single time if you can you've done a great job if you can't do that i get it then try to make it in a couple different commits and try to do the you know the right thing that's what i find is that if you can make it small it's the best for reasoning right people don't give good reviews once you cross about 150 lines review quality goes down all right number four okay so this is where i'm waiting because he gave me three reasons i don't think we care about nearly as much that could be summed up in a single point of like hey some of the benefits are that you know pr size you can dramatically reduce that uh clean history is nice and you're able to revert your commands boom super nice awesome great thank you all right reason number one a much much better workflow all right this is by far the most important reason to practice atama could get commits it completely alters the way you approach problem solving if you're like me you might have a tendency while developing a feature to just do it entirely yup yep exactly then you realize how much you did not think through everything yep uh you need to change more than you expected the edge cases aren't taken into account you broke some unrelated tests they need fixing soon you can't end up with amazing of your own uh making yup you're lost your head hurts this happened to me just yesterday and i i just literally reverted it and then started doing small commits and just walked my way through the problem you can't make any progress without being entirely focused yep yep yep now this is the wrong way to do things and the worse you already know the right way because it's so obvious yes okay so this is the article could have like literally been this sentence in one other sentence an atomic git commit is just the smallest amount of work you can possibly fit into a practical change that's that b if you do that you won't ever get into the situation in which you accidentally cluster yourself by doing too many things at once but i always find that i can only do that in rear view mirror do you know what i mean i can only start making the change and realize what might need to change and then walk myself back and then you know do this see i okay samuel i like this you should have just started there the well-known method to complete complete a big complex task cut it down into smaller manageable tiny steps each step its own simple problem to solve this is obviously advice that you've probably already heard many times but you're actually practicing it and i do all the time but here's the deal is often you don't know that it's a big problem you don't know it's a complex tax you're going like this oh i just need to hide episode numbers that should be easy six months later 14 teams later galacticus finally is online so we can get all past and current date stamps but non-future stamps can't get and you're just like what the hell how did i get to galacticus from this one tiny change it happens it totally happens it's completely normal uh well here's a great uh way to actually practice it write atomic kit commits ah by forcing working in atomic commits you're approaching the work in the right way by simplifying into smaller steps after after all simplifying complexity is our very core of our job so why aren't we always conscious of doing it of course this advice might sound obvious but my past experience proves anything is that it's uh that the obvious really bears repeating even more importantly it bears practicing okay i like that that's a good way to say it uh make your work simple better and more manageable and mostly let's see and most importantly make it easier i do not know what this i don't know how to use colons correctly but i don't know if that's how you use a colon correctly take small steps write small commits atomic commits you will love them okay i feel like this uh there's just things lacking in here which is foreign the idea of free coding or working your way through a series of features is really really good and it's a very good exercise to be able to do more often on your free time to be able to build something in one go to be able to think through problem make a series of changes pretty quick honestly you will find that you actually flex a different muscle which is foresight the ability to look into the future and kind of design the shape of your code to be able to handle various edge cases you'll gain the ability to look further ahead it's kind of like chess right when you first start playing you'd only really are thinking about your current move after a little bit you have like 15 moves you're thinking about all trying to organize and if you practice that you get better at it now some people can just hold more in their head they're more talented than me their name's john carmack other people like me we kind of explore and we try things and we walk through the problem slowly and try two like different ways to do things now if you practice that skill you'll find that you can get further and further i personally have found that i can do about a two-month planning on the spot may meaning that i can write code that's effectively always good for about two months of continuous code writing that's about where i'm at have i gotten better than that sometimes i'll get better by accident i'll get better but i often find that my first go around i can get about two months use out of it and then i have to refactor it into something that i can get about a year use you know use out of it because often it's just that you don't know how the project's going to grow you don't know the direction it's going to take so why spend all of your time planning when obviously you should just get code out there try to understand the pressure and then rewrite the damn thing into something that makes more sense all right personal opinion so does this always work can you always work in this idealized thing no if you're on a greenfield project it's extremely hard to do this just because nothing's even there to do it with you know i wish my managers accepted this take there's a game you have to play and the thing is is that i don't really tell my managers about this take right like i have to kind of i work it in through my estimates you know what i mean but they never let you rewrite things that's why you rewrite them in small chunks this is where atomic is so this is actually a good a good point this is where atomic commits can be really nice is i guarantee you stop tweeting spend one hour rewriting something that really just you really really hate even if it's just a simple move out a simple move out will reduce complexity and then the next day try adding a few like simple items onto it like a simple a nice ways to kind of reduce it and again walk away and it just starts compounding just small refactors change projects big refactors are always hard and hard to sell let's move out let's just say that you have a csv producer that is kind of in line with a bunch of different of your data types and everything's all together and it's super kind of like intertwined and then you need to produce a new csv and so you kind of like hack it in and there's a bunch of if statements and you probably could do this better okay take all that logic go throw it in a single class method or something like that just some somewhere else call it into it then try pulling out some of your events can you abstract them what's in common with it what's not you know what's you know different about it try abstracting like one or two items see where you can get see if you can make it any better and then try doing that a few times and you'll start seeing patterns you'll start becoming better at writing software better because that's always the big thing is that you don't know how to write software better because you have an exercise specifically that muscle enough it helps trust me it does help and so i often just do that i don't try to plan like i really don't try to plan on refactors i just try to do them continuously right i just constantly try to pull things out and make it better all right there you go that's it that's it