hello in this episode we're going to create a method for calculating points that are evenly spaced along a path what slightly tricky about this is that if we take the bezier function i described in the first episode and use that to sample points at constant time intervals they're not at all evenly spaced now there isn't really any elegant way of fixing this so what we're going to do is just interpolate between these points to place new points at a fixed distance from one another obviously the more points we start out with along the curve the more accurately our final set of points is going to match the curve okay so up to this point we've leveraged unities built-in editor functions for working with the bezier curve but since getting evenly spaced points is something we might want to do at runtime in an actual build of the game we're going to need to write out these bezier functions ourselves for this part so i'm going to create a new script called bezier i'll open that up and this is going to be a public static class not inheriting from one a behavior of course and in here i'm creating a public static method returning a vector two i'll just call this evaluate constable evaluate quadratic so i'll take in vector 2 a vector to be and vector to c so the three points that define the curve and then a flirty for the time at which it's being evaluated will sampled and now i'll start off by calculating p naught which is just a linear interpolation between a and b based on t and then same thing p 1 at this time between b and c and then the value that we return is just that same linear interpolation this time between p naught and p 1 all right now as you know the curves that we're using for our editor actually cubic curves but we can calculate those as a linear interpolation between two quadratic curves so it's great a new method returning a vector to called evaluate q ik so this takes in four points a b c and d and an afloat t as well and here we can say p naught is equal to evaluate quadratic passing in a b c and time and p1 is evaluate quadratic passing in b c and d and then t and then we return lynnie interpolation between p naught and p 1 okay so i'll save that and go into the path class and this is getting quite long but someone here maybe just after this last public method i'll create a new public method which is going to return an array of vector twos this will be called sometimes i calculate evenly spaced points you can take an approach for the desired spacing and a float for the resolution shall set by default of one i'm going to create a list of vector twos called evenly spaced points just for adding the points in as we find them so it's equal to a new list of vector twos and we can begin just by adding the first point in the path to that list so points 0 and then i want to know what the last point that we looked at is so call this previous point and initially that will be point zero as well of course then i also want to keep track of the distance that we've traveled along the curve since adding the last evenly spaced point so i'll just call this distance since last even point and i will be 0 at the beginning then i'm going to loop through all of the segments so i'll say for in segment index equal to 0 segment index than a segment count or number segments rather and then can get an array of the points in that segment using the get points and segments method so just pass in the segment index there all right i know i want to sample some points along this segment so i'm going to create a float t equal to zero i'll say while t is less than or equal to one i'll say t plus equals some small amount say point one and then you have vector to point on curve is equal to bezier a dot evaluate cubic passing in the points in the segment 0.0 0.1 0.2 0.3 and the time value we can now increase the distance since the last even point by the distance between the previous point and this new point on the curve we then set the previous point equal to the new point on the curve all right now before we update that previous point let's check if the distance since the last even point is greater than or equal to the spacing value we've been given so if it's equal to the spacing value that means that this new point on the curve is exactly where we want to put our new evenly spaced point if it's greater than the spacing though that means that we've overshot that point by a little bit and so we need to just move back a little bit in the direction we came from so let's figure out how far we may have overshot that distance by i'll call this the overshoot distance and it's simply equal to the distance since the last even point minus the spacing we can now say a vector to new evenly spaced point is equal to the point that we've just found on the curve plus the direction going from this point on the curve to the previous point so previous point minus point on curve dot normalized and we want to multiply that by the overshoot distance so we just move back the appropriate amount in that direction to get our new evenly spaced point we can then add that to the evenly spaced points list so dot add new in this base point and we can say here the distance since the last even point is now equal to the overshoot distance now it's possible that if the spacing value is really small we might overshoot the last even point by so much that we can actually fit multiple evenly spaced points in between the previous point and then you point on the curve so i'm going to change this from an if statement to a while loop so it will just keep running this until it's added in all the evenly spaced points that it can and the only thing that i need to change to make that work it's just inside here set the previous point equal to the new evenly spaced point all right now at the end of this i'm just going to return evenly spaced points and that's a list so i'll just convert it to an array ok this should basically work but currently we're not taking the resolution into account so i want to do is just increase this time value by some amount that's dependent on the resolution so the higher the resolution the smaller the increment should be and there's another factor that i want to take into account here which is the length of the current segment of the path obviously the longer it is the smaller we want this value here to be now a very very crude but good enough for our purposes estimate of the length of a cubic bezier curve can be calculated by taking the distance between the two anchor points and adding half the length of the control net so up here i made you say float control net length is equal to vector 2 dot distance between 1 snort and point 1 plus distance in between points 1 and points 2 plus vector 2 dot distance between points 2 and points 3 ok we can then say estimated curve length is equal to a vector 2 the distance between the two anchor points so p naught and p 3 plus half of the control net length okay and then giresse int divisions so the number of divisions we want to make in this segment is equal to the estimated curve length multiplied by the resolution and let's just also multiply that resolution by some constant factor say 10 this is of course giving us a float value so i'm going to run this up using math f dot seal to inch all right so now we have the number of divisions we want to increase time by 1 f over that number of divisions okay so this calculate evenly spaced points should be working to test this i'm going to create a script that will spawn in spheres at hopefully even intervals along the path so i'm going to make a new folder called examples and inside there have a new c shop script i'll call this path placer want of a better name they'll open that up so this is going to have a public float spacing shall set to maybe 0.1 and another float for the resolution and then in the start method i'll say vector to array points is equal to find objective type path creator and get the path from that and then calculate the evenly spaced points passing in spacing and resolution all right i need to loop through all of these points so for each factor to p in the points array say game object g is equal to a game object or create primitive and create a sphere and then just when i said its position and size so gto transform track position is equal to p and g transformed at local scale i'll set to vector e 3.1 multiplied by spacing multiplied by 1/2 all right let's go into unity and i'm quickly going to just play with this curve a bit i'll turn on auto set control points turn on closed and just make something like that and then i'll add the path placer to this and enter play mode and you can see we've now got these spheres placed evenly around at point one intervals and if i change that to say 0.5 and to play mode once again you can see that it's working nicely of course for a closed path unless it's exactly the right length they're always going to be 2 points which are a little bit too close together but apart from that unavoidable defect it's looking correct so that is everything for this episode until next time cheers