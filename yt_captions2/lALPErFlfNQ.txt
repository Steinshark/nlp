low-level gang our task today is simple we will be doing leap code challenges in particular we'll be doing the two sum problem the twosome problem is one of the most notorious leak code challenges all you have to do is given a list of numbers so for example three two and five return the two indices that add up to your target number so if our target was five we have to return zero and one because three plus two equals five sounds like a pretty easy problem and honestly it is but we'll be doing it in assembly so let's get into it leak code you know for some reason doesn't have assembly as a choosable language in their languages here so we're going to be doing it in c using inline assembly so the way we're going to start is like this and we have to set it up that it uses intel syntax do that with a couple little commands here intel syntax no prefix no prefix reduces the amount of percent signs we use in our code and then we're going to add a ret instruction to just prove that it worked finally to make sure that the compile tyler isn't a happy state we have to return it back to where it started which for some reason is a t syntax so we'll go ahead and do that and then one final thing we have to add to make our program usable is attribute naked so by making it a naked function it actually removes all of the function prologue and epilogue that the compiler adds to the function by itself by default if we run this we will see that we get probably a wrong answer prompt but it means that i compiled and then it ran so at this point we are in full control of the program and now we have to actually get into solving the problem uh we're gonna actually break this down into a few parts so i know the two sum problem itself has a lot of solutions uh one of them is o of n time the the hash table solution i'm not going to be creating a hash table in assembly today we're going to do the o of n squared brute force solution not the prettiest but we're gonna do an assembly so it's going to be pretty cool anyway so we'll break the problem down into parts so first is create a stack because we have to make room for memory for our stuff to go then we have to store are parameters onto the stack then the c solution expects a int pointer to be returned we have to malloc memory for our answer and then we have to do the computation and the computation will be something on the order of uh do an outer loop to iterate over all the numbers then inside of every number we will then do an inner loop to iterate over the other numbers and then from there if the sum equals the target store and leave basically if the sum of the two numbers while we're iterating equals the target number we'll store those indices into the array and then we'll move on and return from the program and then after this we have to clean our stack and and leave all right cool so how do we do all these things in assembly so the first part create a stack pretty simple let me add these things here to prevent the compiler for complaining cool so to create a stack uh the typical syntax and 64-bit intel is push rbx and then we're going to create some room on the stack by subtracting hex 40 from rsp so at this point we've created the stack we now have room for our memory to go when you do a function call in 64-bit assembly a few things happen the first part is that all of your variables come in in registers so there register order in 64-bit is rdi rsi rdx rcx we need to take these registers and store them onto the stack so that we don't lose track of them because if they go away you know our program is useless so store our parameters onto the stack we will do that is let's say move the quadward pointer at hex rsp plus x10 so now hex 10 represents a slot on the stack but we're going to put something and we're going to put rdi there right so rdi is the first all we're going to do now is copy and paste this in order to store all of our parameters onto the stack so remember a quadward pointer is eight long so we're to increment our address by eight so rdi rsi rdx oh and then r c x cool so now we've put our parameters onto the stack and assembly pretty simple so we have to malloc memory now for our answer if you remember before the problem is called the two sum problem which means that there are only ever two answers and those answers of r of type int so 2 times size of int is eight so all we have to do is move into rdi which again is the first parameter of a function call the number eight which is the size we would like to malloc and then call malik we can just do a far call out to malik and malik will call it'll bring us back our memory and return easy and then the return address from malik will be put into rax rix is the return value for a 64-bit function call so we need to put that onto the stack as well to make sure we don't lose track of it either so we're going to put that into slot 30. so we're going to put rax into slot 30. pretty simple so now we've put all our parameters onto the stack we have called malik with the number eight and now we have stored it so we have a pointer to put our answers into now what we're going to do is we're going to create a label that represents the beginning of our loop so we're going to have two counters right if you think of this in like a for loop example we're going to have i and we're going to have i i so the first one we're going to store i in the r8 variable so we're going to set it to zero to start and if you think about this like a for loop 4i equals zero we're setting it to zero right here now we're going to create a label called outer loop which is going to represent you have to do this in inline assembly the little percent equals thing and i have to actually set up the inline to be templatable with these colons here now but now we have a label that we can jump back to when we get to the end of our for loop so we are going to iterate over the list of integers so we're going to start at outer loop so this is i now we're going to create another counter called ii so if you're thinking about two nested for loops r8 is i and then another for loop on the inside and i i equals zero that's all we're doing right here and then we're going to say we have another label called inner loop now we have to do is index into the nums list remember we are given a list of integers we have to index into this list and read out a number and then add them up together so we're going to take the first argument which is going to be rdi which now lives at this location so we're going to do is we're going to say move into rbx the value here so that's going to get us the pointer into our numbers and now we have to do is the math that says that pointer indexed by i so how do we do that well the way we do that is we do load the effective address of rbx and we're going to put into it the value rbx plus r8 times 4. okay because what's happening here is this is i and then we have to multiply i by the size of an integer so 4. and then also we have to create a place that we're going to do this addition right because the whole point of this is we are going to add these numbers together so we're going to clear out rix to do this math so we're going to say load the effective address of rbx we're going to make it the value rbx plus r8 times 4. so we're looking at the value i and then we're going to say add into rax the d word pointer because again integers are a d word type at uh rbx remember to say that rbx points to a four byte type we're going to add it into rax and we can actually just copy and paste this code and then do r9 times 4. pretty simple there we go so we've done the nums of i nums of i i we've added them together and now we have to do is compare that the addition value to the correct target remember because we have to see does that number add up to equal target okay so we're going to take this value here 20 which is where target is stored and we're going to load that into rbx so move into rbx i made a mistake and i said that we are going to point to a quad word at this location well actually the int type is a d word so we're going to say d word pointer instead of rsi it's going to be esi and edx so r is the 64-bit type e is the 32-bit type so we just fix that real quick we're going to say move into ebx the d word pointer at this location and then we're going to compare ebx to eax and if they are not equal which means we did not find the answer we're going to go to the continue label meaning we did not find the answers we have to set up and continue through our for loops right and we'll make that label real quick and we'll get the loop to operate so if we did not find the answer we need to do two things we need to increment our r9 counter compare it to the target's length if it's done increment the r8 counter so we'll say increment r9 and then we will say compare r9 to the number size right because that's going to be the end of our for loop we're iterating over the list we're going to compare it to the d word pointer at this location and if it's less than that value we're going to jump to the inner loop label because that means that we're done with our we need to go back and do our loop and then we can take that same logic and just apply it to the r8 variable because this is our our outer loop counter our ii or our just our i value so we're going to move our comment because our comments in the wrong location so we basically said here compare the two values if they're not the same continue our loop so this area is where the logic is going to be for when the numbers are the same and we've properly added them together if they are the same we have to do two things first we have to store to the return size pointer the number two right because that's going to tell the program hey i have two answers for you that's how it knows to look at our answer and then also we need to store into our return array the indices to those numbers and again what are those indices it's just r8 and r9 so let's do that real quick first we are going to take our return address and we're going to move that into racks and then we're going to say we're going to move into the d word pointer of racks the value r8 and again d is the d word the lower half r8 and then we could say load the effective address into racks the address racks plus four because that's going to be the next integer over and again there's only ever two answers and we're going to move into that location r9d that's going to be the second index so it's going to be i i so once we've done that now we have to do the final part and store the return size to the right value so all we have to do here is take this so we're going to get move into rex the quad word pointer this location and then we're going to say move into the d word pointer at racks hex value 2. so this means treat this pointer as a d word pointer and put the number two there and that's it uh cool and then so once we've gotten to this point it means we've solved our problem we need to go to the label called leaves we will always jump to the leave label when we found the correct answer so we'll take that and we'll make our leave label here where we clean up the stack and leave so at the leave label we have to do a few things one we have to make sure that we put our answer into rax because rx is going to have the return value of the uh the function and then we need to just clean up our stack so we add to rsp hex 40 and then we pop rvx and return so let's walk through this program real quick and make sure that we have a sane answers what are we doing we create a stack we push rbx which is a non-volatile register onto the stack we make some stack space we store all of our parameters onto the stack boom okay we malloc a memory for our answer we're putting eight into rdi and calling malik we're going to move that return address onto the stack to preserve it we're going to create two for loops that are going to be the counters i and r8 and i i in r9 and then for that loop for both of those we're going to take the pointer to our targets and we are going to add the array offset by i to the array offset by ii and add them together and compare that value to our target value in ebx if they are the same we are going to take our return array and we're going to store the indices i and i i into them at the index 0 and 1. so plus four because it's an inch size and then we will take the return size array and we'll store the number two there and we will leave and by leaving we will simply put the return pointer into racks and clean up the stack if we didn't get the answer we will continue by incrementing i incrementing i i and then jumping around so let's give this a run and see if we get any compiler errors or anything like that okay we've got a couple issues here so this is probably an indication that i'm missing colon slash let's see what we got end here it's always one oh so here it didn't like that we used the d word and the racks together so we have to fix those and then same thing with r9 and r8 so we'll do where d word all right all right compare yeah so r9 r9 dd and then we're missing it doesn't like the oh we have to do a colon here instead of the semicolon and then same with the inner and outer loop so we have to define these like this and like this all right couple couple errors nothing too big so we actually passed one of the test cases which is pretty pretty cool i've got the wrong answer for test case two it output 0 0. why is that oh because it iterated over three and then did three again so the issue is it's not going to be i equals zero i i equals i it'll be uh actually move into r9 r8 and then we need to do add to r9 the value one because it's going to be we start with the left and then the right is going to be left plus one so we don't do left and left at the same time so this is going to create i i to be correct test case q's giving us the wrong answers interesting so let's see why is this wrong oh it's not jump less than it's jump less than or equal to because we're not getting to the end here that's the issue there test case two still not doing it oh i didn't i have to uh reload rbx because if i don't do that it'll up the like i'm i'm essentially adding i to it twice right so i have to do this let's try it again cool okay so we got all three test cases right very exciting let's see if we can't submit this and get all the answers right here we go ready drum roll please boom and doing the n squared solution we are still beating 90.9 of the run times guys i hope you enjoyed that i hope you learned a little something about assembly uh and if you like that video hit like hit subscribe and we'll see you in the next elite code challenge take care