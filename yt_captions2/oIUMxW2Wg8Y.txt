i don't know if you know this but rust is stopping your success ++ that's all the title says okay and it's by a man named chad i mean the man's name is practically robert swellington uh this is going to be exciting i'm very excited for this i will say one quick thing at the very tippity top of this i haven't really used c++ beyond c++ 11 cuz that's what our compiler's been largely stuck at and so that's all i've really ever known i know c++ gets a lot better i know here's here's to me hoping that modules really actually will one day work feels like copium here we go here we go all right by the way oh look at that poor crab look at the poor crab uh programming languages are tools not religions yes i don't know if you know this but the term religion i believe comes from the french term religion religion which actually comes from the uh latin term aari which means to hold on to it invokes an idea of you being on a ship and people this was actually a common term before it became a term term for what you believe in but you would really gar a rope while you are on rough seas right just a fun little fact you would hoddle a rope okay and so this was very very important uh understanding so our programming tools something you you grasp onto in the wavy seas well i mean one could one could see a bit of a connection there you know one could see a bit of a connection maybe that's why it's so deep so difficult so backd door wanging you know unfortunately you can't use jokes from other videos because backdoor wang means nothing here sorry if you don't know ftx you don't know backd door w uh anyways sure rust has its merit memory safety without garbage collection yada y y but let's talk about getting actual market ready products out the back door that's where languages like c++ and c sharp shine the borrow checker a double-edged sword oh this okay this actually could be a great take i actually could really like this take okay let's see it ah the borrow checker russ claimed to fame it's like the overly cautious friend who won't let you climb a tree because you might fall and break a leg it's supposed to help you by enforcing strict rules to avoid common pitfalls but in practice it often feels like you're wrestling with it just to get your code to compile and every minute you spend doing that is a minute not spent developing features fixing other kind of bugs or literally or doing literally anything else productive okay so i i guess i have a slightly different take on that one like in some sense i understand what he's trying to say but there's kind like the classic understanding of of of rust which is no i want a tech i want to i want a text way up here which is all safe programs and then there's rust allowed programs right this is kind of like the the notion oopsies the the notion that you kind of have to have in your head when you're using rust which means that if you design a program that is safe but as you program it it's not rust safe you therefore are going to fall into this really big fight with your compiler even though you're doing a safe thing and i think this is where most people's big gripe with rust comes from is not the fact that they want to write safe programs it's that their program which is safe cannot be uh expressed in rust and i think that that can be very very very annoying it' be very annoying and yes someone just said if you're fighting with the bor checker you don't know rust no that's not true at all do any sufficiently sized program and you will start fighting with the borrow checker at some point right uh you don't fight with the borrow checker uh if you write it in the rust way which only comes when you have uh written many of them yeah i know but that's the problem is sometimes the rust way is unclear because no one's really done it yet so you have to like fight your way into this and when you have to refactor you have to like really refactor your way back out which can be very difficult right refactoring is i find it more frequent in my rust programs is it good is it bad not sure it's a skill issue it is a skill issue it just happens to be an amazingly difficult skill f again striving for perfection at the cost of progress here's the kicker with rust you're basically expected to write perfect code from the get-go that's not true at all i wrote several bugs in mind just recently in fact i wrote one that all my clients timed out because i'm a stupid idiot uh sounds great in theory but what if you are in a startup environment or any fast-paced development cycle you need the ship products fast to even see if they're worth refining if you spend all of your time wrestling with the borrow checker to produce perfect code you're burning time and time could been used to do uh used to actually test your product in the market uh most products are extremely simple most things you're solving that you're doing aren't complicated i kind of doubt with this in general i think that most people that are really familiar with axom with the database with testing can produce pretty much equal uh honestly they can produce like equally good stuff in about the same time i've seen some people that can move very very fast if you're really familiar with the uh product you can move pretty dang fast um it's just most people aren't that familiar you know what i mean it's called mvp you can use pyth py for yeah you can also use python you can use javascript i don't think there's anything wrong with saying you should use if it's an mvp you can really use any language you want just use the language that you're the literal fastest with if your only care is to get something out the door just honestly use the language you're the fastest with if you love php donuts with lvl invite taylor otwell over for dinner have a fine glass of wine laugh a little bit and write your product in php nobody's going to care right uh cobalt go for it uh time is money and compilers don't pay bills here's the harsh truth your boss doesn't care about the theoretical benefits of zero cost abstractions if it takes twice as long to ship the product with languages like c++ and c you spend less time fighting the language and more time writing the code that does stuff people actually pay for c+ plus and c have a rich standard libraries and frameworks that uh let you stand on the shoulders of giants rust not so much rust does actually have some really great frameworks right you got a solid like implementation that you can ssr and do templates with with uh such as uh what's it called lepos it has quite a few different templating libraries um it has really amazing handlers like again this just sounds like familiarity right this is just familiarity more than anything else productivity over perfection garbage collect collection in languages like c might be sneered at by hardcore system programmers but guess what it lets you move fast i agree with this it's easier to write a program you can be significantly less familiar with c and write a program faster just like me with go yesterday i literally wrote this in 10 minutes to do a quick websocket test just to see how good i was at writing a bit ago 10 minutes in never used the library never used any of it boom got it up and running super ultra simple it is shocking how easy those things are and in the business world uh often let's see speed often trumps perfection in a tiny memory leak in a non-critical path is the cost of getting a product out six months faster most businesses will pay that price uh gladly fair uh but i doubt that that's the trade-off people are making here here uh ecosystem support c++ and c have been around the block they have massive user bases extensive libraries and a wealth of online resources so i think this i i don't think anybody here would have a problem in some sense with this article if it was c i think the thing that's really triggering people is the c++ you know again i i've been harping on this phrase recently which is it takes a complex language to tackle the complexity of some problems and therefore you write simpler code a simple simple languages make more comp your complexity is either in your language or in your application right i think that's the common phrase i would just like to i would just like to state as a counter example c++ perhaps one of the most complex languages ever in which you can enjoy both the complexity of the language and a complex application all you would like together at the same time because that's what you get it's going be very very difficult uh anyways they have massive user bases extensive library with wealth of online resources if you run into a problem chances are someone else has two and the solution is just as quick google search away rust is getting there but it's not at that level yet the it works factor by at the end of the day businesses care about solutions that work c++ and c have a long track record for working well in a variety of domains from game development to web backends to embedded systems rust might catch up one day but for now it's more of a gamble yeah i mean i get it for game development absolutely embedded systems it's getting pretty dang good right i used it like what last year and it worked with just all the hardware right out of the box with arduino stuff it was like pretty easy you know it was pretty dang easy russ isn't suitable for rapid development cycles where time to market is a priority sure it has its benefits blah blah blah blah blah blah um none of this makes any sense the whole c and then c++ thing it's really this is where it falls apart if you're just saying use a garbage collected language to get your product out the door i buy that argument right java go c javascript whatever your like fancy is for the garbage collected languages if oh camel right if you use one of those i think you'll i think that argument makes a lot more sense right i think you could make a really strong argument there but when you throw this in i just don't like it doesn't make any sense at that point oh camel my camel my camel my camel it just doesn't make any sense there's so many hard things about c i mean like or c++ like how many ways now how many different r&l value combinations of assigning mem copy on assignment versus move semantics versus i mean how many constructors do you need to have these days is there six separate constructors these days i know there was like the rule of four now is it has it has it grown i swear i saw something that's like now there's six constructors zero or six the rule of five dang it is it five it's rule of five dang it okay i was wrong see that's i mean that's how little i know about c++ i mean i' i've always done it i just haven't done a lot of it i'm going to give my verdict on this should you use a garbage collector or non-garbage collected language in all reality i don't really care what you use long as if you're going for speed just use what you're familiar with use what you're you're the best at cuz honestly you're going to be the best at that thing and it's going to be you're just going to do well if you really are not sure you've done a lot of dabbling through a bunch of languages and you're really not sure which one you want to choose i'm still i'm still that go is just really effing simple to get off the ground every time i use it i go h this if air equals no business i hate it but then i program something and i get it done pretty quick and i'm pretty much mostly correct off the rip and i go gosh okay it was pretty easy to do damn it it was really easy to do but man i don't love the language right it's just boring i don't want it i want i want to just i want these complexities i want these type systems that are incredible i want all and then i still just just get stuff done and go and then i sit there and think am i the unreasonable one am i the  right am i the i might just be the just refusing to use something because i'm like it's boring gosh this is boring like i don't like ready and go i do not like ready and go yet it's just so easy every time i just hate it like all you need to know is channels and how to start a g funk and you pretty much know almost everything about go it's shocking it's primitive of course it's primitive and it's primitive to its own fault i don't love it for that reason i find myself doing boring things i don't want to do right i wish their standard library was more complete it's becoming way more complete since they introduced generics but still it's kind of boring uh broad channels are dude channels are amazing and go channels and go are tremendously better because they have syntax support right if rust had syntax support on channels it still would be a pain in the ass because you need this left and right hand side right and so that's what kind of a big pain in the ass whereas go like you just don't need to do that there is no left and right like you just have a channel and you either push it in or you pull it out and like that's that that's great it's unnecessary laborious i know so is every other language when you're doing stuff with java javascript you're still doing a bunch of pretty mediocre string operations you know what i mean it's like when you're doing string stuff in javascript you're just like i mean it's still really annoying to do it it's not like it's somehow way easier don't bring up js in this uh go is easy to start with but it has a lot of foot gums i work professionally with go and there are so many rough edges that you have to be aware of books like 100 mistakes and go are a mandatory reading in my opinion oo interesting i like to read that so yeah easy to start with but it has a lot of hidden foot guns okay yeah yeah i haven't worked any i've only worked in small or mediumsized go projects i've never worked in like a large one when i say large i mean 25,000 plus lines right 25,000 plus lines you could convince me that that's a large project right i i have looked at your uh chat history i'm sorry but you're just you're harping on c++ 14 17 20 23 i see what you're saying it's just not compelling okay i'm not going to read it i'm sorry i do read your chat it's just not worthy to be read out loud and now you're making me do it here okay sorry um no that's like ultra large that's uber large okay that's uber large there's very few projects that are you know in the uh yeah that was great sorry i'm sorry i tried i tried to be polite about it i wasn't trying to dog on you i do i do read i do read your chat i just don't think it's all great to be said the name is it did you like and subscribe a ch