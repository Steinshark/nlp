one of the most important data structures that any student in computer science or engineering should learn is a singly linked list a singly linked list demonstrates proficiency in pointers and is also a good tool to have in your bag when you're going to make bigger projects that need runtime dynamic storage in this video we're going to talk about what a singly linked list is we'll kind of draw out what the structure looks like the different operations you can do on it and then we'll code a linked list in c let's get into it so a singly linked list like it sounds is pretty simple all you really have in a single linked list is all of these different nodes and these nodes have different data in them so we could say that node 1 has data 1. node 2 has data 2 and node 3 has data 3. these list nodes are linked by pointers that point to the next node in the list so here you see this arrow this arrow represents a pointer to the next element in the list at the end of the list you do have a third pointer here but this pointer points out to null which determines that we are at the end of the list also typically in a singly linked list really n any linked list you have what's called the list head this is a statically defined area in global memory that is not in the heap that points to the beginning of the list here so this is our singly linked list we'll call it rsll now there are a bunch of different operations you can do on a singly linked list uh the first is you can add a node to the list so we say add the number four and we would add the number four to this list we could either do an append at the end which is a o of n operation with the navigate through the entire list to get to the end or we can add to the front here and we'll kind of show how both work in c we can also remove an element in the list so we can write a function called remove that removes an element that matches some values if we wanted to remove one we could write the operation that removes this list and then finally we have insert so we can say that we want to insert value 3 at position two and there's an operation we can do as well to make that happen here in our code editor we're gonna get started on our code so we start with the boilerplate see stuff into main rxc arc v and return zero so the first thing we have to do is create the structure that represents a single node in our list remember before like we saw in our drawing a linked list just a series of nodes that are connected to each other so we have to go through and actually define that node structure in c we're going to type the following code type def struct and the reason we do a typedef struct is it removes the necessity to type struct before every every use of the structure right if we didn't say type def struct we would have to type struct in the front and i find that kind of annoying so type def struct node and that is going to represent a single node in our list inside of that node we have two things we have a void pointer which points to the next element in the list and then we also have int data so this will contain the data that we're tracking in our list again looking at our drawing here we have node one node one will be the data and then that next pointer will point out to node two so that's our structure and that's all we need in terms of new structures to make our list happen also we need a node pointer that is the head of the list that represents the first point that points into our list and that will be null to begin so now that we have all of the structures set up we can actually write the code that does our operations and again those operations are going to be a function to add a node to the list to remove a node from the list to insert a node into a position in the list so what we'll do is we'll write those functions but we need to actually create a way for the user to interact with the list so we are going to prompt the user for a number of options to either add remove or insert from the list but first we have to give them a menu so we'll say print menu and that menu function is just going to literally print all the op so we'll say void print menu and the option is going to be you have the following options to add a node to the list do is to remove a node from the list third is to insert a node to the list and then the fourth is to just quit and then we'll return or int option as while option is not equal to four we will print the menu we will scan f store that in our option variable and we'll say that int num received equals scanf and if num received is equal to 1 which means that we got a value back from the user and also if the option is greater than zero and if the option is less than four so we're so we'll make a switch statement that switches the following things we're allowed to do so switch option in the case that it is four we'll just break in the case that it's one we will do our add operation case two remove operation case three insert operation and that's it so pretty straightforward now we have to actually write these functions the function that we're going to use to add a node to the list we're going to define here and we're going to have that function return a pointer to the node that it returns we're going to say node pointer add node and we're going to say that the add node function takes an int data that we want to add to that list okay so the algorithm for adding a node to a linked list it depends on a few edge cases so we're going to go back into photoshop here and kind of talk about what those edge cases are so you have two cases you have to worry about when you're adding a node to a list in the case that you have your head remember the head is just the pointer to the rest of the list if your head is equal to null that means you have an empty list so all you have to do is allocate a node and then point the head to that node that's it that is the first insertion you get to do when you're adding a node to a linked list and then after that if you have your head that points out to a node that already exists and you want to add an additional node you could do this two ways you can do what's called a insertion at the front or an addition at the front which is a little more complicated and the second is to add the node at the end the problem with adding a node to the end of a list is that you have to walk the entire list to figure out where the final pointer is equal to null this actually makes our algorithm end up being o of n where every time we add a node to the list we have to walk the entire length of the list which could be incredibly long and over time that will you know bog down our computer so the algorithm for doing a addition here is as follows so we're going to say again this is our head and it's a little dot and it points out to our node here what we do is we first allocate a new node we point the next pointer into the node to head make them point to the same thing and then we make head no longer point here and we say that head is equal to new node effectively this pushes the entire list forward this way and makes head point to our new node so every time you do this it doesn't depend on how long the list is it always inserts it in o of one time constant time operation so let's make that algorithm happen right now so again we have to handle our two cases first is if the list is empty if head double equals null node pointer nu is equal to malik size of node and always check to make sure your pointers come back correct so if if new double equals null means that like we had a significant issue in our malloc operation we have to handle that but we're not going to worry too much about that so we get back our pointer to our new node and we say that the new data is equal to data which is the data from the user the value that we're actually inserting into our list and then we say that head equals new so this will append the new node to the front of our list and then finally we want to make sure that we set the new next equal to null so this will take care of the list if the list is empty and we're adding a singly a single item to it pretty straightforward so otherwise if the head is not null let's say listed is not empty we have to do our previous operations so this is the same thing we take this we might like a new node and we say that the new data is equal to the data then what we do is we say that the new next pointer is equal to the current head pointer and then the head pointer is equal to new and that's it and then after that we return the new pointer but to make this the correct scope we actually have to move this node new pointer out of this conditional statement set it to null and then just say that nu equals these mallocks okay that we have that and then we return new so now the user gets access to the new node if they want to use it here we've created the way to add a node to the list and we can add as many nodes as we want so you probably should create a way for the user to print the list right so we'll add another option for we'll say print your list well like five to quit and we'll change it so that if option is not equal to five and if it's greater than equal to five and then in case five we break and we'll say uh case four is our print the list so we've created the operation to add an element to the list very easy so we can test this real quick so i want to test out our ad operation but we need to create our print operation first so this is actually pretty simple we'll make this a void because it shouldn't do any operations on the list i don't need it to return anything to me we'll say void print list and what print list will do is it'll say node pointer current equals head while current is not equal to null printf percent d and an arrow to make it pretty and the percent d is going to be the current data and we'll say that current equals current next so all we're doing here is we have a cursor that's walking across the list and after we do some operation on the current position in the list we make the current pointer equal to the current next point we're walking forward one iteration on that list and then we say that we have to print f a new line to make the display pretty and we return that's it walking through this we are going to now add these operations here to our input and uh we'll go from there so to do the id operation we say to the user what data should i insert question mark new line and we'll scan f percent d again into the option field and we will say add node node new equals add node and we're going to add the option value there we go we have to break don't forget to have a break statement because if you don't you'll fall through on your list and then we're going to add some breaks here to make our code actually function and then number four if we get there we're gonna just reprint list operation so pretty straightforward okay so let's create a new terminal and see if we can't get our code to run so gcc attack oh list on main.c a couple errors here these are all just warnings i'm not including standard libs we're going to go ahead and include standard lib we'll run lists the following options we want to print the list so this will actually crash interesting though because it says while the current is not equal to null then it's never going to not be null so it just immediately returns okay so add a node to the list we want to add a 4 to the list we've added four now print the list we printed four add a node to the list one two three four five now we print the list again and we have one two three four five and then four again remember it adds it to the back of the list so okay cool so we have done the thing we wanted to do we made a list and we made the ability to add a node to that list arbitrarily that's great next we want to do the next operations in our linked list we want to be able to remove a node from the list what is the removal operation on a list that's drawn out so let's pretend we have a linked list that has the following nodes we have our head here the head points out to element one and then element two and then element three we are going to remove element number two from the list so the way we have to do this is we have to actually walk it and track a previous pointer because when we find element two effectively all we have to do is make the previous pointer point forward to the next pointer that will effectively remove the links from the list and then we free this node so we're gonna do is we're gonna walk the list and we're going to say get to this element track the previous so the previous at this point points to head is this thing equal to two no okay move on and we keep moving forward until we get to that point in the list so let's do that right now okay so let's write the algorithm for removing a node from the list we have to do the same kind of thing that we did before we keep a current node on the list and we start with the head of our list we're going to do is we're going to walk through starting at the head and compare the data to our to the data that we're looking for and if we match then you know we delete the node from the list so we say while the current is not equal to null so if we find what we're looking for we say if current data is equal to our data the data from the user we have to handle two edge cases one is if the current node is the list head because that changes the algorithm we have to do right if the current node is equal to the list head then all we really need to do is just move the head of the list to the next element so in this case we would just make the head equal to two which is our next pointer so if current is equal to ed and we say that head equals current next and then otherwise if it's not we say that we set the previous next pointer equal to our current next pointer what we have to do is actually create this previous pointer and we can actually set it to start at the element head as well and in either of these cases if we found our data once we've removed it we have to return one tell the user yep we've found the element in the list so otherwise if the data is not found we say that previous is equal to the current node and the current node is equal to our next node so we're tracking these two elements where one is always one step behind and the current node moves up one and then eventually if we get to the end of the list and we hit the front the very end of the list for the list head is equal to null we return zero meaning we did not find it so we're going to go ahead and implement this on our list and prove that it works so we'll take all this code here and add it to the remove option we'll say what data should i remove i would like you to remove this node here and it's not going to be a node pointer it's going to be int success and we'll say if not or if not success we'll just print out element not found get rid of our second break here and there we go boom so let's try this out now errors will run the list so we're going to add one two three four five and we'll see if we can just remove one two three four five from the list one two three four five okay so what if we print our list now okay so the list is empty which is good add a note to the list one what data should i insert we should insert 34. let's print our list okay 34 works and cool okay so we removed it the one issue that i just realized we didn't actually free any of the nodes so we have a memory leak on our program let's actually fix that real quick previous next equals current next now we get to free current and set current equal to null so that we don't ever have access to that again there we go we're done with the remove node now we have the final operation insert a node into a position in the list so this one's pretty simple we have our head it points out to a position of node one and this is position zero let's say position two is position one or data two is position one we want to insert in between these two right so what we can do is we create our new node that is node number four and we're going to insert it into position one which means we'll put it in front of node number two so what we'll do is we'll just say that we make this new node the new node is equal to the current next so it'll point out to node three and we'll say that the current next is equal to us so we're going to effectively remove this link which is exactly what we want to do so let's make that happen in c so we'll say node pointer insert node int data into position i'm going to say that node current is equal to head and we're to say that while current is not equal to null position is not equal to zero we'll just get position minus minus if we get to this position here and we say that if position is not equal to no it's a zero we return null and we print out that requested position too far into list because what happens here if we get to this position here in this loop we're iterating over the entire list until position becomes zero if we get here and it's not zero that means we've encountered the end of the list before we meant to which means that we asked to go to diva to the list so we will return null here now if we get past this point we've successfully actually gotten to a point where we can insert our node into the list so we'll say that node nu is equal to malik size of node new node data is equal to data say that the new node next equal to current next and we'll say that current next is equal to new so that effectively points us to the node in front of our current and it points the current at us putting us in the middle of those two nodes and then we return the new node so again we'll do the same thing as before we'll say what position call it option two and we'll say that node nu is equal to insert node and the arguments where i believe data and position right data and position yep so let's say option option two we get null back if new is equal to null say simply fail to insert into list cool all right so let's go ahead and try that out option two oh okay this should be zero and not null but that's fine so let's go ahead and run it uh first let's try to add a node to a blank list we'll say insert data 1 into position 10. so it's too far into the list we failed to insert into the list okay great let's say add a node to the list we'll make the data at position one we'll say the data will make it one print our list and we'll say add a node to the list i want to insert data 4 at position 0. print our list out okay cool so we put it at the end or we put it at the front of the list it's actually exactly what we want it's awesome um now let's say remove data one print the list for now i want to insert data 5 at position zero aha so it crashed okay so we did find a error i believe we're gonna try on gdb and see if i can get that error to happen again um let's see let's do add a node oh it's because i type freaking five dude that's the issue okay so the issue is if our option is five if we ever use the number five in any of our arguments it crashes the program uh that's interesting it doesn't crash it it properly does what it's supposed to do hmm yeah we're just gonna make a new call it arguan r200 because if we put the option five for any of these it's just wrong we'll call this art1 cool okay let's try it again i was like i didn't see it per uh print that there's a segmentation fault so why did that happen out of node add one add an add element number four add element number five print the list five four one okay cool okay so that's it uh there is your linked list hope you enjoyed that if you did let me do me a favor leave a comment let me know what kind of data structure you want to see next and we'll see you in the next video take care