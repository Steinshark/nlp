every function you've ever written has had a stack well not not this hold on but what is a stack what does it do for your program why does each function have their own how does it work under the hood also why am i stuck here in windows xp i don't know i i'm just as lost on this premise as you are i got banished here when i coded in hasool and i i've kind of just been floating around here let's go back to the vm so here i have a very basic c program that we're going to use to kind of show what the stack does for for each program what a stack frame is and how essentially a stack frame is used to store local data here we have the function main this is the default function in c that always gets called and by default any function that you say that isn't a naked function which is you know the default attribute is not naked uh it will create its own stack frame what does stack frame do it creates room for local variables like this function like this variable z here now when i call function fu the assembly instructions under the hood are going to create a new stack frame for foo to to create room for these local variables we're going to actually disassemble this program and we're going to walk step by step through the assembly to talk about how a new stack frame is created but before we do that we first need to understand some basic things about cpus to understand what's going on in the creation of a stack frame when we talk about assembly in any context we need to understand that inside the cpu there are these hyper fast variables that are called registers now some of them are gp or general purpose register where they can contain any kind of data one of them is extended bx ebx right we can put any data in there that we want to it really serves no purpose to the cpu other than general purpose now there are others that are special purpose registers one of them for example is es the extended stack pointer what that does that points to the top of our stack frame we'll talk about what that actually means here in a second and another one is e bp this points to to the bottom of our stack frame right so b being the bottom and s being the top now when we talk about addresses this is a bit of a holy war in like the computer architecture space but when we talk about the stack we can picture a stack of plates right so here is the top of our stack of plates and you know typically sp will point here when we push additional variables onto our stack of plates sp will go up because the top of our stack gets higher as we push additional plates high higher and higher onto the stack now it is important to understand that as sp goes up the value becomes more negative the more negative sp is the taller our stack is i know it's a little bit of a weird nuance in the world of computing but just understand when we push sp goes up meaning sp goes negative our stack grows up negatively and all the while sp is going up in this case we have bp here which is keeping track of the bottom of our stack frame i keep throwing around these words stack frame so let's talk about what a stack frame actually is in our example there before i showed you that we had a function main and the function main called a function fu before function main actually called fu it already had a stack frame established so you can kind of picture it like this where we have two arrows that point to the top and the bottom of the stack right this thing here is referred to as main's stack frame and main stack frame contains variables like you know maybe it's ark c and arcv or somewhere on here right these are all variables that are that are in scope relative to main when i call foo eventually what we'll go through is the process of the function foo creating a new stack frame that is now above main stack frame all these things here will belong to foo and be in local scope for foo so eventually fu will create this new stack frame an int x will be there an int y will be there these are all local variables to fu and then it collapses the stack frame so that main stack frame is now the stack frame in scope okay so here we go the moment of truth on the left over here here we have the assembly instructions for the function fu and on the right is going to be my drawing of the creation of foo's stack frame we're going to walk through step by step and explore how these instructions lead to more room being on the stack that are in scope to the function foo right it creates room for foo's variables it can do things with those variables and eventually we call the function prologue to collapse the stack and get rid of that room and get the stack back to the state that main had it in so the first instruction we're going to do is we're going to push ebp so right now bp points to the bottom of main stack frame we need to preserve that so we can put it back to bp once this function is over so here we're going to push ebp this is going to be the old base pointer once we do that we then move esp into evp so that now makes the bottom of the stack equal to the current top of the stack so now evp points here so now we have a new stack frame that is of height zero so we're going to get rid of this guy this is no longer here both of these arrows point here right so we have ebp points here as well as esp we're then also going to push variables that we want to preserve across variable boundaries so in this case we also push ebx it's going to go on top of ebp and then after that we call that sub instruction sorry i had to move my fat head to get out of the way by subtracting hex1 14 from esp we raise it and create more room on the stack for foo's local variables so you can't see it here but this new area here that this squirly bracket is the room for foo's local variables and in our code here before we had variables uh x and y x and y are going to live locally here and you can see that we actually move the dword pointer of one and two into these ebp relative locations right ebp minus 10 ebp minus c get one and two that ebp minus 10 and that ebp minus c are the locations on the stack of x and y so before we talked about the function prologue right the area of the function that gets ran before the function even starts that creates this stack frame for our function fu and after this happens fu runs fu does its logic maybe it calls other functions but at the end of fu we need to actually call foo's function epilog what that does is that collapses the stack frame back down so that main can then restore its stack frame to its original state now all the instructions that happen are very simple here there are three instructions the first is that one that involves ebx all that's happening here is it's moving the thing at ebp minus 4 which is right here ebx it's the old ebx that we pushed and it's moving that into ebx so it's essentially taking the saved value and putting it back into the register this means that main depended on ebx not changing when it called fu so it told us to push it onto the stack we did that and now we're preserving it in the function epilog now what we're doing is writing now leave is a function in int assembly that actually does a bunch of implicit liit instructions intel assembly is basically an interpreted language it can do a lot of stuff all at the same time the leave instruction actually moves ebp into esp so now esp no longer points here esp points to ebp it's right here it's in the same spot as ebp and then when we call leave not only do we subtract esp and put it here we also pop ebp which means that the new base pointer is actually down here so the of the stack after this instruction gets ran is ebp points to the bottom and esp points to almost the top now there is one more instruction that has to get ran now the last instruction we have to run is the return instruction there is a magical value here on the stack that when maine called foo it got put onto the stack now the return instruction is a whole magical instruction i made an entire other video about the return instruction because it's so complex in how functions call each other go watch that video and see if you can figure out what happens next