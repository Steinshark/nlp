we're going to do something different here okay i know this is going to be a little bit different but i wanted to talk about a small difference that i see all the time because i see a lot of people always getting super hot and bothered about go air handling if air equals nil and i want to just take a little moment and address it just for a second okay so i'm just going to have this test file and we're going to call it test.js okay and let's say i have an async function you know foo right and then i have another one uh bar okay and i wanted to do something here with that so i have async function main this and i could go await foo and i could go await bar now in goand what would this look like this would look something like this uh right main and it would look something like this where i'd actually have this right and it would look something you know right can we agree this is effectively what it would look like yeah yeah it would look something like this right and that's kind of annoying can we all agree that we don't like that we we like this typically what people always say about go is this sucks this is awesome but there's kind of a lie that you're being told right here okay first off you have some options here right you have some real options here obviously writing go in a javascript file doesn't you know it doesn't count but just deal with it okay you could do something like this but which one errored remember anytime there's an await an error can be thrown you don't know you just simply don't know so that means if you wanted to create the equivalent behavior from go to java script what you would have to do is something like this this would be the equivalent it gets even worse though because if you had a value come out of fu and bar right if you had value air uh uh fu val uh right here oh no no wait go does not go does not do that if you had these two things right here right bar value and fu air right and then i could do something like this return uh oh gosh i have these things backwards just deal with it just deal with it let's just say we had something like this to make the same thing happen in this you would actually have to do it a bit different right if you had to do some sort of special error handling right uh some special error handling right whatever that special air handling is it doesn't really matter what it is we'd have to do the same special air handling same special air handling i don't know return uh return null right we'd have to return null in both these situations not only that we'd have to have let fu val be right here which means that we're going to have to have some sort of type number or null right because now you have to have like null or you'd have to do undefined right you'd have to do some sort of definition going on here fu val equals this you'd have to define it on the outside and then make it go on the inside you're going to have to do the exact same thing right here right it's like that's kind of annoying right that's kind of annoying i don't want to have to do that equals this and then you can return fu plus bar val but here's the worst part is now what does your return statement look like well your return statement is promise or null right it like changes the signature these errors not only have huge change in how your flow of code works it also has a huge change in what your signature is going to due to like the return value so now your outside when calling it also has to perform the exact same thing it not only has to do a try catch for potential errors thrown just in case there's an error thrown because they don't know if you handle every error and maybe you don't handle every single error but on top of it they also have to handle like this null case that you might have to handle right so now it went from a two-state problem to a three-state problem and down here in the goand it's not cuz what would what would the function look like the function well based on whatever this is its return value looks something like error number right or int right and so it's going to have the same it it has the exact same like experience no matter what and so you go into the situation without all that it's like i'm just saying when people say go air handling is bad you got to understand the difference what are you comparing it to there's a reason why javascript services tend to have extremely low n reliability right they're not coming in with 59 they're just not because you have to have an intense amount of air handling everywhere and nobody does that nobody does that every time you json every time you json parse you need to handle a potential error so many people just raw dog jon pars i'm just saying when people say go air handling sucks i simply disagree i say it just forces you to think about errors when errors can happen javascript they just hide the errors error is not going to happen you don't worry you know the worst part about this whole thing is that at some point you have something like this process. un unhandled rejection right you get some sort of top level error catcher and you have to recover from that you have to reset some state somewhere what i mean good luck that's difficult anyways these are just some thoughts i have about air handling in this because i hear this all the time like do i like doing this i don't like doing this i think it's tedious and i think it's annoying i think rust does a much better job with the result object i think the monatic approach of results and being able to morph them an and then being able to do a okay filter map and all the different combinations you can do is absolutely fantastic but at the end of the day this annoyingness right here is just significantly better than whatever this annoyingness looks like it is very very very difficult to correctly program javascript so that you handle all err conditions anyways there you go just my thoughts js errors are very difficult it's very tedious the problem is i just don't want you to fall into this habit of thinking that some other language is bad because it immediately looks worse on the outside i will tell you by that at the end of the day you will find contributing to go easier and more reliable because it lets you know ahead of time ah i got some errors i need to handle i'll take care of these errors annoying but man wow there's a lot of errors i didn't realize how often code that i write can error this seems kind of wild i don't remember my code ever ering that much with javascript oh it does it's no different it's identical you just don't know you're dead like that's the only difference all right the name is i still write typescript all the time i'm not saying don't write it i i'm just saying i i don't love it i recognize its weaknesses okay and you should recognize the weaknesses too and then you can continue to program it but i don't want you to be someone that's just simply ignorant or say stupid things like if air equals nil is just the worst is it the worst is it the worst i don't know i don't know i don't know a jet