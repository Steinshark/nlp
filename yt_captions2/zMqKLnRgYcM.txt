oxidizing o camel rust style ownership in o camel which is i mean this is for anyone that doesn't know o camel and rust share a lot of similarities oam is a lot more functional but has concessions for rust or for uh imperative style programming whereas rust is probably i'd argue as more imperative with a lot of concessions for functional programming so you kind of get that feels fair i i feel like rust is probably a little bit nicer just to look at if you're not used to the functional style whereas you can go pretty for o camel and that's fine and so o camel's also garbage collected meaning that you don't have to think about all the crap you do with rust you want just something that floats around for a while bam everyone has a reference day is over it's fantastic no problem you want a pattern match and return the thing from the pattern match you don't have to write do clone do two stir dot and stir dot and then put the lifetime you just like return the string from the first string you know you just like move them out of there no problem writing performance rust is truly a difficult feat because you you really have to be able to stop cloning things yeah it's just you know but then like you hate not cloning a lot of the time you're like holy cow i just need to add a lifetime in 95 different places now all right we're this one property is slowing down our system let's add a single lifetime oh wait it's actually 95 that's going to be four weeks it's like the let just add a button you know like the for us the just add a button is just at a [laughter] lifetime all right anyways okay so o camell if you don't know jane street has largely been the champion of uh developing o camel into a modern era is that fair to say they do um yeah i mean there's some other people doing really interesting stuff but jam street has been pushing i would say a lot as well in sort of like the exploratory aspects of the language so they have like unboxed types and now they're sort of like oxidizing and some other stuff like that which i think will but we read in the circle i think like these these ideas are going to super click with you after writing rust but then the the thing you have to remember in the article is it's only showing you the places where you have to care about doing this most of the time you just don't do this and you just write normal regular code with garbage collection and you like can actually ship your product i like that all right oak camel isn't a peer language in fact what i mean perer functional do they mean that uh in fact noer in terms of like you have to account for side effects and things like that right or like there exists mutability okay so in other words unlike hasell your final product isn't a white paper right exactly like it runs and maybe like someone makes money off of it i know that that's kind of frowned upon in the haso community yeah it is it truly is yeah it might even be frowned upon in the russ community as well i can't tell yet uh in fact records containing mutable fields are relatively common the compiler also doesn't track the values may be referenced so uh must assume all values are potentially shared at runtime this means several parts of the program may hold pointers to any particular piece of data as much as this like that pattern sucks which can be kind of a headache which is what russ tries to solve it also is just extremely practical it just yes you know that's why go just tends to be really easy for someone to jump into all right so one thing that's cool though is like you do have to mark the field mutable in oaml so like fields are immutable by default i do like that i do like that that they they do what i think is the most important thing in any language which is read only is default mutability is the thing you specify so you you're like pre-planning for something to change and anyone can see that the type is a type that may change which is nice exactly all right shared mutable data is notoriously difficult for uh to reason about and doubly so with additional uh addition of concurrency conversely perer functions provide useful guarantees so ok encourages a side effect freestyle for example records support functional updates with preserved immutability okay so we have type a uh this means the tick a is not a lifetime in this case a tick a is the uh we don't know what type it is correct right it's basically like a type hole like you could put whatever type you want into this spot yeah it's yeah they use the term type hole generic be another way people might be pretty used to hearing it as okay uh let clear box box with x equals none uh value clear box is just like it just it just changes the box right yep yep and then like if it had other fields in this case it doesn't really have any other fields so it's not as exciting but it would like copy all the other fields into this new one so it doesn't it doesn't like update the previous one right this is like creating a new copy okay but you don't have to write all of the fields and stu it's kind of like dot dot dot style thing in javascript land except i think not as expensive yeah you go dot dot dot original object and then you would go uh the field you want to overwrite undefined that'd be the equivalent right all right unfortunately immutability comes at a cost a functional update ac allocates a new record since other code may hold references to the original code we we will illustrate the result here purple blocks are live values which become red when unre referenced before we have a record and some afterwards we have a record to none we do have a record that goes to x which is that same sum value because we've now kind of cleared out that previous value we're no longer referencing it but we still have them living in the gc right right so we had to allocate a new like record to put none inside okay yep writing to an explicitly mutable field would not incur this allocation but instead exposes us to shared mutability ultimately immutable updates only approach this problem from one dire direction we could instead imagine eliminating the shared portions of shared mutability if we knew that our code holds the only reference to the original record the functional update immediately makes the original value unreferenced available for collection and reuse therefore the runtime could equivalently perform an inplace update even though the type exposes an immutable interface oh i see what they're saying okay okay because this record is solely it effectively have a ref count of one the only thing you need to allocate a new is a new option type right here right right yep that's pretty which is really cool right because it's like well if the compiler knows that there aren't any other references right and it can't get referenced again well it can just do something way smarter like not allocate that's actually super clever that's super clever i like that one of russ primary design goals is to entirely forbid shared muil it does which is achi achieves by only allowing mutable values to be referenced uniquely in o camel uniqueness isn't a strict necessity since the garbage collector can handley cyclic lifetimes arising from unrestricted mutability however we still stand to benefit from optimizations and expressivity enabled by unique references in fact in part three of this series we'll see how uniqueness enables us to statically prohibit data races in multicore o camel oh that's pretty cool getting even the safety level of rust without rust that's pretty cool right yeah especially for like they're saying for once this whole like article series is leading up to this idea like about how do we write multicore code safely right because like anything can happen yeah right so and like how do we still do that performant without copying stuff every single time we want to do anything blah blah blah right so like we're kind of like building up the language tools that you need to be able to like solve this problem along with a whole host of other problems so that's like what's going on russ fearless concurrency is just an arc mutex yeah right but like and as we've said many times before the reason i don't have to fear concurrency in rust is because i've never been able to run it in production like i i part of me refuses to use rust with htm x because i don't want htm x to be looked at as a white paper language like got to avoid that uh all right you the uniqueness mode a variable has the unique mode when it is uh the only reference to a particular value in the entire program variables without restrictions have the default shared mode okay so standard programming get shared mode but apparently there's now a new mode you can toss on unique previously well remember like modes are not they're not like for the program they're for like particular like values basically right so they're like kind of like a type but they're not the types right so like type in the sense that if you make an update to a struct you don't have to go through everywhere to make updates i assume right yes and then the other thing is like um the type inference of oaml still works like just the same right like if this thing can take an int it like still only can take ins it doesn't matter necessarily so those are like orthogonal problems so they're going to go through it but yeah so they're saying like we have this new mode about uniqueness right is this thing unique or not unique yeah and for those that don't quite understand it you just kind of got to imagine uh promises and how they color your function blue in rust uh when you do say lifetimes it actually colors your struct in a sense you cannot define your struct without defining the lifetimes much like if you have a promise you have to kind of alter how you call that function and so there's this whole it's it's a very similar thing rust has colored structs whereas this is avoiding the colored struct problem but getting all the usability of it all right is that effectively what's happening here yeah and i think the other thing is it's kind of like the main difference i would say more is that it's focused on like it's opt in right like you only opt in to these ideas for certain parts of your program where either it gives you like some additional type safety in the sense that you want to make sure no one else can like hold this pointer to a file right like okay it's actually nice to be able to say no no you can't like leak this file pointer that's a no no you know like it needs to be safe for this to do right or that you want to do something like the example at the beginning about oh i don't want to do extra allocations yeah right so like in those two cases you would be like yeah i actually do want to opt into those for these cases but the rest of time i don't need to worry about it right which is different for us you always have to do it if there's a reference right yeah i like that i like i like the idea of optin safety or opt-in uniqueness as they're calling it right here which is actually it's pretty clever right if you don't want to ever you want to guarantee you cannot leak the file handle such that a file stay open longer than you realize well you just mark it as unique it can no longer do it and then you have safety in the one thing that needs safety whereas does your int really matter does you know like do these things really the string yeah it's it's like okay it's just a so they're going to do some examples but like that's one of the things i miss in other languages a lot from rust is that ability to like drop something by like the function signature right you're saying like no no no no one gets to touch us anymore we've closed the file i think that might even be one of the examples in this sorry pre yeah let's go yeah pre you've definitely pread i haven't yet previously we saw the compiler tracks the variables uh which variables may escape their region these were global uniqueness can be handled in a similar fashion tracking which variables may have aliases uh tells us which are shared unique variables are hence those used at most once for example given a function that takes a unique argument okay so this one takes only unique arguments uh it doesn't have the type right but it's a un unque it's only has a it's a singular reference one we no longer uh we are no longer allowed to use this function in a way that violates uniqueness uh so we can't go fu consume x return x uh x is unique uh is used uniquely so it cannot be used twice oh very cool okay i see what happens here effectively it is just like rust where you you just call a function without a reference you've effectively created non reference calling you've moved x mhm oh yeah so that's like right you're like you've written some rust and you're like oh i totally get this consume does what it says in this case right where it can take any variable that is unique and then it just says you can't use it anymore afterwards i'm not going to return it back to you or anything it's gone it's been moved i like that ok camel's uniqueness mode mirrors a similar concept in rust where values are unique by default when passed to a function by value a rust variable is moved ownership is transferred to the coli which has free range to mutate or destroy the value subm moding or subm moding a unique variable may be safely used as if it were shared so unique is a sub mode of shared this hierarchy is reversed compared to locality the non-default mode unique is the sub mode in this sense that might be you know you might have to read the previous article to understand what they're saying but i don't think you need the knowledge of the previous article to really yeah they'll they'll give you an example of how it works yep yep in this sense unique behaves like global and shared behaves like local for example we can construct a shared variable by referencing a unique value but not vice versa okay so let bar unique x then we return out two references to x is that what's happening here yeah so you yeah so like they are kind of like references but they're they're really you should just think about them as like shared so instead of being unique they're shared now so notice how like on the right side of the arrow in the tuple there's no uniqueness constraint on those two like tick a the alphas right so it's basically saying like outside of bar you have to pass me something that's unique and then bar can do whatever the heck it wants with it we don't care right and so then it's like yeah it's just going to return two new things and you don't know that that's the same from the type signature right and from like the modes but that's fine yep and so does that make x no longer unique once it goes through this function x is now so now shared right yeah just like how you could this is basically like cloning right like you could take in an x in rust and you could return x. clone x. clone or something like that right that's effectively what we're doing because we get to fall back to a garbage collector right like it doesn't it doesn't matter you don't have to write x clone you just write x because the garbage collector will still handle that in this case okay okay uniqueness uniqueness subm moding relation makes it more int intuitive to interpret a unique function parameter as promised by the caller a unique parameter means the caller promises to provide uniquely reference values the collie is hence allowed to overwrite the value a shared parameter does not encode a promise from the caller the collie must assume the parameter is alias nice okay i like that uh using the following syntax we can perform an in place update on a unique record all right we can do a unique box override box with x boom so now we get the same value back out and we're returning back out the unique reference to it okay cool so unique works on both sides of this on the right hand and the left hand or as return values okay cool so you can do unique operations that you have for return yep okay just like rust okay it may alarm you to notice that clear returns a uh a box uh does this let us cast the box in uh to a new type in place the answer is yes it's perfectly safe to do so oh yeah i didn't even notice that tick a tick b so depending on how you use it you could actually get a new type coming in here y ah that's pretty clever uh no other code maintains a reference to the box it can be referred to as a value of that stale type i actually really like this idea uh the result demonstrates the unique variables provide another important capability updating the values type in place such an operation is known as strong update and lets us write for example an inplace map function okay so we have a function that takes a uh a's unique and returns b as unique yep and then what's this thing right here and this is i read this i suck at these things okay this is the name this is argument one this is argument two right i'm still pretty weak at the old oam okay so box with x if it's none it remains none if it's sum it now translates it into f ofx which right cast it into it calls like the function f that you're passing on like the value that's inside so this is like option. map basically right except that it's saying like you don't need to allocate any new like options right you're going to overwrite the option inside of there and right like if you were chaining this through or something right like you could imagine that you're going to call like option map on something and then option on map again and option map again right or whatever right yeah then what's cool right is like the types can be changing along the way but you're not allocating like garbage for every single spot you're going to overwrite it yeah yeah because so for those that aren't familiar with javascript if you do do map on an array it creates a new array of equal size right and so that is you know whereas this this won't create a new array instead it will mutate the given thing it sounds like or mutate the given items within it to be of new type and i assume you have to do some fancy pancy on the outside to be able to do it with an array but this is just with a singular type but still but so that's like giving you the idea of like oh this lets you keep type safety but also like not generate bunch of extra stuff which is very interesting borrowing unique variables also empower users to write safer api contracts procedural resource management is obviously uh is one obvious use case uh so let's attempt or attempt to define a simple set of functions to manipulate files okay type file we have open read close all right since require let's see since close requires a unique parameter we can be sure that files are never used after being closed oh that's pretty cool yeah okay i like that okay so we have print and close it takes in a unique file print line or print end line read file then just close the file close file let's see file is uh used uniquely so cannot be used twice yep so they're going to introduce a new concept to solve this problem okay yeah because i was about to say how do you use how do you do a read file and a close file here yep i would assume that you'd have to have it like to solve it without any new constructs you'd have to have this thing to be unique and then you'd have to return out the string plus a reference to the file that's unique right that would be right so yeah you would have like a read and that would return like a tuple with a unique file and a string or something like that right you could do that similar idea yep all right even though read does not require a unique parameter we we are no longer allowing to close the file uh using a unique value at the shared mode is a one-way transformation okay perfect once we create a single shared reference uh to file we're no longer allowed to use the file uniquely this makes perfect sense this behavior seems overly restricted and just like before we go like notice how that just kind of like happens at least in my mind i haven't gotten a chance to like play with this a time it basically happens like automatically transparently yeah you don't have to think you just like you just like used it twice it's like dude you can't use it it's unique like that so either you like remove the uniqueness constraint or you figure out what you need but you don't need to go like crazy to do a bunch of extra things for it right it's like kind of happening automatic which is really cool it is nice feel very yeah it's a very simplified version of the borrow checker slow values work in rust without all the other parts this behavior seems overly restricted right we know that re itself does not use the file uniquely so if it uh so if it also doesn't leak any references to file we could keep using file uniquely after read returns fortunately we've already discussed a mode that expresses this constraint locality read file local okay print close read with an ampersand so what's going on there is do you have to do a different type of syntax okay the syntax uh reference to file denotes bar in which weakens the mode of file to local shared oh interesting the resulting reference cannot uh cannot be leaked by re so after reed returns we still only have reference or we still only have one reference to file ah because you're saying hey this is a local share and it's only locally shared within the read and the read uniquely you know can't do that it only accepts a local variable yep so that's what we did from like last art local was say you can use this of your but you can't leak it out to the global scope right so this is once again as we're going to say like the rust in rust borrowing is less restrictive as the collie is parameterized over the true lifetime of the borrowed value that's that last sentence before we get to exclusivity which is basically just saying like i thought you said that freeh handedly and i was like tj you sound extremely smart when you talk like that yeah you know no big deal you sound like an academic blog article when you speak like that in my free time you know um but like so what they're saying though right is in rust you can make unlimited numbers of lifetimes yeah right but in ok they're saying like okay okay okay but like maybe what if it's pretty much just like it's used by this function or it's not just used by this function yeah which is if you think about it and you think about all the times you've been writing rust like the vast majority of the time you're doing that you basically just want to say like i'm referencing it or i'm owning it like that's kind of you know what you want to do for a lot of situations and so in this case they're basically saying like instead of having to specify a bunch of different lifetimes you're going to say when i use ampersand file like this i move it from a unique to a local shared that has some guarantees when that function's done i know no one else can be holding a reference to file so it's still unique yep i like that's how we get to use it for close all right exclusivity let's expand our api to uh to include a right function a file represents access to mutable date and we're avoiding shared muil uh mutability so right should require a unique file okay that seems fair to me uh it takes in a file plus a string to write and returns nothing out but when we try to use this function right file data this y closed can't be used un uh twice because it's unique okay fair if we pass file uniquely it cannot be used again while we could return file from right that's what i was suggesting originally piping brain yep medium brain we'll call it semi smooth brain three wrinkles at least yeah it it solves the problem but in a nondesirable way that's pretty much that's actually how i program it soles the problem autop not desirably but he solves them all right see while we could return file from right uh from right piping unique values through every function call isn't a good solution ideally we want to express that although our function mutates file it does not consume it to better handle this case we've added a third mode to the unique uniqueness axis exclusive h uh which sits between the initial options a variable at the exclusive mode is the only active reference to a particular value interesting specifically exclusivity expresses that while the other references to this value may exist none are accessible until the conclusion of the exclusive references region therefore we may freely mutate the exclusive value but we may not use it uniquely okay bam so this one is local exclusive oh yep interesting okay and so we can use it we can mutate it and then we can close it bada bing bada boom right okay so once again right we think about like what local is local says you can't escape the function and exclusive is saying i'm the only one with this reference so it's like it's like kind of like mute a mute reference in rust because in when you have a mute reference you're saying i'm the only one that can have this mute reference right but it's a little bit you know like excl that's basically what exclusive is right cuz you think about like the way you have in rust you have the owned value and you have a reference and you can have like only one person has the owned value as many people as you want can have the reference but only one person can have a mutable reference at a time that's like basically the same idea here does that make sense it makes sense um yeah yeah i i i i like all the things we're saying uh because the call to write borrows file by the way i we're becoming dangerously close to an educational channel right now i want i want you to know that this is we joked enough at the beginning so i think it's safe we tricked all the people who are looking for education we got them out you yeah okay i'm very worried about it because the call to write borrows file exactly once file uh has a mode local exclusive if the file was borrowed multiple times its mode would instead be weakened to local shared so we can do this okay so write takes a local uh exclusive and it takes a local exclusive file again and produces a string to the unit so we do it twice f this is just an example to show like you can't borrow this twice basically two you have two it's allowing two references you can write two files at the same time effectively saying found a shared value where an exclusive value was expected yes because it's now being used twice okay y i wonder how much this is going to slow down the compiler i guess not too much because it's it doesn't have to do it for every variable for all time it only has to do it for a very small subset thus you get 99% normal compile times with the 1% slower on just this particular small piece yeah my guess is since jane street is like actively using this and they have like unlimited amounts of o camel code they're going to make it go zoom zoom like i don't think they would sacrifice a bunch of like o camel's really fast compilation speeds just so that they can do some of these things yeah but but if you think about it let's say it's 10 times slower to compile because it has to do all this fancy footwork it's still one variable that it does in like three locations ver 10,000 variables elsewhere so it's like does it really matter well most of the time it just is like you're you're global shared go go go go go and then all this one it's just like oh hold on let's be a little bit more specific right here i love i love and they they are working on my understanding is like like inferring these for where like it's possible for you to know at least for like the locality so that you can do less allocations so like there is like i mean if you can just apply less gc pressure and also use less memory and also have things just run faster with exactly the same code that is a big win you just go from stack it's it's literally like a magnitude it's a magnitude win all right awesome uh this exclusive mode is not just useful for resource management it also expresses that a function may mutate a record but never strongly updates it uh give an exclusive variable we know our code has the only active reference value uh to the value but later the uh but later code may inspect it at the current type therefore uh we also introduced exclusive mutable fields okay so this is mutable only when it's exclusively held yes an exclusive mutable field behaves oh that's also really good because it guarantees that way you can have mutability and guaranteed singular reference right effectively or singular update which allow fearless concurrency yeah fearless it's going to look like right it's going to look like it's immutable all the other time which is nice like you know you're basically saying like most of the time this is immutable right and then occasionally we're going to have something that like actually owns this thing is able to change it like cool that makes sense yeah safe mutability an exclusive mutable field behaves as you might expect it may be written to via an exclusive reference but appears immutable when accessed via a shared reference beautiful with exclusively mutable fields we can enjoy the performance benefits of mutability without the strict move semantics of uniqueness okay so we have a lo local exclusive counter bam bam bam look at how that looks just like beautiful right making individual fields as exclusive mutable is a natural extension of o camel's current mutability story but notably diverges from rust's approach in rust variable bindings are marked as mutable upon declaration that is mutability becomes another deep property perhaps a mode despite this this difference ok camel's uniqueness mode access now mirrors russ hierarchy of references i don't quite i think i understand what it's trying to say but let's see what it says so like well just to be like in rust you say like let mute x equals this thing right like in o you say like this type this field has mutability or not okay right so like that's that that's different in terms of like when you mark mutability okay a unique variable is akin to a value and rust uh passing a parameter by value allows the collie to destroy yes this makes sense which means ultimately you can get very close to being able to infer i assume stack operations at this point is kind of where this is all going to many things that can go zoom zoom after they figure these out yep an exclusive variable is akin to a mutable reference in rust passing a parameter by mutable reference allows the colly to overwrite but not destroy the value yeah a shared variable is akin to an immutable reference in rust passing a parameter by immutable reference restricts the coli to reading or copying the value perfect there's a there is one important difference o camel's references are not parameterized over lifetime variables like we saw in part one this means uniqueness does not lead to higher order polymorphism and doesn't interfere with type inference all of that to say you don't have to go everywhere and just denote lifetimes crazily is that exactly is that fancy for i don't need the update 90 places to make this individual thing local yep that's like one side and the other side is that like all the type in prints that worked before in oam like still works with the solution you don't have to write the type parameters for like every single function and every single return but we still like okl has types like for people who don't know and maybe you're not familiar like everything is type safe yeah like with a real type system so that's so that's like the two sides of it yep all right so far we've uh seen how uniqueness and locality access interact to represent ownership unfortunately we uh we unfortunately we can now write the following code oh unfortunately okay we have type uh it's a box as an option a right we don't know the type right rap unique box is a function to a box okay so we make a unique function that returns the box let unsound unique box get wra box in a equals hold on hold on hold on okay so this is okay this is the function that returns box yep a is the value from that box b is the same value so we went from a unique one and now we have shared ones overwrite a with x equals z overwrite b with some string okay i see what happens here you have two references and now you're actually trying to overwrite in place effectively yeah and that's real not good when one's an integer and one's a string that's a no no that's typescript land you know yeah we don't dop stuff here we don't want to do that here we don't do that here i do take advantage of any quite a bit when i have to it can be it can be very nice just throw that out there yeah typescript isn't doesn't have polymorphism it has craz ism you can just just make it anything uh naively app applying a get simply returns the wrapped box box but that means invoking get twice creates two supposedly unique references to the same box violating uniqueness breaks type safety as we can uh can use strong updates to refer to the same value at multiple types okay so is it therefore we must not allow r to return a closure with a signature unit to tick a box unique we know the resulting function may uh may be executed once but it is unsafe to invoke it a second time more generally any closure capturing a unique value must be ran at most once okay so this is probably where uh fn once comes from in rust look at this guy preat preat put it in the chat right now free watch did i get it tell me i got fn1 you got it you got it nice yeah you did all right to encode this restriction we pre-at let's go we will define a third mode access linear linear l linearity there we go i got it i got it jackal down confirmed he didn't preat jack no it turns out he's too stupid to actually pre-at this in practice linearity mode uh modes will almost exclusively apply to a variable of a function type closures but this is not a requirement variable with modes once carries a restriction of being used at most once this allows to close over a unique and once variables a variable with default mode many does not have the restrictions it may be used freely and may close over shared sl many variables a many variable can be used if it were once uh so many is a sub mode of once like locality the salient mode once okay i i'm not i honestly don't know what salient means it's like the thing in your mouth noticeable or important okay this the most notable or important mode once is the super mode the parameter perspective once represents a promise by the colleag okay so this is a lot of words and i think it's very hard to see i've always been very bad at understanding abstraction first and then or principle to uh action i'm much better at understanding action to the principle yeah they should have showed this code first and then did the long explanation because you'll see the error and be like oh this makes sense it says you can only use it once that's why i could say oh we need a once i can say it right here by just to look at it and then they explain a once and i'm like i don't know what i'm even i don't know what this says i know what you're trying to do but i don't know what you're trying to say all right right let baz once xx okay you can't do this hey that's kind of cool that's yeah i'm not sure how i feel about it but it's neat i'll say that right so it's just in general you won't use this very often for non- like function things and you probably won't have to do it for functions either because it's going to be inferred just like a bunch of these other things right but it's like it's just saying you can only use this value once it's actually pretty dope to be able to say you can only use a value once um yeah you would i i could think of very few places you' ever want to do this and so maybe it makes sense once you start doing it you can go oh okay this makes sense yep in some sense line linearity linearity is the dual to the uniqueness access both uh analysises analysis analysis are connected with uh aliasing a once variable prohibits the creation of new references to its value whereas unique variable states that no such reference exists okay interesting consuming variables returning to our unsound example rap now returns a closure at mode once when we try to invoke the result twice the compiler raises an error right okay once you found a once value that was uh where a many value was expected cool that's actually super cool so it truly does prevent this silly situation yep i'm curious how this all goes in practice because it seems nice like talking about all this but i wonder y what levels of complication does this introduce at the performance layer obviously just o camel you'd never have to think about this blah blah but when you want to do the performance layer is this going to be harder or easier than rust it appears to be easier oh i see yeah but like when it comes to it is it going to be harder to practically use so from talking to some people about it my general like perspective on this is that you probably like you'll still be able to write faster code in rust right like i think that that's like oh yeah there's a gc involved rust should forever be faster yep but the like the thing that this gives you is that when you find those hot paths in your code right then you don't have to write a whole new stack to solve the problem yes right or even like you don't even have to do like ffi right like okay so you're writing python and then you need something to go faster like well i'm gonna write c now like well that kind of sucks right like i i was just writing python i chose python for convenience and now i'm somehow writing c happened with my life oh i think we need to do like a you know the grw meme where he's like pointing at the plan all four spots you know and it's like pick python for convenience like use c you know and then likey convience writing c to make it faster writing c for convenience that's a good tweet yeah that is i'm gonna send that once we're done okay deal but like but like that's the difference right is that now you can you don't have to go to that other language to get the solve you get to solve it still in the language you were writing everything else in yeah which is which is great um and i make the same arum with go sorry to interrupt i make the same argument with go which is rust is the 100% performance case just like uh c is the 100% performance case zig is c++ but go is like the 98 performance case right it's like it's almost there is 98% performance good like javascript's like you know the 65% performance case you're really cho convenience over performance and it's easy to make it the 15% performance very easy to make it the 15 it's it's actually yeah you could make 10x faster code in other languages so yeah or even more than that but it's kind of interesting to see all this because you're like okay you can make it faster like it seems like o camel has the chance to be even faster than go like you can make it the 995 case where it's like yeah there's very little value that you can squeeze out using rust c c++ zig right at this point because it covers the most case yeah and the other thing too right is that like a lot of these features like they have a performance win i mean i'm more excited about some of them for like the expressivity like aspects like we did for the the file descriptors one like it's nice to be able to encode that and just like you don't have to rely on docs to like tell somebody not to make a copy of this or like not to try and write to anything after you call closeth or you know like it's just nice to be able to have the compiler say um hey you said you're not going to leak this and then you did like i like that you know i want the compiler to tell that to me so there is some there's like a lot of it that i'm excited for for like performance stuff that's great but like for locality and for like borrowing and stuff i'm like pretty excited as well about the like type level stuff that you can do which is cool yeah that's actually a really good description which is performance i mean at the end of the day people don't choose javascript for performance they choose it because they have stockholm syndrome and so if you want something faster you can pretty much choose any language like java go rust i mean there's zig i mean there's so many available languages at this point and so now o camel's really contending to be a good one i like this i i do want aun functional arc in my life just to really say that i've done the functional thing is it actually practical or is it no one can call you a script kitty anymore i'm still a script kitty though i only know rust which is like a clearly script kitty language uh but but real talk like i i keep going back and forth which is is a functional programming language actually practical or is it is i mean how much and it really goes with russ too which is how much of this type intensity is it actually practical can you produce real software with it or is it really high thought and it made look nice like the final product is like a couple lines and they're so smooth and nice but like the boilerplate hell that lives behind those few lines you're just like it's hard yeah so i that's what i'm exploring as well i'm having fun with it so okay that part's good so far and i'm making progress too so that's yeah you're actually building something you're you might actually release a product in o camel yeah and it'll be for this stream managing react content haskal the haskers are in shambles right now hearing about this white papers are being derived as we speak about tj potentially writing software products considered harmful like oh my goodness so far we've conspicuously omitted closures that capture exclusive references uh really for me it was inconspicuous cuz my brain hasn't even gone there when a cl your borrows a variable it cannot it's not like oh yeah i saw this one coming it cannot use the value uniquely so the resulting function is safe to run multiple times that is it needn't be once however borrows still come with restrictions borrowing always creates local references so a closure that borrows a variable must itself be local okay i i think that makes sense so we have a we have a box that is exclusively mutable in this position that's always of the same type so no type mutations allowed here at any point or at least at least this one is a typ hole so yeah it produces a okay never mind there's you don't do type holes at this point you do it at the function level right all right rap takes a box in clears it out throws a none into it and then returns out the function clear right yep right exactly yep clear this value escapes its region that makes sense i think that makes sense because you have a closure that has a that has this and you have to denote something in here right you have to right well basically it's like if you passed in an owned value into rust and you return a function that references it rust is going to yell at you just like it's saying yes yo you can't do that you you have to like fix this you can't just pass call backs around like that yeah which this makes sense if you're starting if you're going into the land of performance i assume unique is also in the land this is more of a performance consideration than anything else yes or it's like yeah well it's also like the file descriptor one where you're going to say like yeah you can but i don't think this one's when you're doing this this is because you're trying to do something that's fast right you're not right that's because want to update memory in place right yes mh all right so in russ closures that borrow values uh exhibit similar behavior the functions lifetime cannot exceed that of the reference value however we know that clear can never outlive box because box is global we must instead move box into the closure and allow clear to escape to do so we add explicit global annotation okay so box is unique we own box we can send this out but this still has i wonder what the type signature is right which is it takes let's see wrap returns out or it takes in a box and it returns out unit that returns or a unit that takes in a unit that returns up so it's a function that like has unit as its parameter and it also returns unit so like you call clear and it just empties the box oh i see i see i see yes yes yes of course i sorry i thought it was returning this but i realized no it's not returning it okay takes in nothing gives out nothing and this at separate i don't know that one ownership is transferred to the closure so box may not be used outside of clear correct in rust this behavior can be requested or requested by adding the move keyword in a closure okay so this is a move effect it's nearish a move yes keyword right except like it's going to kind of move it right because we don't have all these intermediate lifetimes it's basically just moving it from local to global yeah right and so it says hey garbage collector you're going to handle this later for me which is nice right yeah garbage this is now a garbage collected variable i don't like box leak it you know and just let it exist forever i just let it go until the garbage collector is ready to it's that intermediate state which is the one that when you want box leak you just usually want collect it when i'm done using it and i don't know how long i'm going to be using it for it was it this last section is the most word salad one just as a heads up okay so we get pretty word sality right here this is the last one but like the the short summary is pretty much like you can't have the function call itself basically it's like re-entrance right so it's going to say like okay yo dog like you can't just let this call itself it's not clear who owns what when it's calling itself basically like most of the time you don't have to worry about this yeah yeah fair it was slightly misleading to say that closures capturing exclusive references can be run multiple times this is true but they're not re-entered intuitively when a closure stores an exclusive reference invocations must use the reference one at a time in other words they cannot overlap this makes sense so you couldn't have something that gets a reference be called multiple times producing many references to the same thing this limitation or like imagine you were going to overwrite a value and you had like a if this then that and like one of the branches overwrites it with a string and one overwrites it with an int and then like later you ref like it's not clear who owns it and what the type should be right you just say that makes sense yo dog you can't do that you that's that's separate it's just says you got to let the whole function be done before you call it again this limitation is encoded by a third mode in linear access separate the separate mode prohibits the creation of new references to a value during its execution therefore a separate closure may be invoked repetitively repeatedly but only one invocation can be active at any one point okay makes sense all right we have a separate function f uh let's see we have a let's see let separate run f f must be the parameter b it's just a function yep we invoke that function and that's that okay so now run we pass it in and we invoke and then we run with the function that runs and produces another function run let's see found a separate value where a many value is expected okay yeah so it's it's it's calling itself yep not allowed not allowed not allowed luckily most higher order functions do not require re-entrancy uh it's actually really hard like i'm surprised there it's it's it's a hard case to figure out how to do this in in my head yeah you would like it would be weird to actually have this problem if you're having you're probably doing something pretty goofy right at that point probably already have other problems we're in the emotional stage of programming luckily most higher order functions do not require reiny for example list itter does not over see doesn't overlap applications of its call back so it can take a a separate parameter oh nice okay that makes sense uh now callers are able to provide callbacks that close over exclusive values perfect b bam bam bam uh let let's see unique is this guy iter function write x okay iter function consume x uh found a once value where a separate value was expected right so like consume was the function we made before that basically like moves the value and so say you can't actually move this in a list like i don't know what to do the next time something gets called right makes sense then what is your list filled with it's filled with it's filled with voids in some sense yeah you can't we have big problems so that doesn't work okay that makes sense the separate mode has also corresponding rust trait in rust closures that capture mutable exclusive references implement or implicitly implement the function mute trait which makes invocation require a mutable reference because oaml does not rely on type bounds to encode linearity constraints type inference is again unaffected whereas russ function traits further complicate the type system i think i hear what they're saying if you've ever used function traits in rust it's a nightmare that's effec it's very confusing it's it's exceptionally difficult and it's really hard to make like to write a little function and pass it around yes yes like that captures anything like at least for me i've had really hard time which is like a shame because so much of the rest of rust you're feeling like oh i could totally like function and close over this and like pass this to an iterator and do this stuff and then it like ends up not doing that so you either just clone them all or you like have to write a big function and write a bunch of type constraints um so they're saying you can maybe still not do that right like the examples we had just above we we didn't have to do any extra stuff to say you just called consume and it just worked or it didn't work that's great yep i like that um let's see i'm 95% ready to get behind this that's good i mean i think there's a lot of things i i love i again i love that uh that the file the file one i think was the biggest win there which it just shows you can make practical constraints in your application that are impossible in effectively every language but rust right you can't make that guarantee in typescript you can't make it in go you can't make it in anything because what you end up having to do in those languages is you do a close operation you have to like close over slide the file handle and you manage the file handle and then when they call close you have to like gull it out and ensure that your program is procedurally doing the correct thing versus this is actually saying at the compiler level we'll do the correct thing without you writing the procedural aspect of it all yeah it's beautiful exactly linear types go mainstream oh pick's talking in in hll again i don't know what he's trying to say but i think i do just just more hkers it's fine okay write a white paper pick uh okay jane street's compilers team is currently implementing the uniqueness and linearity access based on the design by leo white and stefan dolan anton lorenzen summers's 2022 uh intern project produc wow that's an intern project uh produc yeah i know what a what kind of like stuff there they have so they have such cool interns yeah i don't know what kind of internships going on here but that's wild uh yeah i guess at netflix we okay netflix by the way we produced a vmf if you don't know what vmf is a vmf right uh this is visual what is it video media something fusion score where seven points is a j and d ad just noticeable difference and it's about video quality and it's all perceptive and it took like hundreds of thousands of people judging scores and then interns coming up with like an equation to do this but the intern was like a phd student doing it vf is pretty cool we also have imath which is like the same thing i honestly thought you were saying v math like m a h but just saying it goofy how like how you like to say other words so when you typed it out i was surprised oh no no this is not quick math here this is actually multimedia something fusion uh video multimedia something fusion i forget what uh what is it called so now i have to now i have to know what is it yeah pick brings up a good point one of the previous summers one of the interns like completely wrote a tcp stack in o camel the whole thing so that they could use it in in some of their other like projects just the whole tcp tcp ain't fun either um it it's just really annoying sliding window all that crap yeah it's just a lot i know it's only 20 btes for the header but it's it's it's a lot of work all right jane streets compiler team is currently oh we already did that one um let's just keep on going despite locality success one might be skeptical that uniqueness and linearity modes will provide more than minor optimizations after all oaml already supports explicit explicitly mutable fields that may be written without incurring allocations however with the release of oaml 5 mutable fields are now subject to data races if multiple domains access a field and at least one performs a right results observed by readers are unspecified absolutely though the program remains type safe fortunately the addition of exclusive mutable fields gives us the power uh gives us a powerful new tool to compat this class of concurrency bugs in part three we'll use modes to define statically uh define a statically data race free api in a multicore oaml fearless concurrency arca mutex i'd like to see how it's done without arc mutex honestly if you can do that without arc mutex man that is super cool well we'll just we'll just have to read part three later we're going to have to read part it's already out so we can read it whenever okay awesome well hopefully the o camel people liked our read through this time last time they were all pretty stoked right yeah say tell ron hello ron if you made it this far in the video hey thanks say hi ron everybody yeah everyone in chat say hi to ron everyone's just currently eyes are signals and threads say it right now it's my favorite 1400 people we can barely get a high ron out of them there we go thank you chat which is apparently delayed yeah yuron minsky he's the one who asked for this one pick oh he asked for us to read this one yeah he he said hey i liked your first one can when's part two and part three coming on so i was like yeah let's go talk to prime and make it happen i like that he's clearly way too uh smart for me he's way too smart for us i can't believe he liked our first one i'm almost a little disappointed myself that i was the that i was even on there reading it look at that dummy go red demo demo camels is like that's nice for a netflix engineer he's gonna make it there one day all right yeah hi sweet all right hey thanks o camers bye o camel oh