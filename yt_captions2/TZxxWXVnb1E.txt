the state of async rust holy cow in the middle of this picture let me i'm gonna move myself over a little bit the state of async runtime recently i found myself returning to a compelling series of blog posts titled zero cost futures in rust by aaron turon uh about what would become the rust or the foundation of russ async ecosystem in the tokyo runtime this series stands as a cornerstone in writing about rust people like aaron are the reason why i wanted to be a part of the russ community in the first place uh aaron's the guy that did the whole tokyo stuff and all that right it's pretty base pretty base guy right there well 2016 evokes nostalgic memories of excitement and fervor surrounding async rust my sentiment regarding the current state of the ecosystem are somewhat ambivalent through this series i hope to address two different audiences newcomers to async rust seeking to get an overview of the current state of the ecosystem library maintainers and contributing contributors to the async ecosystem and hope that my perspective can be a basis for discussion about the future of async rust okay the first article or in this first article we'll focus on the state of async rust runtimes their design choices and their implementations on broader rust async ecosystems one true runtime an inconvenient truth about async rust is that all that libraries still need to be written against individual runtimes writing your async code in a runtime agnostic fashion requires conditional compilation compatibility compatibility layers and handling edge cases uh yikes it's one of the problems about not having see this is one of the problems about just like having the community implement things is that yes it's good because you get you get it's faster you get to see all the different ideas come out you get to kind of see and feel out every single different way things can be done and you don't have to make bad decisions in early rust or create things that are not good stop with the golden kappas stop flexing that i don't have one but the problem then becomes this right here which is now we have a bunch of different ones what do we do now kind of sucks uh executor coupling is a big problem for async rust as it breaks the entire ecosystem into silos documentation examples for one run time don't work with other runtimes moreover moreover much of the existing documentation on async rust feels outdated or incomplete for example the async book remains in draft with concepts like futures unordered yet to be covered there is an open pull request though oh lovely uh that leaves us with this with a situation that is satisfactory for everyone involved sorry this delicious smoothie is making my mouth water i sucked that one dry we sucked them drive right there fellas that leaves us with the situation that is unsatisfactory for everyone involved for new users it is a big ass to navigate this space and to make future-proof decisions for experienced users and library maintainers supporting multiple runtimes is an additional burden the it's no surprise that popular crates like request simply insist on tokyo as a runtime uh this close coupling is an a known issue which is acknowledged by the async working group this closed coupling recognized by the async working group has me worried about its potential long-term impact on the ecosystem the case of async standard async standard was an attempt to create an alternative runtime that is closer to the rust standard library its promise was that you could almost use it as a drop in replacement for the standard library i have spent so many i i genuinely spent so long i don't know how long it was but it was long in my head trying to figure out why one of my tcp streams wasn't working whatever it's because i was using standard instead of tokyo and it was emotionally bruising and it's like it should be so simple but when you're first learning rust and all these differences and everything named the same and how you know sometimes you get those auto magic imports and all that when you're very first learning you can spend an enormous amount of time trying to figure out what's going wrong okay this was a long time ago but still i still remember it that was like my first big this really sucks moment uh take for instance the straightforward synchronous file reading code bam bam bam bam bam okay beautiful an async standard uh it is let's see it is an async operation instead okay bam bam bam bam the only difference is the away keyword function coloring people we talk about that a lot here well the name might suggest that async standard is not a drop in replacement for the standard library as there are many subtle differences between the two it is a it is hard to create a runtime that is fully compatible with the standard library here are some examples of the issue still open new threads bond okay yep there you go it is an enormous effort to replicate the standard library and it's not clear to me if it is worth it even if it were a drop in replacement i'd still ponder its actual merit rust is a language that values explicitness this is especially true for reasoning about runtime behavior such as allocations and blocking operations the standard the async standard terms are team's proposal to stop worrying about blocking was met with harsh community response and this doesn't feel very harsh i'm not going to lie to you is this why rust is filled with a bunch of babies harsh feedback i don't actually like if you really think about it when you reference the future standard of the project i really like when you check out these feel i i really do feel like we shouldn't be approaching this topic i really do think we should be concerned about it in my opinion i feel like these things man that was harsh this seems like somebody put some thought into it and thought about why we should be worried about these things as of this writing there are 1754 public crates that have dependencies on async standard and there are companies that rely on it in production however looking at the commence commits over time uh it essentially abandoned and there is no active development anymore ah this looks like grunt this leaves those reliant on async standard api bet uh be it for a concurrency mechanism extension trades or otherwise in an unfortunate situation as there is a case for library developed on top of async standards such as surf the core of async standard is now powered by small oh so small but it's probably best to use it directly for new projects again you leave the community to solve it this is what happens have you seen javascript tools grunt gulp webpack snowpack parcel vite turbo pack those are like the big ones that i know about i'm sure there's other ones just saying you leave it to the community you get sub fractured you know you kind of you have to make this choice tokyo stands as rust canonical async runtime but to label tokyo merely as a runtime would be an understatement it has extra modules for fsio net process and signal handling and more that makes it more of a framework for asynchronous program than just a runtime parsley this is because tokyo had pioneering role in the async rust it explored the design space as it went along and while you could exclusively use the runtime and ignore the rest it is easier and more common to buy into the entire ecosystem yet my main concern with tokyo is that it makes a lot of assumptions about how async code should be written and where it runs for example at the beginning of the tokyo documentation they state the easiest way to get started is to enable all features by do this by enabling the full feature flake this seems like a great getting started guide to me hey you don't know a lot about it just do that just do that what is that cargo ad tokyo features full right it's just a really simple getting started situation like i get that i'm on that team you know you don't want to explain like a bet this is one of the problems about rust in general is that they want you to know everything before you program anything and so it's just like do you want to be the person that has to know everything just to use async or do you want them to start off with maybe overkill for sure for sure you don't need all these features start overkill pare it down to me that just seems natural that's like that's how i like to learn is that i like to learn by simply you know being ignorant of everything and then slowly peeling back the layers you know what i mean damn i'm late you're not late you're not late by doing so one would set up a multi-threaded runtime which mandates the types are send and uh static and making it necessary to use synchronization primitives such as arc and mutex but for all for all but the most primitive app or trivial applications the original sin of rust async programming is to make it multi-threaded by default if premature optimizations is the root of all evil this is the mother of all premature optimizationed and it curses all your code with an unholy send plus static or worse yet send plus or send plus sync plus static which just kills all the joy of actually writing rust it was not pride it was not greed it was send plus sync plus static that truly was the original sin i think it's funny and then god cursed the earth with archview texas everywhere arc mutism arc mutasies okay usurk you pretty much now zerg rush are communities uh anytime we reach for an arc uh arc or a mutex it's a good idea to stop for a moment and think about the future implications of that decision you know every time i write an arc mutex i sit there and think to myself ah i'm watching performance go away well i guess all of my multi-threaded just is becoming shittier like that's what i think about the choice to use arc or mutex might be indicative indicative of a design that hasn't fully embraced the ownership and borrowing principle that rust emphasizes it's worth considering if the shared state is genuinely necessary or if there's an alternative design that could minimize or eliminate the need for shared mutable state this also highlights a really impressive thing about rust which is you just have to think a lot while programming you know what i mean like you have to think a lot have you ever thought about this in go what no like every now and then you gotta throw mutex around something but you really just don't you just don't think about these things which can be really nice uh and the same with javascript obviously you don't think about in javascript because well let's just face it it's javascript you don't think about it at all you know what i mean i avoid channels so they use like five locks interesting are there more efficient channels uh the problem of course is tokyo imposes this design on you it's not your choice to make beyond the complexities of architecting async code atop the synchronization synchronization mechanisms that carry a performance cost locking means runtime overhead and additional memory usage in embedded environments these mechanisms are often not available at all multi-threaded by default runtimes cause accidental complexity completely or unrelated to the task of writing async code say in general that i i dislike async rust every time i do anything beyond trivial i get a little pissed about it maybe after reading this i need to rethink my stance on async rust in general and maybe i need to just try a little bit harder to think about it in terms of like my own threads or use something like cross beam or small or whatever the other one is maybe i need to kind of bring it down a little bit and think differently about the problem yeah and then or just use gnu parallel i think gnu parallel is incredible i use it all the time whenever i can however now i have little hope that the rust community will change the course on this point tokyo's roots run deep with the ecosystem and it feels like for better or worse we're stuck with it in the realms of networking and web operations it's like it's likely that one of your dependencies integrates tokyo was actually very true runtime effectively nudging you towards its adoption tungsten knight tokyo tungstenight at the time of writing tokyo is used by 20 000 crates that's a lot other run times going beyond tokyo several other run times deserve more attention small a small asynchronous run time which is easy to understand the entire executor is around a thousand lines of code does it require like what does it i mean do all these ones somehow avoid the send sync static problem these runtimes are important as they explore alternative paths or open up new use cases for async rust drawing on a parallel with russ error handling story the hope is that competing designs will lead to a more robust foundation overall okay that'd be great especially iterating on smaller runtimes that are less invasive and single threaded by default can help improve russ async story i mean i like this idea maybe i just need to explore them all i guess i've always just been a tokyo andy does that just make me a tokyo andy is that what that does am i just a tokyo andy i just simply use tokyo for all my async needs and i really haven't tried much else i think i download a cross beam once why is he calling them runtimes because they're run times you can tell what it is you can tell it's a run time by the way it is all right regardless of the runtime choice we end up doing part of the colonel's job in user space if you allow me to play on greenspun 10th 10th rule any sufficiently advanced async rust program contains an ad hoc informally specified potentially bug written implementation of half of an operating system scheduler modern operating systems come with highly optimized schedulers that are excellent at multitasking and support async io through i o urine and splice they should make uh they should make they should make better use of these capabilities let's finally address the elephant in the room threads with their familiarity present present a path to make a synchronous code faster with minimal adjustment for example take our sync code to read a file from above and put it into a function there we go oh look at that box dying error boxdine air this is the first way i ever handled heirs was boxdine air it's also the way i hated my life you know like that's my first major program the drum machine on twitch with rust box down air everywhere we can call this a function inside of the new scopes thread okay there we go we get a little thread we get a little scope we do one of these read some contents we got another content we got another content look at all that content no join threads get joined automatically once the scope ends oh nice okay cool that's nice that code uh looks but like but i assume scope spawn are what does this mean are these what is this like are these their own threads are these operating system threads or are these some some sort of green thread i assume they're operating system level threads you don't really necessarily want to do operating system level threads right they're os threads i assume they're os threads yeah they're os threads whose lifetime is limited by the scope they're created in okay yeah i mean that's really expensive still right uh that code looks almost identical to the single threaded version notably there are no await calls okay they get fair fair uh where read contents par uh part of the public api it could be used in both async and sync callers eliminating the need for a synchronous runtimes async rust might be more memory efficient than the than threads at the cost of complexity and worse ergonomics as an example if the function were async and you called it outside of a runtime it would compile but not run futures do nothing unless being pulled correct this is a common foot gum for newcomers i have i have done this you know what the worst part is is when you try to ignore an error because you look at this right here and it's an error right so you look at the function's content as an error so you go underscore equals read this like you just want to ignore the error you don't care but what you don't realize you did is you just underscore equal the future and therefore it never runs and you have no idea that that didn't happen and it takes forever to figure out why things it's it's a painfully slow process to figure that out right in recent benchmarks async russ was 2x faster than threads but the absolute difference was only 10 milliseconds per request to put that into perspective this uh this about as long as php takes to start in other words the difference is negligible for most applications i'd really like the challenge that one because i can't imagine that's true right because i can't can you really just spawn off os threads that easily and it really only adds just a little bit of time that is that true a good php roast very eight yeah 10 milliseconds is a huge amount because you gotta remember when you have like a constellation of micro services it grows yeah i mean we just read java java said it was about two megabytes per thread php has completely different uh use case to rust this is correct 10 milliseconds is massive it is massive all right thread based frameworks uh like the now inactive iron showcase the capability of effortlessly handling tens of thousands of requests per second this is a further complemented by the fact modern linux systems can manage tens of thousands of threads tens of thousands of threads per second is is is it's kind of like is peas for rust i mean node bun on an empty request does like 80 or 90 000 or whatever on my local machine i don't know what that equals rust doing it like if i take bun create a server that just echoes back a post body for whatever you send it right create an echo and just do that i can get it you know pretty high up you know not a hundred thousand but pretty high go is like a hundred and eighty thousand uh on my this is all my machine all local testing so again grain assault uh and then rust is like 200 and some thousand so you know when i see tens of thousands i don't think oh wow right like is there a big difference stop with your golden kappas oh we already looked into a project loom all right turns out uh computers are pretty good at doing multiple things at once as an important caveat threads are not available for fee uh or feasible in all environments i'm not not by the way i'm not knocking this i just i don't have any data on whether this is worse or better i'm just curious if it is actually better or worse as an important caveat threads are not available or feasible in all environments such as embedded systems my context for this article is primarily conventional server-side applications that run on top of platforms like linux yep just linux uh i would like to add that threaded code and rust undergoes the same astringent safety checks of as the rest of the rust code okay fair it is protected from data races null dereferences and dangling references ensuring a level of thread safety that prevents many common pitfalls found in concurrent programming since there is no garbage collector there never will be any stop the world pause to reclaim memory traditional arguments against threads simply don't apply to rust fearless concurrency is your friend fearless concurrency oh we got a tweet we got a tweet people concur ansi is it antsy or ansi i always i always forget this one is it nc or antsy ansi antsy not antsy antsy fearless concurrency and ship it to production ship it ship that one ascii js is a religion so is rust so is all programming languages hello privacy what did i miss not a lot we're about to go to the last one all right let's see and if you need to share state between threads consider to use a channel i've never used much for channels i do want to use more channel stuff i feel like there's a lot of cool things you can do i really think it's cool that you can break from a loop and return a value in rust so you could have like a tokyo select in a loop receiving values waiting for something to happen from multiple different sources and then when you get the thing you need you can return it via a break out of the expression i always thought that was pretty kind of clever you know i always thought that was pretty dang clever and i just don't i don't think about that enough you know what i mean uh my original intention was to have uh to advise a newcomers to sidestep async arrest for giving the ecosystem time to mature however since i realized that this is not feasible given that a lot of libraries are async first and new users will encounter async rust one way or another and cry an acrust truly truly cry in async rust instead i would recommend to use async rust only when you really need it just learn how to write a good synchronous rust first and then if necessary transition to asynchrust learn to walk before you run fair fair if you have used asynchrust stick to tokyo a well-established libraries like request and squeal x in your own code try to avoid async only public apis to make downstream usage easier oh this these are actually all really good pieces of advice this is actually a great advice right here however it's valuable to know that there are alternatives to tokyo and that they are worth exploring one hard part though is that if you have a thread running and it blocks because it hits a sync api that you don't realize is sync for a long time you can get some goofy results in tokyo right like some things can happen that you may not be expecting and it can be uh it can slow your program down a whole bunch it can block things uh it's not necessarily as straightforward as as just simply go you know uh however it's valuable to know that there are alternatives okay yep at its core rust and its standard library offers just the absolute essentials for async await the bulk of the work is done and creates developed by the rust community we should make more use of the ability to iterate on async rust and experiment with different designs before we settle on a final solution in binary crates think twice if you really need to use async uh to use async it's probably easier to just spawn a thread and get away with blocking i o in that case you have a cpm a cpu bound workload you can use rayon to paralyze your code rayon is pretty good uh i've i've played around with it if you don't need async for performance reasons threads can often be simpler alternative fair it's fair really just threads and channels i think i just need to use just use those more but i will say that the go go supporting syntax for channels and how channels work is massively easier the fact that you have to have a single read and multiple rights and you got to clone things around and all that i feel just like it makes it harder you know isolate async code if async is truly indispensable consider isolating your async code from the rest of your application i never know how to do this it leaks it's very very leaky keep your domain logic synchronous and only use async uh for i o and external services following the guidelines will make your code more composable okay okay okay okay and accessible and on top of that the error messages of synchross are much easier to reason about facts facts upon facts fax that in the machine async rust feels like a different dialect significantly more brittle than the rest of the language i still don't know what pin is uh the default mode of right for writing rust should be synchronous freely after a stress rep inside rust there are uh there is a smaller simpler language that is waiting to get out straw strap uh br is this bjorn bjorn made a little uh a little little post it is a language that most rust codes should be written in i actually really like this this was really great it definitely makes think more because i just reach for async rust first i i reach for async rust first and i don't necessarily consider its implications you know what i mean i just grab it and i'm so it's almost second nature exactly like when i start a project i i it was a very balanced article this was a very this was a tremendous one hey cora corrode appreciated this this was this was this was a beautiful article um async rust is really difficult and really bizarre and i think i reach for it and i'm just so used to it and i program a certain way to it that i think often i forget maybe there's other ways and maybe i should not reach right away for async rust maybe i need to just try spawn in some threads and start using channels i'm gonna try that next time honestly i'm gonna try that next time next time i do anything i'm just gonna try to do uh uh i'm interested try spawning and tossing out something different i feel like i'm pretty good at rust i'm okay at async russ pretty good at rust i don't know the deeper size right i call myself a level one developer meaning that like i wouldn't be able to effectively write tokyo well right i don't know async rust down to its core and how it's actually done i just know how to use it i'm level one deep i know how to use everything i don't know how it works at a deeper level whereas like something like typescript i know at like a level two i could write pretty much any library out there i feel completely confident in it i don't think i have a lot of i don't think i have a lot of problems with it um go i'm like a 0.5 developer i think i could be better i just haven't done a lot i just haven't done enough production level go you know what i mean i just haven't done that yeah i feel like i can do lifetimes i don't feel like i'd have a hard time writing like a really performance based library with no copying in all lifetimes i just don't because i just clone you know what i mean i just i just clone because i don't care i don't care for most the times most of the times i'm just trying to get the thing correct and make sure i like what i see because rust is one of these languages that it requires a different feel to really be good at it's different than other languages like generally when i'm programming go or javascript i can kind of just i can mostly just kind of do the thing but rust you kind of got to take a slightly different approach to it's just i don't fully have the right everything first try with rust yet i think i just need to do it a little bit more you know i gotta get there it's a take a step back language but i don't i don't believe in take a step back languages i really think that that's just experience i don't like the idea of taking a step back either i really i think that it's you should just be able to free write ejaculate code at high speed and get somewhere that means you've learned a language sufficiently and i'm mostly there with rust i can mostly just rage program rust but i'm not quite there huh whiteboard masturbation first so i never do whiteboard masturbation i'm not a big fan of whiteboard masturbation i don't like to i don't i don't generally i think it's uh i think it's i think that the more you plan out a program besides for the high bits i think often you don't get anything out of it you've just wasted time zig i'm definitely not good at zig zig i'm like point one oh camel i'm like point one you know i just need an excuse to say masturbation okay fair anyways uh let's go marker uh i need to come up with a better name of uh of this title what should i call this this thing because the state of async rust run times is actually really misleading to what this article is about dr watson ejaculates 11 times in the sherlock home stories that's the strangest top fact i've ever heard the name is the think twice a gen