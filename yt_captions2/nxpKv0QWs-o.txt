if you've ever programmed anything in c or c plus plus you know that it's very easy to make mistakes and leave behind bugs in your code languages like c give programmers precise control over their code but with great power comes great responsibility languages that give the programmer such granular low level control are known historically for allowing them to make catastrophic mistakes which can leave their code full of memory corruption vulnerabilities and memory leaks c is now 50 years old but unfortunately still a pivotal part of every major operating system linux for example is the world's most widely used operating system may be seconded by windows and is written entirely in c now given that this year is the 50th anniversary of the appearance of c i've decided to learn a new safer language that is taking the world by storm rust rust is a programming language written by mozilla that puts an emphasis on the two factors transparent performance to the user and most importantly memory safety unlike c rust is designed to ensure that memory accesses are quote unquote safe in today's video i'll be starting my adventure of learning rust and eventually we'll take a rust to the raspberry pi and the raspberry pi pico so hit subscribe to follow along with us also hit that like button and leave a comment about what platform we should try rust on next now to get started in rust we have to do something pretty simple which is to install the rust compiler that is done by running sudo apt install rust c i already have this done so i don't have to but you do it will take a few minutes to install it actually installs the entire llvm back end as well as the rust runtime environment as a library it takes a little bit of time but once you let that run you should be able to run rust c and it'll output some file for you when you give it uh rust code to compile so over here we're going to write our hello world this will literally be three or four lines of rust it's actually fairly simple it feels like c as you're typing it but it reads like python it's actually very very nice so similar to c every rust program starts with a function main and is opened and closed by braces similar to the c syntax if main had arguments which will in the future for us they would actually go here and we'll do our hello world pretty simply right where we type uh print ln exclamation point the exclamation point here makes it a macro right so print line is not actually a function in rust it's just a macro and to this macro we can provide the arguments we want to print we'll say hello world exclamation point and a semicolon and then we'll type return and we'll be good to go from here we can type russc on main dot rs it'll produce our binary main that we can just run and it works a few points i want to make about the rust binary before we actually get moving on to other functionality in the rush programming language notice that the binary is actually pretty huge to do a basic hello world we actually get up to about 10 megabytes in that binary the reason for that is that the rust runtime environment actually gets cooked into this binary so in here we actually have an entire thread safe memory safe runtime environment that is completely portable to any system as long as lid p thread is there notice that there are no lib rust or lib big library that get baked into here that are a requirement everything we need goes right into main that's pretty cool um yeah and also notice that we can just dot slash the program and it runs as if it were a flat c program gets up pretty quickly okay so that's pretty awesome you may be looking at this and be thinking why does this matter why do i care about this new language well there's actually a pretty big dynamic that goes on in rust that other languages do not have so we'll do something like this we'll say let x which is a u32 equal four okay and i'm going to compile this and it's going to get mad at me because i'm not going to use that variable but it will actually run still and there will be no issues right a big part of rust is that if i were to access rust and say hello world and i'm going to say comma x and this is four here pretty important right good this works uh in access to x every time we do any kind of memory access it's reading into our memory access to make sure that we're only accessing a u32 type in rust what's different than this as compared to c is that nc a valid access that we actually could do is we could say the address of x offset by one or by four or you know we can keep going this is an illegal memory access that would read us into uninitialized or even like unallocated memory that could crash the program but here in rust i can't do an access like this now the one big thing about rust that c does not have is this idea of safe and unsafe code here in this code by default we are in a safe operating mode i couldn't do that access into x because the code is thought to be safe there is a mode in rust called unsafe where basically the rust runtime and the rust compiler put on its blinders and let you do whatever you want to do in that code things that you can do in an unsafe mode that you cannot do in the rest of rust are things like dereferencing a pointer breaking pointer allotation rules producing invalid types things like that so here's a little example program i want to have and just kind of prove to you that there is a possibility that russ code can have bugs you can crash rust it just you need to explicitly write out the code that does that in an unsafe mode so here you have the function made i create a variable called address that is a number one two three four five and it points to an undefined size this is totally normal rust no one cares about this this is not unsafe then i say hey take that that number address and call it r1 and treat it as a pointer to an integer 32 and it's a constant pointer okay then what we do is we do something that we're not allowed to do in safe rust and it dereferenced that pointer in r1 here is a line that basically the rust compiler and the rust runtime are saying i'm just going to close my eyes and let you do what you want go ahead and have at it and here we dereference this pointer this pointer is a bad allocation there's no memory here and this will actually crash the program so we'll do rust c unsafe.rs and notice that the compiler actually makes no warning that you've used unsafe it doesn't even let you know like hey man you know you're using unsafe right it just lets you go ahead and do it and if we run this program we actually get a cord dump segfulting on the lookup at address one two three four five so that's kind of the big difference here between c and rust and that rust is constantly operating in this checking your access to make sure you're not crazy mode whereas it does give you the opportunity to do an unsafe access to addresses you maybe shouldn't even have to touch and as we progress in this video series all of the accesses that we do into peripherals on a chip for example like if i want to access the peripheral bus on an arm cortex you know m3 i have to eventually go out and touch completely by hand this address and then i'll do it in an unsafe way what you're allowed to do then is make these peripheral accesses happen in unsafe ways and then wrap them in safe functions so that the only time the code is unsafe is during the memory access so that's pretty interesting um all that being said rust is a fairly powerful and robust programming language that i'm really excited to learn more about it reads and feels just like python and c put together with a little different syntax in the variable assignment um we'll continue in this series about doing basic things like arrays memory accesses how to do structures classes and all that stuff and then push the limits on it and bring it eventually that we're running rust bare metal on an arm environment and use that to kind of figure out how to use the unsafe safely um guys if you enjoyed this video do me a favor hit like hit subscribe we'll see you next time when we dive deep on rust on an embedded platform i'll see you guys then take care [music] you