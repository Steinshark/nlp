semantic versioning isn't just the practice it's the backbone and foundation of stable and reliable software products which is why i'm going to cover semantic versioning in this video today but before we get into that i also have a discord server where topics like this are regularly discussed it has over 10,000 members there lots of knowledgeable people there you can join for free read the link in description semantic versioning or sver in short is a system for versioning software and standardizing how the version reflects the change of the underlying code there's two areas that i'm going to cover in this video first i'm going to talk about the building blocks of samver and the precedents of versions but in between i'm going to share three tips about semantic versioning that are really good to know but that are not explicitly in the samver specification so be sure to stick around so you don't miss those the basic structure of sver is in a format of x.y z where each letter is a non negative number called a version whenever you do an update you're going to increment one of these numbers by one meaning that we go from 1 to two to three etc and not directly jump from one to five or six or something like that also sometimes these numbers may be reset to zero x is called the major version y is called the minor version and z is called the patch each version type whether that's major minor or patch comes with implications and should only be used for certain types of changes and here's also the first tip best practice when you start a project with semantic versioning is that you start with major version zero now let's talk a bit about the difference between major minor and patch versions a patch version must be incremented if only backward compatible bu fixes are introduced for example you update a function so that it doesn't crash in a certain edge case well in that case you release a new version and for example going from 1.5.6 to 1.5.7 a minor version must be incremented if a new but still backward compatible functionality is introduced to a public api for example you add another endpoint to your api without affecting the other endpoints in that case you go from let's say 1.5.3 to 1.6 a major version must be incremented if there is backwards compatible changes that are introduced to the public api for example you change the names of access points or you remove features or you totally rework the concepts and how you are supposed to use your software in that case you will go from 1.5.3 to 2.0.0 important thing to note here is if we do a minor version update we need to reset patch to zero so 1.5.3 becomes 1.6.0 and if we do an increment of the major version then we need to reset both patch and minor to zero going from 1.5.3 to 2.0. z then another aspect of semantic versioning is precedence this refers to how versions are compared to each other when they are ordered the ordering is determined from left to right meaning that the higher the number on the left the later the version is for example 3.0.0 is a higher version than 2.1.0 is higher than 1.0.1 which is more than 1.0.0 and here's the second tip version 1.0.0 should be the first version to be production ready in some cases you might want to add an extra identifier for example pre-release or beta identifiers like pre-release or beta are always added to the end of the version with a dash separator for example 3.1.4 das pre-release in terms of precedence a version with the identifier is considered an earlier version than a version without the identifier so 3.1.4 is a later version and 3.1.4 pre-release and you can even take this further by adding more and more identifiers like 0.1.5 alpha. november. delta. eo. romeo. shar etc but of course nobody in the right mind should ever go this far down with identifiers which actually leads to the third tip which is that you should use a maximum of two identifiers for your versions to like not let everybody go insane when looking at the versions of your software so this was just just a really short introduction to semantic versioning and as the authors of sam verse say it's not really a new or revolutionary idea however that doesn't take away the importance of it there are also some tools that help you with setting the version using sare like poetry but at the end of the day as a developer you need to decide what an appropriate version update is if you haven't used semantic versioning before in your projects it's super easy to get started just write in your read me file that your project follows semantic versioning and then start doing it question for you though do you use semantic versioning or do you use something else let me know in the comments now using semantic versioning is just one step of building and publishing python packages if you want to learn more about that watch this video next thanks for watching and see you next time