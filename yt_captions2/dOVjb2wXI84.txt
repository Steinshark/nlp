this is the esp32 development board by espressif the esp32 is a quick 10 us dollar way of wi-fi enabling any project you have in this video i'll show you guys how to set up the esp idf or iot development framework and use it to get an led blinking on the board okay so to get started you're going to google esp idf that's the iot development framework it should bring you to this github repo this has a bunch of examples and the build chain and pretty much everything you need to set up your esp32 you're going to copy this link in your command line you're going to get clone tactec recursive that directory what the tactic recursive does is if there are any sub-modules in this repository which means a sub-module is another git repo inside of a git repo this repo has a bunch of those so it'll go into every sub-repo recursively and clone those in as well so you want to do that there is a lot of stuff here so this will take a second for you guys to to get through but we'll let this run then we'll come back okay great so for me that took about three minutes i hope it took not that long for you but now that we have that here we can go into the esp-idf folder and lsa directory a bunch of files should be here we don't really care about a lot of these right now but the big one we want to run is install.sh so install.sh will actually go through it'll install all of the required apps repositories all of the required pip repositories and everything we need and set up our environment so that we are able to run idf.pi which is the the framework itself so let's run this cool so this didn't take very long for me because i already ran this before i started this video it may take about 10 or so minutes for you because it has to go through and pip and install all these repositories um but once this has ran now we have this export.sh file so what this export.sage file is it'll export environment variables that in the current window that we're in we're able to use idf.pi so to run this program we do dot for the current directory and then export.sh so here you see that it's adding the esp idf tools to the path and now we can use the idf.pi so this is where a lot of the money comes from with the idf right so i'm gonna make a directory for all my projects and then we're gonna go into there and then i'm gonna type idf.pi so this is all the different things that idf's able to do for us um the big one we're gonna do right now is create projects we wanna make a new project from scratch that'll allow us to blink the led on my esp32 so we're gonna go dot pi create project and then create project wants us to give it a name so we're gonna say idf.pi create project and it's gonna be uh blink led cool so now we have a folder called blink led and you see they have the uh a cmakes file and a main folder so idf does generate uh c makes files which is pretty cool it's a pretty robust build system we're going to go into main and then we're going to sublime main right because we want to get our our code all set up cool so this is what it gives us it gives us a shell that we're able to write our program in so it's actually happening in the background we don't get to see outside of maine is the board is running free rtos free rtos is an operating system that runs code as tasks right so we're able to specify a task for the led blinking a task for the wi-fi scheduler running and all these other things that are happening and then every couple of system ticks is what it's called so for example maybe a thousand clock cycles the scheduler runs and it decides what thing goes next and then one of our tasks that run on the os is our so application main so what we can actually do to build this is go to the top level directory where the cmix file is and then we do idf dot pi set target so right now no target is set um i have an esp32 board so we're going to set the target to esp32 and what it's doing here is it's configuring our build files to enable it for the esp32 and then once we do that we do idf.pi build so this takes a very long time because what it's actually doing is compiling every possible feature that you could have put into your project and setting it up so that it's it'll run faster in the future so this initial compilation does take a few minutes but once this stops every time we make a modification we only recompile our application not the entire os so we'll let this run for a second we'll come back there we go okay so that took about five minutes for me uh hopefully it takes a little less time for you but it does take a minute but there's a lot of code getting compiled there so this code starts as an application as a task in free rtos and the way that we can actually prove that is we can have the esp32 print the name of the task that we're in to the serial console so the way that we do that is with a few things first we're going to have a variable named uh our task name and it's going to be equal to pc task get name this little bit so that's actually a function in freertos that returns the name of a specified task and if you give it a null handle it'll actually go into the task that's calling it so our task and get you the name of the task and it puts it to this character or to this pointer and then we can do esp log which is a function that writes data out to the serial console on the esp32 and we're going to make the first argument what's called the tag or it's like the the caller of the log when it outputs it and then we'll say hello starting up and then that'll be it we'll end it there so this is all our code is going to do for right now and then just to prevent a possible crash for not exiting a task properly we'll just sit here in an infinite loop so the way that we build this is simply by idf build again and you should notice that it takes significantly less time to do this we are going to get a few errors though yeah the reason we're getting errors is we didn't give it the uh header files for the free rtos task api and for the esp log so the way we do that is pound include free rtos free rtos.h and pound include free rtos task.h this is the freertos os api this is the freertos task handling api and then we also include esp log.h if you're curious where i'm getting all this from you actually can go and google esp32 development information and it exposes the api of where all these functions come from um and then down here you can see how to use this library it shows you that you have to include esp log and this is how you use the function so esp logged up i misspoke we actually have to do esp log i for information i apologize so esp log i cool so then we could build this again and notice that nothing is rebuilding it's only our program it's rebuilding and we get no errors which is great so now we have to flash this thing to the board the way that you flash a program to the board with esp32 is you do idf dot pi attack p the port so for me it's dev t2i usp0 and then flash what it'll actually do is it'll reach into your configuration settings it knows what binary to flash and it'll go to flash the and it will go to flash the program to your board so we go here it'll try to recompile it and get it all set up and then for me i have to go over here and hold the boot button for this to actually catch cool and now we can see that it's comp it's uploading our program to the board okay so now we have stuff that we want to see being output to the serial console we need to do idf dot pi monitor this will actually go in and grab the serial console on the device and again i'm holding the boot button for it to catch now it's in a give me data to program mode and i just hit the reset button and now this is the output of free rtos starting up so we have it loading up the spi flash and then it's going in it's setting up all of its heap segments and all this other good stuff and eventually it runs and we say main hello starting up that's us and then the board actually crashes what happens is we put the board into an infinite loop and a task without it's called yielding the task to the scheduler the watchdog timer of the board saw this and it crashed the board so we're actually seeing a huge crash dump of the board and it's going to keep doing this over and over again because the watchdog timer is complaining for our task not basically giving priority back to the board so the way we can do that actually and fix this is we can do v task delay and we'll do 1000 this is actually wrong we'll talk about why that's wrong in a second but again we build builds the whole thing we flash and again i have to hold the boot button for this to work let it flash and then we do the monitor hold the boot button again for it to catch and then reset and now it's starting up and now this task delay is yielding priority back to free rtos and as a result free rtos is not complaining so to get the gpio running right the whole point of this tutorial is to get this led to blink we need to do a few things first we need to pound include the gpio driver this is the code that runs the gpio devices on the board without this the program would yell or the compiler would yell at us for not knowing what a lot of these functions do so first just like an arduino we need to set the direction of the gpio pin right so we're going to set the direction of blink led and blink led is going to be defined as pin 2. set the direction of the blink led to i think it's gpio out and again i don't know the actual name for what the output is so i can actually just go here and i can do gpio set direction the function because i know that's a function name it will show me the function in the api and then i can actually look at what the proper number is so gpio mot gpio mode t has these so it's gpio mode output that was close cool so now that we have the direction set we also want to adjust the gpio reset pin on link led this just flushes any config functionality or config settings that may already be on the pin just in case we something got changed in the os before it got to us we want to make sure that all that goes away okay great so now we do gpio set level on the blink led to high we're just going to do 1 and then gpio set level blink led to zero and then just like in my free rtos tutorial we're gonna do v task delay 1000 for one second and what this does is this actually sleeps our task and yields priority back to the processor so we can do other things in the background cool so now that we have this written in theory what are we going to do we're going to print hello starting up set the reset the blink led pin set the direction to be an output set the level high yield of the processor and sleep set the level low yield to the processor and sleep cool so to get out of our monitor by the way we do control right bracket and we're going to build fatal error with gpio driver what is the proper oh it's driver gpio.h excuse me not driver here we go driver slash gpio.h okay build again cool so then we go to flash it and again i have to hold the boot button for this to work flashing good and then we go to monitor okay so we get this weird bug where the board does not actually flash every one second it flashes every 10 seconds we'll wait for it to go down to see that it's working okay so something's happening but it's not the right thing why is that so funny story i actually ran into this when i was setting up this tutorial v task delay does not delay for a number of seconds excuse me v task delay v task delay delays for a number of clock ticks so a clock tick is not a clock cycle a clock tick is a number um so what v task delay does is it actually sleeps for a number of cyst ticks not a number of actual seconds so we need to actually divide this number by the conversion rate of cystics to milliseconds and that conversion factor is called this port tick period milliseconds so what it does is it converts a thousand milliseconds which is one second what we care about and it converts that to the proper number of cystics that the v task delay actually delays for only one second so we're going to add that to both of these and again control right bracket to get out and then we idf build idf flash flashing it great and now we have the board flashing one time every second in the next video what i'll do is i'll actually build out the code that wi-fi enables the project and connects you to your wireless network and it will call out to the internet and report the temperature of cpu core 1 every time it changes but with that being said i hope you guys learned something if you did do me a favor hit like hit subscribe and i'll see you guys in the next video take care