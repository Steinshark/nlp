i think aspects of oop are nice and there sometimes i like things about it now it just depends on to what extent you mean by oop like i do not like the word extends okay i do not like inheritance inheritance 99 six% of the time is terrible but there's just you know there's always just that there's always just inheritance tax is wrong okay the pe people don't understand o o me mean or to me means only messaging local retention and protection and hiding of state processes uh and extreme late binding of all things alan k the guy who coined the term object-oriented programming okay okay it seems like a lot of people dislike objectoriented programming functional bros hey can i get some fs in chat for all my functional bros out there can i get some fs in chat for all my functional bros out there lots of functional bros okay this this is this is the gathering place of a lot of them all right how about this one let's invert it for a second can i get some some o's in chat for those that like o o o's in chat if you like o o okay damn okay you know what we got to do before we start this let's jump in here let's let's hit him with a pull okay because this seems a little excessive don't you think o or fp uh yes to o yes to fp i program procedural all right let's see it epic typing thank you i haven't had coffee dude i don't know if i can give up this coffee business i don't know if i can i'm feeling so weak i'm feeling so right now i've never felt more weak in my lifetime i've never felt more weak in my lifetime uh damn okay so i wasn't expecting this what would javascript do i don't know what javascript would do declarative or imperative uh declarative is the world's greatest scam really declarative is the world's greatest scam for sure because it always feels so easy but then all of a sudden as you use it it becomes incred ibly difficult it's like super nice until it's super awful how much coffee do you drink regularly couple cups anyways okay so it looks like we have more oops than fps and then we got the this whatever this is this procedural group they're pretty heavy over here that's why i like implicit returns shut up you shut your dirty mouth all right so let's let's g let's keep on going okay it seems like a lot of people dislike object-oriented programming the first things to come to mind when hearing these three letters are cars inheritance getter setters and object factory singl tens yes all of these are true this always seems kind of odd to me not only do i like o i feel that it often is the best sl most obvious way to model a problem all right here's why i think it is so i i'd really like it if they could give uh whoever whoever who wrote this sigma blog uh my sigma my sigma aster uh if someone could tell me how much experience does whoever wrote this article have with functional programming because that's always the big thing that i see is that you see a lot of people critique about how something is or is not and they often have little to no experience in one category versus another so i always do appreciate a little bit more of a hey this is you know i've done years of whatever like if he was just like i was a full-time hasal dev for this long and he got he left hasell i mean i'd be very curious as to his his reasoning okay because normally you don't leave hasell just saying hasal mentioned let's go i think before anything further we should probably define what we are talking about unfortunately oop is not well defined for the sake of coherence let's settle on a clear and unambiguous definition first okay this guy is starting to sound like a functional programmer uh we will be talking about objects a lot so what are they most introduction texts to oop use physical things like cars and animals to illustrate what objects are and while that is not wrong it's literally where the object metaphor comes from alan kay was thinking in terms of biological cells and networks it's certainly misleading because objects are much more than that okay peter wagner writes objects are collections of operations that share a state okay kind of like a cured a curried parameter in a function it's kind of i mean like i mean you know delicious rust it has a struct and you can attach methods to it the methods are the shared state right the methods share a state right i love that if that falls into the definition of o i love o i love structs with functions you love chicken curry okay i get it i get it uh mark stepik and daniel bobra babra uh define objects as the following objects are entities that combine the properties of procedures and data since they perform computations and save local state uniform use of objects contrast with the use of separate procedures and data in conventional programming okay here's another definition by the gang of four object oriented programming are some made up let's see are made up of objects and object packages both data and procedures that can operate on data procedures are typically called methods or operations like if we're just talking about this right now i'm on oop train i like my data i like methods that work on that data i find it easier to use in the world of lsps uh i don't like a bunch of functions because i find it harder to figure out what functions i need to call to do things whereas if you have a simple object that i can do a dot separator on and i get all the methods to manipulate and or do something with set object i find it very easy and simple so i'm curious where this is going because where does the break happen at what point do i say i hate this let's find out okay okay that's a good start but i still think an important characteristic of objects is missing maybe tim ren can help objects are units of state that are generally opa to the outside this i think is an important part we will see later why that is is an object can however provide the possibility to interact with its state by the means of message passing oh my goodness method method path i'm having a stroke haven't had coffee in two days message passing methods h okay yeah okay wait a second collections of operations that share state entities that combine procedures and data units of state what the hell is that supposed to mean meth it's meth it's meth people well uh in means that object is an abstract term and an object can potentially be anything anything with state that is it can be a physical item like a car an abstract concept it can be a random piece of data with some sort of behavior attached to it oop just means we model our problem using these objects that is it i mean if that is all the definition of o is then i mean i'm i'm on board yeah then everything is oop well not everything is o because some people some things aren't o function like pure functional programming where you functional programming in which you have no methods then i would say yeah right functions where you can only just pass in like structs c would be not uh c would be like just not doing it right i know the problem is is everything o yeah yeah yeah yeah uh when lightning strikes a tree what uh whose behavior is that i don't know what are you talking about what the hell are you talk why did i read that out loud uh you might be thinking hold on we define oop without even touching classes what gives the answer is simple classes are not strictly necessary for o a shocker i know of course we need to be able to construct new objects and a class-based languages are admittedly way more prevalent however or prevalent however this is not the only way to achieve the goal languages like javascript although es6 introduced classes is to the languages or lua used the concept called prototyped based or prototypal oop instead of providing a schema for constructing new objects we use existing objects as prototype this approach can have real world benefits as it reduces the language complexity i don't know if that's true at all i mean protot uh prototypal uh o op is interesting like lu's uh metat tables are very very interesting but it's most certainly i would not call it simple i would not say that it reduces complexity they're weird as hell they're not weird as hell they're you have to like again you can't fit them into the construct of what you already are used to you have to kind of think a little bit differently and they're really not all that bad they're they're interesting uh just let's see see just as a side note classes don't need to be called classes languages like go or rust ooh uh and also see to some extent call them strs for example do c structs it's hereditary another term while not technically necessary is often associated with oop as inheritance there are two reasons to use inheritance okay okay i i i would love to see this rust of course rust mentioned because that it makes sense because it's just strs right right now okay i think we i think we got something here i think we're seeing a more clear picture of what he means by o is not bad uh another term that while not technically necessary is often associated with oop as inheritance boo can we get some like uh there are two reasons to use inheritance first is to reuse existing code however in modern programming this is usually discouraged in favor of object composition an object inside another object yo dog i heard you like objects yes python yeah get that python out uh yeah hell yeah object in an object the second reason and to me the more important one is for abstraction and polymorphism the term the technical term is uh for this is subtyping yeah i don't know i don't know know i have never met an inheritance chain that i really liked you know what i mean just saying i've never really like i've just really never liked inheritance every time i've ever used inheritance i've been upset about it inheritance is not o op correct well i mean in some sense he's saying it sort of is but let's find out yes i think the topic is important enough to warn its own heading subtyping is not exclusive to oop however it is a special significance here since it's the primary way of modeling polymorphism the idea is to combine multiple different classes that share common messages have methods with similar semantics into a super type that defines those messages now the super type can be used instead of the uh instead of a specifying a subtype my favorite example of how subtyping can be used in practice is the java collection framework it defines interfaces we'll talk about what exactly interfaces are for example use cases are lists cues sets maps as well as different implementations with different characteristics which support those use cases hell yeah hell yeah um nothing like a good oldfashioned concurrent skip list baby i don't remember i i don't remember my uh i'm not even sure what i'm looking at link transfer q is an abstract cu which is a abstract collection which is a collection which is an iterable is that how you read that see i don't think inheritance is a good way to solve this i think the trait system in rust or just being able to have like you know orthogonal types to this is is way better right i don't want to have to have iterable as something i inherit from this graph was generated from java docs by scraping all known subclasses of collection and map and removing non-relevant nodes oh okay they removed non-relevant notes everybody nonrelevant ones this is actually this is actually a tightened up version of it thank god i know i mean i wouldn't have been able to understand it otherwise uh so let's say i want to process a list of data i want to use a list interface everywhere at the point where i instantiate the list i choose array list since i us let's see it's usually more performant implementation that is not a sentence i want anyone to listen to because i do not know if that's true or not uh it really has its time in place later on it turns out that the program is doing a lot of inserts and deletes at the beginning of the list which is pretty slow on arrays to speed up the program i can switch to a link list without changing any of its type signatures side note when calling a method we need to know the actual class of the object not just its declared class otherwise subtyping won't work properly this is called late dynamic binding it's technical execution is a bit tricky and is the main reason why c++ objects and object pointers behave differently cv tables okay i mean yeah interfaces are great i think we all agree that interfaces are great right you love the collections api there's there's a lot of good stuff in the collections interfaces are great someone said no of course interfaces are great you love interfaces don't try to tell me you don't love interfaces no you don't love interfaces why not array list isn't an array yes it is it's an array underneath the hood in which stores the items and then as the list exceeds its capacity it reallocates and moves often doubling in size commonly referred to as a dynamic list or a dynamic array so no one can tell me why they don't like interfaces interfaces are fantastic is go slices array list go arrays the make arrays they act like array list yes that's why you have they i assume they're probably an array list underneath the hood i assume they're not uh linked list they're dynamic arrays yes um let's see i love contracts i read every sentence interfaces stole my girlfriend okay you guys aren't helping at all i think we can't and shouldn't talk about subtyping without mentioning behavioral subtyping and barbara uh lisov the basic idea of behavioral subtyping is that a subtype should behave in a way similar to the parent type barbara lisov who later won a touring award for her work on programming languages in oop in particular formalized the concept in 1987 into strong behavioral subtyping a subtype should be able to use in every situation its parent type can be used in okay okay this sounds like she created inheritance solid mentioned i'm not really sure what i don't know if i'm i'm applauding barbara maybe i should be i don't know uh subtype requirement let this be a property provable about objects x type t then only this should be true for all objects of y of type s where s is a subtype of t classic classic classic just get just just get get it together people what are we reading hll ah yes ah yes okay let's try to understand this okay this is a property provable of objects x of type t then this should be true for all objects of y of sub of type s where s is a subtype of t i'm not really sure the problem is i don't quite understand what this is trying to say is this a function that takes in parameter x like what's its meaning no i'm not saying the word fee i'm saying speak english stop speaking them greeks boy uh this is called uh lisov substitution principle i won't go into details here but the basic idea is that any precondition for types data or state for parameters can not be stronger than the super type while any postcondition for results cannot be weaker than uh the super type the notion is related to the design by contract methodology that started to pop up around the same time oh okay did i get that correct well this was that stupid article we read lcav lcav what did i how did i say it i did lovs okay yeah yeah yes i've been using chat gpt to learn roblox okay l i got hit i got hit with the l there l uh okay uh is one of the five solid principles of object-oriented programming and design formulated by barbara lov in 19 87 it states that objects of a superclass should be replaceable with objects of its subclass without affecting the correctness of the program in practical terms it means that a subass should extend the behavior of a superclass not alter it here is a practical example to illustrate l uh lisov substitution principle super class bird k [ __ ] subass sparrow in this example the bird class as method fly and the spal class being a bird naturally implements fly method adhere to the lsp adhering to the lsp however the ostrich class although a bird cannot fly and raises a not implement exception this violates uh the lov's whatever principle uh because it changes behavior of the superclass uh method leading to unexpect behavior yeah yes it does that's because this just never works o disproven by chad g gity bird flying bird okay so this would be how you do the correct version of it oh my goodness it is it is like communism you just have to do it correctly and then it works gosh dang gosh dang i've been wrong this whole time okay i i mean that's okay i i i guess i get this i feel like this isn't uh doesn't have to be with the thing i don't like about this in general is that there's so much more subtyping you have to do whenever you use inheritance as opposed to having a behavior you can attach to something like that's why i do like go or rust is because i can just have a struct and then i just make the struct just have more behaviors and be usable at any point in interface that i fulfill like to me this is just a 9,000 times better version of solving this exact same problem it's just so much easier because whenever you do this like think about how many things you have to get correct right you have to get it correct to the point where you actually make sure that you don't bork this principle but let's be real here whenever you use this whenever you've done in inheritance you've borked this principle at some point you work at a place that borks this principle no matter what this thing is always broken it's you're done effed up you're done effed up a aon every single time sparrow bird iterable drawable yeah exactly and so you end up making these this this is what always happens whenever i see someone try to do o op right is that you end up getting this really really really long chain where you have to go through like 15 different classes to figure out what the hell is happening because it just doesn't work because everything has to be so gosh darn narrow this is an extremely correct solution but it ignores the practical reality that implementing it fully and more complicated than the context management overhead of not doing at all yes exactly it precisely it's always so simple it's the same reason why i always [ __ ] on like like any example app people give me like look at how easy react is do you see this example app or look at how easy it is to use redux look at this sample app look look at how easy to use htm x look at this sample app the reality is that real applications take everything that you like and pour a gentle amount of just [ __ ] oil over it and just ruin everything okay ruins everything every good concept just turns awful when you use it in reality [ __ ] oil i didn't have anything there okay my bra okay i haven't add coffee okay just let me let me pb all right in some cases we don't care about the code sharing aspect of inherit but still want to profit off of subtyping we might never actually use the super type implementation of the methods and can therefore omit it entirely this is in fact so common it even has a name virtual or abstract methods you know rust does have some things that are very similar to this uh in the sense that you can do traits and then if you have enough methods defined on a trait you can even do trait default implementation have you seen that so you can actually have like an what feels like an abstract class in some sense because the trait itself self has a default implementation it's interesting have you seen this have you heard about this i'm that's what that's why i'm saying it rust is o op all the way baby all the way uh that's mostly because rust is failing towards the c++ approach of implementing everything for everyone classic uh some languages let's see we might even end up removing all state from our abstract super type and only use it as a stencil for defining methods this is called an interface o yay interfaces some some languages go or even go a step further by the way i think one of the biggest faults of a typescript interfaces is that it allows well there's actually a couple faults but one of the big faults ambient interfaced make my dream sad collisions are very very sad but the second one is also which by the way they can also be very very nice but the second one is also that they allow properties on an interface i think properties are truly an implementation detail and they should not be there just saying uh some languages go a step further and completely decouple interfaces from classes there are two different schools of thought here yeah i like the i like the secal structural typing as opposed to uh usual nominal typing is when an interface implementations are not declared at all you can simply use the object as an implementation as long as all the necessary methods are defined this is uh statically checked at compile time examples of languages that support structural typing are go i love i actually really do like that both for interfaces themselves and type constraints and c++ for concepts yeah but are concepts even implemented like how long have concepts been around how long have they been around are we actually getting concepts and do i even really know what concepts are even though i did read it once concepts feel like traits give it 10 years yeah concepts feel like traits conceptually speaking yes uh they need some time to marinate uh duck typing is similar but the existence of methods is only checked at runtime languages use this pattern uh included python and javascript one disadvantage that's often cited is that it is more complicated to figure out which classes can be expected at a particular point in the program yeah yeah i mean that's that's the whole i yeah fully agree actually so i'm i'm a big fan of structural typing by the way i actually really like this because you get all the compile time goodies but you get kind of like the ease of use of everything else you know what i mean like you don't have to say like oh i'm all these things you're just you just are those things i am this thing now i will say that with rust the use of turbo fishes plus parse is you know is really cool i like that i prefer type unions or rust enums to interfaces uh most of the time enums give you a list of types that you can accept and do pre-type implementation or per type implementation interfaces force you to be abstract yeah but there's many there's plenty of places that you need interfaces like right like parsing the from trait in in rust is a great is is a great example you just need to be able to parse something to something else it just has to be an interface you know what i mean it can't it can't be an enom uh anyways the second pattern doesn't seem to have an established name yet the idea is to declare that the class implementing an interface after the class was already defined an example of a language that does this is rust with traits unfortunately traits is a horrible name for this concept since traits usually just refer to mixins i've heard the term extension traits in reference to extension methods in c cotlin dz nuts uh but this doesn't seem to be very common either another language that supports this feature is hcll they call it type classes but hll is arguably not object oriented arguably one would argue that hll is not object oriented uh okay yes i i do agree traits is a terrible name uh because once you know what a trait is then it makes still some not sense but i just call i just use that word because that's what i i know now um all right hideand-seek the term that is often used with oop is encapsulation there are actually two applicable definitions of the term the first one refers to bundling data with behavior the object metaphor and the second one refers to restricting access to the state only to the object itself i would like to focus a bit on the latter since i think a lot of people don't understand it properly encapsulation is the technique for minimizing interpr dependencies among separately written modules by defining strict external interfaces so why is it important to restrict access to state well there is multiple reasons we could argue that it would violate lov's history constraint well i didn't know about lov history constraint now did we i feel like i need to wash it normally i order larges and they they fit nicely encapsulation versus abstraction yeah yeah yeah yeah yeah yeah yeah yeah yeah we're we're kind of on the encapsulation uh el ligma history constraint classic but i think it that oh my goodness but i think it's much more practical to look at it from the perspective of a developer who wants to refactor the code base let's say we want to change the internal structure of an object like in the list example earlier maybe we want to switch from an array list to a link list but if other components are reliant on the internal state in the case of the array list this could be an internal primitive array we cannot easily change it we would need to find all places outside the class where the internal structure is re referenced the problem gets even worse when the class is exported and used by modules that we might not even control again this is why i said earlier this is like precisely the reason why i said earlier that interfaces in typescript that allow properties was a great mistake you look more buff in this one i've been feeling buff okay i've been feeling like i'm getting in shape these days i have been sore for like the last eight weeks straight and i'm just sick of it sick of it open close principle open for extension close for modification uh object coupling and class cohesion are often talked about uh encapsulation object coupling describes how much different objects depend on each other high object coupling are we talk about afr or eant coupling uh implies that objects in question rely on a lot on each other which usually means that or usually means they should be one single object instead if objects rely on each other's internal structures they are highly coupled class cohesion describes the same characteristic but from a different perspective it's a measure of how coherent a class responsibilities are a class should ideally represent one idea and only do stuff rel relateded to that idea low class co uh cohesion usually means high object coupling and vice versa okay so these are some of those things that you know normally i would love to agree with all these things yeah if you just use composition you don't have this problem again a lot of these problems i feel like are self-made problems i think judo you are very very correct in the sense that a lot of these problems that we're reading are purely problems created by people who love o and now we have oop problem whiteboard masturbation there's a lot of whiteboard masturbation in oop and it can be very very difficult to follow along because there's just so much of it i'm not sure if you've done any objectoriented programming you've heard something like don't use public properties properties in the sense of member variables at some point and this is true because public properties expose the internal state and can potentially cause high object coupling however as with any dogma it is usually a good idea to question it in this case the complete guideline is don't use public properties use getters and setters instead which is completely wrong i would actually agree with this completely getters and setters are such a waste of of energy and mental headp space in terms of encapsulation getters and setters are just as bad as public properties exactly as they do nothing to prevent object coupling if you have a class without meth any methods besides getters and setters it it doesn't really fit our object definition a term that has been used uh for this is record by the way if you just have getters and setters like real talk getters and setters are just slightly less convenient properties you're still just as i mean i know that c has get and set i just don't understand the the the purpose of get most getters and setters there's like very few getters and setters that make any sort of sense but what's the point i people just want to not have properties i don't know what the point of getters and setters are you want to be able to programmatically be able to define a a definition without having getters and setters are by far highly one of the most like i swear it's one of the biggest lies in all of programming i guess we're going to have to do something really quick aren't we um let's go like this so let's just delete that uh i know i know c has a version of them right uh i don't know where my music is but anyways so imagine you have a private you know a private uh foo it's a number okay am i on js or ts ah crap i'm in t js here let's let's make this ts because it makes it more clear i think anyways okay there you go shut up anyways so we have this food right we have this priv so then we can have these things like uh here we'll call this private underscore food you know what i mean you know what i mean then we'd have something like get fu that returns a number that returns out this fu look at that look at that look at that x uh v value right uh void and then we go this. fu equals v okay fantastic all right oopsies uh fv uh what is it uh number there we go let's see cannot have type annotations okay shut up shut up all right so that means we can have a new foo right here and i'm going fu. fu equals 123 dude just use an effing method at this point can we all agree that this it's just you could put some more logic in this right you can definitely put some more logic in here that you want to do right you could have some sort of calculated method what happened if you had something like this right uh bar and so then you wanted length right and that was this. fu plus this bar okay so that means i'd go something like this what is my length right oh look at how nice that is that's really really nice in fact i have an exact use case for this exact thing right here did you know that i have an exact use case because if you build yourself a say a request queue you have two different you have two different lengths right you have the uh uh items right which is an array let's just say and then you also have inflight requests which is going to be a number so the length is actually those two numbers put together right it's going to be this.in items q. length plus uh this.f flight request right or you can just stop being a jackass and just use a just use a effing method okay just use a method okay why are you doing this to yourself okay what are you doing what are you doing request q okay just stop it just use just use just just use a method okay save the parenthesis but it makes it dude it just somehow it is such a lie to do this right this feels like you're lying like computed properties are always just i i genuinely feel that they're they're kind of dangerous you know what i mean i just feel like whenever you use a computed property you're doing something in which is a little naughty and you should ask yourself why am i doing a computed property this is the thing if you actually want to use this with interfaces you have to recognize that a programming interface doesn't specify a data type it specifies a transport otherwise it's an abstract class or template which are not the same thing facts and if you go with a computed property you know it doesn't really work out in the interface sense of the world right uh i would name it compute length okay great i would name it length i in fact i would even name it link i would name it len okay cuz that is who i am okay that is what i would do i would name it like that and then i'd have its counterpart method uh empty which returns bull buing which would be len equals zero okay oh my goodness oh my goodness all right there you go look at that all right fantastic or just l l's l l doesn't make any sense len is perfectly fine len makes high level code look like assembly language no it doesn't make it look like assembly language where do you guys where where do you guys get off you guys don't program enough rust okay go program some rust and come back to me lenin communism lenin co communism anyways all right okay so what is oop op is related to state and behavior are bundled into units objects other property other properties objectoriented languages may have our classes prototypes encapsulation subtyping and inheritance let's look at the modern languages at least top 15 okay okay here let me i'm going to zoom this out just because it's a little bit easier to look at these things javascript encapsulation okay this is wrong it does have encapsulation modern javascript does have privates right uh python uh not on a language level okay fair yes i mean python you can in can't you inspect values in closures uh let's see typescript classes it also has encapsulation no javascript also has if you use uh you can also use this right right and that means i i can't access fu right like that's that's real it actually does have it and that's at a language level and when you in fact when you when you in fact when you uh when you string json stringify it um so it is actually at a pretty high language level dang it uh get rid of all this crap there we go get the hell out of here okay cool cool cool talk cool talk okay cool talk cool talk i don't know what that is why is my lsp breaking all right i take out everything look at that see notice that it only printed f 69 it didn't in fact actually print the private property the property the private property is actually pre yes i'm ignoring the fact that all that other [ __ ] just happened okay do you even knowe uh today if you want to ship your project on schedule and minimize the amount of tech debt uh you forward use go yeah anyways you get it all right all right some good stuff in here no one cares about no one cares about these ones uh sear a c none of them okay it doesn't even have objects well i mean are strs objects i don't know are structs objects i guess you can't quite say they're objects because you can't because a part of his definition of objects are they have function pointers right they have methods so you can't say it no they're just trs they're just memory c has perfect encapsulation php go yeah powershell didn't even realize that was a language uh go on a package leal uh level and structural typing best typing honestly it's best typing i think structural typing might be my favorite typing right it might be my favorite typing i thought i loved russ nominal typing extension traits but i think i actually like structural typing better just in general uh okay so let's see now that we have a good understanding of what exactly oop is and what we can expect from a language that implements the oop paradigm let's take a look at some common points of criticism i shamelessly crowdsource most of the following part by asking my friends what they hate about oop but what are objects what uh so objects are can be anything right so how do i know what should be be an object when should i combine things what should be separated well that's called experience bro and this exists in or not in objectoriented like that's just that's just that's called programming doc uh well in the end that's just practice and experience with time you'll get a feeling about what shouldn't uh what shouldn't be an object however to get started there are some tricks that might help you uh here's what the gang of four has to say dude it's that skill issue going on here object-oriented design methodologies favor many different approaches you can write a problem statement single out the nouns and verbs and create correspond by the way if you're hit me with nouns and verbs and you're talking about programming i already know that you're hitting that whiteboard too hard okay i don't know about all this i don't know all i don't know about all this this nouns and verbs and adjectives and participles going on here uh or can you focus on on the collaborations and responsibilities in your system or can you model the real world and translate the objects found during analysis into design there will always be disagreement with approaches uh on which approach is best speeding speeded speedy things go in speedy things come out op slow or so i've heard the rational is that the vtable lookups are overhead compared to direct function calls i don't know i don't actually know whether that's true so i decided to test it the test setup is as follows i wrote the same program a touring machine checking for binary palindromes three times once using object-oriented programming once using structural programming using only functions loops tupal and arrays and stuff like this and one using functional program for good measure i measured everything in c++ so it's equally playing field an equal playing field also c++ has the first class function class functions lambda expressions for functional version hell yeah it does everybody loves who here doesn't love c++'s lambdas aren't they just so good yeah there you go thank you jamely appreciate that that's what i always like seeing what am i capturing what are the arguments where's the function body it's just like damnn son i don't even know what the hell is happening um there is 100,000 test cases the total time is measured the compiler is clang 1403 and the target platform is apple silicon m1 i can test each and uh with both o uh 0 and 03 for the o implementation i made sure not to rely on heap allocations since the context witches would probably completely ruin the runtime i did however use inheritance the template pattern to be specific to make the template pattern to be specific to make vtable lookups as realistic as possible the structured version also allocates everything on the stack i built two different versions the first one uses tupal in the translation table lookup however i wasn't sure how tupal are implemented under the hood and i wanted to avoid using objects by accident if possible so i wrote another version that only relies on functions but it turns out the results were uh so close i couldn't tell the difference does that mean fp is winner or loser is this how many cycles we're doing or as we can see the structured version is marginally uh is marginally 5% faster than the object oriented uh one okay hold on okay so more is worse more is worse you know this just tells me you got some skill issues going on you got some skill issues on the functional program if you acally wrote something that is 10 times slower you got some skill issues o camel is dead that's just skill issues that's skill issues for sure uh when using 03 the performance is basically identical so my guess is that c++ optimizer was able to get rid of whatever uh impacted the performance the functional implementation is not even remotely closed to a certain extent this is probably caused by the benchmark i chose touring machines are inherently stateful which is pretty awkward to model in a functional way did you model it well though did you um another aspect is that even though i use c++ 14 which supports return type inference i was forced to use standard function template as a wrapper for the lambda expressions anonymous types are a pain in the backside which according to my test are quite a bit slow slower than native lum expressions okay so he might have forced himself to use something that wasn't very swift i don't remember programming a touring machine you're programming on a touring machine have you ever thought about that i should have probably done some more rigorous statistical tests or at least calculated the deviation but honestly i was too lazy i may write up an update on proper analysis later on uh in case you wanted to do some tests on your own feel free to send me the results afterwards the source code is on github uh also i should probably apologize for the horrible code c++ is not my native language and i hacked it together in an hour or so again dangers here dangers uh anyways without rigorous statistic uh statistics my conclusion of the test is that there is only a very small difference in performance adding more abstraction layers or using different data structures probably has more significant impact agreed agreed this article is a skill issue this article is not a full skill issue there's a lot of good insight here however other benchmarks on embedded systems have found 10% performance penalty compared to procedural implementation let's go procedural another paper comparing the performance of different aspects of o as well as different design pattern has shown that virtual functions which i used in my implementation can impact the performance negatively uh the template pattern which i also used can decrease the performance by about 3 to 4% but this may also be uh this might also just be because it relies on virtual functions by the way whenever you see percents and stuff like this i will just completely disregard most of this it might slow it down it might slow it down all right abstract nonsense for some reason oop leads us to over complicated everything we need we endlessly or we needlessly build abstractions on top of abstractions seemingly for the sole purpose of making pretty uml diagrams okay this is a pretty good argument but this works for every type of programming can we agree to that i think that anybody that has the ability to program in a more abstract language will by the very necessity make more complicated and abstract things the startup not only has increasing net worth but also increased net girth thanks pick i hope that girth is feeling quite girthy the thing is it's caused by how we use the tools not the tools themselves my suspicion is that most the these issues arise from developers wanting to be clever and build generic solutions to cover every possible future development yep exists in every single language i think a lot of this can be avoided by adjusting the workflow specifically if the end goal is not determined from the beginning don't plan on every eventuality from the start only plan for what you need you'll need dude i love this this is so good this is so good this is like the greatest piece of advice in this entire article right here is just build what you need stop stop stop the requirements might change later on so your amazing highly generic solution that you worked on for four weeks straight might not be used in the end a waste of time facts uh the threat of get and set op is so verbose there is so much boilerplate getters and setters for example sai this is a personal pet peeve of mine we touched on this earlier but but i would really like to hammer this part home if you really need getters and setters for every single member variable it's probably not a proper object to start with also bad programming skill issues i'd highly encourage reconsidering your object model try to reduce coupling if it's really a record class with no internal behavior everything might as well be public there is hardly a point in using getters and setters a similar thing though admittedly it's better applies to properties in languages like c oh c mentioned damn it we got c here of course code generators uh like the infamous lombok c people classic cper the only reason for the use of getters and setters over public members is whether or when there is some additional logic like validation of invariance for example that's fair i still think it's just dangerous i think you should use a method and not a getters and setters uh kind of related if you have a value object with no setters but a lot of getters make sure to not accidentally expose a modifiable reference to same internal state otherwise you've got setters that's not intentional ooh okay okay this is the la this looks like kind of like the last one uh object factory factory singleton i guess there are two topics that fits this heading the first being naming madness that has been established in enterprise software development this is again not a per se an issue with o although for some reason it seems to happen a lot more in oop this is more of an issue of o dog i happened to be uh a calvin henny fan and he gave an amazing talk on naming in programming at devweek 2015 among other things he talks about how naming can influence modeling i highly recommend watching it okay on the second topic it is a rabbit hole of design patterns that are often blindly applied seemingly without any thought on why exactly specifically the factory pattern has some valid use case or uses but because people overuse that pattern so much it's now synonymous with unnecessary abstractions everything's a factory c is a really good programming language you watch your mouth judo we don't complement it out loud there are some courses also let's see there is there are of course also established patterns where you should really have a damn good reason to actually use it at least in a strictly objectoriented context single singleton for example singleton is in essence just a fancy name for global variable great fun little side note in the spring framework beans by default gets a singleton scope meaning if not stated otherwise every single bean is global your beans are global boy the dream of spring another thing i've been noticing with modern enterprise applications is that they're actually not objectoriented entities dto are records not objects beans services repositories don't hold state and could just well be plain functions in modules we are we are using languages that force us to think in classes with architectures that don't require objects spring boot could just as well be written in c it's pretty sweet it's pretty sweet maybe spring is not that bad maybe spring is not that bad maybe i like spring i don't even know uh what a ride in my longest blog post so far maybe a bit too long i'll make sure the next one is shorter i also found a really interesting talk by barara uh lisov about abstraction but i just wasn't sure where to put it so here you go uh i particularly like the stab against python for throwing encapsulation out the window anyways i hope i could shed some light on the topic maybe you've learned something or at least you found some of my ramblings somewhat entertaining see you soon sigma let's good i actually really like that this is sigma grind set i actually really like this article there's a lot of good things in it but at the end of the day i still don't quite understand o you know real talk i still think the problem with o the problem with any of these things is that they all have very they're all accomplishing the same goal with slightly different approaches and i think at the end of the day one reason why i like one reason why i've grown to like go so much in the recent time is that it just forces you to be stupid and by forcing you to be stupid i find myself highly productive simple is not intuitive at all you got to quit regurgitating dumb dumb dumb phrases you read on the internet okay i know whose blog post you're effectively quoting word for word it's not that great the internet is always right just saying uh the prime se all okay i haven't had coffee in a couple days and i'm angry okay simple is good ns simple can be very very good and in most cases simple is good enough it just depends on how simplistic you have you just don't want to exceed a certain line of simplicity cuz once there's a certain line of simplicity then it becomes very difficult i don't think go's a great language no one ever said that it's a very mid language it just is very very practical is rust simple rust is neither simple nor easy uh take that a step further i think that languages with a better modules and interfaces had become more popular sooner we wouldn't have gotten microservice as hell and we would still be on a lot of monoliths potentially maybe go is so mid it's good yeah it's just it's super mid it's pretty good he quick caffeine too yeah nice job nice job him what is a great language for you then i like go it's a great shitty language it's like a great shitty language and i like to use it and i enjoy using it we'll see if i keep on enjoy using it after a year i'm going to give it a good year of trying to build a bunch of little things in it and i'll see how i feel at the end you know what i mean we'll see we'll see anyways become grug brain use simple things okay it will make your life easier just trust me just try not using as complicated stuff try hmx with go enjoy it the name you know what the name is and you will shut the hell up