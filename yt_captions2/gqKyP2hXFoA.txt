the first thing we do is jump on here and tweet it then we go here let's read this because this is an article designed for me to get excited which one do i do here which one do i do here we're just not going to do either of them c isn't a programming language anymore okay okay phantom derp and i have recently been aligned on a particular subject being extremely angry about cabis and trying to fix them we when uh where we are not aligned is why we are mad about them okay okay sounds like someone's trying to integrate with rust and not very happy about it uh he's trying to uh materially improve the conditions of using c itself as a programming language i'm trying to materially improve the condition of using literally any language other than c okay okay now you might reasonably ask what the [ __ ] does your problem have to do with c it wouldn't if c was actually a programming language okay we're cooking okay there's some cooking going on right here unfortunately it's not and it hasn't been for a long time i'm curious how one goes from a programming language to not going from a programming language without itself changing i'm curious about this this isn't about the fact that c is horribly il defined due to a billion implementations or completely failed integer hierarchy that stuff sucks but on its own that wouldn't be my problem okay my problem with c was elevated to a role of prestige and power it's rain so absolute and eternal that it has completely distorted the way we speak to each other rust and swift cannot simply speak their native comfort and comfortable tongues they must wrap themselves in a grotesque sim simulacra of se skin and to make their flesh undulate in the same way it does called it rust i knew it rust makes you just very angry that things don't act like rust but i also get it uh i hear see i hear some of the abi problems are kind of annoying but i thought that's what the whole uh i thought it was kind of a partially solved problem is this not a partially solved problem isn't there just like a isn't there a repper there must be things i there's probably a huge set of things that i just simply don't understand i thought it was like kind of a solved problem it's not russ wearing cs skin is uh texas chainsaw massacre it is it really is i got into this argument really i i don't know why this dude is complaining i got into this argument recently okay go on the problem with this is when it comes to abi stuff i've never played with the abi stuff uh it's definitely not solved abi is unstable across the board abi compatibility is not a solved problem okay so it's just it's generally just a sucky problem and so does does rust solve this problem does rust have a solved 100% guaranteed abi rust abi is still unstable i thought it was unstable i thought i thought it was unstable because i thought that was one of the things is that they guarantee no no formal layout it's not compatible across compiler versions there are a third party crates like stabby that attempts uh to do that okay okay c is the linga franka of programming we must all speak c and therefore c is not just a programming language anymore it's a protocol that every general purpose programming language needs to speak so it's act so actually this kind of is about the whole c is inscr ins scrutable implementation defined mess thing but only in so far as it makes this protocol we all have to use even bigger nightmare foreign function interfaces okay let's get technical you finish designing your new language babby script with the first class support of uh see for babby pa hooves and fins an amazing language that's going to completely revolation revolutionize the way cats sheep and sharks program but now you need to actually make it do something useful you know like take user input or write output or literally anything observable if you want programs are written in your language to be good little citizens that work well with major operating systems you need to interact with other operating systems interface i hear that everything on linux is just a file so let's open a file all right there we go here's the man this looks like man paging uh there we go here's this beautiful thing one we got uh little all these all of this this open at i've never used open at or open at 2 i've never used any of that those are new ones for me i've never tried that header files why i mean i we let's see i'm sorry this is babby this is babby script not c where's the babby script interface for linux googles what do you mean there's no babby script interface for linux oh well sure it's a brand new language but you're going to add one right okay i guess we have to use what we've been what's been given to us we're going to need some kind of interface that lets our language call functions that are foreign to it a foreign function interface as ffi oh i like the sound of that all right for those that don't know this is we've now built up the basics oh hey there rust h you have a cffi 2 uh and you two swift even python what if we kissed parameter passing after the argument uh values have been computed they are placed either in the registers or pushed onto the stack that is how values are passed at the describing following section okay beautiful we uh and we were both c i'm not sure what's this is this is this is a strange one i'm trying to follow along here everyone had to learn to speak c to talk to the major operating systems and then it let's see and then when it came time to talk to each other uh we suddenly all already spoke c so why not talk to each other in terms of c2 okay i mean this is actually pretty reasonable i like i actually really like this description thus far this this this foreign function in business is actually making i'm now following perfectly oops c is now the lingua franka of programming oops c see now or now see isn't just a programming language it's a protocol okay okay yes so apparently basically every language has uh to learn to talk c a language that is definitely well very well defined and not a mass hallucination what does talking c mean it means getting descriptions of an interface types and functions in the form of a c header and somehow matching the layouts of those types doing some stuff with linkers and resolving function symbol pointers calling those functions with an appropriate abi like putting args in the right registers well we've got a few problems here you can't actually write a c parser c doesn't have an abi or even defined type layouts okay okay maybe i don't understand i'm sure this will become clear i'm sure this is going to this is ludicrous what will be next forcing x86 with x86 with intel cpus yeah sounds like skill issues i don't know yes i'm genuinely asserting that c parsing c is basically impossible but wait there's a lot of tools that read c headers like rust binding nope b genen uses lib clang to parse c and c++ header files to modify how b genen searches for lib clang see the clang cis documentation for more details on how b genen uses lib claying see the b genen users guide anyone who spends much time trying to par see optionally plus+ header files quickly says uh actually [ __ ] that and ask c++ compiler to do it keep in mind that meaningfully parsing a c header is more than just parsing you need to resolve include type defs and macros too so now you need need to implement all of the platform's header resolution logic and somehow figure out what things are defined in the environment you care about oh yeah that would be that would be that would be slightly tough this would be slightly tough and if let's take a really extreme example of swift it has basically everything going for it in terms of c interop and resources it's a language developed by apple effectively replaced objective c by the way objective c terrible language terrible language as a primary language for divining uh and using system apis on its own platform in doing so it has in my opinion taken the notion of abi stability and design further than anyone else it's also one of the most hardcore ffi supporting languages i've ever seen it can natively import that's so many that's so many options right there is there objective c++ there has to be please god no there has to be headers and will produce a nice native swift interface with types getting automatically bridged to their swift equivalence at the boundary often transparently due to the types having identical abis good old mpp files is that what it is uh swift also developed by many of the same people at apple who built and maintained clang in llvm straight up yeah that's chris lner he's also doing mojo right now straight up uh world leading experts in c and it's spawn one of those people doug gregor let's see what his opinion of cffi is of all let's see all of this is a reason that swift uses cl internally to handle the c++ abi that way we're not chasing every new abi impacting attribute cling ads so this doug fella agrees agrees with the idea that we should be just use clang uh well [ __ ] uh not even swift has the stomach for this more stuff so what do you do if you absolutely positively do not want to have a c compiler parsing in resolved headers at compile time you hand translate to those bad boys in in 64- t oror t right i64 long right uh oh no what's a long nobody knows what a long is does anybody know how much is in a long versus a long long what about an unsigned long long what about a long short can you have a short long is a short long and int platform dependent i know it's platform dependent that's that's the problem is it's just it's crazy c doesn't actually have an avm okay well no big surprise here the integer types in c were designed to uh to be wobby wobbly sized for portability and are in fact wobbly sized like okay we can punt the charbit being weird but that still doesn't help us know what the size and the line of a is this has always been i've always been confused by this i'm sure there's a well-defined very well understood what a long is supposed to be i just don't know what it is uh i know metam chat does move fast but wait there's a standardized calling convention and abis for each platform there are and they usually define the layouts of key primitives in c and some of them don't just define the calling conventions in terms of c types side eyes amd 64 cisv cis5 okay calm down uh okay but there's a nasty problem the architecture doesn't find the api no not the os enti either we've uh got to go all in on a specific triple uh target triple like x86 64 pc windows ganu not to be mistaken with x86 64 pc windows msvc how many of those could there be 176 triples i was originally going to include them all for the uh visual gag impact but it's literally too many for even that that's so many abis it is a lot of abis this is a lot of abis this is quite the nightmare actually uh okay still a language still a language i let's see uh and we haven't gotten into all the different calling conventions like standard call versus fast call versus aapcs versus aapcs vp vfp well at least all of these abis and calling conventions and whatnot are definitely available in a nice machine readable format that everyone can use pdf uh pdfs full of human pros okay well at least the major c compilers agree by the way a pdf it just sounds like the world's worst version of being able to parse out things who chose pdfs like this out of all things to do you think there would at least minimally be something that's not full of human pros subu woo yeah take it out does not equal kids i know don't worry we're not taking out the kids um okay well at least a major c compilers agree on abis for a particular triple target like uh okay sure there's a weird jank c compilers but clang and gc that's my ffi abi checker running on x64 ubuntu 2004 a pretty dang major and well uh behaved platform all it's testing here is some very boring situations where some integer arguments get past by value between two static lib compiled by clang and gcc and it fails yeah clang and gcc can't even agree on the api of an int 128 on x864 linux okay i take back everything i said this sounds like an this sounds like a nightmare this sounds just incredibly unfun because i mean i've built some protocols but at least like anytime you're building protocols everything's just like ah we do we do big end en coding uh big indian and that's that it's easy it's simple all you have to do is just go nothing nothing hard about it this one's just like and they're all mismatched imagine like just the nightmare of hand programming in all of those little oopsy daisies zig is the best c compiler zig is literally the best c compiler it is literally the best se compiler hey prime see you on may 9th hey i'll see you on may 9th in brazil my friend thank you mario we're going to be so we're going to be so in there so in there in brazil may 9th uh let's see okay so that's wild i wrote this thing to thebug uh to check for mistakes in russ se i didn't expect to find inconsistencies between the two major c compilers on one of the most important and well trodden abis abis are lies i wonder what i wonder how zig does all the things it does because isn't zig zig is like the best of all of them isn't it isn't that like the thing that zig is known for being the most convenient on is that it makes life it makes life easy with c it's a lack of building solutions to discover details oh interesting wait zig uses clang oh god zig just uses clang oh no uh let's see how do you interpret how do you interp interp interoperate with this mess well first the option is to completely surrender and soulbound your language to with c which may be uh write your own compiler runtime and c++ so to speak c natively have your codin just amid c++ so the user needs a c compiler anyways build your own compiler on top of a established major se compiler gcc or clay but even these only take you so far because unless your language is literally exposing unsigned long long you're going to inherent sees big portability mess this brings us to the second uh option lie cheat and steal this is a good option this is a good option right here a bunch of if statements you're going to have more if statements than an llm right this is going to be wild if it's all going to be a dumpster fire anyways you might as well start hand translating the type and interface definitions into your language that's basically what we do in rust all day every day like yeah people use rust bind gen and friends to automate some of this stuff but a lot of the time the definitions just checked uh in or hand tweaked because life is too short to try to get someone's weird bespoke se build system working portably nice hey rust what's an int max te i've never heard an int max te okay that's a new one this is a new one for me never heard of an int maxt cool end of story hey nim what's a long long n64 cool end of story a lot of code has completely given up on keeping c in the loop and has started hardcoding the definitions of core types after all they're clearly just part of the platforms abi what are they going to do change the size of in max that's obviously an abi breaking change oh yeah what was the thing uh fantom derp was working on again we talked about how int max can't be changed because of some binary somewhere would lose its mind and use the wrong call convention return convention if we changed it from eg long long 64-bit integer to 128 oh int max is i didn't catch that int max is a 64-bit one but there's a 128 bit oh that hurts that has to hurt that just has to hurt a little bit emotionally to know that int max is not the actual max it just has to hurt but there is a there is a way that if the code opted into something we'd upgrade the function calls for newer applications while leaving the older applications intact let's craft some code that tests the idea of transparent aliases can help with abi lots of [ __ ] uh so like yeah their article is really good and working on some very real and very important problems but how would programming languages ever deal with this change how would you specify which version of int maxt you interop interoperate with if some c header uh you have referred to int maxt which is defined using man this does sound awful i will agree this sounds awful this sounds like an actual int kind of max it's actually int was the maxcore t i can feel the author's frustra frustration in the writing you can feel it you can feel this this does sound like just an absolute nightmare see these are some things that i'm happy that i don't you know there's there's a level of going down the chain and and learning more and more about how things work and there's just a point where you hit that it just feels just disgusting right and i'm happy i haven't hit that point you know i'm happy that right now we're out here and we're just simply doing a real-time asy engine in and go okay just making x's move just feels really really good okay because i get to define the tcp protocol i get to define the server i get to i get to do everything it just feels good for me okay i don't have to worry about everything else that feels good this on the other hand this does not this does not feel good reject modernity return to asom i think we need to return to asom the primary mechanisms we have been talking about uh platforms with different abis are target triples you know uh what's one triple triple what what's one target triple yes unknown there's also unknown unknown isn't there uh linux ganu you know what that covers basically every major desktop and server linux drro for the last 20 years right now you can ostensibly compile for the target and get the binary that just works on all those platforms i do not believe this would be the case if someone program if if some programs were compiled believing in max 64 was larger than in uh 64 4 t so it's just an agreed on convention okay would any platform that tries to make this change become a new target triple unknown ganu too would you even uh would that even be enough if anything compiled against ganu uh unknown linux gano uh was allowed to run on it oh dang changing signatures without breaking abi so what so what does c never get to improve anymore no but also yes because they've shipped bad designs making abi compatible changes is honestly a bit of an art form part of the art is preparedness specifically it is much easier to make changes that don't break abis if you're prepared for them as phantom der's article notes things like lib uh g libc the g is the ganu in x86 unknown linux ganu uh have long understood this and use mechanisms like symbol versioning to update signatures and apis while keeping the old versions round for anyone compiled against older versions of itself oh clever you can add more pluses to see sol the problem i agree if you put more symbols more pluses should just mean more more fixes and then your file extension just keeps growing in peace i think that's actually a reasonable that's a reasonable answer but if you yeah if you hit four if you hit four pluses is it c when you accidentally hit c or does it just keep on being c with many pluses i don't know how this works we're moving to d that's it we're moving to d so if you have int 32t my rad symbol int 32t you tell the compiler to export this my rad symbol v1 and anyone who compiles against your headers will write my rad symbol in their code but link against my rad symbol v1 then you write then you decide to actually it should be n64 and you make it my rad symbol n64 64 as my rad symbol v2 but keep around the old definition my rad symbol v1 anyone who compiles against newer versions of your headers will happily use the v2 symbol and anyone who compiled against the older versions will continue to use v1 i hate backwards compatibility okay it's just the worst except you still have compatibility hazard anyone who compiles against your new headers can't link against the old version of your library the v1 version of your library simply doesn't have the v2 symbol so if you want to hot new features you need to accept incompatibility with older outdated systems this isn't a deal breaker though it just makes platform vendors sad agreed it just makes them sad that no one gets to use the thing they spent so much time working on right away you have to ship a shiny new feature and then sit on your hands for several years while everyone waits for it to be common sl mature enough that people are willing to depend on it and break support for older platforms or willing to implement dynamic checking and fall back crazy if you really get serious about letting people upgrade right away then you're talking about forward compatibility this lets older versions of things uh somehow work with newer features that they have no conception of changing types without breaking apis okay so let's see okay so we can change the signature of a function what else can we change can we change the type layouts yes but also no it depends on your how you expose the type one of the genuinely fantastic features of c is that it lets you distinguish between a type which has a known layout and one that doesn't if you only forward declare a type in c headers then any user code that interacts with that type isn't allowed to know the layout of the type and uh let's see hold on with that type isn't allowed to know the layout of that type and has to handle it opaquely behind a pointer at all times okay so you can make api like my rad type pointer make vow and use use vow myad type and then the same symbol versioning trick to expose make va version one make uh use value one okay symbol and at any time you want the change the layout you bump the version on everything that interacts with that type similarly you keep around myad type v1 and myad type v2 in some type defs uh to make sure people use the right one you know sometimes i don't think i realize just how much of of the shoulders we stand on you know what i mean like i've i again i've never worried about any of these things right now like even with this thing we're building the realtime render if your version doesn't match my version i just don't let you connect i just say sorry you're not allowed to be here get the hell out of here it's just easier because things line up correctly i know it's actually wild how how much of our life is built on that this is actually shocking how much of the life is built on this uh nice we have to change type layout uh between versions right well mostly if multiple things build on top of your library and then starts talking to each other in terms of your opaque types bad things can start to happen uh lib one uh makes an api that takes in my rad type pointer and calls use vow with lib two that uh calls make vow and passes the result to lib one uh oh yeah i know i was just thinking about that if lib 1 and lib two are even compiled against the version of your library then make val one can get fed to use val to yikes you have two options for dealing with this say that it is forbidden chastise anyone who does it anyways be sad two design myad type in forward compatible way so that mixing is fine okay common forward compatible tricks include uh reserving unused fields for future version uses nice just put some padding in there uh having a common prefix uh to all versions of myad type that lets you check uh what version you're working with have self- siiz fields so older versions can skip over new parts well those all sound horrible hm that sounds just awful microsoft is genuinely a master of this ford compatibility [ __ ] to the extent that they even keep stuff they really care about uh layout compatible between architectures an example i've seen recently have been working with the uh mini dump handle data stream in mini dump uh api set header this api has described the version list of values the list starts with this type type mini dump handle data stream size of header size of descriptor number of descriptors reserved nice they got an extra four bytes of oopsies the size of the mini dump handle uh data stream itself if they ever need to add more fields to the end that's fine because older versions can use this value to detect the version of the header and also skip over any fields they don't know about size of descriptor uh is the size of each element in the array once again this lets you know what version of the elements you have and skip over any fields you don't know about the number of descriptors is an array length length reserved is some extra memory if they decide to reserve in the header let's see in the header anyways mini dump set api. is extremely uh meticulous about never having padding anywhere because padding bytes have unspecified values and it's serialized binary format or file format i expect they added this field to make the struct have the size that's a multiple of eight so that there wouldn't be any question about whether the element of the array needed padding after the header wow that's talking about that's taking compatibility serious oh that makes sense yeah because you wouldn't i see what i i see because this would be 64 uh 64 bits 64 bits so instead of having 96 they went to 128 ladies gentlemen just use zig i don't think that's the problem here this is wild okay so microsoft's pretty good at this indeed microsoft actually had a reason to use versioning schema and defines two versions of an array element all right so here's one that has this one has two extra objects right here nice uh the actual details of these trucks isn't terribly interesting uh other than there are only let's see they only change it by adding fields to the end have a type def for the latest one reserve some uh some maybe padding again rva uh is a ulong 32 uh this is an absolutely indestructible forward combat uh compar to behemoth so in other words what they do is they just keep adding fields and then in keep in if i'm reading this correctly and then keep increasing these sizes such that older ones use these earlier ones and newer ones have and skip over the newer fields and the newer ones can skip over these earlier ones and use just the newer fields impressive uh well it's uh at least it's really robust if you play along with the game and actually manipulate things by reference and use field sizes but hey uh at least it's very clear that there's a game to play at some point you don't have to say you're using this wrong well okay no microsoft wouldn't uh say that they just do something horrible instead okay what's the horrible instead oh no i see direct x is this where is this where we get hacked oh man now i want to read dang it now i want to read this oh my goodness now now i just want to read all the things okay i'm not terribly familiar with this situation but while looking into historic g breaks i came across this great article in uh lwn lawn uh the the g libc uh s39 ai break i let's i'll be assuming it's accurate as it turns out g libc has broken the abi of types before at least on the s390 based on the description of this article it was chaos specifically they changed the layout of the saved state type uh used by set jump long jump uh now they weren't combat uh now they weren't complete fools they understood this was an abi breaking change so they did the responsible symbol versioning thing but jump buff wasn't an opaque type other things were storing instances of this type in line like oh you know pearl's runtime f and pearl again i know somebody right now whose mom writes pearl every day and it's like for infrastructure that we all rely on yes way i i i'm actually trying to get her to come on to the show and just tell us about pearl what is it like writing pearl uh like to that i know like that level needless to say this relative obscure has wormed itself into many binaries and the ultimate conclusion was that everything in debian needed to be recompiled ouch this article even discusses the possibility of version bumping libc to cope with this uh the uh s soame bump in the mixed abi environment like debian resulted in two lib c's being loaded and completed or competing for effectively the same name space of symbols with resolution and therefore selection of abi being determined by elf interposition and scope rules it's a nightmare it's possible a worse solution than just telling everyone to rebuild and get on with their lives just get on with their lives uh this article uh let's see is full of lots more great detail i highly recommend it oh man there's so many good things can you really change int max t i still love the fact that int maxt is is 64 bits this is just so beautiful as far as i'm concerned not really it's just like jump buff it's not an opeg type and that means it's inlined into a ton of random structs assumed to have specific representation by a ton of other languages and compilers and probably part of tons of public interface faces that aren't under the control of lipy linux or even the dr maintainers sure lipy can properly do simple versioning tricks to make its a a apis work with the new definition but changing the size of a really basic data type like int max t is begging for chaos in the larger ecosystem for a platform i'm happy to be proven wrong but as far as i can tell making this change would necessitate a new triple target and not allow any binary library built for an old abi to run on this new triple and you can certainly do the work but i don't envy any dro with does after learning about this i don't envy any of it this article is deepening my hate towards abi compatibility yeah this is kind of wild this is kind of wild and even then if you have an x64 in problem it's such a fundamental type and has been the size for so long that countless applications may have weird undetectable assumptions about it this is why int is 32bit on x64 even though it was supposed to be 64-bit int was a 32-bit for so long that it's completely hopeless to update software to the new size even though it is uh it was a whole new architecture and target triple okay so i'm very curious about this cu that's what i always figured that inch should be 64bits on a 64-bit target so it's not that i thought that was like the whole thing int was supposed to be this this wobbly build make it make it bigger as things got bigger oh my goodness it was a lie all the l this whole time i've been lyed to this is why anytime i use c i use like u 64t i do not not use the word long long long long just feels so unreliable a long int can be either 32 or 64 bits i would never do that just just do standard int. and just do just do uint 64t how could just the worst don't use uint max i refuse to use something that doesn't specify a bit long long is reliable long is unreliable you guys so funny you can't just go around longing people's logs apparently you can in is platform specific usually it's 32 bits but uh but a long is either 32 or 64 depending on the platform a long long is always 64 uh but so is a un 64t like you said yeah i'd rather use something with a number in it i'm really into just using a number because you can't screw it up because i don't know all the rules and the rules are too hard size t is also really confusing and it's the worst part of size t is like required all over the place for things like vector stuff that is probably the worst part of the whole thing is just like you want to in you want to you want to index into something you better get your size tea out baby it's not really required well it's it's it's not easy to use other types with it yeah i don't get size t i don't get size t what the hell is size t uh anyways again i hope i'm wrong but sometimes you make a m let's see you make a mistake so bad that you just don't get to undo it uh if c was self-contained programming language sure go for it but it's not it's a protocol a bad protocol certainly but the protocol we have to use nonetheless sorry c you conquered the world maybe you don't get uh to have nice things anymore you don't see england trying to improve itself do you poor england at the end of this whole thing you know england is just hanging out there just not even involved in this whole situation and then england just gets caught with the straight take that england you know what england and shambles america still going america hey did you know that uh in in two years we're about to have our 250th year anniversary so suck on that suck on that america 0.1 commonly referred to as uk just catching strays hey man see to be modernized without sacrificing legacy to compatibility not to break code that has ran for 40 years yeah i mean c is really the worst possible of all situations which i think a lot of people don't appreciate is the fact that we have managed to be able to use a program or use a computer that doesn't break regularly because there is somebody whoever this person is that has to go through and make things work and it's the past that's really holding you down see is like feudalism changing will break a lot of things and some heads chopped yeah it's it's probably so furries could be furries i'm probably going to get i'm probably going to get blocked by more furries by the end of this um all right well hey this was beautiful a furry making the whole world work you know stranger things have been said stranger things have happened okay so 128 bit is a long long long i don't think there's a triple long i mean i wouldn't be surprised if there was a triple long but i feel like if there isn't a triple long we should get a triple long i think you should just be able to keep adding the word long and it just keeps making the int wider cuz honestly that's the only thing and it should be platform dependent make your int longer furries literally prop up modern society it should just keep getting longer okay i think you should kill along i think you should be able to kill along honestly i think you should be able to long long long long long and i think that that should be somewhere between 32 bits if you're on an 8 bit platform all the way up to whatever 64 * 4 is that's 2 to the 2 plus 2 to the 8 right two to the or 2 to the 2 plus 2 the 8 2 to the 2 plus 2 to the 6 got 256 256 i think it should be between those bits a din arc mutex long long long long long i have to agree that a a long short that's 48 bits i think a long short for 48 bits is completely reasonable can we all agree that a long short is 48 bits it should be system width minus 1/4 system width so if you do a long short on on an 8bit you get a six-bit integer i think that's the only reasonable i think that's the only reasonable answer okay we're going to use a long short it it just makes sense i think you should be able to get six bit integers i'm long long long long in height you are please no i think this is the only reasonable thing we should be able to mix and match them all hey the name is gosh i'm so happy i don't work in this area a jet and