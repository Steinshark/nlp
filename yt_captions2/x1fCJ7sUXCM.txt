you can talk to a database using raw sql queries you can use something a bit more advanced such as a simple query builder or you can use an orm which completely abstracts the way the database communication or you can use sign language or smoke signals or binary clouds with or without rev nodes is that a weird joke it's maybe a bit weird anyway each of these approaches has its pros and cons if you don't know about them you risk picking the wrong technology for your project and unfortunately it's a huge pain to switch later on i want to help you avoid that by comparing three options today and show you a few practical examples except for the clown thing so you can make a more informed decision about which option fits best for your project before i started working on this video i had a sort of favorite but now not so sure anymore anyway before we start if you want to become better at reviewing code and detecting problems much sooner i have a free workshop on code diagnosis for you you can join by going to iron.cole slash diagnosis in this workshop i teach you three facts or framework and show you how to apply it to actual production code it's about half an hour very simple to the point just go to ireland.code diagnosis to join i've also put the link in the description the example that i use today is based on a sample database taken from db for community edition you can download this for free i'll put the link in description of this video it's basically a sqlite database that contains customers and invoices among other things and i'm going to use sql and sql queries to query this database in a variety of ways so to show you the difference between just using raw sql sql query builders and orms i'll just use the same query for and this is the query so i'm selecting the id first name and the total from an invoice joined with a customer for that particular invoice and then i'm going to order it by total so this is the basic sql query so what this returns is a list of the customers who spend the most at this particular company so the main versions i'm going to show you is first the raw sql version so that means just running the sql query and getting the results i'll also show you how to use an orm or m stands for object relational mapping i'll talk more about that later but basically it means we're using the power of object oriented programming to define a layer on top of our database and the third option that i'll show you is a sql query builder which is a sort of interface on top of sql to make it a bit easier to construct sql queries and i show you some of the pros and cons of each of these approaches so the first i'd like to show you is the raw sql version and that's basically script that you see here so i'm importing sqlite there's nothing else going on here i'm simply asking hey how many top customers do you want to query then i connect to database using sql lite i get a cursor then i define my raw sql statement so that's what you see here and then i execute that query and for each row i print out the row and that's basically it so there's a couple of things that are happening here one is that you see that we use a question mark and this allows us to replace this with the value that i enter here when i run the script so let me run this so i can show you what actually happens by the way i've created a virtual environment with poetry i did a video about that recently if you haven't watched that i've put the link at the top so i'm running the raw sql files so first it asks how many top customers i want so i simply type let's say five and then it gets that information from the database directly so these are the top customers from the database one of the nice things about using sql directly is that you have direct access to the full power of the sql query language which means that you can do really a lot of things it's really flexible because of course that's how sql was conceived what's also really nice about directly writing sql is that it forces you actually to learn sql which is quite useful if you ever need to query other databases in the future though sql is not one language of course there are dialects so if you have a mysql database or a postgresql postgres sql database or microsoft sql database then it's going to be slightly different and something is going to work and others are going to be slightly different so that's always something to aware of sql is and that sounds not really a standard error dialects but still if you know some sql this can always come in handy especially if you need to regularly interact with the database but there are also certain problems with writing raw sql queries like this and that's why there have been other options that have been proposed for example one thing is that if you're not careful you can easily create a situation where you can have sql injection attacks for example you might be tempted to instead of using this question mark here and replacing it with value to simply use an f string if you do that and that's part of your api then a hacker could potentially create some code that injects into your sql statement and that basically opens up your database to all kinds of vulnerabilities so that's why it's really important to use the question mark syntax in order to construct the query before you execute it and well as these queries become more complex constructing the queries in this way can become a bit cumbersome there are a couple of things that you can do to make this a bit better one thing is that instead of using question marks you can actually use placeholders and then you can use a dictionary to supply the data here i have an example of what that looks like so it's exactly the same sql query except that here i use a placeholder limit and i'm constructing the dictionary here which maps the number of top customers that i read from the console to this limit value and then i execute the query and it provides this dictionary and basically you can use these things everywhere in your sql query and you just add them as entries in your dictionary and then it's going to be replaced in a way that's safe so there's no risk of sql injection that way another thing you can do to make this slightly better is to actually not define the sql query in your python script but do it in a separate file so here i have a version where it's exactly the same except i read the sql query from a file so provide a path and then i'm simply using the read text method from the path class to read the sql file as a string and then i simply store it here in sql top customers.sql and you see i use the same placeholder here and what's actually nice as well is that dot sql is recognized by vs code so you get some basic syntax highlighting here so that it's clearer for you to understand what the query is exactly about so if you were to really use purely raw sql queries then probably you're going to end up with folders with lots and lots of different sql files that contain those queries and then use placeholders in order to input the data in order to modify those queries so it works but in my opinion that's not really ideal by the way if you are enjoying this video so far give the like it really helps the youtube algorithm show this content to other people as well an alternative to querying the database using sql queries is to actually use an orm oram stands for object relational mapping and that basically means you use classes and objects to represent tables and records a very common one or m is sql alchemy in python and i've used that also for this particular example next to sql alchemy there are other types of orams for example django has an orm there's also pv and pony oram and a couple of different options i've used sql alchemy here because it's i think one of the most commonly used ones and it works pretty well so in case of sql alchemy this is what the code looks like so the main thing that you need to do if you use an oram as opposed to just directly using sql queries is that you need to define some sort of schema so that the orm knows what the structure is of the data in your database and then each table in the database is represented by a class so you can see here i have a customer class for example and that maps to the table named customer and that has a couple of fields in there we have a invoice class and we can add more classes here depending on how many different tables we have in the database and an oram typically we provide some helpful features for you to define certain types of fields easily and doing things like defining primary keys or relationships so for example here if you look at the customer class we have something called a mapped column which means that this column is of type integer and it it's a primary key because this is the id field and it's nullable is false so that means id needs to have a value and you see there's other examples here of okay first name is a string last name is string we have company address city so you see in this example these things are mostly strings if you look at the invoice there's also a couple of other things like the invoice date which is a date time so typically an rm is going to provide basic types that map to database types that you can then use and what's nice about this is that if you now have an object of type invoice then you actually have some help from the ide because it knows what the properties it knows what the instance variables are of that particular object here you see an example of how that works so this script does exactly the same thing as i've shown you before so i asked for the number of top customers then i read the database that's what's happening here i start a session and then i create a statement so this maps to the sql statement that i showed you before so i select customer information i'm using the sum of the total of the invoices as you can see all rams also have support for joining things grouping ordering this looks very similar to a sql statement but here i'm actually using classes like customer and invoice so that my ide helps me because for example if i try to modify this i write invoice dot and you see i have access directly to all of these instance variables so creating these queries is a bit easier now because the id is going to help me auto complete things and so when i run this you'll see we get exactly the same result so i want to query again five customers and i get of course exactly the same five customers there's also a couple of issues with orms first is that of course if you want to use an orm you're going to need to learn how the orm actually works just like you need to learn sql except that the orm is going to be specific for a particular platform so in this case for writing python code if you want to write let's say a javascript application that accesses a database in node.js for example well then you come to need to learn another orm whereas if you used sql statements well in javascript though it's going to be exactly the same so with an oram you're really picking a framework and then learning about that particular framework and if you want to switch well that's going to be a bit of work that might also be limitations into what an oram actually supports because it might not support the full set of capabilities of the sql language so you might run into some issues where you still end up having to write particular sql query in order to do something so the orm kind of loses its advantage that way what is nice though is that orams typically work independence of sql dialects so you can use it with both postgresql or with mysql or microsoft sql a known as to worry about the particular database dialect the oram is going to take care of that another thing that's nice is that it's going to have sql injection protection built in because you only use the orm functions like select and join and those will already take care of that for you so that makes things a bit simpler two more potential issues one is that on orm might sometimes have a very specific way of modeling relationships between tables and that's going to influence how things are structured in the database so that means if you use a particular oram and you want to switch to another orm you might actually have incompatibilities in your database and that's really a huge pain to fix and finally if you're doing a data science project and you're working with data and you're in the space where you're really trying to figure out what kind of features you need to add to your table roles let's say you're really experimenting with it and changing the data quite often then an oram can be kind of cumbersome because that means that every time you create or remove a feature from your table you're also going to need to update your orm model although that might not be that bad because at least that way you have somewhere in your code a clear overview of what exactly you expect to be in the database the final option i want to show you is using a sql query builder and this is sort of a middle point between let's say flexibility and security so i'm using a library here called pi pickup if you're using another programming language like javascript or typescript you have something like next yes that which is also a query builder but this basically gives you a bit more flexibility while still solving the sql injection problem for you so here for example i also again asked the number of top customers but then i'm using order query table and some functions from pi pica to actually construct the sql query so you see that i'm using query. from so that uses the invoice table and there is also things like left join group by you can do things like creating a sum of totals you can change the order you have limits and you have a select so it's more or less looks a lot like how it works in an orm except that you don't have the schema it's really built as a system that generates sql queries for you and it takes care of security vulnerabilities such as sql injection what's nice about a query build is that it allows you to create pretty complex functions that might not be possible with an orm so it's typically a bit more flexible though disadvantage of using a query build is that you don't have help from typings like you have with sql alchemy and when i run this code then it's going to be exactly the same as what we had in the other scripts so well let's change the number this time i want to have the 10 most profitable customers instead just to change things up a bit but all of these scripts basically work in exactly the same way so do i have a personal favorite well that's interesting actually when i was working recently in javascript and typescript i really liked working with a sql query builder instead of a full-on or ram because i thought it just gave me a bit more flexibility but i must say the orm option with sql alchemy is actually also pretty nice what i really like about sql alchemy is that it also allows you to easily define a schema that you have to type annotations then when you're writing your queries so i thought that's actually really nice and that's actually better than the query builder and also i must say that typically these or rams are actually quite flexible they allow you to do a lot of things and maybe there are some rare cases where you need a really complex raw sql statements but overall the available options that you have in the orm are pretty extensive so i'd say it's kind of a wash for me whether i really like the sql query building more than the orm version but i'm curious though which of these three options do you prefer do you prefer the full flexibility of raw sql statements or do you prefer the orm which takes off a lot of work for you but um might be a bit less flexible but gives useful type information ide or do you prefer the query builder approach which is really a simple layer on top of a sql statements but that is pretty lightweight let me know in the comments what you think so i hope you enjoyed this video if you want to learn more about how to build an actual back-end surface using fast api which is what you will typically do when you access the database like this watch this video next where i dive into the details thanks for watching and take care