hi everyone in the series we'll be looking at procedurally generating some simple but fairly diverse planets these planets are mainly intended to be viewed from afar as a level of detail system will not be implemented in the series the first task is to create a sphere but not all spheres are created equal this one for example is made up of triangles which gets smaller and smaller towards the poles which means we'd get a rather uneven distribution of detail in our planet a sphere like this is much nicer because all the triangles are roughly the same however each time we increase the detail the number of triangles increases fourfold which doesn't give us as much control as we'd probably like instead we're actually going to start with six separate planes making up a cube we'll then essentially inflate this to get off sphere as you can see the triangles are all more or less the same size and we also have quite frank control over the number of triangles as a further benefit if you want to add a level of detail system it's a lot easier to do with this approach because you can divide the phases of the underlying cube into smaller chunks there is a drawback to this method though which is that these surface normals won't match up along the seams resulting in a visible seam when lit and so we'll have to do a bunch of extra work to patch those up okay so let's start by creating a script called planet and another script which i'm here to call terrain face and the idea is that the planet script will be responsible for creating six terrain phases and telling each of them which direction they're facing and then each terrain face will then construct its own mesh so going into the terrain face script this isn't going to inherit from one a behavior and each torrent face is going to want to have its own mesh it'll also need to know how detailed it needs to be so collect the resolution and i want to know which way it's facing so i'll collect the local up then we can generate a constructor to set all of those and now if we imagine we've got this face and it has a local up direction we're going to want to calculate these other two directions which i'll call x ese and xs b so let me write these here vector three axis a and axis b so we can say x is a is equal to a new vector3 and we can just swap around the coordinates of the local up we've been given so for example i can swap the wire with the x and the said with the y and the x with the z like so then for axis b we want to find a vector which is perpendicular to both local up and xs a so we do that using the cross product of local up and access a alright i'm not gonna create a public method called construct mesh and this is going to have an array of vector threes to hold the vertices so that equal to a new array or vector threes and the resolution is going to be the number of vertices along a single edge of the face so the total number of vertices will be resolution squared then we also need an int array to hold the indices of all of the triangles so we really need to figure out how many triangles will be in our mesh so imagine these dots as the vertices of our mesh so we can say that this has got a resolution of four and then the number of these little faces is the resolution minus one squared and each of these little faces is made up of two triangles so we multiply that by two and each triangle is made up of three vertices so we multiply this by three so we can now set this equal to a new integer array with the size of resolution minus one not supplied by resolution minus one x two x three or just x six all right i am now going to have a for loop for into y equals naught y less than the resolution and another nested for loop for index equals naught x less than resolution as well and in here i'm going to create a vector 2% equal to new vector to x comma y divided by resolution minus 1 so for example when x is equal to 0 the percent on the x-axis will be equal to zero as well and when x has reached its highest value of resolution -1 then the percent will be equal to 1 on the x axis so this is essentially telling us how close to complete each of these loops is so we can use this to define where the vertex should be along the face so i'll create vector 3 point on unit cube is equal to and now let's imagine the top face of our unit cube here so if the center of our cube was at 0 0 0 in the world then this corner here would be negative 1 1 negative 1 and this corner here would be 1 1 1 so to get our point on this face we're going to want to move one unit along the local up axis and then we're going to want to value between negative 1 and positive 1 telling us how far along axis a we are and another value between negative 1 and positive 1 telling us how far along axis b we are so let's start by moving one unit along the local up axis and then for our value between negative 1 and positive 1 we can have a cent dot x minus 1/2 x 2 and then we can multiply that by axis a and we can do the same thing for x s b so percent dot y minus 1/2 x 2 x access b now i'd like to add this point to the vertices array but in order to do that we need to calculate the index so let me create an inter over here so this will be equal to the number of iterations of the in a loop so that's x plus the number of iterations of the outer loop which is why but remember for each iteration of the outer loop we're doing an entire row of vertices so we'll multiply that by the resolution okay so we can all set vertices with an index of i is equal to point on unit cube just in case you're confused by this line this is the same thing as just writing into i equals 0 up here and then incrementing i by one each time we do a loop all right let's now create our triangles okay so if we're at vertex zero so our index i is of course equal to 0 then we're going to want to create these two triangles now we want to define them in a clockwise order just so that the mesh faces the correct way so the first triangle could be for example 0 5 4 and the second perhaps 0 1 5 more generally if we're starting at vertex i then the next vertex in the first triangle would be i plus the number of vertices per line which we're calling the resolution plus 1 and then the next one would be i plus the resolution for the second triangle it would be i followed by i plus 1 followed by i plus resolution plus 1 note by the way that we'll be adding these two triangles for each of the vertices except for the ones along the right and bottom edge since of course for those the 2 triangles would be outside of the mesh alright so outside of the loop i'm going to create an int try index which starts at 0 then inside the loop here we can create the triangles so long as the current vertex is not along the right or bottom edge which is to say x is not equal to resolution minus 1 and nor is y equal to resolution minus 1 so now to actually define the triangle we can say triangles within dex of try index is equal to i so that's the first vertex then i'll copy this twice so the second vertex over the first triangle will be try and x plus 1 and this is equal as we saw to i plus resolution plus 1 and then the next will be i plus resolution so that's the first triangle then we need to do the second triangle so let me update these indices here this will be trend x plus 3 trine 2 x plus 4 and try and x plus 5 and we go i to i plus 1 to i plus resolution plus 1 and then we've added 6 vertices so we want to increase try index by 6 so now to actually assign the starter to the mesh i'd say mesh dot vertices is equal to vertices mesh to triangles is equal to triangles and let's also recalculate the normals now one thing we need to be careful of is if we're updating the mesh with a lower resolution version then when we assign the vertices here it's going to see that the triangles that were existing from our previous higher resolution mesh suddenly are referencing indices that don't exist anymore and we're going to get an error so best to first just clear all the data from the mesh ok let's save that and now going to open up the planet script in here we're going to want to create 6 mesh filters for displaying our terrain faces so i'll create a mesh filter array colet mesh filters and then i'm going to have a method called something like initialize and in here i'll say mesh filters is equal to a new array of mesh filters with the size of 6 and then i'll have a for loop to loop over all of these and then in here we can create a new game object i'll just call this mesh object set that equal to new game object escort mesh and just to keep the hierarchy nice and organized let's parent this to the current transform and then we're going to want to add a mesh renderer so in say mesh object dot add component mesh renderer and when say mesh filters ai is equal to mesh object dot add component of type mesh filter will want to assign that mesh filter some mesh so i'll just say mesh filters id or shared mesh is equal to a new mesh okay we should probably also just give this some default material for now so when we add the mesh renderer component i'll just say that the shared material is equal to a new material and let's go shader dot find the standard shader all right now that we've got our mesh filters will st. you want an array of terrain faces so create a variable for that as well and assign that up here terrain faces go to a new terrain face array also at the size of 6 and we can set terrain faces with an index of i equal to a new terrain face and you pass in a mesh a resolution and a local app so for the mesh let's go mesh filters with an index of i shared mesh for the resolution that's create a public in turn up here give us a default value of 10 and now you make this in a range from 2 to 256 just because 256 squared is about the maximum amount of vertices in mesh can have so we pass a resolution entry here and then local up all we want to go through all the different sort of cardinal directions so let's create an array of those over here vector 3 array directions is equal to and we can just go through this all back you 3 dot up actually 3 down left right forward and back okay so we pass in directions with an index of i know for that okay now i mean to have another method here called generate mesh and in here i'm just going to loop through all of the touring faces so for each terrain face in the terrain faces array we can call face dot construct mesh now i'd like this to work in the editor whenever we update anything so i'll just use the on validate method sure and each time this is called i'll first initialize things and then generate the mesh now we don't actually want to create a new set of six mesh filters each time this gets initialized so what i'll do is say we only reinitialize the mesh filters if the array is currently null or if it has no elements so if the length is equal to zero like so and in this loop will only create a new mesh object if mesh filters ai is equal to null now in all of these mesh filters to be saved in the editor we're going to want this future to be serialized so add a serialize field attribute but i don't want it to show up in the inspector so i'll also just add the items back to attribute all right so i'm going to save that and go into unity i'll create a new empty object in the scene here call this planet and i'll add the planet script to that and as soon as i do you can see we have this cube popping up here and i'm just going to shaded wireframes that we can see the actual triangles on this so as we change the resolution here we should see that being updated very nice okay so now in order to make this into a sphere we want all of these vertices to be the same distance away from the center so the easiest way to do this is just to go into the terrain face and here we'll create vector three point on a unit sphere is equal to point on unit cube normalized now there is actually a better way of doing this which will give us a more even distribution of points but for now this is perfectly fine so we'll just assign the point on unit sphere to the vertices array instead save that and head back to unity and now as soon as this finishes compiling we'll see that we have a sphere instead of a cube now as mentioned at the start of the video we do have these noticeable seams between the pieces i do to the normals not being consistent across the edges which gives us funny lighting but that is something that will be addressed later on in the series that is gonna be it for now so until next episode cheers