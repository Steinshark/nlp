hi everyone our main goal this episode is to replace these simple colors with actual textures before we get into that however i'd like to add in support for blending between these different layers so let's start in the texture datas script we can create a public float array call this the base blends and these will all be values in the range 01 so i'll just add that at attribute and then when a pl material is called we'll of course want to uh set those values in our shader so material. set float array base blends and pass in our base blends array save that and then go into the terrain shader and we'll want to create that variable here float base blends with a size of max color count so now we'll want to modify our draw strength value so that it's not just either z or one but actually blends from 0 to one so uh remember that this value over here this height percent minus base start heights i uh represents how far above the uh start height the current pixel is and if it's negative that means that the current pixel is actually below the start height so if we replace all of this with a call to our inverse lur function fun passing in negative base blends i / 2 as our first argument and positive base blends i / 2 as our second and then this height percent minus base start heights i as our final argument this will give us a draw strength that is zero when the current pixel is uh half the base blends value below the starting height and interpolating to one when the current pixel is half the base blend lends above the starting height the only potential problem at the moment is if our base blends value is zero in which case we'll be passing in zero for both a and b in our inverse l function which means we will be dividing by zero and while the shader won't actually kick up a fuss in fact on my machine it works completely fine uh the behavior might differ on other hardware so it's best just to avoid that all together so up here i'm going to create a constant static float called epsilon which as you may know is a greek letter which is often used to denote just a arbitrarily small value i'll make this say one * 10 -4 and we can just subtract our epsilon value over here so if bas blends is zero then we'll be going from some very small negative number to z and we won't get this division by zero so let's save this now and give it a try just wait for these to compile and we can now go into our terrain assets onto our texture asset and we'll set our base blend size to three and we can now have pretty much limitless fun playing with these blend sliders all right so with that out of the way we can start worrying about textures i've prepared this little texture pack most of these actually come from unity standard assets just in a few cases i've made some uh minor modifications to make it less obvious when they're being tiled but just got some grass rocks more rocks and so on so you can download those from a link in the description if you wish i'm just going to drag these into my project and once this have all imported going to head over to the terrain shader and we're going to start off just with a simple test so in this properties block i'm going to create a texture field i'll call this my test texture and this is type 2d and we need to give it a default value so we just write that as white in quotation marks followed by a pair of curly brackets and then we also want a size for our texture so i'll just call this the test scale and this is a float type can just set it equal to one by default and then we need to declare these variables in our sub shader so the texture type is sampl 2d and then we write test texture making sure to use exactly the same name as up here and then our float test scale all right so if we save this and go into unity and actually locate our mesh material should see we've got a texture slot and a uh scale float so let's go into our textures and pick one of these we just drag the grass in here and currently of course nothing happens we are going to want to go into our surf function to actually apply the texture so we're just going to be overwriting what we do over here uh for the time being so we can say o. albo is equal to and we'll want to use the text 2d function which allows us to sample a texture at a given point so the texture want to sample is our test texture and for the point let's try using our pixels world position on the x and z ais divided by our test scale so since we're using the x and z axis you can imagine this as projecting the texture straight down down onto the mesh along the y ais let's save this and have a look so immediately our terrain has turned green indicating that the texture has been applied as you can see it's very small at the moment so we can up the scale a bit and unsurprisingly since we are projecting the texture downwards the texture looks very good on the flat regions but if we go to a mountain you can see that there is a significant amount of stretching occurring so let us try something different let's go into monod develop again and instead of using the x and zed coordinates let's use the x and y coordinates so this is now projecting the texture along the z ais so if we go into unity we should see that this now looks a lot better but some of these other regions look absolutely terrible and the flat regions also look gastly at the moment if we change this to be y z which is then projecting the texture along the x-axis of course the ground is still going to look terrible but some of these other vertical regions will look a lot better so what we're going to want to do is blend between those three projections based on the normal of the mesh at each point this is a popular texturing technique known as tripler mapping all right so let's go ahead and implement this i'm going to start by creating a float three called scaled world position which will be equal to input world position divided by the test scale and just going to replace this over here with scaled world position. yz all right and instead of setting our output elbo to that directly i'm just going to create a float three to store this in and i'll call this the x projection all right then i'm going to copy this twice for the y projection and the z projection and just change this to be x z and then finally x y we're then going to want to weight each of these according to the mesh normal so we'll add that to our input struct float 3 world normal and just over here we can write float 3 call these the blend axis and set this equal to the absolute value of input. world normal the reason for using the absolute value is just that we don't care if it's negative or positive so we'll multiply this by blend axis dox the next one by blend axis doy and finally blend axis do z we can then add these all up to create our final color so output. albo is equal to x projection plus y projection plus the zed projection let's save that and have a look so we can now see that there is not much stretching going on anywhere it seems to be well textured uh all over the place the only thing that you might notice is that the texture has got a bit brighter and the reason for that is that when we're summing this up uh any of the red green or blue channels could exceed a value of one making the color brighter so we can avoid this by by making sure that blend axis dox plus blend axes doy plus blend axis. z uh adds up to a value of one so all we need to do to ensure that is to now say that our blend axis gets divided by blend axis dox plus blend axis doy plus blend axis do z so if we save this and go back into unity nothing's changed except that the texture is now at its correct uh brightness before we start worrying about having multiple textures i'd like to rearrange the texture datas script a little bit so that instead of having all of these different arrays we've just got one array with all of our information in it so we're going to need a custom data type to make that possible so i'll make a public class and call this layer and each layer will have a texture var variable it will also have a color which i'm going to call the tint along with a float for the tint strength and then a float for the start height and another float for the blend strength finally we'll also need to be able to define the texture scale all right so i'm going to add a range attribute to some of these so the tin strength is between 0o and one as is the start height and the blend strength and then to allow this class to show up in the inspector let's just add the system. serializable attribute so we're then going to have a public layer array called layers and this is going to replace all of these arrays that we had before so now the base color count will will be equal to uh layers. length and in fact i'm going to change this name to layer count and before i forget let me just copy that and go into the terrain shader and just give it its new name there as well as in the for loop where we used it over there all right back in the text data class we now need to set our base colors array to an array of all of the tints for each of the layers so the easiest way to do this would be using link with lambra expressions so let's just say using system. link and then we're going to say layers do select and we want to select tint from each of the layers so we're going to create a little lambda expression here let's create a variable x use the lambda operator and say we get x do tint we can then convert this to an array with simply dot to array all right let's copy this little bit over here and just paste that in so for the base start heights we want to get x dot start height and for the blends that will be x. blend strength then let's copy this whole thing so we'll want to create a new entry for base color strengths and we set this equal to the tint strength and then one for the base texture scales and this is equal to texture scale all right so now we'll just want to go ahead and create these two entries in the terrain shader so i'm just going to copy this and create float base color strength with a size of of max color count and the other one was base texture scales so float base texture scales with a size once again of max color count all right and using our new layer terminology this should rather be max layer count so i'll just copy that and replace it in each of these instances to quickly make sure that everything's still working let's just comment out this line where we actually set the albo to our texture values so we're once again using our colors to determine the albo let's save that and save our texture data wait for this to compile as always and then we can go onto our uh text ret here and i'm going to set this to a size of of six and i'm just going to fast forward the video as i fill in some colors back to normal speed i'm now also going to fill in the textures for each of these so dragon of water some sandy grass and then the grass texture maybe some stony ground and then rocks one and finish it off with some snow now you'll notice that while there is a material do set texture method there is no set texture array method which is what we want so what we're going to have to do is construct a texture 2d array object so to do this let us create little method it's going to return a texture 2d array i'll call it generate texture array and it's going to take in a regular array of texture 2ds call these my textures we can then create our texture 2d array object call this texture array set it equal to a new text array and as you can see it needs a bunch of information first of all the width and height of uh a single texture all of the textures must then have that same width and height then there's the depth which is just how many textures we're going to be storing in this array and then the format of the images and whether or not we want mip mapping so up the top here i'm going to create a constant int called the texture size set this equal to 512 so all of the textures must be 512 x 512 and then a constant text texture format and i'll set this equal to texture format. rgb 565 which is just the 16bit color texture format all right so we can then pass this information into our text to 2d array constructor so texture size by texture size and then for the depth that's just the number of textures so textures. length then our format is just the texture format we defined and we can say true for mip mapping all right let's then loop through all of the textures so want i equal 0 i less than textures do length i++ we're going to say texture array dot set pixels so as you can see it needs an array of colors and an array element so the array of colors we'll get from textures i do get pixels and then we'll just pass in i as our array element all right finally we need to say texture array. apply and then we can return the texture array before i forget the texture here in the layer should actually be a texture 2d so just make that modification and then up in apply to material we can generate a texture 2d array set this equal to generate texture array and we'll want to pass in an array of our textures so we'll once again use this link method just copy that in here and change this to x. texture and then finally we can say material. set texture give it a name base textures and pass in the textures array all right let me just copy that name save this and go into the terrain shader and the way we declare a texture array here is a little bit weird in all caps we write unity uncore declare underscore text 2d the array and then in parentheses we put our variable name let's save this and go into unity and when this finishes compiling we should get an error saying that the texture is not readable so we're going to select all of our textures here and in the advanced dropdown we want to say read write enabled is true and we also need to put this into a format that can be read so let's click click the override button to set the max size to 512 and then for the format we're going to want to use our 16bit rgb format so just hit apply and if we clear that error message now and go onto our texture asset and press update that's all working fine of course the text is aren't being used at the moment we'll worry about that right now so these two blend axis lines i'm going to cut and put at the top of the surface function over here and the rest of this i am going to cut into a new function returning a float three called tripler this is going to take in a float three world position a float scale a float three blend axis and finally an integer texture index so paste all that stuff into there now scaled world position is going to be equal to the world position we're given divided by the scale that we're given the projections we're no longer going to use text 2d because that's not how we sample a text array we instead need to use unity uncore sample underscore text 2d array our first parameter is then the name of our texture array which is base textures then for our aes we need to create a new float three so remember using scaled world position. yz let's create float 3 scaled world pa. y by scaled world pa. z and then for the third axis we need to use our texture index telling it which element in the base textures array it's actually sampling from so here we pass in texture index okay it's probably easiest if i just go ahead and copy this for each of these and i'll change this to blend axis doy and zed and then this should be x z and finally x y all right and then we're going to return x projection plus y projection plus z projection i should also probably correct the number of parentheses here just need to add one to the end of each of these so now coming down to our setf function in the for loop going to create a float 3 called the base color it's going to be equal to base colors is i multiplied by the base color strength index i just want to check that i got that name right it is the base color strength okay then we've got float three texture color and this is going to be equal to tripler now we need to pass in all of our arguments so the world position is in. world pa the scale is base texture scales i the blend axis is just our blend axis variable and the texture index is just i we're then going to want to multiply that by 1 minus the base color strength so in brackets 1 minus base color strength i all right and then we'll set our output albo equal to all of this stuff but just replacing base colors with base color plus texture color all right so let's save this and see if it does anything so we can go onto our text reset here and just say update and what we should now hopefully see if we just increase these texture scales is that it is now actually using the textures to color the map so we've got our grass there transitioning into stony ground which then transitions into rocks and then into snow all right that is looking quite nice let's just zoom in here the scale looks good um uh the water is very not noticeably tiled so let's just increase the scale of that a little bit more and let's also play around with this tint strength option so for example if i set the water to be uh red and increase the tint strength you can see it turns a uh pinkish color and then as we increase the strength it goes to completely red cool so that is where i'm going to leave this for episode 17 we will continue making improvements in the next episode but until then cheers