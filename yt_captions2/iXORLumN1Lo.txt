how's it going guys in this video we're going to be looking at function overloading in python and i'm going to be demonstrating how we can use single dispatch to do this so if you are looking for a multi-dispatch tutorial i'm going to produce that later on on this channel but in this video we're going to concentrate on single dispatch and how we can use that to overload our functions in python because at this point you're probably very familiar with that if you type in a function such as function that's called function and you say it has a parameter of type string and you say print param and we're just going to say string because this is the string implementation and then we define the exact same function under and say this is of type integer and say this is going to be the integer implementation as soon as we run funk hello it's going to say hello int because it only uses the last one defined because this is an interpreted language which means it first reads of course these two lines and then it reads the next line the next line then it uses the one that was defined last so how can we make this so that function with the parameter of type string will be run if we insert a string and the function with the int will be run if we insert an int well one of the first things that might come to your mind is why don't you use is instance to check what type it is and then edit it accordingly and i'll explain later why that might not be preferred in some situations but to get started we're going to import from funk tools the single dispatch and we're also going to import single dispatch method because you need that in case you're using it in a class then for fun i'm going to import from typing any to get started with this we're going to create a simple implementation of function overloading in python so to do that we're going to use the decorator at single dispatch and we're going to create our first function so the func and it's going to take an argument of type any and this is the first implementation this is the default implementation we want this to be run in case it cannot find the corresponding type so here we're going to say arg of type any and we're going to add some optional keyword arguments such as verbose and we're going to set that to false in my case i do not want this function to run if we pass in an argument that has not been implemented so i'm going to insert a not implemented error and i'm going to give the user a very friendly message that says type and inside here we can say type of arg cannot be used with funk so this is the default implementation and you can insert literally whatever you want you can say if verbose print ag and you can also run that as a default implementation if you do not want to raise a not implemented error but this will serve as the base function now let's add the different implementations so to do that we need to refer to our function as a decorator and call dot register and this is going to register it for the single dispatch then we can type in dev underscore and we're going to type in ag of type int or float and you can use this syntax in python 3.11 and above otherwise you're going to have to create a union type but since i'm using 3.11 i can specify whether i want int or float using this pipeline and we're going to type in verbose and set that to false initially now if this is verbose we're going to print a formatted string that says here is your number and we're going to pass in the argument and we're going to return out of this because if it's not for both we're just going to print that the number is the argument so that was our first implementation of the function overloading right now if we insert an integer or a float into this function it's going to use this implementation here but let's copy that and create the string implementation and you can create as many of these as you want depending on what argument you receive but here we will say arg of type string now instead of writing here's your number we can say here's your text or text is the argument so that's a different implementation and i also want to specify that in some situations this is absolutely up to you but you can also define what data type you want to be recognized right next to the register so instead of saying that it's arg of type string you can also say atfunk.register string which might be easier to see or to notice when you're running through your code to see which one does what but both of these ways are accepted so that's up to you i'm going to leave it in here for now because that's what i wrote down in my tutorial so i will follow that to avoid making errors but with both of these being written we can now test it out we can create our usual if name is equal to main check and inside here we're going to run the function with different arguments or different types of arguments and the first one is going to be hello and capital letters and if we run that it's going to say text hello we can also say verbose is equal to true and it will say here's your text hello because it was able to recognize the string data type if we change this to something such as 30 it will change the here's your number because now it recognizes this to be an integer and even if this is a float it will still say here's your number because up here we defined a function or we registered this function to recognize ins and floats for this implementation and finally i'm going to just set this to false and insert a data type which is not recognized such as none and if we run that we will get the not implemented error that says type class none type cannot be used with func so this was a very basic scenario on how you can use single dispatch depending on what data type you decide to look for it's going to run the code accordingly it's important to note though that you cannot use single dispatch in classes and that's why we have the single dispatch method since the concept is nearly exactly identical i'm not going to type this code out i'm just going to show you how you can use it in a class so for example let's say you have a class called computer and you have a function called display because you want the computer to display either text or an image so you have this function called display well again you can define the default function using the single dispatch decorator except this time you need to use the single dispatch method decorator for it to work in a class so for this default value i have def display it takes one argument which can be of type any you don't have to specify this it's just a personal preference if you want it but what this default implementation it's going to check if for both and if it is it's going to give you this verbose displaying message otherwise it will just print argument so just like with the last version we still have our default implementation except this time we had to use at single dispatch method the rest is exactly identical we have the different versions down here so here we have a string version and here we have an int version and i only placed the int in the parentheses here to demonstrate that you can specify the data type you want in the decorator so there's nothing different about using it in a class other than the add single dispatch method now to use this i'm going to create an instance of the computer and i'm going to say computer dot display and we're going to start with and let's say the number 10 and we'll set verbose to true i'll duplicate that and i will also add some text here and the text will be text and we'll set that to false then the final one is going to be the nun type so if we run this now the first thing that's going to happen is that it's going to trigger the integer implementation then it's going to trigger the text implementation for the text down here and finally it's going to trigger the default implementation for the default implementation so that's quite nice and all but why would we use this over is instance well i'm going to copy and paste in the code i had for the implementation using is instance so as you can see here we're not really saving any lines of code by using single dispatch but what we are gaining is some readability because right here we can easily understand that we have different implementations for different input types and it actually creates different bodies here so that might be easier to read and personally i think it actually would be even easier to read if we were to add this up here because it's much easier to spot that this is supposed to be an implementation for int or float so having different bodies for each one of these can increase readability but we are limited to the fact that we can only have one argument to recognize and that's why it's called single dispatch because it's only searching for that one argument and again we'll go over multiple dispatch in a future video but it's still good to understand how single dispatch works before doing that but going back to is instance as you can see it's kind of all put together here and this can become quite illegible if you have lots of is instance checks and you can use the match statement if you want you can use if else if you want but i find the is instance approach to be much less readable and it really crowds your function because if this gets really long i mean how many lines do you want there to be in a function that's a personal preference i prefer the function to have as little lines as possible so even if single dispatch is all one function it feels like we're kind of separating the concerns for each data type but anyways guys that's actually all i wanted to cover in today's video do let me know what you think about single dispatch whether you use it or not or whether i missed an important point that had to do with single dispatch but as always thanks for watching and i'll see you in the next video