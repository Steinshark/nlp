all right your back end is too complicated i've said that before if i told you right now to go and build me a backend api for a new project idea what language would you choose prob right now to be completely fair i would probably choose go rust or zig now some people choose elixir i do need to investigate elixir maybe elixir needs to be my like 2025 language what do you guys think about what do you guys think about that one 2025 elixir i want to use elixir i want to use elixir but i also don't like doing uh functional languages on stream because y'all y'all get so confused at functional languages it's like really unfun to do on stream cu it is just like genuinely it's genuinely difficult for a lot of people to follow it just is it just is and so it makes it it just it just turns into a whole like it turns into an entire like chat skill issue it is a chat skill issue just use c already you scrubs okay we're moving on probably something you're familiar with with but that could still get the job done like python typescript or go right but now i need you to cach external api calls maintain multiple caches and manage a long-running background process that reads and writes from these caches at regular intervals suddenly you've added writers to your stack along with a background processing library and some of you have already started thinking about microservices i can tell you're all done my favorite twitter trope of the of the like super duper modern backend engineer is that you have more microservices than you have users you know i think it's completely fine not to have microservices like yo dog just build the application okay do you do you really do you really want to spend all of your time going that hard on your architecture when 99% of all startups fail like maybe just maybe build the build the gosh dang thing you know what i mean maybe just maybe right tool for the right job myad i left a um use the right tool the right job hey by the way can i say something can i say something you know how i know that i finally made it you know how you know that i finally m like i've actually made it dhh follows me okay my based takes have finally achieved stardom level okay that's that's like that's how i know i've made it all of this [ __ ] on typescript finally got me somewhere okay he quote retweeted me oh i didn't even know that anyways i i actually i genuinely agree actually do want to get dhh on here i think i would love to hear his opinion because he okay i know we're completely off the rails at this point but there's this one that okay i love this tweet and i want to know more about it this i find to be one of the most compelling takes on twitter today which is do the things that you think are beautiful there is something really important about that that i think people don't take enough time to think about which is that like it's it's so so good to be like you know it's so so good to be driven by beauty you will find yourself using and programming so much longer and the the best part is beauty is is totally on your behalf and so if you love type masturbation and you love like programming and just having the greatest types i honestly think that that's okay that's why we sort our docks by sidebar length yeah exactly uh i i do want to get them on here i actually i i love this i actually really i i genuinely like this take right i think there's something really i think there's something very true about that great i have one final requirement this api must never crash damn time to rewrite it all in rust i guess as with every problem in software i think you just need to rewrite it in any language that has errors as values i think that's just the real big thing is that as long as you have errors as values you will never have a you you'll generally never have a problem but b i'm actually i don't believe in the thing it cannot crash i think crashing is a great way to send a message that you have fundamentally violated your program's principles and you should be able to do that effect ts doesn't work though like that's that's the thing so people always say this effect ts you have to wrap everything in effect right like you have to it's an all or nothing library there is no middle ground right let it crash airl yeah yeah i i think there's something really good arz valu is and happy crashing you you have to like everything has to be wrapped in effect for you to be able to be safe from it right and that's but then again you also have just all these other problems if you were to crash in some sort of a async handler you also have to have top level uh uncaught uh what's it called uh uncaught rejection and uncaught exception so there's also like a second level in all typescript applications where if someone has an error it will be a problem on the outside so that's one thing that's really really good in general about errors as values languages and effects you effect you cannot do like effect helps the problem yes but it doesn't it doesn't fix the problem myths yes effect not make your code that much much slower i agree it would never make your thing much slower but it will make your code slower it will make your code slower it will cause more garbage collection it will cause more of that and if you're trying to build a long running service this would be problematic if you're just building lambdas you don't care about your application and how good or performance-based it is you only care about startup time which again great argument to avoid having libraries like real talk if you want fast startup time have less javascript like that's not that's not a like that's not a crazy take so for me it's just that i'm not going to personally yeah prime knows about lambda i know the basic idea of it okay it's not like it's crazy hard thing needs to run less js equals more performance exactly so wrapping every call in a try catch makes it slower because you have to understand how a try catch works i know but this i this is this is silly 99% of people's concurrency problems are extremely simple okay this is this is a crazy take i see this all the time the effects people are always just like oh yeah well what happened if you have to deep bounce and then you also have to throttle and then you also want exponential back off on a single request call i'm like yo maybe maybe just maybe you're making a very crazy api okay maybe you just simply need a promise doall settled and if something fails you just got to handle the thing that failed like maybe that's not the crazy thing to do okay this idea that all of a sudden you need to be able to handle all the crazy timing situations and you're a crud application i'm kind of calling i'm kind of calling bs on that one okay i just am i just am use use effects because you want a bunch of functional composition don't use it because you're like oh i'm going to need all these as c 99% of the time you never need that okay and the 1% of the time you actually need like say an async request queue writing 15 lines of code to write an async request queue not very difficult including a whole ass library just to say that you only want three parallel request at any one time a little rid a little ridiculous okay a little ridiculous there is a better way a way you can handle everything i've just mentioned with one tool you've seen the title by now so you already know i'm talk gleam this seems like a very interesting language i i i really liked their approach to everything i've only read a little bit about it but i i i genuinely liked the syntax i liked the ideas i would like to i mean part of me wants to invest more into it but i have a general rule of thumb which is if dylan mroy loves it i probably won't love it but i love dylan like that's the thing is that i think dylan is a fantastic amazing engineer and anything he builds i think is extremely talented but i just probably won't like it i'm just saying okay i just probably won't like it it's just not for me i'm not that kind of guy shout out dylan moay yeah dude absolutely give give the man a shout out go follow him he's super talented engineer i i i don't say that out of a i don't say that out of a like a negativity i think he's so good look at that i i even follow him on twitter it's just different brain different brain i'm not that brain that's it talking about gleam the types safe simplicity first language expertly baked for massive concurrency high availability and effort of scaling if you're not already sold give me a few minutes and i'll show you just why you should be writing your next api in gleam this is a gleam rest api written using the wisp web framework for simulating pokemon battles and it has two endpoints the first endpoint sl pookemon takes a pokemon name and returns information on the pokemon such as its base stats and available moves this i i do want to take like a quick quick note here this is amazing that it's not like a to-do application test it's actually like a real test this is super cool i absolutely love when people make real like real mock apps it's it's actually super cool i think it it it really does give you a lot more insight into the language than just these dumb basic apps that most people compare like oh we're going to do a hello world test against each other it's just like super cool wow you did 200 it is a poke w p just wants me to see this poke w so bad you can see it look at this he just keeps hitting out that poke w you know it you know pick is just so horned up for it poke did you okay good it didn't hit me i thought somebody might hit me with a pok second is/ battle which takes the name of two pokemon and simulates a battle between them okay but i can do that in another language what makes gleam so special gleam has an incredible static type system it's super simple it has proper some types i do like some types and this is one thing i wish uh go i i go back and forth on this i really do go back and forth on this cuz every problem that i've ever solved i feel like some types is the solution and i wish go had some types and then sometimes i'm thinking maybe i've created a problem that's more complicated than it's needed and there might be a simpler way to think about it and then sometimes i'm like yeah actually there might be a simpler way to go about it and sometimes i do actually find a simpler way that didn't need some types but i do like i do love them yeah they are some types are pinnacle type masturbation but they're also really they're so useful sometimes and no null values inly errors of value that are generally propagated using the built-in result type this makes code more verbose but it keeps control flow visible and simplifies debugging for example here's the logic for the/ poemon route first we check if the pokemon we're looking for is in the cache and return it if so otherwise we make a request to the poke api the use syntax with result. try will return the result if there's an error only assigning the pokemon variable and executing the code below if the function call was successful we do the same with the pokemon's moves before creating our return type adding the pokemon to the cache and returning the the root handler simply calls this method returning it as jason if it was successful otherwise returning an error response with our message all of this it's pretty clean right like i i do i do love this type this style of code generally speaking i do like the result style code i think that that tends to be one of the more nicer ways it's one of those things that i think that go i wish they would i wish they would somehow figure out how to have a idiomatic way to handle uh early returns i still remember you calling sometimes uh just an academic thing i know pick pick everybody knows the arc every programmer goes through okay it always starts off as n that's just stupid then you start liking it then you fall in love with it and then you realize you probably used it too much and then you turn like it's just the it's just the standard curve now this is [ __ ] this is the greatest thing ever we need to use it everywhere actually maybe there's some middle ground that's nice okay i agree dang it stop calling me out po moves before creating our returning an error response with all of this code is very simple to read very simple to write and doesn't blow up in your face the code for calling the pokey api is also very simple we use the gleam http c library to construct and make a request and then handle both the request failing and non2 200 error codes then we use the gleam json library to pass the result into the api pokemon type since gleam is statically typed and doesn't support macros or reflection you are very dehydrated uh false okay look at this this is actually my second leare of water okay so think about that think about that we have to manage jason decoding somewhat manually the json decoder we saw earlier decodes a json string into gleams dynamic type dynamic contains data that we don't know the exact shape of and we use decoders to turn it into something we can represent in the gleam type system in gleam a decoder is just a function that takes a dynamic type as input and returns unknown type usually in a result while more aose this allows us to do some validation logic at decode time rather than having to wait until later for example the poke api returns our pokemon stats in adjacent array that looks like this this would not be particularly friendly for our uses so it be much i do like that i do i mean just just hearing that i actually really like the idea of having a dynamic type supported so you don't have you know one thing that kind of sucks is when you have to know all shapes of your types it is it is just i mean that's like why people love javascript or python or lua or any of these things cuz you can kind of like also just make it work you know i i like that i i i like that experience sometimes you just need to make a something work and that's that and so it's it's nice much better to combine this into a single object that contains one field for each of the six stats here's a custom decoder that creates an intermediate list of api stats objects containing the base stat and the name of the stat and then includes that in another decoder to create a i i did want to see how they handle that dynamic field oh interesting okay okay so this they keep having return they keep having return values and then no return values and i'm having a hard time following what they're trying to do my assumption is this returns a result type i do like to code three is this going to turn into isn't there something in what is it is it lisp that's like i swear it's something like car car car and just like keeps getting longer with more and more rs isn't that like isn't that a thing decode three decode four i assume decode three means you pass in the the object yeah car r r r yeah k exactly yeah yeah cer c c c c so funny object containing the base stat and the name of the stat and then includes that in another decoder to create our desired stats object finally we use our stats decoder in the decoda for our api pokemon and we're all set at this point you might be wondering isaac how did you become such a god tier programmer it was all thanks to today's sponsor cod crafters cod crafters is an on what a great what a great ad transition i'm always so impressive or impressed when they do such such great ad transitions m learning platform for advanced software their courses are all focused around building your own versions of real by the way i do i actually really like this approach i think cod crafters has done a great thing i i really do i really do like this generally this approach of building like a a project that makes sense production grade software personally i'm fascinated by the technologies behind databases so i've been learning rusts by completing their build your own sqlite course each has run in stages instead of being told which functions you need to write and exactly what to do cod crafter's courses are more open and simp i i just don't want to see more open and then have that on my screen okay is is that just like can we just all agree on that one okay simply link to any relevant documentation for the tool you're building you then just push your code to a special git repo that runs some automated tests unlocking the next stage if they pass i love this approach because i'm not stuck using a crappy online editor i can use my vim by the way and i don't feel held back you know i think it's the greatest thing ever to refer to neovim as vim you know why because it is the one true vim it's been the one true vim for for a half decade now it is the truest one true vim okay backed by the slow pace of lots of online programming courses and tutorials they've even recently released a couple of courses on replicating redis and sqlite in gleam if you're interested can sign up using my link which is on screen and in the description for there you go ihh dodev cod crafters ihh dodev cod crafters by the way i do like that gleam gleam was really really smart i don't know or uh lewis uh i believe that's his name the creator of gleam lewis it was very very smart of him to be to like get into cod crafters and get his uh and get his uh what's it called his language as one of the like one of the the building ones because it really gives everybody like that really fast charge that you know how you can build really complicated things with it i think it's i think it's pretty dang smart 40% off your plan and if that's still too much see if you can have it paid from your company's training budget let's talk about concurrency since gleam runs primarily on the erlang beam vm black on black people black on black currency acts slightly different to how it works in other languages instead of running every async function in a single process and switching between them using an event loop concurrent tasks and gleam each get their own process which can be completely isolated from the main process there are two basic ways to use concurrency in gleam tasks and actors we'll cover actors slightly later but i wish i knew more about the actor like the actor pattern or whatever you called it i think it it tower uses it right i really i really want to know more about that i really truly do tasks are essentially jobs that have a single purpose and run to completion you can collect the results at the end of the task but typically you won't interact with it while it runs we use tasks for collecting all the moves for particular pokemon the poke api only returns a subset of move information when requesting pokemon info so we have to call another endpoint to get stats like the moves power and accuracy to do that we map over the list of moves using the task. async function from the gleam otp library to create a new task for each move this calls the get move function which is just an api call like we saw earlier and return to task handle then we call task. tri8 on each handle passing in a timeout value if the task returns successfully within that timeout task. tr await will bubble up the task's return value wrapping it in a result then we have some error handling code that generates a tupal containing our moves and any errors that occurred the word partition makes me feel like i'm not as smart like i know what it means but in this context i have absolutely no idea what's happening like result. flat and i totally understand but this one i just don't and it makes me scared if we had any errors we return the first one otherwise we return all our moves you can avoid all the error handling by using task. await instead of try ait but then the host process will crash if the task process crashes as you can see this has all been incredibly easy and you can pass any function to a task you don't have to mark it in advance using an async keyword thanks to this you don't end up with function coloring a gleam and you can write linear synchronous code and easily parallelize later it's also worth i do like that noting that you don't have to i i like that i do like uh not having colored functions cuz yo f f your colored functions okay go does a really great job of this i like that a whole dang oh it's just like i hate i hate function coloring i hate it i hate it i hate it it's one of the reasons why i've largely stepped away from rust is that i hate lifetime coloring it has struct colors and function colors and that can be just such a pain in the ass to await the tasks immediately like we do here you can just leave the task to run in the background and await the result when you need it even in another function but come on isaac you said also be able to replace our reddis cache it doesn't look like tasks are going to help us do that well that's where actors come in when you're everyone says what is function coloring dang it ryan winchester why didn't you just show up as one of my auto completes ryan winchester here you go this is function coloring thank you for having this pinned i need you to have this pinned at all time for me so i can refer to this at any point okay this is a very important this is like the most important image of this century there you go that's function coloring okay when one of them async they're all async oh that yeah function coloring it makes you have to call functions all a certain way to use it and so when one becomes async they all become async that's why i said uh strs have coloring and rust when one has a lifetime all the functions that have it now need lifetimes out of them i don't i don't even remember enabling auto mod but now look even auto mod's like i don't know i don't know what you're doing out there writing an api in a language that uses async awa or some other implementation of futures your concurrent functions will generally run on a single process this means if you create a lot of futures and one of them has an infinite loop of cpu bound code it could block other futures from completing this makes it very difficult to have long running background processes that can communic i mean it would if you had something that creates an infinite loop at any time even if it's in a different thread it's still going to like it's still going to make it massively hard to run your system because you're just going to be pegging you're going to i mean you're just going to be constantly contact switching and pegging your cpu okay with the main thread in these cases people will generally reach for either an external service like redis or split up their monolith into microservices the beam gives us some other options instead for something like a cash you typically use an ets or llang term storage table which is a concurrent inmemory data store built right into the vm however the etss api is a little more complicated and not quite suited for a beginner video like this one so instead we're going to make a trade-off and use actors actors are long running processes that hold some state and you can communicate with them by passing messages which will be processed in a first in first out order this makes actors a great solution for keeping your apps race condition free i only one m by the way i really really want to see i i've been hearing this talk about and i really hope the olympics by the way really got to make these images bigger but i really hope the olympics does uh do this i think that they should have one college level runner join the olympic run just to see how slow more normal people are i think that that would be fantastic cuz i want to just know how slow more regular people are comparatively to the olympics it'd be ab absolutely fantastic like get a high school runner and a college runner to join in and see like see where it goes that poor slow guy yeah it would look like this it'd be fantastic message is processed at a time so the underlying memory is not shared across processes unfortunately actors can't process messages concurrently so in a production use case there'd be a bit of a bottleneck but this is a silly little app for demonstration purposes so let's take a look at how we can implement a cache using actors i've created a couple of type alyses here to save my little fingers a store which is our underlying data storage for our cash is just a dictionary with string keys the cash we'll be passing around in our app is but how big is his dick will we be able to measure it it's really just a subject that takes a message a subject be thought of as an address where you want your messages to end up you don't need to worry too much about the implementation details for this video but let me know in the comments if you'd like a deeper dive into gleam concurrency the last type we need to define is the type of the messages we'll pass to our actor the set and shutdown messages can be thought of as oneway messages they tell the actor to do something and don't require a return value the get and get keys on the other hand take a subject their constructor which is generic across the return type of that particular message and allow us it's always really hard to show this level of code in a video cuz i'm trying to remember all the previous things and trying to add these new concepts into my brain i always feel like if you just don't have the exact thing already in your head this stuff just feels confusing to the average person walking in to send data back to the original process so sending a get message will return a result containing either the value at that key or nail if it can't be found lastly we create a handle message function that takes in our message and our store doing some work before allowing the actor to continue with the updated store for get and get keys messages we use process. send to send the result back to our client the shutdown message just stops the actor finally finally we create some functions to start a new actor using actor. start right uh with this previous code effectively you can only have like only one thing in the actor can be executing at one time so there's some sort of cue that's behind it that way you don't have like multiple values going in at the same time that's my that's my assumption of what's happening here because they all call actor. continue i think that's probably what's happening and so i think that makes sense send the result back to our client the shutdown message just stops the actor finally finally we create some functions to start a new actor and to abstract away some message sending from the rest of the appliation that seems like a actually only 83 lines of code to allow us to create fully isolated caches in our app we set up the caches in our main function and add them to a context type that gets passed into to every request using the caches speeds up the app a lot and actually helps us stick to the pokey api fair use policy so it's a double win gleam and the beam also have the concept of supervisors in concurrency by the way that is super cool how simple that cash was i mean i know we looked at it and we all could we could all largely agree we didn't understand the cach and plus their caching system is a relatively simple caching system it's just pokemon and its moves so it's like a very one-dimensional cach it's not like something that changes regularly um and so it's very simple to cach and so i just love that approach that approach was super simple it was straight to the point absolutely loved it which are processes that look after other processes but i'll talk about those in the aforementioned concurrency by the way that is something that i i i do think is so super good like if you can if you can just realize how simple your cashing is you don't need to bring in an entire caching universe just to cach a simple request that doesn't that doesn't change you know what i mean i absolutely think it's it's just wild how how often over engineering happens that i mean this was a perfect example of just engineering the problem and that's it it was beautiful video make sure you subscribe so that you don't miss it i also won't be going into the details of the pokemon battle simulation in this video it's very rudimentary and it's all fairly standard gleam with nothing particularly noteworthy involved if you want to take a look the code is all on gith home and i'll probably also use this project as part of a full wisp tutorial in the future the/ battle endpoint simply returns the winner of the battle between two pokemon making sure to use the cash to avoid unnecessary calculations that said we do have one other long running process to wait hold on whoa whoa whoa whoa whoa are you saying that every single time you battle you only battle once and that's that can't a battle i mean couldn't there be more than one result out of a battle isn't that like a possibility isn't there some level of stochastic yes critical hits yeah yeah wouldn't either you win or you lose yeah but there's like some there's some level of stochastic to it you're telling me there's no there's no critical there's no pokemon poke pokemon battles are deterministic well then why would anyone ever play there has to be i mean that's how pokemon works really so there's never a competition i assume i assume there's no competitions ever then you just walk in everyone shows their cards and they pick the one card that beats everybody and then we all walk out is that like how pokemon is that how is that how pokemon works yeah okay that seems kind of crazy that they have whole ass days dedicated to a tournament that everyone just hands in their game hands in their cards and we just call that a day no you guys just told me it's deterministic so i mean that's that's fine that's that's okay that's just how it works that's because pokemon is stupid you just made so many people upset with that one statement let's go let's go to avoid unary calulations that said we do have one other long running process to talk about and that's the battle manager again this isn't special it's just a task that runs infinitely calculating the results of the battles of every possible combination of pokemon that we already have cached i wouldn't recommend this for a production system as the number of battles increases exponentially with each additional poke it's quadratically buddy exponential is when you have the n in uh the exponent not in whatever that you call the the base number i forget what the base number is called what's the what's the what's that number yeah n s is just it's just quadratic uh anyways the bass i thought it was called the bass okay so i'm right i just called the bass i'm b the mantisa you can't just use the term mantisa okay that that freaks people out all right there's the exponent in the mantisa okay we're not going to do that quadratic is exponential many people confuse quadratic and exponential functions because they both have an exponent in their equations the key difference between quadratic exponential functions is where the variable is located oh looks like somebody's right looks like somebody else is wrong and [ __ ] yourself all right no it's called quadratic because the variable's not there that's why it's not exponential poon but it's a fun example for this video and that's about it as you can see gle makes it really easy to write fault tolerant scalable apis the types oh my goodness this penguin is bothering me so much how it's laying bricks did you guys just see that look at system is a big it's robust enough it put the bricks the long way who puts who puts bricks that way who throws the shoe honestly who throws the shoe this is ridiculous stupid penguin enough to allow you to make invalid states unrepresentable but it's simple enough to not be a nightmare to work with or refactor what do you think do you think you'll adopt gleam in your future projects let me know in the comments and if you decide to start using gleam in production make sure to try out the crafter to help you get there want a more basic intro to gleam well i just so happened to have a video made just for you and you can find it right here boom go get it thank you for showing me look at that thank you for showing me my own videos i like seeing my own videos h how great is that uh that was great i like that i like that a whole bunch thank you thank you the prime gen react reddit i appreciate that uh that was a great video i do like the idea of having more gleam in my life i really do i really genuinely do want more gleam in my life but at the exact same time i'm a realist and i realize i just want to do askin coding okay that's it i just want i just want to do aski and coding that's all that's what i want to do okay and so therefore i will not in fact be using gleam i'll be just continuing on down the go path maybe checking out a bit of zig okay because zig is really like the right way to do this problem is my guess zig is the ultimate of it because you can really control the allocations with zig and that's probably the way to go you know that's just what i'm saying you know what i mean you know what i mean you know what i mean anyways the name you got to stay true to your desires honestly so a really good thing for you everyone here cu i hear it all the time how do i not get burnt out how do i do all this how do you program so much programming what you love for some amount of time a week will really help kind of give you the the fury the fire the desire the the excitement that you need throughout the week cuz when you program really boring things and then you kind of develop this distaste for programming and then you don't address that problem and you just let it fester over and over and over again you're just going to eventually build like an aversion so you have to also be able to have fun right like think about this imagine you played any professional sport like let's just say basketball but the only thing you could do was practice free throws like you would hate basketball after like two months you'd be like dude i've just shot 9,000 100 million free throws i just want to play the game no you don't get to play the game we only shoot free throws around here right like it' just be so dang boring it's crazy a jen