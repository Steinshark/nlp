apparently we got signals coming to job jaob script okay tc39 proposal for signals let's see what we got here in august last year i mentioned that i wanted to begin pursuing potential standards for signals in tc39 today i'm happy to share that a vzero draft of such a proposal is publicly available along with spec compliant polyfill so this would be a strawman right is that where they start off at the strawman proposal right what are signals a signal is a type of data that enables one-way data flow by modeling cells of state and computations derived from other state sl computations the state and computations form an en cyclic graph where each node has other nodes that derive state from its value syns and or uh contribute that contribute state to its value sources a node may be tracked as clean or dirty all right i want i want i want i want honesty here for everybody that did not understand what was just said can you press one a too big brain for me i just assume they're talking about uh what's called solid signals effectively when you try to set it if you have other pieces of code that use it it automatically gets re-executed it's kind of like how you're doing it's like an it's it's a one yeah it's like an observable the hard part about observable is you also have subjects and then and but what does this all mean let's take a look at a simple example imagine we have a counter and we want to track right so we'd have this one we have new counter okay can reread it with get yep you get the value out uh can we set it yes we set it and we get a one okay fantastic now let's imagine we want to do that with another signal that indicates whether our counter holds an even or odd number computed signal is we get a value and we ampersand one equals z damn this man's not even h this man's not even hitting you with a modulo 2 equals z going straight in with the amp1 okay oh man you can tell this man's a chad level programmer right here love it absolutely love it avoiding avoiding the divided by operation okay okay nice let's go let's go uh computations aren't writable but we can always read their last value is even even false set to two is even true what is ampersand one it's it's pretty straightforward here uh just for those that don't know let's pretend let's pretend you had the value um uh heximal 45 okay heximal 45 is represented like the following there we go okay obviously heximal 45 is equivalent to 69 nice um and with it uh if you were to do an ampersand one what you're doing is you're doing this value ampersand one is represented like this right there we go fantastic and if you did an and it just does is uh is it one and one yes is it one and one no is it one in one no is it one in one no is it one in one no is it one in one no is it one in one no is it one in one no it produces this which this value of course is equal to one and long as we have this bada bing bada boom you got the idea out okay it's bitwise operations remember everything on a computer is represented by ones and zeros numbers are two uh numbers are base two well two's complement for the negative numbers which it's i can't remember exactly how two's complement goes but all i know is it allows for easy addition uh computations aren't rable but we can always read their last values okay in the above example is even is a sync of counter and counter is a source of is even okay fair fair uh yet we can add another computation that provides the parity of our counter parity seems kind of odd that it called it parody i'm not really sure what that word means this guy must write language specs so we have a parody source is even and is even as a sync of parity even if we change the original counter the state will flow through unidirectionally to parity does everyone understand this pretty cool right it just means that you can create values that react to other values in your code i've been thinking a lot about this do i like this do i think that this is a great idea and i'm gna say something that people might find a little bit offensive which is that i don't know how much i love signals beyond purely ui coding i like it and i'm also worried that it's going to create such an effing tangle this feels like the world's greatest spider web that has ever been created i'm curious how debugging works when you do a get how does walking through the state work deadlocks coming to js you can't you can't create a deadlock cuz they're one way right they're they're they're a cyclic so you can't function pointer are awesome i i feel like it's going to be really difficult the thing is is that at least if you're d if you're just directly tied to a ui element i think we can all kind of agree that it just fundamentally makes sense i want to set a value that just shows up on screen we're we're all we're all on that team but this i don't know i don't want people doing non ui things with this if you acquire two signals uh let's see if you acquire two signals in a row can you deadlock you can't deadlock cuz it's it's it's a cyclic graph anyways i'm just curious what people might do with it and it just it feels like it it it you know like i've never loved higher order components i've never loved higher order functions generally because people that use higher order functions tend to use them everywhere and once you start using them everywhere you start getting into this just like this oh my goodness you just start getting into this thing you know what i mean right it just starts getting really really convoluted and then all of a sudden you are just you're just like hopping into so many function constructions over and over again and it feels pretty pain f whereas i do like like i've used them to solve many of things and i like it but at the same time using somebody else's higher order function set can be such a pain in the ass right starts getting into functional programming i find the thing about functional programming so hard is that other people's functional programming sucks to read and mine is awesome to read uh everything we've done so far seems like it could be done through normal function composition but if implemented the other way without signals there would be no source sync graph behind the scenes so why do we want that graph i recall that i mentioned signals can be clean or dirty when we change the value of counter it becomes dirty because we have a graph relationship and we can mark all the sinks counter potentially dirty as well oh interesting think about the per potential performance implications here people like if people start using these things i mean i'm just trying to figure out why you'd use them for anything other than ui maybe nothing right maybe there's nothing here you could actually use it for reasonably but i worry i'm just so curious about what could be done here right like you have to crawl a graph you know crawling a graph ain't free right it's pub sub for the front end it is pub up for the front end anyways there's an important detail to understand here that the signal algorithm is not a push model making changes the counter does not eagerly push out an update to is even yes this is very it's a pole model uh then via the graph an update to parody it is also not a pure pole model reading the value of parity doesn't always compute the value uh of parity or is even rather when counter changes it pushes only the change in dirty flags through the graph any potential recomputation is delayed until the specific signals value is explicitly pulled we call this the push then pull model dirty flags are eagerly updated pushed while computations are lazily evaluated pulled pub sub sandwich yeah there are a number of advantages that arise out of combining an a cyclic graph data structure with a push then pull algorithm here are a few signals computed is automatically memorized if the source uh values haven't changed then there is no need to recompute unneeded values aren't recomputed even if the source changes if a computation is dirty but nothing reads its values then no recomputation occurs false over uh false or over updating can be avoided for example if we change counter from 2 to four yes it is dirty but when we pull the value from parody its computation will not need to be reran because is even once pulled will return the same result for four as it did for two what i mean by that is that it said this okay false or over updating can be avoided i i understand this principle it only runs things that are dirty for example if we change counter from 2 to four yes it's dirty which should make is even dirty which should make is like parity dirty but when we pull the value of par its computation will not need to rerun i don't see how that's possible because is even once pulled will return the same result for four as it did for two does that mean signals can only be peer signals have no chance of being non-peer so you couldn't make like a counter of how many times something changed h interesting okay maybe i do get it i'm g to be real with you uh i'm going to be real with you i don't understand how the  this uh it does that well it does it it's pretty simple here i i i can draw how this exactly works okay so we have a counter up top in here in here we have something called a dirty flag and we have last value it's pretty simple from here we has is even right is even which has these two flags again we have d and l from here we have one more which is parody when we change counter from two to four it marks as dirty dirty dirty then when we pull with parody it goes like this okay i'm dirty is my effectively is my sink dirty these sinks need to be recalculated because these sinks are used in here dirty is like okay i need to reull from counter because counter is dirty pulls it down bada bing bada boom i'm not really sure how the dirty flag changes in this sense maybe the dirty flags aren't stored on here i probably am storing the dirty flags wrong it's probably something more like counter is dirty and this one probably has uh is even is dirty right it probably dirties it direction and so once it calls this then it can set it to a zero that's probably how it works so it probably dirties it on a per signal basis right it doesn't have a dirty on itself but on the references to it that probably makes more sense yeah uh and then um when it calls here and it gets an answer back out and then this value comes out its last value is the same as its current value which means did it change no so when parody sees that all of its signals though were marked dirty changed no values there for parody does not actually run and therefore we return out its last value does that make sense i that's how i would this is how i just initially recognized this thing being implemented now i may be incorrect here but this is kind of how i'm thinking about it does this make sense i think it does so i may be incorrect here but that's how i read this statement is i read it just like that so hopefully that makes sense um it's a little bit tricky but by the way this is a really good exercise for you guys to do and this is really something you should do more often right really re real talk you should do this more often is you should read something like this and you should be able to implement it meaning that i just was able to take a sentence we read and kind of came up with the entire chain right here of how it probably should be implemented we probably need referential referential dirty flags and i should be able to go up the chain and down the flame we probably need a last value and we need to compare current value versus last value like we need to go through all of this right but i'm not a masus well you can think it you don't have to implement it like can you think through it to the point where you could implement something i think a lot of people don't go through that and think about how things are implemented all right uh we can uh be notified when signals become dirty and choose how to react these characteristics turn out to be very important when efficiently updating user interfaces to see how we can introduce a uh a fictional effect function that will invoke some action when one of its sources become dirty for example we can update a text note in the dom with parody okay we have an effect that uses this the oh man comments on the bottom is crazy this is crazy effects call back is ran is run and the noes text is updated with odd the effect watches the callback source parody for dirty changes okay dude crazy to do this all right counter set two counter becomes dirty at s resulting in the effect being marked as potentially dirty so a poll is scheduled the scheduler begins to re-evaluate the effect call back this is very interesting how they're going to map the scheduler do the schedulers run like uh like promise timing does it get thrown on the kind of the micro q task or how does it how does it how does it run parody begins to evaluate by pulling is even is even pulls counter resulting in a change to value for is even because is even has changed parity must be recomputed because parody has changed the effect runs and the text is updated to even all right so this is where let's see if i'm correct on my my my thought process here the counter is dirties uh its sync resulting in the effect being reran marked as potentially dirty so a poll is scheduled the scheduler begins to re-evaluate the effect call back by pulling parody parody begins to evaluate by polling is even is even pulls counter resulting in the same value for is even as before resulting in a new value from counter but the resulting output of is even is the same as last value last uh is even is marked clean because is even is clean parity is marked clean parity is clean the effect does run and the text is unaffected okay so you're hoping that that level of computation is cheaper than updating the text content of the node itself so that would be the goal of signals which i mean very well could be right hopefully this brings some clarity to what signals is and an understanding of the significance of the combination of an i cyclic sourcing graph with its push then pull algorithm late in 2013 i partnered with daniel erenberg ben leses and dominic ganway to try to round up as many signal library authors and maintainers ers of front-end frameworks as we could anyone who expressed an interest was invited to help us begin to explore the feasibility of signals as a standard we started with a survey of questions and onetoone interviews looking for common themes ideas and use cases semantics etc we didn't know whether there was an even common model to be found to our delight we discovered there are quite a bit of agreements from this part over the last 6 to seven months detail after detail is poured over attempting to move from general agreement to specific specifics of data structures algorithms and initial api you may recognize the number of liaries and frameworks that have provided design uh input at various times through the process so far angular bubble ember fast mob x preact quick rxjs solid star beam spelt view wiiz and more if you store the path you could exit early and save uh uh if the path is long oh really i don't even know what you're talking about it's it's quite the list and i can honestly say looking back at my own work in the web standards over the last 10 years this is one of the most amazing collaborations i've had the honor to be a part of it's truly a special group of people with exactly the type of collective experience that we need to continue to move the web forward important if i've missed your live your library or framework there's still plenty of opportunity to get involved nothing is setstone we're still at the beginning of this process scroll down to the section titled how can i get involved uh what is the signals uh proposal okay this is where it just gets into the specifics of this all this is very this is very very interesting i like signals in theory in practice i'm curious how does signal scale like this is a very interesting uh observation which is you open up the signals tab in the dev tools and there's effectively 1 million individual signals my favorite thing about tooling like this is that there are approximately a dozen teams in the entire world who are building apps with sufficient complexity to make the addition of signals anything other than tech i think the goal is probably a little bit different than that i think the goal here is that signals are meant to be used as a way to design ui now whether or not it's the superior way to design uis is is up to you know is up to people right and i'm not saying they're bad i think solid solid uses them and solid i think is a step better i i mean i like the idea of solid i haven't built enough big things with solid to have any sort of really concrete opinion about it but there's a lot of things i like about it um client state management uh the problem i generally have with client state management is that the client is one of the worst places to keep state there's a few hours there's a few places in which clients are great to have state on but a lot of state just kind of sucks for the web i i i'm you know me i'm more of a server deserves the state than the client does you know i will probably always be that again that's why right now we're building our real time our real- time neovim renderer because i just find it nicer signal sl rxjs are very nice you just need to be careful from back pressure um that's all i have to say to that would you agree that there does need to be a standard client side state management or should that not be standardized at all let me tell you a little secret about standardizations there are 14 competing standards hi 14 ridiculous we need to develop one universal standard that covers everyone use cases yeah situation there are now five competing standard or 15 competing standards obligatory xkd this is what you just suggested and it's not that i don't think you're doing it out of a good place it's just that that's what will happen and i'm going to be check the alt text too fortunately the changing fortunately the changing one has been solved now that we uh that we've all standardized on mini usb or is it micro usb it's pretty good it's pretty good it's pretty good but i mean that's that's the whole problem with these standards right anytime you have a standard you're going to have people that don't like the standard uh but why signals or is it usbc or is it going to be micro usbc uh we read this just recently about how someone created their own database and greatly improved their cloud performance just demolished their their spending in the cloud despite the fact they definitely spent more in engineering hours than in cloud but nonetheless they're attempting to scale for the future uh the problem with any generalization is that generalization works in the 80 85% 90% of the time the other 10% it doesn't work well with and even though it's great and i'm happy we have these generalized solutions sometimes you have to make non-generalized solutions for yourself and this is why client side state is so hard whatever client side state you need is likely very unique for for you and your application it's likely completely different how you want to do it how your engineers think about it depending on the type of technology you choose to use your frontend whether you're going with strictly web components solid react view or some other thing somewhere far in between right it's just that everything has its own way of doing stuff and it becomes excessively hard and i've seen so many bad bad implementations it's good that there's diversity unsure um i don't know if it's good or if it's bad it's hard to really state that because i find that the things are very emotionally painful uh ui a ue5 game needs different state than a wikipedia yes i mean again again i'd be i'd be stupid to try to compare state management in video games to the web signal assumes you never lose state s signal is the state holder right signals is the state holder itself the the the penders people have a good approach they uh have zand which is redux like uh vasio which is a proxy based and joe thai which is atomics based pick and choose but you uh but you know it's the same solid crew maintaining it yeah i mean it's an interesting way i'm still mostly in the uh i'm mostly in the hdmx camp and minimize i i'm mostly as far as i can tell whenever i have to do anything with uis i try to go with uh i try to go with local locality of behavior as much as i can the amount of disasters i've seen with react and keeping state in react and redux is a nightmare and but i've also seen big ones right i've seen some really big ones and they're just such a piece i you know what i i love jay phelps okay i have no i have no this is not an attack against jay phelps i think jay phelps is a champion um but most people don't have back pressure issues okay this is just not the thing that we're going to talk about or even need to think about okay redex just tried to bring elm state management to js yeah and you know like and the thing is is good ideas in one language doesn't mean it's a good idea in every language anyways um uh background motivation design goals okay so it has all the stuff we're going to have to talk about signals proposal does not include and effect api since such apis are often deeply integrated with rendering and batch strategies that are highly framework library dependent however the proposal does seek to define a set of primitives and utilities that library authors can use to implement their own effects hell yeah we're about to get ourselves six implementations of effects people here it comes on that note the proposal is designed in such a way to recognize that there are two broad categor of signal users application developers and library framework infrastructure developers apis that are intended to be used by application developers are exposed directly from the signal name space that includes signal. state and signal. computed apis which should uh rarely if ever be used in application code and more likely involved in subtle handling typically at the infrastructure layer are exposed through sign signal subtle uh these include signal subtle watcher and untracked in the inspection introspection apis yeah i'm still worried about some of this overall like again i always worry because the the the thing is is that you you hear this stuff and you can immed everyone has an immediate use case in their head of how they could use this but you just got to remember that in everybody's head how they're going to use it and what they're going to use it for is going to be slightly different and then you're going to join a company and you have to play this game of how how did my data get there right and and i find that these disconnects can be very frustrating sometimes we add an incredible amount of difficulty just to update a value and sometimes there's some justification for why it exists but i'm not always convinced yes it is there is going to be a there's going to be a terrible amount of weird patterns right there's going to be a terrible we have decided that this wasn't hard enough uh to debug so we're going to make you think about a signal priority order and data lifetimes absolutely um all right let's see uh we interrupt this blog okay oh i do like web components uh i i i want i wish i loved web components more i want them to be awesome but i feel like there's such a pain in the butt sometimes as an app developer how do i use signals i think this this is probably not really very interesting right now but you get this it's just going to be doing some sort of nice little do something beautiful do a little counter oh look at this look at this beautiful counter we got going on here look at that beautiful counter we got even private variables look at that private variable look at that private variable signal accessor value wow that's quite the uh it's quite the modifier clap yeah um okay well i i see enough for it right now i think we all get the idea of signals uh i'm curious i'm curious what the next five years are going to look like for you javascript people good luck i hope that you guys enjoy all of the new features that are going into javascript i i'm just actually one thing that's really funny is that javascript in some sense it's like racing to become like c++ you know what i mean it's like it's racing to see how many features can it cram into a language and it's going to give you every poss way to do something ring zero js is the future enjoy the nightmares yeah like i like don't get me wrong js can be i mean for a ui developing language it is very useful loosey gooiness is truly just needed in a lot of ui development like that's why i enjoy using lua to make the vim stuff is it you know i enjoy the loose goose nature i'm not i'm not against it it's just that there's a lot of difficulty to it as well it's a huge pain in the ass sometimes the name good luck c++ js whatever you call yourself these days a genen