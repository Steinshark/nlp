see skill issues how the white house is wrong for those that don't know the white house recently recommended that everybody should effectively start using rust or go or something like garbage collected language rust because that way you can avoid having me memory critical bugs anyways there has been a lot of running debate on how rust should replace c and recently the white house issued a report urging developers to migrate from unsafe languages like c in favor of safe languages like rust triggering a new round of discussions absolutely my general rule of thumb is the the moment the white house recommends something i immediately now think it's sus i'm like i don't know i don't know if i should use rust anymore okay first you got the rust foundation doing god knows what now biden's up there tell me i should use rust i don't know i don't know if i agree with this world okay now feeling a little freaked out all the sudden time to dip i know i'm dipping i'm out i'm like do just dodging that [ __ ] right right left and right man now the white house is not completely wrong most programmers using c should use rust instead yes yes tell me have you ever have you ever read a sentence that hit so many strays at the same time this sentence is so good oh my goodness oh my goodness i love this it's savage uh but that doesn't mean all of them should my argument is simple c is superior to rust in certain scenarios and in the right hands i love the fact that it's skill issue it it this must be written by a chronically online individual that is absolutely correct it is a kill issue or a skill issue i said kill because i highlight stupid i highlighted and i saw kill and then my brain became a brain okay unfortunately it seems most people are unable to understand my argument skill issue again uh perhaps due to the human tendency to paint everything with a broad brush so in this post i'll explain the argument step by step so hopefully the nuance is not lost and with ample examples so there's no ambiguity there might be a bit acoustic in here okay i don't know i you know i don't think we got any of that that sound foam prevention here all right anyways this post is divided into three parts first i'll explain my argument then i'll address how my argument could be plausible for people that don't think it is and finally i'll give examples okay not everyone should be a sniper agreed let's imagine a team of 10 soldiers all using sniper rifles oh you mean my favorite way to play halo okay can we just be real here for a second maybe every soldier should just come with a sniper rifle because that's the only way i want to play halo i don't i want to quit playing it okay i i'm sick and tired of playing it with anything but dude sniper shoty is the greatest is the greatest way to play sniper shotty shoty snipers it's the best that sounds horrible it sounds hilariously fun okay everybody loves shotty snipers okay it's the greatest uh this team probably wouldn't have great results so shall we conclude that no one should ever use sniper rifles if you give everyone in the team normal rifles and they perform substantially better that would lead to simplistic conclusion that normal rifles are better than sniper rifles yes normal rifles are better than sniper rifles in the hands of most people but that doesn't mean everyone let's say uh eric is a really good sniper so his team is reassembled with nine normal rifles and eric with a sniper rifle now the team does substantially better uh with 10 normal uh riffles i do got to make one small comment i love that there's just like this this nice gentle description of people getting absolutely murdered as a way of being like ah now they're better they're just doing better now the mixed team uh did better because it embraced the diversity of human capabilities the potential sniper rifle has in the right hands the understanding should not be controversial the notion of using the right programming language for a particular job is common you wouldn't use c to run a bunch of programs in a certain sequence shell script is better for that and you wouldn't use javascript to write an operating system kernel some people are better at javascript others at ruby others at php and that's fine c excels in certain tasks like system programming and low-level libraries by the way this is like the greatest he's making a great reason why you should learn zig honestly zig zig is might be if if i wasn't in my go arc right now i think i'd be in a zigar uh rust is probably better than c in other tasks say for example a graphical widget toolkit gtk plus so yes if if gra graphical widget toolkit is written in c it might make sense to rewrite it in rust the same applies to other tasks perhaps most but not all rust advocates argue that rust should replace c in all tasks and this is what i strongly disagree with they would argue that rust is inherently safer than c and it should be used even in systems pramming where c is king i do not disagree that many code bases of system programming using rust instead of c probably better but again not all okay okay okay i mean so far i'm actually i'm tracking with everything he's saying do does anyone have any disagreements i have no disagreements so far which is i'm sure there's some things that i think c is just nicer at or c++ or any of those kind of things sometimes it's nice it's nice to have a little bit more you know a little bit more loosey goosey you know what i mean i like loosey goosey if all the currency uh code were written to be rewritten in rust the world would be a better place yes just like if all 10 soldiers use normal rifles instead of sniper rifles the team would be more effective but that doesn't mean eric should give up his beloved sniper rifle and use a normal rifle instead just because everybody else sucks at it yes yes yes it's not my fault that everybody else sucks at it there will always be a place for c even if it's 10 times more rust code because there will always be people that can make seash shine the basic versus aces rust advocates love to share lists of security vulnerabilities found in c code and they use it as proof that no one can write c code safely by the way right now there is actually a rust unsound compiler bug in which you can cast uh you can cast uh lifetimes to static and be able to access memory that is gone right and you can do this safely in rust right now it's not like rust is is completely immune to problems oopsies right let's suppose that most c code is actually unsafe and poorly written following the sniper analogy couldn't it be because nine out of 10 c programmers actually suck at it what about eric what about the top one out of 10 that are actually exceptional i'm going to call these top 10% aces in the bottom 90% basics i love skill issue articles okay i don't know what it is but this is also the exact same argument that you hear like when it comes to misusing uh any technology right anytime someone says oh you you have a complex react app that's because you just don't know what you're doing it's just skill issues everything is a skill issue every i'm just a basic [ __ ] trying to write some basic ass programming and yes i'm r i'm riddled with skill issues okay just just let my basic [ __ ] self be basic my argument is that you shouldn't use the performance of the basics as proof that asis should give up c and use russ and said someone with poor understanding of statistics might argue that it's not just the basics all c code is like that not true if you administer an exam to 10 people and nine of them score one out of 10 while one person scores 10 out of 10 you might conclude that everyone failed because the average is 1.9 but that's not how statistics work well the the the median is also one have you thought about that one the did you know that the the the 90th percentile was one so is the mode so is the mode redpilling the nfs i'm not sure what this word means this looks german to me can some german ass person tell me what the hell that word means it's naive okay redpilling the naive if you accept that caes might exist then you can move on to the next section where i provide examples of how ces write significantly different code if not the next subsections are meant to open your mind to the possibility that rabbit hole runs deeper than what you might have thought and thus you make you question what you think you know not just see but statistics and everything damn let's get red pilled neo me and you we're going deep let's go we we baguette baguette ajama kapel 2 jamel michelle uh the few that carry the team okay in my synthetic example of one exceptional student the average is not representative uh but surely that doesn't happen in the real world right did you know uh do you know that every open source project most people are below average number of commits that's right most people are below average here's a graph showing the number of commits per contributor to the linux produ project it's funny it's this is a funny graph what this really says is one person typically holds up a project and the rest don't do nothing okay you know if he would have used a logarithmic curve it would have looked really nice statistics can we all just agree that statistics are pretty fun uh all right the average is 37.4 commits while the median is three commits 88% of the contributors have less than 37 commits that means that 88% are below the average this mean this may run contrary to most people's intuitions but that's because most people have a only rudimentary knowledge of statistics this actually runs exactly how i think any open source project should run unlike i mean that's just because i'm old enough to know that inner source doesn't work and that anytime someone says you should do something specifically this way because everybody at the company can contribute is lying to you lying to you and you're about to do something that you're going to only be the one holding up and that you're going to hate your life just saying unlike what you may have been told university most distributions are not normal distributions but power law distributions especially when it comes to matters of information what does it mean it means you probably don't know much let's see as much about statistics as you might think you do and therefore the conclusions you might have drawn from the overall performance of c programmers might be flawed too have you heard of a prao principle in proficient let's see if proficiency and c followed this distribution then 20% of programmers would have 80% of the skill sets of course the ratio is not necessarily 880 20 it could be very well 9010 or 6040 or anything like that graphs i'm not exactly sure what this graph is trying to tell me but there's graphs here okay yes number of commits is an indication of quality or anything like that there's the there there isn't any indication here he's just talking about how often does somebody commit to a project meaning that most people don't commit to a project most people have some ancillary set of commits while most people just while the individual a couple individuals pretty much hold up a prod right that's what that means okay therefore my example is not far-fetched uh at all reality could be pretty close mount stupid versus dunning krueger effect this is me this is my favorite place to be is mount stupid because everything is amazing and nothing is bad can we just all agree that we want to be here if i could live my life here and be happy forever ah hey that's me hey yeah you don't know about this do people not know about this this is like every learning curve you'll ever go on right i remember every time i've learned every technology you do this you think it's just amazing you start using it you misuse it wrong a bunch of ways you realize how bad you're using it it totally sucks and then all of a sudden you start learning how to use it better and then you really like it this is how it really works all the time i think there is a loops after the valley the sometimes sometimes it looks more like a learning curve that that's uh non-differentiable but that's different but then you learn to hate it yes then the then the hate happens a lot of people would associate the dunning krueger effect with this graph and you may be thinking i bet the author is suggesting i'm peak of mount stupid and i actually don't know much there's only one problem dunning krueger ha effect has absolutely nothing to do with this graph this is the graph that most correctly depicts the dunning krueger effect it feels bad because i don't understand it so this makes me feel like i'm stupid hurts a little bit uh is this so so in other words is this graph trying to say that most people never learn who they are and thus they fail the art of war know yourself and know your enemy and win every battle they just actually don't know themselves or their enemy and they lose every single time is that what this is saying yeah yeah i would say that well i mean there's no there's no lines here so we don't know like what what the distance is between these two points there this is all relative but yes this line tends to be down here and this line tends to be well they they they start at the same point and then the perceived goes up to here whereas the actual goes like right here so there's definitely like a nothing to a whole bunch to then it like slowly goes through you know what i've never had a point in my life i don't think this happens for me like the green part i don't think this is green either i actually think this is worse than green in fact i would color i would say that this is not as bad as this and what i mean by that is that if you're really good at something and you perceive yourself as not being good at something like you're a bigger idiot than someone who thinks they're good at something and they're not you can't even tell what good is somehow that's just feels worse but you do less harm do you i say you do more harm because you have the ability to steer the ship but you think you're too stupid to steer the ship you're wasting potential like everybody starts here we we we're all this side of the graph everybody starts off in the red side so nobody thinks that's like bad that is called this is called life this is called getting experience and this is really where impostor syndrome sets in i mean the problem impostor syndrome is a completely different topic impostor syndrome can be very in my opinion can be very simply summed up you think too much about yourself there you go if you think more about the problems you've solved and the things you're working on you'll have much less time to think about yourself and much less time to gauge other people and guess what you'll find that you're you're more confident at at solving things all right anyways but this part it just means that you have the ability ities you just don't use them like crazy okay the irony of duning krueger effect which suggests that people with poor knowledge on topics overestimate how much they know about the topic is that people with poor knowledge of the dunning krueger effect overestimate how much they know about the dunning krueger effect okay this is this is a great article i'm loving this okay can we just all agree that this is fantastic just for a second can we all say this is fantastic i don't know who came up with the mount stupid graph above but they clearly did not read the paper of jay krueger and d dunning and most people who mention dunning krueger effect don't do not know what it actually is i misread that but you got the idea and the exact same applies to the ca language people with poor knowledge of c overestimate how much they know about c fair i wrote drivers for network cards and flash drivers in c for two years and i can tell you this and and planetary pancake motors and cameras and crap like that i can tell you right now i don't know see as someone who's done a lot of c i'm not that great at c we even on this stream uh we even on this stream did uh i did a test where i thought i could write a linked list in c using only exor and we were able to do it i said in 10 minutes and it took me like 12 minutes okay it just goes to show that i'm not i have and i'm sure there was bugs in it but somehow i proved that it worked i know nothing about c and every time i use c i always get i always just feel so much stupider than i think i am so you basically underestimated yourself yeah i know i did self-owned uh let's see so you may have heard from a person with decent knowledge of c that it's nearly impossible to write c safe or safe c code but how would he know if he doesn't even know how much he knows about c facts and logic atheist all right are you starting to see the metacognition problem skill issue my life this should this is going to be on my gravestone i hope you know that that when i die i i pray that either i get turned into ashes and launched into space or i get a gravestone that says skill issue uh hopefully at this point i have provided enough examples of statistics and the dunning krueger effects to make you question what you uh think you know about c might not be accurately represented what you actually know wow i could sorry i think i had a stroke did i just have a stroke i think i just had a stroke um you get the idea is it possible that in order to accurately assess how feasible it is to write safe c code you would need a level of skill that most people simply do not possess fair by the way i do have dyslexia so i really have to try hard okay i'm trying hard here people don't make don't make fun of me uh in other words the ability to assess if there are skill issues in trying to write safe c code is in itself a skill issue the issue is not solved by relying on the opinion of some respectable member of the industry because they themselves might not know as much as they think they do and you would not be in a position to figure that out the problem with this argument in general that i'm kind of hearing is that this argument can be boiled down into a different way trust me bro why should i then then like by the very nature of this argument i shouldn't trust this guy so why should i even trust this guy's opinion about this topic if i'm not even sure if he understands this topic right the problem with the the problem with the continuous distrust argument is that then you can just trust nothing right like it just it just continuously just eats its own self it's the snake that never stops eating itself so it becomes the trust me bro he's eric i'm not eric i could tell you that much i'm not eric this issue is not solved by relying on the opinion of some respectable member of the industry we already read that in other words in order to accurately assess how powerful the sniper rifle can be you probably should be asking an actual sniper not somebody who wrongly believes they are a sniper but how do you know that they are a sniper or not even if they're a respectable member of the industry i don't even know how unfortunately there's no objective way to det okay he answered my question to determine who's exceptional c programmer and who isn't you need an exceptional c programmer to tell you that it's a self-referential problem if let's say i could tell you i'm exceptional i'm an ace who can point you to other aces but how would you know and for that matter how would i know i could very well be overestimating my uh own abilities as well okay facts we're going to just skip on okay here we go let's consider the simple example of allocating some memory and assigning some values and doing that uh and and something with that okay struct person we got 50 bites plus a little injur plus a little po or two uh apparently another point to itself all right struct person john uh struct person we're going to malik the size of the person if john equals null returned memory issues imagine having memory skill issues right now this guy's so smart he outsmarted himself you don't go toe-to-toe with a sicilian when death's on the line that's just what i had that's like what i'm thinking about right now me said size of john this person okay stir copy john name john doe john h25 do some stuff john free john zero i'm all about free and john can we just free john stir copy ptsd i know he didn't even use stir and copy i don't even think this guy's a real programmer okay can we all be real here for a second the man's over here throwing in stir copy and not stir end copy yeah right like i'm going to trust this guy he didn't even bounce check he didn't even bounce check to make sure that john doe is less than 50 characters which is the hardcoded amount what what about the assert where's the assert sir copy's more efficient yeah but he didn't assert so i don't believe him he should have had a he should have had a debug build assert so we know he doesn't uh this is very typical way of writing c code but right away i can tell that this person who wrote it is not a season developer get him get dunked on uh the hot dog dipped all right first of all size of struct person is unnecessarily verbose and we can do size of john instead okay that feels like a nitpick and i didn't know that a skill issue okay i already have skill issues [ __ ] i'm already skill issued i am literally already skill issued but this does make sense right it i mean it does make sense right it does make sense okay shut up uh this way we don't need to specify the type of variable and if the the type changes we don't need to change this code i mean really honestly that's fair this is really fair at first i thought this was the nitpick but the more i think about it the more i think this is actually pretty good okay second malik returns a void pointer uh and anyone with moderate c knowledge knows that these pointers do not need to be casted so the line to be cleaned up would be this i mean it's really making me question all my skill issues next jn equals null is unnecessarily verose not jn is simpler is it i don't know i've never liked this so i'm one of those people so i'm i'm a huge i'm a huge proponent of when i'm in like when i'm in this and i have like uh const a equals a string i always go if a.length equals zero right i'm not someone that write uh if not a.length right i don't like that i've never been like that i i i prefer this way i understand that it's it's it's verbose but i i am much more of a fan of this than i am of this and you could even go all the way to if not a right if not a is literally equivalent to a like length equals zero right and so for me it just conveys a more understanding or it conveys more intention in my code so i'm someone that likes to convey as much intention that's not true it is literally true when it comes to a string they're literally equivalent okay don't question me i know but but a is a string okay we've already determined it's a string you're probably using js doc or typescript or something and it's a string okay we're not talk okay here assert a type of a equals string there you go are you happy we've asserted it it's now a string it's it's guaranteed to be a string so shut the hell up about a oh what if a uh atheist redit tier atheist what if a is a number got him no one's doing a number here okay shut up what a stupid argument we're talking about strings you dummy got him checkmate dude [ __ ] people and then we could use the same size of john trick with m you did a number on him oh assert it not inserted i did not say insert it okay i want you to know i said assert asert um call but it would be much easier if we used cic instead of malik uh and then the memory is zeroed at the same time as allocation let's go but that's not the linux style the linux style is straightforward with no nonsense struck person named john age 25 ooh this is something what is that is that like c11 [music] [ __ ] is bro using is that damn bro's using c1 isn't he that's c99 no it's not is it didn't this come isn't this like part of c++ 11 or 14 or some [ __ ] actually c++ 20 yeah add it to c++ way later okay okay my bad i i a lot of my c knowledge comes from me having some inclination as to c++ my bad my bad my fault let's see let's see does this do the same as the traditional code yes traditional trad code uh when the function is called there's a place in memory for all the information related to this function and this includes local variables when the function is exited the memory is repurposed this is not even a feature of c this is a feature of the cpu c being a low-level language makes the cpu features transparent so the definition inside a function we allocate the necessary memory automatically and you can initialize the memory at the same time what about zeroing the memory i didn't set boss member to null therefore it'll be garbage there right no if you set one member of the structure all others uh all others members will be zeroed oh i didn't know that this i actually didn't know this i actually did not know that's kind of cool i didn't realize there was zeroing when you initialize like this uh but that's not all uh if we make variable static then all the memory will be zero even if we don't initialize anything but more importantly the data will be part of the program so it will be set even before the function is called thus saving time if the function is called multiple times the data would have to be copied over the uh to the stack over and over now i could attach assembly code to of this program with a variable as static versus non-static just to show how much of a difference a single keyword in c makes but that would probably be too cumers uh cumulative too cumulative and cumbersome cumulative is cumulative even the right word there uh and hopefully at this point you are uh already minable to my uh premise that there's orders of magnitude difference between beginner uh inc and expert well the problem is again you can't just toss out static like this because one thing that you're not saying with static is that you can't just static everything because your program will take up as much memory as a javascript you can actually you can you can static everything guys we can static we can static everything it actually is true we can static everything i i don't i can't believe that but it just all you're doing is building programs as big as um javascript and they'll be super fast so my bad i'm i'm i'm the stupid one uh to be clear comparing the assembly code generated by different c codes is not overkill it's something c experts do regularly judo you're kind of like my c expert in this chat judo do you compare different compilers regularly bold words are those bold words you do okay you do i do okay okay looks like we got some c experts in here it sounds like we we actually have a litus test litmus i said litus that's like how much of a dunny krueger dummy i have i am okay i'm like so stupid that i'm not even using the right words trying to sound smart but i'm not litmus test li igma test um what's compiler okay i hear you but what's a compiler can we just take a second to address this uh it's what god bolt. org is for it is what god.org is for uh the ligma test dude i can't wait to have a little bit of ligma test i have i have dummy krueger uh let's keep in mind uh let's see with different compiler options and even different compilers one single line of c code can have tremendous amount of work and be thought behind okay let's keep in mind that this is an absolute most basic example i could think of and already the difference between a beginner and expert is substantial let's keep going i'm actually excited about this okay so we got a little node data with an in value a little node with a void pointer to data interesting and the next node okay okay okay classic linked list is what this looks like i think we can agree linked list linked list here we go uh list list for each struct note head void call the next thing with two void pointers uh void user data okay okay struct p head equals that bad boy while p that's the average stream of mine next note equals next if let's see call the function with the data and the user data p equals next okay fair fair list free go here do the same thing call this data that you're b the free free the p you know i've was taught once you should not free the p uh go to p next let's prepend do a little bit of size malik of this bad boy if we can't do it you should really do like some sort of if you can't malik a node you really should do something more than return all like can we all agree that like if you return n if if if you can't maloc anymore like your program's done what are you going to do i mean i guess you could say if you're managing your own memory and you have your own areas and you try to like free it all up then yeah maybe but this is pretty much a panic for the average person the average person is just effing effing it all up all right we got a little head we got a new head and some no data we're going to do this bunch of malx blah blah blah blah a lot of return values we're going to set it all up and then we're going to for each on the head and then we're going to we're going to free the head we're going to free the head and free the p okay so this pretty good because this code is generic it' be uh if we were writing a library by the way is anybody here confused about what this code is doing right this is pretty straightforward code i mean honestly this is besides for this right here this is pretty much what i would be writing if i were writing c like i'm not that great of a seas seesm ship you're lost it's okay so this is just a call back the call back simply says i'm a function that doesn't return anything and i take two pointers i take two pointers to i don't know what a void star literally just means i don't know it's something and the compiler's able to the compiler's able to deal with this because void star has the definitive size whereas what you're pointing at may be anything that's all it means it just it just me means any literally void star is any of the of the 80s the list iterator implementation is pretty uh the list iterator yeah it's pretty good this is a great little function right here by the way i i think it's pretty cool right that's all it means i'm a little confused why the user data gets passed in on each function call right like i don't really understand that this just seems like it's complicated for no reason like to me it should have been a struct head void function with a single pointer pointer to the data itself right that would have made more sense context i know but why would you need context if you're having that like you're iterating in place right like look at this he's even passing in null because it doesn't make much sense i don't know that's all i'm saying okay uh context to the user call back okay fair fair okay maybe i'm wrong i'm just saying it's kind of weird i a little weird this c code is not good okay this c code is not good we're about to find out why because this code is generic it would uh like it would be if we were writing a library the structure where we're going to store our custom data has to be separate from the structure where the generic node information eg next pointer therefore yeah for those that don't know like you can't just do a generic right you can't go struct node generic t and then next being a pointer to t you can't do that this is se dog okay you only raw dog you raw dog your cpu okay we raw dog cpus around here uh for those that don't know uh yeah exactly se dog you seog them therefore every time we want to add a new to the list we have to do two memory allocations one for the node and one for the node data this is cumbersome but that's how most people would do this task and for example that's how it's implemented in gb so what you're trying to say is gb's a bunch of bunch of rookies bunch of skill issues most people would not bother checking if memory allocation succeeded they would let it let a segmentation fault happen which might happen anyway and that would make the code much simpler but here i want to show how properly checking these allocations would look like that's not the linux style though how would c do this how would a ca do this did someone just mention se dog yeah someone did did mention se dog all right let's find out we got a a a list an l list head an l list node and a node okay okay i'm trying to hold i'm trying to make sense of this so i get the node the node is literally a node is just a pointer to the next node a node contains a pointer to the next node or contains embeds a struct that points to the next node and has an int value so he did interesting ahead i'm getting aced so hard i'm confused at how node even works because node points to list node but list node does not point to any data first off what i consider a big faux pa in any data structure implementation is when the head is has a different implementation than the node i really dislike that right and so a node it's pseudo code it's not pseudo code this is code code okay this is literal code so i dislike that a node is a node which is a node that's a node all right struct node this is the part that okay so let's look at these defines okay first off using defines i think you're just an evil person just so you know that uh list for each position note i don't understand why you'd want to do this ever can't you just call can you can you not tell see the inline of function does it just not always inline of function is that why um all right list for each position node we're going to go over this thing position node equals node i no idea what's happening here four type of node position node pass pos equals next oh oh this is naughty wait a second is this super naughty code this looks like super naughty code all right list safe for each uh four type of node node position equals position n position n okay okay i think this might be super naughty code i think this is it's super normal c list code is it it feels super naughty i i i dislike when you have half of a statement up here uh let's let's see okay list l list add we take the node we do this head first let's see new node next equals head first head first equals new hold on next equals next equals the head n next equals the true head first equals this okay yeah okay that makes sense node add all right so that was l list ad node add so we have a separate thing for just the node i'm confused by that why just this feels more confusing i'm confused at this one okay so we create this struct i still don't know what this does like honestly i have no idea what this does it feels like it's separate from list maybe that's why i don't understand it is that list is actually completely is completely or they they they store the data completely orthogonal to the actual item i think this is i think that's what's happening i think i again skill issues okay so i understand what's happening here uh test we're going to go through here we're going to create a new list we're going to calic the list zeroed out we're going to add to the list goto okay list experts do they use goto as well in see clean up yes [ __ ] damn it you know it's like i try to get them and then they say yes okay it's comment well [ __ ] and i guess i'm the stupid person i guess i'm not the ace cleanup we're going to go through each list free okay so the problem i have obviously with this free list can i be real here for a second the thing that i have a problem with this free list is that it's a single instruction that's all you can put here so for those that don't realize this you can't put more than one instruction or one statement in this for loop so that's why they do it this way i know please wrap that i know so so that's that's what i was thinking was there's no curly braces here so this is a single statement you can with that yes but this is not like you can't just do this you can't just do this you have to do it you have to put the little squirly braces yourself which feels terrifying i feel scared okay i feel scared free the list return r i don't know okay so i don't know if i like this better but maybe this is what is this what experts use is this really like for those in chat is this really what people think is really this is good c this is good c is this good c peak performance damn c is hard okay see i told you i'm not good at c it's clear that i'm not good at c it's clear i'm not good at c okay it's tom c peak c is a nightmare then i can be i can be completely fair that i i understand c but my c professor would have considered that bad practices well i would assume so too but i'm being told that i'm wrong uh the first thing uh to notice is that there aren't multiple allocations that's because every custom node contains within itself all the generic node information because the struct l list node uh element is the first element inside the struct it's by the way it's link list for those that don't know what list uh first element inside the struct node a variable of type struct that can be accessed by str struct list node at the end of the day it's just memory and all the information is there second thing to notice is the incredible useful macro list for each it traverses a list with a for loop but that is hidden inside the macro this is syntactic sugar to make life of the users of the library easier yeah i guess i guess if i always used macros and i was used to this maybe that would be easier maybe that would be the expectation but the problem is i guess since i don't use c like that often those macros are normal they are very helpful okay that's what multiple people have said that okay i i could buy that as an argument that i'm just simply not used to seeing it so therefore it looks ugly there's this whole theory that i have involving this which is on there's two sides of what is called developer experience okay uh by the way look at how pretty straight that free line is okay there is like bad dx right bad dx right this is where the developer experiences bad and then there's good dx and the problem about this is that this entire line is made up and really what this should be said is by the way look at how not straight that line is this should really be uh unfamiliar and this should be familiar and i find personally that all of a sudden i really like stuff that i thought i hated like a good example of this is um is underscore names like fu bar i thought i hated that cam case only i think this is completely inconvenient absolutely the worst to talk about all that kind of stuff but then all of a sudden now i think it's the best and it's the only way we should do things why would you ever use camel case camel case is for rookies and it's stupid right like what happened to my brain at what point did that just happen well it happened some point when using a snake case based language and it's like what i considered bad became good right you realized it was easy to read i'm not sure if it's was easy to read it just was more pleasant to my eyes maybe you could say it's easier to read i'm not really sure all i know is i just liked it more i can't tell you why i liked it more i can tell you no re i can tell you no reasons why i liked it more i can just tell you that i liked it more and that's it like that's it that's it i don't know why so easy to read i maybe more pleasant to read for me is probably the better answer like that's one of those things that i i don't exposure it's literally exposure therapy it's not a matter of taste it's it's not a matter of taste all i know is that i thought it was ugly looking and now i think it's more prettier looking i'm not even making a statement about easiness to read excited to hear your opinion on single letter variable soon i will talk about go and why the go's greatest mistake is single letter variable boom going in we're going to twitter go lang's greatest mistake is normalization of single letter variables boom posted it posted it my thoughts exactly transplant right onto here okay 100% agreed it is like it's literally the worst possible thing it is awful okay skill skill issue all right in my experience few people program like this you're right i would not have programmed like this i think i'm starting to see the value of this meaning that you have a generic list structure and then you invert it and make the node define the next one and then you use the generic list list structure to add things i think i'm starting to see this and obviously you would change value from int like this would be the code you write to interact with the list thing right uh the prime gen can your dyslexia read this easily i wouldn't expect that for real i does for whatever reason it does not bother me right so now i see the value for whatever reason now i actually see the value of this type of writing i didn't at first because it was confusing to me but now i see it again this is one of those things where i feel like if you if you're unfamiliar with a with a method you find it to be upsetting but if you're familiar with a method it becomes nicer i'm not saying it's better you know i'm not even sure if people actually think it's better but i understand why this could be considered better at least better than i did before suck it even more an ace by the way can you not call yourself an ace okay what are you a [ __ ] fighter pilot uh sorry for cursing that's just how i feel okay uh what would be uh able to tell you that decide let's see depending on the libc and colonel it might not make much sense to check malo failures because even in that case that the system has run out of memory an unlikely situation to begin with malik wouldn't fail depending on the example of the overcommit policy on linux instead the process would be killed once you try to use the memory so you might as well skip those checks and let the system handle those situations thus simplifying the code substantially and and actually this is significant simplification of what linux does i placed the generic notes structure at the beginning of the custom node precisely to avoid explaining the container of macro that although beautiful is not necessary to drive the point home in the real world the structure could be in another positions for example if you consider it a mix in of two objects like the list and device for more information on that post do this i don't know what the container of thing is i'm not going to look at the container of i don't even know what's happening here all right so we got another one of these uh let's skip it let's just go to the conclusion we can't watch more of this let's go to the conclusion i could go on and on with the different examples and perhaps i will add a few more later on but hopefully the subst let's see i have substantiated my claim that the top 10% of c programmers do write code in a significantly different way than the rest a lot of people scoff at the idea of a 10x programmer but when it comes to knowledge of c it's certainly possible that the top programmers do have at least 10 times the knowledge of the bottom programmers and possibly much more all right so i buy this basic conclusion but i will say one thing right here the reason why i would argue against this isn't that this is like the considered the way to go blah blah blah blah blah blah blah it's that it's air prone you have to keep these things in lock step that's my more big my big problem with this kind of stuff and that's why people claim rust is so much better is that it feels better that's one thing i really like about zig so with zig you can say defer right so zig has defer in it so you can literally say here let's go like this uh zig uh memory allocation example and for me it's just like this is kind of like the safe for close quote unquote way to go right so right here we allocate a new 100 bytes of u8 right and then we free it but this free doesn't happen until the end and so wherever you allocate you also defer free and so like this right here seems like this is the superior way to do it because you don't you're not jumping around and again you could also say that you could forget to uh defer allocate free it and that's that's fair that is still it's still an error prone way to approach things but it's less aor prone it's less aor prone you can say you can write macros in uh c i'm sure you can but i'm not completely convinced that c that zig isn't for me when i look at these things i just i feel like it's more a prone i i can i believe okay my two the two people in here that were very into se can we at least agree doozy that it is more errone than having something do it for you macro macro meta programming and c is highly frown upon that's my worry so lowle learning yes i can agree with that i'm not trying to say it's i'm trying to say that it's it's easier it's e this seems easier to get correct than this does because i have a branch here and i have a branch that needs to go somewhere and then this somewhere has to do the cleaning up so for me this is this this feels harder to get correct and so that's why like in my head i prefer the zig style and this is why i think a lot of these arguments come up is that it's just simply easier um and so i'm not you know that's kind of where i come come up with these things is like yeah you're right so this article well the article's fundamental point is that it's a c skill issue that's really going on here and that that most people are right here when they say c is not that great and the few people that are are apparently not confident enough that they say they are great this guy does not index here this guy has a straight line straight af erect perfect line right down the middle 45degrees but at the end of the day i the problem is is that the skill issues are more accidentally skill issued no matter how smart you are as a person who's been programming for 20 years i have goofed it up many times no matter how smart i am dude i have programmed memory leaks in javascript okay i'm good at this okay in a language that's supposedly able to protect me from me i have goofed up i have programmed memory leaks in rust okay on accident because i'm bad i'm bad okay so it's just like if you're trying to say why c is actually still completely fine and it's just people that are dumb at it i don't think you've sold me on that argument you have sold me that i do completely like not understand c as much right i think that's one thing that i can say for sure is my c ability is definitely lower right that's fine uh you can write your own allocator to track all of this you just use uh and just use an arena and not worry about freeing memory i mean that's super interesting by the way brother i leak memory in real life i know for real so yeah skill issues yes absolutely i'm just not convinced we have literally decades of empirical evidence that people aren't good at safe c c++ as they think they are yes this is true but i mean that's why we we create things like the sanitizer and all that to show you where you've goofed up greg you're absolutely right on that but again i i still think i i do want to shout this out one more time i really do think zig is a super interesting language if i was not in a go like a learn go and use go as much as i can phase i think i would actually be in a zig phase right now i know people everyone wants me to do elixir brazil mentioned but right now i really do feel like i would i would be in a c a c i i think i could be in a zig world i think i could be in a z world z world zig world sorry is isn't go uh more ready uh than zig though yeah of course go's more ready than zig go had the power of google behind it for like a decade and zigg is andrew kelly just [ __ ] out cod at a high rate that's surprisingly good your classes aren't taught in c are aren't they yeah i i didn't get taught c i i had one class in c i want to try odin i odin would be fun too uh oh uh-oh f f f f we're coming back we we we we coming back we coming back we coming back we're back we're so back we're back we're back we're so back we are so back we are so back we're back everybody i just had a little bit of a oopsy daisy little oopsy daisy hey the name is we're so back a jen we're so back