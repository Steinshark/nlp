hey object oriented programming is good asterisk a few years ago i made some videos laying out a case against object-oriented programming and since then i've been meaning to make a positive case for an alternative a prescription for how code should be written rather than how it shouldn't it's taken me a while to work out what i think can be said about how to write code with any certainty and confusingly the prescription in part might sound suspiciously like oo to some ears i'm not really recanting my prior position though many people just remain confused about what's unique to oo and what's not hence i'm calling this object-oriented programming is good but with an asterisk that was a very long asterisk um okay okay so we have an oh oh hater that might be coming around to uh enjoying a little casual oh oh is this some cash flow is that what we're seeing right now could be could be kind of a little bit cash you know just a little just a little oh hater turned lover you know what i mean a more honest title for this video might be module oriented programming where module refers to a unit of reasonably self-contained code but the even more honest title would be how to write good procedural code i love dude procedural code is the best code fight me fight me it is the best okay it is the it is the way to do it there is no other way procedural code is just always been it will always be it has always been functional programming it's just procedural code with with functions change my mind encapsulation polymorphism and even inheritance will be a part of the story but as i'll explain the total picture has profound differences from object-oriented programming so here's how i think code should be written code should be written in units we'll call modules and these modules come in two basic kinds state modules and logic modules the distinction is that logic modules contain no internal state ie global variables and logic modules do not reach out for external state starting to sound a bit functional right here i'm just saying already we can tell just right away this sounds like peer functions going on right now tell me this is not some pure functions right now tell me this is not it right here right now um interesting so this thing only contains external state it so what i when i see this what i think is that these are like definitions structs and stuff this is implementation on the structs traits whatever you want to call them it does all that uh define a peer function without using peer a function with whom has no side effects laughs instructs an impul exactly this means that a logic module consists only of functions and these functions only touch stateful things which are explicitly passed to them so a logic function can for example read and write to a file if an open file is passed into the function but a logic function cannot itself open any files i'd say that that in general that's just building good software i think i i think i see because he does he did talk about just like how to build better software you should always avoid certain activities within a file right like if you want to do something to a file such as take a file like open a file read out the contents go over the json blob parse out whatever x events sum up some values do something like that uh what i tend to find is a lot better is separate out those into two separate ones right the file bits and then the actual like logic bits because that way you just pass in say your events whatever those events look like and then it does the operation on top of it because it just all like whenever you separate out things like that it makes testing easier it just seems to make logic easier it just makes your life easier i feel like uh that's a good that's usually a good sign of a more junior person is that they they mix all them logics up the management of state is not the responsibility of logic code a logic function may generate new data and also may mutate its inputs but its only responsibility is to generate and mutate data only as it says it will in its documentation the side effects of a logic oh i'll do that we'll pull let's pull all right here we go let's pull are you ready all right new pull oop oop uh do you like oh yes or no yes no do you like oh tell me right now okay here let's start the poll we gotta know i just gotta know where's the pole it's right here oh we have a pretty i'm actually pretty shocked we have a pretty split group here i honestly did not see this one coming i honestly i i really truly dynamic dispatch is a curse yes equals actually no oh my goodness i think you're trolling me at this point just to get him to tie what there's no way that more people like it there's no way there's no way okay so this is wild this is wild okay okay you know what hey we're all allowed to be a little surprised now where where did that uh video go no no no no no no i do want to watch this but it's an hour long no no no yes i am so confused right now function are actually then the responsibility of its colors so the relationship between state modules and logic modules is strictly one way state code can call into logic code but not the other way around as for the state modules each should protect its private state and state modules should only directly touch each other's public interfaces in other words the modules should be encapsulated and even though logic modules have no state to protect they too should distinguish between public functions and private functions so as to minimize exposed surface area you know these are all good tips i i'm appreciating everything he's saying so far i feel like is pretty like no one can argue with as of right now do we got any arguers this all seems good no touching privates ex don't expose yourself you know you might object that modules might sound like objects but there are two key differences first there's no rule about how big modules are allowed to get well there's no rule about how big an object can get okay you know there's plenty of there's plenty of big objects out there okay i don't know why this guy has to be upset that this that statistically larger objects are a problem there may be tens or even hundreds of thousands of lines long very large okay that's too long a module better not be if i walked into a file that was 100 a module that was a hundred thousand lines long i'd have plenty of questions i'd have a lot of questions at this point modules are perhaps not ideal but i'm not going to give you any hard rules against them second a module is not an instance of a data type in almost all cases our state modules are singletons and we're unapologetic about it i don't like the word singleton singleton's almost always exist in such a way that they make me cry single tens make me cry every single time in almost all cases our state modules are singletons that's just making sure do you at least apologize for it and we're unapologetic about it oh that got me okay oh my goodness this is an arch user convention i can tell right away data types in fact don't really belong to any module the best way to think about data types is that they live outside all modules and when data is transmitted from one module to another the structure of that data belongs to another module more than the other i wouldn't say that a protocol belongs more to a client or more to a server and the same should go for data types yeah okay it's a practical matter though a data type must be defined somewhere in code so we generally define a data type in the module where it's most predominantly used we may also sometimes want to i think i'm misunderstanding the term module here i think what he means by a singleton and modules is that you know like a file filled with functions and data type definitions that that itself is a singleton which i would agree with it would make no sense if you had if you had instances of of modules is that what he's trying to say i feel like that i feel like that's what he's trying to say huh capsulate operations on a data type in which case we put the data type and those functions in the same module it's a unit of scope i agree with that it's just a unit of scope it's it's a it's it's just a unit of scope and it by definition it better be a singleton or i'd be confused because state management is an ugly problem the general goal in any code base is to minimize the proportion of state code as much as possible we want to punt code from our state modules into logic modules in some programs state management may inherently predominate but in many cases the state code can be a small fraction of the whole code that's true the question that follows is when should we break up modules into smaller modules and along what boundaries for state modules a major reason to break them up is to divide and conquer state management for either kind of module we might also break them up simply for organization modules by any of these do you know what i mean well i mean like i organize it by concept like i wouldn't want to organize it by team that seems confusing i wouldn't want to organize it by organization i'm not sure what it means to divide and conquer state management or to publish an api like the public api you could you could imagine is it in of itself its own you know repo module how are redefining it but i mean i tend to always organize my modules or my see the problem is i think i don't understand what he means by modules i think this is the fundamental problem here i always organize it by concept you struggle splitting modules i feel like modules are very naturally together or they're very easy to do the right thing a couple of minutes uh after this here's another great example hold on hold on picky all code concerning future a goes into module a and all code concerning feature b goes into module b etc such structuring can make the code base easier to understand if done well just be careful not to overdo it yeah we also might explore modules for the sake of team collaboration group x takes ownership of module x group y takes ownership of module y and the modules are coupled only through their public interfaces even for logic modules this can help because it allows one group to change internal implementation as long as the public interface remains unchanged still seems weird like i'm going to draw the line based on team's responsibility you know because there's plenty of places that are like you know there's like in-betweeners you know what i mean there's things that exist in between that just like that just you know i don't know i have a hard time with this whole organization collaboration teams business for similar reasons we might split up modules to better formalize an externally exposed api we don't want to bother our external users with details that don't concern them and we want freedom to change what we've kept private again many people today accredit these ideas to oo but the idea is actually predate oo and don't require us to follow the rest of its prescriptions we should not conflate modules with data types and we should not obsessively whittle models down to tiny sizes so yes though i spent most of my earlier videos arguing that oo sells an overly aggressive form of encapsulation i think encapsulation is actually a perfectly useful idea what then about i'm actually fine with smaller modules i've never thought of a modulus being big or small i don't know this this whole this whole time i swear we must be miscommunicating because this whole time like i never really think of size or any of those things i do agree that like having a singular data type in a singular file sometimes is super annoying like when things get like when you go into like a utils folder and there's like 900 files it's like that's really hard to work with and so i understand but then the inverse of it which is one file in a like a utils.js a utils.rs and it has like 900 functions in it then that's also hard utils is a code spell the problem is is that that statement is a statement that exists outside of practical work it just does it just always does in the end you have some stupid thing right like okay let's just take this you're working like on puppeteer so puppeteer when we were writing the integration with televisions if you don't know i helped build part of that uh which is like you have the c plus plus side the actual controlling of the v8 engine or other parts of say nrdp the television app and the javascript side and one thing we have to do is we constantly have to do these weird promises right so it's like promise tell you that hey i'm going to call this function and i'm going to resolve this problem but i had to like resolve it later i had to like api and i had to do something kind of weird and so what i do is i created a function called explode promise that would return the promise the reject and the resolve so that way you could have access to any of those and then you could store that and then say a minute later when you've done the actual thing which could be a series of steps i could then resolve the promise that i handed back way earlier it's a pretty you know typical thing if you do like async request cues anything like that you kind of have to explode out a promise and so that function is just it doesn't live anywhere it has no it has no like home and so it makes no sense to have it anywhere but like in a utils folder you know yeah yeah yeah polymorphism and inheritance my take on polymorphism is that interface types or type classes or traits or whatever same equivalent in your language they can be extremely useful their utility is primarily across module boundaries particularly across the boundary between an api and its consumer i like interfaces interfaces are great well traits are great uh homeless folder yeah uh homo like uh traits are great typescript interfaces are the actual worst out of all things typescript interfaces are by far the worst convention ever there's two things that are super wrong with typescript interface is one you can define uh props i do not think properties belong on interfaces i think somehow that just feels really really wrong number two you can you can effectively uh add stuff to an interface later on you can just like add a method i can just take a known interface and create another method on that known interface a deck interface merging or whatever it's called i just think those two concepts like typescript interfaces are by far terrible i'm not the only one uh surprisingly this is where me and the other typescript chads actually agree types are just bad i don't think you should be using interfaces i don't see a point in using interfaces i don't see what you get out of them it just seems wrong like i properties is definitely wrong properties are definitely wrong they're crazy but you can use them like trace no you can't you fundamentally cannot use them like traits traits you can you can use traits like interfaces but you cannot use interfaces like traits because traits are just they're just they're just different you know they hit differently the trade system just hits differently like the fundamental concept of being able to say like hey here's a function and it's defined and if you have this you get it but it's also there's nothing that explicitly has to implement that interface you know what i mean here i don't think you guys understand that thing here let's get out of let's get out of chad stack uh here rust typescript here this is what i mean by that is that i hear interface area nothing in here like circle doesn't have to implement area to be considered an area right so if i take a function function uh you know calc area i know even though this is stupid right uh you know uh item implements area right i can go in here and go item area and circle though no intention of actually implementing the interface just due to how it works you know the old quack quack typing i can go new circle and uh i don't know what's my interface on circle okay go complete it it just works there's nothing that like it doesn't it's not doing the thing it's not the thing it's not doing the thing you know what i mean uh yeah i know that's how go works i'm not i'm not necessarily the biggest fan of that i think i i still think how the trade system works is just a better usage of interface uh interfaces uh i i like the explicitness of it that for like so so in the rust world you'd have the uh do i have that around here uh dude i don't have it you have to implement there you go here's a trait you have to implement a display so you have to implement the traits you want for the type you want and that's really important whereas you can't just simply have an implementation that happens to have the same names for things it has to be i implement this thing intentionally and then there's a lot of other really great things with these interface types we can formalize commonalities between different data types including data types defined externally to our own code much like a protocol allows us to treat client servers and peers like swappable components interfaces allow us to interoperate with code that hasn't yet been written if however i have no need to allow for such external extensibility i generally avoid interfaces an interface requires me to speculatively generalize to imagine needs i don't concretely yet have and this extra burden does not always pay off for internal business for modules well contained within my control i don't really care about that kind of extensibility for sometimes it's useful it can be a again operating with interface you know always using interfaces it can it can be very useful obviously that's just like saying types right interfaces and types and typescript are virtually the exact same thing uh there's a few key differences but feels approximately the same i like defining my types i don't mind defining interfaces i don't mind doing any of those things because i think it's really really useful to do that code i control flexibility is maintained by favoring the simple solutions to my concrete problems rather than entering the realm of speculation now as for inheritance i do i do agree with that like the sentiment or i understand the sentiment which is like don't abstract things that don't need to be abstracted i do find that that's like super common concept especially in javascript javascript is the world of abstractions and people abstract they reach for abstracting as the like the first tool to implementing something inheritance is also a mechanism for expressing the commonality between types but inheritance additionally shares implementation a child type automatically shares implementation of its parent except for those parts the child overrides this implementation sharing might be convenient in some cases but as famously noted it tends to make code fragile changes to ancestor class implementations can affect the sentence in unexpected ways sometimes leading to some pretty nasty bugs i generally hate inheritance but i always think of one thing that i really like about inheritance and the one thing i always think about is a ventimeter in javascript right to be able to have a class that also has an event emitter i think is really really really amazing so if i had uh gosh uh extends event emitter right uh i always for whatever reason i just i always this this indenting is insane but i always really like event emitter because then when i get a circle right const a circle equals uh take that put it up here up bump up put in the middle uh put that right here be being able to emit right like that as a thing i really just i fundamentally like that and you know maybe one could say it could be it could be implemented without using extends or inheritance and you could like you know especially with that blanket implementation via tray classes you could get something where maybe you only have to implement a subset of this but i like the fact that i don't have to implement anything yeah exactly there are reasons where uh inheritance is really good and i'm not one of those people that just simply hate inheritance for all sakes like uh creating something like an event emitter in rust is not fun because you can't just quite do that it's not quite on the other hand where types have lots of overlap in their data inheritance makes these overlaps and code clear and more convenient to write in the first place this is something i think the go language gets right a type can inherit the data of another but this embedding as they call it does not create a subtype relationship so that's actually all i have to say about how to structure code i think it's a relatively simple picture overall i'll end though by elaborating on what i think this implies that oo gets wrong okay okay discussed oo conflates modules of encapsulation with data types second oo is overly optimistic about how frequently and easily we can create good abstractions i would agree with that there's modules and data types i don't know i still think you know there's a series of data types that fit within a module or an idea that just makes sense and they kind of go together and so i i don't really understand the separation of modules and data types now like i agree we shouldn't have you know we shouldn't break every last thing up in add infinitum but you know there should be some level that makes i don't know and third oo favors design with too many small pieces so about the second point the underlying premise of oo is that more abstractions are always better and that we can create good abstractions in the normal course of application development this is wrong i would agree fundamentally i agree with that the idea that it's it's that we talked about this yesterday this idea of of that i'm going to abstract my code because there could be this case that i haven't thought about yet therefore because i have not thought about it i know it could exist so let's design our system to be able to handle some future case that is probably led to more heartache and more upsetness than i think anything i have ever had in my lifetime is just that because it's so frustrating it's so dang frustrating it always ends up being this just this cluster festival that just didn't need to exist because it turns out you never actually extended it beyond anything basic and so it's just it's abstractions take a lot of hard thoughts and time to get right and typically they emerge only slowly over many iterations now when creating an api creating good abstractions is part of the job hence creating a good api can be very difficult in normal application code however we should free ourselves from this burden where it's not truly necessary cases do arise where new abstractions provide better solutions but a default mode should not be seeking to create new abstractions as for the size of our code units the difference between procedural and oo is how and when we subdivide the units in procedural code we modularize by accretion only splitting up modules when they get too unwielded in object-committed code however we modularize speculatively splitting up modules in anticipation of problems later in theory oocode is flexible we create a bunch of small independent pieces such that system behavior can be changed by reconfiguring the connections but in practice the burdens of speculative generalization rarely pay off now that i agree with that i mean the thing is is i i actually do such a different version of uh starting off so like i have this whole um i have this whole theory where whenever i start a new project or i start something new i start in a single file and i just start dumping things in until i find a good reason to change it so like i have this whole search thing that i've been building at netflix for some data and it just takes a bunch of different sources and then does like an extra step of data processing underneath the hood and so i started with just like one file i just wrote it yesterday and today and i just wrote it out just making it all happen and i realized okay there's really like two parts of this there's like the building of the request because i want to be able to request these datas to a service and then the handling of a request now that i have data plus the request i want to make how do i do it and so it's kind of like these two sides and so it became a very obvious natural splitting of the of of uh of the like the modules right and so for me that just made perfect sense that's just how i wanted to see that's how i wanted to do it but i didn't start off knowing that i just i just simply built it out all in one file until i felt like okay this is the time i need to abstract this is the time that i feel like i see two separate things developing how much code do senior engineers actually do i write a chaton i write a huge amount i am i am that is my job to write a letter is about the things relations to other things but my team is a heavy code these little tiny units in isolation the pieces produced in this process might be easier to build and understand individually but the whole system is not there's like no architects we just don't have architects architects are the ones that go around in lab coats telling you how you should write your code and it's very fantastic and it's very beautiful and it works perfect on a whiteboard but when it actually comes time to implement it's horrifying and awful i don't like architects okay i don't want anything to do with architects i've never had a good experience involving an architect i swear every single time it's always just awful meaning requires context and these tiny units are isolated from context object-oriented design is often sold as the responsible thing to do the moral equivalent of keeping a closet or drawer meticulously organized but typical oo designs feel like though are tangles of excess packaging look at that little guy poor little guy uh who's our who architects then everybody architects everybody does the architects like when you build out your piece you architect and when some piece needs to be larger and put together itself and we have like a larger constraint you have to go and get a couple people together and all agree on it that makes way more sense like when okay i want to re or i want to re-change like the program of how like how say startup works or where our main is is how how do we link with partners and up partner televisions well somebody does the research comes back and says hey these are the ways i want to change it and then you can get a group of people on the team go yeah i like these changes i think these are good i don't like those changes i don't think those are good and then they go back and they kind of make some changes or what they think is good and then kind of come back and argue for it so like each person becomes the own architect of their own area because there is no reason to have somebody that only thinks of architecture i really don't understand that i think that architects if you purely do non-coding architects you do not at all you just you can't contribute to a project reasonably because every month that goes by you're not coding is every month you don't understand how production works and as that gets further and further from your understanding you just simply start suggesting these things that are just stupid and it feels good because it looks good on a whiteboard it always looks good on a whiteboard every piece of code looks amazing on a whiteboard just like my brain when i come up with this new greatest idea everything is fantastic and then you implement it and it's horrible it just was wrong um everybody is an architect that's the thing everybody's an architect whenever you build code in some sense you're architecting it and as you get more experience you can build larger pieces of code that fit together and that's really it that's how i look at it chad stack looks amazing on the whiteboard yeah don't mock boxes and lines there's lots of crap so fractured indirected and abstracted that like in wonderland nothing in code is as it seems the names of the classes and methods lie about what they actually do because the real work is always done elsewhere the procedural alternative comparatively encourages us to introduce abstractions only when they're much more likely to be useful go subscribe to brian will good guy good guy right there good guy that's a good one i like it here let me finish it off finish it all the way through you know all the way through there we go perfect yeah that was good um yeah the pro there wasn't you know this this was a really good video but i don't really know what it has you know it's hard to take anything concrete out of this video it was good i i appreciate it i'm gonna give him a thumbs up