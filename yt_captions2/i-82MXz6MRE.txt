all right hey this is the pattern matching proposal for ecmascript because of course you can't actually call it javascript because oracle will then come and sue you live like actually not kidding oracle will come and figure you out okay so we're gonna actually go through um we're gonna go through pattern matching and we're gonna see what does the new pattern matching look like that the proposal by the tc 39 committee we got some champions right here awesome hey champions way to go um all right so what's the problem they're trying to solve there are many ways to match values in the language but there are no ways to match patterns beyond uh regular expressions for strings switch is severely limited and it may not uh appear in it's the expression position an explicit break is required in each case to avoid accidental fall through scoping is ambiguous block scoped variables and side case statements are in the scope of others yes this is true unless if you explicitly put a scope around the case statement so i don't know if you know this uh is this this is lua what the hell am i doing with lua uh but if you go to let's see i don't know if you guys know this it's kind of a weird thing about uh typescript if you go like this switch uh i don't know my uh let's see foo right you do one of those and const foo equals right um you can do something like case you know uh bar and then you can do this right and then you know const a equals you know 69 and then break right that's okay then you can go case a bass and then you can do another one and cons a again right uh constant equals 420. right and so you can do this it's just saying because foo i already defined foo uh somewhere else up here and you know it's like hey you can't do that and so uh yeah uh oh my goodness uh typescript i'm typescript anyways cool way to be able to do that i don't know if you know that just like cool little fun fact if you need to scope your your switch statements you can do it with that but i agree it is complete ass pain you know nothing's worse honestly nothing is worse than seeing crap like this right where you have like this kind of stuff going on because then you have an a that's within all of your case statements except for this one which shadows over an a like i've seen stuff like this it is just maniacal truly truly truly maniacal um break goes outside the scope i know i do it's it's just it's it's insane uh let's see are available uh let's see in the scope of others unless curly braces are used oh i didn't re i should have read further there we go and you can only do comparison on this yep exactly priorities for the solution this section details the proposal priorities note okay so pattern matching let's see uh all right the pattern matching construct is a full uh conditional logic construct that can do more than just pattern matching such as there have been and there will be uh more trade-offs that need to be made in those cases we should prioritize the ergonomics of the structural pattern matching over the capabilities of the construct okay uh we already know all this i assume if you don't understand why switch sucks that i mean go play with the difference i do like this idea that matching should be an expression good uh pattern matching construct should be usable as an expression love it love all of that little i mean i'm actually struggling to see what does this mean oh yeah okay so this is a return statement oh okay yeah yeah yeah yeah okay sorry i i now struggle i on struggle should have just waited a second uh the value of the whole expression is the value uh of whatever clause is matched okay exhaustiveness and ordering i love this if a developer wants to ignore certain possible cases they should specify that explicitly this is like a huge w i really hope that they do this it would be nuts to have a match statement without that right like rust yeah exactly like rust a development time error is less costly than a production time error absolutely if developer wants two cases uh to share logic what is known as fall through switch they should specify it explicitly oh interesting are they're gonna oh are they going to make an explicit fall through logic i don't think i've ever seen that or know of it is that like a thing can you do that in rust i have never seen an explicit fall through case does that mean you're introducing a new keyword called fall through or something like that go has it i feel like i've seen it and go that's why i like in my head i'm like i swear i've seen this but i don't know where interesting uh userland objects should be able to encapsulate their own matching semantics without necessarily uh privileging built-ins uh okay this includes regular expressions uh licenses um no tc39 you don't you don't appear to have a license yet for regular expressions um so maybe you shouldn't just be illegally okay and out of terms and condition using such phrases like that okay i just want to let you know because we all know one thing because you shouldn't be adding regular expressions to a code base without a license and those who have a license generally know it's better not to use them okay remember that remember that oh i'm just gonna do a quick email parse or an ip address this is gonna go great no it's not no oh great it's it's ungrate it never has been great it's never going to go great it is always an awful experience by the way this is by some coding guy on twitch me and him work together on uh uh at netflix and him and i won a hack day award together we replaced a lot of the stuff doing with netflix and took off all the json and did a really strong um the binary encoding we just did literally uh c c structs we just inlined a bunch of c-structs and then transferred it over and then we're able to beat uh production by doing a series of galaxy s3s or a galaxy whatever they call them galaxy threes uh samsung phones we beat amazon aws by making our own micro services running on uh galaxy threes or whatever it was it was pretty fun we took the w we took a strong w just then uh it was it was a lot of fun it was a lot a lot of fun uh anyways let's keep on going uh prior art do you do i do i seriously need you do need a license okay are you are you you wouldn't download a car would you um all right use your land's matching oh hold on prior art okay those proposals ads uh pattern matching okay so there's a lot of prior art obviously they didn't mention uh okay they did mention russ they also mentioned coffeescript was which still is a mistake use the landmass a list of community libraries that provide similar matching functionality optional ts patterns uh babel plug and proposal pattern matching uh matches pat com all right match res when status equals this this equals this handle body so i'm really curious how this is gonna work do you know what i mean like i i am really curious how they plan on doing this because like how do they know that you're exhaustive because in some sense to be exhausted like especially on an object like this to be exhaustive it has to know the type the type has to be defined like for real real since javascript is all loosey-goosey do you just always have to have a default you know which kind of sucks like that it really feels like it ruins pattern matching if you have to have a default everywhere right that's the point of pattern matching is that i don't like i don't have to uh have a default i i explicitly state every possible way to handle this one thing it is interesting i never thought about that with javascript because i was wondering how this is going to look so i assume what this is actually doing is it must build up some sort of sweet byte code into inside the engine like when they actually implement this that will just do you know c plus plus comparison of these properties right um okay i don't really understand i also have a hard time understanding this syntax specifically are they saying that there is going to be two or more properties on this thing status it'll be a number that's 200 body it just has to exist and then rest which is actually going to create a new object that represents the remainder of the properties i think that's what it's saying it matches objects not types exactly so that's what's kind of wild about this proposal is that it matches on on objects not types and so you lose a lot of the cool like i assume there's a lot of optimizations inside of a proper match that can't happen here match expression the whole block but getting uh with the match keyword is the match construct res is a matchable oh okay a matchable what is a matchable just so we understand just so we have the right terms wait where the hell did i just push that matchable there we go a value let's see the value a pattern is matched against okay so that's just a term okay so it's just a term whatever it is what it is okay okay okay okay okay it's actually just that let's see there are four clauses in this example uh three when clauses and a default one uh clause consists of a left-hand side and a right hand side separated by a colon the left hand side begins with when or the default keyword the when keyword must be followed by a pattern uh in parentheses uh each of the when clauses here contains object patterns the parenthesized pattern uh may be followed by a guard which consists of an if keyword okay cool so that's kind of very like rust and i'm sure there's other languages that have it as well i think i've seen it in plenty of other ones i think oh campbell has it all that the right hand side of the of any expression it will be evaluated if the left hand side successfully matches okay so it's like i mean oh wow they're talking about this have we become lua it is kind of interesting that we're like we're introducing a lot of keywords here one problem i always kind of have with with javascripts just in general is that i feel like it has it it has a series of really good ideas but often it can be wrapped in kind of ways that feel like it gets out of control a little bit i'm a little bit worried about how you know i'm a little bit i'm a little worried about how far or weird this can go do you know what i'm saying like there's gonna be a whole like debugging is going to be kind of unfun you know it could be weird uh i don't know maybe maybe it'll be great my assumption is that i will love this right i will love using this but my assumption is there's going to be a few times that i will hate that i'm using it you know what i mean um you're on fun okay calm down uh the samples i can drive parser for a text-based adventure game okay cool uh all right the first clause okay we already know how all these things work i don't think i have to do that array length checking match res is empty if is empty huh really really like i i just assumed i would see something like this right it'd be you know a thing right and i would see something that looked like uh case that like i figured that would be the empty array that makes way more sense like that's what pattern that's like pattern matching it feels right i really don't like the idea so so i think one thing that gets really kind of complicated here and i think is going to be really unforeseen is that you're definitely gonna have a lot of logic executing that you may or may not realize that you're executing as because you're gonna have to order these things in like you know you could imagine that any hot hot path item you're gonna have to really feel you're gonna have to really think about it which is uh doesn't feel great anyways uh array pattern uh patterns implicit uh length check coming uh let's see incoming okay let's see implicitly check the length of a oh it's incoming okay uh um array patterns i don't know what this is what is array patterns that's what i wanted to see as array patterns okay so that's not what it is anyways bindings uh bindings from regex uh patterns with named capture groups oh interesting okay oh i wonder how the g works in this did anyone ask about the g what's the g looking looking like it right because for those that don't know g contains state a global match has state so therefore it is kind of it could be i wonder what happens when you use a match with the g you know what i mean top g or g spot we don't even know we don't even know who's g she's a streamer on twitch her name's study time but we just call her g it goes kaboom i know it's just again there's a lot of oddities that can happen especially in the regex world when it comes to javascript i wonder if they're gonna disable the g my assumption is this will make js uh even slower um and uh bros let's see uh bros will overuse it and write well actually the code doesn't matter developer speed is what matters uh processors are fast yes this will i mean this already happens no matter what um this this is this is already a statement that's why we have it disable the g-spot uh this feature made by arch linux yes it is it's made by arch linux but it's like it's a real uh it is a real conundrum which i think that this one thing that i see right here is this makes it a lot harder to reason about your code and how it's executing that's right you know i'm a little worried about it but you know maybe it's good um i i'm not a fan of of regex's you should know that speaking of interpolations okay okay here we see the interpolation operator which escapes from pattern mode a syntax to expression mode syntax it is conceptually very similar to using template strings okay written as just lf lf is an identifier uh pattern which should always match regardless of the value so 0a is new line zero d must be uh return i always remember it if you're ever wondering is it slash r slash n or slash n r how i always remembered it is it's the registered nurse because that's what you're gonna need after you get done dealing with slash r slash n and slash n slash r or slash r slash n you will need one um anyways uh i actually don't understand what they're trying to say why can't we just provide this as a value when it's this value is it because this is a string and this is because there is no char type therefore there is there's an oopsy daisy going on here this is a char proper type and this is a char string type therefore you have to do this where's the ticks i don't think i quite get this i mean i think i understand what's happening here but i would expect at least like ticks on each side of this to kind of like you know this is just a lot of syntax huh another question i have is does this is is this a single time operation meaning at compile time or you know slash interpretation time for the first time do they take this value and since it's a constant do they move it out and they never re-compute it or do they compute it every single time due to the loosey-goosey nature of javascript i'm just curious i'm curious about these kind of things anyways i'm just curious cat okay uh okay uh let's see let's let's look at this option has let's see value has value okay do this get value we if it has this we do this value else throw this thing uh somebody by the way i really hate i i will say that like on on the level of bad syntax the pound me sign as denoting private in javascript feels emotionally bruising it it honestly it feels like it just feels like they said you know what i refuse private because i feel like the engine could have just been like okay we know how to handle private right like you're still denoting it with with you're still denoting that it's private with something i feel like the engine could have done this it just feels weird and this somehow does not make me feel happy i agree and this is coming from someone who loves js i've never liked the syntax i just thought i just find it horrible i've also gotten to arguments with my co-workers about this where it's like someone had you know class we'll just recreate this where we had it in typescript and they wanted everything to be uh underscored uh prefixed because it's not technically oh thank you high five um because it's not you know because it's not technically private it's just like i have this rule of thumb which is that if you break ts by accessing private items and then using like ts ignore two things happened one i've designed something that's horrible or two you are doing something that is horrible right and so it's like why would i why why would i do that right my the typescript compiler tells me exactly that i can't execute this i rely on my ide to tell me the correct thing to do or my pde my personalized development environment to do the right thing right uh so why would i why would i put semantic meaning on a character i just think it's dumb it's a it comes from an old tradition that made sense back in the day to let people know that this is private and may change but that's because we used to just write javascript and just javascript was a horrifying experience typescript is a bad experience it's not horrifying right like i can write something you know i could i could do that still very common it's a crazy thing to do underscoring private fields i just do not understand it that like i understood it in the day in which you didn't have um you didn't have an lsp when you didn't have an lsp and you didn't have the ability to be immediately told or even told during some sort of like developer time non-run time moment that hey this thing can't exist to me that made sense but since we don't exist in that world anymore we should stop using it for that you know what i mean like it makes no sense that world doesn't exist now it makes no sense this there's there's plenty of things that that made sense at one point um let's see regex let's see regex's are a major motivator for the custom matcher protocol oh my goodness my emotions are broken my emotions are literally broken reading that statement okay so let's keep on going down custom matcher protocol okay uh static some value none oh my goodness okay okay let's see uh okay here we go let's see um symbol matcher is a function matched has value in val and oh this is the this object oh weird oh this is a that took me a second to kind of figure out what they're trying to say so has value is being interpreted as a property that's inside value and if val and and this value okay so if it's matt okay if it's matched okay okay i think i see it matched in value okay i think i see it i think i i think i understand this i think i understand this which means that we can do this okay i didn't understand this that is horrifying syntax okay so i think i under actually i think i understand what's happening here oh my goodness i think i understand what's happening here do you know what with does with is the devil's keyword and i is it making a resurgent in when cases is that's what is that what we're seeing is a resurgence of the world's grossest operator with is deprecated with is like one of the only deprecated items ever in javascript it was such a bad idea with is a preposition follow me for more tips damn the satan's keyword legitimately a satan's keyword holy cow in this sample implementation of a common option type the expression inside this are the static constructors a summon option which have a symbol matcher method this method is invoked with the mattress so so here's my next question this right here means that it's constructing an object every time it does a match statement see like this is one of those things that people aren't catching on to since i have to have such an eye for memory usage like i i am definitely seeing something here like things are being created right i don't know what it's going to do to performance i can't make a direction either way but it seems as if this could be really uh this could be really really difficult you know what i mean object pull this yeah filthy casuals exactly thank you oat steel thank you since you know this thing uh probably has a very limited life you could probably just literally have it as a singular thing yeah well if you come from lua that's like the length of something okay yeah uh the interpolation pattern can be optional chained into another pattern with chaining oh no oh no here it comes okay okay okay i was hoping to see something built-in custom matchers i guess we're leaning into the uh no types for javascript i mean this statement can only exist in a world in which you need types but you're not allowed to have types that's the only that's the only world that that can exist in um when name and ascii ci color hold on i think i see this i think i see what's happening here return matched stir equals lowercase equals so only if name is color two lowercase okay i'm super actually okay actually i'm i'm genuinely confused here because this looks like it will only match things that say color right is that what it's saying i actually i'm actually having a hard time trying to figure out what's happening here so what i think i see is that you have a name and you run this function which produces an object which has a matcher which the match function is then created on it in which that match function gets passed in with the thing you're matching on which in this case is a css property and then we're going to return and we're gonna see we're gonna take the string we're gonna create it all to lowercase from up here and then from there we're going to match it against what was passed in and lowercase that one as well so what i see is that name and name has to be color and value oh it's oh i see it it's taking a css property and ensuring that it's the color property and then we get the value out and that's that oh this is like a oh my goodness but name is unused in this scope but do you need to specify name because you need to be able to end it with this property or end it with this matcher is that what's happening i think that's what's happening that's really complicated yeah dude this this bright [ __ ] this is okay so that's what's happening to be able to run this thing on the matchable the matchable is this name right here so the name effectively gets pooped into this thing because the thing that comes out of this interpolator is a simple matcher so therefore it's going to run the symbol matcher on it it's an object with symbol matcher and therefore it's going to run it on this thing and we're ensuring that color will be used another thing that's a little crazy here is that every single time at least as far as i can tell every single time this thing is ran we reproduce this symbol matcher right here based on this string i walk in on this yeah it's a little crazy maybe i need more time to understand this like i can see why people like this right like this makes sense why would you not like this this is like of course you'd like this of course you do right who doesn't want that a motivating example right like i understand why okay if status if status is greater than this request error well you know as a motivating example this is hilarious you know why because if i return i'm a teapot it's a request error 500s and 400s are very very different it's funny that even in this thing it's just like okay that's crazy talk um a more concise more functional handling of redux reducers someone is someone is drinking some serious kool-aid to do redux reducers with this okay here we go to do's reducer state equals initialize state actions isn't that considered like a complete naughty naughty already right there you're having wait is this even legal syntax isn't this illegal syntax you can't have something that comes with an initialized state and then an uninitialized one call the cops right now oh yes this is a default value but then this one doesn't have a default value bruh this is like that's normal and fine no it's not that is a straight to jail item right there no this is fine no you are crazy uh okay return match action when type is set visibility filter payload this filter filter oh look at that nice copy uh vis filter filter okay so we take the object we break the object we reproduce the object and we throw on a vis filter from the action okay cool uh type to do add-on do this do this add this thing to the front of the list or first we recreate the list and then we put in a new one all right let's go uh type toggle let's do this we're gonna take this one we're gonna take the to-do's create a copy of it until we get this one we're gonna splice it out you know splice just works right or not even they're not even splicing what are you doing holy [ __ ] i just realized what this thing is doing this thing is taking state taking the tattoos copying the to-do's out creating a new to do object uh and the new to do object gets recreated it looks like where we flop this thing and then we also return out oh look at that beauty syntax can we all agree that don't you just love the idea of well we can't use return statements so here's a parentheses expression return [applause] laughs that is so good and then we recopy the thing and also the new to-do's like you recopied every single object in here oh campbell is alive and well after this oh campbell is loving life right now um you know one of the funniest things about this is that you always see this argument about why you use redux or something like that and mark from front end masters did a vanilla to do mvc and people looked at how he was handling actions which he effectively had this exact same piece of code except for as like a series of functions and people are like that's unmaintainable what happened if you have to add more i mean in this example you'd have the literally the exact same problem it's just a slightly different looking it's funny how it's funny how it's it really goes back to the original statement that i made i think the last one which is dx is if it feels better to me that's dx right like if you're used to this then this will be fine do i think this is a little crazy there is so much happening right here um yeah i feel like it's it's a little crazy but for someone who's used to this this is dx right uh concise conditional logic and jsx uh fetch url path uh prop match props when loading loading when air do i never even caught the do keyword the lord's loop except for this is in the lord's loop this is only just a large loop with length one you know many of us have a length one and we're all still really great okay i just want you to know that okay we're totally still pretty awesome okay uh this is just so funny to me this is so funny to me that that you have a do with the parentheses and then to cause it to return on a value expression you have to do this because you can't disambiguate a scope versus an object it's just so beautiful this is where i think the word break really would make a lot of niceness here just break with the value i think zigg does that and i like that i don't think zig does that i think zig does something else i would love to see just some sort of explicit keyword here because this just looks crazy um all right proposal match construct mob blah blah blah blah we already looked up we already looked at matchable this is where we do all the definitions we've talked about guard clauses already array pattern matching all that kind of stuff um i like this see this is exactly what i wanted to see we found one int we found two why can't we have an empty where is the empty why did we have to have that if statement i love see i like this this is what i want this is what i want i want that i like this this is great this is great to me all right i think we've kind of reached kind of the the example to the end of all that kind of stuff this is also really weird type coercion is this or not type coercion this is type checking via a match which it's just kind of crazy just in general to me like this whole statement is kind of nutty do you know what i mean is it just me am i just being too am i being too old i could be too old maybe i'm too old i maybe you know i think i'm gonna go buy a box of brand cereal um i'm gonna buy a box of brand cereal maybe get my pooping under control you know there's no default i know there's no default how does it know there's no default right see like that's one of those things that makes match like exactly you're actually 100 correct there's something that makes match really really amazing which is that you can exhaustively match anything is this exhaustive or not how do they know it's exhaustive or not follow up okay okay property name it already gets in the cache okay i was about to say follow-up that means this thing is only executed once so this statement right here okay this is this is also i mean this makes sense so this thing is called once which also doesn't make sense so if you're in a loop oh if you're in a loop it will re-execute once per loop but it will only execute this phrase once and cash the value let's go i like how they provide really sane and totally normal examples that don't make you have to think about things they look for your exhaustion i know to do got em all right well i'm gonna give my opinion on pattern matching and javascript okay this is my opinion on pattern matching i think pattern matching is one of the most powerful features ever and i truly truly do not i truly am unable to make um the most effective use of pattern matching it is genuinely one of my most underrated like one of my most underutilized skills that i have and i'd love to be able to do it more and more and really be able to understand pattern matching because pattern matching is truly probably the most powerful programming concept that we have as programmers it is incredible it is one of the most amazing things ever but i will say that in this example that we're looking at it seems like it took pattern matching and up leveled it into runtime expression matching effectively and this thing feels really really hard this feels like this is gonna go out of control generics are better than pattern matching they're really not if you don't understand pattern matching you really truly don't understand how powerful that feature is i too thought this exact same thing and until i started playing with it and truly understanding what you can do with the pattern that you cannot do with generics right that like there is one really amazing thing you can do right here that they're showing right away things like this this can be really incredible for certain reasons and this is really great to be able to take like the ends of the two lists there's something really amazing about this to be able to do something with a multi-match right that's something that um that russ can do way better than this can so you could actually do like a match give me the first and last item of the list and if they're both an object and they both don't equal each other then we have a list that is you know there's like all sorts of cool things you can do uh i really really really really really really like the things that you can do with pattern matching that is just super unique and takes away a huge amount of programming that otherwise you would have to do matching is freaking sweet this example that they're giving us and and all the things i'm seeing here i truly do worry about the state of i really worry because you know a lot of things people don't do is they don't try to remember what it felt like to not understand how a function works and then even more so not understanding how a method works and then even more so not understanding say how objects and scope and all these things work right like you really have to remember that feeling and if you looked at this as one some of you like if this is going to become the normal state of code that you see a lot of times i do greatly fear for the people just coming in because it is so many things happening right here the amount of computer operations per symbol is extremely extremely disproportional and so you may not realize what's happening like this statement alone is crazy it's taking an object copying the object taking the twos recopying the inner this is a buy handcrafted deep copy and then adding a false at the end like that's a lot of things that happen up here that if you're newer the statement is really hard to understand all the things that are happening anyways it's just kind of my thoughts on it which is just i i feel like this is just going to be a really hard feature it's gonna it's just gonna make a front end i feel like it's just making front end harder and i think this is this is why changing modern front ends takes uh four ever i think it's only going to make it harder right and i think it's just i i worry a lot about this feature i love pattern matching i wanted to start off saying how much i love pattern matching first because i had really high hopes in javascript to have good pattern matching uh you know we also read just an article just recently that less is more and the reason why go got started was because instead of adding more and more features try adding less and less perhaps this could have been a better way to make a less is more reduce the cases of pattern matching so that only certain things can be done so it's very straightforward right you can take an object and just grab things out kind of like that status 200 and s thing right but like this right here is someone just said declarative everywhere someone said it i can't even find it right um uh someone said it anyways what else let's see i think declarative programming should be the norm everywhere so like that that statement is great the hard part about this is that everything about this isn't declarative right there's so many things in here that aren't going to be declarative like these are all nice and declarative i get that that's great i like that i can buy onto this this is very this is very good but there's other places that they're actually like this is great this is what i think is fantastic pattern matching right here but there's things that we looked at that make this really really hard like this you kind of leave the world of declarative and you're really starting to get into the world of you know uh of like in mixing the two it's like a declarative imperative style that's really hard to follow all deckler obviously all declarative styles become uh become something else like this is now you're starting to get into the same thing it's a little bit goofy i'm having a little bit of a hard time to see this why is this thing called value and this thing is called val i don't understand it how does it know how to pull this property is value like some keyword it's you know there's some things there that are kind of unique about it also this right here you're starting to lose that right you're starting to like look at these statements you're starting to lose some of it and you start getting into this like mix of which i think is the worst of all things which is declare to feel with imperative execution which makes it so it's like super hard right it just makes you have to really think about everything anyways thoughts on it excited about pattern matching i really hope that they maybe pare it down a little bit you know what i mean pare it down a little bit at least maybe make it not so expressive uh worried obviously about that uh i feel like devs often forget a lot of people write code semi-casually like pen test or cis admins the complexity of code is what keeps them away from framework and languages that's a good point that's a good point um i can't wait for syntax highlighting for javascript after this name is the primagen by the way vs code still uses a lot of regex's uh for for for text highlighting i cannot wait for the regex that's gonna have to be written for this because they still haven't quite gotten trees that are put in amount of red sexes that are gonna have to be written in the amount of escapes to get all this right mild looking uh it's beautiful foreign [laughter]