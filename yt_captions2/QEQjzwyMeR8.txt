by the way someone said that theo looked like he had to he had to pee is that the face i make am i am i holding it in like that it might be true let's get started which is go is certainly one of them i'm not known for being a big go fan but over the years i've by the way he's not when he says not being a big go fan he's actively said go is like the single worst language he has ever used so this is like this is a crazy take okay this is crazy the fact that theo is is saying this i mean he's theo's an atie theo's an atie go okay okay he he's been an antie so that's why this is so interesting started to come around to it a bit not because i enjoy writing it i don't think that will ever happen but because i see the value it brings to developers and to the industry as a whole there a lot of good things i use every day that are built with go like es build vest for handling our myql databases and even docker there's also some bad things like kubernetes terraform and the github cli the man hates kubernetes okay but to be completely fair i'm sure versel probably uses kubernetes and so he likes using kubernetes he probably just doesn't like implementing kubernetes okay can we be can we be real there for a second you like using them k8s don't like don't like don't like uh implementing them people to build things quickly that are relatively fast in runtime as well i just posted this diagram on twitter and the response was loud but largely agreement the goal here was to point out the ways that all of these languages are both faster and also slower than other ones we i don't actually fundamentally agree that typescript has more developer velocity than go at this point i've used go now for a couple weeks like actively and i've used typescript for ah gosh a decade and i'm almost as fast in go than i am on typescript but i'm only two weeks into this old go business you know what i mean maybe three weeks ts ts has more dx if you're interested in all things web but a nightmare if you're not invested if you're not i mean that's that's where my big runtime this is absolutely true i i think none of us can none of us would argue this top one or this bottom one go is just fast as fast as crap to compile it's it's it's runtime not as good as rust but significantly better than typescript comp compilation significantly faster than typescript it's just the middle this is where the argument comes down to which is do you believe this i'm curious about rust longterm still i'd like i'd want to see a bunch of lightly invested 9 to-5 andes right rust for a year and i would like to see how their application goes do you know what i mean gor is trash yeah that's why everyone uses squeal c but i'm actually curious about that because rust if you get a bunch of people are very good at rust i could see it probably being pretty good but the reality is that most companies they're they're just a bunch of people that are just there they're just there to be there they're not there to be the greatest person person ever and so if you have like just a bunch of 9 to5 i don't i just want to clock in write clock out i don't want to think about things i'm curious how fast rust would actually how fast it would actually go would it would it actually maintain a nice like would you be able to deliver features or not go you can do that with nineo fers with go damn you can move fast right if you're only writing front ends i can understand why ts is appealing but the moment you're writing a library ts goes closer to rust because everybody wants the craziest autocomplete where you hand in some sort of object and out comes all of its properties as dot separators and everything i wouldn't use rust for application code neither would i i like i like rust for well i mean unless if it's like cli stuff i like it for c eyes go is easier to master than rust or j yes go is easier to master like i bet you if you took a if you just took any random person who has never programmed i think it would be easier for any one of them to develop a comprehensive cli in go with the shortest amount of time lies you think so you think that's a lies i think i think i think go would be the shortest amount of time anyways you can see here in the runtime performance that rust obviously wins it's crazy what happens when you manage all of your memory yourself when you compare that to something like goang where you don't manage the memory garbage collection handles it for you you can move significantly faster when you're not worrying about the borrow checker and all of these individual parts obviously the size of the typescript ecosystem and the lack of checking things generally speak you can move faster in typescript see that's the thing is that the the size of the ecosystem i actually thinks hurts i think it genuinely hurts typescript uh there's 10 separate csv parsers some in javascript some in typescript sometimes they don't have type libraries and you have to figure out how to provide them uh there's like a whole bunch of barriers that you have to really think about with typescript whereas go most of the things that you use typescript for are just freely available on the standard you want a templating you want to just do some basic templating it's ino you you want to do some basic operations over arrays it's already in gh standard library you want to do pretty much anything oh you want to just create a quick tcp server or a quick http server already ino and has pathing and it has everything right like most of the things you've ever wanted are already ino that's why it's so interesting but again that's web server i noticed i said all web server things it's the web side of things is that typescript is that what makes it good i mean i can i can agree with that like if you're developing an application i think it's kind of wild to try to i don't think wm's there can we be real i don't think wm's there i think that if you're just developing for the web i think typescript will probably remain king for quite some time there's a lot of go and infra yeah go is like the primary thing in infra wm's really awesome but i'm not going to lie to you it's it's it's very it's like it's it's hard it's not a great development wm doesn't touch the dom we're not there yet yeah and even all the dom like crossover and things you can do to like touch the dom it's very asm i dude i there's a lot of aom all right uh but man i've already lost my train of thought due to aam pick i read aam and just lost it i lost it i actually can't remember what i was going to say if you disagree with this you haven't worked in both languages for long enough you can move faster in typescript meaningfully your code will be slower for sure and i i don't agree with that i think it depends i i think i think when he says these things so to be completely fair when he says these things i think he's talking about web development specifically so i think he's he is probably correct in the sense that if you're just doing web development then it makes a thousand times more sense with typescript to say that you can move faster if you have a oneperson team maybe you could say you could move faster because you're writing just a singular singular code base for both i still think actually just using uh js doc javascript for the front end and go for the back end htm x in the middle you will simply move faster uh that's that's personal that's a personal opinion on this one i could maybe see why he's coming to that but i i'd say if you're writing infra you're writing anything to do that's just like a program that runs you're going to get way faster developer velocity right here even maintenance might be a bit harder in typescript but the speed all right shy l take hit me hit me with hit me hit me with it shy vip l take come on make it happen lay it down on my face laorel rails phoenix greater than web i knew it's was going to be the son of a bit i knew the son of a was going to say this i knew he was going to come in with some just some wild just some left field one i knew elixir was going to be mentioned i just knew it i do think it's hilarious that rails is thrown in on that one that one we maybe are going to have to disagree on the rails part i guess i haven't done enough rails to know you go from 0 to one or even 1 to 10 in ty script is unmatched but then we get to compilation times where go is comically faster than all the other options something that i've always been amused about with rust is the weird reality we live in where rust is being used to make faster javascript compilers and typescript compilers despite rust's compiler being one of the slowest in the entire industry it's actually hilarious how long it takes for rust code to build i am regularly blown away by the speed that you don't get when you're compiling rust code thankfully it is it it is funny that which makes things fast is inherently slow there is something that's very beautiful about that it competes with has compiler it does it it really does compete with the has compiler it is i do i do love that i i love that fact both go and rust are being used to rethink how we build our javascript and typescript code but i do think rust needs to take some time to reflect on how they could speed things up on their side the resp i don't think they can really i mean obviously the compilation is extremely complex um i i'm sure there's like there's like base improvements they could do if they have any non-parallel stuff they talked about that how they made parallel building of certain things much much faster blah blah blah blah yeah yeah we we all get those things but one thing that i think is missing from here uh which is uh uh what's it called which i guess you could claim is right here is going to be ecosystem like uh uh developer uh tools right developer tools um one thing like if you've never been on a million line code base with typescript effectively the lsp is is is dog water it doesn't run it it it will run you will get results five to 10 seconds later after you press the dot um it's it's it's just really really slow it can't it can't handle any sort of sizable real projects it it's just it's absolutely terrible and i work on a multi million line codebase with typescript and it just crumbles it absolutely crumbles and so that that that's like a real thing is that scaling dev tools is very interesting kind of like i guess vertical within this developer velocity when you start with go or rust you literally use go or rust to do everything oh cargo you know cargo ad tokyo go get whatever right it's just like it just works right it just simply works you want to go build you want to go test you want to go do anything it's all within go and you don't have to do any of this extra crap whereas like with your typescript if you happen to have made a typescript project two years ago the likelihood that you're using just and not vit test is through the roof if you have a bunch of really complicated uh complicated reporting mechanisms and acing stuff inside your test the chance of you using one tooling versus another is really really high where's go like that's not an option you just don't you don't even have that as like a thought process right right the tooling already is good and so you don't have to make these a bunch of these like little little ideas uh or these little takes throughout your project and there's a lot of starter projects that are really great to get started in typescript like you can get started today faster than you've ever been able to get started with something that builds really fast and it's actually very impressive but the the the the other side is that the moment you scale beyond the basic tools needs you you effectively inherit a build team and if you don't believe me please for the love of all things holy and good go to any team with a large javascript project with a lot of internal tools and a lot of stuff they have to do and just see what they have to do to get the build to work the way they want it to work like please if you don't understand that you just haven't done a real project yet i'm not trying to like dunk on does not mean dunking on you you just haven't done a real one yet that requires actual integration with proprietary stuff and it becomes a night may right it is it is very very difficult educational dunking stream it is an educational dunky stream you know it's really really fun and so that's like where i think and i think rust suffers from this as well a little bit and i think go has the least suffering from it all shut up was surprisingly positive low level even points out that the rust compile time issue is a very interesting and deep rabbit hole let me know if you want a whole video on that so i can figure it out everyone's saying developer velocity is extremely subjective yeah so is runtime and compilation time like a really good typescript dev could write something more efficient than a really bad rust dev but i'm talking about general it'd be hard to do that though that i think that's the take is that it's actually hard to write something in rust that is slower than ts it's it's actually hard to do like you'd i i'm not even sure exactly how bad you'd have to be to do that it'd be impossibly it's not impossibly hard you just have to use a lot of clones like you just have to clone everything and it would you effectively you just need a really large string if you deal with a really large string then you could do that incremental compile compilation with proper structure of split crates uh can be pretty fast yeah it's decently fast you can get it uh you can get compilation time of rust down to a few seconds but you have to be really good to make it bad trends and extremes here that's it so if go is right in the middle of the road or better than all of these other options why am i not using it well let's take a step back and go to when i first started trying out go when i joined twitch in 2017 i was on the only team working in elixir it was really cool go ahead shy ryan okay go ahead go ahead brazilians just say it just say it just say just let's go come on get it out of you guys shy ryan right now is is is is doing the brazilian brazil just mentioned dance but with with elixir hell yeah brazil mentioned let's go let's go jose valum fast and build crazy stuff the only reason our little two and a half engineering team could build the infrastructure for all of twitch's marathon content was what elixir in the earling vm i love bob ross i cannot tell you how often i'll just put him on in the background just to just to enjoy a little bit of you know bob ross in the background the thing is is i hope to never find out about his personal life cu i always worry you know have you ever had this worry that you find out that bob like you find out that the person you think is really really nice turns out to be a complete in the background i really don't think he's that way okay but just imagine if you found out that he was just like horrifying uh it would just hurt me because then you know i'd be watching him be like man but he's like really a bad guy in the background but he seems like a really nice guy he seems like a really nice guy and the stories i have heard are all positive ah love bob ross i love bob ross yeah it would hurt me again yeah i mean this happens enbl i was able to level up significantly as a dev get deep into functional programming and move faster than it ever moved before for by working in elixir with that team sadly that team ultimately folded and i ended up on a team working on the video infrastructure for the rest of twitch which was all in on go at the time i hated front end i was known as the anti- javascript guy i hated the web i didn't like building for browsers i shot on electron all the time good move by the way uh i actually am curious because there's something that i've been wanting to do which is i want to like i want to catalog all of my opinions that have changed over the last 10 years you know it's kind of interesting like even theo just mentioning the things that he has changed on isn't it funny like isn't it funny how the world changes and and what you think is terrible can uh will you know will will change over time it's it's it's totally normal but it's kind of fun to kind of catalog and think about how you viewed the world like okay real talk i'm going to be i'm going to be dead serious here and maybe i still think it's true i think grunt was one of the better build tools for javascript gulp is better i hear you gulp is better gulp did not come around grunt walked so gulp could run so webpack could make your life miserable okay that's how i look at things and so when i used what the hell is grunt yeah you just that's because you didn't understand you weren't there tweet that is a that is a tweet i would say that that that is a tweet that's a tweet mostly focused on building native apps and backends i' done a lot of time in both android and ios development but really was focused on servers so moving to go seemed to be the right move and it wasn't i was miserable every second i spent in that language i hated and i gave it a solid 2 months and it wasn't because the language is this horrible terribly designed thing although we'll get to some of the design quirks in a bit it just didn't make me feel smart and i get it i under he's ready for rust no i mean this is real this is real some some people find joy in that i i don't want to i don't want to dunk on him cuz i know a lot of people that want to feel smart while they program i don't i don't i mean i i really don't think at my age i'm older now okay theo's theo's a younger fellow than me by about a decade and at this point in my life i don't want to feel smart like i don't i have no i have no desire to feel smart i want to be as stupid as possible every single time like you know what i like doing here's kind of like the kind of the real talk well you're doing a great job of that hey thanks thanks teach like uh teach all you get all always count on te to make you feel a certain way you know like i'm not going to lie to you uh this is a hard problem creating like an extensible tcp um protocol to be able to send packets back and forth between uh goang and vim and to actually have like a real extensible way to be able to create sessions and all that that is a complex problem but i want to solve it in the simplest possible way so that way i like to solve problems that make me feel smart in a language that doesn't make me feel smart does that make sense i like that to me that's that's where i feel really good at is i like to solve the hard problem oh we have ginger bill oh hell yeah what's ginger bill have to say ginger bill by the way odin creator definitely smarter than me okay i mean it's not that hard to be smarter than me by the way it's really not that hard uh user ginger what do you what did you have to say ginger by the way ginger bill we got to get you on here uh i i actually do want to get you on here for a talk at some point the problem is the problem i always have with wanting to feel smart is that i pretty much always make really dumb decisions feeling smart does not equal being smart feeling smart equals acting dumb you think so that's that it's a little bit of a hot take i like it i like it though ginger i like it though i think it's good uh hey can we all take one second and applaud theo for being honest though there's a lot of you out here right now there's a lot of you out here right now that completely agree with theo and you're and you're just not being honest about it that's why i call it type masturbation right i'm being real on that one people like type masturbation they like the act of creating a very complex type so they can have the world's greatest everything because they just want they they just do some they they just want to feel anything in life you know what i mean everybody loves type masturbation type masturbation say what cles you just hold on now um it's real though people like they people people genuinely like that dhh was right about types maybe understand that prog is not about feeling clever and smart all the time in fact the desire to feel clever regularly results in really bad code being written i'm certainly guil that myself but go never sparked joy for me and i missed that because when i was in elixir i actually was loving it i was for so i actually have to put a big timeout right now this is something that i think theo should think about theo you know i'm going to talk to you one-on-one on this one you have made fun of dhh quite a bit about his dislike of typescript and the reason why he doesn't like typ script is that it doesn't spark joy like we're talking about i i think potentially even the identical phrase being used and so i i do think you got to you know you know what i mean let's let's apply that let's let's give let's give some man let's give a man some grace if he has the same argument why he doesn't like typescript hey that's his you know that's his that's his prerogative we're not this is not this is not a bully theal it's it's actually it's i think it's actually kind of a funny observation because i never heard him say the term spark joy and like i totally get that really at the end of the day you just hope that you can provide a nice life for yourself and the people that you love uh that you can have uh stability of some sort that you can uh just enjoy the things out of life while being able to solve problems that kind of bring you kind of bring you life and you know the reality is that if you're solving really hard problems but you're just not liking it at all and you'd rather solve simple problems it doesn't matter how cool your job is you're going to have a you're you're going to lose a lot of joy and you're going to feel a lot of like upsetness in your heart and it's going to it's going to kind of pull at you over and over and over again and eventually you're going to have burnout and so like i don't mind this take i actually think this take is perfect fine if go just doesn't spark joy and you just don't want to do it and you find yourself lamenting every time you use it i think that's like a perfectly valid reason to say i don't want to use it because you know what's worse than uh you know what's worse than writing in a language that i think is utterly doo is writing in a language that that makes you have burnout like typescript doesn't make me have burnout i just i just think that people write complex code in typescript all the time my work doesn't spark joy so i'm not going to go anymore uh do do you know what sparks joy for me turn tuning into your streams a a baby right like i can write typescript and not have burnout like i i think it's fun language i just think that it's it gets really complicated really quick and i don't like building large applications in it because it always just gets all stupid um i don't know if i c++ doesn't spark joy in me you know what i mean c++ is one of the very few languages that i actually get really sad when i have to write and i've had to write it maybe for 400 hours at at netflix it just doesn't make me it just doesn't make me happy you know what i mean i don't like reading c++ code i don't like writing c++ code i just don't like it c on the other hand i think c is kind of fun c is kind of this like i've had the right sum c i had the right i had to like co-write a driver i was definitely on the the lesser side of the writing i was like 40% of writing the driver for one of our internal test devices for uh for live video and that took a that that was fun i was wri in c wri in alla drivers i totally effed up the audio buffer like five times it was a lot of fun it was a ton of fun to be able to write those kind of things and that was just a couple years ago that was i i had a blast doing that and so i love c c is a good time i wrote the entire uh we have a synthetic live video sync so if you don't know what a sync is that means as audio and all the video frames go in it's sent into the decoder which the decoder is going to be like your tv right it's going to be now we are handing it off to the tv i wrote a virtual version of that that takes everything in and reports kind of like the stats about it and it's all written in c i really enjoyed that that was a great process i even wrote a bunch of unit tests for it it was a lot of fun i i i completely enjoy that process c++ just makes me sad right and there's not it's not like you can't write c when you're using c++ it just makes me sag i don't know why so i get this this is a great argument and i think this argument you got to extend grace to other people for for doing that right for the first time in my career java doesn't make me sad i i don't mind java i don't mind most i honestly don't mind most languages there's very few languages that make me sad genuinely enjoying the craft of building and creating software and then i went to go and that just wasn't a thing anymore which was by design cuz go was designed to be boring and minimal repetitive and consistent i'll never forget the way go is subscribed to me by one of my first managers at twitch one of the specific goals of go was that if you took two prs one from a really senior dev who' been working in go for half a decade and one from a newer dev that just recently learned go the code would look nearly identical which was a very strange way of thinking to me i had never worked in a language that by the way that is like that's i really like that like to me that's very exciting um that's a huge w in my book because that means maintainability is big well that's not an l take he just said that surprised him right have you ever like if you've never thought about that once if you use javascript you could get like i i make this argument about rust all the time which is if you got five senior rust engineers into a room and told them all to solve like a a decent siz problem maybe one that took a thousand lines you'd have none of the solutions look like each other there all would be unique flowery way to do things if you did that with javascript you could have the exact same experience you did that with go though they're going to be all fairly similar and that's like a for me that's a big selling point because at the end of the day i like the idea being able to maintain stuff right because because you know remember we don't ship features as programmers we don't ship features we ship maintenance to our future self don't forget that it's a fact of life can you elaborate what would you like me to elaborate on you ship stuff that you will have to maintain tomorrow and the next day and the next day and the next day that had that making things as simple focused in one way as possible and then there was the garbage collector which was a very interesting addition for a lower level language because most of those languages had you manage your memory yourself usually garbage collectors were associated with languages that were much higher level often running in their own run times or virtual machines like java so go feeling like c++ but not making memory your problem feels like c but yes was a weird mental shift that has enabled a lot of wins but also a lot of confusion the results a language that doesn't necessarily fit in any one specific box and as a result it's been hard for me to recommend for a long time but the more i think about it and look at it and break down the decisions that were made in its design i have started to see the strengths especially now that i've seen many a project try and fail to rewrite itself in rust a lot of my frustrations with go are very well detailed by the way i do uh absolutely love this idea of people failing to rewrite stuff it's funny to me because it is hard like people don't realize like how hard it is to be good at when you're good at go it makes you feel like you're good at programming and then you use other languages that are a touch harder and you realize like how hard it really is to use a rust like you really have to study rust you really have to like be deep down zig on the other hand i think zig may have you know how hard it really is um i think zig is actually one of the more interesting ones because i'm actually curious if zigg has a fairly similar learning curve and experience as go just with a slight bit more deepness to it uh like like maybe a little bit more learning curve zig feels verbose at first look but so does so does go right so does go uh i have this kind of like this is the easiest way to understand languages okay so effectively just imagine you have this pyramid right here and at the very tippity top this is you're going to have your compiled memory managed language so you're going to have c zig uh c++ rust right you got have all those ones the next layer is going to be go pretty much go and o camel are the ones that i know of off the top of my head they're going to be compiled languages that go down into the machines but they're going to be garbage collected so they are they're just a little bit different right they they're they're closer to the top of the triangle then they are the bottom of the triangle the next one's going to be like your cs or your java right these ones are a little bit different right because they are they are garbage collected but they aren't necess neily compiled into machine code they have like you know they got some some sort of virtualness to them maybe c doesn't have that anymore maybe c you can straight up compile it down to a static binary i have no idea what c does anymore these days c has greatly changed since i used it but typically they produce a bite code in which is interpreted and eventually jitted and all that kind of stuff so c maybe exists like right here maybe it's better to say c exists right here i don't want to say whether not and then you have your like more of the bottom of the barrel which is going to be your javascript uh which is going to be uh your python and then you have the actual bottom which is going to be ruby right you know what i mean there we go lua lua would fall under this one right here uh because lua has lua jit so there you go that's kind of how i look at languages and so typically this part of the triangle is really easy to master and be good at this part of the triangle tends to be really hard to master and be good at but zigg might be unique in this situation that zigg may be easier to master and be good at while maintaining all of the amazingness of manag memory and uh manage memory and compiled just a thought just a thought just a thought i've been having just a thought you know the old brain has been thinking about held by faster than lime in his odin i don't the problem is i don't know odin enough to have a like i don't know it enough to know how good it is but odin definitely is going to be if i'm not mistaken odin you manage your own memory and all that so odin would fall into here and odin may be on the same level of zigg as in next generation language that's super like that has all the the goodness right here without all the difficulty right same with ji yeah ji could be it as well but again no idea we haven't done the planet scale stuff two blog posts about it his two blog posts are titled i want to get off mr golding's wild ride and lies we tell ourselves to keep us and going both of these are great articles i highly recommend reading i didn't like the articles if you can like get off goes wild ride one of them was just the fact that uh file system strings aren't utf8 and go forces you to use utf8 so there could exist a file in which uses a non utf8 character in which you could like try to read i just i would say that if you if you don't use a utf8 character in your in your file name you're you're just a bad person okay they chang my perspective on the language and more importantly made me feel way less gaset because i hated my time and go and didn't have great words for why two my favorite points in here are around types and channels i absolutely love this quote this quote came from oscon which was a conference for programming lang i do agree that i wish channels were slightly better i really think they should make channels too that just have a bit better semantics around them uh especially on like are they closed all that kind of stuff i'd love to see a a slightly better thing around cuz i know channel can be a bit difficult sometimes nerds and designers and at the time lion was working on designing his own language and as he said here he gave a bad presentation but he fondly remembers when an audience member asked the go team why did you choose to ignore any research about type systems since the 1970s didn't fully understand the implications at the time but i sure do now go types are utter chaos and i don't think they're utter chaos i actually think they're very they're they make you step back and stop trying to be clever i think there's a huge amount of clever that involves there i i'm not convinced that this is bad i am i'm honestly not convinced that uh using something beyond the 1970s is bad okay i still use vim so to be completely fair i'm out i'm out i'm out here still using the 7s default nil is yuck i i'm on that team i think that that's a failure that's a failure of their types and all that do i wish they had options i think they would have been better to use options versus uh nil 100% but you got to also remember that when you use options anytime you use that kind of concept you also have to add in a bunch of guards and those guards can be very annoying right like if you have a pointer and you know it will always not be nil well you know i'm sorry that's not not in the option world that you're going to have to it could be it could be theoretically therefore you got to option it right and so i think that it is it's not a it's not a simple conversation to have it just makes a lot more stuff you know what i mean uh if error does not equal n nil is annoying to i actually completely disagree with that take you know what i think is more annoying than if error does not equal nil calling functions that will error and you don't know to me that is that is a 10x awfulness you know what also is really awful uh what is what i think is one of the worst aspects of programming is the following is that i could have a function right so pretend i'm in javascript i'm in l right now so just pretend i'm in javascript and i have a bunch of lines and then i have a try because you know i mean i just have to and a catch and now i have to make a decision here how to handle my error versus which one of these lines failed to what state have we got to when when and how do i make that decision if you don't do that then what do you have to do well you have to do this like really annoying thing right which that totally sucks like nobody wants to do you know let food this and then you do this whole food equals that like nobody wants to do any of that you know what i mean like that that also super duper duper duper duper sucks and so it's like do i mind if air equals deal is it like too much yeah i agree it's annoying but the other way is also super annoying you know what i mean the other way is also super duper annoying anyways let's keep on going and the result is rough i personally in the tiny bit of go i had in production at twitch introduced a pretty significant number of bugs and the reason is a lot of values were knowable but the type system just couldn't detect that so yeah but you call that just skill issues right you got to know those things it's not i'm not saying it's good like i actually i mean i'm i'm like 60% on theo's team i wish the zero values were better like i think one of go's biggest mistakes is that maps are nails to begin with but it's also a skill issue right like i i also just need to learn that right i mean to be completely fair be completely fair when i go in here and i go const a equals sum array one to uh 69 and then oh that's sorted dang it a. push 4 right and then i go sort and i go con b equals uh a do sort uh and then dang it i have to do this whole a oh wow how did you know that you know like well you would mess this up in production right notice that i've already like notice that i've already done the exact same skill issue as a map is nil is that i already know that this thing will sort incorrectly potentially due to it treating things like strings right like i already know these things it's it's one of these many programming language little rules you have to keep in your head and when i do that i'm like oh look b came out and it got sorted awesome i know that it's sort but what you don't realize is that it also sorted in place like you'd only know that if you shot yourself in the foot bam right you shot yourself in the foot once and now you know and now you're not going to make that mistake again right and so it's the same thing with map and nils right you you make that mistake and then boom does that make sense and so it's like that's why i have such a i have a problem with those kind of takes but i also don't because he is 100% correct i think the language should have done a much better job at warning you i really do believe that long sock enjoyer yeah i'm a long so enjoyer like i really do i i really think that the language should do a better job at warning you but i also don't necessarily hold it too much against him like or against the language there were multi instances where i thought a value existed i did something with it but it didn't so it failed and there was nothing to hold your hand through that type of stuff they handle errors great but they don't handle empty great unless you choose to make empty an error case in which by the way fair take that's an extremely fair take it is a fair take i think everybody here can agree i would much like i think we all want options we just don't want the verbo of options it's tough right it's tough like i think that's one thing that does uh that typescript does pretty good in the sense that typescript when you do when you have a a an undefinable value or a nullable value when you check to see if it's nullable and then you return the next line will now know that that value is not nil and therefore you will get it pattern matching needn't be to be verbose pattern matching still makes it verbose i mean no matter how you skin the cat options make more verbose code every single time because you have to have some level of of lifting so the answer is in the linting i mean i think i think that that's actually really nice lithium i i truly do think that that's a really nice way to do to do stuff optional ch but at the end of the day you still have to do some sort of lifting operation you can you can you can't just have one monad you never have a yeah lifting is greater than if if statements are lifting though right like if you're in rust and you do uh if you do if you know uh let some x you know you're still lifting i just lifted right it's just like that's not you know what i mean like that you still have to do that right and that that's the thing that i'm talking about when i say that um when i say that options are verbose is that you have to if you want the value underneath it you have to do something right sure you can x. and then right you can do x. map right but you still have to do a thing to get to the value in typescript you still have to if you know foo if if not if not fu bar then return false or whatever it is right you still have to do something right that's what i mean by that we need operators for options yeah i mean rust rust actually has a pretty good one which rust does have the whole function fu and if you return out an option right whatever that option is you can then do something that looks like sorry my indenting is all wrong i'm in aa file so just just deal with it if i had uh other funk and this thing returned an option i could just throw on that i actually think that this is one of the better i actually think this is one of the better things about russ i think russ did a really good job with that i think that this is something that makes options not nearly as crappy but it also makes it so that there's only one way to handle it which is you have to just return prime successfully uh ignored everybody mentioning cotland yeah i did cotland nuts right dealing with it currently in jail o camel i'm sure o camel has a nice way to do it uh ginger build here here's a quick question ginger bill with um i saw you just chatting ginger are how does odin have uh options or how do you handle the the bottom values nil undefined you have maybe t okay okay do you i mean do you have the same unwrapping do you do pattern match to unwrap it do you do like a just an if check and then after words you know that it's not nil then from there on out it's defined like typescript like what's the way that you use unwrap the burrito boys that's why monads are burritos okay so you do this okay so same way as like a standard rust one or even okay cool yeah i like this by the way this is very i do like i do like this by the way this is very nice this is very nice it's it's zig i think zig does something similar i think zig does something along the lines of x uh value like something like that right i think i think x has a or zig has a very similar thing i'm i'm fine with those kind of that kind of stuff uh i think that yours is a little bit better in the sense that you could i assume you can chain off of it and i think chaining is pretty cool x or return oh that's really cool i like that that's that's that's pretty legitimate i do like the fact that it's x or return that's cool because you're kind of giving that option right there i like that okay odin might be the best language damn it odin might be pretty dang cool ah dang it i don't want to learn another language jinger bill i love it though love it but i do agree i i genuinely agree with it's crazy how they got one side so right and the other so wrong and that jarring experience felt weird because i felt at the time like i was constantly checking errors because the type system couldn't prevent them i've since learned there's a balance here where there are errors that no type system can prevent and having a system that encourages you to handle those errors is good but having a type sy to prevent that is also good and they entirely failed to strike that balance and go the other part i hear a lot about is channels because channels are regularly pitched to me is the reason to use go if you're doing concurrent things go is one of the best languages for it no it's not the channel axioms make no sense if you're not familiar with channels they're the core model for concurrency and go and they have some weird quirks these are the four channel axioms ascend to a nil channel blocks forever a receive from a nil channel blocks forever ascend to a closed channel chanel panics and a receive from a closed channel returns the zero value immediately none of these behaviors make any sense and i've had a lot of people try to explain them i do agree like i said i i i i i do agree with this point that i think channels that's why i said earlier i want to see a v2 but also go is by far more significantly better at handling async uh than than most languages like it is probably the best i haven't used elixir enough to know that it's not but i think that go right now is the best colin is better go i don't know if that's true i don't know because people say a lot of things about colin uh elixir is really good it's the v oh really okay yeah so that's that's like that's the thing like obviously this ascend to a close channel panics forever is interesting i' you know again this is why i'd say a better better close m like better go semantics i think would be nicer nonsense sending to a nil channel should error receiving from a nil channel should error sending to a closed channel should error or i guess panic fine that's the closest to a reasonable one uh p i mean panic kind of sucks i'd rather see an air i'd honestly rather see an err honestly really really sending to a nil channel should panic because you're doing a nil access a receive from a nil channel should nil because or should do a panic because it's an ill access a send to a closed channel i'd rather see an air and a receive from a close channel i'd rather see an error right i'd rather see two values come out of a channel right value and error right i'd rather see that panic why don't you just return an error that's go whole thing is returning errors all over the a panic is like uh an unrecoverable error generally an unrecoverable error is the best way to put it it's like where your system effectively has done something in which is unrecoverable now in typescript you can it's not unre i know but it's gener generally to say it's unrecoverable it doesn't doesn't stink you do it all the time panic is a crash panic is it's good that it's a crash in the sense that when you've done something so stupid and something so far out it's good panics are not easily recoverable and go that's crazy talk okay that is crazy talk because you have to know about you have to understand the state in which you are recovering from panics are not i mean it's the same it's the same thing about like deep try catches unhandled exceptions how do what do you do real talk how do you recover from an unhandled exception i don't know what what do you do how do you how do you recover the state should you keep moving forward is your database going to be fine you ignore it you break the system crash i would prefer the dump and say this is where it happened and let's like let's go from there right it's kind it's it is you recover from stack overflow right that's what i'm saying is that recovering from a panic is hard because it's different than recovering from an air because an air is like oh i can see why this thing failed therefore i'm going to do this process yeah i understand there's process. unhandled exception and you forgot by the way uh metlex i can tell that you're not there because there's also unhandled rejection okay you forgot your little promise there buddy but nonetheless it doesn't make it easy because you have to figure out how do you recover from a completely orthogonal point uh checks for the closed channel so if you have two variables it it works better so i have a quick question about that because this one's saying if you try to receive from a nil channel it blocks forever right this one's saying oh this is for a closed channel so then that okay so if you if you try to receive from a closed channel you get the okay you get the second variable and then you know it's closed okay so this fourth one this fourth one's not real let's just say this fourth one is not real and that's fine but the other three are still real i think that like i said i'd love to see a channels v2 that has all the same syntax as a channel and is it is mostly swap with a channel other than like a couple of these you know what i mean i'd love to see that place and receive returns the zero value immediately so there's no way when i receive from a channel to detect if it's closed or not what yes you can yes you can no this is a mess and as but theo just didn't know that and neither faster than lime obviously didn't put that in there so that people that are reading this have a worse take than is available uh so you can obviously as someone just said you can right so you know lime says here the reason is there had to be a meaning for nil channels so they picked these ones yeah chaos there was recently a presentation about the things that go did right and wrong and thankfully they acknowledge the failure of their type definitions here we define generic containers in the language proper maps slic arrays and channels without giving programmers access to the genericity that they contained this was arguably a mistake we believed correctly i still think that most simple programming tasks could be handled just fine with those types but there are some that cannot in the barrier between what the language provided and what the user could control definitely bothers some people more that's true and now they have generics and so you can get most you can get 90% of what like at this point there's almost nothing that go can do like isn't pretty dang good because there even is right now there's like a slices there's now a slices package which you can do generic operations over arrays so it is we're pretty dang it's pretty dang close bothered in more than some i'm sure this has caused plenty of issues in the past i know i certainly encountered plenty myself regardless lime did a great job of explaining my frustrations with go so why are we talking about it today why why do i care let's diagram this one out because it's hard to just put words if you're familiar with the line of prime this is likely going to feel somewhat familiar on one side of this spectrum we will say perf rules all and the other side we'll say dev velocity i'll just say perere this is a rough spectrum i can already tell i'm going to fundamentally disagree cuz i think often people measure dev velocity based on familiarity and i also think that any large larger long rand typescript project features grind to a halt when i say large i mean large not not we're not talking 50,000 lines of code okay that that's that's not large where on the left here ultimate performance is key in focus and on the right side dev velocity is the focus so let's make some rectangles we'll say there an obvious thing that fits here let's say it with me guys c++ ultimate performance good luck with the developer velocity where on the other side we have js and typescript and things like that where the performance will not be as good but you get really fast developer velocity also put things like python here i' argue python's theoretically capable of being a little faster and i would argue roughly the same velocity python's actually definitely slower than javascript in python proper but in python bindings to c python is faster right that's why you get something like numpy it's you can go pretty quick so yeah it's slower than v8 in python pier but it's faster than v8p because most of the things you do is in um sealand right that you can get from javascript and typescript and as you see here just because something covers more area than other options that doesn't mean i necessarily recommend it like if python can be faster than javascript and typescript why would i ever use js and ts because i have to it's necessary on the client and also it has a really good tool set in ecosystem makes a lot of sense to use javascript and typescript where you can because there are places where you need to what we're starting to see is a gap forming in the middle here and if we were to start plugging it we can only get so far with something like rust rust theoretically can't be quite as fast as c++ unless you break a lot of its rules c++ lets you write theoretically faster code but it also is harder to write correctly and is more error prone it's actually a fair take it's it is easy to write shared memory operations in c++ but shared memory operations man like i mean that's it's pretty it's pretty crappy it's it's not a it's like that's not you're not uh you're not loving life when you're doing that okay you're not loving life uh whereas rust you can do that but it's it makes a lot of these stuff near shared memory or even like it makes partition shared memory really easy to do and so one thing that you can do is like you can actually do a you can actually take like say an array buffer and you can actually slice out a bunch of contiguous regions and all of those individual can be mutable references and so like that that is true like you can actually split up contiguous shared memory and have multi- threat like you can have some pretty good access into it changing things without you know without all the complications to c++ you can go pretty good with the concurrency side but nonetheless when you get to that last final part it's very very difficult there's almost a separate i'm not going to be the one to make and if somebody wants to make an updated version of this diagram that has an access data parallel data parallelism is easier in rust facts facts facts logic of life c++ is most of the time skill issues the problem is that that to earn the ability to not have those skill issues requires you also to do it for 25 years i was just playing with shared memory in js the other day yeah you can do that but you're not really it's not really shared memory unless if you're doing workers and a shared buffer then i think you can get there and i'm not really sure i have never played with uh shared memory buffers and javascript with workers can you can you can you edit them at the exact same time because that's like that's the like that would be the win if you can edit them at the exact same time then you could actually get some pretty fast speed but you also have no synchronous logic that's available you'd have no ability to say hey i need to own this region for some amount of time before anybody else you have no lock you have no mutex you have no semaphores and that's where the things get real i mean that's that's always the problem what's that semaphore well it's to prevent you from dying of reliability go nuts you have my support but that's not what i'm here to talk about today what i'm here to talk about is this giant gap in the middle here this gap exists with a lot of the tools and technologies we talk about i've always referred to it as the uncanny valley and i think that's the case here more than ever if we draw lines for this space here uncanny valley this is an area by the way i i hate excal draw how they try to make the handwriting like it's handwriting and having the slight inconsistency like that little thing right there it's so evenly inconsistent it like it bothers me i hate even i hate consistent inconsistency because it's not real where the tooling isn't going to be i can disable that i have it disabled but i'm just saying the the fact that like you know you have like the the open mouth here you have the open mouth here just like it's like it's like it's perfect for anyone because it doesn't lean far enough in one direction typescript and javascript will always have a crazy eos reinventing how we build so that we can move faster and do really cool stu and that's great for people who are in greenfield projects and rust will always move a little bit slower and be tolerant of things like terrible compiled times because their goal is performance and safety above all else as a result these things are very exciting and enticing because they represent extremes and those extremes get us extremely either excited or disgruntled and this is why those technologies get the clicks the reach the stars and all the hype that they get because they represent extremes of mindsets and extremes of needs that developers have but there are things that live in this middle ground and i would you know what i'd love to see i would love to see somebody who has never ever programmed before like if if only i could have like a real experiment here where i could have a hundred devs who've never programmed before like a two be devs and a 100 of them go and learn go and aund of them go and learn javascript and see where they get in one month like that's that's the real dev velocity that you want to measure again i think one of the problems that you're seeing is that you're measuring this from a position of understanding do you know what i mean like you're measuring it from a position that you already have a bunch of this pre-built in knowledge that makes it feel like what you're good at is easy to use have you ever have you ever talked with someone that thinks c++ is super easy and yet oh i have i know some people i have some people on my team that have been doing nothing but c++ for for for literally 30 plus years and they're like oh it's actually really easy you just have to do all these things and for them it's like completely straightforward but for me it's not straightforward it feels difficult and so what ends up happening you think something is easier than it actually is and so that's generally how i view all graphs when it comes to dead velocity is that i think we're all wrong i think that i'm wrong okay i i think i'm wrong on what is actually easy and not easy i think theo's wrong on what's easy and not easy i think this is really just a this is this is better to look at i think it's probably better to have this graph as perf matters to what i am most familiar with matters that's probably a better way to put this graph because i would have something probably slightly different here honestly if i were to build something i could easily build it in typescript i wouldn't be able to easily build it in go as easy because i'm simply not as familiar with go remember i'm only i'm really only in on on like 3 weeks of actually trying to learn go but i'm already like pretty close like my line would be like right here on typescript it'd be like right there and so i can already tell that i'm having my ability to learn it is extremely fast rust on the other hand i did it for two years for all my side projects plus a bunch of internal tools and i was pretty dang fast at it i'm pretty like comfortable in rust but i can tell you that there's definitely like this weird trial of not being fast or these moments of like sinking your dead velocity and that's where things get very interesting with go or i mean with uh with rust rust is something where you're making progress you're making progress you're making progress you realize that one of your design decisions is actually not good and your your velocity just just tanks because now you have to reconsider huge swaths of your program to get it to get it going and then to go back up and keep going faster the trout is real like i think rust is as fast to develop as typescript but if you goof it up just a little bit you' collapse is that not true for other languages as well it's not nearly as true for other languages other languages have the ability to kind of uh to put stuff over the top what about the dep velocity when you move across boundaries of context and share code like when uh your rust program is no longer just doing that one thing and is now used by other rust programs across teams yeah that one's also interesting so i haven't i haven't got to that point so i wouldn't know about that point yet that's what i i i still don't know about that but it is very interesting um it is really interesting because i i just like i said i only did it for for pet projects sl for tools and tools are very like kind of one-dimensional and i i even rewrote one of my rust tools in typescript just to make it easier for other people to use run and be more comfortable with you know like i i i i was willing to do that there are things you could do to make these other technologies fit here i know that people have hacked stuff like java to fit in here with languages that are built on top like scala i know people have tried to make ruby run faster by porting its runtime to stuff like java none of these solutions really filled this middle out great i think java does fill this like any of the java stuff if you're really good at java you can whip out a lot of services and you can do a really good job pretty easily like i mean most of netflix backend is just java people can do it that's like definitely an argument of familiarity um java spring totally totally can do it and it's much faster than java js or typescript it it can do quite a bit in my my language triangle it is it is further up the triangle of performance uh and so it it can most certainly do that but then again you have to do java which a lot of people have a visceral reaction to hearing that they're doing java colin i assume has the same thing uh i'm sure cotlin has fairly close similarities look looked into it js has atomics for shared array buffers oh really i've only just gotten into workers for a large project i'm beginning i'm currently in the play phase keeping it uh fun by applying the creative coding nice that's super cool that's super cool that they had i didn't realize that they had synchronous uh yeah synchronization honestly if you're doing a big project like this and it doesn't have to be done it it's not a ui i would just strongly consider looking at something like go like i think you'll find your life a lot easier having better uh better concurrency semantics better better parallelism and better concurrency semantics than than something like using everything it's all web- based then if it's all web- based have fun with javascript have fun with javascript though this is where things get interesting this is the goal of go is to be this middle and as of recent they have pushed further this i don't think that's the goal of go i honestly think the goal of go was this to begin with i think the goal of go was to take people who are relatively inexperienced in larger uh larger enterprise systems and to be able to make them as effective as possible i think that the original design intent of go was actually developer to velocity if i'm not mistaken if you go if you go and listen to um rob pike i'm pretty sure that's what he said the goal of go was to make people who don't know how to program to be as effective as possible so i actually think it's it's it's this is go incidentally is fast because it was designed by smart people right i think that's that's what it is that's what i read yeah yeah rob pike was very very certain on this they failed didn't they i don't think they failed at all i really don't think they failed as someone who's writing their first real go project i'm loving i'm loving it i'm shocked i'm shocked at how much i enjoy it way with the introduction of arenas in order to understand the importance of arenas you first need to understand are arenas i i did i thought arenas are still in um uh experimental mode i didn't i didn't realize that they have been officially uh they're gone they gone oh they they left them arenas are dead arenas are dead yeah i thought i thought i thought i remember reading something about that uh they left a lot on the table that's fair uh but arenas are very very exciting you know i mean i do like the idea of arenas why there is a g by the way i do i do do this this is uh so hey just watch the video i'm going to give you a ban i hate when people tell me how to run my stream just play the video i'm going to also ban you i i don't i don't want to see your messages just real talk okay this is me talking about the video it's it's my choice to make it's my choice to make that get them out rip bozos app between nothing's more annoying than having someone tell you how to do everything right like i'm not here to make you happy i'm here to talk about this video and the way i want to talk about it you know what i mean like that that's like that's how it works that's how life works if you don't like it you don't have to okay you know i want you guys to be able to enjoy it and if you guys can enjoy it i try to make it enjoy but i just try to talk about all the thoughts that come to my head you know what i mean performance and the reason is pretty simple it's garbage collection since go doesn't require you to deallocate memory once you've allocated it it needs to spend some amount of compute doing that for you it keeps track of how many references a bit of data has and when it runs out of memory or has a fair cycle it looks through all of the memory references sees if there's anything in memory that isn't currently being referenced and it nukes it in order to do that yeah it's very complicated garbage collection is super cool by the way hey thank you everybody for the subs this is the longest react video i've ever done so this is we're like well into we're into an we're into a long time right now has to take away some of your potential performance in your runtime in order to clean up the mess you left behind and that is really good for the agility of you and your team as developers because you don't have to think about that problem anymore and believe me thinking about memory allocation will always make you slower if there's anyone who uses russ that says they can build generic solutions to generic problems faster than a typescript dev can they're lying through their goddamn teeth because i actually completely agree with that it's extremely like there are there probably does exist somebody that can but they're doing like sin macros right they're like they're popping out these like procedural macros that five people right five people can do right you to be able to do generic solutions like that is is extremely difficult the borrow checker will always slow you down for iteration in specifically massive changes if the architecture of what you're building changes if the needs of your project change if the spec changes while you're working on it your ability to pivot and change direction with rust is nearly zero because you have to bake so much of your intention into the code in order for everything to work with by the way i do love rust the borrow checker slows you down such that you hopefully make better long-term decisions that's the trade-off the trade-off isn't pay me it's a pay me now versus pay me later tradeoff i think it's a good trade-off it's a very interesting trade-off i think we can all agree but it doesn't mean it's perfect right garbage collection there's way less code that manages all of those things and making these changes is significantly easier but not everything needs to have that level of flexibility there's a lot of projects and a lot of packages and pieces we use every day that are pretty rigid like the thing that reads a file from our system and gives us the result like a json parser a lot of these tools and technologies pretty rigid in how they work and what they do so having to worry about those garbage collecting constantly in the background isn't great the go teams never pretended that garbage collection is magic and free and not going to cause performance issues that you wouldn't have in other languages it makes you way quicker to write code and it's not a big deal in terms of the performance impact but it is big enough the reasons why o camel has some pretty interesting stuff on that i i still need to do a react video with tj on the last on the last o camel article but there's some pretty cool stuff that o camo can do he' want to opt out of it this is why go had planned to introduce a new feature called arenas which as i was recording this i learned that it's on hold indefinitely the goal here was to allow for perfect so to speak performance for core packages and reused pieces like a systemer or since those have expected inputs and outputs that aren't going to change anytime is oaml managed memory or garbage collected it is garbage collected but it has this idea of local and global and a other items that look kind of like rust except for it's not bound to the type it's bound to the function and you can technically get like stack allocation it's pretty dang interesting so it is definitely a managed memory but it's managed memory in a very interesting way i'm soon it' be a pretty good use case to not let garbage collection handle things there and just make memory safe code for that are most reused across all go projects i was really hyped on this proposal to the point where i was thinking a lot more about go and taking it seriously and that's why i'm heartbroken to have learned now that it's on hold indefinitely because it seemed like it would solve a lot of these problems and most garbage collection problems and go are fairly solved um even like that whole discord thing with the things being super super slow i mean first off that was just a really old version of go that they were using where it does like a timed garbage collection that's why this that's why the spikes were so even uh but b there's a lot there's a lot better like go has one of the best garbage collections and now there's a lot of things you can do to t to tune it quite a bit and if we go back to the diagram it seemed like i gave go the opportunity to slide way further this way this is why i'm concerned because go seems perfectly happy sitting in the middle right here and that's resulted in it not being that interesting to me as we've hinted at a bunch throughout this in other videos there are ways to push any technology a little bit in the other direction jav and typescript we have some really cool stuff happening with bun that's going to slowly expand the it doesn't technically i mean you're you're that that's the reason why bun is so fast especially with all the async stuff is that if you look at node there's this like this there's this whole promises hook thing this is where a bunch of like projects and all that can that can that can take advantage this is how a data dog collect stuff and all that uh bun bun just didn't do it bun bun be like he gone and so it's like it it's faster because it's just not doing stuff promise hooks right there's a whole bunch of promise hooks and stuff like that so it's like there's a whole bunch of async handling stuff that node does that is more enterpris than bun does you don't need those if you're not build like if you're building something different it's a good trade-off to make it's a trade-off you can make but you just have to know that type of performance we can get out of our javascript code with rust as the tools keep getting better the education and resources continue to improve and ideally the compiler gets faster and easier to work with we'll see rust getting easier and easier to adopt but with go i don't know where they're going to end up and that's the weird part for me let's say we start i really think theo needs to actually talk to new developers on this uh because the problem is is that all new developers that you you talk to are all trained in boot camps right now and they're all coming through with the pre-existing knowledge of javascript they forgot about the six months it takes of learning all the quirks of that language versus the month and a half it takes to learn all the quirks of go and so it's like i think there is just like a large difference here that it's it is feeling a little it i think go has significantly higher developer velocity and this is coming from someone who's never done go in any serious reason until the last like three weeks and now i'm like oh wow yeah that's a lot faster than i thought i'm a lot more productive than i ever thought i was going to be and i think that just has to do with me building the things i want to build so i'm not saying you know better for worse and i'm not even by the way that was not a on boot camps boot camps i think like gen real talk i think more boot camps need to exist that are longer like that's the real problem boot camps are too short and that's where the fundamental problem comes out of i think you need about two years of solid training to be able to get anywhere near it and i think that if there's companies that would uh participate in that replace un i think i i think university is great i prefer university but university does not make you practically useful you will be more useful in four years due to a university but boot camp makes you more useful in two years i like like the difference between a boot camp and a uh university is very very simple when you like here here's the time period right so this is four years this is a boot camp you come out of a boot camp like getting pretty useful and then i think you slow down because you have to really self-learn to get better and i don't think most people do that most people just do what they do university on the other hand you are like this but you have so so much foundational knowledge that when you encounter problems as you start doing it for real you your your your your peak is way way higher and so like after six years almost always university people have a huge advantage over base camp people the thing is is that base camp people they're like like if this is the line of higher ability like this is where it's at right this is where this is where that higher is and so boot camp people have this illusion of being more useful quicker but i think long term it's a lot of pain because they don't have all that foundational knowledge so i'm not saying that you should do one or the other that's why i'm saying i think boot camps need to be longer right i do just think that if you could go to a boot camp for two years that really maybe takes a bit more like good stuff i'm happy about that totally agree un unis these days have terrible something something terrible content something someone disagrees about something um i i hate to tell you this but you're wrong learning about a compiler is completely useless and you will not be a great a great practical software engineer but you will understand javascript at a level in which no one coming out of a boot camp can so is it useful no yes well it's hard you can't really say it's you can't you can't really say it's it's useless you can't really say it's useful right it's very very difficult and if someone does a lot during university they can become extremely useful as they start applying practical knowledge to how much they understand about the underlying system they take off much much faster now do i think that universities teach stupid stuff of course a lot of times you're going to be learning java like i don't think that that's necessarily a good language choice these days i'd much rather see them learn something else honestly i'd rather see you learn c++ or rust than java just because it's easy to learn java when you know c++ it's not hard at all right like it's not hard to learn java when you know these other languages it's hard going the other direction with javas and typescript and we start to hit performance issues like the performance is here but our team has now landed where our needs are at the very least here and maybe every year our costs are getting higher so our needs are shifting more and more towards performance the weird part of the spectrum as it stands right now is that we start here where we just want to see if this thing works we i think one more thing you got to take take with this is that theo also is a very big uh react proponent and i think react fundamentally makes go hard like if you are doing react and you're building your uis around react i i i completely actually agree with theo that using go would be like a downgrade in velocity so so i so maybe this is actually a very accurate graph based on like what he has to build i could i i could actually completely buy that now that i think now that i think about this uh it is react is very difficult to use with other languages it just is there's nothing there's not like there's not that's not inappropriate take it's it's a pretty normal take whereas like if you use something that's a little bit like you know like if you had absolutely no framework and you wild west your ui you could use any language on the back end there would be no there would be no no need to do anything right whereas if you use something that forces you more and more into the like javascript ecosystem it's harder and harder to break out of the javascript ecosystem like you would have to have only very backend services be and go and then you'd have to have a middle layer that is going to be react server components you know what i mean like there you'll really have to think about these things it's just different slide more and more and then we hit this point where javascript and typescript might be hackable for better performance but it's not going to be a great experience overall and then we have a long ways to go before these other solutions make sense by the way i don't think react is is garbage i think react is very very interesting i love what it i i love some of the ideas it brought to the ecosystem i'm happy with some things it's just not for me i find it i i just i personally think it just makes things more difficult eventually i think when you're first starting off i think it's very easy to see the ui as react is built i think jsx is a natural way in which your brain works to build a ui but i think that overall you will have a more complicated project that's that's harder to scale as as features go up like that's why i don't that's why i just simply don't use it i like i don't like that you know what i mean like that's just not for me you know what i mean and unch valley is where go is strongest and as such i think it has a great opportunity to continue expanding left so that the team doesn't have to change technologies right now my general recommendation for companies is to start with javascript and typescript if they don't have immediate massive performance need to have something faster or more maintainable and when they hit the point where the performance of this solution is bad enough that's when you eat the cost and move to rust so i actually disagree with that take uh fundamentally i think it's easier to start with go and htm x on almost all universal projects most projects i see are just extremely simple and they need exceptionally little front-end logic uh there's front-end logic only because you use something like react right you baked in the logic and the state management into itself i think it's honestly i think you i think you could build any product significantly faster using go and hdmx than you could javascript and react and all those things now obviously right now react has the most focus so i think it's probably easier at this current moment to do login all these different things using react because there's just there is a very well-built e ecosystem around it i would love to see if if i mean if hdmx had the same level of ecosystem when it comes to logging in and some of those other items such as you know checking out and all that i think it could be i think it could honestly be just a giant rival it's just that i don't want to uh i like me personally i don't want to do that if you're building a spa i wouldn't agree i think that it's easier to build a spa with hdmx i like theo by the way so anyone that thinks like i'm going against theo i like to have these con conversations with theo because we agree to disagree and that's great i drew these lines really strong but the reality is all of these things are way blurrier than i might have led you to believe here in fact i would argue that these are near touching as a result the time you would spend in that theoretical bad zone here isn't that big and if you know where your performance needs are it's a lot easier to make a decision this is also why go is so interesting because many companies just will never be here for example twitch like twitch's internal services will almost always get enough traffic that spinning them up on a javascript server that has really bad error management and might crash in various unexpected ways is just not a real option for you and as such go allows you to compromise by the way that's a that's a very fair take and also also i want you to take a quick second and realize what he just said there dev velocity is not containing error management so for me that's part of dev velocity is being able to make a strong service that can live at infinitum and so for me that's a very important part and so i think we could also we may just simply define dev velocity slightly different and i think that's okay like i think that's okay because that's it's a madeup word that doesn't make any sense and it is completely relative to everybody that uses it right a little bit of that velocity in order to go way further down the spectrum of performance but if you want something that handles every single bite in memory as efficiently as possible go will never be the solution for that especially now that arenas are killed that all said i've seen rust being adopted for way too many problems that fit squarely within go's wheelhouse common one that i'm seeing nowadays is compilation we have a really fast compiler for typescript now it's called es build it was created by evan wallace during the end of his time as cto of figma because he wanted the job builds for figma and other companies at these huge code bases to be faster and he concluded that javascript was the wrong language to do that work he picked go as the language for es build and the result is a core piece of tooling that is used by almost every modern javascript solution if you've used vit before v is built on top of roll up and es build es build in dev and roll up in prod that's why by the way if you use like s swc s swc is really good too it's just that it doesn't have as much features um and if i'm not mistaken s swc doesn't support um decorators yet i might be wrong on that one i i know i i i looked at something and i know either es build or s swc doesn't support decorators one of the two uh don't but like there's still some things that are interesting about it but the difference in performance is fairly negligible meaning if you're compiling 10,000 files you're you're you're you're talking in the um you're talking in the millisecond range that they're going to be different so it's like why not do something that can why not use a move fast language to build something that can keep up with with features the reload times decorators you don't deserve your code go sadly if we look at the contribution chart for has buil a fact you'll see very clearly the vast vast majority is evan by like a lot and when you compare this to other devs like the next biggest has 4,000 lines added and 16 commits evan has 3,800 commits this is a oneman band and rather than try to fork it or build into it or build more around s build it feels like everyone's been trying to reinvent it in rust now we have s swc rs pack turbo pack roll down which is a rewrite of roll up in rust it seems like as the ecosystem realized the need for faster javascript compilation we left behind one of the most valuable parts we left behind go and i don't know if that was the right call all of the rust b by the way great take by theo i think this is a really good take i think that a lot of these projects could have been delivered sooner using go maybe they are maybe they are faster you know i i'm i'm positive uh i am positive that they're faster but i really like that i actually genuinely like compilers considered have had a really slow adoption life cycle and even slower iteration s swc just hasn't kept up in terms of feature additions it's getting there but it just hasn't gotten there yet turbo pack has notoriously been a mess and they've massively descoped the project in order to try and get it to actually ship it seems like a lot of these projects that committed to doing what es build did but in rust instead of go have ended up stuck in development hell and i don't know how much that is to blame rust versus the project management versus the massive goals and scope of lot of these projects all i can look at is the results and say definitively that es build has still had the best results of anything in these tools and i don't know why we didn't learn more from this project i've talked to a lot of de great take i love i absolutely spot on i think with this take which is uh i love i mean the problem with the rust side is that did you hire the right people were the right people involved was it a bunch of people that were novices at rust being excited about it being fast and you know you could have it could have led to just really bad stuff right i think that really talented rust engineers can most certainly write all these things very very well but i i don't know if the average r person can write some of these things as well i'm very very very i'm impressed with i i'm genuinely impressed with this take because i think it's very balanced which is we should have used there's easier languages that get the 99 right they get 9 go is literally like 98% of the performance of the average rust application the average go and the average rust is probably different by that much you know to work on a lot of these things and most of them don't have a good answer either it feels like they went with rust back to if you're over here if you live in this world and you're in conant pain because of it you're stucking with these languages that just aren't fast enough for what you want to do it makes sense that when you look over the fence and you see rust on the other side that's what you want to reach for and grab and use but the fence the thing in between the two that thing is go and i'm honestly feeling a little bit of guilt because i've been part of writing that off so i've always said like if you're on this side did theo accidentally just mentioned chesterton's fence are we accidentally having a chesterton's fence moment right now damnn damn we're having a chesterton fence moment aren't we oh it feels good it feels good and you need to be on the other side just go to the other side but there's this whole space between that we ignore because we strive to jump the gap javascript compilation doesn't need to be perfectly memory safe javascript compilers don't need to be in a language that requires you manage every bite of memory and handle borrow checking and all of these things correctly javascript compilation doesn't need to be as complex as rust allows and i honestly think we would be in a better place as an ecosystem if javascript had centralized a little more around go instead of rust but i could be wrong here too the same way i was wrong in believing go was a bad choice for us in webdev i might be wrong that rust will dig us out of this eventually it's very possible that by the end of the year maybe even by the end of the month we'll see a lot of those projects i've talking about before get to the point where i can meaningfully adopt them but the harsh reality is i've shipped es build production many a time i've never really shipped these other alternatives i think we used the s swc compiler in next now for some of the transpilation but it's still webpack at its core i think go has a really good opportunity in this middle ground but again which is kind of the theme of the video by not being one of those extremes go has ended up being significantly less interesting i'm just curious how the rest of yall feel because the more i've soul searched the more i've realized that i kind of didn't give go the credit it deserved for where it sits and even though i just learned arenas aren't happening and that is definitely tapered my hype around go once again i do think it's important to not leave behind as we learn more lessons about the tools and technologies we're building with and i still think that just maybe we screwed up going all in on rust when we had a good enough language right there how do you feel about all this and am i being too negative about rust i think i think pick you said it best go is mid and it's and it's perfect like that i i think that's one of the hardest parts about go i think go's biggest adoption problem is not anything except for what theo said at the very beginning i want to feel smart and i think complex types that really perfectly say exactly what you want that are very very exactly super amazing autocomplete being able to hit it with the generic sub doing all these things blah blah blah blah i think that it's very very easy to see to see that and want that whereas i just don't believe it's actually that useful right i think that it it just feels good and at the end of the day it's not great go is pretty boring the only exciting thing it has right now is generics and it's not even that useful exactly they're like kind of useful kind of useful generics they're useful enough that you can now do a bunch of array operations right and you can also do options now so it's like that's that's really good uh good video i thought this video was very good by the way if you i think this video was very very very well done always watch it you want be more negative about it i'll pin a video in the corner where i do just that good see you guys as always see you later peace n oh there we go i thought that was great i thought it was a great video i think there's a lot to it go generics are actually well done for go i cannot grumble about them too much neither can i i mean they're very simple and they keep it simple right you can do what you need to do without without all the like the thing is is that i would have been sad if they would have added in the complexity of typescript or uh rust into it like that would have been sad for me i would have really disliked it i think this video was great i know you're saying it was okay i think this video was great because this video was a like the thing that a video that i like is a video that makes me argue with myself a video i don't like is one where i pat myself on the back being like oh yeah i was right oh yeah this is correct right i actually find those videos to be one of the most like those are like the most boring videos this is a good video because it made me really think like am i even correct on what i think and i actually found myself half agreeing with theo have not agreeing with theo i know i was more vocal about the things i don't agree with him on but that's because i think it's boring just be like oh yeah hell yeah hell yeah and then like what am i going to expound on say what he said again right is he your brother no he's not all right let's see velocity wise in my opinion a go belongs all the way to the right only exception being what you said about rsc yeah i think that's where things get confusing um i don't know i liked it do you two share mustache tips no we shared mustaches um not just the tips uh i don't know i i enjoyed it go doesn't let's see go doesn't make tip masturb masturbator erect the only problem honestly that is a real problem it is a real problem of of go is that it is boring and people don't want boring but i in my older age am fine right now with boring i'm going through a very like i'm going through the renaissance of boring is what i like to call it uh i've just been all about trying to be as boring as possible in every last thing i'm doing because if i don't i'm going to be really sad by the way what's coming up next uh for all those people that are on youtube for all those people that are on twitch we have a pretty exciting set of things coming up i want to let you know i i'm very excited about the planet scale thing i even have a special guest coming on here very soon theo looks like owen wilson's mobius charact dude by the way owen wilson and theo that's a fun that's a good one that's a much better one so i'm very excited about all this the name it's the prime gen