all right hey c++ paper paper cuts uh my current day job is now again a c++ rule hertz i' i've been there i recently had that happen like six months ago where i had to go back into c++ land for a while always is emotional bruising uh and so i find myself yet again focusing on this blog post on the downsides of c++ overall i have found returning to active c++ dev to be exactly what i expected i still have the skills and can still be effective in it but now i have uh worked in a more modern programming language with less legacy cruff the downsides of c++ sting more isn't that funny how that is like when i used to program for i7 and 8 ie8 felt like a godsend ie7 felt horrifying i think the rest is very very obvious as your environment and things become more modern the feeling of pain becomes more real uh there are there are so many features i miss from rust not only the obvious safety features uh this one i feel like um like the quote unquote safety features just throw things in unique pointers and shared pointers and you you have like 95% of what you got from the borrow checker it's pretty nice or even primarily those but also features that c++ could easily add like some types uh called enums i mean you have t you have you just have less convenience syntax for this i mean you still have that you just have to make a little union type discriminator and boom you got it right it's annoying but i get it i get it or first class support for tupal but it doesn't quite have the same it's definitely more dangerous i will i i agree with you it's more dangerous it's more dangerous uh i i you know or first class support for tupal uh actually i do like tupal tupal are glorious uh tuples are glorious until i use them i swear every time i use a tuple that zero and one syntax triggers me it just triggers me you know you use a tuple because it's convenient and then after you get done using a tuple you realize a struct is no different than a tupal but it just has nicer names and you go why am i using that smart pointers are slow this is true uh smart pointers are much slower you're absolutely right but so is the 1,000 calls to do clone in my rust program okay that also is very slow that also is extremely slow so it's like which slow do we want to use i don't know which slow would you like to use i'm just saying i'm just throwing it out there that i agree that having a compiler check the unique pointer of things is much better but they are slower uh before i start getting into the paper cuts though i want to address one of the primary defenses i've seen of c++ one that i found particularly baffling it goes something like this c++ is a great programming language okay that is baffling i don't know anybody that says this like i don't know anybody other than game devs that say this okay this is very strange take what is this uh the complaints are just from people who aren't up to it if they were better programmers they'd appreciate the c++ way of doing things and they wouldn't need their hand their handheld language anges like rust are not as helpful for such true professionals the thing is is you can make the identical argument for rust you start using rust and you make some bad design decisions early because you don't understand and then you get into this point where your program becomes just unmaintainable without a full rewrite because you've just just done up the rust way of doing things and people are like well if only you understood the idiomatic rust way of doing things again it's all skill issues in all languages that argument is just a a snoozefest it's always been a snoozefest it will always be a snoozefest and it exists in every language it's just some make it some make it easier for you to go longer with your bad decisions and i think that that's a good thing okay i'm going to throw that out there that's why i think go is so successful because you can go longer with a bad decision than you can in rust think about that for a second obviously the uh the phrasing is a bit of a parody but i have seen this sort of attitude so many times the most charitable view i can take of it is that a a claim that c++ difficulty is a sign of its power and the natural cost of using a powerful programming language what it reads like to me in many cases however is a form of elitism a general idea that make uh making things easy for uh poor programmers is pointless that's why we invented uh javascript okay you let the poor programmers use javascript i'm getting canceled today boys uh and that good program don't benefit from making things easier uh as someone who has programmed c++ professionally for a majority of my career and who has taught a company inter internal classes in advanced c++ this is nonsense to me i do know how to navigate many paper cuts and foot guns of c++ and i'm happy to do so when working on a c++ code base but experience as i am they still slow me down and dist uh distract me taking focus away from the actual problems i'm trying to solve and resulting in less maintainable code yeah i agree uh it sucks i am no defender of c++ as uh as for the upside i see very little any way in which c+ plus is more performant or more appropriate than rust in terms of platform support legacy code bases optimization that are only available in specific compilers that often or that happen to not support rust or other concerns irrelevant to the actual design of a programming language i mean there are in there are a lot of things that are very nice you know like when you're doing uh a uh an array of strs and you're mutating and you're playing around the amount of dancing and things you have to do in rust are not as much as you have to do in c++ granted there's more foot guns but there's things you can do in c++ that are just simpler problems to solve than you can do in rust uh while i'm proud of my c++ skills i am not too proud to appreciate the better technology can render them partially obsolete uh and i'm not too proud to appreciate that uh having features that make it easier in most cases it's not a matter of programming languages doing more work for me but of c++ creating unnecessary uh extra make work yeah this is this is perfectly reasonable take often due to the decisions that made sense when they were made but not long since stopped making sense don't get me started on header files yeah header files are a bit emotional for me um me hates it i i do want you to know that i'm not ragging on rust it's just i think that people with excellent c++ background are the worst rust is the greatest people because you can take you can almost virtually transfer all of your thoughts about c++ onto rust you know what i mean the reason why header files suck is that it's called the module why do you need to define the same thing twice what the hell are you doing defining things right it makes it literally makes no sense that you have a file that says here is what my class looks like and then you have another file that says here's how you implement it and yet it's for better compilation speed you know what's way cooler single pass to create the header second pass to create the thing okay it's called a two pass compiler or a three pass compiler or an n pass compiler okay they've been doing it for years somehow i'm able to state several functions that will be used and it doesn't have to compile the whole gosh darn thing to figure out what the hell i'm exporting right it doesn't have to be crazy yes yes yes and header file still has all the private members of the class inside if i remember c++ is seven passes which is crazy i don't know if that's true but that's wild right single pass you can get the shape of things right you can make these decisions you don't need something to tell you what's already available uh but i also want my programming a language to be beginner friendly i'm always going to work with other programmers who have a variety of skill sets and i would rather not have to clean up my uh colleagues mistakes or mistakes of earlier more foolish versions of myself if making a programming language more beginner friendly sacrifices power then i agree that some programming language should not do it yep i yeah i agree with that go go is a great language for this but many even most of c++ beginner unfriendly and expert annoying features do not in fact make the language more powerful so without further ado here are the biggest paper cuts i've noticed in the past month of returning to c++ development love it love it con is not the default yeah i do agree i think that this is probably a better way of doing things i do like the idea of specifying mutations as opposed to spe specifying um specifying uh constant i think that's a better tradeoff to make uh and remember with javascript you have to do a const const right they're const pointers they're not constants so it's like a double one you got to be extra careful uh it is very easy to forget to mark a parameter con when it uh when it can be you just forget to type the keyword see that's the thing is you never forget the type the mutation word but you will always forget to type the const word it's very very true this is especially true for this which is an implicit parameter there is no time when you are typing out this parameter explicitly and therefore it won't sit there looking funny without the appropriate modifiers uh if c++ had the opposite default which every value reference and pointer was con unless explicitly declared mutable then we'd be more likely to have every parameter declared correctly based on whether the function needs to mutate it or not if someone includes a mutable keyword it would be because they uh know they need it yes it actually i i do i love this take by the way i think this is one of the big wins of rust in other languages like o camel o camel pioneered it for rust i think there's i'm sure those languages o camel got it from if they need it and forget it the compiler error would remind them exactly exactly you want the compiler to tell you when you're wrong and this is beautiful now you might not think this is important because you uh can just not use con and have functions with capabilities they don't need but sometimes you have to take things by const in c++ if you take a parameter by non-const reference the caller can only use l value to call your function but if you take parameters by const reference the caller can use l values or r values so some functions in order to be used in natural ways must take their parameters by cons reference once you have a cons reference you can only easily call functions with it and accept uh con references and so if any of those functions forget to declare the parameter const you have to include uh const cast or go to the function later and correctly accept con unless you think this is just a sloppy newbie error note that many functions in the standard library had to be updated to take const iterator instead of the addition to iterator when it was discovered correctly that they made sense with a con iterator uh functions like erase it turns out that for functions like erase the collection is what has to be mutable not the iterator a fact that maintainers of c++ library simply got wrong at first that's pretty impressive to get that wrong right obligatory copying ah sounds like are we talking about about rust now is this rust are we talking about rust in c++ for an object to be copiable uh is default okay i do i do actually agree with this i hate the fact that default is copy there's something so effing emotional about the fact that when you take a vector and go const a equals this vector con b equals a you got yourself a copy and there's something it just it it i i agree i agree i've chased down many above has been due to that one thing just just hurts if you don't want your object to be copiable and all of its fields are copiable you often have to mark the copy constructor and copy assignment operator as equal delete the default is for the compiler to write code for you the code can uh code that can be incorrect yeah yeah if you do make your class move only however beware because that means that there are situations where you can't use it and c++ 11 there is no ergonomic way to do a lambda capture by move which is usually how i want to capture variables into a closure no similarly uh the standard function expects the object it manages to be copiable and will fail if compile if your closure object is move only this is going to be addressed in c++ 23 which should come out in 2020 in 2033 uh with standard move only function but in the meantime i have been forced to write classes with a copy constructor that throws some sort of runtime logic exception and even in c++ 23 copyable functions will be the uh the default assume situation i love runtime exceptions for things that should not be runtime exceptions feels good using standard function not like this this is strange because most complicated objects especially closures are never and should never be copied generally copying a complicated data structure is a mistake missing a and or a missing standard move but it is a mistake that carries no warning with it and no visible sign in the code that a complex allocation heavy action is being undertaken this is an early lesson uh to new c++ devs don't pass non-primitive types by value but it's possible for even advanced devs mess up from time to time and once it's in the code base it's easy to miss agree i dude i this bites me at least every time i start back back up in c++ this bites this bites me once i mess up something and it takes me like a a good oldfashioned gdb printa time to figure out what the hell did i do wrong uh bu reference parameter paper cuts it is unergonomic to return multiple valuables by tuple and c++ everybody loves standard tupal come on it can be done but the calls to standard tie and make tupal are long-winded and distracting not to mention that you'll be writing un idiomatically which is always bad for people who are reading and debugging your code as a result c++ often resorts to out parameters i love that c so thoroughly loved the idea of out parameters you actually have an out keyword so that you can have out parameters in c chef's kiss on making hard code uh in this as well as other situations uh you end up taking a parameter by non-const reference meaning the function is supposed to modify the par uh the parameter the problem is the only uh this is only marked in the function signature if you have a function that takes a parameter by a reference the parameter looks the same as by value parameter at the call site really return let's see return false on failure modify size with actual size message decreasing it if it contains more than one message message nice dude who abbrev message like that okay can we just time out this entire thing and just realize that this is that that i i personally have some problems here okay i got some problems going on here long before any of this is taking place you know what i mean that is cursed it is cursed messy that's totally unhinged dude it's totally unhinged if you're reading the calling code quickly it might look like the resized call is redundant but it is not size is being modified by got message the only way to know that it is being modified is to look at the function signature which is usually in another file yeah i do agree again specify specifying mutations are better than specifying constants i think it's just generally accepted that it's true 100% at a time some people prefer out parameters in and out parameters to be passed by pointers for this very reason i can purchase that this is great or would be if pointers weren't nullable what does a null pointer parameter mean in this context it is going to be is is it going to trigger undefined behavior what if you pass a pointer from a caller into it people often forget to document what functions do with a all pointer options are just a great way to to type system specify this and i love it um this can be addressed with non-nullable smart pointers but very few programmers actually do this in practice we are like we kind of require ourselves at netflix to do this smart pointers are great in general they're great yeah they're a little bit slower but you know it's really slow debugging that's really slow okay that's emotionally slow you know it's you know it's even slower the javascript were running underneath okay now that's the where the real slowness happens when something isn't the default it tends to not be used everywhere where appropriate the sustainable answer to this is changing the default not uh heroic attempts to fight human nature fair uh obligatory side gripe at least in non-owning situations like this it is possible to write such a smart pointer however if you want to write the obvious uh companion a a non-nullable owning smart pointer a companion version of standard unique pointer then it cannot be done in a useful way because such a smart such a pointer cannot then be movable i don't quite understand that this man has too much c++ power for me to understand method implementations can contradict oh this sounds exciting just always write the code correctly the first time lol fourhead five head on head i refuse to use smart pointers interesting really you refuse to use them is it because of the atomic increment i wish there was like one thing i say that rust also does very well is not allowing nonatomic pointers to be po to be passed between threads i think that that that's a really nice thing because that way you can have a literal plus one a very simple you know smart pointer the rc to be passed around and then you have the more costly arc when you need something right smart pointers are awful they're not that bad awful a pretty int word for it they're not great okay i prefer having my compiler be a smart pointer but but awful is a little intense yeah if you have a if you have a c api don't use a smart pointer um anyways all right for many cases uh for many classes the default implementations are enough and if possible you should really rely on them or you should rely on them whether or not this is possible depends on whether uh naively copying all the fields in a sensible way to copy the entire object which is surprisingly easy to forget uh to consider absolutely but if you need a custom implementation of one of these you are on the hook to write all of them this is known as the rule of five you have to write all of them even though the correct behavior of the two assignment operators can be completely determined by the appropriate constructor combined with the destructor the compiler could make default implementations of the assignment operators that refer to those other functions and therefore would always be correct but it does not implementing them correctly is tricky requiring a techniques like either explicitly protecting against self assignment or swapping with bu value parameter in any case there are boiler plate and yet another thing that can go wrong in a programming language that has many such things wait until your friend implements a template for you to solve this problem gosh conclusion unfort i look at me i'm getting all steamed up i'm steaming right now unfortunately i'm too well aware of why these decisions were made and is exactly one reason compatibility with legacy code c++ has no addition system no way to deprecate core language features if new addition of c++ was made it would cease to be c++ though i support the efforts of people to uh transition c++ to new syntax and clean some of this stuff up yeah but russ doesn't break backwards compatibility either i think there's been one such case of a method being completely removed uh due to some gigantic security violation but even with the additions i don't think it it removes anything right i don't think there's anything that says that it can't be undone c++ 2 when you should see c++ 23 before we talk about c++ 2 okay buddy for russ is a new language yeah i know russ is a new language that's expanding exceptionally fast just wait for this article to exist with rust it's going to happen right however if you ignore backwards compatibil it's going to go back to o camel it always goes back to o camel don't worry it's coming back the arc's happening um however not not atomic reference counter by the way uh if you ignore backwards compatibility in the large existing code bases none of these paper cuts make the programming language more powerful or better just harder to use i have seen good faith arguments in favor of uh human- maintained header files surprising uh as uh that is to me but i challenge my readers to tell me what is beneficial about c+ plus plus's design choice in these matters i agree you might find these things trivial but these all slow programmers down while simultaneously annoying them if you are experienced enough your subconscious might be adept to navigate it but imagine uh what your subconscious could do if it didn't have to but how adept are you at seeing these mistakes in a code review from your junior colleagues impossible uh if you are a rigorous reviewer how much more time does it take how adept are you at finding these issues quickly when a bug arises these are great questions honestly this these are great things o cell sucks you suck okay you know what we're not going to have this you know what this is n 1984 going to happen right here that message never existed get the hell out that message uh what would be more effective uh let's see we'd be more effective more efficient and happier if these issues were resolved programming would be both enjoyable and faster to do what's the downsides the only upside is uh contin uh continuity with history and while i can see the value in that it is very limited value with very limited scope i agree this is a great article this is a great article on some of the c++ paper cuts i really agree with the the the uh the the the five one that is the rule of five it is just so painful and i've had it happen to me and it it's just like it can go terribly wrong okay hey c++ is cool but man does it have some foot guns the name is the foot gunen