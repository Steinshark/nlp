here i've written some c code that's vulnerable to a buffer overflow the fgets function reads in hex 100 more bytes than the buffer has room for obviously this bug is fairly trivial but this scenario is very easy to recreate in the real world when you're calculating things like buffer space remaining in a operation that requires multiple reads this code is vulnerable to a buffer overflow but i have stack canaries enabled which is a default feature in gcc and if i give the program more data than it has room for the program will gracefully fail with a stack overflow detected so here the file or input file is twice the size of the buffer which does overflow the stack but when i run the program i don't get a full crash i get a semi-graceful fail that a hacker could not take over the way this works is actually pretty cool so every time a process is created the kernel creates a random number that will be the stack can narrative that random number is meant to be a complete secret to the user so the user cannot replay it when they do a buffer overflow attack that number is put into a special memory segment at offset hex 28 and we move that into rax then we store that rax on the stack very very very close to the bottom here near rbp and again remember the rbp is the base pointer that's the bottom of our stacks anything above it is going to be negative to it so it's right at the bottom of our stack just above the base so this is a function prologue the beginning and this happens before any of my code gets ran so here is where my code begins here's a little snippet that actually reveals the stacking area for a future example but eventually i print it out and i open up the file and i call fgets all of this is code that i wrote and during this time the stat canary sitting there he's looking all cute he's on the stack he's ready to die for us respect the canary comment after that we begin what's called the function prologue and where the stack canary actually gets its use so what we do is we move the canary at rbp-8 into rcx and then we xor it with that magic value again and if the result is zero that means our canary was not corrupted nothing to worry about but if we don't take this jump we will call the stack check fail function which means our canary has died and our program is full of carbon monoxide pretty cool so what does the canary actually look like what does it do how does it smell how does it taste here i've ran the program three times each time i've added a little snippet of code to show you the secret canary it's not actually a secret you know you could check it out yourself the kernel doesn't care if you know the reason for that is that every time you run a program you get a new canary from the kernel and just c's and k's in there notice a few things one each time it runs it is random and unique pretty cool extremely hard to guess nigh impossible unless your rng is bad and you'll notice this last little character here is zero why is that why would a random value a value that's supposed to be non-predictable have a predictable value a lot of operations that lead to a buffer overflow are typically related to strings and how are strings terminated they're terminated with a null byte which means if you filled up a string buffer right up to the end of a canary and didn't have a zero as the least significant bit you could actually just print out your string and the canary would be revealed and again that's supposed to be a secret so by putting a zero at the front of the canary it basically gets rid of the possibility of you being able to leak out the canary via a string operation there may be other ways to leak it maybe with a hard read or a hard memory copy now i know hold on this sounds crazy i know hold on hear me out hear me out let's disable the stack canary let's try it let's see what happens now we gotta try some new things in life and this is going to be one of them disable the stacking area we're gonna do gcc tech oh all the regular stuff canary.c we're gonna say attack f for function or feature i don't know what the [ __ ] it stands for but attack f no stack protector boom so now the binary is there and if we run check sec on it again you'll see that there is no canary found so what does that mean for us what does that change about our functionality remember before we ran the program we ran it on the file instead of it being a stacked check failed buffer overflow detected we got a segmentation fault core dumped that is a very different error and the most important reason that it's different is because of what happened to our program in wyatt craft if we do we can run this in gdb real quick and just see what's going on so we'll gdb the canary program and then we'll say that we're going to run it with the the file as the argument and then we're going to see that our program crashed trying to execute instructions at hex 414141 4141414141414 there's a reason why this is extremely dangerous now if you're not sure what these four ones mean let's go ahead and cat our the file all of these a's are hex four one if you don't believe me we can do in python 3s we can do bytes dot from hex four one four one four one four one quad a boom by not putting a stack protector or a snack canary on our function we gave the file the ability to determine where the program returned to and ultimately what instructions got ran by the program this is the classic buffer overflow scenario for a hacker that wants to do evil stuff so in summary don't disable you damn canary now let's circle back to all you damn heat people okay i know there are some of you probably the minute you saw this video you're like oh my god just allocated in the heap all right fine fine you want to play that game okay i made the data buffer a pointer into the heap where we call malik x100 you had a notation to make sure that we actually get a variable back from malik and then we're going to do is we're just gonna load that file same thing and we're gonna also read in double the size of the buffer again you can buffer overflow on the stack you can buffer overflow on the heap and i'm not even going to disable it i'm going to use the default flags on the compiler boom we do get one little error about not including standard lib for malik but that's not a big deal get rid of that run the canary on the file why are there not canaries in the heap i'm looking at you libc maintainers obviously i'm joking i'm not making any real assertion that any kind of memory is more safe than the other obviously the heap contains data the stack contains control flow information so completely different and before you go i want to talk about a long time supporter of this channel that allows me to keep making videos like this improving the equipment and keeping the low level learning going this video is sponsored by brilliant.org the best way to learn something thing is to get your hands dirty and try it out and brilliant.org knows this their hands-on visual approach is an effective and easy way to make daily learning a habit in your life they have thousands of lessons that go from foundational to advanced and topics like math ai computer science and neural networks instead of just staring at presentations or slides all day you'll learn something new and then immediately be able to go in and try it for yourself and the best part is you can try brilliant for free right now if you use my link brilliant.org level learning you get a free 30-day trial and the first 200 of you to sign up get 20 off an annual subscription thank you again brilliant for sponsoring this video