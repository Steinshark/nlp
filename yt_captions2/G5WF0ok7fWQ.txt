i've already watched this guy's video once before not this one but another one so i'm i'm pre- subscribing i like i like this guy's video a lot i like him a lot all right all right all right all right let's go whenever i upload a video about my mario 64 optimization project i get asked about implementing the famous fast in wear square root function made famous by quake 3 this algorithm computes one divided by the square root of x only with still favorite line just just what the [ __ ] just right in the middle of the code we wa we actually watched this one this was like the first video i ever reacted to was the fast inverse square root algorithm and like a deep explanation of it and i cannot seem to remember any of it it was wild it is it is crazy that someone in some coked out nightmare created this simple operations by exploiting need properties of how the computer represents float point values this allows you to skip computing a square root directly which is usually very expensive and old computers often had to run much more expensive approximation algorithms like this one here i will explain to you why most of the time this is a bad idea but i will also show you when it is a good idea and i will even show you a little improvement over the algorithm listed on wikipedia that works faster and is more accurate for most use cases as well as a completely new spin on this algorithm by the way his game looks so good i want to play this game mario 64 was my favorite game like of all time potentially i loved this game and look at how good it is yeah zelda was better was zelda better i'm not sure i i go back and forth on that because i've beaten ocarina of time gosh i'm not even sure how many times i've beaten ocarina of time um probably' 20 25 times i've beaten majoro's mask like 15 times but man this one i mean mario i don't even know how many times i've beaten it it's just so good majoro's mass was greater than ur of time you're an ignorant [ __ ] it was not it was not better that is crazy easy to say that it was better ocarina of time was the great but uh but as an old man i give it a link to the past that might come in handy the problem with using the f got him got him got him got him scar algorithm is not that it is a bad algorithm but rather that most of the time on the n64 we have a much better option available to us the n64 has special hardware parts that let it compute the square root in the single instruction can anyone name the song that's playing right now right now name it really quickly forest temple thank you someone said forest temple right as i said nice nice job forest temple forest temple good job good job that takes 29 cycles this is the exact same cost the doing a divide instruction costs so if we compute 1 divided by the fast inverse square root of x instead of the square root of x we really just tch the cost and accuracy loss of this function on top which is all around terrible here is a table comparing the cycle costs for using the build and square root function and using the fast inward square root with 0 one newton iterations don't worry about what a newton iteration is newton iteration had to write that one out by hand uh nice nice i mean that's pretty that's pretty great i mean 59 cycles that's crazy but still pretty great one don't worry about what a new generation is just yet it's just a cheap little thing we can do to increase accuracy for this reason it only ever makes sense to use the first iners square root function if we actually want to compute one divided by the square root of x and never if we need the actual s beautiful additionally there is another issue we are not cpu bond on the n64 at all the n 93.75 megahertz i just want you to just take a moment and think about how shitty your website runs and you're watching mario running on a creamy smooth 60 frames a second on a 93 megahertz computer okay i just want you to think about that for a second i just want you to take a moment and consider your life and what you've built versus this you should be ashamed of yourself 64 is possibly the machine with the worst m to cp ratio of all time to render at 30 fps we need to finish a frame in 33,000 microc seconds in this scene you can see when you say it that way it just sounds like so many the cpu doesn't even use half of the time while the renderer needs all the time it can get the renderer and the cpu share the same memory so any optimization we make should aim to improve memory throughput to make the rambas go vroom vroom while using the square root and divide instruction to get 1 divided by the sare root of x takes 58 whole cycles it also only takes two instructions loading eight instructions takes 60 cpu cycles and it starts the rendering for a bit which is a whole lot worse than just running the cpu a little slower here is a comparison for oh you have to do more instructions and this causes a whole a whole situation going on here huh wild that is wild i mean first off this is this is incredible second off this just goes to show measuring is really really great right measuring just really eliminates an entire category of false premises computing 1 / by theare root of x if you look at the graph you can see that the instruction count for the fast in square root is higher regardless of how inaccurate we go this is because while the fast in square root uses a bunch of quick to run instructions that just move numbers around in memory it has to use a lot more than just divide and a square root instruction there is one saving rce here and that is cach code the cache is like a memory that the cpu can use all by it itself very quickly without disturbing the renderer it can hold 16 kiloby of information and it's our best friend as far as optimizations go if our code is already cached we don't have to pay any cost per instruction beyond the first caching making this negligable i've rewritten mario 64's graph rler engine to fit all into one block of code cache meaning if we use this somewhere in engine we can avoid this cost and make this whole column irrelevant but but even then there's an i don't understand how that works but that's awesome right like i don't understand how it makes it irrelevant fast memory oh that's on this is is interesting because it basically proves why risk workstations were expensive fast memory was really really really uh expensive and uh risk had flattened code and cisk uh this is why risk video game systems uh didn't scale well this equation is different now and arm will win yeah i arm arm is arm is quite wild another issue with the fast inverse square root function the accuracy is reduced we can use this for any type of code that values the accuracy more than the tiny performance benefit that this offers in this video i've used the fast andw square root to normalize the view matrix and while you might not be able to see the accuracy loss right away i think the accuracy loss is more noticeable than the 0.5 microc in cpu gain that this algorithm offers per use all of this means it's looking very grim for the fast and with sar function ever being useful but this is just the weirdest guy in all of zelda okay i don't know why this guy why was the mask guy okay what was what was his issue why was he so strange all these factors working against us is there ever a situation where it's faster that dude registered sex offender probably that guy's i don't trust the mask guy yes actually we just need to fulfill all three of these conditions one we want the actual inverse of the square root and not the square root itself okay two the code we are running is already residing in instruction cache okay three we don't need very high accuracy this leaves only a single use case that i can think of right now normalizing vectors for important graphical effects which is coincidentally the exact same use case doom had to make this algorithm as famous as it is normalizing vectors works by multiplying with one divided by the size of the vector and the size of the vector is the square root of all the elements added together meaning we can substitute 1 / the root of x with the fast inverse square root function here and our first condition is passed i managed to compress the code for the graph render into just 12 kiloby we just that is very funny just a bunch of the the little igen vectors got you that's all was i can't believe that this is also this is just incredible just watching this less than the 16 kiloby of in vector normies just a bunch of vector normies second condition is passed as well and additionally it is not important that the vector is perfectly normalized for unimportant effects like shadows so we passed all three conditions additionally we have a little advantage here because the inverse grare function has inaccuracies we don't have to worry about dividing by zero in this spot anymore and end up saving an additional free cycles for a total of 58 cycles saved this is another small advantage for the f and sare algorithm and it ends up making it just a tiny bit more valuable i went with the lowest accuracy version of the fast and with square rout which saved around 80 micros per frame on the cpu which means data is fed into the gpu more efficiently where it saved around 20 microc per frame which is a much bigger improvement than i initially expected from investigating this and the inaccurate you know when you hear this i don't think any of us have thought about 20 microseconds in a long time someone hire this guy for switch graphics can somebody just hire this guy for switch graphics please uh the wife he has the actual red pill moment uh with this video is none of the elegance was required uh to make mario a commercial success and would and wouldn't have helped much i mean that's the truth mario in all of its flaws was still one of my favorite games of all time and yet here we are are showing it could have been done much bettery is at most around 3% which is the difference between these two circles of course the average difference is much lower and i doubt anyone would actually notice the inaccuracy in no one would notice a 3% reduction in girth right it's just it's just a little it's just a little less girthy that's all just just a touch but the fast and west algorithm as shown on wikipedia was just a 35-year-old algorithm that wasn't fully cooked back then let's see if we can improve on it there are a few obvious accuracy improvements to this like optimizing all three constants instead of just this one here and there are a lot of scientific papers on a subject already that we could simply copy paste if you've been counting cycles throughout this video you might have thought that i was off by one on all the new durations but that's actually because there's a one cycle improvement you can make over the algorithm with them listed on wikipedia you can actually just bitag even harder and subtract one from the exponent instead of multiplying by 0.5 in a normal inverse square algorithm this sayes one cycle on the n64 and i've been comparing with this algorithm the whole time throughout the video it only works if your number is bigger than this tiny number shown on screen that i'm not going to pronounce but like come on your number won't be that small i can't imagine i'm the first to think of this but i figured i'd mention it before you guys cook me in the comments but since we actually use the simplest and least accurate version we only want to optimize the version of this algorithm with no newton iterations which somehow doesn't seem to have any research done on it so we can get to be the first to optimize it optimizing this is surprisingly very simple because by the way we've entered into the area in which my math knowledge has left the building um i don't know how a floating point number is represented anymore i know there is the mantisa and the exponent and i know that this uses the exponent as part of the trick but that is where i leave the building and that is it all i had to do for it is ride a brute forcer and let it run on my nintendo 64 overnight since all our vector ns are going to be in the range 0.03 to1 we can simply iterate over all floats in this range and try all the constants and then use whichever one ended up having the lowest maximum relative error running the brute for directly on the same hardware that this algorithm will run on also accommodates for all kinds of hardware quirks that we might not know of after letting my n64 run overnight the best constant and found was 0x5 f37 8171 classic which is not far off for doom us at all and improved accuracy by just 1.9% one other idea that syus lock had was to not compute the first and with square root but instead compute two separate approximation for the fourth inverse square root using two different magic constants pick to cancel each other's error out and then to multiply them together to get the inverse square root what a cool idea this gives us a 33% reduced error over the fast invers s algorithm but it does cost nine cycles more to give you a comparison the first newton iteration cost 24 cycl and it has 90% that's the i turn over to look at chat and all i see is this background ricky just real angry about it just could not handle what he's about to watch background ricky i get it ridiculous absolutely ridiculous brain shambles dude the idea of creating two constants that compete against the that erir in opposite directions is just just out just mantissa and shambles right now just use rea act just use react already increased accuracy i think all three of these approaches are valid and this new idea provides a pretty nice intermediate step i'm sure there are some cases where each of these free functions is your best choice and i bet at least one programmer watching this just went yo because that 33% accuracy gain was all they needed but this concludes my research on this topic i hope you learned something and i'll see you in the next video bye-bye dad i can officially say i have learned nothing i have learned nothing but i have never been more excited at the exact same time i have learned nothing because i am incapable of that level of of games you know what i mean i don't make games i'm not a games guy so i don't i don't i don't quite it was a watch more of his excellent vids i've watched one other one and they're they're great