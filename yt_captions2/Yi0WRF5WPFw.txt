fellow low-level rust stations welcome back today our adventure continues into the deep dark recesses of rust if you aren't already subscribed hit that subscribe button to follow along on our embedded rust journey in this series i'll document my adventures into embedded rust and today as promised we'll be learning how to write rust that compiles down to a flat binary and runs on the raspberry pi pico or the rp2040 now if you aren't already familiar with this board the raspberry pi pico is a small arm cortex m0 plus board made by raspberry pi meant to compete in the same space as smaller maker boards like the arduino the raspberry pi pico is closer to a microcontroller than a microprocessor board and as a result is not designed to run an entire operating system like linux luckily for us the rust embedded ecosystem is extremely well documented and actively supported meaning that tool chains exist within rust that will allow us to compile our code down to a format runnable on the raspberry pi pico most what i'll be talking about today here it can be found on the embedded rust documentation page and i'll link that down in the description below first to talk about embedded rust we first need to talk about the embedded rust abstraction model now to be clear there are two ways we could do this tutorial the first would be to write rust that uses the unsafe mode to directly access a memory address kind of like what i did in my first rust video and then use that to directly access our peripherals this of course is not only unsafe as the unsafe keyword describes but also is not scalable it wouldn't make our code portable as we added additional features we wanted to access more and more peripherals so instead we'll use the second and arguably correct way to do this video which is through the use of what is known as a hardware abstraction layer or a hull a hardware abstraction layer does just what its name implies it provides an api for the programmer to interact with the hardware without directly accessing it instead it provides a simpler easier to use interface and abstraction as the name implies to take the burden off of the higher level programmer when they write applications for the lower level device the structure of how a rust haul crate is actually designed is a bit more nuanced and complicated but we don't need to worry about that for right now luckily for us the embedded rust community has already designed a haul for the rp2040 we could in theory write our own haul however and i do plan on doing that in a future video but right now i'm still actually learning rust fundamentals and i figured this would be more educational and less dangerous to use one that already exists now i know in my previous video when i showed you guys how to actually install rust to run rust code um i said sudo apt-install rust c i said to do literally just this sudo apt install rust c um i realized looking back at it that this is actually the wrong way to install rust so if you did watch my video and partake in that horrific action i would do sudo apt remove rust c uh the reason for that is to get actually um better control over your rust environment you want to use the rust installer that the rust language provides on rustlang.org by running this line of code here basically that just downloads a rust downloads and startup script and pumps it into your shell and then that'll actually like install the most recent version of rust as notated by the rust maintainers so remove your rust run this piece of code um it'll actually yell at me because it's going to say hey man you've already got um rust on your computer but what's going on here uh we'll just you know run through this and let it kind of override it um once we have that we want to do source home user cargo m there's a bunch of environment variables that rust needs loaded up to run like you need to update your path to include additional rust binaries so that when you're doing all this package management through this the use of crates um that your code actually runs and the programs know what to do so once you've installed cargo and installed the rust running environment like this you want to actually go to this link here i'll put it in the description box and download the rp2040 hardware abstraction layer right so you're gonna go ahead and get clone that repo i'm actually already in it so i'm not gonna do that but if you open that repo up you'll see a bunch of cargo files and a bunch of you know additional folders where the actual hardware abstraction layer for the rp2040 lives and we're not going to go deep into all this code but there's a lot of good stuff here that allows you to do anything from use the timer interfaces to the usb interface etc um what we do want to actually go into we're going to go into the rp2040 hall and then go to the examples okay so we're going to be basing this tutorial off of the blinky example and we'll pull that up in sublime real quick also i want to point out real quick that before i go into this if at any time i'm not properly describing something or i do it in a way that you don't understand a leave a comment let me know but also the documentation for the rp2040 hall is really really good the link is here i'll put in the description box um all of the structures and functions of those structures are well defined in a way that you can go into these documents here and figure out what does this argument do why does this argument have to be in this place for this function etc so here we go we have the code up in uh sublime we are going to walk through lambda line to figure out what all this code does so on line one uh no std is no standard which means it actually puts the uh rust runtime from lib standard which is a standard runtime that rust runs with all the time and links into your binaries it puts it into lib core which is a smaller condensed version of the rust runtime with less features that allows you to do smaller application writing like for you know writing kernels firmware et cetera here we have nomaine that basically tells the compiler to not emit the main symbol and then also don't cry when we don't have a main symbol it just means that we're not going to call the standard you know call the main function to run our program we're just going to go somewhere else the other place we're going to go to is actually the cortex m entry point so we use this part of our hardware abstraction layer to expose the idea of the entry point for the board we can actually describe functions with this label and use that to tell the compiler hey where does your code start oh it starts here at the entry point um basically this line here just allows us to properly let the board panic if things don't go right we need to mention this otherwise the linker will complain about not knowing where panic halt is um here we actually pull out the hardware abstraction layer from our crate and then call it something else call it hal just to make it easier to work with within hals within hardware abstraction layers in rust you have the idea of a peripheral access crate so i'll pull the image up here but hardware abstraction layers and rust have two components so they have the micro controller abstraction layer which is for the just cortex arm zero itself and then you have the peripheral access crate which is for the things that are specific to the rp2040 so we'll expose the peripheral axis crate so that we can use that later down in the code um this is more boilerplate stuff basically we're just saying we're going to use basic structures that are you know native to all hardware abstraction layers like an output pin a fixed point in time etc also we're going to pull out the clock structure from a hardware abstraction layer as well a really important set of lines that we can't skip here is that we are going to actually like just openly declare the bootloader we're going to say make sure you put the things that are you know denoted below line 33 into the dot boot 2 section and that thing we're putting in there is actually the boot to bootloader right so we're saying this structure boot 2 is variable boot 2. it's the rp2040 boot to bootloader it's of this type right if we don't do this line and we don't do that it's in this linked section that it's used we literally will not produce a bootloader to load our binary and nothing will happen so we can't we can't skip this right uh moving on line 39 pretty straightforward we're just telling the you know global environment hey by the way your crystal frequency in hertz is 12 megahertz subtype u32 we need this because we're going to put it into our clock initialization layer later so that we can do things like properly delay you know set up pulse width modulation properly etc um so again like i said before this entry symbol here tells the compiler and the assembler that this function is going to be located at the point where the cortex m0 processor expects it to be starting right um so then we have this function we've declared we're going to declare two parts of the peripheral access crate that will give us access into the actual peripherals that we need to use um we call unwrap on these things by the way to act as an error check right so in rust if you unwrap something and it returns none the board will panic and that's actually good because we don't want to get any further in this code if we go to unwrap our peripheral access crate and set up all of our stuff and it breaks we need to literally kill the board right there next we actually create what's known as a watchdog a watchdog is a structure this idea in embedded systems where it's literally a dog that if you don't wake it up every some set amount of time the board will reset itself we do that to avoid things like infinite loops um edge cases and logic we haven't thought of and we want to make sure that we have code written that at every set interval we feed what is called the watchdog we actually don't do that in this example but we do need the watchdog object to configure our clocks so here we actually set up the clocks all of this is actually boilerplate this will never change we only need to make sure we're specifying the correct crystal frequency so we can configure the clocks to do things like delay and we again unwrap this to make sure that if this structure does not return something it freaks out because we we need to have clocks we then create this mutable object of it's a delay and again it's not that we're doing a delay it's just an object we're going to use to actually conduct a delay action so the way this works is we say okay from the cortex-m microarchitecture package there is a delay type and then we pull out a new instantiation of it and we just give it basically again the system frequency as an integer to that so that we can delay in the future and we do that down here later in the loop uh this is really important we just create a single cycle i o block the controls gpio pins this is just the another structure we use to do gpio and then finally kind of like the most important thing out of all this this is where the true like control layer comes from the hardware abstraction layer we reach into the hall we reach into the gpio layer and we pull out the structure called pins we make a new one and the idea here is that this is what gives us the fine grain control over the pins without doing unsafe accesses and unsafe code right so here we say you know we're going to use the peripheral access code of i o bank zero and the pads bank zero and gpio banks there's only one bank in the rb2040 this doesn't matter um again we can reach into the documentation to figure out what all this does but basically we get a set of pins from this call and then finally like arguably the most important set of lines is lines 84 through 90 in terms of what this code actually does and again the fact that we've been doing this in russ is pretty sweet um we are going to pull the led pin which is a type pin and it's immutable it's mutable because we want to be able to write to it right by default if you didn't know this rust variables are not writable or changeable by default you have to allow them to be mutable so that you can actually change them and give them to people or you know let them be borrowed we say that led pin is equal to of all the pins i want gpio pin 25 also i want that to be converted to a push or pull output pin basically that means can i push a single high digital value to it to turn it on and can i pull a value from it to read from it but it's an output so we're not going to actually worry about the the pulling it's just the pushing and then yeah so now that we've gotten through that part we do this loop and we say hey in the loop and just like we would in python right it feels pretty simple at this point led pin set high and then unwrap unwrap being if it fails let us know delay delay ms we're going to delay for half a second for 500 and then set it low on wrap and then do it again and this will run forever again we did mention the watchdog before if we had activated the watchdog we would want to do a watchdog.feed in this loop that would actually prevent the watchdog from freaking out because if we have activated the watchdog and we do go into an infinite loop it would actually activate the watchdog every sunset amount of time and it would kill the board but i'm not sure if this is actually correct i don't want to mess up the code so i'm going to remove this we're able to write code that compiles down to a rp2040 compatible set of code so the question is how do we actually compile it right uh the way we do that is we can just go here we can do uh cargo build attack attack release attack attack example blinky so this would actually take a lot more time for you to run uh for me it actually took not that long that much time at all because i already built the entire board support package in the background and then it recompiled the code based on the changes that i made so once you plug in your rp2040 as a you know bootable device you can flash code into and you're going to do that by holding the boot select button and plugging in the usb uh we should be able to see it show up in my vm here and i'll pull up nautilus real quick yup and we have the rp2040 here what's cool about rust is there's this idea of runners where you know first we did cargo build to create our project you know compile it into the format that we want and now we can do cargo run which will actually execute what's called a runner by default in the background and put and do something with our code so what we can actually do is do cargo run hit enter and uh we want to actually specify the example we're gonna run we're gonna you know do the cargo run for the blinky example and this will actually take the uf2 file that gets created from the cargo build and put it directly onto our board oh and actually we need to give it uh tack release that's why it's not working because it's going into bug mode by default there we go so we did attack run or run attack attack release the example blinky it was already built from our cargo build before and then it found the uf2 off at my this location here and it put it onto the board and now i'll show you guys with my webcam that it is in fact blinking guys i hope we learned a little bit about kind of the environment that we have to use when doing embedded programming with rust right we got to find our hardware abstraction layer we got to set up our code in a way that produces embedded compatible code and then use that hardware abstraction layer to set up all our peripherals and then do basic stuff we do in other languages you know set up your loop and blink your led as if you like this video and you want to learn more do me a favor hit subscribe hit like leave a comment down below and i'll see you guys in the next video who knows what board will try next [music]