reflections on a decade of coding okay okay i've been programming professionally for about 12 years wow we actually started programming nearest the same time professionally i did my own startup i don't consider it quite professional because i worked with nobody else but in the workforce i'm sitting at right around 12 years or 13 years in workforce time with startup time i'm about 15 so that would put us nearest the same time given the difference here uh here are some things i've worked with on the last two years in a small team averaging three people i think in a little under a year we built a squeal query planner that passed the greater than 6 million test in the squeal logic test suite nice i figured out how to decorrelate arbitrary squeal subqueries i wasn't the first person to figure this out but i got there independently nice i demonstrated a mode of consistency failure in various popular streaming systems that i believe was not widely understood at the time i wrote a text editor really uh that i use for coding and writing every day it took me on the order of a 100 hours of work interesting why not just i mean i i mean i know it's for fun it's it's funsy but why not just use neovim with zen mode low latency text header not intended to be useful for anyone but me ah it's in zig nice nice job that's cool for funsies is fine funsies you do funsies funsies i don't care it's hard to write these examples without sounding like i'm bragging but to be very clear i don't think that these projects are particularly impressive in context they are kind of the projects that someone with a dective experience in a specialized area should be capable of this is a great take by the way this is a great take because often what people do is they read something like this they're newish to work and they work on react and that's like their life and they're like i could never what what does it even mean to decorrelate arbitrary squeal subqueries right like it just is it feels it feels impossible in your brain it's not this is what a decade of doing one thing looks like you can just do this because that's what you've been doing you've been thinking about one thing and and that's good like that's really really fun but there are also projects that i'm fairly confident i would have failed at even five years ago my ability now isn't due to any intrinsic talent or grand insight but instead hundreds of tiny changes in habits processes and values when i compare these changes to online writing and discussions about how to get better at programming i see i see very little overlap oh this is very exciting what is what do you what do you do the changes that led me to being more efficient are either not talked about or uh at all are in direct opposition to popular advice oo oo o i like this i like this i'm hesitant to write these kind of posts because they're uh because they're veer i don't know this word what does this word mean change direction suddenly um american football what what oh to like veer off the road oh i know that word that's weird i just never they veer awfully close i've never heard it used in this context yeah i know veer off course but veer awfully close to flame bait and i really prefer to write things that are strongly factual rather than opinion based i mean fair but i mean so the the only problem i have with like this type of statement is that whenever you write anything and whenever you think of anything and whenever you use your experience to write something you're writing only about your perspective that you've had over a decade and someone else can arrive to a vastly different conclusion that's why i think neovim is the greatest editor of all time and there are people that are like no vs code is the greatest editor of all time i don't think you know that's experience speaking right that's someone that's somebody's experience speaking to why they do things right so like it's hard to not have opinion-based things especially in tech it's it's extremely difficult but there are a lot of things that i wish i could go back in time and tell my younger self and the situation hasn't gotten much better sense there are a lot of high quality writing aimed at people who are just learning to program but very little that helped me figure out how to progress from being a novice i love this when i started reflecting on what uh has and hasn't worked for me i found a lot of things that i wanted to write down so i've tried to uh roughly organize them bad advice things unlearned emotional management setting goals speed matters moving faster coding testing writing nice not i i i want to check some of these noticeable gaps where i don't have useful experience to offer maintaining large code bases operating long-lived systems collaboration working in teams this is good it's good to know your blind spots because if you're always working on small things that's good let's check out on on bad advice all right like many programmers i'm largely self-taught i'd rather worked with let's see i rarely worked with anyone uh more experien in myself especially early in my career where i spent a lot of time working with 20s something year olds who also had only a few years of experience so we all learned about how to program from advice we found on the internet especially posts uh that were shared via sites like reddit and hacker news much of my progress then has been unlearning those things in hindsight most of the writing and discussions i read about online or read online about uh how to program was actively harmful to my ability successfully produ uh to successfully produce code interesting interesting okay let's i i'm curious what this all has to say there's there's this it feels like this is going to be such a good one it feels like it's going to be good not to say that most programmers are bad programs it's just that it's not automatically the case that good programmers will prod will produce good advice oo i like this or that good advice will be more widely shared than bad advice interesting the paradox of choice is widely told folktale about a single experiment in which putting more kinds of jam on a supermarket display resulted in less purchases the given explanation is that choice is stressful and so some people facing too many possible jams will just bounce out entirely and go home without jam this experiment is consistently cited in news and media usually with the description like scientists have discovered that choice is bad for you i've seen this they call it a decision fatigue is like another reason you'll hear about people who will only wear certain clothing i i actually i actually do this real talk i have a drawer with shirts and pants in it and that's it i grab the top ones every day and i put them on today i'm wearing a long sleeve un uncolored standard shirt like that's it i don't make any decisions about what i wear and i'm wearing two-day old pants which is probably not good they're a little dirty uh anyways but if you go to a large supermarket you'll see approximately 12 m million varieties of jam have we not learned from the jam experim experiment jim manzi relates uh relates in uncontrolled first note that all of the inference is built on the purchases of a grand total of 35 jars of jam second note that if the results of the jam experiment were valid and applicable with the kind of grant uh generality required to be relevant on the basis for economic and social policy it would imply that many stores could eliminate 75% of their products and cause sales to increase by 900% that would be fairly outstanding uh let's see astounding result uh and indicate that there may be a problem with the measurement yes that sounds way too fantastical every store this one trick to increase 900% sales the rearch the researchers in original experiment uh themselves were careful about their explicit claims of generalizability the significant effort that devoted the exact question of finding conditions under which choice overload occurs consistently but popularized telescope the conclusions derived from one coupon plus display promotion in one store on two saturdays up through assertions about the impact of produ uh product selection for jam for this store to the impact of product selection for jam for all grocery stores in america to claims about the impact of product selection for all retail products of any kind in every store ultimately wow this is the longest sentence of my life to fairly grandiose claims about the benefits of choice to society as we but as we saw testing this kind of claim in 50 experiments in different situation throws a lot of cold water on the assertion this is awesome because i've heard this cited i've heard this like i haven't heard this study ced but this idea of decision fatigue i've heard this over and over and over again so this is actually really it's really interesting to know that like where i talk about this a lot this is called an unknown known you know this fact but you don't know why this fact is you know what i mean like you just you just have accepted it you've em bibed something and you believe something is real but you don't even know the fundamental basis for it it's neat uh as a practical business example even at uh a simplification of casual uh mechanism that comprises a useful forward prediction rule is unlikely to be much like renaming quickmart stores to fastmart will cause uh sales to rise but will instead tend to be more like renaming quick mark stores to fastmart in high income neighborhoods on high traffic roads will cause sales to rise as long as the store is closed for painting for no more than2 days there you go that's much better that is much better it is extremely unlikely that we would know all the possible hidden conditions before beginning testing and to be able to design the and execute one test to discover such condition laden rule yes yes i mean this is really just good for ab testing in general like if you have to ab test you really have to think about how do you isolate what you're testing and people are not good at this people often confound all the results with too many changes with too many things they're testing and it it it is ultimately extremely confusing i don't know if you've ever been through it but it is it can be quite awful uh further these these causal relationship themselves can frequently change for example we discover that a specific sales promotion drives a net gain in profit versus no promotion in a test but next year when a huge number of changes occur our competitors have innovated with new promotions the overall economy has deteriorated consumer traffic has shifted somewhat from malls to strip centers strip malls uh and so on this rule no longer holds true to extend the prior metaphor we are finding our way through the dark room by bumping it uh our shins into furniture while unobserved gremlins keep moving the furniture around on us i used to play a game where we used to blindfold one person and then we'd spin them in circles and shift all the furniture in the room and then you'd get points by punching them without them touching you and whoever got touched became the new person and then i met somebody who used to play something they'd call bucket head where they'd give somebody a whiffle ball bat and a bucket and you'd play in a baseball diamond and buckethead would just be swinging a bat everywhere and your goal was to see who could touch buckethead without getting hit with the whiffle ball bat i feel like i would have loved that game sounds like a great time by the way tj's coming over tj you want to play buckethead with me i think we could have a great time tj that explains the brain damage dude it sounds great uh for these reasons it is not enough to run an experiment find the caal relationship and assume uh that it is widely applicable we must run tests and then measure the actual predictiveness of the rules developed from those tests in actual implementation here's a really good here i'll give you guys a really good example here uh a project uh a friend worked on was to do play prediction for videos uh that means as you went through the list of videos you would find a video and then we'd start prefetching that data right it was like a really good thing it was the the project was called destiny it was awesome it improved play rate people were more happy people liked to watch more everything was great and then as time went on uh you know there's observations that we're just fetching a lot it's like our our ui got more complicated and then as everything kind of all got together our original assumption could actually be wrong because now we're just putting too much memory too much pressure things became less and less easy to use because we're just doing too much so i it took a lot a lot of asking a lot of people but i finally got an okay and i just turned off destiny that was my test just turn off destiny and when i turned off destiny i called the project fate by the way the fate of destiny i thought it was just just it was glorious and guess what when i turned it off there was an increase in view there was an increase in watching but there was a there was a play delay it actually caused it take to take longer i yes we get it you think you're funny kind sort of funny uh kind of funny but like there was a delay in startup but there was more watching oh dude it was so good it was funny how like this happens your landscape shifts and the initial assumptions you've made of what is good is no longer good it actually slowed down the play rate but we had less crashes because we're using less memory and that's because our ui got more complicated something shifted out of underneath it you know like that means your original assumptions were good assumptions they were right and i still think that it it is right to fetch data beforehand and have fast playback but just because because it was right at one point does not mean it's right at all times this is great this is beautiful uh this is this is beautiful this is what i think about when i see a blog post with py wisdom drawn from a single experience in a single domain programming covers an enormous range of activities with different problem domains team sizes management structures project lifespans development sizes deployment frequencies hardware performance requirements consequences for failures etc we should expect it to be incredibly rare that any given practice is appropriate across all those cont text let alone that we could discover general best practices uh from the outcome of a few projects love it details m matter tacit knowledge or implicit knowledge as opposed to formal co codified or explicit knowledge is knowledge that is difficult to express or extract and thus more difficult to transfer to others by means of writing it down or verbalizing it this can include personal wisdom experience insight and intuition nice yeah i mean there's sometimes i i think every software develop developer inherently understands that you can look at a new library or look at something and you can have like a bad feeling about it though you may not be able to express exactly why you have a bad feeling about it you just know okay i know something's wrong but i don't i can't explain why immediately but i don't think this is going to be good as it as it goes out the ability to speak uh a language ride a bicycle needo play musical instrument or design and use complex equipment requires all sorts of knowledge which is not always known explicit even by the expert practitioners which is difficult or impossible to explicitly transfer to other people wikipedia nice programming practices are mostly tacit knowledge tacit knowledge isn't easy to share an expert will relate some simple sounding rule of thumb then but then grilling them on specific cases will quickly uncover a huge collection of exceptions and caveats that vary depending on the specific details of the situation these are generated from many many past experiences and don't generalize well outside of the context of the body experience yep i mean this is why this is why twitter's such a terrible place for advice and it's also why i don't do any prefacing on twitter because of course everything has context of course everything there's nuance of course it's all these things but man like just it's so what about what about uh you know like dude twitter's a terrible place fact um trying to apply the rule of thumb without knowledge uh knowing all those details tends to result in failure phrases like don't repeat yourself uh you aren't going to need it uh separation of concerns test driven development this was a direct kick this was a direct kick in in uncle bob's test driven development area uh etc were originally produced from somebody of valid experience but then wildly overgeneralized and over applied without any original nuance uh closure let's go uh the way to convey tacit knowledge if at all is via the body of experiences that generate the rule for this reason i find much more value in specific experience reports or in watching people actually working as opposed to writing about general principles i like this i wish this wasn't such general principles and actually a little bit more practical but i i do like this general principles about general principles yes all right confusing means and ends the goal is always to write a program that solves some problem and that can be maintained over its useful lifetime advice like write short functions is a technique that help achieve that goal in many situation but it's not a goal in itself love that phrase the goal is not to write small functions the goal is to have small functions some of right like it is good to have small functions but it's not the point all right and yet some characteristics of human thinking makes it very easy for these sort of pseudo goals to take over the actual goals so you may hear people saying that some piece of software is bad because it has very long functions even if the evidence suggests that it happens to be easy to maintain i've seen this i've seen this a lot when means and ends are confused it's also often accompanied by the word should and and other similar phrases that carry a moral or hygienic weight this is great uh a this is the a is this cs lewis of programming here i don't even know eg the right way to do it clean code versus code smells i'm pretty sure we've officially just hit the cs lewis mark can we all agree uh if you write shorter functions it's often easier to isolate specific behavior in unit test is a concrete claim linking behavior and outcome that you can test and evaluate in context of a specific project okay you should write short functions means that you are a bad programmer if you write uh long functions there is nowhere uh for a conversation to go from there agreed the should problem all right technology companies often often make incredible profits by using simple technologies to solve business problems this means that programmers at those companies can make a lot of bad decisions and adopt poor practices and still be successful facts if money falls out of the sky whatever you do there isn't much gradient to help discover better practices for for example slack is an incredibly successful product a multi-billion dollar company and still does not have reconnecting websockets i can write that code in a tweet just put it in goodness gracious if on close call reconnect with exponential back off jeez louise slack sorry i get really angry all right but here it seems like every week i encounter a new bug that makes it completely unusable for me from taking seconds per character to typing to be completely unable to render a message dude or or the the best part if you copy and paste from a code block you cannot uncode block ify it that is i love that i love that oh hey is that a code block you copied and pasted well guess what you can never uncode block it again forever forever more hence forth dude discord on the other hand has always been reliable and snappy despite judging by my highly scientific googling having one-third as many employees uh so it's not like the chat apps are just intrinsically hard uh dude it is so annoying i slack is one of the single worst rich text editors of all time it is so like and remember i've used jira okay i just just throwing it out there people i i've literally used jira and i'm saying this about slack okay gosh i hate slack uh and yet slack's technical uh advice is popular and if i ran across it without having experience the result myself would probably seem compelling the wrong gradient jir is pretty bad though jira sucks but have you used slack jir is not bad you are are clearly a scrum master social sites like reddit hacker news twitter are do uh are dominant in deciding a large portion of the reading material for myself and most other programmers i know these stories these sites strongly select for short easyto read entertaining and pseudo-controls opinions the tech community also heavily skewes towards young and inexperienced because its rapid growth so voting mechanisms aren't a useful mechanism for uh distinguishing boring good ideas from entertaining bad ideas go is boring go is great i also suspect the dynamics are some self-reinforcing after after seeing my ma uh many highly voted comments endorsing some particular idea or motto it starts to sound like it must be widely known to be true so when you see new comments with the same idea you up voted them for giving the correct answer this could allow ideas to persist without needing to be reinforced by any actual success i get that y yep yep yep yep i like this boring is good boring is great uh lock uh looking back at small subset of writing that has in hindsight turned out to help me get things done it tends to be from people who have multiple decades of experience have substantial technical uh achievements are measured and thoughtful rather than highly confident uh admit complexity and subtlety rather than having one method to rule them all interesting uh this is a very interesting take i always have so just something to think about is that you could be told a piece of advice and you can't hear it right like you just don't have the ears to hear you don't have the ability to to really grasp it one of the problems about any really thoughtful piece of advice is that you also have to be in a position of experience to hear it and i find that to be one of the most difficult parts like when i was younger things you told me i couldn't hear i feel like some i i personally feel like i have to fail my way to success it's why i learn like you watch me program o camel uh earlier uh the reason why i'm not doing o camel in the way the like reading every last way to do everything is that i kind of i like for me i have to do it wrong i have to write functions that already exist in the standard i have to do all this kind of stuff because i need to kind of get it and then it's like it feels easy to correct things as i go as opposed to doing it right the first try i've always been a learned by failure not to learn by doing things right the first try uh judo play's cave there's definitely a bit of plato's cave here there's something about it that it's it's like i have to progressively be exposed to oh no only by doing what is wrong can you appreciate what is right sometimes right a fool so that i mean that's like the biblical definition of a fool versus a wise person uh versus the permanent fool right the a wise person can hear good advice and learn from hearing good advice like that should be all of our goal a fool to wise person is someone who does something wrong and corrects it that's good a fool is just somebody who does not learn from doing something wrong right i mean your ultimate goal should be to learn from doing from hearing the right thing if we can for example subject on how to organize code into functions contrast martin fer f fer i i i like martin fer i have his book right there i can see it refactoring if you have to spend effort into looking uh looking at a fragment of code to figure out what's what it's doing then you should extract it into a function and name the function after what any function that has more than a half dozen lines of code starts to smell to me versus john carac i'm not going to have any issued or see i'm not going to issue any mandates but i want everyone to seriously consider some of these issues if a function is only called from a single place consider inlining it if a function is called from multiple places see if it is possible to arrange for the work to be done in a single place perhaps with flags and inline that if oh i love this is great advice by the way if if there are multiple versions of a function consider making a single function with more possible default uh with let's see with more possibly defaulted parameters if the work is close to purely functional with few references to global state try to make it completely functional try to use const on both parameters and functions when the function really must be used in multiple places minimize control flow complexity and area under ifs favoring consistent execution paths and times over optimally avoiding unnecessary work to make things more complicated the do always then inhibit and ignore or or ignore strategy while a very good idea for highly reliable systems is less appropriate in power and thermal constrainted environments like mobile john karmac is really good by the way right john carac is really really good cuz i like i totally agree with this one any function with more than a half dozen lines of code starts to smell to me like i i don't like that right i just i simply do not like this statement i i think martin fower has a lot of good ideas i mean he i mean his ideas are the the basis of refactoring which i think is great like he has a lot of great stuff but man do i not like those type of statements because it has it has no context it only has opinion no context right john carac not only looks smart he also knows bjj and will kick your ass in the rest of the series i'm hoping to ao to avoid void or at least temper the failures modes above first let me uh be explicit about the context i'm writing from 70% self-employed 30% working in small ear least uh stage companies 40% production code versus 60% research no serious production usage no long-term maintenance 30% in codebase with 100,000 lines of code or more 70% in small green field projects mostly systems problem especially database engines and declarative languages some ui work but all of it exploratory rather than production i've never had to maintain a cod base for more than 2 years i've never been respons for running a long live service nice anything that i report having worked well for me has to be considered in that limited context second i'm aiming uh to accompany every idea with multiple examples this helps convey the actual details and ensures i'm talking about things that i actually do rather than things i think i should do third where i can i am including counter examples where something i used to think was a good idea shut up caused problems or was poorly applied i i mean i like all these things these are really good deep thoughts uh i like this we're going to have to do another article from him at another time i want to i i want to do more of these i might do some more but i like that okay shut up shut up i like this a lot i think i think context is really good the hard part that i see though about what he's trying to write is that all context cannot possibly be delivered yeah suck it pick uh but not all contexts can possibly be delivered and sometimes you have to decide whether you want to write with nuance versus you write just with general principles right it's like how much context can you can you really really get out there it's hard anyways just things to think about the name is the primagen