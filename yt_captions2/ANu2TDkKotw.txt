async rust is a bad language but to get at whatever the hell i mean by that we need to talk about why asynchrust exists in the first place let's talk about it okay this is great i love this i already love this starting off the conversation giving us the proper context let's go modern concurrency they're green they're mean and they ate my machine i don't get it and that guy's face doesn't look like he wants to be here either suppose we want our code to go fast we have two big problems to solve we want to use the whole computer code runs on cpus and in 2023 even my phone has eight of the damn things i got a new phone by the way look at this sweet pixel 7. it's pretty neat i no longer have a bright line down the middle of my phone pretty cool huh if i want to use more than 12 of my machine i need several cores this is true even in my some of my best attempts i still can't get node to use 100 of the cpu i've tried so hard to make it just use ass cpu and i cannot make it uh we want to keep uh working while we wait for slow things to complete instead of just twiddling our thumb sending a message over the internet or even opening a file takes in eternities in computer time we could literally do millions of other things meanwhile very fair and so on we turn our friends parallelism and concurrency it's the favorite hobby of cs nerds to quibble over distinctions between the two so to oversimplify parallelism is about running code in parallel on several cpus concurrency is about breaking a problem into separate independent parts i'll give my my take on it which is parallelism is having machine instructions executed simultaneously concurrency is having tasks that do not need cpu to move out of the way and allow other tasks to run while it's waiting for a result concurrent my nuts out your mouth okay i don't know how i got that one but that's about fair was that a is that about a fair-ish statement wrong again parallel is is more than one thing happening at once whereas concurrency is is stacking them like bricks parallelism is a subset of concurrency i don't believe that parallel is at the exact same time occurring at the same time interval okay that somehow makes it less clear now i think everybody's more confused at this point i'm still confused what's the difference okay think of no think of node.js when you do a uh think of this right here here we go this guy this code okay not that code vim test this right here right one is going to take one second two is going to take two seconds we can either run them one at a time this is not concurrent or parallel or run them both at the same time but here's the deal one will run until it relieves any need of the cpu then two will run and relieve any need of the cpu and then one will pick back up after it's one second wait and then start running and then be done and then two will pick up after two seconds and pick it up this will take a grand total of two seconds it's concurrent but it's not parallel one is not executing at the same time two is that's concurrency concurrent processes overlap parallel runs literally the same time that's why it was specific there's at least two lines of running machine code like something is happening two different because you can you can have parallelism and they're not running the same code they don't have i don't think there's any requirement that it has to be identical code being ran uh they could be running different parts chipboard politics yeah okay whatever i think we all get it we're moving on these are not the same thing single core machines have been running code concurrently for a half century now but they are related so much online well actually well actually ignore dude we literally just did this we literally just did this we're doing this okay right now um ignores how often we break programs into concurrent pieces so that those pieces can run in parallel and interleave in ways keep our cores crunching we didn't care about performance why would we bother so let's see how do i concurrency one of the simplest ways to build a concurrent system is to split the code into multiple processes after all the operating system is lean mean concurrency machine conspiring uh with your hardware to make each process think it has its whole box to itself the os scheduler gives us parallelism for uh free running time slices of any process that's already on on an available cpu core once upon a time this was the way and we simply we still employ it today whenever we pipe shell commands together let's talk about golf build tool oh no a lot of you javascripters are discovering that it is a lot more efficient to pass data from task to task rather than writing it to disk between each step or akka actors in scala concurrency sure is simpler with non-shared memory and immutable messages huh okay let's begin with processing pipes they've been in unix for 40 goddamn years this is actually really funny by the way this is this is really good uh it's been happening forever but this approach has limitations inter-process communication is not cheap since most implementations copy data to os memory and back yep uh mutex based concurrency considered harmful or horror was right uh some people when confronted with a problem think i know i'll use threads and then they have two awesome this is such a good statement this is a beautiful statement right this is a beautiful statement okay this is parallelism getting awful we can avoid these overheads using threads processes that share the same memory uh common wisdom teaches us to connect them with mysterious beasts like mutexes and conditional variables and semaphores isn't a semaphore just a mutex with a wider lane just has a higher count to begin with um anyways yeah i know i'm just saying i'm just saying that just okay anyways uh this is a dangerous game i mean i like using this i have my little test clients all use this i think it's a lot of fun to use semaphores to produce asynchronous code it's fun i i mean i actually enjoy it a little tokyo spawn a little semaphore a little glass of wine and you got yourself a seg phone uh this is a dangerous game simply uh simple mistakes will plague you with the race conditions and deadlocks and other terrible diseases that fill your code with bugs but only on tuesdays when it's raining and the temperature is in the middle of three is a multiple of three oh gosh it's a red riddle and god help you if you want to learn how this stuff actually works on modern hardware fair all those are fair statements all of it fair statements there's another way in this 1978 paper communicating sequential processes tony horror suggests connecting threads with cues or channels which they can use to send each other messages this has many advantages are we just slowly becoming go is this literally a statement of like hey man you want to hear about go i think this is where we're going or erlang okay erling sorry it's erlang uh dude erlings is literally the simpsons of programming oh is this goat erlang did it okay it showed up threads and joy process like isolation from the rest sorry the music was a little loud uh threads enjoy process like isolation from the rest of the program since they don't share memory bonus points for memory safe languages that make it hard to accidentally scramble another thread yeah rust uh each thread has very obvious set of inputs the channels it receives from and the outputs the channel it sends to this is a re this is easy to reason about and is easy to bug it's actually true it is very easy to debug these type of problems instrument uh the channels for powerful visibility into your system measuring each thread's throughput channels are the synchronization if a channel is empty the receiver waits until it's not if a channel is full the sender waits yeah this is actually i mean this is beautiful threads never sleep while they have work to do graceful pausing if they outpace the rest of the system okay after decades of mutex madness many many modern languages heed advice and provide channels in their standard library in rust we call them sync channel okay most software can stop here building concurrent systems with threads and channels combine them with tools to parallelize cpu intensive loops like russ rayon or haskell's par ooh haskell mentioned can we get a w haskell mention pick pick come on down pick dude anytime haskell gets mentioned there's just high fives like 35 individual people just start high-fiving each other and they're just like yeah they recognized us let's go pick sitting there at the leaders full on full-on cult enthusiast oh it's so good uh and you've got a powerful cocktail i do think that i've relied too heavily on async await and maybe i do need to consider more just playing with this kind of stuff but ludicrous speed go some problems demand a lot of concurrency the canonical example described by uh dan cagle did i say his name right the man's name is kegel did he invent anything else is there any other well-known item that uh this damn fella happened to to know about i'm doing one right now that squeeze was great uh as the c 10k problem back in 1999 is a web server connected to tens of thousands of concurrent users at this scale threads won't cut it uh while they are pretty cheap fire up a thread per connection and your computer will grind to a halt to solve this some language provide a concurrency model where tasks are cheap and managed by uh in user space i.e without operating systems help a runtime schedule these tasks onto a pool of os threads usually size so each cpu core gets a thread to max maximize parallel parallelism very hard word by the way to say rust calls this the mn thread problem okay uh this scheme goes by many names green threads lightweight threads lightweight processes fibers co-routines did you know that in react they also use the term fiber starting in react 16. um as somebody who's been recently going through their source code and reading a lot of lines of it just saying okay that that it exists and react as well uh and more complete and with pedantic nerds endlessly debating the subtle differences between them russ comes in with this problem with async await model seen previously in places like c-sharp and node.js here functions are marked async don't block you but immediately return a future or promise that can be awaited to produce the result a little different though than node.js in node.js world an async function is greedy it runs right away it's hot is another term for it whereas with uh rust unless if you call dot await it doesn't ever actually run which can bite some serious ass okay you may not realize that i've heard the term cold be that used lazy you know there's a lot of terms for it foo returns an end async food returns a future that we cannot await to get it weight i've been here before you should have thrown a literally should have thrown a little arc mutex somewhere in here uh on one hand futures in rust are exceedingly small and fast thanks to their cooperative schedules stackless design but unlike other languages with user space concurrency rust tries to offer this abstraction while also promising the programmer total low-level control there's a fundamental tension between the two and the poor async rust programmer is perpetually caught in the middle torn between the language's design goals and the massively concurrent world they are trying to build rust attempts to uh statically statically verify the lifetime of every object in reference in your program i still truly don't understand pin and unpin okay i keep trying okay i haven't tried in a little while i'm just saying that sometimes you gotta pin it sometimes you want to not unpin it sometimes you want to unpin it okay sometimes you want an async reader plus unpin i know that's almost like pin doesn't move you're like oh okay that makes perfect sense okay i get it now i get it i super cool um design goal is a massively concurrent world they're trying to build rust attempts to statically verify the lifetime of every object in reference in your program at compile time futures promise the opposite that we can break code and the data it references into thousands of little pieces runnable at any time on any thread based on on conditions we can only know once we've started a future that reads data from a client should only run when that client's socket has data to read and no lifetime annotation will tell us when that might be it's actually a really fair take so that's why send you asked about say this sounds like a send problem uh assuring the compiler will uh shortly probably that everything will be okay runs into the same challenges you see when working with raw threads just raw dog those threads data must either be marked ascend or moved or pass through references with a static lifetime both are easier said than done moving at least without cloning is often a non-starter dude it's so annoying this is like the this part is such an emotional bruising moment do you know what i mean like this is such an emotionally bruising moment when you start getting into this oh my goodness since it's common in async code to spawn many tasks that share common state the reference uh references are a pain too there there's no thread scope equivalent to help us bound future lifetimes to anything short of forever i thought there was some level i thought in uh mara mara's book on a uh threat atomics or uh rust atomics there was some sort of thread scoping that allowed some version of this i could be wrong though it could be very very wrong uh foo big chungus get that big chunk is out here async food big global static ref or something similar horror chungus sendable chungus clone that's pretty good you gotta have that sendable clonable chungus okay it's a requirement unlike launching raw threads where you might have to deal with these annoyances in a handful of functions this happens constantly due to async's viral nature yep since any function that calls async function must itself be async so i talked about this earlier this is the problem of a leaky abstraction when you have one thing that uses something the thing that uses it must also become it itself and so you just like all the way back or you create a something that can walk a future in rust which i'm still not quite sure of how that works uh you need to solve this problem everywhere all the time just arc my up toss a little mutex on there a seasoned rust developer will respond by saying that russ gives us a simple toe of our dynamic lifetime spanning multiple threads we call them atomic reference counts as or arc for short did i do a good recipe um while while it's true dude so republican versus democrat functions yes this is what we're talking about while it's true that they solve the immediate problem borrow check and our code compiles they are far from the silver bullet used pervasively arc gives you the world's worst garbage collector like the gc the lifetime of an object and the resources they represent memory file sockets is unknowable but you can take this loss without the wins you'd get from actual gc it's true you get all the inconveniences of rust with none of the benefits of gc that's pretty good don't buy the gcs slow fun yeah i think that like discord probably did the largest disservice ever to the gc is slow and bad they're like on an old version of go they had no tuning that was being done there's a lot of improvements in go and what they've been doing with with that and i really hope memory arena's come out but it's true don't buy the gcs slow fun gcs can be fast you can make things good in a compiled language with the gc it is possible gochi see is a great it's a great gc the claim is misunderstanding of a latency versus throughput at the best and bizarre psyop at worst throughput at best and a bizarre psyop at worst i love a good psyop i am all in on a good psyop a modern moving garbage collector gets you more allocation throughput less fragmentation and means you don't have to play mickey mouse games when weak pointers to avoid cycle leaks yep and you can even trick the system programmers into leveraging gc in one of the world's most important software projects by calling it deferred destruction colonel.org someone stuck in a gc someone stuck in a little deferred destruction step b the above key to underlying rco's deferred destruction hr here uh hold up please that's actually pretty funny uh another random nonsense let's say other random nonsense i'm not sure if that's actually real or what they're saying if it's really a garbage collector or anything but it's just a funny idea that that exists because rusco routines our stackless the compiler turns each one of them into a state machine that advances to the next await yeah if you've ever looked at some of the code that is generated it's pretty wild but this makes any recursive async function a recursively defined type a user just trying to call a function from itself is met with inscrutable errors until they manually box it or use a crate that does the same well i've never tried a async recursive function huh there's an important distinction between a future what does nothing until awaited in a task which spawns work in the runtime's thread pool returning a future that marks its completion exactly this is true i mentioned this earlier uh there's nothing keeping you from calling blocking code inside a future and there's nothing keeping that call from blocking the runtime's thread it's on also true you know the entire thing we're trying to avoid with async i mean i've done this a lot of times with rust i did this a lot of times with rust it can be quite tricky running away always monty python's always a solid reference what is your favorite color um mixed together this gives you async rust a much different flavor than a normal rust oh one with many gotchas that are harder to understand and teach and pushes users either to develop a deep understanding of how abstractions actually work writing complicated code to handle them or sprinkling arc pin static unpin pin project some structures with also a pin macro somehow sprinkled on them um you know in other sacred runes throughout their code base uh and hope for the best this is me i'm pretty much on this team i'm on team arc mutex you know i'll take option two the thing is is that you gotta remember that when they say this what they what they mean is that it's not something like you know like don't worry about that you know like the difference between going from geez uh like i don't understand the dom because i don't get trees is like it's a small gap right like we can all agree that that gap looks something like this right it's a small little gap right you have to learn a little bit and then you kind of get it and you're like okay i understand how you recursively descend i understand breath first versus depth first search okay i get this whereas i added an a at the end of it whereas when it comes to rust async it's like the amount of stuff you do have to learn you have to actually learn what pin pin is actually doing you have to oopsies uh you have to learn about like what is actually happening with the rust run time and how async is handled what the hell is happening what are all these extra things that are going on why do you have to mark some of these structures as some sort of pin project like it just keeps ongoing right it just keeps on happening and keeps getting thicker and thicker and thicker it takes a while to get over it you know what i mean it just does all right uh rust proponents i'd consider myself one might call these criticisms overblown but i've seen whole teams of experienced developers trying to use rust for some new project mired in this minutia to whatever challenges teaching rust has async adds a whole new set agreed cries nasync is a real meme because it really exists right it really really exists rust is like a learning pointers and mallex all over again yeah but it's eat like honestly just rust it's pretty simple right like i genuinely just rust a little cli that does something it's pretty straightforward but the moment you get into these like some of the more arcane sides of rust the difficulty is just like a serious step function harder right you're not learning you're learning both a concept and how to express it in rust's kind of constricted language and how they do things sink rust a day async rust that uh to a degree to which these problems aren't just a thing in other languages can't be overstated in haskell or go async code is normal code you might say this isn't a fair comparison after all those languages hide differences between blocking and non-blocking code behind a fat runtime and lifetimes are hand waved with garbage collection but that's exactly the point these are pure wins they are doing with this sort of programming it's true it's very true maybe rust isn't a good tool for massively concurrent user space software uh we can save it for the 99 of our projects that don't have to be i love rust when doing cli tools i love rust for cli tools so yeah i agree with this i like i genuinely agree with that statement one a file which could be on the other side of the internet thanks uh nfs i'm not sure what that is um until we could cut down ipc overhead by sharing memory between processes but uh but this gives us but this gives away one of the main advantages of multiple processes the os isolated from each other yep i like that mara boss recently put out a fantastic book that despite targeting russ specifically does a wonderful job explaining the fundamentals of low-level concurrency in any language uh yeah i i've read i've read through most the books pretty good like it's pretty good book if you don't have time to for the whole book i've done my best to sum it up in a few pages also super cool of course i'm simplifying here not every programmer can express uh not every program could be expressed as a dag fair you'll find good occasions for other primitives say atomic flags to indicate changes in global state still horse model is great default and i've always found it helpful to think about how data flows through my system each thread has four kilobyte control block and linux and switching between threads require a trip to the operating system scheduler this context switch to the os memory is much more expensive than a normal function call fair uh uniquely rust doesn't provide a runtime for its futures in the language delegating instead to libraries like tokyo this is great for users rust builds tool cargo and ecosystem gives developers freedom to choose alternatives that are better suit unique environments they find themselves in that's that's true that's true i mean it sucks that people like tokyo also have to shoulder the community for most concurrency tokyo right like i i do think that that is the sucky downside of this is that people who develop these alternatives are truly like that's a pretty tough job to have but it's a detail that largely immaterial to our discussion one that can imagine a world where tokyo is built into another language and all the same rules apply you can break a chain by commanding the entire runtime to uh block on this is true and i've done it many times on a completion of a future you probably shouldn't do this pervasively since it isn't composable if a function blocks on a future and that future calls a function that blocks on the future congrats runtime panics um facts eight uh learn more in without boats future and segmented stacks and the c plus plus paper okay cool amos wagner aka fast and limes pin and suffering is a fantastic snarky intro there you go now you see it all i actually agree with this i think that uh my ventures into async rust though i built several programs that i'm happy about and i've done well um and i'm very very happy that i did some using a bunch of async awaits i'm not in fact like if you look at this little shooter game my little oopsies uh i just did the wrong thing there um i just what is happening my brain just just totally went to twice i used a bunch of like i used semaphores to kind of do this and do some nice little fun things right here and join a couple little items right here enjoyed it very very much doing this kind of stuff i i i i have actually enjoyed these kind of things and i think it's really fun to use semaphores and all that but ultimately at the end of the day i'm still relying on the async nature of it and i do a bunch of box leakings for that exact same reason i just need a static reference right i just need a reference out that i can just have everybody else uh using this article screams uh skill issue so i don't my big problem with this is that i don't believe that you know what i mean because here's the problem with that statement in general and and one of the reasons why i i semi-dislike the phrase skill issue is that some are just genuine skill issues but some the requirement to be good at async rust not just like kind of good right you could build a simple web server that cruds out stuff that does stuff not hard async we could all do that super simple throw up a turso client hit the database really easily by the way tercel is doing something incredible that i'll be talking about here soon that involves a millisecond transactions or a micro second transactions it's incredible um but nonetheless it's like that's simple simple async is simple in rust large async uh large async programs become very hard in rust and can become very hard and rust and so i really don't think that um i don't think this article is far off i think that's why again i just really really love uh and the thing is is that when you have to do something like if you're going to get a group of people to try to learn async rust to the fullest extent you're asking them to learn rust to an exceptionally deep level that's like do you just want to be a rust only andy or are you someone that's more like i'm truly trying to be someone that works on many stacks of any kind and so that's kind of the thing you have to choose to do and i'm not saying it's bad i like rust but i like to go and i also like typescript and i also don't mind working in just javascript with js doc and i also don't mind working in lua and when i have to i've done that one big gigantic multi-threaded objective-c program that was pretty terrible because i hate objective c i'll even work in a c plus plus i'd love to get into oh camel right and so it's like for me it's like i'm fine kind of being in a bunch of places you know what i mean i'm fine doing a bunch of stuff but it also means i can't go super deep to the level of understanding rust async at a compiler level because that would just be really hard but i could get there i mean theoretically i could just take that amount of time and and do it i like ts yeah ts is just fine ts here's the deal typescript takes a shitty language and makes it slightly less shitty anyways i don't mind typescript i just think it's still a shitty language it still has shitty things and i think large typescript programs are bound to be incredibly emotional right that no matter how much you want it to be good it is a it is an act of refactoring types and logic that is very annoying um so that's that small programs i really am fine using typescript you know if i just need to get something really quick i'll just use that sometimes that'll rust i tend to use rust or typescript for a quick cli app depending on how i'm running it now that i have bun i'll probably use typescript more frequently for something easy so just thoughts but i like this i like this take i actually really like this take great job bit bashing sweet article that was a sweet article typically whenever i do anything to with the cli i i i actually uh pick um rust instead of a node because i want to write typescript but i don't want to build a build system and uh ts ts node or any of these other runners are just really annoying to set up and then setting up everything is also super annoying to set up so i just tend to not ever use that but now that bun's there maybe i could see myself using it but there's still a lot more that i'll have to think about you know what i mean a ts node hurts it does it's an emotional pain and then you got like this ts paths issue and it just every single time i get super pissed off at it you know what i mean i get just super pissed yeah dino maybe i do need to invest a little bit more into dino yeah i agree i i fully i by the way i'm fully angry and so striker i actually i have a video dropping here maybe next week on bun and my real impressions of bun it is not production ready one is a lie the name is the asyncogen