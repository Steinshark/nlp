this is apparently the react compiler uh we now officially have a compiler that takes a library and turns it into other javascript which is then transpiled so we have a compiler to transpiled i don't even know what these words mean anymore okay they used to they used to mean something now i don't even know what they mean but we're going to read about this because this is actually very interesting because this is something that i think react should have done a while ago cuz i think the compiler is actually it's much more interesting okay we lost all meaning absolutely this page will give you the introduction to the new exper mental react compiler and how to try it out successfully by the way we'll also look at jack harrington because apparently he has an amazing uh breakdown of all of this so pretty cool pretty exciting stuff uh you will learn getting started with the compiler installing we don't we don't i just want to see like what it does i know down here there's some there's some there's some code examples so we're going to look at it react compiler is a new experimental compiler we've open source to get uh early feedback from the community it is a build time only tool that automatically optimizes your react app it works with plain javascript and under understands the rules of react so i wonder if it works with plain javascript i wonder if that means you can't have it in typescript you have to first trans pilot then compile it then bundle it curious i'm c just curious and let's see and understands the rules of react so you don't need to rewrite any of your code to use it the compiler also includes a eslint plugin by the way eslint uh the devil's the devil's lint um i've never been a big fan of es lint just just throwing that out there personal opinion that surfaces the analysis from the comp compiler right in your editor the plug-in runs independently of the compiler and can be used if you aren't using the compiler in your app we recommend all react developers to use the eslint to help improve the quality of your code base okay the compiler understands your code at a deep level through its understanding of plain javascript semantics and the rules of react this allows it to add what are the rules of react rule one juice hooks components and hooks must be peer there's there's okay so these are the rules of react they're all in here okay cool anyways you may be familiar with manual memoization through use memo use callback and react. memo the compiler will automatically do this for you if your code follows the react the rules of react if it detects breakage of the rules it will automatically skip over those components or hooks and continue safely compiling other code if your code base is already very well memorized you might not expect to see major performance improvements with the compiler however in practice memorizing the correct dependencies that cause performance issues is tricky to get right by hand yeah i am curious how it knows what to memo um because you know like like all tradeoffs memoing uh requires you to use a map requires you to or some sort of data structure right it may be an array it may be something right there's some thing depending on how deep or how much you're memorizing right because you can have something that's just memorizing a the last result of a function or you could actually have something that memorizes tons of different results from a function and so i'm not exactly sure the level of memorization that happens in react whether it's the last value or many values or if that's hand tunable so i am curious what the uh because i know that the performance improvement or the performance win of used memo is not necessarily straightforward meaning that you can't you can't just memorize everything and thus you win because it now makes it faster yes i've seen this i've seen this all the time we've seen this you know last time i worked on a major react app we had the exact same problem you cannot memorize everything right i had to lag more exactly this is like a real thing this actually happens and as far as i can understand it pretty much tries to memorize everything it can oh interesting for this reason to adopt the compiler successfully on existing projects we can recommend running it on a small directory of let's see in your product code first you can do by configuring the compiler to only run on specific directories okay awesome um neat neat i like it i like i love being able to just write javascript for more compiling uh that way you definitely don't introduce complex build step processes at all uh in rare cases you also configure the compiler okay oh yeah here we go this is what i want to see okay this is the stuff i want to see here in rare cases you also configure the compiler to run opt-in mode using the compilation mode annotation option this makes it al uh it so the compiler will only compile components and hooks annotated with use memo directive i hate directives i think that's crazy just throwing it out there that's crazy for those that don't know i believe it's as explorer. net did i get that correct yeah yeah yeah if we go to where's javascript give me that javascript there's some javascript if we take javascript and at the first line we go use uh your mom you know it actually has uh you get inside of here let's see function declaration you get an identifier you get a block statement you get an expression statement the expression statement has literal use your mom and it's a directive right so it actually gets parsed as a directive so if you have a string as the first kind of expression in a function it's called a directive and things can happen and you can actually program in specific behavior so by having a use memo you are having a directive that tells the compiler to do something special based on that string i've never really liked that i think that that is kind of a it's a it's a very bizarre hammer that exists use strict that's where ust strict comes from it's interesting in the sense that you get a opt-in compiling i think that i mean i i like that general idea that opt-in compiling pretty cool it would be very nice i mean i guess the one nice part is that you can use this and you can uh take this and explore what the compiler does on like a function by function basis right so maybe maybe there is something even though this is kind of like a uh what i would consider like a really strong hack it's a very probably nice way to test things right we don't intend for the used memo directive to be used uh for the long term okay good so it's just something that's nice to explore what happens right okay use foot gun use foot gun it's a beautiful it's it's one of my favorite hooks yeah i hate directives yeah i generally hate directives that's why like go compilers embed the files embedding the files i can kind of see as being something that's kind of nice that way you can have embedded file system lookup so that way you can run anywhere without a file system like i like that general idea but i do agree that directives are often dangerous when you have uh more confidence with rolling out the compiler you can expand to other directories yeah okay so maybe i'd take back what i said using this as a stop gap and exploring how it does things is a good is a good kind of hack to make it work out so hey hats off to making a good hack work out checking compatibility all right so there's a bunch of health checks and all this okay i just want to see okay there's more compile stuff we don't care about the compile stuff blah blah blah blah here's some vite here's this all right with webp pack this is still all more of the compiler by the way so much compiler stuff you have to add i'm always very worried about build i know people i get i get told this all the time on the internet because i say that hey you guys don't realize how bad like these compilations things can be until you work in a large project build systems spec specifically for javascript become so obtuse and difficult to work with that once you exceed a certain size you start doing so much stuff and this and and it can be so hard to wrangle like at one point like i mean you you'll find plenty of companies that have an entire group of people not just one person multiple people that are working specifically on the build for javascript anyways everything is great until you use it in bigger terms even go like i'm using go right now and go is pretty great but i also find that go in as as the project is slowly getting bigger like go has its own little cracks and things that are kind of you know what i mean they're kind of annoying and so you you just got to choose what you want and choose what you want to suck you know there's there's things that suck in every single language except of course zig which is a perfect language okay so let's let's change things up and let's look at this video cuz this is the announcement video and i am very excited about this announcement video finally arrived react developers are getting the react compiler all right frameworks like spelt and view and solid and quick all have compilers but react doesn't have one until today and this compile is by the way is that a good thing just because other frameworks have it i don't know if it's a great thing i mean spelt is its own is its own like you know it's it's it spelt is its own thing onto itself so it makes sense that it has a compiler like i get that and obviously uh solid has a lot of stuff that is onto itself it's its own kind of thing whereas i am curious like because that's one of the selling points of react is that react is just java script and so you're just compiling jsx you're not compil you know you're not actually doing something else and this kind of makes it into its own thing right so once you compile react you are now entering you're you're leaving react as just javascript into react as something more than javascript piler is amazing it definitely does not disappoint and i think i can say it this point in my opinion this is the most advanced compiler in the front-end framework world let me start by showing you an example appliation it's a simple application it's got a header on top and then it's got these two incrementing counters now the state for those counters is actually up above in the app component itself so what do we think happens when we click on this increment button so now all four of those components render the app rerenders which means that the header render which means that both of those counters render but that's normal for react or at least it used to be check out for those that don't understand what what he's trying to say here whenever u state gets set uh it renders the function in which has this like little hook uh hooked into it so this function gets recalled and thus everything gets rendered and so when you increment this thing once this whole function needs to get rendered which is typically why you're going to want to try to put it somewhere else you're not going to want to pass down this function because if you pass down this function you really create a great distance between where you render versus you know uh what's it called uh where you set the data so typically you don't want to do that just in general but i'm curious how how does react solve this because that's pretty impressive if react can solve this you're you know and by the way this i mean this is generally like terrible code example which i think is a great example which is like this is what this is what production looks like when you actually go to a real application people made all crazy amounts of shortcuts and you're like what the hell is going on here and that's just what happened so i'm i'm very curious runs with no code changes at all when instead we use the react compiler to generate the code all right this is the react compiler version i'm going to click on that same increment button and as you can see only the app and the single counter that we changes at all instead we use the react compiler to generate the code this is the react compiler see squ click on that same increment button and and the single counter that we clicked on rendered that's it is interesting that it uh what's it called that somehow it rendered this and only rendered this and it kind of drilled down from where the us state was to only the things that have changed so i mean that's that's very impressive compiler okay compiler has created code that is memoized the header component as well as both of the counter components when the app rerender happens the code that was generated by that compiler sees that there are no changes required for the header or the other counter so the memoized versions are returned and so you get super granularity when you're updating with no additional effort at all on your part just use the i'm curious how that scales because you know now you know let's just imagine you're just like a a medium-sized place with with thousands upon thousands of components if everything is memorized what does memory look like do you start getting things slower right you does do things change i like i i don't have a good way to reason about you know reason about how uh the performance goes on this because it is it is curious right it is curious to see what what that what that equates to instagram already uses it okay i i i don't use instagram on the on the on the web react compiler and with well-written react code you'll start getting the benefits right out of the gate well maybe not right out of the gate it's not in its final form yet right now it's still in development and so i wouldn't put it into production but i got to be honest with you meta products like instagram have been running on this for a while so it's not too far off okay let's go through one more example before we dig into the guts of this thing and see exactly how it works so here you got another example it's got a counter again on the top and that just helps us to re-trigger the render of that component what we're actually looking for is on the console side over here every time i click increment we should not be resorting those names because those names don't actually change nor does the sort function so let's go try and fix this over in our nonreact compiler so what's happening here is a sort function is getting called multiple times so one thing i want to do is wrap it in a use memo now what do we depend on we depend on the names names as well as the sort function itself all right let's see if that works that's a bit of a foot gun so if you pass in a function if you just pass in a rando closure every single time it renders it would actually realize that the function's different each time so you have to make sure you lift out the sword function you know just throwing that out there classic classtic oopsy daisy right there and then increment a bunch more times and nope it's still giving us the same sorting of names so why is that well if i go into my sort example you can see that the sort names function is getting regenerated er pre-at i totally pre-at this one i totally just pre-at this one i knew it i could feel it i can feel it inside of me classic pre-at yeah it is a this is a classic pre-at situation um interesting yeah you need uh use call back to fix another issue yeah every time the sort example component renders so we're getting a new reference for this sort names function that we're sending on to the sorted list of names so you're also creating a new array every single time there's a lot of there's a lot of garbage that people don't realize like okay let's see if they you know i know that it's like really free dependency the so every single time this function is now called you also create an empty array and inside the other one you created you create an array of those dependencies so every time it renders it just creates garbage you know it's just a garbage cre doesn't actually look at any it's like so small figure out how it's it's in the i understand it's in the nursery right by the way me and jack harrington are entirely too close here jack sorry sorry for getting sorry for getting in your business like that uh but uh what's it called uh i know it's it's in the nursery and the oroko i believe right oroko or oroko is that is that what it's called the oroko the oroko garbage collector is really really really really smart and how it handles minor uh minor gc's versus major gc's the scavengers pretty cool pretty cool stuff it's going to do it sorting so let's hit save and then try it out again someone just said oroko the ena song and now everything's fine we only get one sorting of the names because we've used use memo and use callback to fix our referential identity problem here's the good news though with the react compiler you don't need to do any of that here's the exact same example without the used memo or the used callback but this time with the react compiler compiling the code and i hit increment and there's no updating i'm curious how this is debuggable right like when you have something that's not rendering how do you debug that i think that that's going to be an extremely interesting uh thing because i'm sure they have some good react tools and all that but it's just another it's just one more vector of things you need to consider so that seems interesting uh on top of it i wonder how it's doing it i know i'm sure he'll show me it's just me thinking through my thought process here which is i wonder what it's going to do does it like trace through this this function all the way to where it's used and if it's used in a dependency array and it's been passed all the way through then it's considered a used call back and attaches a used call back to it i'm i'm fairly curious this is why yeah yeah console. logging just got a lot harder uh it things are going to get a little bit harder function never gets called except by big worry so when i read this kind of stuff my big worry so let me just throw out some things anytime you introduce magic anytime you introduce control flow that's different than what you've programmed by that very nature you make it harder to debug every single time so when something changes out of underneath you it is always harder this is typically why something like try catch is considered harder than errors as values errors as values is considered more cumbersome but it's very explicit at this point this error can occur therefore we handle this error every single time whereas try catch it's like i call this function i call that function i call this function i call that function one of those functions may error how do you recover from that do you need to do cleanup do you need to you know dispose of anything what do you actually do so there's like a lot you know there's trade-offs there one makes one makes the code just easier to write and read theoretically the other one makes it more explicit more cumbersome but it makes it more correct which one do you choose i prefer the correctness side of things i prefer the explicit side of things because it for me it's just easier to debug cuz my my control flow just goes top to bottom right that's it it just goes top to bottom always whereas with this you're you're kind of you're getting like that same feel again right you're getting that same feel where things are going to be moving around in a kind of a a very difficult way except for the first original to really understand what's happening here we really should take a look inside the compiled code now to do that i built my own ripple it's available in a github link below meta version of the rle which is probably far better than mine is available as well there's a link to that in the description but that wasn't available at the time i was doing this video so we're going to muddle by with my version of the repple which of course you can play with okay in the get up link in the description right down below all right here's my janky version of the repple so before we get into what the react compiler generates we really should take a look at what the current version of the transpiler creates because if you don't know how j see it's just javascript rookies okay it's a div it's a div it has a class name it has a class name that's that there's its content there's its content it's just javascript sx is turned into actual running code then it can get a little confusing as you look at the output of the react compiler so here's what's generated today from the function on the left hand side this hello function what's actually generated is this function on the right hand side that uses this underscore uncore jsx now underscore this makes sense right because it's just it literally just looks up these names and all jsx is what jsx actually turns into underneath the hood the first argument to jsx is the tag type in this case a div second argument are the props in this case the class name of fu and then the third and any follow by the way this is you looking at the compiled stuff will give you a lot of insight especially as you do prop spreading for exactly what happens and why you are creating say a ton of garbage there's a there's there's a lot of cool there's a lot of cool stuff you can kind of glean from looking at the transpiled code plus it's actually just a really good exercise to do every now and then because what it what what it will open up to you is how transpilation works and then you're not going to be as confused as to why just general bugs crop up because you understand the the the essence the the thing underneath the hood so i i do recommend looking at this stuff from time to time following arguments are the children of that component in this case it's the text of hi there so what does this look like with a react compiler so i'm going to click over on the react comp that is so much more straightforward pyer tab and see what the output of the rac and pyo looks like it's going to bring in this new hook called use memo cache now what use my cach allows it to do is it create by the way uh i think dhh was right on the no build javascript you know what dhh was right have you ever had an experience where the source maps don't work have you ever had the work in nice twittering that's how you do twittering right uh have you ever have you ever been a part of things where have you ever had the work in an in an environment where things don't work prop properly right i think we've all had to be in that environment before it's it's not it's not easy right it it it sucks it's not fun it's just the reality of working in software is that sometimes software sucks and so when i see these things i realize like how hard it can be for some people to do some debugging you know what i mean uh there's a lot of things going on here and this can be it can make things difficult i'm also i'm curious what i'm curious what this does to bundle size there is a lot of implications into performance performance here what does this mean for your server if your server is already struggling to say like whenever i've built react servers i find that they struggle beyond like 10 requests per second what does this do i don't know i have no idea do you compile your stuff i'm going to click over on the react compiler tab and see what the output of the looks like it could be it's going to bring in this new hook called use memo cache now what useo is to create an array of cachable elements in this case just one and it's going to take parts of the component and assign them to slots within that memo cache so it's going to start off by taking that jsx and assigning it to t0 then putting it in that used memo cache slot and then returning t0 oh that's funny how that works okay okay that makes sense that i mean it it does make sense so it's going to do that to every single component it's going to just effectively slot every single one of them so that you have t0 t1 t2 t3 and it's going to kind of produce all of them um you know this stuff is definitely not free because you got to remember how do you think used memo cach works well you could imagine that react is probably in some sort of rendering state as it's going through this and every single time used memo cache is called it has a reference to the current node that's being rendered and then inside this tree of renderers in inside this tree of caches it then stores it maybe it's not a tree of caches maybe it's a map of caches of component being rendered to cach state but either way there's this big growing thing that's just storing all of your uh app state so now you've just created a cache between your dom and you another level of caching between you and your dom right it's it's i mean it's it's it's a tr it's a truly interesting approach i i i think it's pretty cool but it's just one more caching and i i i have a general rule of thumb which is the more client side caches you have the harder your app is to develop now use memo cach is going to do is just like any other hook the next time this hello function is called it's going to get back that array that dollar array of casual and i also am very curious about uh hand tuning performance versus just general shock gun approach to performance often performance is not quite um as straightforward as just like just make everything into one thing usually that's not how things speed up typically what it's going to be is like you want to memorize these few things but it's actually cheaper to generate these other things and this is what we're going to do you know i am pretty curious is this like a do you get 50% of the performance game you get 150% performance gains plus 75% reduction in performance due to just over memoization i have no idea but i am curious about memory usage about cpu there's a lot of things be cu look to see is there any change in zero and in this case there's not going to be any change to zero so it's just going to return whatever was the zeroeth element in there as t0 for this particular example this is effectively the same as memorizing the component let's take a look at a more deeply nested example so this example is a bit more deeply nested we had a strong tag in there and it doesn't matter to the compiler the compiler has looked because there's one item so i'm curious about top lel and seeing that that tree the div and the strong is one unit and it's cashing that one unit so that tree could be arbitrarily complex still roll it up into a i am curious what this this if statement is how how does it know it has cash like a dollar zero is simple react uh memo cache sentinel meaning an empty value sentinels is like the negative one value well what about something that's rendered but needs to change oh oh so something else okay i think i get it so something something inside of react is detecting the change and deleting out the cache such that you get a sentinel value that's must be okay so that that has to be how it's working okay neat so you don't actually do a comparison it deletes out it deletes out the element internally upon change that must be what it is a single cache entry as long as there is no dynamic elements inside of it all right let's take a look at some data so in this example we've got a constant with a name jack and then we're going to just output that constant and you can see that this is where the compiler has really kicked in this is why i say that this is the most advanced compiler that i've seen in the front end space because it's looked at that constant seen that that constant is unchanging and actually just remove that constant alt together and just simply added it as part of the jsx invocation it's actually actively refactoring the code and that's why i say this compiler is an incredible piece of work it's taking the a that's given to it by babel and it's actually reconfiguring and rebuild what is the output of this beforehand wouldn't the output of this just be high and then passing in the constant named jack i mean do do you get i i don't know what you get out of that i i have no idea what like what extra you get out of here holding this component on the fly and creating an entirely new as and giving it back to babel for continued processing yeah i'm curious about object at this point you might be worried that your code is getting moved around by the compiler but in reality optimizing compilers that rewrite code have been around since the early 80s when we first got cpus every piece of software we use on our computer on our phones every day is compiled by an optimizing compiler this is just us as front end developers now getting those same kind of benefits of that compiler on the front end we as human engineers manage the logic and the compiler handles optimizing it to make it faster all right let's get back into the action i mean i i generally agree with this sentiment we shouldn't be we shouldn't be too worried about that i i'm just uh the difference of it all is that compiler bugs are extremely difficult and i'm not sure how much this is you know like i i i don't know if this is the same thing as like a an if false a if permanently false branch being trimmed out versus this i'm not sure if these are equivalent in compiler bugs to me this is more observational changes i'm i'm curious i'm curious if it falls into the same category maybe i'm just being a little too cr critical and you know maybe jack is completely right on this one hey i i can take the l i can take the l now let's jump ahead to our counter example this is what the current transp would look like you just have a ust state and then you have the jsx and anytime this component changes state it's going to rebuild that entire jsx tree now let's take a look at the react compiler version so in this case the compiler has looked at our code and seen that we have a count it is dnam and we are going to assign it to this p tag so it's going to create a cachable element this zeroth element as that particular p tag oh this is so wild to create to move this must create really large arrays because if you look at this values you'll notice that t0 gets assigned to t1 t1 gets assigned to t2 um also kind of wild that you you can you can take these out but then it looks like you do another thing with t 2 t1 goes into the third slot i'm curious about this set count which is dependent on count oh now it's not even doing the looks anymore okay even though it's actually so i was actually just looking at sentinel looks oh so the okay that's because the other elements they were they were unchanging elements they were static elements hence the reason why it was just like do a sentinel check if it's empty we render it once because it's an unchanging element else after if this is a changing element we have to do this okay so this memorization makes much more sense now now i i get this now now i get this okay my bad on that one my bad this makes much more sense but why ma models we're not sure the button code right below it and the button isn't actually t3 mention defined until this t2 block and then finally there's a t3 block at the bottom that brings it all together so if count changes then that zeroth block will get re-updated the t2 block will get re okay so just so i understand this it does look like how many pieces how many pieces of state do we have here we have effectively ust state i so this is how i'm going to look at it points of interest we have one point of interest with the set state we have one point of interest with this count this p count and we have one point of interest with this button count notice that we get all the way up to uh seven uh point right here the seventh insert which means that if if i just do basic math which i'm curious about if this scales now i'm actually very curious about this are we seeing exponential memory growth it it does look like exponential memory growth to this because there's three points of interest in this function and this thing goes to the seventh or eighth the the eighth item in the list which means 2 to the three is eight and so what happens if we add a fourth point of interest do we get all the way up to 16 if we get all the way up to 16 then we have ourselves exponential memory growth which would be i i one would argue pretty terrifying because most components don't look like this right most components don't look like that at all right you know have you ever have you ever worked again have you ever worked on any real application it's more like 9,000 items in a single one uh it's way more complicated i'm very very yes it's way way way more complicated um i'm very curious about this i am very curious about this and then the t3 block will get updated and then returned so let's see that in action to demonstrate that we've now added a by the way i am oh i never put i never put stuff in stuff i never put you know hooks in hooks but it's probably okay oh man actually i do want i i okay it probably has not it probably just has to do with rendering my guess is that these things probably only have to do with rendering but you are going to defeat the jit i guarantee you you will get jitted much less and you'll probably and and another thing to really consider is that for something to become jitted and its function length you'll probably have to run it like 22 times and when it runs 22 times it has to keep track of all of that memory to see are you having monomorphic calls how you know it does a bunch of checks and all that so your memory usage my gut feel says that this thing is probably going to significantly increase memory usage that's just my gut feel a doubled count to our counter component that just simply doubles the count and as we can see in the current transpiler we invoked the ed memo just as is but what happens when you get the react compiler looking at it well in this case we just remove the ed memo alt together and just simply run the calculation in place so what happens when the compiler sees something that isn't well written react well as it turns out it has a fallback where it just simply lets the original transpiler go so let's take a look at an example of that so in this case we're doing something they claim 0% memory increase somewhere in the talk i i just simply don't believe them uh i mean the jit alone has to increase because it requires more function calls there's i i just don't i i don't know how how does that how how i i just don't get it because we're storing more things i could be wrong they're very smart and very talented engineers i could be completely wrong and i'm i'm willing to eat some crow okay i'm willing to eat some crow and say i probably don't understand but to be completely real i just don't believe it i just don't believe it at all doing fairly funky in our assorted list component we're getting a list of names it's a list of strings and then we're setting this new name's state to that in it just moves allocations without creating them no no it doesn't it it has new arrays there are new arrays going on here and not only that but you're also increasing function length and function length is going to be proportional to memory usage have you ever looked at how much memory is used to make your jit work it's quite a bit per function you can actually look at these little these little uh function datas attached to each function it's not free it's not zero incoming prop what we want to do is if the prop of names ever changes we want b code also has cost string size is proportional to uta utf uh 16 like i i just i i just currently don't purchase it bundle size has to change here there has to be bundle size change change like you just can't convince me that this is somehow a zero cost there's many many things that exist that just like you can't you just can't say that i it would i would be hard pressed to believe this it disappear on me faster interactions uh faster initial load in navigations 0% memory increase yeah i mean i just from the va te one of the core members of the va team used to say to me you know i can make i can make anything look faster sorry i'm i'm an oldfashioned dev i'm an oldfashioned dev that when i see any numbers i don't believe it you should do the same thing you should just not believe things now you can say that you could be wrong i'm fine being wrong right i'm i don't know if it's bs i'm not saying it's bs i'm just saying i don't believe and that's that set new names to that new prop now a lot of folks hack this by using use memo and this is not the way that used memo is supposed to be used so if we remember back in counter doubled we actually ran the used memo code right in line so on line six you've got the exact count times two and we removed the used memo problem is that if we remove the used memo here we're actually going to get in an infinite loop where we keep continually setting new names over and over and over again every time we rendered in fact actually the linter tells us this and so there's an additional linter that comes along with a compiler that helps you get around problems like this but the really cool thing is what the compiler does is smart enough to know that in this case compilation is only going to hurt the component it's actually not going to make it any better so what it does is it falls back on the original transpiler and just says yeah we're just going to create a regular component out of this we're not actually going to put in our compiler optimizations and that's actually a really interesting behavior take a look at this intermixed file so here's two components sorted list and header the compiler has evaluated both of those components it does on a per component basis sort of the list that's good per component basis compilation happy about that so it said i won't optimize that component and instead let you have it your way but the header it can safely optimize so it's going to convert the header and use its caching in the header but it's not going to use it in the sorted list so you might be saying to yourself hey it's cool that i don't have to use use memo or use callback anymore but what about use effect do i still have to write dependency arrays for use effect well unfortunately yes you do but the react compiler does help stabilize the non-primitive references in your use effect dependency arrays so you my my general take on this one especially with that uh that that that twitter picture right here right is that you can just write a simple application that just renders everything and then by doing some basic memoization you're like look at how much faster or nicer it is that's what my worry is is that like did we get a really good test did we get someone that walked did we get an application that has been tuned that is large that has that people are actively trying to make faster and you have the right people on it to actually make it faster you know not like hey i'm faster right they use it in instagram well i'm not i mean that doesn't mean i'm that doesn't mean i'm convinced it's good i don't are these are these instagram stats this is in the context of instagram okay i mean hey okayy i could be i could be wrong i could be wrong okay okay okay okay on things like functions arrays it's very likely that it will help you fix some of your issues where your use effects are running out of control let's go take a look at a very simple timer example that demonstrates how the react compiler helps you with effect so here's the non-comp iled react app and we're getting this timer component mounted every time we go into the use effect and the reason we're running the use effect over and over and over again is that the reference to the adjust time function that's actually doing the work of adding seconds on is getting rebuilt every time we go through this function sense that means that depend array is changing which ends up creating a new timer that's not what we want check out the exact same code but this time running on the compiler what's happening on under the hood if we go back into my repple is that the react compiler is creating a t0 variable that holds the adjust time function and it's never going to change that adjust time function it's just going to create it once and then cach it off in dollar zer then down the second block it's going to create the cache body for the use effect as well as a cache dependency array and then it's going to pass both of those on to the use effect so what it's doing is stabilizing all those references for you and fixing what is a very common mistake when it comes to use effects that depend on arrays fixing shitty cod's a good thing all right before we wrap up a couple important things to really emphasize one react 19 does not include the compiler second there is a rules of react and there's a link in the description right down below follow the rules of react follow when you're writing your react code regardless of whether you're compiling or not so you can make sure that rule one of rules of react talk about the rules of react [laughter] this just like everywhere was just like dude this thing that the what's it called this thing had the word rules of react like' times on this page rules of react seven separate appearances of it just and the page is not even that big there's like not even that much stuff on there there just so much rules of reacting inverse fight club rule right there rule one talk about react rules that you're compatible with a compiler when you decide to use it next you should really be experimenting starting i do like it i actually will when it become i will ecro and say that the used memo directive is actually pretty cool that you can experiment and just drive small changes to see if it actually makes a difference i think that's pretty good i i i like that experience i think that that's pretty cool more stable another important note is that mobx is simply not going to work with this compiler it's just a fundamental issue with proxy based state management and this model because the compiler can't detect the use of a proxy at build time also as we go forward fair fair and factual proxies are extremely difficult i would anticipate that there's going to be a time when we have new libraries that only work correctly when they're compiled and that's probably going to cause some headaches and i think that's just to be expected good take jack good take that is that is such a good like observation which is there's there's this is actually such an incredible observation i wonder how much is going to happen where there's just going to be libraries and assumptions made about the react compiler where you just have terrible outcomes if you're not using it you know interesting interesting based on the layout of the component maybe using something like block rendering like million js in some cases i can even foresee a time when it potentially removes the need for dependency arrays that would be awesome now i'm not going to say that any of that is going to happen but having a compiler now opens the the door for all of that yeah long story this is dependency arrays would be great because it's i mean dep the the hard part about removing dependency arrays is that sometimes you don't want something in the dependency array that does appear within the capture uh by the way dependency arrays and and use effect who here has done c++ functions i'm just curious who here has done c++ functions yeah here yeah yeah cat dude i'm telling you yeah there's a lot of ones flying on the screen um use effect and use memo and these little capture groups are what your closure captures as well just gives me such strong c++ lambda vibes oh my goodness such strong c++ lambda vibes where you have to have like your capture group yeah exactly jamie jam le jam le knew it jam le knew it look at that oh my goodness does that does that not give somebody nightmares whole new era of react and we'll be writing react very differently starting pretty soon here a guy on my team is in love with c++ lambdas really you can throw some you could wait what what what does this do oh you can template a lambda shoot that's crazy that's that's crazy man templating a lambda man i i don't i don't know about that that's kind of wild i don't think we should dude i don't know if we should do that i don't i don't i don't know if we should do that what is this what are what are you doing why do you got why do you got hats in here what language is this how do i declare a block crazy objective c nobody ain't nobody likes objective c all right let's finish let's finish off this video and i don't think any of us really know exactly where this is going to go but i can say with confidence that i'm really excited to be on this ride with you and i really appreciate meta giving me an advanced look at the react compiler so i can bring all of that information to you well i hope you enjoy this first look at the react compiler i'm sure there will be many more to come in the meantime i am working on a course on nextjs it's called pr nextjs dodev head over there right now give us your email you get on to a free newsletter and come in the meantime i am working on a course on nextjs it's called pron nextjs dodev head over there right now give us your email you get on to a free newsletter and also get access to really great tutorials on state management and forms management i'm super proud of it and it'll be coming out really soon now so look forward to that in the near future meantime of course if you like this video hit that like button if you really like the video hit the subscribe button and click on that bell and be notified the next time new subscribe you guys can go and you guys can go and like that video and you guys can subscribe there you go that was great good job jack that was really good it was a really great breakdown good job jack i you know i am again i'm very curious about jit how does how does this affect jit and i know those stats were from instagram um you know i've worked at a fang company uh for a long long time and i just one really strong thing to make make sure you always understand is that just because it's a fang company does not mean software is great coming out of the fang company so when you tell me that uh instagram got that much faster i'm not like dang the world's greatest engineers couldn't compete against couldn't compete against the compiler it's that it's that it's that good that's not necessarily how uh these things go okay i'm just letting you know that typically the code is horseshit at at a fang company okay you think it's some sort of prestigious great place where you have to do these crazy leak code questions to be able to do anything but the reality is is that it's just horeshit it's been horeshit it's been dog [ __ ] every single day it is dog water it is low bar it is not great and this is only speaking from my limited experience at fang for being 10 and a half years at a fang company okay that's it that's because all you know i'm going to give you i'm going to give you one last secret just because someone is super smart doesn't mean they don't create bad code okay all code is ugly all code eventually sucks you have any product that's been around for 10 years that has had fe feature after feature after feature in which it was not designed to initially contain of course it's just going to turn into just crap and then not only that but it also has deadlines it has people asking it has things it has to do you have layoffs you have hit by this you have hit by that you're going to have people that leave that have just a huge amount of tribal knowledge with the product and what happens in the end it's just not that great this is just how it works life is messy code bases are just a reflection of it the name is the prem