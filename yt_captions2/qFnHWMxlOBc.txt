what about your setup how many screens what kind of keyboard is there something interesting what kind of i uh ide to be completely fair me and lex we share the same keyboard okay him and i we use the same keyboard okay and i'm a one screen i'm a monogamous screen user okay it's just a fact of how i live my life emacs vim or something modern uh linux what operating system laptop or any interesting thing that brings you joy so i kind of migrated cultures where early on through all of game dev there was sort of one culture there which was really quite distinct from the more uh the silicon valley venture you know uh culture for things it's they're different groups and they have pretty different ways and the way they think about things where and i still do think a lot of the big companies can learn i can learn things from the hardcore game development side of things where it still boggles my mind how um how hostile to debuggers and ides that so much of them the kind of big money get billions of dollars silicon valley venture-backed funds are well this is who says anyone's hostile no but no one hears hostile towards i should think sorry so you're saying like like big companies like google meta are hostile to they are not big on debuggers and ides like so much of it is like emacs bim for things and we just assume that debuggers don't work most of the time uh for the systems and a lot of this comes from a sort of linux bias on a lot of things where i did come up through the the personal computers and then the dos and then i am windows and and it was borland tools and then visual studio and do you appreciate the buggers very much so so i do think there is something here that's a little bit just a little out of sync here you know sorry if i'm you know just i'm not trying to be a mean guy here i'm just slightly correcting john carmack i know i shouldn't even do that but i'm gonna do that uh there's also this idea that being able to log and be good at logging to debug and relying on logs to debug is really great for your servers right because that way when you're off in production you have a way to be able to turn on the complete and proper set of debugging instrumentation and know exactly what the problem is and if you're not good and adept at that you won't know why something is breaking one of the worst possible solutions in production is when you have to create what's happening you know on the server on your local machine to know why it's breaking i think that's really really really hard and so to me that's like a it's a different problem it's a different problem a different scope and so i think a lot of people are used to one way or the other and i totally get why people like the buggers people love the buggers uh i think a lot of times it's also based on the complexity like the stuff that he worked on is vastly different then the stuff i work on right there is no such thing as a shader the amount of complexity and things that i'm working on is extremely small in comparison and so is it faster or worse is it better what is it javascript is not like this continuously running debuggable environment like he's talking about it's not quite the same worlds that were you know that we live in here um but it's interesting you know and so a very good thing is to know how to debug what's going wrong in production when you need to what did he work on john carmack what did he work on do you need to get the hell out of the chat buddy you need to get out you want to get the hell out of the startup coming at me with that who's john carmack talk i'm gonna leave this earth both feet fly through space and they're gonna land betwixt your shoulders okay i'm gonna drop kick you if you keep this up clean out of the startup i mean a debugger is how you get a view into a system that's too complicated to understand i mean anybody that thinks just read the code and think about it that's an insane statement in the that is an insane statement you can't just read the code and think about it that's there's no way that you can do that but again it you know logging is an important aspect of debugging that's different for different things yeah we can't even read all the code on a big system you have to do experiments on the system and doing that by adding log statements recompiling and re-running it is an incredibly inefficient way of doing it i mean yes you can always get things done even if you're working with stone knives and you know and bare skins that's that is the mark of a good programmer is that given any tools you will figure out a way to get it done i do like my bare skins and my stone knives sir sir uh you know but again it's still very very different like there is no i don't have like a an equal here when it comes to like when i'm developing on netflix there is just it's just like not even a thing right it's like i can't what he is saying i can't even like do you know what i mean like i have to run it i have to compile it i have to go it's always compiling it's just like a go and it has to take the input and play it through so replayability is like a huge part of debugging for me like that's really where i put a lot of my like emphasis on on stuff is in that area but it's amazing what you can do with sometimes much much better tools where instead of just going through this iterative compile run debug cycle and you have the you have the old list direction of like you've got a repo and you're working interactively and doing amazing things there but in many cases a debugger as a very powerful user interface that can stop examine all the different things in your program set all these different break points and of course you can do that with gdb or whatever there but this is one of the user interface fundamental principles where when something is complicated to do you won't use it very often there's people that will break out gdb when they're at their wit's end and they just have beat their head against a problem for so long but for somebody that kind of grew up in game dev it's like they were running into the debugger anyways before they even knew there was a problem and you would just stop and see you know what was happening and sometimes you could fix things even before you you know even before you did one compile cycle you could be in the debugger and you'd say well i'm just going to change this right here and yep that did the job and fix it and go on and for people don't know gdp gdp is cool though rgb gdb is good i i've always wanted to get better and better at gdb because i feel like that's like the end game of great of like knowing your stuff like i kind of know it a little bit here a little bit there you know what i mean i'm okay at it the grand dick debugger yes that's what it stands for b is also popular i guess linux debugger uh primarily for c plus plus they handle most of the languages but it's you know it's based on c as the the original kind of unix heritage and it's kind of like command line is not user friendly it's not it doesn't allow for clean visualizations and you're you're exactly right so you're using this kind of debugger usually when you're at what's end and there's a problem that you can't i mean i agree it's not as pretty as like uh the chrome debugger or intellij's nice debugger i assume he uses vs code or not vs code but visual studios and so visual studios i assume is is probably is prettier right when they say not friendly a lot of times what it comes down to is the fact that you can see your changed variables your stack trace your code you have like a lot of options for what you can see um i just don't really again i just don't really have like a a huge need for it you know what i mean i figure out why by just looking at the codes they have to find it that's how i guess normal programmers use it but you're saying there should be tools that kind of visualize and help you as part of the programming process just the normal programming process to understand the code deeper yeah when i'm working on like my cc plus code i'm always running it from the debugger you know just i type in the code i i run it many times the first thing i do after writing code is set a breakpoint and step through the function now other people say it's like oh i do that in my head well your head is a faulty interpreter of all those things there and i've written brand new code i want to step in there and i'm going to single step through that examine lots of things and see if it's actually doing what i expected it to it is a kind of companion the debugger like you're you're now coding in an interactive way with another being uh the debuggers are kind of dumb being but it's a reliable being that is an interesting question of what role does ai play in that kind of um well i think this is pre-chat gpt3 right yeah so so a lot of times whenever i'm doing something this is kind of an interesting take also here which is whenever i'm programming any sufficiently complicated function anything that's really kind of difficult for me to be able to do first try so i think of like a classic example is like how do you uh chat generation or not chat generation sorry csv generation it's it's not an easy problem it's not an easy problem to create a csv and so with that in mind when i'm doing my stuff i'm going to create unit tests around that and program against it right and so as i create the whole thing i then create a unit test make sure that i done the happy path correct think of one or two things that aren't good and program against that and as something breaks inevitably i use that as a mechanism for remembering that this thing broke this way or even more so i will sometimes use unit tests as a way to develop when it's just too complicated to try to run that thing any other way now some people might call this tdd but it's not quite tdd because i've finished the implementation and i'm just using it as a way to validate and test it quickly and then i delete that test often because it's just me using it in various ways and i try to formulate a test that's more reasonable you know what i mean uh yes 2020 bc before the old the new bc is now moved all the way to 2020. with codex and these kind of ability to generate code it might be you might start having tools that understand the code in interesting deep ways that can work with you i mean there's a whole spectator that's code analyzers and various kind of dynamic tools there up to ai that can conceivably grock these programs that know he literally no human can understand they're they're too big to intertwine and too interconnected but it's not beyond the possibility of understanding it's just beyond what we can hold in our heads as kind of mutable state while we're working on things and and i'm a big proponent again of things like static analyzers and some of that stuff where you'll find some people that don't like being scolded by a program for how they've written something where it's like oh i know better and sometimes you do called rust okay that's why we all use rust all right we all use rust because we're not sadomasochists we're actually people that we want strong static you know analysis i know better that i'm not that smart and by the way i just have to be able to figure out any way i can bring in rust into this okay i just have to know you know like this is one of those moments this is a clear moment i saw the opportunity i brought it in dude but that was something that i was it was very very valuable for me when uh and not too many people get an opportunity like this to have this is almost one of those spiritual experiences as a programmer and awakening to i am feed software code bases were a couple million lines of code and at one point i had used a few of the different analysis tools but i made a point to really go through and scrub the code base using every tool that i could find and it was eye-opening where we had a reputation for having some of the the most robust strongest code you know where there were some you know great things that i remember here that's a great reputation like who wouldn't want that rep like how would you like to know that when people use your code or use your stuff that the way they say it is oh yeah that yeah that's like the best code out there like if i'm gonna have to integrate with anybody i want to integrate with that guy like that's that should be like a hashtag goal for everyone i love that that's what i want in my life i want more of that bring from like microsoft telling us about crashes on xbox and we had this tiny number that they said were were probably literally hardware errors and then you have other significant titles that just have millions of faults that are getting recorded all the time so i was proud of our code on a lot of levels but when i took this code analysis squeegee through everything it was it was shocking how many errors there were in there things that you could say okay this was this was a copy paste not changing something right here lots of things that were the most the most common problem was something in a printf format string that was the wrong data type that could cause crashes there and that i did i've i've print i have print myself way too many times way too many times in my lifetime to dang dang it gets me now you really want the warnings for things like that then the next most common was missing a check for null that could actually happen that could blow things up and those are obviously like top cc plus plus things everybody has those problems but the long tail of all of the different little things that could go wrong there and we had good programmers and my own code stuff that i'd be looking at it's like oh i wrote that code that's definitely wrong we've been using this for a year and it's this summer you know this mind sitting there waiting for us to step on and it was humbling it was and i reached the conclusion that anything that can be syntactically allowed in your language if i'm it's going to show up eventually in a large enough code base i you're not gonna good intentions aren't going to keep it from happening you need automated tools and guard rails for things and those i like this take a lot like i you know i i know we'll probably disagree on the debugger thing or really i don't even think we disagree i think we're just in different environments uh it's just like not really an option a lot of the things he's talking about for me to run but this idea of being able to run additional tooling on top of your code to say that you are correct correct you know that's why i've said multiple times this new like co-pilot x thing coming up the fact that it does not have a hey these could be problems in your code blows my mind right like that is the they they've integrated it with github and they do like unit test generation i don't want it writing unit tests i want to really think about my unit test i don't want to generate just crap i don't want it to alert me that i don't have enough testing i wanted to tell me where have i messed up that's not caught by the language like something my own dumb self has done right like to me that is like the greatest possible use of ai in programming and that's like the one they're not doing that is the best thing it blows me away honestly it blows me away start with things like static types and or even type hints in the more dynamic languages but the people that rebel against that that basically say uh that slows me down doing that there's something to that i get that i've written you know i've cobbled things together in a notebook i i'm like wow this is great that it just happened but yeah that's kind of sketchy but it's working fine i don't care it does come back to that that value analysis where sometimes it's right to not care but when you do care if it's going to be something that's going to live for years and it's going to have other people working on it i and it's going to be deployed to millions of people then you want to use all of these tools you want to be told it's like no you've screwed up here here and here and that does require kind of an ego check about things where you have to to be open to the fact that everything that you're doing is just littered with flaws it's not that oh you occasionally have a bad day it's just whatever stream of code you output there's going to be a statistical regularity of things that you just make mistakes on feels good too doesn't it oh man especially like right now i'm kind of having what uh you know we've jokingly referred to as like you know it's just like my tool is kind of being used a bunch um at my job now my latest tool and a lot of people are using it and dude i get like one or two reports a day like hey it doesn't work this way hey this thing broke it hey this one thing you didn't expect this output from the server because you know i'm hobbling together like seven different services to do output and dude i just get bamboozled bite all sorts of things i didn't know existed right just constantly and i am and i do think there's a whole argument about test driven design and unit testing versus kind of analysis and different things i am more in favor of the analysis and the stuff that just like you can't run your program until you fix this rather than you can run it by the way that was obviously a rust reference clearly that was a rest reference okay i know he may not admit it out loud no matter what but you know we all know and hopefully a unit test will catch it in some way yeah in my private code i have asserts everywhere uh just there's something pleasant to me pleasurable to me about sort of the dictatorial rule of like this should be true at this point and too many times i've made mistakes that shouldn't have been made and i would assume i wouldn't be the kind of person that would make that mistake but i keep making that mistake therefore an assert really catches me uh really helps all the time so my code i would say like 10 to 20 of my private coach just for personal use is probably a certain and they're active i do like that i really i really do feel like i need to try using more asserts i don't really assert like i do feel like there's something to that that just seems like such a good move and yet i don't do it you're gonna assert these nuts where are you gonna assert them at they don't make any difference to the program and if it was all operating the way you expected it would be then i they will never fire but even if you have it right and you wrote the code right initially then circumstances change the world outside your program changes and in fact that's that's one of the things where i'm kind of fond in a lot of cases of static array size declarations where i went through this period where it's like okay now we have general collection classes we should just make everything variable i because i had this history of in the early days you get doom which had some fixed limits on it then everybody started making crazier and crazier things and they kept bumping up the different limits this many lines this many sectors uh and it seemed like a good idea well we should just make this completely generic it can go kind of go up to whatever and there's cases where that's the right thing to do but it also the other aspect of the world changing around you is it's good to be informed when the world has changed more than you thought it would and if you've got a continuously growing collection you're never going to find out you might have this quadratic that's a really good that's that it is very interesting right like to be able to always find your bounds like what cannot what can something not exceed and if it's exceeding it why is it exceeding it this video is in 1.25 slow down on something where you thought oh i'm only ever going to have a handful of these but something changes and there's a new design style and all of a sudden you've got 10 000 of them so i kind of like in many cases picking a number some you know nice brown power of two number and setting it up in there and having an assert saying it's like hey you hit the you hit this limit you should probably think are the choices that you've made around all of this still relevant if somebody's using 10 times more than you thought they would yeah this code was originally written with this kind of world view with this kind of set of constraints you were thinking of the world in this way if something breaks that means you got to rethink the initial stuff and it's nice for it to for for it to do that is there any stuff like a keyboard or awesome i wonder how well that works in the web world right like you can't assert things in production but you need a way to be able to run enough things to be able to know that because right like you can't just explode your pro you can't just take down your servers it's interesting a fairly pedestrian on a lot of that where i i did move to triple monitors like in the last several years ago i had been dual monitor for a very long time and i am and it was one of those things where probably years later than i should have i'm just like well the video cards now generally have three output ports i should just put the third monitor up there that's been a that's been a pure win i've been very happy with that um but no i don't have fancy keyboard or mouse or anything really the key things is an ide that has i always feel like that argument for multiple monitors it always just comes down to one thing how efficient are you at moving within your operating system uh for me i'm a one monitor person i will always probably be a one monitor person because it's just a single key press to do that which for me it feels easier than looking somewhere else focusing getting the point and doing you know and using it the same way i'd rather just do this because for me that's easy i don't know i've always been a one monitor kind of person i have two computers i only have a second computer because i stream it's not because i have two computers i when i when i'm at my day job i'm just i'm just doing that and i just play my music right here you know i'm on youtube doing whatever on youtube there we go this is fantastic and then when i'm done i'm just right back here you know i'm just i'm just working and when i want to change something i just hop back over to it i3 yeah i know a window manager is really good a window manager is really really good i think people sleep on how good a window manager is uh helpful debuggers has helpful tools so it's not the emax vimro and then diet coke yeah so i did spend you know i spent uh one of my week-long retreats where i'm like okay i'm gonna make myself use uh there's actually classic vi which i know people will say you should never have done that you should have just used them you know i gave it the good try it's like okay i'm being in kind of classic unix developer should have went with vim vi is too old it's not quite it misses a lot of good motions it's why i don't really like vi there's a lot of motions and ways you can manipulate texts that are just so much better with vim developer mode here and i use i worked for a week on it i used kinky to like teach myself the different little key combinations for things like that right and at the end it's just like all right this was kind of like my civil war reenactment phase you know it's like i'm going out there doing it like they used to in the old days and it was kind of fun in that regards so many people right now like it was screaming as they're listening to this okay the out is that this is not i mean i am offended okay i am genuinely a program i think it's just the best the fact that i can do that this is fantastic to be able to jump in here and just hit that chad stack right like look how good that was okay to be able to go back here and go to that cargo chatter that we're building right the ability just to swap between these two projects with you know just oh modern video but still i yes i was very happy to get back to my visual studio at the end yeah i'm actually i struggle with this a lot because so use a kinesis keyboard and um i use emacs primarily and i i feel like i can exactly as you said i can understand the code i can navigate the code there's a lot of stuff you could build with an emacs with using lisp you can customize a lot of things for yourself to help you uh introspect the code like to help you understand the code and visualize different aspects of the code you can even run debuggers but it's it's work and uh the world moves past you and the better and better ideas are constantly being built and that that puts a kind of i need to take the same kind of retreat as you're talking about but now i'm still fighting the civil war i need to kind of move so i did i did do it you guys saw it i did a week-long in vs code right i i decide to lay down my musket and try out one of these new fancy armalite rifle platforms it was horseshit solid solid yeah i spent a lot of time setting up vs code i spent a lot of time setting up vs code it just works no it actually doesn't you gotta set up quite a few things and then you're playing this game of finding options and all the options are crazy to find just like vim except for it's just not it's just not quite the same you know just not quite the same moving to the 21st century and it does seem like the world is or a large chunk of the world is moving towards visual studio code which is kind of interesting to me against the javascript ecosystem on the one hand i use harpoon and i did use harpoon by the way i used harpoon and vs code i was using it i was loving it okay i still have i still hate it and and ids are one of those things that you want to be infinitely fast you want them to just kind of immediately respond and like i mean heck i've got there's someone i know i'm an old school game dev guy that still uses visual studio 6 and on a modern computer everything is just absolutely instant on something like that because it was made to work on a computer that's ten thousand or a hundred thousand this is why i like using them right here this is this is the statement that's why i like it is because i don't want to have to be in here and having to play this game of like why isn't my stuff loading why is my lsp taking so dang long like i just want things to feel really crispy you know what i mean that's why i use it because i don't like that feeling that vs code gives me it just drives me nuts thousand times slower so i'm a glutton for performance i love it just everything happens immediately and all the modern systems just feel you know they feel so crafty when it's like oh why is this refreshing the screen and moving around and updating over here and something blinks down there and you should update this and there's you know there are things that we've lost with that incredible flexibility but lots of people get tons of value from it and i am super happy that that seems to be winning over even a lot of the old vimini max people that they're kind of like hey visual studio codes maybe you know not so bad um that may be the final peacekeeping solution where everybody i actually i would rather use visual studio real talk i'd rather use visual studio if you said hey do you want to use visual studio or vs code i would rather use visual studio i'd rather use intellij at least intellij it takes like a minute to start up it has to go crunch some indices for a while it takes a long time to get set up but once it's there intellij is fast but it has to do a bunch of crunching but at least after it's crunched it is fast and to me that is really important is that i want that smooth feeling i want all that stuff you don't get that with vs code ever it just never feels fast he is reasonably happy with iowa is good i use intellij for two years i really tried to love and learn intellij and i really did i used it for quite some time and then i moved over i did i did visual studio i've done intellij i sublime vs code adam vim neovim emacs do max space max i've tried so many gosh dang editors you know what i mean i've tried so many intellij's tooling is absolutely great yeah it is it is very very good intellij is really good