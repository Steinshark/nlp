let me know if this has ever happened to you you feel like you finally mastered pointers you write some code that uses pointers maybe you use the heap maybe you don't you run your code and it still crashes anyways you check the syntax of your code and the syntax is definitely right but something about the code isn't now all because you know how to use pointers doesn't mean you're using them correctly and it's actually really really easy to mess up raw pointers in c and c plus plus take for example this piece of code here you see the bug this bug has a used after free vulnerability where on this line here the code gets freed but later on the logic doesn't check for the free and the pointer gets used anyway causing the program to crash i used the syntax correctly i just didn't use the pointers correctly now i know c plus plus catches a lot of hate for being a language that kind of puts the whole kitchen sink into the language but it actually has some really elegant solutions for stopping this kind of scenario from happening in the future by using a thing called smart pointers now c plus offers three kinds of smart pointers that add some really cool functionality but also have some really huge pitfalls that make using pointers easy in some places and harder and others let's talk about those scenarios now here is an example of c plus plus code where we create an example class the class's name is dog and it has a method speak and a method that's a setter of set name that sets the dog's name we have the functions defined here reset the name and then when we talk we say bork bork i'm the the dog um and so this is the example that people typically show to show why you should never use raw pointers in c plus plus so we create a new dog and set the dog pointer named ralph and then later we call the function do something with the dog where we say the past object set its name to high high and then speak so if we go ahead and compile that we can compile it and run it and it actually behaves as expected no issues so far but what if there was logic in this code where we do something to the dog and eventually we say delete d but later on in the code when we talk about the dog or do something else with it outside of that function we don't check the value of the pointer to see if it's null or freed and then eventually we run into a crashing state right where we could say pork pork i am high high this first part runs but later on in the program because this pointer ralph is no longer valid it crashes the program so instead of using a raw pointer in c plus what we can do instead is use the smart pointer concept here we're going to create what is called a unique point winter a unique pointer literally is as it sounds a pointer to an object that is unique meaning no one else is allowed to point to that object we make a unique pointer of a type dog the unit pointer's name is ralph and then we call standard make unique on dog to invoke the object constructor and make the object right and then so later we can just pass around ralph like a regular pointer we can call set name on it we can call speak on it and we can compile it and run it we get kind of that expected behavior right bork bork i am asdf etc now the things start to get a little weird with unique pointers and you start trying to use unique pointers around in other places in your program a unique pointer represents not only a pointer that is unique to an object that points to that object but it also represents who owns that object and in programming when we say who owns a thing we're talking about who was responsible for destroying the object when you're done using it right to prevent that use after free scenario and to prevent memory leaks right now as programmed by passing in ralph which is a unique pointer to a function that expects a dog pointer a raw c pointer as input we will get a pretty nasty compilation error because these types just don't match up so by now changing the parameter type from a dog pointer to a dog unique pointer you would think that this would work but this is also another problem and it goes against the unique pointer construct if we compile this what's happening here is we are actually passing the value of the unique pointer ralph by value right we are making a copy of the unique pointer and that in itself is not very unique right i'm now at the same time have two copies of the same pointer and the c plus plus compiler will not allow me to do that to pass ownership of the object from our main function to the do something with dog function we have to do what is called a move we will literally standard move ralph the dog to this function and now this function is responsible for controlling it so if we compile that we get no errors and let's run this okay so we did crash again and i want to see if you guys understand why we crashed what did i say before ownership is the idea of who is responsible for destroying the object we moved ownership of ralph to our function do something with the dog we then called set name on ralph and then called speak on ralph and because we did not return ralph ralph went out of scope and because ralph went out of scope using a c plus plus smart pointer ralph was freed our code then continued and later on in the code we tried to use functions in an object that had been freed and we crashed the program just like before and this first part pointer started to get a little weird right because now essentially every time i want to use a smart pointer i have to say that this is no longer a void function this is a standard unique pointer to a dog and we're going to say that it returns this and we're going to say that it returns d and we'll say that ralph now equals itself after the move so it does something with the dog that we move ralph into we pull rat ralph back out and now the program doesn't crash it runs twice but this this is kind of gross right this code is not very good to look at it's kind of confusing and typically when you have a function that does something you want to return the result of the thing but if i have to move ralph out of the function every time now every time i want to use a unique pointer it makes it very ugly to do so one way we can deal with this problem with the unique pointer where we have to pass it around and move it and then unmove it is to use the get method from the unique pointer so the get method in the unique pointer actually returns a raw pointer to the thing that the unique pointer controls you're probably thinking well then doesn't that defeat the entire purpose of the unique pointer and yes it does but what you can do with it is actually there's a couple ways you can work around it to make the unique raw pointer work right so here i say ralph.get which again returns the raw pointer to ralph what we can do is in our function that uses that raw pointer we can set the raw pointer to to a constant which essentially locks down what the pointer is able to do and it doesn't allow us to modify our class variable now that adds some future complications where now d speak has to be declared as a const function that guarantees we don't actually modify the class we have to also put that in the declaration right here but with that all done we can go ahead and compile this and eventually we can actually use the raw pointer to do certain things with the class while also retaining ownership in the main function now an even easier way to do this is just to treat this the way that i think you should treat it all the time generally which is the use of the other class a shared pointer if you have a shared pointer dog d it's a still a void we'll clean up our constants here and then we will also say d set name to asked as this will be not a unique it'll be a make shared and we'll set this to a shared pointer and then we will just pass ralph and that should just work so what happens here is we essentially create a shared pointer which is a unique pointer that can have multiple copies of itself as we create the second copy of ralph all that happens is that the reference counter inside the sharepointer goes up by one and that reference counter is used here to denote that we have a pointer that now has two places that are using it when d goes out of scope the shared pointer copy that we made is deleted and we still retain ownership of the object here in main then ralph continues and we call the extra functions here and things are good another smart thing you could do to protect hackers from stealing your identity online is to use two-factor authentication for reliable two-factor authentication for all the services they use during the day i rely on uv key by ubico the sponsor of today's video hackers who steal passwords are pretty smart but adding a security key to your authentication scheme is an easy way to protect your online information the ubiki by ubico is a two-factor authentication solution that makes adding a second layer of security to your accounts super simple now i use ub key every day to log into my personal accounts like my gmail my stripe application for my business and my twitch account just plug the ub key into your device add that ub key to the service and then the next time you're asked to log in touch the key and you're in so if you're doing anything online be smart and protect yourself with an additional layer of security with a uv key by ubico you can use my offer code low level 5 to get five dollars that's ten percent off get one before the offer expires thanks again ubico for sponsoring this video i wanted to make this video to kind of show you guys that like you know smart pointers exist they have their powers they do solve certain problems but with every solution in computing you solve one problem and you make another problem anyway guys that's all for this video i hope you enjoyed that if you did go watch this other video that i made about c plus plus as well