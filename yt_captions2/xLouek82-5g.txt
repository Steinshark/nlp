meet val a new language because you know honestly what we need right now in 2023 is another new language because right now i'm not going to lie to you when i'm programming v o camel nim uh odin zig rust carbon i sit there and i think you know what i need i need a new language because all these other languages okay they ain't it i need something different i need something new something fresh meat val a new language alternative to c plus plus and rust val is a high level programming language that runs close to the metal said the language creator demi recardan val is a new high-level programming language that runs close to the metal it's the brainchild of demi record a postdoc researcher at northeastern university who focuses on language design and type-based approaches from memory safety it started as a byproduct of research uh she did with google and adobe on the swift programming language and the decide in the discipline of mutable value semantics which upholds the independence of values to support local reasoning i'm sorry or congratulations i ain't gonna read that um haskell rust and r are other examples of languages that use mutable value semantics oh man given pick boners right here uh this is a project that started around two years ago i wrote the paper i collaborated with great people at google and adobe told the new stack now for this paper i had a small idea in the back of my head and i thought oh we'll try implementing some stuff and it will be two or three week project it's been two years what does this tell you people what does this tell you tells you two things first off the rate of new languages is slowly exceeding the rate of new javascript front and dom manipulating libraries specifically number two what this tells you is that engineers are the worst estimators ever look at this person okay she demi demi demi or demi i'll call her demi for here from here on out demi is a post doc okay postdoc that means she went through school then decided to go back to school and then decided to go back to school again and then after being in school decide to go back again for languages and then thought oh i could probably do this in three weeks two years later honestly this is literally every one of my projects this is this is me this is actually me uh let's see nothing else does quite what regardon wanted she started with swift because she already knew it if there's ever been a sentence that never needed to be written that's the one yeah started with swift why you ask cause i knew it you know i didn't start with the language i didn't know to design a language i started with the language i did know and did a lot of research on i know it's kind of crazy and swift supports immutable value semantics it checked a lot of other boxes she wanted as well such as compiling to machine code making it good for systems programming but also undermines the value semantics because it mixes it with other things she added that made record i wonder what would happen if she made a language that was purely about mutable value semantics okay so i'm gonna be real here i'm gonna be really real and vulnerable with you guys so please don't say anything that's rude or hurtful i don't know what mutable value semantics means okay my guess is it literally you just have to define when something is mutable is that all that it means and in strictest form of mutable value semantics references become second-class citizens they are only created implicitly at function boundaries and cannot be stored in variables or object fields hence variables can never share mutable state in other words mv s allows you to return multiple values from a single expression while mvs restricts how references can be used in a program returns multiple values from a single expression restricts how how did multiple dude i swear this is just chat gpt just a hallucinating things here's a table that summarizes the key difference between mvs and mvs what the hell are we even looking at can we stop using ai to solve everything can we just stop i don't even know what i'm looking at anymore now i'm just super confused can we just stop using ai to solve literally everything it is very very confusing we're just gonna go on okay i'm sure what it means is something amazing but i can't do this anymore okay we're gonna all pretend like we know what this word means and we're gonna keep on going they checked a lot of other boxes as well she wanted she wants such as okay we already read that mutable value semantics is a programming discipline that really focuses on notional value not notional values so if i have an array of things for example the value of this array is the most important concept that i want to manipulate she said that gives me local reasoning is this just gonna be another haskell clone amazing white paper but doesn't actually do anything i don't know what the hell just i again what the hell did you just say to me what are you saying to my face uh to really understand why this approach is needed record said uh consider reference semantics which is another approach used by modern programming languages especially in parative languages such as c plus plus javascript python and java uh these languages distinguish between primitive data types such as integers or strings sometimes and those uh types behave like values she said changing the value of an integer doesn't create an observable side effect to some other place in the program this is definitely a hassler that's not the case for other data types such as aggregates arrays or hash maps because they have reference semantics okay okay what happens if you pass an array to a function in python and then this function goes on to change the array maybe adding an element or removing some element from this array then this effect can be observed from the outside of the function is are have we just been reading hundreds of words to just describe the word mute in front of a variable is that is is what i'm hearing right now is is it literally just going let mute foo equals five is that what they're saying by local reasoning i knew i was a genius see this whole time this whole time i'm over here pretending to be stupid for you okay but the reality is you you are stupid okay maybe you should kind of you know use your brain a little bit more often okay big brain okay big brain she explained the collar of the function will have its own array being changed you cannot reason locally about the values because every time you call the function some side effect might occur in a seemingly unrelated part of your program that makes i mean i do agree with the idea that you should define i love the idea of defining mutations man i've said this in completely different terms uh i've always preferred the idea of define when things mutate versus uh don't or defining when they should be immutable so typescript does the opposite of this right so if we go back uh here and go to uh scratch wait i thought i had it in here uh scratch is it in here really do i not have it i thought i had like a little do i not have it in here do i is it in here i thought i had something in here huh here let's let's erase this thing uh and you see this all the time uh with something like typescript is that you'll have something like uh function foo and foo will take in a say an array and it's an it's a number this as const right or no no no not as cons and it in a function header you go read only is read only over here no no that's that's it's right here there you go like you have to specify the inversion of that you say when it's not changeable versus the other way which is you have to specify when it's changeable i think i prefer i i prefer the other way and it's true because i go like this let's just pretend like this thing is an array of can we do that can we go uh foo equals i don't know uh food number there we go lots of foods in this thing because you know i prefer things to be as confusing as possible you know what i mean there we go all right so this is an array of foo and so can i go like this foo equals five foreign i hate typescript sometimes i know people love typescript okay i get it um i get it uh i get it i understand that read only means that it's only read only at the array level but this this ain't it okay this is not how it does stop making excuses for just really annoying behavior okay it's please just just drop the copium yeah of course you choose ts over js foreign just it's always emotionally painful when i see those things that makes it difficult to apply local reasoning for humans which makes it harder to be sure that programs are correct she said but it also makes it uh difficult for compilers because optimizers now need to be very conservative about what happened she said the optimizer has to account for the fact that other references might exist and some seemingly unrelated part of the program might need the value that is being mutated so it's best not to do anything rather than compromise the reference architecture the value of mutable value semantics this is where the value of mutable value semantics becomes useful mutable value semantics remove the references from the picture she explained uh but it preserves in-place mutation which is very efficient absolutely for instance if you want to sort an array in place you don't have to build a bunch of new data structures and try to recombine them she said uh that kind of peer functional model will put a lot of pressure on your optimizer to recover the lost efficiency you want to do things in place because allocating a lot of pieces of memory and recombining them together will be very very slow i mean i agree this is in terms of in terms of computer speed she's 100 correct that provides a very transparent uh performance model which is a very good so i honestly have no idea what this language does yet mutable value semantics removes these references from the picture you only have values and a bunch of techniques that you could use to preserve sufficient expressiveness it looks like functional programming but what you really want to preserve is in-place mutation because in-place mutation is very efficient that's what she said um take care this is definitely haskell 2.0 really what i'm reading out of this is that the heap was a mistake is that what i'm hearing the heap was a mistake we should have just always used the stack to begin with um that's you know there's there's this funny notion that programming got hard because of the because of the heap the heap truly ruined programming garbage collection is a result of the heap being impossible if you don't understand the difference between a heap and a stack like go read about it like i'm sorry but i think that might be slight slightly out of scope for this talk uh why don't you just create mike michael michael scott plus plus language one shut up okay i'd rather be bill burr uh this includes let's say okay uh the language is designed for systems programming so it's primarily for any application that runs close to the metal and needs to squeeze the most possible performance from the machine then said that includes uh uses such as operating systems memory intensive applications such as video games or image processing or other applications that can't afford a virtual machine or a garbage collector embedded applications would also be very interesting target she said so again one of my big problems i have with this whole thing is never answer the never answered the original question up here why another programming language you know like why yet another one why doesn't rust do this enough for you russ plus plus but even harder with rules about yes even harder it's even harder or rust plus plus this is always my problem with these things is like even no matter how much backing and no much you know even if google that i mean it's the same reason why i have such a hard time with carbon when zig already existed right zig great great header support it has a lot of great stuff already really built in and i know carbon's like trying to it's more for c plus plus and all that but it's like you get everything you need from zig and it integrates really really straightforward so why yet another version i just don't get it i honestly don't get it i i don't get the purpose of of more and more like odin made sense because odin is a language designed for game programming it optimizes things that are hard in one language to be easy in this language right it's a language designed for a purpose and to me that makes like that actually makes sense designing a language for a purpose makes perfect sense to me that's why javascript is great for the front end it just is what it is it's really fault tolerant it it really allows you just to be kind of loosey-goosey because you know stuff just changes constantly and it's okay with moving targets and you know it just is what it is and to me that makes sense you know what i mean uh but zig doesn't have a direct compatibility with c plus plus oh it doesn't okay okay it only has direct compatibility with c hmm yeah uh but think about the linkedin post yeah val's uh purpose is distributed heterogeneous highly parallel compute with ease is it fast by definition val is compiled ahead of time uh to machine code that relies we just we just call that compiled uh on a type system to support in-place mutations and avoid unnecessary memory allocation val avoids hidden costs such as implicit copies and therefore avoids heavy dependence on optimizer for basic performance aside by default or safe by default valves foundation of mutable value semantics ensures that ordinary code is memory safe typesafe and data race free by explicit audible opt-in programmers can use unsafe constructs for performance where necessary and can build safe con constructs using unsafe ones okay so they're taking a different approach apparently than um then rust in this case okay val uh borrows heavily from swift which has demonstrated a user-friendly approach to generic programming and deep support for value semantics valves a programming model strengthens and extends this support while de-emphasizing reference semantics and avoiding complexity that results in from trying to make it statically safe uh eg memory reasons lifetime annotations etc okay interesting sounds great by why another language i'd say okay here we go what sets val apart in the current landscape is its focus on mutable value okay so they really love this termutable value semantics for uh for the purpose of writing a efficient generic code val has zero cost abstraction language that fully acknowledges the physical constraints of computer architecture yet presents a user model that marries these constraints with the benefits of value-oriented programming well the name is the primogen the name is i feel slightly embarrassed that i really truly didn't understand anything that was just said here