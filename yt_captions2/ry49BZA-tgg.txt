gnu parallel where have you been all of my life i i'm not gonna i'm not gonna lie to you about three years ago somebody some coding guy twitch.tv you may have heard of him he goes like this yo yo baby he actually doesn't talk like that at all uh he doesn't talk like that at all and he's probably a cia cia plant anyways uh anyways he told me why aren't you using gnu parallel and i was just like gnu parallel i just use xargs that's all i need and then it turns out no i do i do need parallel now i use it like every day of like literally every day of my life i love gnu parallel i love it it's the greatest thing in the universe it's the greatest thing i was recently trying to figure out how likely a bunch of end-to-end tests were uh were to be flaking then i wanted to gather some stats about their pass fail rates on my local machine before including them in the broader test suite these tests uh run for a long time and they execute extensive scenarios against live services over http in this post i'll share an approach i ended up using with good new parallel this is a great case for gnu parallel by the way this is so good you don't even know it you don't even know why it's so good it's so good it's so effing good i love it you love it we all love it okay uh quick aside if you want to follow along and run the upcoming examples in your own terminal use this command to generate some test files they'll emulate a flaky test by sleeping between 5 to 15 seconds then randomly exiting with the failure xcode 1 or success exocode zero now that's something i can do okay here we go parallel echo sleep print pass all right print fail exit one let's go potentially flaky test and i'm not really sure what this this is right here but okay this seems exciting i don't i i don't know what the syntax is what is this is this fish is this python is this new rust rust 2.0 what is this what the hell does that even mean but is this really something i don't even know about turbo fish it i think it's a turbo fish but it has too many turbos on it and so i don't know what it does new bash bash2 bash better bash me daddy what is it called run it refuse uh typically to gather flakiness stats i've used a couple of the nested loops one for each test i've wanted to run and another loop uh for each attempt i like doing uh this kind of stuff in bash for simplicity slash a portability tess classic array in bash my general rule of thumb is that if you see an array in bash you've programmed too much bash you've just you've done too much you've done too much this is this is how you know it's time to switch to a new language for test in tests at this at me daddy uh do for each attempt of that test a one through ten uh four attempt sequence one through ten capture the timestamp now test me pipe everything to devnal except for errors apparently keep the errors in pipe standard out to there what's the previous status that this is get the you know get the previous pro whatever previous executions exit code calculate duration duration of the test bam bam don't you love doing math and bash it's the all the dollar double print open do your math double parent close don't you just love it it just makes you want to just love it uh printf uh do all this one if status equals this then pass else fail is this why i always fail doing bash because i never remember when to use the dollar sign and when not to use the dollar sign i feel like you're supposed to use the dollar sign here why is there no dollar sign being used here i can't bash i cannot bash it is an impossible language it's why porque moria always use the dollar sign i thought it was always use the dollar sign people make fun of bash for the stupidest reasons really well again my general rule of thumbs don't once you hit here i feel like once you start seeing this you're you're starting to you're starting to get into that region where you should maybe go a little bit different uh this approach ended up being tediously slow though since the tests take a while to execute to running them sequentially wasn't going to cut it exactly don't do it this way parallel me daddy and then you don't even need this you don't you can use xargs or you can just use parallel itself you know what i mean uh this approach ended up being tediously slow though since the tests uh take a while to execute running them sequentially wasn't going to cut it i knew about gnu parallel but i've never used it before man parallel and 15 minutes later i was living life in the parallel lane it's really people you just dash j it hit him with the dash k call it a day it's like that simple sometimes you don't want dash k uh rewriting the above work in parallel ended up looking like this do your tests parallel progress jobs five delay two timeout 360. uh shuffle results uh out csv and then do all this bash one super turbo fish tess ultra turbo fish sequences i really don't know what this is i still don't quite know what this is my assumption of how to read this is that okay we're gonna execute bash with the argument from here which is going to be determined by this no no no no that's not it it has to be something different there's something different here i just don't know what it is my guess is it run okay i'm redoing it i'm redoing it we're gonna run test one through one through five right we're gonna have one through five going here and then we're gonna do that ten times and this is an inclusive sequence from zero including ten so 10 times that's what i'm thinking that's what i'm thinking right so this is all the values so 50 tests we're gonna run 50 tests and we're going to do this with a uh with all this beautiful stuff right here five separate jobs all that kind of stuff basharrays test files shuffle the order yeah uh gnu parallel specific no this is not parallel specific this must be a bash thing i don't know about the tripler i honestly have never seen the tripler in my life uh okay that just expands then huh okay i didn't know that but pretty cool there's some there's something that goes on there that i don't quite get i don't understand this this yet but anyways pretty neat i don't do a lot of uh i don't do a lot of that you know what i mean i'm not a big basher anyways uh the joy of finding the right tool for the job can't be beat more performance functionality with less code let's go into a bit of detail so here's a little story about how i use parallel i had this thing where i'd have to go query the database uh in the netflix game stuff uh get out a bunch of uh data from there and then in a separate database all together i then have to query more data and then in a separate database from that i'd have to query more data and to be able to query each one of those i need to be able to actually get the data here do some morphing query the next part do some morphing query the next part and then i'd be able to get i got some gen z hair going on yeah baby i'm finally a zoomer um and so parallel was fantastic because what i could do is i could get like a nice big query for the very first one that just dumps out rows of data and then i take each one of those standard outs in just one line at a time pipe it into the next one which then pipe it into the next one and so i could do the whole flow just raging it and i can say okay i can only have app max 10 connections to the database so jobs dash j10 right and just it just is so fantastic because then you don't write the parallelizing code yourself so many people write code in which they write the actual parallelizing themselves when you shouldn't do that just use parallel use gnu parallel it's so fantastic because then your program becomes really small and simple and it's just like one step at a time or you could just use javascript why would you ever use javascript to write your parallelization like this that's so stupid right it's already there you can use javascript to do your querying which i was forced to do because we had a library that connected to all the databases in there so i had to do that but nonetheless i use javascript for just writing the basic item and then i would parallel over the top of it i was joking no you weren't you wanted javascript you know you do it now you're caught in 4k on youtube trying to avoid that okay don't pause the music you sob imagine using go weight groups gross you know it that's it mario ben you know what i'm gonna say to you mario ben it's me a mario oh yes i'm going cancelable inside of a youtube video anyways parsing or passing inputs and gnu parallel you specify command that is able to execute in parallel in the example provided the co the command is bash one the one is a placeholder that gets replaced by each input value if you have more than one input you can use two three etc the inputs to the command are specified after the triple colon operator in this case the inputs are rlse are the array of tests there's an array of tests uh the sequence of numbers a zero uh one through ten these inputs are provided to the command in all possible combinations nice okay nice beautiful so in this case we have five test scripts that we want to run uh each ten times parallel all right controlling concurrency parallel provides a number of options to use to avoid uh resource contention here are a few that i found useful j get those jobs out parallel will execute as many jobs as you have cpu cores a delay ensures that each job waits for two seconds before starting preventing a thundering herd problem like it time out terminates any job that has been running for over an hour beautiful uh runs the jobs in a shuffled order again beautiful very very beautiful click that for b scale what about node closure i don't even know what you're talking about at this point okay we're trying to talk here is parallel written and go i would assume not it's old i'm pretty sure it's older than go uh and it's also gnu i'm sure it's just c baby i'm sure it's just a little c baby oh let's rewrite it and rust oh dang hey bisco i just clicked the little uh firmware thing just for you uh by default the output of your command will be printed to your terminal however in the case since i wanted to capture the stats using parallel's capability to output to csv files instead was very helpful results this uh yeah you can definitely do that i usually just you know i usually just do like a little little pipe well i do that sometimes i'll t along the way if i have multiple parallels i'm running uh i'll put the job completion results to the given file which includes duration exit codes and captured standard out uh standard error progress prints live progress as the jobs are executing the csv file ends up looking like this only the first lines of it for brevity what about all the area you're capturing right look at all that goodness look at all that goodness this is great uh it's trivial to use this uh uh output to aggregate charts uh chart or aggregate slash chart stats exploring further uh this barely scratching the surface will parallel can do i strongly recommend the excellent free and funny book by the parallels author ole tanki the first chapter takes about 15 minutes to get through and covers 80 of what you're likely going to use by the way this look at this look at what you can do limiting limiting this it's so good parallel is so damn good it is so damn good you gotta you gotta use it okay this has been a public service announcement okay this is not even a prime time react this is just me telling you learn to use the tools that are available okay learn it happy parallel outing read uh dude while primus reading start talking about javascript no i'm trying to tell you about gnu parallel and you're talking about javascript the name is the parallelogen