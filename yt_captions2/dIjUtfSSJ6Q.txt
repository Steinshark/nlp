all right so my name is threaten mikov and i helped create the hermes javascript engine at meta so i can tell that there are at least two three users of hermes in the audience uh can you make some noise so i can hear you i need the supports we explored the hermes engine at netflix for a little bit it's pretty exciting we went with v8 but i'm still curious what it would have been like going with hermes anyways for two people you guys are really loud i have to say anyway last time i was here i was really pleasantly surprised about the reaction to my talk after my talk a couple of people approached me to tell me that the talk was very technical but okay so let's hope we can live up to this standard once more i like it i want to start by telling you a little story this is the sad fable of john native in his slow cold by the way is anyone noticing the back the backdrop to this guy it's like he's in a rave concert going on behind him i feel like whatever's going on behind him i can't tell if it's this part of the screen down here or if they just have the craziest background of all time dj herpes i know it looks wild back there joe was sad because he hit he was having performance problems in his react native app the startup was very fast because we've all had performance problems but there was occasional ui stutter when scrolling very long lists when using complex animations oh and computing crypto hashes or mining a bit of bitcoin in pure javascript problems that we all have had obviously joe who was a very you know making jokes at conferences is really hard and i genuinely appreciate the attempt to get out there and to make it happen because you know what sometimes no matter how hard you make a joke people just aren't they're just not they're not joining in and it's a little bit emotional okay very passionate try it and tried doing a 50-hour coding marathon he swore he drank gallons of coffee he profiled he optimized his code he reloaded over and over but ultimately he was faced with the fundamental limit of interpreter performance he could not make his javascript any faster it was beyond his control deadly tired with the crash spirit but boiling anger to a joe was considering making his final move of total desperation trying to rewrite some of his code in c plus plus but then he wondered what if i could leverage type information to generate efficient native code ahead of time i would still be writing javascript i would be in control of performance not the here is interpreter which is actually great but let's i could optimize as much as i need could i do that joe wondered and the answer to that is yes yes you can joe you can do all of those things and more you realize like how much better things can get if you can just have type information like what you can do in a programming language is vastly different when you can just just have it in there as part of our cross-platform vision we really want to unleash js developers like joel and give them access to the unchecked power that native code has to offer optionally if joe really wanted he can even carefully perform unsafe operations potentially not only creating harmless web javascript crashes but also devastating native crashes just as c plus plus developers regularly do it's a good time look at him he's so happy he doesn't know what he's getting into but seriously he will mostly get tons of performance and on that highly optimistic note i am excited to introduce the next version of hermes which we have been working on for some time now code named static hermes some of you may have already heard some speculation about it very excited it was not meant to be a secret it was on github since day one but we didn't really want to talk about it because there was nothing to show well now finally there is something to show and we are eager to share it with you the main innovation of static hermes as you have guessed already is optional ahead of time compilation of javascript to native code this is just so cool like i i just this is just my favorite this is my favoritest thing right here right there do you see this thing that just goes on right here this top line is so good like a met like think about think about like cold start times in no they they're they're slow especially when you're running on a single thread right a lot of these a lot of you know a lot of these serverless things it's not like they're giving them maximum resources you're getting a shared resource and whenever you start up node right like even if you just do the most world's most basic thing if you just do a node uh a trace gc uh e-console log uh hello right oh i didn't get anything oh that's nice uh but if you import anything right i mean we're talking about like barely import anything you will just you'll cause so many trace gcs i thought you'd get a trace do you see this is a little disappointing you didn't get a trace gc for this one but you'll gc multiple times and on these like single core little running ephemeral processes it's a stop the world gc right it is a stop the world gc and it completely destroys stuff and so i know it's very anticlimactic you know and so like you could you could imagine how much you could potentially do by having your stuff compiled and more tight and being able to just have finer control over what's going on i would love to see more of that i know gc isn't gc is going to be present in either of these but it could be a vastly different type of performance and what goes on um i love it it brings us close to our goal of combining the predictability and high performance of c with javascript usability and no that's why that's the last slide said natively compiled js is completely safe by default exactly as interpreted js so there will not be native crashes for job oh well that's cool to be clear native compilation is not for your entire app even though that is possible you need to decide which parts of your code need to be optimized to the max and only they get compiled to native ahead of time the rest continues to use hermes bytecode and if you want to learn hermes by code i recommend a great talk by radic react native field 2023 you will find it on youtube in a couple of weeks now the really big change here is that in order to i wonder how true this is c performance with jsu's ability like what what exactly are they saying i i don't know i i would love to see some sort of like channel i know strong sauce i know whenever i see someone say c like your biggest dead giveaway that people are saying something stupid is when they say it's faster than c then the next one is when they say it's a dynamic language that's as fast as c or it's a bytecode language that's as fast as c you're just like well you know what you're saying is largely offensive i don't believe you i'm not going to believe you sorry fully exploit native performance static hermes relies on sound types now even if you don't know what sound types are what's a little after remember these words and we'll really delve into that a little bit deeper in a few slides i see someone say e e equals m m c squared so it didn't didn't someone tweet just recently e equals m c squared plus a i as if it was some sort of revolutionary thing you think twitch chat is dumb okay i just want you to remember this if you think twitch chat is dumb go on twitter whole new world out there okay whole new whole new world out there this point i want to make a big disclaimer uh we are seeing encouraging results from static hermes but it is still very much a work in progress okay it's not ready right now it is not suitable for anyone besides the most extreme hackers in enthusiasts like radic it is still not easy to use and many things are broken if you tried it which you can because it is on github you might get disappointed okay but rest assured we are working on it and it is getting better all the time some of the hermes team is here with me in black native for you and they are submitting this as we speak so it is improving at this very second with all that said we really wanted to share it early with the rack native community and to get your feedback we also want to thank our partner in this amazon by the way how how different is react native from react who here programs in both anybody anybody honestly pretty different very different me pretty different okay i only use preact oh okay tough guy 50 similar i mean i'm like 97 similar to an ape so 50 similar means nothing to me okay i don't even know what that means i don't i don't even know what that's supposed to mean at this point 22 better because internally we added flow support did i just hold on did i just typescript support to static armies we also want to thank our partner in this amazon typescript support to study hermes because internally we added flow support amazon users react native in many of its apps and it has been supporting us in going like native over the past few years okay so this is a brief overview of the topics that we'll cover in this presentation yeah amazon doing non-evil things okay it's it's weird i i okay w on the board for amazon flow yep vomit i've never actually used flow i am curious about flow you know what i mean i've never used flow why would anyone use flow has anyone used flow flow's good flow's great one w a thousand l's flow is better flow has sound types oh interesting flow has sound types how does it do that does it have some sort of runtime component is that what it does because like how do you have a sound type it has speakers oh you're you're a funny guy huh you're a funny guy aren't you okay forget you guys but i will try to fit everything in the remaining yeah sound types what are those and how does it have it so first we'll start with explaining why it is difficult to compile javascript to native then we'll explain what sound typing is and we'll look into an example of actual native compilation so you can get a few shut up finally we'll talk about something that became possible with static hermes and that is zero cost ffi first we'll look at an example which reads an sqlite database entirely in javascript without c plus plus or c this hermes have does hermes have his hand run time hermes like node yes yes no sounds like it yes no why do i keep asking you guys things why do i keep asking you guys things okay what what is my problem wow somehow this became less helpful i'll just have to go places a little bit more detailed example of one simple native code which is get them 50 likely first let's stage let's set the stage a little bit here why do we need static hermes isn't regular hermes good enough well as an interpreter hermes is pretty good and we actually do have plans to make it about twice faster which is a topic for a whole another talk but ultimately that's a lot faster there is only so much performance that you can get from an interpreter and that isn't always enough one way for people to exceed that level of performance is to write extensions in c plus just as poor joe was going to yeah that's how it can be quite difficult to write and to maintain so instead we want to take advantage of react native developers familiarity with typed javascript and compile type javascript to native ahead of time i know i'm repeating myself a little bit you know this is about compilation to native a valid question to ask here is what makes compiling gs to native so difficult in the first place well the answer is easy to see in the example like this one yeah we have a function it takes two parameters but we don't know their types so all possible types string array number regular expression whatever and combinations between them need to be supported the result is that if you wanted to compile this to native you either would get a binary explosion you effectively get free generics you get a generic you get you get a generic of t and uh v and u and you get both of them and then they just explode to every type that'd be fun huh that'd be kind of nice all type combinations or you would just get interpreted like performance which defeats the purpose of native combination compilation uh there are interesting solutions in the academia that i would like to acknowledge specifically the excellent hope c compiler by manuel serrano but unfortunately it doesn't really meet our needs since it compiles every function twice and relies on heuristics so performance is not guaranteed and predictable we are not rolling it out though for the future okay then we already said that we want to use type annotations can they help unfortunately not by themselves because type annotations in typescript and flow are unsound the typescript community right now are in shambles they're completely in shambles right now it's not it's type safe just shambled right now you shook there's that word again sound and sound what does it mean unsound means that these type of notations cannot guarantee that the actual types at runtime are correct but they are what we say here how so you might ask well here's a very simple example we have this function annotated with number we imagine doing all this annotation just to not actually have types always with two array elements unfortunately these array elements are out of range so instead of calling the function with number and number we're calling it with two values of undefined so as you can see we have vulcan the type checkers it is true typescript has only ever talked about a code organization has nothing to do with actual types it's it's supposed to be that it gives you the feeling of doing the right thing and likely cures most your bugs uh and and as i'm sure you know there are many similar ways to break the type checkers and this is not a bug in typescript or flow uh it is just that given javascript semantics this problem cannot be solved statically at compile time correct it is a very difficult problem here is how static hermes addresses this problem in this specific example on the left we have regular hermes executing this code oh nice you get actually like hard as we can hardly recall undefined on the right we have static hermes now rather than call the function with undefined it throws a range exception when we try to answer the not in range dude welcome to java one point oh there you go all you script kitties have you ever heard of rangers they're a lot of fun they're a lot of fun okay modifies some javascript semantics in order to enable efficient sound typing at runtime in other words at runtime the types of values are guaranteed to match the type annotations which in turn allows us to compile that source very efficiently the new semantics are opt-in on a granular level and you can use them only where you need them plus the new code can coexist in interop and finally as i mentioned both typescript and flow are supported this is super curious to me because i mean you still can cheat at some point in typescript to convert an object to a number and then how does this all like i i wonder what all the errors are and what is that are we breaking javascript we can't arbitrarily change how the language works can we well consider this we are simply enforcing the behavior that the user declared they wanted when they hold the type of notation when they wrote that x is of type number they certainly did not intend for x to occasionally be of type undefined that wouldn't make sense so technically the program we had there was incorrect we just called the bug at runtime instead of silently ignoring it so we are strengthening the typescript in flow type systems i wonder if the static generation all this allows for something like uh number or undefined and allows for like that more uh like still loosey-goosey feeling of javascript while having still like this increased performance of pre-compilation i'm very curious about that because that would be you know that would be dynamite right that would be a genuinely dynamite item yeah a nullable effectively you'd get a nullable uh it would be pretty cool uh so so if you use hermes and you use protobufs instead of uh instead of json you correctly organize oh my goodness all of your code into modules hierarchy and you don't spam but none of this [ __ ] functions all over the place and then you can do basic modern programming in js yes you've now officially caught up again 1995 was a hell of a year it was a hell of a year for programming java came out javascript came out they announced together null was included in javascript because it needed to interrupt with java i mean it was a good it was a good year it was a genuinely good year super information highway we don't necessarily view that is breaking javascript but regardless of these philosophical arguments it is all opt-in so if you don't like it you don't have to use it but if you do use it it will make your code both faster and more correct so we we would like you to use it i like this idea we have talked a lot about this in theory now so it's time to finally look at concrete examples by the way this is the most confusing meme still to my lifetime i genuinely have no idea how to interpret this meme it's just like you put the most confusing image of all time and you just put words on top of it and somehow it makes me chuckle i don't even get it it's darth vader caring about his water quality obviously i know but it doesn't make any i don't i i'm still i still struggle i didn't understand what compilation to native means for performance and what it looks like it's ironic for example we have chosen is some of you may be familiar with it it's a part of a well-known computer language benchmarks game okay it is a math heavy benchmark do you think it's like the three body problem famous novel by the way by the way citing that i read hey just so you know i read i i read not a big deal with many property accesses when we started compiling it wow it was the same performance as hermes and that is 550 milliseconds but now as you can see hell of a difference it is 10 times faster when compiled natively so that is that is not pretty shabby plus we're certain that there is more headroom we can probably get to 20 times faster than harvest 20 times [applause] something like v8 as well in this comparison just so you can see um like another engine so you have something to compare to because it's hermes against itself meaning that it just got a lot faster has it caught up to standard javascript expectation speed or has it exceeded javascript expectation speed i would have loved to see something outside of just hermione comparison you know just toss it no toss it and bun somewhere else just so you can understand what you're looking at you know [music] [applause] okay so we have this very nice performance improvement but what does the compiled code look like let's examine this loop from inbody.js how did it be the three body problem series is coming to coming in january 2024 to netflix by the way oh gosh they have another opportunity to ruin a really great book damn you come so fast well this is how before starting hermes deal with dozens of instructions executed for every line of this loop by the interpreter with static hermes it is much better and by the way i'm really happy to bring some low level assembler to this javascript conference in the next slide let's put the native interact native here we are if you don't know r64 assembler don't worry i think you'll still get the idea the first thing to see is how if you assemble instructions we have for the first two lines of the loop we have six instructions and most importantly most of these instructions are very cheap the entire calculation the two multiplications in the two apps what's an f my life advanced mode on two dimensions is this some sort of sim deez nuts type operation going on here what's this f my life going on right here it's divorce papers it looks like it's doing two operations at once multiply and add floating multiply lastly add that all performed in parallel by a single instruction which is marked with a divorce which is really impressive and trust me this is very fast and it is quite exciting for compiler developers this is the rest of the loop again very few instructions well why is that one so again you don't need to understand the details of this but you can see how small the output is and rest assured this is indeed very fast it is achieving performance close to c much faster than hermes i'd love it i'd love to see again saying those phrases i really wish they could have just tossed tossed a quick into god bolt and done a quick little look-see and see like what what does that look like what is the equivalent 03 awesome you know compiler version of this and and look at that even done with it it will become even faster but it'd be interesting when we hopefully would have shipped this now a little a few more benchmarks we can see the results of other benchmarks that we have created they are in the static hermes repository they are not as impressive but it's still not bad one of them is like five times faster and we again we are still working on making them better i mean this is all good i love the performance increase next thing i want to talk about is zero cost ffi which i suspect might be even more exciting for some of you come on zig um very serious slide i don't know i shouldn't have used chat gpt for this presentation let's keep moving so early on when we started implementing sound typing we got an unexpected benefit we realized that sound types unlock the possibility of very efficient native platform integration yes we can call native platform functions with practically no cost just as if we were a c program this enables us if we wanted to implement platform integrations entirely in javascript without the need for resorting to c plus at all that is incredible and the reason i can foresee some of the the reasons why that is so dang incredible because especially with the moving target like a phone where the platform does make changes from time to time what does ffi stand for fast fourier intercourse um with the platform moving like various things change on the platform pretty regularly and so being able to have a bridge methods written in javascript means that you can do like javascript operations and actually have like a platform normalization layer and it effectively gets to run at almost native speed like that that that's super cool that's like super super cool so what problem are we really solving here first 20 billion dollars sweating amount of code in order to implement and wrap a single call to a native platform api furthermore those wrappers which use jsi can become expensive when they're invoked very frequently we can give javascript developers another option the zero cost ffi information is literally that zero cost it performs no conversions no allocations no interactions it is exactly as cheap as performing a regular library code in c plus we have measured that the call overhead is between 15 and 80 times not percent 80 times lower than jsi native function wow that's that's pretty dang good even i mean i know it's all self-referential speed up points that they keep doing right they're only referring to hermes as what they've actually made faster but nonetheless i mean making stuff faster within your own platform by huge leaps and bounds like that's really good like that's genuinely an awesome thing especially native calls like that where you can really get deep on it i like it however we have to be careful as we all know native functions can be unsafe and dangerous we have made it very cheap to call them but that doesn't mean that they should be called irresponsibly to ensure that we have introduced a distinction between safe and unsafe code this is very similar to another very popular system software language i'll let you guess which one it is unsafe code sections trust that the developer knows what they are doing hopefully joe knows we'll see and interacting with whoopsies i just accidentally i tried the plus i just i just messed that up he's talking about rust okay the rust mentioned let's go patience on the other hand disallow unsafe operations so you cannot accidentally call a native function from there so you have to be very really deliberate when interacting i skipped something i'm not sure what happened here you cannot deal with it just deal with it by the way squeal light is still so good for those that don't know why squeal light is so good i just want to let you know something you can take squealite and you can point it to a file and it works i want you just to take a second and think about how many cool integration tests you could have written by simply having golden database files and you just write the database file once save it as the file and then that's the thing you test against now you can actually like just test and have actual database like working and the database is perfectly set up and all you have to do is just like cp that file into a directory run it call it good you're like yeah that's exactly the thing we wanted to to work i know actual data like actual data squeal light is really cool if i i wanted to give you a taste of what is possible you can do ram only first example ramrod me uh but the problem about ram only is i i don't know how this i don't know how the environment's set up first so that's why i just like the file thing right you can really do some cool stuff foreign first as you can see we need to declare some native apis these are the apis exported by sqlite now i did not write this by hand it was generated by our tool which takes a c header and generates javascript bindings that we can use and this is the javascript source that opens the database queries it oh gosh guys i know there's a lot of javascript engineers in here um this this is raw docking squeal okay squail form a boy i know this is this this is very hard to see there's not even an orm or at least a squeal builder okay i get it i get that this is really hard to look at and you probably feel very scared okay you're probably you're literally going to prisma chat and chatting with a live representative right now just to feel better about yourself i i understand but trust me it's okay we can do this it's just it's just it's just an example okay it's okay where's my [ __ ] ose brings the result and this is it this is the entire source there's no c plus plus this is it runs sqlite and it actually does work i was actually planning to do this in a live demo but i got discouraged after i saw what microsoft did yesterday i couldn't compare with that so here's a screenshot that's pretty funny you can see you can see this is invoking static hermits to compile the demo on the mac os imagine big whatever what whatever whatever microsoft did ruined the guy this is such a good presentation i would love to see whatever this is yeah i'm just showing you the output it is a true wait is the thing called shermis what the hell sure means is shermis the compiler is sure me is to compile for hermes please tell me that's real macro is binary and we're running it okay i don't know how i didn't see that so as you can see you could even use static hermes if you wanted to to hide native applications for mac os or linux or windows oh my goodness but although we do not recommend it but i find it amusing that it is possible javascript devs don't even raw dog javascript imagine looking at squeal yeah i can imagine that okay this second example will be a little bit more boring but i hope it will allow you to understand a little bit more what is going on here we have deliberately chosen a very simple native api for demonstration purposes it is the c get end function average an environment variable by name uh think process.n in node.js again observe that this is all javascript there is no c plus plus jsi or anything like that here and we're not going to spend a lot of time on this but let's quickly go over what is happening first this is the external declaration that we're going to call this is telling static hermes of the c function that we want to call we're converting the name of the variable that we want to take from a javascript string to a c string okay here we are calling the native function okay then we're converting the result to a javascript string what's that 2048 is 2048 like the max value are we just did he just did he literally just go over a quick 2 to the 11. just just allowing a 2 to the 11 hang out like that buff size i know but that's what i mean you can't just you can't just gloss over the fact that you're i don't know how i feel about people playing with buffers and thinking about stir end copy in javascript okay it makes me feel a little nervous all of a sudden freeing the temporary buffer that we needed then you got to free it i know this is a simple very logical although you should only do this in libraries you should not do this in product code obviously and here i would like us to examine a little bit external variable uh the external function call and i promise you this is actually the end there's not a lot more first we have a place where we can put options things like calling convention platform depend on things it is an object open-ended where we can use it to add functionality this is where we specify the name of the native function we're importing we describe the types of its parameters like you can just say c point describe the return type that's nice and this is just a throwaway body that we need to populate in order to make the types i want to know microsoft did i know i do too since this is an external function but it's still passing to the to typescript and flow we just throw a dummy exception so that it doesn't complain that we're not returning a result so yeah this is it for questions or suggestions i'm highly encouraging you to use the discussions tab i really want to play around with this i really want to play out and play around with some shermis right i think shermis is really exciting i love this idea like i said i i've been super excited about all of this um i i really do think that this is the much more interesting version right of of a run time than anything else i think i feel like this is the first real iteration in javascript in any sort of way in app just in years upon years obviously v8's like this slow iteration where they said hey we could make a better engine hey we're gonna add in jit jit was really important and then really some of their different uh garbage collection stuff really made a big a big difference but this i think is like the next big step which is like well we have to kind of get out of this interpreted world if you actually want to see it move fast now you're actually starting to get into speeds that are probably a lot a lot a lot better and so this to me is just extremely exciting love the idea awesome presentation shermis for everybody did bun just get toasted i don't know but the name