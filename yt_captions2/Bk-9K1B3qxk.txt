didn't i just watch this an option type yeah i i feel like i've seen this i mean the pro so a huge problem with a lot of this stuff is that first first off don't use underscores underscores are grody okay don't use underscores don't use underscores underscores are stupid um but the thing i don't like about it in typescript i want to like it it's that you cannot add implementations yeah it's a non-zero cost abstraction right it's not it's you can't add implementation functions to it you can add methods and so i am curious do this i've been using rust and to me this sounds a lot like when people use booleans to represent two states yeah yeah yeah just to make it some type i know exactly i i do like that uh let's let's look at this i'm actually curious about this let's find out what this guy has to say there's a really neat construct of the language that i want to talk about today but we're not going to do it in rust we're going to pour it to typescript i'm talking about the option enum the idea behind the option enum is that it's a wrapper for a value that may or may not exist no surprise that we're going to model this in typescript as a union and the union is going to be a union of none and some and this is the terminology that russ uses i should say too that this is not unique to rust there are a lot of languages that do something like this so the idea here is we're going to have this underscore type field to distinguish between the none and the sum and the main difference here is that if we have a sum it has a particular value and when you have an option of t you could have nothing or you could have something and so this can be really useful in cases where you may have a value or it might be undefined or this function could return something or maybe it throws an error or this is a promise that what can we just agree that no no underscores probably the best the best score a great thing called promises uh if you're gonna do a video about options and you don't say monad i dislike no excuse yeah really returns a value or it might reject and this option type can give you a unifying interface to interact with those different scenarios i just mentioned and we can create some helper values here for creating option objects there's not really a need to construct new none values because it's just a hard-coded value so this is the menu that we can use we have our non-constant here and it just is the object you would expect some on the other hand is a function that takes an argument and the return type is a sum of t and we just return a new object that has our tag here sum and then the value by the way using arrow functions all the time just feels like such a try hard move like this syntax sucks can we agree that returning an object from an arrow function it just sucks it just looks stupid it's it it's it's it's it's just it just feels like a strong try hard on this thing i'm a fan of arrow functions i like arrow functions too but using them as top level functions is not the same right private type amen i mean the thing is is that there's a difference between this like you're not really saving anything dude get triple x arrow folks you're not actually saving anything doing this right you're not you're most certainly aren't saving anything at all and look at this you're even defining a return type on here you're i mean you're defining the whole thing like this is fantastic like just just write a function it just makes it easier right but not uh jokingly functions and yeah uh uh function syntax i use for top level functions for functions i pass around i think arrow functions are fine right that's kind of where i've got where i've gotten into uh writing function takes two less characters right for me it's just all about clarity right the fact i see const sum it's creating a variable but now we're creating it as a function like there's just like maybe just created as a top level function be clear with what you're trying to do you know what i mean just be as clear as possible so now we have some easy ways to reference a nun and to create a sum now once you have a wrapper type i also understand that you can't that this is a dead fight i understand it's a dead fight people this is just what's happening um it's gonna it's gonna happen forever forever ever you know what i mean uh if you're trying to be as clear as possible you'd rewrite it in rust this is very very true solution linter formatter that dominates everybody i saw a video that said creating functions like that and normal functions are functionally different they are functionally different uh these wrapper functions actually lexically bind to this whereas regular functions don't so passing in an arrow function and you're referring to this gives you the ability to refer to this whereas if you passion a function that's an anonymous function you can't actually bind to this you bind to the global scope of this like they are non-functionally equivalent like this or an envelope if you will that we can put a value inside of it's kind of two things you want to be able to do right the first one of course is we need to be able to create these and the second thing of course is that we need to be able to consume them let's create a couple i do want to take a step back here for a quick second having keyboard sounds 100 iq okay it proves he's really typing okay of functions that make it easy to create or put values into an option and also to consume more pull those values out of the option so i mentioned earlier a couple of scenarios where you might have a value or you might not and one of those is if you have some function that throws an error wouldn't it be great if instead of throwing an error we could just get back a none instead sometimes we don't really care about that error we just want to know did i get my value back or not so to do that let's create a function here called optional catch now this optional catch takes a function that returns some type t optional cat will return you an option of t and then of course in here we just have a try cache and we call the function that gets passed in and if that function returns the value of type t as we would expect then we can create a sum and return that if instead it throws an error we'll just catch that error and we'll return none instead so for example here we could create a function called greet and it's really simple to have this return hello name but maybe let's say we don't want to greet anyone named andrew so we could say if name equals andrew then inside andrew we'll throw an error and so we either get our greeting or we don't so what we can do now is create a variable here and we'll call this maybe green optional catch let's just say greet andrew and so if we look at the type of maybe greeting here we can see that it is an option of string which means there might be a string in here and we'll look at how we can get that value out a bit later when we look at our consumes but for now we successfully handle the error and we captured our value now another common scenario for possibly getting a value back is when you're hold on my beautiful wife's calling me okay when she calls me i i gotta answer hello she hung up on me i'm over here answering phone calls being a it's 1.5 x speed i'm not watching things i'm a programmer hey what's up great all right here we go and promises so maybe we want to have an optional resolve a function as well so we can wrap a promise result in an option so this is our optional resolve here it takes some promise of type t and it returns a promise of option of t now that might feel like we're going the opposite direction because we now have more rappers on our t value but because we're taking a promise and you have to await it there's no way we can return anything but a promise from this function the nice thing foreign besides for a basic designs decision i see where he's going with this one we haven't watched ct ct oh wait what hold on just stopping though is that when we have something like our optional result here we can know that when p might reject promise of option of t is never going to reject in the case of our catch here we don't reject it said we'll just resolve with a nun instead and so our code execution will continue until we actually need to inspect this value but we don't get interrupted by an error i've written this in a way that's pretty similar to what we did up here with our optional catch unfortunately because of the way so something that's i think kind of interesting about at least the sum call this sum call right here will effectively never be optimized inside of the javascript engine because t value changes so that's one kind of interesting thing is you kind of destroy your monomorphism or whatever they call it uh which means you could get optimized de-optimized some semi-regularly kind of an interesting thing having these type of functions around promises work there's not really a way for us to combine these i guess you could also choose to write this with then and catch instead so we could do something like return p dot then and get a value out of p and then so we can return some of the otherwise if we catch we can just return none so this is kind of a little bit more succinct you can see that this also matches our types sorry i don't have enough money for a tooth never say that never say you're sorry i appreciate your support wholeheartedly uh just curious did the combo with theo yesterday make you feel a tad uncomfy feels like disagreeing with the friends can be tough uh i don't feel i i don't feel i i don't feel uncomfortable about it um i think that me and theo will probably never see eye to eye on this one um i can't make any guesses as to how we have arrived to two different conclusions uh but we just have arrived to two different collusion conclusions i don't know i don't know this is maybe a little bit easier to read depending on the type of code you like to write what we can do to actually give this a quick test is we can say maybe count optional resolve and we can have promise.resolve of 34 in there if we hover over maybe count we can see that we get a promise of option of number back now the other thing we could do here is more likely we would be doing this inside of some kind of async function like this and i would probably have on a weight on here and this and now is going to be an option of number and so the await of course unwraps that promise for us now handling an error that's thrown or a promise that's been rejected are two common cases but so one thing i say that's kind of interesting about this is that at least so far he hasn't talked about this but value lifting and typescript is not as good um because you don't yeah you just don't have a lift operation right you don't have match or pattern matching and so i feel like this is kind of difficulty you know what i mean i mean like i feel like wrapping these it's the the one reason why i haven't really ever liked this idea of being available in javascript because there isn't the mechanisms to work with it nicely uh you don't have like a nice concept around it uh pattern it feels like pattern matching is extremely needed for this but i don't know maybe i'm wrong maybe i'm wrong here you could also imagine wanting to create optionals around your own specific business logic and for that we can create what i'm going to call too optional this is a function that returns one of these option creating functions so the way this works is two optional has two generic arguments here ino for input and output right and these are the types that we expect to receive and the type that we expect to put into the option now the way this works is that we expect the output to be a subset of the input and we can encode that by saying oh extends i if you're not sure what i mean here think about the scenario where maybe you have a value that could be null or undefined or a string and you want an option of string i hate that example already i don't want null or undefined or a string maybe you have something that could be a negative or a positive number and you want it to be an option of a positive number in this case i might be all numbers and o might be only positive numbers and so to determine that narrowing we take some function here that takes an i and returns a boolean and if that is true then we are saying here that i is o so that means our our value here i is of type o and so then this returns a function that takes an argument of type i and returns an option of type o and we could write this in a single line as you can see here i've got commented out we can just say if function of argument true then we have some otherwise we have none however why not include some try catch i guess actually one way that we could make this a little bit smaller is i could put this in here in my try catch may as well offer some free error handling while you're at it but of course that's up to you now let's create an example error handling is not free simple usage of this and let's go with one of those use cases i mentioned earlier where we want to filter out null or undefined values so let's create something here we're going to call optional defined and we need to call to optional and we know that we need to pass it some kind of function here we want this to work for kind of any type like you know string or undefined number undefined that type of thing so we're going to need some generic t here this is going to take an argument that is t or undefined or no and then this function can return if r is not equal to null now notice that this isn't type checking just yet and for better for worst typescript needs us to include the return type here we're going to say arg is t and so basically what this means if arg is not null are undefined then arg is of type t one case where i know we get undefined or null is when you pop something out of an array so for example let's create a quick array here with a couple of numbers in it and we can grab a value out of that right if we do array.pop now if i hover over b you can see that it's either a number or undefined which makes sense because when you pop your we don't really know how many values are left in the array if we wrap this in optional to find then what we should get back instead is an option of number okay so we've looked at a couple of ways that we can create these welcome to costco i love you hey i love you too msp at ms mps um you know again i like i mean i get where he's coming from with this which is trying to figure out why are just trying to include options right because options are a superior version of undefined slash null i think most people can be on that side of the table meaning that uh it seems to make a lot of money a wall tanker thank you very much i appreciate that let's go nine months on twitch prime's hard and so like i totally feel that but it's just like i don't think i'd want this in my code base you know what i mean i don't think i'd want this to be around in my code base i don't think i'd want to include a library using these kind of things uh first off one thing i just don't like which we can't see right here is just there's a lot of error catching and options aren't necessarily meant to capture an error do you know what i mean they're not meant to capture an error they're meant to describe if something does not exist or does exist and so you know like this whole thing that's going on is is a little bit uh you know like maybe it's just his example but it feels it feels goofy you know what i mean like i wouldn't want this because i feel like it at least this specific implementation would just like hide everything right he's a yeah he's he has conflating exceptions and undefined in this example yeah and so it just feels dangerous you know what i mean i want i don't think i want optionals right now in typescript until there's a mechanism to work with them well like you can have types but you cannot you cannot attach uh implementations and i hate that right so there's not really like doing this really high programmatic types meaning you have like this type hierarchy that you build and then you have to also build the same type hierarchy but you have to use it and build it in code so it's like you get no advantage of using all these types uh yeah it just seems seems frustrating um you know rust has its own problems i i most certainly don't think that um you can extend through interface but that's i mean that's so dangerous right that's like typescript's worst features one of them extends through interface to any right um extend through interfaces they're so dangerous it's just so dangerous it really is is the fact that if you don't even realize it right like hey thank you uh jay galt i appreciate that uh if i'm not mistaken i think this should just work uh let's just find out really quickly so there is actually something called a node right this is an interface that's available right here right and so if i'm not mistaken i believe let's just see if this one works let's see if i can do this one interface uh node uh bar baz is a number right and so now what i have just done is that this is something that is totally used by something else right something like this uh ts ignore um oopsies we're gonna oh my goodness uh do that and go let uh foo up wrong language cons this thing equals node get node right this function doesn't exist whatever we're just going to say it exists and it returns type that is that now i have bar bats right like i didn't mean to accidentally add a definition to something that already exists i just tried to create my own node interface and so like i kind of i just hate that right it just feels super dangerous you know what i mean it just feels like that's just like a surefire way to actually end up trying to debug a problem for a long time you know what i mean yeah well the problem with it is that you can't it's it's not adding implementation details it's adding it's like mutating definition details right it's just it's it seems super scary the cool thing about option is and then yeah yeah map is neat i don't use it very often uh thank you it's biz just because i don't really need like i've never ran into a case where it's been super useful for me uh anything basically only good for methods that accept it and do something like two string the most other uses are very dumb i don't know what we're talking about i literally run into this problem you described and ended up debugging for three hours yeah it's extremely hard that's the thing it's extremely extremely hard if this if this is the faster than lime one i'm not gonna watch it thank you for including the rust stuff um it's uh let's see my linter has stopped me from doing that yeah okay dude that's cool stuff uh i don't think i want to watch any more of this do you wanna let's look a little bit uh is a monadic bind over an option type when you speak like this i want you to know that you be it it prolongs your stay as a tarnished a maidenless tarnished longer okay just so you know careful i'm trying to help you you know move on with your quest in life you know it's very it's very scary you know very scary i missed that i missed that blueberry i missed it again i missed it again i've caught it four times without taking my eye off i missed that last one