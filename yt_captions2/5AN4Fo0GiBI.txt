you can learn mips assembly in 15 minutes i know it sounds crazy but stick with me and by the end of this video you'll be able to write a hello world program in mips assembly from scratch on your own to learn mips assembly we'll have to learn about three things first the registers on the mips processor second the instruction format of the mips instruction set and then three the syscall interface that the processor uses to talk to the linux kernel okay so to learn about assembly we need to know what registers are so registers are these hyper fast internal hardware hardware-based storage inside of the processor that are used to contain values that are either data or memory addresses so the ones we care about in this video are going to be the zero register which in mips is always the value zero the v0 and v1 registers which are the return value of a sub procedure and then a0 through a3 which are the arguments that we use to call sub procedures the rest so t 0 through t 9 and s 0 through s 7 are important but for the sake of this video we don't need to know about them for this video care about v0 and v1 a0 through a3 okay so when we're writing assembly we have to write instructions the instructions come typically in the format of operand destination register source register so in this case we have four instructions laid out the instructions come in two formats we have either a load instruction or a store instruction a load instruction is where we want to take data out of memory and put it into a register and then the store instructions we want to take memory that is in a register and store it into memory again registers are inside the processor they are hardware based and then memory is stuff like ram and other memory regions like that so the first example li dest immediate that's going to load the immediate or an integer into the destination register la desk symbol that's going to load the address of symbol into the destination register lw dest offset source what that's going to do is it's going to take the source register it's going to offset it by some immediate so it could be zero four eight it's going to load the value at that address into the destination register so again the three of those instructions are loading from memory into a register the last one is store word so that's going to take the value in the register reg and it's going to store it at the address stored in the destination register offset by some offset a little confusing i know but we'll talk about it in an example right now okay so here's an example program li t1 ox1337 what this is going to do is it's going to take the value 1337 and put it into t1 now lat0 my adder what that's going to do is it's going to load the address of my adder into t0 and then finally swt10t0 that's going to store the value in t1 at the address stored in t0 so at the end of this we will have the number 1337 stored in my adder pretty straightforward so if we are only able to move data from register to register from memory to registers who cares how do we make the processor actually do something we want to we want to read data from users we want to print things to the screen how do we do that the way we do that in assembly is what's called a syscall to execute a syscall we literally run the instruction syscall and what this does is it is an instruction that alerts the kernel hey we want to take an action we want to do something and the way that we talk to the kernel is through these registers we talked about the beginning v0 is the number that tells the kernel what action do we want to take in this register we put the cis call number we want to invoke a0 through a3 are the parameters of the action we want to take so for writing a string to the screen we'll put the pointer to the string in a zero if we want to read from the user in a1 we may put the number of bytes so let's dive in to our development environment and we're going to write some assembly to print hello world to the screen and then exit the process cleanly let's do that right now okay so here i have my development environment all pulled up the way that this is going to work is i'm going to be doing console commands on the left and i'll be typing assembly on the right what we want to do first is make sure that we have this installed so you're going to run sudo apt-install or yum install if you're on centos gcc mips linux new what this is going to do is it's going to install the build chain for linux for mips related stuff then you're also going to do sudo apt-install kimu so my virtual machine that i'm programming in is an x86 virtual machine but we're going to be writing mips code how do i get the mips code to run on x86 we need to run that code in an emulator and key mu is an emulator that can run mips instructions on an x86 platform so i already have both of those but you go ahead and pause the video also like the video and then come on back when you have those things installed okay once you have them installed we're gonna start writing some code so when you're writing assembly you have two set they're called segments of memory text and data the text segment is a segment that contains readable and executable data better known as instructions because we execute them and then data is a segment that contains readable and writable data but not executable so in the text section go our instructions and then in the data section go our data so if we're going to print a string for example the string goes here also to get set up we have to do a few more housekeeping things we need to expose a symbol called start so when gcc will get invoked it will look for the start symbol to know where it needs to run first if we don't make this a global and if we don't declare it it'll say i was unable to find start so i can't compile your program for you too bad so sad okay awesome so now we're going to start writing some instructions to invoke the syscall remember how i said that v0 is a register that contains the syscall number you're probably asking well how do i know what the syscall number is how do i know what registers to use for what parameters etc so what we're actually going to do is reference what's called a syscall table and i'll zoom in for those of you that are on mobile here so this is a syscall table you can google it and type in google mips linux syscall table or you can go to the url here i'll put it in the description box what we have here is the syscall table for linux so if we want to run the exit syscall for linux we will use this syscall number in v0 a0 will be the error code if we want to write a string to the screen we are going to use syscall 4004 we're going to put the file descriptor to write 2 into parameter 1 so a0 we're going to put the string to right into a1 and the number of bytes to write into a3 right or a2 rather so we can start with the exit syscall so v0 is going to get 4001 and how do we load an immediate into v zero we use the load immediate instruction so into v zero goes four thousand and one and then we wanna make sure we return a sane exit number right so load immediate into a zero right so that's argument 0 or the first parameter to be spent to be sent and then that goes into a0 and we return the error codes i want to return the error code 13 just to test and then now that we have these registers set up to invoke a syscall we type syscall and in theory if this works correctly this should just exit the program and return the process return code of 13. so now how do we compile this stuff we have to do it in a two-stage process so first we're going to assemble so we type limit mips linux new as for the assembler we're going to pass in hello.s as my file and we're going to output hello.o and it's just warning me that i didn't put a new line at the end of the file it looks set so i'm gonna hit enter and make it shut up okay so now we have this file hello dot o this is an intermediate relocatable file that we're going to use to now compile into a final elf and how do we do that so we do mips linux new gcc we're going to use the hello.o file we're going to output hello the binary and then we're going to do tac no standard lib so no std lib and then also tax static what this will do is it'll prevent the binary from doing run time linking and it'll prevent a lot of errors when we're trying to emulate our code so hit enter here and we should get no errors and now we can do kimu mips kimu mips to invoke our emulator and pass it the program hello so nothing happened and nothing crashed which is intended and now if we do echo dollar sign question mark which is the previous return code we should get 13 which is the syscall error code that we wanted our program to exit with awesome so now we we are able to invoke system calls we want our code to print hello world so how do we do that first we have to declare an ascii zero terminated string so ascii z and it's just gonna be hello world exclamation point new line the new line being the enter key so it looks pretty when we when we print it um and now we need to invoke our syscall so what is the right syscall right how do we print to the screen we write to the screen so we got to look at what the right syscall is okay so it's a0 gets the file descriptor param 2 gets the address and param 3 gets the length so we'll do our load immediate into v0 4004 we're going to load into a0 the file descriptor that we want to write to so remember in uh in linux land standard in is file descriptor 0 standard out is foul descriptor one and standard error is standard descriptor two there's file descriptor two so we wanna write to standard out so we load one into a0 now we load an address into a1 remember we can load the address of things so we're going to call this string message this declares a label and we're going to load the address of the label into a1 and then finally we need to put the length of the string into a2 and that's going to be 13 as well and then we syscall right so set up for a write syscall we're going to write it to standard out we're going to load the address of the message into the buff pointer for the syscall and we're going to tell this and we're going to tell the kernel to print 13 bytes so remember we assemble we compile and then we kimu mips boom hello world and our output should still be 13. see like i said assembly is really easy if you just know the basic building blocks of the instruction set by learning the registers by learning the instruction set and by learning the syscall interface you can basically teach yourself any assembly language really really fast if you did enjoy that or you learned something do me a favor hit like hit subscribe and i'll see you guys in the next video thanks a lot take care [music] you