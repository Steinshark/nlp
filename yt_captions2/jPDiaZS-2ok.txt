hey there youtube welcome back to another uh low level learning video uh by the end of this video today you should be able to write a hello world program that outputs hello world to the screen in purely x86 assembly so let's uh let's dive right in my assumptions here is that you have a little bit of programming experience you know how to use linux all that good stuff and you're working in either some kind of intel linux environment be it a vm or bare metal on a laptop and with that being said let's dive right into it so before you get started make sure you install this one package we will be running um writing 32-bit assembly so if you don't have lib c6 dev i386 installed you'll have issues at run time with the loader once you have that installed go ahead and copy down this template into a file i call it 001.asm and i'll walk through the template here right so everything with a hashtag as a kids would say or a pound sign is a comment the title and this is our goal right to write a string to standard out on the next line here we have global start global start just gives the assembler the directive that start is a global symbol that is exported to any other interested party that wants to look at it intel syntax means that we're going to be writing our intel assembly and intel syntax i know the intel versus't syntax war is kind of a holy one so i won't take a formal stance but we're gonna be writing an intel syntax um and then these two lines here the section text and the section data that tells the assembler that anything south of this line is to be interpreted as text that means that it is readable and it is executable it is not writable and the opposite is the same for section data so it is readable and writable it is not executable right you don't want any part of your program to be read write executable and we'll get into that in a later video so all assembly ends up being is a series of instructions that either have to deal with registers or memory and i know that's a gross over simplification of the problem but that's honestly what it ends up being so if you look at this instruction right move ex4 cool right so that means that we're moving the number four into the register eax you may be asking what are registers okay well let's take a look at um and this my beautiful art here so registers are um a part of the processor that are hyper fast physical pages of memory that exist to transfer data um between themselves or between memory each register has a purpose we won't go over all of them today um basically understand that you have your general purpose registers here so eax ebx ecx edx etc there are some others and then your non-general purpose registers so this is esp this points to the top of your stack in memory and again if you don't understand this it's totally okay this is for a later video ebp points to the base of your stack in memory and eip or pc we're commonly referred to is the address of the next instruction to be executed but again none of these are particularly important just understand that assembly happens at the register level cool so now that we know that registers do we can write some code right we can say move eax 4 or move ebx 5 and that's all well and good and we can do this all day with moving stuff in and out of registers and in and out of memory but the question then becomes how do we make the computer actually do something that we can physically see or you know a process crashes or something and the way we do that is with what's called a a system call and a system call in intel 32-bit is executed by interrupt hex 80. so this basically asks the kernel hey colonel i've set up my registers a certain way can you make the computer do something for me and the protocol or i guess the the spec that we've set up to do this is accessible through what's called a system call table right so if you google system call table 32-bit you'll get this nice document from google that chromium puts out and you can look at the x86 32-bit it's just call table and basically you get a list of functions that you can ask the kernel to perform for you so for example if we wanted to exit our program we can't do it ourselves we have to ask the kernel so the way we ask the kernel to exit our process is to put one into the eax register and then we put the error code we want the process to return in our zero or in this case ebx right and then we invoke that that in 80 and the kernel takes an action so let's let's try that out so we said that to get an exit syscall we have to say eax is one right because that's what this table says exit is happened by ex is one and then the error code is through ebx i want to return 65 and we invoke uh the system call by typing int x80 as the uh the next instruction cool so we write that and we've got to compile our code and run it right so the way that we are going to assemble assemble our assembly and then compile it into a valid elf is through this series of commands so we have we invoke the assembler on our code we're specifying it's in 32-bit because we're doing 32-bit x86 assembly right now and we are going to output an object file so an object file is an intermediate artifact of the compilation process if this is over your head don't worry about it but basically it's not executable in this format if we produce this with no assembler errors that's good and now we say hey gcc we would like to produce an executable elf in 32-bit mode from our original object that we produce from the assembler and also please don't link in standard or libc because we don't care about live c it will create uh compiler errors if we don't do this so we run this can't find oh i deleted the start tag so what happened here is i said a global label start exists the compiler depends on start existing otherwise it has no idea where to begin the code and i failed to declare it so we have to add start to our code so we'll run the assembler again because the assembler has to put that symbol into the object file we will invoke the compiler because the compiler needs to then look into the new object file and we'll get no errors great and in theory if we run this it should just exit okay and now we want to check the return value of that process which was 65 perfect okay great so that worked out exactly as we thought it would um so now that we know how to write uh syscalls to do something via the kernel uh the question is now how do we output a string to this screen and the way we do that is just like any other syscall right instead of exiting the process we're going to have the process write something um and how do we do that so in linux when you start a process there are three file descriptors that are open by default standard in which is zero standard out which is one and standard error which is two so we're going to write to the file descriptor standard out which is one so ebx will be one we're going to point ecx to the thing we want to print and we're going to put into edx the length of the thing we're printing it sounds a little complicated but it's really not that bad let's dive right into it right so syscall 4. and we're going to actually leave this exit syscall because at the end of printing we want to you know exit our program if we didn't do that it would crash of so we said um eax needed to be four to pull this off ebx is equal to one right which is standard out in out error zero one two standard out so we're going to write 2. and then e c x is equal to the address of the thing that we're trying to print so in this case when we're dealing with memory operations in intel we actually don't use the move instruction instead we use this new instruction called lea load effective address we are saying we are loading into ecx the effective address of message right because we want ecx to point here before we invoke the system call and then finally move edx the length of the thing we want to print so it's going to be 5 ten eleven twelve thirteen and then and eighty let's try to compile this and see if uh i messed it up no worked well so we assemble we compile we run the program great so what have we done we've written a program that sets up and invokes a write system call sets up and evokes a exit system call exits to prop the process and we get back the 65 error code all right guys i hope you enjoyed that if you did drop a like hit subscribe i drop these kinds of videos all the time and let me know in a comment what video you want to see next on this channel so thanks for your time i appreciate it keep learning bye