why am i choosing go in 2024 over rust this is kind of the year that i'm going to be choosing go over and over and over again and so one of the big motivating factors have been for me that i've been doing rust for every little side project for every little thing i could do on netflix and any sort of tool and all that uh and i've just been using it a lot for the last two years for pretty much everything uh i've graduated from the point of using arcam mutex hashmaps and so i feel like once you overcome that hurdle on async rust you're you're pretty good place and so i've just been doing it for quite some time and what i'm kind of realizing is that the type system is incredible it is the best type it's like the second best type system i have ever used but there's a little something that i i think is really important to kind of know about which is that when you have such expressivity such complex some such complex complexi livity of a language uh there's this phrase that that i that i've seen said which is if your language doesn't have the comple if if your language isn't complex your app will be complex something along those lines either the complexity is in your language or in your application i've heard some version of this statement somewhere and i i i i truly 100% believe that that is just a dumb statement at this point it is not true in the slightest what i found with rust is that you can make anything incredible anything absolutely out of this world when you really need to if you really wanted to you could do proc macros to really even like drive things off of strs and it's actually it's just such a powerful language but what i end up doing is that i end up making so much time investment into making my code pretty and i feel like rust has this weird curve where if you're not invested into making your code pretty it's actually it becomes uh excessively hard so there's like this weird line where i find myself battling against rust or battling against trying to make it so that it's super convenient to write so every single struct i'm making i'm implementing so many different of these like basic traits to be able to do anything like display uh into and all that and so it's just like it keeps on you know i just keep on doing that with everything whereas with go i'm trying go out for the next one to two years as like my kind of go-to reach when i can have a decision on the language i'm using and the reason why i'm doing that is i want to explore like the literal opposite paradigm of rust which is this language is extremely simple it's designed to be simple it is like that is the literal purpose of it is to be like peak grug peak simplicity and so i really want to experience what is the difference of becoming really good at a language in which is extremely complex and very powerful all the way down to like exactly how things are happening like at a very low level versus maybe a little bit higher level of a language that's still really fast it fits my bill for being a fast enough language i don't feel like i'm just doing users dirty and so it's on the fast enough thing and has a great concurrency model is the simplicity true and right now what i'm seeing in my kind of initial run through is that if your language doesn't have complexity it does not mean your app has to have complexity your app having complexity that is unmanageable is a skill issue more than it is anything else and so that me i can have at least this is kind of what i'm experiencing i'm having the simplicity of not having to overthink things though i do miss stuff right i miss trade implementations there's things i really wish go had that i really would like you know what i mean there's things that i like this is not me saying go rust is bad okay rust is great it's just that i i end up like i i do too much type masturbation when it comes to to rust whereas i just don't do that with go i i it's cuz i really can't you know what i mean it's just not in the cards and and so it becomes a lot harder to to spend my time really thinking about types and due to it being so simple i end up approaching problems with a really simplistic kind of view and it ends up making things really simple if that makes sense hopefully that that that makes sense uh go became amazing once generics were introduced yeah this actually has greatly simplified their uh their standard library because now they have like a max and all that so there you go that's that's kind of been my thought on go versus rust and i've been really kind of stewing on this because i i here's here's one problem that i see with a lot of people is that they find something that feels good and they really like it and so then they think this is peak programming right and you see this constantly with typescript typescript is the worst offender not because typescript is somehow there no knock against typescript typescript is the worst offender because people who are new to programming start there and so when they start using it and they see a different language they automatically discredit it because they try to think of it through the lens of typescript and that's like not how you should approach any programming language you should approach a you should approach a programming language of how do you how do you use it its way how do you write idiomatic version of that if that makes sense and so i i feel like a lot of times people don't take that that kind of paradigm shift to write it right like if you try to write rust like you write typescript you're going to be deeply unpleased if you write typescript like you're trying to write rust you're going to be it's just not going to be that much fun if you try to write go like either of them it's not going to be that much fun right you have to like really kind of think through each one of your decision you know what i mean and so that's how i think about it all i wish go at union types see that's the thing is i'm actually find that they don't have union types you solve union types by using interfaces and what that what the reason why i do like that is that it also simplifies how i approach this because often union types i use it as like a catch up for things that need to change and instead i can walk backwards and try to figure out why do i need this union type and what can i do to change it you know what i mean like i there's there's definitely things that you can it's almost like i go through and go okay wait a second why am i doing this to begin with what's the simpler way what's the thing that i should be doing here it just tends to make me just think a little bit different if that if that makes sense and so it's been fun i've been i've been having a lot of fun uh you know programming the grug language versus is the the you know the the the 600 iq floating guy language and so i've been having fun on both sides and so i like it so there you go that's why i'm using go in 2024 versus rust you got to you got to flex your brain you got to really flex your brain and try different ways to approach problems honestly i think that's that that will be your biggest hindrance to becoming a great engineer in the next 10 years is your inability to be able to shift paradigms around and so i do have one last paradigm i still want to do which is going for a real functional paradigm like moment and i think it's really good uh to be fair just use the language you enjoy no see i hate this i honestly i hate that take because the problem with that take is that you won't enjoy any other language if you try to make other languages a certain way you don't understand why something is good or bad until you use it the way you're supposed to this is what keeps people stuck in this like i only use say you know whatever i only use rust because that's all i'm using because they they only view problems through this one lens and then they just leave this entire thing on the table it's not about what you enjoy it's about learning paradigms to solve things and then to use that to kind of springboard yourself into into understanding it do you need to love another language i think you can learn to love everything you can learn like the thing is here's a good example of that just i know this is one more take when i started using rust one of my biggest gripes with my big my two biggest gripes with rust was one i didn't like that if statement didn't have parentheses around it and that it was in a forced snake case as opposed to camel case honestly those i i hated that i found those just to be super annoying cuz that's like how my brain thought i thought it i just thought it looked annoying right now after doing it for a while i've unfortunately flipped my stance now it's like okay if your if statement has parenthesis around it it's it's it's awful and if you're not using snake case you're a loser now it's just like now i'm sc rude cuz now i'm unhappy in every language now i'm using go which doesn't have parentheses but pretty much wants you to have camel case and i hate my life you know what i mean it's so funny how your view of things can just simply change by using it and trying to use it for the purpose that it's intended for instead of use the best tool for the job because that's like again someone can make a roller coaster in excel and i can give you a reason why making a roller coaster in excel is the right tool for the job i prefer to try to understand the domains in which a language is best used and use the language that i think is best for this domain if possible and sometimes unfortunately it's a people problem if i'm working with a bunch of people that only know typescript i'm probably using typescript i'll i'll say hey we're using js doc losers but that's me you know you know what i mean we're using js doc losers all right hey the name hey the name is the prime gen