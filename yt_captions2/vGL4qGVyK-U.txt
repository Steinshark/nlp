hey guys welcome back to another low level learning tutorial uh today we're going to be going over memory operations in x86 assembly um by the end of this you should be able to do the following push a string onto the stack and write it the standard out and then write a string to the stack using store operations and write the standard out as well um if you didn't watch my previous video it's going to be a little over your heads i would go check that video out i'll drop a link in the description uh that's where we learn how to move data in and out of registers and invoke a system call to get the kernel to perform a function for us so to go into this tutorial we need to first talk about memory in uh in assembly right in a program typically you have this memory structure that's referred to as the stack and you can think of it as a stack of plates right and that represents the memory that you have access to when you're writing your program and that memory lives in ram random access memory um in my diagram here so this is going to be a little much but just understand that the data grows down positively right so as esp goes up as we push onto the top of the stack esp gets decremented and the width of the stack is the word size of the architecture right so in this case we're doing 32-bit intel right so the word size for the stack is 32 bits or four bytes right so for example the value one two three four five six seven eight in hex which is a four byte value can live on the stack as a single word right so when your program starts you have esp which points to the top of the stack right and as you push you you execute the push instruction esp gets lower by four every time the stack gets taller and your your data goes onto the stack so what we're going to do is we're going to write a little program that pushes something onto the stack and we're going to print it out to the screen right this is going to be our first exposure to writing data to the stack so let's execute the push operation right so push and we're going to use this value and i'll explain why we use this value in a little bit zero zero four three four two four one right so after we execute that value the top of the stack is going to equal it's going to have this value in it right it's going to have 0 0 3 4 3 4 2 4 1. awesome you may be asking me why why do we use that value that value is important because that value is important because it actually equates to the string a b c you may be asking how does a number become a string okay well in computers all data can be interpreted in different ways right so an integer can also be interpreted as a string if the values are ascii printable right so the value 0 0 4 3 4 2 4 1 in little endian is actually a b c nullbyte i said little endian what does that mean um so in intel intel is a little endian architecture right little endian means that when you're doing a memory store the least significant bit or the lsb or sorry the least significant byte or the lsb gets stored first so 41 is a in hex so that gets put onto the stack first 42 is the next most significant byte that gets put on the stack next and so on and so forth so the integer ox00434241 is actually the string a b c null byte cool so what have we done we've pushed that value onto the stack next we need to invoke the system call right so if this value lives on the stack we need to set up our system call so what was the syscall number versus call right if you watched my previous tutorial you remember that syscall right is system called four next we need to make ebx equal to the file descriptor we want to write the data out to if you watched my previous tutorial you'll know that ebx needs to be 1 because 1 is standard out and now we need to make ecx equal the pointer to the thing that we want to print right so if we pushed our string what is the new pointer that exists that already points directly to our string well we talked about this before right if we look at this operation if we've performed a push esp will point to the top of the stack where our new push data lives so after we execute that push instruction esp will point to it so if esp points to the top of the stack we can then move esp into ecx so now both esp and ecx point to the string we want to print out and then finally we set edx equal to the number of bytes we want to print and that is going to be three we can do three or four i like three currently and then finally we invoke the syscall right um and i made a little make file that makes things easier for you basically you write you type make and it runs the instructions i told you about in the previous tutorial so if we run make we see the makefile is putting our program together for us and then it runs the program and we do print abc to the screen right um to make this a little prettier we're going to change our null byte and our code to ox0a that's the new line character or the character that happens when you press enter it'll just make our our flow a little cleaner so we need to make um the null byte zero a and we need to make edx equal to four to actually print that zero a so we type make again boom abc cool so what have we done we pushed a string to the stack esp after that push instruction pointed to our string then we made ecx which is the register that needs to contain the pointer to our string come from esp which already points there and then we called the syscall ex ecx pointed to our string and we printed it to the screen awesome that's one way of doing memory operations in intel right we can push things to this uh to the stack another way is doing a direct memory write so instead of a push which pushes get kind of messy right because what did i say every time you execute a push instruction esp is getting less and less kind of without you knowing about it if you don't keep track of that that can get pretty messy pretty quick so another way we can do this this operation is instead of pushing the data there we can do a memory move so normally we've been doing moves like this right where like eax becomes four well there's a new way of doing moves where instead of moving to esp we wrap it in these hard parentheses and what that actually is saying is that don't move into esp the register move it to the thing that esp points to right so instead of treating esp as a register itself we treat it as a pointer and we move something to where that points so and we're going to move exactly what we said before move 0a 434241 which is the string abc newline little endian right so we're going to compile this we're actually probably going to get an error right so the error here is ambiguous opera operand size for move so what this is saying is that we're trying to move something where esp points to but the assembler doesn't know how big the thing is we all know how big the thing is the thing is four bytes but when it actually um assembles the instruction it needs to know the max width of the operation and we're not specifying that so the way you specify that in intel assembly intel syntax is going to be by adding move d word pointer so what that's actually telling the assembler is to treat esp the pointer as a pointer to a d word type and in assembly a d word because of historical reasons ends up meeting a four byte wide um memory structure right so what we're saying is move to the thing pointed to by esp of size d word this value which is a string a b c new line then the rest for operation right move into eax the value 4 for the right syscall move into ebx 1 for standard out esp points to our string so move that into ecx move into edx the length of the string and invoke the syscall we type make oh i didn't actually save and type make cool and we get abc to the screen anyway guys i hope that made sense to you thanks for watching drop a like subscribe i drop content like this all the time and uh leave a comment on what you want to learn next thanks for your time bye