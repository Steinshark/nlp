to tell you the honest truth i don't even know what it is i don't i don't even know what git flow is one of the more popular certainly more widely recommended approaches to managing change into production is git flow i confess that i've never been a fan i'm a continuous integration guy and get flow prevents real continuous integration by the way i do not speak whatever subtitles are currently being displayed i'm not exactly sure why this has been chosen for me but okay so i have no idea what git flow is teach me daddy for a long time ironed people like me who value fast efficient ci over feature branching have felt that we were kind of talking at the margins yeah i think that many if not most people disagreed with us on this however one of my friends has recently had some success in movies i mean sometimes feature branches are necessary or perhaps by how the team is structured the people working on it they're necessary i don't know if you can ever get away from them fully um anyways moving the conversation on a bit so i thought that this might be a good opportunity to explore git flow and its use in a little bit more detail so what is git flow okay so git flow is direct contradiction to continuous integration that's what we're learning thus far interesting so is it like another form of ci is that what we're looking at and why is it incompatible with continuous integration and continuous delivery i do not believe in continuous delivery um i don't i don't believe in continuous delivery i think continuous delivery is crazy uh [music] hi i'm dave farley of continuous delivery welcome to my channel and if you haven't been here before please do hits not like him continuous delivery i'm just saying like if every single commit you make goes straight to production i think that's crazy talk subscribe and if you enjoyed the content today hit like as well i'd like to begin by thanking our sponsors harness equal experts octopus and spec flow they're helping us to grow our channel and so please do support them by checking out their links in the description check them out if you'd like to know more about my preferred approach to continuous integration and branching check out my training course where i'll cover this in a lot more detail all right get the flow was invented in 2010 by vincent driesen this was the same year that might do we all hate do all my homies hate vincent reason is that what i'm taking out of this do we all hate me and my homies hate this guy my book continuous delivery was published so git flow is certainly not designed with development approaches like cd in mind really this is the git flow model it's based around two branches usually called develop and master this approach is based on the use of git hence the name and even though one of these branches is called master the name choices are somewhat arbitrary really doesn't mean the same thing as mastering does in git git is a distributed version control system meaning that every clone of the repo is the same interesting interesting i'm not necessarily opposed to what i'm seeing just so you know just throwing this out there i'm not opposed to what i'm saying okay so i guess the real question is why should it be different the selection of a one true branch for master is purely by convention not imposed by git itself supporting these branches are a bunch of others feature branches release branches and hotfix branches so five different kinds of branch in all but in practice there may be many more branches than that in play because there'll be multiple versions of feature hotfix and release branches this is a complex branching strategy and as i said in the intro works against continuous integration i'm curious how it works against continuous integration because your ci is something that happens per merge on some set of branches so why couldn't you just have ci in develop am i missing something i'm looking at i'm looking at chat right now um is there something that i don't understand here because i totally get it if i don't understand that um yeah i know don't don't don't look at the versions but real real talk like to me i mean one problem i have is that i have people you know relying on some of the tools that i make and so one of the tools that i make is integrated via just having a master branch right whatever's whatever's there we don't even they just take whatever's latest right now we do have some releasing mechanism but it's just like you know we're it's just like such a low whatever that we haven't really productized it in any sort of way it's just kind of like the just the gsd get  done and so having a develop branch is quite nice because it allows me to have a you know a place where i can work make sure things are good continuous integration built on that one and then just merge over to master every now and then right i don't see how this one somehow makes a construction better well i have employed branching strategies like these on projects in the past but that was before i learned how to do continuous integration properly so what do i mean by it works against ci here's one of my favorite descriptions of continuous integration from the inventors what if the engineers didn't hold on to modules for more than a moment what if they made their correct change and presto everyone's computer instantly had that version of the module continuous integration is about establishing and maintaining a shared accurate view of the state of the system that we were is that the display is that the definition of continuous integration maybe i mean i guess i've probably been using it wrong so i mean i'm fine saying i've used it wrong for single branch workflow a lot of testing prevents pushing it without triggering your ci um is that is that because i mean i i'm fine being wrong i've used words wrong right i've definitely is i've definitely used words wrong so i'm fine with that we aren't guessing whether our changes will work together we're checking frequently multiple times per day continuously here's another quote from the seat i mean it's it's it obviously that quote is is completely you know idealized because let's just say you have ci to what level do you run ci on every single commit now there's plenty of different levels you could be running like say for instance for television to release it requires i i forget it's like one to two thousand separate integration tests that are ran it takes about you know 100 machines over the course of six hours to really get it done so does is that i mean do you want that at all points or is just having any branch as the branch of truth versus what is the branch of truth for production like is there is there a difference for that does it have to be do they have to be the same that's my question which is does what the developer works on have to match exactly what's in production i don't i don't think so do you do that in pr no that's why we have smaller pr right smaller pr's there's there's develop ci develop ci is smaller runs in about 40 minutes a smaller subset of the integration stuff just like the most important stuff just to make sure it all effectively works and then you can auto merge in if you have the right stuff so it just kind of goes in goes out you know pretty straightforward yeah unit tests take uh gosh three minutes to run uh just because you know there's like 2 000 unit tests um yeah yeah yeah yeah see that makes sense i know there's like it totally depends right just like right here the medical devices right there's there's different levels of severity and our like one of the things i work on as a c plus plus environment in which these tests are really complicated and they take a long time i worked on a project where the nightly test took 30 hours long that doesn't make any sense because that would be night and day then night again then day again to wiki description that i like right the fundamental assumption of continuous integration that there's only one interesting version the current one really am i just totally wrong on my definition because i am completely fine okay so what is what is the name for the thing that happens in which you commit to a branch and it run a lot of tests but it doesn't necessarily have implication for what master or slash production has to be what is that process called are they mixing is this a mix of two concepts i i thought that we always called that ci or ligma for short i thought that was ci is there oh is this like one of those ideas of like there's there's ci the the the thing and then there's also like the philosophy of ci which might be slightly different than say ci itself is that what we're looking at here is this like the the philosophy of said ci okay huh let's look at where we can achieve that clear correct picture of the current version in git flow is it here on the developer branch well it's close but it's not definitive what if we evaluate our changes as we commit them to the developer branch is this really the truth no this isn't the collection of changes that will definitively end up in production we may have hot fixes that haven't been merged backing to develop yet so develop and master are for a short time out of step maybe with that okay this to develop that we decided i think this is a very singular world view in the sense that everything you change must be also what is in production like it just it cannot like what i work on the c plus application on netflix that this this can't exist like it cannot exist what he is suggesting that somehow these should be in line they they literally cannot uh because like what do we do with a product that was launched in 20 uh 21. that could have hot fixes it's a c plus plus application with a certain set of like ways in which the partner in integrates you can't just change that right they can't just redo their television and then launch that information about the same coins were based on incorrect assumptions i can imagine fans of git flow at this point now smiling and saying dave doesn't understand we work to keep the developer master instead well let's pose the question the other way around if develop and master are kept really close together in terms of changes what's the point of having both and so risking one represents the state of production one represents the state of develop them being even for a moment out of step why don't we instead use our version control systems to do its job and control the versions that we're interested in so i can imagine using the developed branch as the truth but that would eliminate the need for the master branch and the hot fish branch altogether merging all of the changes into develop whether new development hub fix or bug fix and releasing changes into production direct from there yeah i mean i've i can i can i'm fine with that as in develop can be this place in which you just literally cut the releases and that was goes that doesn't really bother me it's more of these feature branches because inevitably in larger more mature products there's just changes that cannot become an atomic commit like it just it can't be unless if you're doing the mega merge and we all know about the mega merge we've all lived through mega merge sometimes it just can't exist in production like imagine if you're replacing uh some amount of react with solid.js you can't just you can't just like it's very hard to do that incrementally this is now just continuous integration or maybe continuous delivery not git flow we can think of the master hotfix and release branches as release supporting aspects of this approach they're all focused on managing change into production this is obviously important the truth of our system is what ends up in production so i think that should be the focus of our evaluation so we could decide instead of treating develop as the truth to evaluate our changes every time we merge a change to master this would be accurate in terms of the changes since that's where we release from master into production this is the interesting current version the only that only works in a continuous integration sense though if we're doing that multiple times per day by definition continuous integration says that everyone's merging their changes together at least daily we are also still left with the special cases of hot fixes or bug fixes what's the current version now the assumption that i think is built into git flow is that we do this merge when we think our work on a feature or bug fixed is complete if we're waiting until we think we're finished before getting feedback on our work though that's crap feedback it doesn't no that's not true i mean feedback exists at many levels i think one thing that he's missed that is definitely missing here is what is the product being built if you release your website every single time a change goes in you are just continuously busting cash you're continuously having longer load times for first time rendering the page um it is there's a reason why you may want to have larger regions there's a reason why you want to do certain types of testing right so like for us to be able to do testing or release in production not only do you have to do this whole like cutting something from a specific version then we release it to only one percent or a half percent or a tenth of a percent of the people using our product and measure a whole bunch of different things like are we getting more star players are people still streaming as much as they were are we still getting the same amount of application starts right like are we still getting all the stuff we need to know that this is good now that does that mean all of we should never let production we no one can commit because production is now being held back by realistic stuff what happened if we do that we push some stuff in we have a good release and then we are about to release and we also find a critical bug in our previous release in our new release we release out and there's a problem we don't know what the problem is but it seems to be worse do you make a hotfix branch then is that when it's okay like to me just there's something about this that's just not adding up which is real life gets in the way a lot of these idealized kind of items that's how at least i look at it i i could still again can be completely incorrect here that is still compatible with this idea he didn't say you always have to release to everyone you can still do feature flags or canaries yeah but what's the state of master then that is in contention because the only thing interesting everyone should be lockstepped and changed with each other but there are times in which it makes no sense to do that but sometimes you have to do a like a hotfix i've had to do a hotfix i've broken production really support development and it's certainly nothing close so we need to up the rate of merging to master the most sensible way to do that is to eliminate the development hotfix branches and now yet again we're back to continuous integration as well as i still think hotfix needs to exist because again what happened if you cannot release this orange one due to a separate problem than releasing this blue one but the blue one also has a completely orthogonal problem what do you do do you try to fix both problems or do you simply fix the problem that's in production affecting people right at that moment then fix this problem this doesn't feel like ci this feels like you're entangling the idea of organizing your commits to go to production and ensuring they're correct is different than ensuring productions correct there are different levels of checking i've spoken about my thoughts on feature branching before in previous videos it's really the same line of reasoning that we've just explored for release though as a developer i want the clearest possible signal that my changes are safe to release and i would much prefer to find out that my changes aren't safe to release close to the points from at which i begin to diverge from safety rather than after weeks of now wasted work even if the work isn't completely wasted i'm not where i thought i was now i've more work to do than i planned because i need to get back to safety so but isn't that i mean real talk though that means that you have two tiered safety system right safety one is your ci which is a series of tests whatever you run that ensure that whatever you're doing is correct and then there's like case two which is does production does the actual you know boots on the ground accept your changes right isn't that kind of like a isn't that like how we all live in these two-tiered kind of safety systems so i'd like feedback on the safety of my changes frequently so that if i do make a mistake i'll find out really quickly so that my mistake would have been a small one what does safety mean in this context well it really means that our changes are releasable the changes of production quality it does the job we expect it to it works along with everybody else's changes it may not actually the paid production quality but we can assume that it's production quality based on our ci right integration was invented to solve so in a perfect world what we'd really like is constant you may think continuous feedback on our changes every moment you know that your changes work along with mine and we both know that our changes together are good enough to release the problem to me that just seems like why why make the why make the distinction between develop and master then if i have all of that feedback equally strong on develop and then i only release and just have the changes go over to what is in production i don't see why that's a problem this guy should do a video on how we handle a nuclear launch code but really but real talk like i don't see why that's any different at this point the only thing it leaves open the door is that as a production which will naturally stray from dev even if you are releasing every single commit there's still a period of time in which there is a difference and then there is also a train of commits so if you're like every commit then there would be trains of commits that need to go out no matter what there can be you know like a difference between the two which means that there could arise a problem that requires a novel fix me is that the world isn't perfect so there are some compromises in reality okay i don't really care whether your code compiles with mine while you're in the middle of typing character by character that would be too continuous so we break it up evening continuous integration there are times when i'm working on my local copy and you and yours but if we want this semi-continuous picture of the combined safety of our changes then we can't afford to wait for too long in continuous integration most experts agree that daily integration although too infrequent to be ideal is just about good enough to qualify as continuous integration so if your feature really i i always well i'm a rebaser you know me so i take my changes i rebase them on top of latest master all the time i don't know i just always do that why wait for one day it takes longer than a day to create you can't wait till it's finished and so do feature branching before you merge your changes if your feature takes less than a day to create what's the point of creating a feature branch so is this okay hold on i think i i think i understand what he's trying to say when he says feature branch what he's actually saying is that he literally works on master and then must have a forked version of master so that he can do a merge to master request because i assume he doesn't push to master right he works on his version of master and then merges it over is that is that correct i think that's what he's trying to say there and real talk that's a feature branch if oh he pushes directly to master terrible there's plenty of reasons why that's terrible because someone can pull and then you can find out it's broken you're waiting on some other machine to tell you right that that can't be good that cannot be a good pushing directly to master is not good you should have some level of checks you should have something called ci that checks if the pushes you wish to push into master are correct enough now if you have your own version of master which you push to and then you merge it over you're just doing a feature branch they're just both called master it's the forks the origins that are different i am largely against pushing directly to master except on small changes uh and or sorry not small changes on small projects in which you know there's it's just not worth your time to set up an entire system for it my preferred way to organize all of this is that i will work in my local repo on my copy of max i thought that was red pill commit changes locally frequently usually just after the test that i'm working on has passed after every successful local commit i will push my changes to origin master where that triggers the first stage in my deployment pipeline which is really just continuous integration some version of this is sometimes referred to as trunk-based development though i confess i don't really think that there's any real difference between this version of drunk based development and continuous integration you aren't really continuously integrating to trunk at least once per day now get flow does that mean that's also everybody else's remote master is that what he's saying that that that's also everybody else's remote master i guess what he's trying to say my assumption is that if you how he would want it set up is that you have git hooks and you can't push to master without whatever should be running on ci should be ran on your local machine i think that's what he would be advocating for because i don't see how you could ever have any other situation okay i i think that i mean i i personally don't want any of that crap running on my machine right it just takes up my own thought process see my last message sorry you have to copy it i'm look you have to copy it adds all of these other branches branches by definition are defined to isolate or hide change continuous integration by definition is designed to expose changes these are kind of mutual i think the difference lies in continuous delivery and continuous deployment uh you're thinking about continuous deployment continuous delivery in his words is ensuring you are able to release but not actually deploying those changes to production after pushing you still decide whether to deploy them to production environments then what's the difference between develop and and master again i i feel like this is a conflation of terms because then why not have a developed one and then why not have one that perfectly represents the state of master because you may there just can be things out of your control that require develop to have an update and then master itself can be in such a state or production shall we say that can be failing that could be where you you you now have two distinct failures and you have to solve them i don't know why you'd ever want to put yourself into that position the exclusive ideas at the start of this episode i mentioned some recent moves on this topic these are down to a friend of mine brian finster who reached out to the inventor of ditflow vincent and asked him to revise his explanation in the context of continuous delivery i think it says a lot for vincent that he did so vincent's article that introduced gitfloat now has an update here's a snippet if your team is doing continuous delivery of software i would suggest to adopt a much simpler workflow like github flow instead of trying to shoehorn git flow into your team now clearly i've taken i also don't like straight up get flow i don't want all those branches i'm not i'm not necessarily i mean the hard part is is that what the hell is a feature branch if you work on master but you push to your remote master and then you merge your remote master into the teams remote master is that a feature branch in my book that's a feature branch where a lot of the problems come from is long-running feature branches where you can't make your commits atomic you should really think about feature flags you should find ways to make your your commits much smaller if you start running into that that's that's like that's my own personal opinion like i get that but i still like the idea of having a production branch like the thing that's in production and then the thing that developers are working on really care much more about that if you work in a large c plus application you're going to have releases so then you're going to have you know 2021 version 2020 version 2019 version 2018 version and these are all masters they're all in production they're all running on someone's machine they just look different uh it's not yeah hmm a step further than vincent did i contending this continuous integral long living feature branches are the devil nation not the it's bigger brother continuous delivery you need to find an alternative to get flow there are a few other things that vincent says that i disagree with too continuous delivery certainly for more than simple web apps that he refers to um as tesla erickson or siemens if you don't know what i mean but i do want to thank him for making this change i think it was an honest and a respectable move thank you vincent brian wasn't done though has that all mean my homies hate vincent now i like vincent i'm confused i'm having emotional turmoil right now the number one hit it's not completely realistic it's an idealistic missile yeah okay so long as i mean because again even if you have tags and you're on master branch and tags represent production you still run into this goofy situation where now you have these hot fixes that bounce off of a tag and then get merged back onto the main line it's like yeah i guess you could say that you could have done from tag to tag you could have done however you want to do but somewhere something has to something has to contain these changes i prefer a branch reason why i prefer branches i feel like it's easier to make a hotfix ensure that's working then go through your deployment process because you have a singular branch in which you deploy off of so yeah i tend to like that just better i will probably always like that better pit when you google for git flow he's like yeah there's bigger ones it now reads as follows git flow is a legacy git workflow yeah this was originally disruptive a novel strategy for managing git branches git flow has fallen in popularity in favor of trump-based workflows which are now considered best practices for modern continuous software development and devops practices git flow can also be challenging to use with continuous integration and continuous delivery this post details git flow for historical purposes in vincent driesen's revision he mentioned github flow as an alternative this is certainly a simpler approach than git flow but it's really just describing a feature branch model in github flow you do all of the work on a branch until you think it's finished so the problem is speed and accuracy feedback once once again the description that vincent links to doesn't mention continuous integration or testing of any form at all this also contin how he's describing it also just can't work in open source like no one can just push to to master you have to have a bar somewhere just add the word hub yeah you just add the word hub right to me this i mean this is how i like to develop right here i have feature branches that go into develop right that's all it is feature branch develop feature branch develop i don't know this this whole like just push to master business you know how bad i feel when i break somebody and so just having this separation and a ci that runs before merge can complete to me it just seems the best i don't know i don't understand the difference maybe i'm missing something still oh so i wouldn't recommend githubflow either i think that this emission of any mention of testing in the descriptions of both git flow and github flow is a significant one to me both of these strategies read as if you'll forgive me sticking plaster fixes for teams that don't do a great job of automated testing i don't think you need to mention testing to me testing is mentioned right here this arrow from this branch to here is where the testing happens like that's how i look at it i look at that's where testing happens test one test two test three like i see it i see it right there the slowdown is that inaccurate feedback enforced by both of these approaches as a problem for continuous integration it means that we wait too long to find that we've made a mistake i'd also say this accurate this diagram is also highly inaccurate because look at development move forward but there is no other branch to come in and merge in it suggests that they're pushing both to develop and creating future branches but it's inherent to the approaches their aim is to give you time to look at and check your work thoroughly i think that speeding up the feedback cycle is a much better solution to this it brings the problem into clearer focus it allows us to evaluate definitive collections of changes together rather than a best guess approximation of what he's likely to be deployed into production the real issue here is how confident are we that our changes are safe git flow and github flow try to make the change process safer by slowing things down allowing more time presumably for developers to think and check their changes manually or with automated tests on one of one of the several branches but as a result of slowing things down and reducing the frequency of integration the testing on these branches even if it is very thorough evaluates collections of changes that aren't the same as what end up in production so it's not definitive i think that continuous into oh no i think i fundamentally disagree just with that in general i think what he just did was set up a straw man that wasn't correct i don't see how it's any safer in fact i say that it is safer than whatever he proposed because i can always defeat anything he proposes by adding a dash in i don't have to run tests locally i can just push straight up to master there's nothing that prevents me from just skipping all all get hooks from skipping any safety on my system you need the safety between my system and the system of everybody else's right and so it's just like to me having that barrier where you have these two you you it must happen the idea is that the test will run on the ci not locally well he said he does his tests make sure everything changes and then pushes to the origin master so that means there has to be something that takes the push holds the push runs the tests then prevents that push from going in if it breaks because then you just break other people i'm i'm a little bit i'm a little bit confused by that immigration makes people nervous because we're exposing changes before developers are finished with their the features that they're building this is a big change in how we approach our work it forces us to think and work more incrementally but this is like that more closely represents the reality of software development in reality this incremental approach at the heart of continuous integration works not just for simple websites but for some of the most complex software systems in the world taking a genuine engineering approach to software development sometimes means that we have to face difficult realities in this case i suppose it comes down to what is the biggest risk working so that our software is always working as we're doing continuous integration or even working so our software is always releasable as we're doing continuous delivery i honestly think we're saying the same thing i honestly think me and him agree it's just that what he says is different so we're trying to figure out what someone's name meant um they said it was like boobies but you know the whole backwards thing and so i was confused but my guess is what i'm saying and what he's saying are literally the same thing is that what he is saying is that he probably has something called uh his like his you know me slash dev oh my goodness this is way too big this is way too big uh undo undo help me help me tom cruise i don't know why i didn't just use x cali draw for this this makes no sense not to use excalibur uh let's just go 50. all right so he probably has something like me slash dev and then there's a you know then there's you know everyone's uh dev right and he makes the changes just on this singular branch no feature branches it's just the branch itself is what my guess is and then he merge directly over from this and then when this gets in he also rebases it probably on top of this again and then he probably merges it back over some simplified version of this uh something that looks like this it's just that's my guess that's what he is doing and if that's what he's doing i would just simply argue this is a feature branch that's all it is that's just a feature branch they just happen to have the same name if you're on two different origins it's just a feature branch i'm right there with you then i completely agree right i completely agree that this is correct i like this kind of development i just develop on mine i go up i make a pr it runs the ci once i know it's good i merge into dev i take dev and then i go and i re-pull it down i make sure i'm on the latest and then i develop my next thing and then i put it back in right to me this just seems like what he was trying to say but then he also said he pushes directly to this and i think that's where i got lost it is but you'll not have a feature branch in the central replay i know but that's just like such a pedantic stupid difference if you're worried that you have a branch called feature slash some stupid feature and it's in the main repo versus someone's side repo and somehow in the main repo it's bad but in someone's side repo it's not bad it's just it's just so pedantic it's just mega pedantic that's all it is as you're arguing you're literally saying if the apples in the fridge it's good but if the apple's in the fridge in the garage it's bad it's like no i don't understand why one's better than the other the only thing is yeah it just doesn't i i we're either talking past each other or he genuinely develops in a way i would never develop i don't know which one it is interesting though very interesting