why closure really now this is the weirdest part is this is uncle bob okay uncle bob we're talking the clean code guy the guy that wants to abstract on top of abstractions and put everything in its own little maybe this is not so crazy after all he wants to put everything in a function and all of a sudden now he wants to do it i just know that one fact about uncle bob is that he does not like functional programming languages at least in general he's openly stated i think he just like disdains lisp for 40 years uh something along that lines like so so you know he's been around the block for a long time and he does not like it i have programmed systems in many different languages from assembler to java i've written programs in binary machine language get wrecked i've written applications in fortran cobalt pl onec pascal c plus plus java lewis small talk logo and a dozen other languages i've used statically typed languages with lots of type inference i've used typeless languages i've used dynamically typed languages i've used stack-based languages like fourth and logic based languages like prologue okay if you program in prologue the only thing you literally can solve in prologue is bill sits in room a bill's adjacent to susie susie does not like to sit next to shirley shirley sits across the hall from george george is a close relative to bob which room is george in and you're just like uh foreign over the five decades i've used a lot of different languages i've come to the conclusion my favorite language of all the language that i will outlast all the others the language that i believe will eventually become the standard language that all programmers use is lisp major list w okay so i'm not gonna lie to you uh me and uncle bob we've had some we've had some disagreements in the past which means that when i see this i just automatically assume this is a lisp l okay this is a lisp plus l plus ratio uh you know what i mean i'm just saying i don't know what to go with this i don't know how to i don't know what to do with this i'm just saying this is very very confused i have not come to this conclusion casually nor even willingly i was not a fan of lisp for 40 years i was not a fan of lisp no i saw the cars and the cdrs and the cds ca-dd-a-ddrs do you like how i do can you believe how i literally cannot read twitch chat and i just read that letter for letter perfectly i think i might be a savant i might actually be able to read things and thought it was all just academic baloney interesting but not truly useful uh and then a decade ago i found a sick pee and after that i found closed jerk clojure is a lisp that rides on top of the java ecosystem that is not a way to sell it if there's ever been if there's ever been a phrase uh if there's ever been a way to not sell me on an item this is it right here and it does not have cars and cdrs or cadada dr i wasn't convinced right away it took a few years but after the usual stumbling around and frustration i began to realize that this language was the easiest most elegant least imposing language i've ever used and not by a small margin so why clojure i've made a list are you ready for it here it is dude i am actually extremely excited about this i cannot believe someone's unironically recommending closure that's not from twitch chat now twitch chat you guys recommend everything right here watch this nim gang can i get a nim gang in here can we get some nim gangs in here nim gang nim gang anyone nim nim nim nim nim nim nim nim nim nim nim game uh no no refuse ivan rust uh nope nope nope nope no name get this you know what's crazy is this in nim are you ready for something that's gonna blow your mind in nim are you ready for this foo bar is a variable right you can make the variable foo bar did you know that foo bar is the same variable as foo bar let that sink in for a moment let it sink in that you could literally name it foo underscore bar and foo campbellcase bar is the same thing you should take that and you should just die a little bit off the inside snake case is garbage oh that's the solution snake case is garbage therefore we're gonna do this crazy ass thing based language that just hurts fubar equals foose a bard what the first hail i don't know nobody knows so why closure i've made a list are you ready for it here it is i am ready this is the strangest transition ever so why closure i've made a list are you ready for it here it is okay geez that's like running we just went from uh you literally just started on home plate instead of hitting the ball you just went you just stayed on home plate uh one economy of expression if you're if you are wondering where the rest of the list is there isn't any more i i'm not wondering where the rest list is because i'm at one and i can't see below the fold so i assume there's more thank you for spoiling it i would have put that at the end maybe that's the reason there's only one it is just simpler and easier and less occluding to write expressive code enclosure it requires fewer lines it requires fewer characters it requires fewer hours it requires fewer mental gymnastics okay i am genuinely now interested in closure okay first when you said this whole java thing wherever you put that java thing it's like lisp but on java like that did not sell it to me but this okay you're selling it to me well why should this be so the answer is very simple indeed the answer is very simple the language has almost no syntax or grammar what uh let me say that again the language has almost no syntax or grammar probably the best way to uh elucidate this point is to show you an example so here for your entertainment is the program that prints the first 25 squares of an integer print line take 25 map pound me daddy um range you're right very few symbols extremely few symbols um pretty much no symbols no symbols in that one obviously the pound me daddy this is obviously obviously this is an anonymous function um star is the operator you're going to apply to it and the percent sign is implicitly the first argument passed into the map function every everybody knows that duh mental gymnastics okay none none appear here none you know why because it's simple let's walk through this means beginner list means end the innermost list names are just names and in all case they're all functions a star is the name of the multiply function bam goes the dynamite pound me means interpret the next uh list as a function pound me data or daddy got it look at that percent side means the first argument of that function let's go i am a genius i knew it i am a genius i am tom uh dude okay we got it we got that one uh you've just seen 80 or so of the syntax of cloture but before i show you any more let's just walk through the code above first of all there is an opening this that means everything that follows uh until the final is a list uh in most contexts closure interpreps lists as a function calls in this case the function is print line uh that's just a regular old system.out.println classic because when i think of a regular old print ln i think of that one right there system.out.println that's the one i think of right there this guy right here java uh we're used to it in java sort of uh what are we passing into println well we're passing in the result uh of the take function the take function expects two arguments the first 25 is the number of items to take the second argument is a list in this case uh the take function will return a list with the first 25 items of the list in the second argument what is the list in the second argument it's the result of calling the map function the map a function expects two arguments uh the first is a function and the second is a list the map function will return the list that is the result of the call uh calling the past and function on every element that is passed in list okay what function is passed into the map it it's the anonymous function created by the pound me daddy which implies uh which simply calls a multiply on its duplicated duplicated first argument percent sign me and bob we were tight we literally are identical and we could just figure it out now range range must be a function that every time you call every time you pull a value it simply increments it right uh what is let's see what is the list in the second argument it's the result of calling the map function the map function x oh we already did that uh what is the what list is passed into map it is the list returned by calling the range function the range function simply returns a list of all non-negative integers that is a uh that list is lazy so only the integer is required by the upstream function will actually be generated some folks don't like the complication of the percent syntax so we can recreate the square function as follows uh define square x x me print ln take 25 map square range boom so many percent uh parentheses so many of them uh the the def end function uh defines a new function named square the brackets work just like parenthesis except for they define the different kind of list called a vector lists have a runtime complexity of a linked list vectors have a runtime complexity of arrays sort of porque maria uh anyways in this case the vector tells death and that the square function requires one argument named x the rest you should be able to infer yep okay uh this makes the second uh line a little nicer the map functions simply invokes square now you've seen about 90 of the syntax of closure now let's compare the equivalent to a java program uh public class square of integers public static void main string args four and where's my parentheses squirrely brace system dot out i times i where's my spaces where's my ending squirrely brace what kind of language is this who would write this um this is my least favorite aspect of go did you know that go enforces this i think that that kind of syntax is the literal devil and i think that whoever wrote this idea that you should squash everything together should get a firm slapping around okay my version of development experience is that these things are separated by white space my dx not your dx mighty x also if you don't put squirrely braces because it's one line you're actually the devil okay you are the devil in your own code base this is the this is honestly the worst programming practice ever created and the fact that it still is being propelled forward in some languages is actually awful i hate this i hate this because every time i want to put a little print statement in there i'm like i'm gonna put a little print statement right you just jump in here and you're just like ah i think the bug's right here i'm a good programmer i'm gonna jump in here and i'm gonna go like this i'm gonna go oh gosh i can't even handle this as system.out.printel and uh some uh something about debugging and i'm like nobody's actually going to be a jackass acid forget squirrely braces run the program and everything breaks or it breaks on compile and i'm just like maria why did that happen and then i see this and then i go like this get blame and i look at it and when i look at it i go this person's the devil then i go on slack and i take a picture of the code then i put squirrely braces in the code i make a meme about them being the dunny krueger with the guy crying in the iq bell curve and say this is you stop being an this is considerably more wordy even if you don't count the enclosing classes more to point however is that it covers a covers perhaps five percent of the syntax of java and don't get me started in the comparison with c plus plus uh now i don't want the belabor the point i could go on with comparison after comparison with language after language the bottom line is that clojure has a much smaller syntax than most languages the minimal syntax means that i can express problems clearly and directly with much less effort uh and contortion than most other languages look i was not an easy sell i was am a c plus plus programmer more than that i was and am no longer ac plus a language lawyer foreign sorry twitch loves the aids i won't be able to keep keep going a c plus plus language lawyer uncle bob is getting senile time for him to find a home by the way c plus plus 20 uh ranges are blah blah blah definitely a lazy evaluation so good c plus plus apologist curly braces equal good uh parenthesis equal bad i do agree with that i've reveled in the heavyweight syntax of the language i was enthralled by all of its lovely fidelity bits i found the transition to java 20 years ago to be rather meh it was just a slimmed down c plus plus and it's gotten a bit more uh corpulent sense i'm not sure what the word corpulent means but i'm gonna assume it's negative by my transition to clojure was an eye-opener based on the lightweight syntax i expected it to be suitable for a few classroom exercises but not for building large systems in my mind large systems equated to large syntax boy was i wrong this is actually a shot okay completely real i don't care how bad or how good a developer is if you've been doing something for 40 years and you use something completely different okay i just want to just take a moment here you use something completely different you go into it and you try to learn it the best you can and you come out with a changed idea there is just so much respect on that for me uh it's just a it's just such a huge respect and the thing is is that you got to think about this imagine being in a c based language land for 40 years and then finally trying to make the transition to a lisp based one there's a lot of respect there and not only that but you just gotta think maybe you know i always come back to this maybe my idea about dx what i think is actually good is not actually good it's why i'm willing to explore things like oh camel maybe i should try closure just for fun just to see what it is just to build a couple small tools in it this is why i explore other things is because what i think is good is really what i think is familiar and all of us fall into this trap it's the inevitable program trap which is good equates to familiar and bad equates to unfamiliar bad is d a bad dx bad dx is because i don't know it and therefore it's bad because when i try it i don't understand it it's clearly complicated no it's not complicated you're just ignorant and that's okay i'm ignorant too we're all ignorant of things we don't understand that's literally the definition and that means you just have to take the time to understand it but i feel like in the modern day era if it's not typescript if it's not rust if it's not go then it's just clearly bad and maybe just maybe we're all being a bit ignorant there uh what i found instead was that the minimal syntax of closure is far more conducive to building large systems than the heavier syntax of java and c plus plus in fact it's no contest building large systems enclosure is just simpler and easier than any other language i've used and as i've pointed out in the beginning i've used a lot of languages uh but what about so you've probably got some complaints questions objections etc let me see if i can anticipate them oh my gosh all those parentheses how how old are you look here's a function uh call f of x now here's a corresponding function call in java enclosure f of x do you see any extra parentheses there get wrecked by uncle bob okay that's not entirely fair what do you wind up with a few more parentheses uh but that's just because we intend to nest function calls look at the squares of integers program above and you'll see why don't fret though if you really don't like the nested syntax you can always use the threading macros uh let the reader understand i didn't understand i assume there's just some way to pipe instead like an o camel you can just pipe and it just makes it nicer right uh but isn't it slow no cloture is not slow oh look it's not c it's not assembler if nanoseconds are your concern then probably don't want to use closure in your innermost loops you are probably you probably also don't want to use java or c sharp but 99 of the software we write nowadays has no need for nanosecond performance i've built a real-time gui based animated space war game using closure uh i could keep the frame rates up in the high 20s even with hundreds of objects on the screen closure is not slow it's an odd measurement uncle bob i'm going to give you an uh you know uncle bob i'm going to toss in a l on that this entire statement uh slow is is is not a per is not based on human perception it's based on uh language comparison so is closure slow yeah it's slow but the purpose is good building just like javascript javascript slow python is slow we still use them i'm not saying it's bad to use them i'm just saying using the term slow and fast should be a relative measurement between what is really fast c and what is really slow say closure or javascript or python or any of those right it's simple uh what about javascript closure script compiles right down to javascript and runs in the browser just fine indeed the space war program i mentioned above was compiled using closure script and ran in the browser at even higher frame rates than in native mode i'm still trying to figure that out javascript is faster is what that means but it's dynamically typed you don't write tests don't uh you you do write tests don't you and as a part of those tests you can employ the closure spec library to uh specify the schema of your types i hate i hate tests that specify types i think that that is a failure uh yeah and do dynamic chopping checking with preconditions and post conditions designed by contract style to your heart delight but it's dynamically typed declaring types requires syntax syntax reduces economy of expression incoming ooh but damn it it's dynamically typed i'm on this team okay i get it you like static typing fine use a nice statically typed language and i'll use closure and i'll be in scotland before yi okay okay okay okay okay okay okay okay okay okay what about ides intellij with uh cursive plug-in doesn't uh does very nicely i hate ending uh sentences with adverbs uh most closure programmers use emacs though of course they do this is literally true i in fact i just saw who was it that just quit oh uh athena dude fina the legendary vimt uh vim conference speaker thina has gotten into lisp and uh he switched to emacs for the sole's sake of being able to write lisp uh what about refactoring intellij with cursive has some nice refactorings although they don't have extract method yet come on guys uh what about iava interrupt no brainer closure programs can call java directly java programs can call closure programs with only a little bit of uh fuss interruption not be your concern come on man java it was designed for the web it's web scale of course it can interact uh where do i find closure programmers they're out there uh dozens of them just dozens of them waiting but you are better off making them uh the syntax is trivial the java platform you likely already know uh the java platform you likely already know okay that sentence is fusing just decide to build your next system enclosure and spend a week or two getting used to the language then start oh by the time you're a couple months in you'll realize how primitive your early stuff was and you'll be tempted to clean it up but what else is new yeah that's reasonable what about a new language over there what's it called um gazoo yes there's new languages every month every week every day and we have no lack of new languages the thing about those new languages is that there's nothing new in any of them they're just made up of uh made up of the pieces of old languages that they cut up and shook in a jar and then dumped out in a game of yahtzee this is actually an incredible point which is kind of like there's this thing that we do as humans where we actually try to we try to fix problems right and the thing is is there's nothing new under the sun everything that has existed still just keeps on existing we're just simply we're just simply trying to like re-fix the problem right for whatever reason the ground is cursed when you program it's just simply cursed everything you do falls apart somehow you don't touch code and it gets worse nobody knows why it just does it literally just gets worse we don't know why just entropy exists in the static language assets and nobody understands why and it's true all these languages that are coming out rust is just simply oh camel smashed with c like it's not like it's some magical new thing that has never existed before it's just a reshaking of no wait a second if we optimize here then it will finally solve the fact that programming sucks it's like no programming will forever suck that's all there is to it it's just always going to suck why are you trying to make it not suck just accept the suck and determine which version of suck you would like to suck on okay that's not entirely fair there's still some good ideas percolating in the language space but none of those ideas are revolutionary we've encour we've entered the era of tweaking i don't find any of the new languages nearly as compelling as closure simply because of the extra syntax virtually all of them carry other languages have minimal syntax why not one of them yes that's true fourth had a tiny syntax so did small talk but those two languages had baggage of their own fourth was rever uh was a reverse polish stack language academy of expression is not uh the phrase i would use for fourth though i find it fascinating that postscript was based on it a small talk was a small and elegant beautiful it spawned the design patterns revolution it's on the refactoring revolution it spawned the tdd revolution it helped to spawn the agile revolution small talk was the language's tremendous impact take it twitter it tweet it paste it quote it uncle bob now we know who to blame and tweet it back to the article small talk was also image based uh language very few programmers have ever wrapped their minds around what that really meant so unfortunately the language that languished compared to the text file based languages i don't even know what that means what do you mean images what do you mean we're looking at images i don't want to look at a jpeg okay what is this nft programming i don't want to be a part of that lisp is older by far than small talk or fourth it was created in 1957 from the concepts that came out in the 30s and it has never languished in this uh way small talk or fourth half indeed it's the language that refuses to die we've tried to kill it many times but like the annoying neighborhood stray cat it keeps coming back not if you use a gun uh finally lisp is functional the future is looking very functional to me you know i love this article i i must say that bob uncle bob if you hear this this was a great article there's lots of things to take from this that i absolutely love hey maybe i'm even becoming a fan not of your takes but of the things you write i think this was really great insight the name is the primagen the reason why i went so fast there is i'm literally gonna pee my pants okay gotta pee ah