let's do from c to c plus plus to rust apparently back from haskell i see haskell in there i don't know what's happening here welcome to a code report solution video in this video i'm going to be refactoring some c code to c plus to rust and then also looking at the equivalent half can't you just like take c and call it cpp and boom you got yourself cpp again get that out of my mouth code to see how functional languages influenced rust and if you stay tuned to the end i'm also going to do a short comparison of the number of assembly instructions generated by each of the c c plus and rust solutions which is quite interesting i've never watched this video i'm very excited did you just say you want to see my pp this is gonna be on youtube bisco and you know i read everything you say okay i'm like ron burgundy and i can't even help it now that's gonna be on youtube beast go in my opinion but the first question is why am i making this video a few days ago or maybe now it was a couple weeks ago youtube recommended me on my home page whoa this youtube video from oh can we go back what in the world was going on here what what is happening right there she that is that is something was a couple weeks ago youtube recommended me on my home page this youtube video from a youtube channel okay i love code aesthetics so hey code report i don't know if you know we know each other but i love code aesthetic okay i don't think he loves me maybe he does maybe he doesn't i don't even know but i i love i love code aesthetic okay code aesthetic and the title of the video was why you shouldn't nest your code and the thumbnail says i'm a never nester so i was intrigued classic i love programming youtube videos i clicked on it and then i was very quickly disappointed not to say that the video is oh my god poor code aesthetics am i right [laughter] it's not funny okay we're about love on this youtube channel okay or we love all these people average code aesthetics experience go drama but i was hoping that the video would go in a different direction because it starts by showing you some c code it can we be real here for a second look dude this guy i don't know what he does this thumbnail it's not like it's it's crazy engaging something look at that it's crazy and then says this code is too heavily nested and then refactors it by basically pulling a small piece of the function and just putting it in another function so that it reduces the total amount of nesting okay sure maybe that's the refactoring you want to do it's just not the refactoring i wanted to see so in this video i'm going to show you what i was hoping to see in the video and hopefully it is educational hoping to see and we're starting off and see huh you don't think i didn't get that code report okay i like where you're going with these puns code report funny guy right here i you could just tell right away this guy's gonna be laying down some pretty slick jokes no for the viewers so let us go to the c code that was initially shown in the never nester video check out the link in the description down below if you want to go and watch that foreign sorry every time i see a squirrely brace on a new line i have to swallow the bile that comes up okay we can we can continue that video first we're given a function called calculate that takes two parameters that are integers called bottom and top that form an inclusive range due to the fact that we have a less than or equal in our for loop and we basically have an if statement that's going to form two branches when top is greater than bottom we're going to enter the first branch it's going to declare a local integer sum we're then going to have an index base for loop that goes through all the numbers between bottom and top inclusive and anytime we encounter an even number which we determine using our modulus right here simple to zero we do a plus equals to our local sum and then return that sum at the end of the for loop otherwise we return zero i mean my guess is i haven't seen this one from code aesthetic either but my assumption is that he pulls out this right here and puts this into a new function so that way it feels a little bit less maybe he put some squirrely braces on on the same line so that way it's not as nearly as bad am i right on that maybe that's what's happening yeah never nesters more like never have good code style take that code aesthetics okay remember i like code aesthetics and this is the code we start with hopefully pretty easy to understand and we are now for the rest of the video going to refactor this first yeah and then show the equivalent rest code and then some haskell at the end so the first thing we're going to do is change this to c plus which requires doing absolutely nothing i can checkmate atheist okay all those people coming in thinking that we had to do something when changing it to c plus plus yeah right no no no you just need a color scheme change and boom you're then you're in cpp called it right there piled this with gcc 12.2 for both the c and c plus plus code and it works perfectly fine and for a couple unit tests gives the same answer so nothing to do here we'll look at the assembly generated by both or the number of instructions later but the next change we're going to make is just reformatting this because there's too much white space in this for my liking hahaha he just got oh he got squirrely brace same line dunked on right there a little squirrely brace the dunked on too much white space you know um you know like maybe we could have like less white space somehow if we just really think about it everyone's got different preferences but for the purposes of this video we're gonna make this a little bit more which i prefer this obviously is not a selective change so our first semantic change is going to be using something from c plus plus 20 called views iota so here we are basically replacing our index based for loop with a range base for loop which is now basically looping through you know i feel like every time i look at c plus plus it's like they they have just the longest way to say the shortest thing you know what i mean you know that that previous for loop was just there's just so much less to it this obviously is not a semantic change so our first semantic change is going to be using something from c plus 20 called views iota so here we are basically replacing our index and it's inclusive oh yeah no it's not inclusive it's exclusive this loop is inclusive uh you know i i really don't really know that i'm not a fan of the iota ligma operator you know base for loop with a range based for loop which is now basically looping through each number in the views iota range that is determined by basically the views iota adapter here so it's determined by passing two parameters or one but in this case we want two uh bottom and top plus one because it is not inclusive it doesn't include the last number that you want to so this is basically equivalent code and in my opinion a lot nicer because it avoids you know abilities for uh off by one errors because you don't have to do you know plus or minus increments and a less than comparison you just create a range and i honestly don't get the term iota okay i know he's saying all these things and i'm sure whatever he's saying is really really smart and adept but i'm like super stuck on the fact that it's iota iota is the smallest character in greek right and i know in i don't i don't know i know it's using go but go goes crazy iota yeah iota integer to ascii range i'm super confused i i'm super confused right now uh but my i'm more stuck on c plus and what it the hell's of views and then you can use a range base for loop much nicer the next semantic change that we can do now is to add a views filter along with our views iota to basically replace the if statement that we have checking for even so we can filter out the odd numbers by basically going no no no no no no no no no no no no no no no no no no no no no no no no there's there's nothing semantically worse than a c plus plus uh function like this oh my goodness the empty capture group and auto i hate auto and c plus plus it's not because auto is somehow like you get this nice inferred ability every lsp in the universe just returns i don't i know that's what it returns it is just the worst to work without i hate working with auto but i would like to say i use auto like wild okay hey just re real talk i used a lot of auto okay because i'm i'm evil i'm a mean individual oh my goodness i really am not a fan of this and i didn't know this bar operator what is this bar operator it looks like a bit wise or operation on on an iterator oh they overload it oh yeah i forget c plus plus you can just overload operators uh i'm stupid they overload yeah yeah they overload a bit a bit or yeah yeah yeah yeah i'm stupid i'm a stupid man i'm stupid man going filter even where even is a lambda that's um above our range base for loop now that checks the modulus 2 equal to zero to determine if our numbers are even so this is quite nice in my opinion once again comes from c plus plus 20 so you have to using the c plus 20 version in order for this to work and then the next thing we can do is basically replace our for loop and our local integer sum with a collection to the c plus plus 98 i believe uh numeric algorithm stood accumulate so we can basically get rid of did he just say stood i've never called it stood accumulate or accumulate this studs are accumulating hard in my front yard yeah i've never heard that okay that's fine i hey i'm not a big c plus plus guy i'm not a big c plus plus guy yeah i know i i could handle things tj but now that he's throwing out stud like that i don't think i can do it um i mean this is this does feel better i guess in my base opinion it's based okay everybody feel good uh i would say that in general i'm okay with this i'm used to the fact that iterators you have to do this like doppagin.end bullcrap um it is what it is local some and now we have let's go boys big dick energy you guys got some dr pepper i love the asman gold ai machine by the way all right let's keep on going i have uh an even local variable which is our lambda and then evens which is a composition of our iota and our filter from the c plus 20 views and then we can pass this to our stood accumulate numeric algorithm begin and end of our range of evens and initialize this to be zero and just return this directly so already here you can see by using more modern features some of them are not that modern because stood accumulate existed in c plus plus 98 we have reduced the amount of our nesting drastically but we can continue to go further so the next thing we're going to use is actually not in standard c plus plus yet but we will be getting something like this i call it i believe c plus plus 23 which is the standard that is being uh you know adopted or implemented right now so depending on when you're watching this in the future you might actually be able to use this without calling on a library here we need to use the library though which is the range v3 which gives us access to a ranges accumulate so this is not the standard accumulate and this gives us the ability to pass the range directly as our first argument to our accumulate algorithm so we still have the zero at the end of our accumulate algorithm as the initial value you know people do say rust is ugly okay they say that you know i i actually don't think this is that all that bad i mean c plus plus is an ugly ass language like if you go into writing c plus plus like you're going to have some nice experience it's just straight up ass okay it's always badass it's always going to be ass you know the the the the meme with the gun and the astronauts this is ass this is pessimistic code yeah this is the pessimistic code that casey was talking about i've been working in c plus plus for a long time and a short time all at the same time and just because i've worked over a long amount of years but only in short little spurts and every time i do it i hate it but i never get to use any of these modern features okay i never get any of these really nice features i'm just writing good old-fashioned const reference accumulator nonsense for for goodnesses okay but we don't need to declare a local called evens and then call the dot begin and dot and we can just pass the view directly which is even nicer in my opinion and there is one next thing we can do but before we're going to do that we basically are going to get rid of these stood views namespace because at this point it's going to make the code a little bit messy so if we just declare namespace rv equal stood views we can replace the two stud views with rv and at this point we can now make our change which is going to irritate some people why is it rv how did we get rv out of this how how did we get rv out of this okay i don't i i swear the animations are really nice recreational vehicle coding yeah i don't know how we got rv on this one there must be a reason for the r ange views hmm but these are standard views because there is ranges these are standard views these are svs okay because i know there are some people that hate the ternary operator but we can get rid of our if else branch because we're basically doing two things that do returns real views stop that that is the uh don't do that don't do that just people honestly it's always worth it just take this stupid line of code put the effing if statement right here return early and then just return this you know why because there's that moment you want to log and the moment you want to log it always ends up you have to rewrite this anyways and it's just the worst experience in the universe just do the thing you know what i mean just do it just just make the if statement it's not worth it it's never worth it ternary operator and to be fair i do like ternary operators if it's like this or that and it's something small but it's just it always feels like every time i use it i always end up regretting it right i know i say it but man i always end up regretting it surely the iota thing should handle the topping lower than the bottom surely it should don't call me shirley though it basically has two different branches now so we check his top less than or equal to bottom and this we're just inverting the comparison to be able to put the zero first and then otherwise we do our call to ranges accumulate that is a composition of iota and filter for some reason yeah debugging this is really hard uh it's one of these problems about i mean anytime you have these type of mappy type operations debugging is difficult the goal of these things is that it reduces the amount of change so that you shouldn't worry about this right like that's the whole thing is that it comes in here and you know that okay i'm only filtering on these but every now and then your filter gets us just a little too complex and boom it sucks to debug you know what i mean i i'm not fully on uh i'm not fully on the functional terrain just because debugging is kind of a pain in the ass sometimes that have never seen any of this it might seem overwhelming but once you get used to this stuff in my opinion it's actually much much more readable than the code we started with and it's more declarative i don't i don't mind this code i do think it's nicer i think the previous one was like overwhelm like if i knew what ranges accumulate meant and rv iota and rv filter meant right like if this was a normal thing for me to see this would be really really easy to understand right now remember readability is a function of experience this is very experia he's had this experience many times so this is very simple form uh you know when i'm in rust and i see the exact same thing in rust it feels very easy okay so i mean i feel like it's one of those things where it's it's totally easy if you're used to doing it a certain way i know they're all saying it's not readable this is dysfunctional i assume this is beautiful if i did a bunch and sure it makes use of a turner expression i'm a big fan of the turn nearly expression because it leads to more declarative code no it doesn't it's not ideal it's so frustrating just give me imperative is always almost the right answer i've seen very few times imperative not being the right answer ideally i'd be able to pipe the ranges accumulate um after the iota and filter but unfortunately we don't have that in c plus plus however it'd be nice if we had a pipe into it we can do the exact same thing we're doing here except just slightly nicer yeah except it's actually way nicer and it's the following so note we no longer have need this is the code that i made in my head handles the case where um bottom is going to be less than or equal to top c plus plus doesn't handle that case the c plus plus just go on forever [laughter] it's like well i'm adding one it still hasn't happened yet i don't know what's happening here i know you said that tj i just had to believe i know it raps eventually you know you're eventually going to get that four billion times through oh my goodness it's a rapper using the dot dot equals operator that forms a range this is really nice by the way we don't have the pipe operator here but we have filter and we have a built-in sum which is the equivalent of our accumulate our lambda is much much more uh readable and concise in my opinion and this is the epitome of beautiful code uh i would say missing the return explicit return loser uh no i'm kidding that's just me right uh but seriously again for people that are new to rust this looks really unreadable but for someone who's been doing rust for a little bit this is really straightforward right like this is exactly what i expected to see in my head and this is exactly what i see i would reformat this a little bit differently for slideware but you know this is basically the exact same it's very readable the font a tiny bit bigger and it's slightly more readable but rust format would keep this all in one line however when you do start to chain these operating operations i would say like this is one of my favorite features of rust right here is the fact that they have a built-in range and the range becomes something that you can interact with uh it turns into an iterator or it is an iterator in of itself like i really love that there's syntax dedicated to making a range right this i think this is just a very important concept in programming and it avoids a whole catastrophe of off by one errors and you know in reality i have off by one errors all the time right it's just totally normal for those that don't understand that means from bottom up to top and including it that's the equal sign then it's going to filter e it's weird i would have used x i'm always an x kind of guy not an e kind of guy e doesn't make any sense to me e is just every single letter that or every single number that comes out of here right so if bottom was zero top was five this filter would get called with zero one two three four five e of course modulo two equals zero bam bam bam returns true for every even element then you sum it pretty straightforward right e is for even well that doesn't make any sense because it's not even until they do the check e is for exception or even or error or w element oh it's an element y'all don't make any sense okay but it's making even so it's for event it's for erection actually it's for full-on rust based erection s together and go past a certain length this is how rust format would format it and this is just absolutely gorgeous in my opinion um the i32s are more informative than the ins which are implicitly on most platforms in 32 underscore t just super beautiful lambdas you know these are the iterator this is sort of using the iterator trait which is the spiritual equivalent of ranges in c plus 20 and c plus plus 23 rust is phenomenal here for i do like the spiritual equivalent good call you know pieces of code i can't interact like i mentioned before you don't really make use of the turner operator because the range created by the double dot equal operator is okay okay tj got banned tj got banned okay tj got banned tj oh flip can you keep uh the shilling to a minimum tj asking for shilling to a minimum [music] here's the deal here's the deal karen this is what i was thinking personally is that if you can place his laptop on several t's individual tees i will go get my driver go home right now lunch hour it and we could see how far this thing can fly that's what i'm thinking personally that's a good way to fire somebody uh else we could just lock him out of his email and let him discover that tomorrow which one do you think is better uh i'm personally more the aggressive kind personally [music] all right i'm very excited about this care of that case where um bottom is sort of less than top and it's just going to automatically return you zero absolutely beautiful and at this point some of the most astute observers and viewers of this video we'll be thinking in your head the rust code is actually not equivalent to the c and c plus plus versions of the code really and that's because not because i think i made a mistake or the rust code is wrong but because i think there was a bug in the initial c code that got carried over to each of these c plus solutions and i wonder if anyone has seen that bug if so hit the comment section down below and said i saw it first but basically that bug i think is the following if you take a look at this for loop the range that is defined by this for loop is an inclusive range it starts at bottom increments up to top and includes top it's a less than equal to top however the if statement does not cover that case on the bottom is equal to top that's behavior so if we have top and bottom both equal to six it'll return zero however based on this for loop you should actually return the value of an even number if both top and bottom are equal to that even number and the rust code will return you six uh you know that's kind of hard because you got to follow like the logic that's already there so unless if that is explicitly the bug because you know the function's called calculate we don't know what calculate does we don't know what it's supposed to do and so i would actually argue that this is incorrect then and that should just be an edge case that's part of the edge case right that's part of it that's what you get that's the kind of life you have to live that's that right big if true yeah it's a big if it's true you know what i mean which is why i think it's not actually a bug importing it from c and c plus to russ it's a bug that is not actually it's it's a bug that's materialized if you have the proper unit tests and i guess if you had the unit tests and c and c plus plus in the first case you would notice the bug and you'd fix it but the point here is that if you were thinking in your head there was a mistake porting this to rust i actually think that materializes the bug in the cnc plus code not in the rust code itself so food for thought maybe that is what the initial intent of that function was we'll never know but that's my guess i also dislike that if he were to do the initial code he'd had to put an if statement here and then since he's using implicit returns he'd have to do an else statement as well to else zero i i've always i don't like the else explosion that happens with implicit returns i hate that i hate elsa's elsa's i don't like that i don't know why i don't like it it's so unreasonable of me i just hate it i don't know what it is i don't know why i get so worked up over the smallest things right like i can walk into a project and there can be five levels of inheritance i'm like got stupid uh but then there's like an if else and i'm just like you come here with that big nfl saturday right like i i will lose my over the stupidest thing in the universe i don't know why i don't know why it just it i don't know it's just so stupid you know literally yeah i know it's it's dumb it feels dumb if maybe we can contact the author of code aesthetic and ask ask them all right i promise equivalent haskell code which is actually quite similar to the rust code and that's because rust was heavily inspired by the ml language family and you know some people say it's more influenced bio camel some people does ml stand for modern language what does ml stand for okay i'm gonna ask a stupid question i'm gonna be vulnerable i'm being vulnerable okay i'm being vulnerable right now machine language means chad it actually just means chad i'm gonna go with machine language on this one i will not be listening to the meta language call outs here it's more information that is a company so i don't know meta language there's many meta languages okay so i don't know what you're okay it stands for metal ligma okay mommy love oh potatoes very similar languages when comparing it to c plus plus and c and this is the haskell code so you'll note we are also defining i can totally understand why haskell is completely useless you know just an immediate look at this i can just completely understand why haskell is useless right you can just see it right away um a range using the dot dot operator very inspired and then we are filtering even we have a built-in even predicate so we don't need to spell it out in haskell and then we just sum after that and if is is dot dot inclusive i don't want to look at apl so dot dot is inclusive that seems like a big big big miss okay so how do you read this okay so just to be specific let me let me try to understand how to read this i'm just gonna guess calculate takes in a bottom and a top and we are going to sum the result from a filter of even over the range of bottom up to and including top oh no you go right to left okay so we take the range of bottom to top only have the even items out of it because it's a filter even so this dollar sign must be some something i don't know what this dollar sign is and then those values are summed oh to exclude you have to put a bang dollars are pipes is basically let's see dollar and basically adds parents from there to the end of the line that somehow made no sense to me oh wait a second it adds an opening and a closing is what you're trying to say uh [music] okay i really don't understand this little top definition up here i don't know what's the what in the world's going on up there okay and is it so dollar makes parentheses is that jquery is this jquery inspired language if we compare these two you can see how similar they are and that they are very much you know spiritual equivalents even though rust and haskell are i don't see it at all i don't see how this is equivalent at all i feel like i'd have to like relearn programming to do haskell whereas i feel like this one i didn't have to relearn anything yeah this is definitely like second cousin business third cousin business right here um i feel like i have to i have to reorient my mind to understand haskell yeah i'm climaxing hard on realization right now whereas with this i'd say if you have any understanding of basic c languages you could probably you could probably get by on what happened here you know what i mean like just basic c language you could probably guess like this might be a little bit confusing um but this is obvious right i think nobody here would have a much questions on what this is and i think this is pretty obvious okay i did this even stuff and then i summed it okay so what the heck is this um right you see the difference in special character typing though right i don't really see it that syntax is weird yeah but you could guess what that means it may be weird but i have a strong inkling that you can guess what this means i could guess what that means different languages all right so that is comparison of c to c plus plus to rust and to haskell all of the links to these solutions and each of the sort of changes he didn't even explain this i would love to know what this means right here this must be the definition but i don't understand what it means an int to an int on an int i don't get this like to me it would have been int comma int arrow end meaning like we take two ins in and we produce one end out but i don't understand the int to an inch to an end it's curried oh so the last one is the return the first one is the curing amount or the this is all occurring and this is the return last is return first is curing or let me say it this way last is returned the rest is occurring you can pass calculate 10 and get a new function back oh my goodness i just had a braingasm i'm not gonna lie to you i would hate debugging haskell i would hate it i would hands down hate debugging haskell think about how many things are curried you don't debug it your replica oh my goodness like because i i truly hate debugging higher order functions and it's just one of those things i warp death i love how you say it in such a simple way actually it's just called partial application you can partially apply my foot in your ass okay how does that sound does that sound good or do you want to do a full application what are we looking at uh because here's the deal i hate i i hate debugging higher order functions it always ends up being like a print crazy town right like you just have to print everything because you have to figure out what in the world your state is stop being a hater i can be a hater all i want i hate higher order functions okay i i worked on a team with 50 people and all 50 people thought higher order functions were awesome and you know what we don't think higher order functions are awesome anymore took a long time to debug the way the hell out of that thing uh granted this was also in javascript i'm not sure if javascript makes it inherently worse perhaps there's tools or language features that make it easier and haskell to understand but i don't understand it you know what i mean like i i only have javascript a version of it love to hate yeah there's haskell is not the same as jobs exactly so there's probably some features you know that make it easier js makes everything worse i would agree javascript does make everything worse if there's a feature in any language javascript somehow managed to always make it worse every single time every time i don't even know how it's possible they could do that it's crazy this will be linked in the description down below in a github repo that i call content but i also promised that we would do a comparison of the count of assembly instructions generated by each of the c c plus and rust uh pieces of code so this is that comparison so you can see on the very far left we have our c code and note that the green and blue bars correspond to compiling with the ocean bars buyers fatalisk so this is that comparison so you can see on the very far left we have our c code and note that the green and blue bars correspond to compiling with the o2 and o3 optimizations the equivalence in rust are i think hyphen opt hyphen level um two and three and uh i think those are equivalent in these cases or all cases i can't remember actually what version i compiled with ross i think was 1.63 but um the details are in the gobbled example that's linked in the repo that i mentioned that you can find down in the description down below but if we walk through these not super in detail but you can see that c c plus plus and the reformatted c plus plus all have identical assembly uh generated assembly which is great because you would definitely not expect anything formatting to have an impact and uh it's great it's so that means this thing so i you know i never know it does more instructions mean it runs slower i know i don't know how true or untrue that is right because if you unroll a loop it can be like longer and so it doesn't always mean it right like can you can you strictly say that is this one slower than that one yeah i mean that's like let's see you can't know until you run it yeah it's a computer okay here's a checkmate um it's just yeah it's interesting though i mean what's what's interesting right here is why did these all get so long on the next level of optimization like all right i don't understand why those things got so long and i also am confused why iota is not like an equivalent like how is that not compiled identical because in the end you're just adding a number right i i'm very confused how they didn't come out to be the exact same cmd maybe okay okay send these nuts i see that c and c plus plus are identical here um because you didn't change any of the code views iota does increase i think o2 by an instruction or two and o3 by a few instructions uh but what's very interesting is that views filter um changes it a lot so it increases the number of o2 instructions but decreases the number of o3 instructions then a stood accumulate ranges accumulate and the ternary operator change nothing and c plus format which behind the scenes this was sort of left off the slide deck i please tell me that that he he literally didn't just format his code and it changed it i was using i believe stood io.h for each of these but i wanted to see what the impact of using the c plus 20 format library and the increase there was like or two okay in both the o2 and o3 uh generated assembly so read into this what you will a bit a bit interesting that the o2 was shorter for up until the iota but then it completely switched but on average i guess it's the same across them i don't really know i'm not an assembly expert uh but then we get to the very end rust o2 and o3 are the same and they had 50 instructions uh for both of those cases so does this make a difference at the end of the day i will leave that to the viewer to determine and you can debate in the comments section down below i will conclude the video there uh i hope you enjoy trying to get some engagement right there okay should we debate this i think the real thing is that we need to debate this okay we're gonna debate this we got to get in there um see the thing is that iota's greater instruction count is due to the fact that iota being the smallest character sometimes have the largest impact both metaphorically and literally seems about right i'd say that that was a correct take i don't know where my comment went oh it went right below here i feel like that was the right take it's not about the iota it's not how you use them it's a hot take i know enjoyed hope you learned something and there will be a follow-up video being released about two days from now which is going to be a behind the scenes of how i made 10 of this video because the number one question that i get is how do i do my code transitions and if you are interested in finding out be sure to subscribe and look for that video in about two days from when this video i wonder how i curious what to use this what is that congratulations you took perfectly readable code with logical progression easily debuggable and turn it into a nice spaghetti the boomer in me would say that's what is wrong with the new generation i mean it's pretty good powerpoint no