with the impending collapse of the u.s banking system i've been looking for new ways to make some money and with all this hype that i've been hearing about crypto and bitcoin i decided i took some spare hardware i had laying around my house and turned some of them into bitcoin miners in particular i'm talking about my son's baby monitor over here strapped with a hefty little arm processor down there surely it should make a strong minor to do this i designed the following system for my quick little cash scheme first i'll have the bitcoin node running on my pc the bitcoin node will give me block information and target information about the mining that i have to do i'll use an arduino to feed the block information over rs-232 to the monitor to do the work i'll feed the block and the target up to the baby monitor when the block is solved i'll make my block reward which is 6.25 times a bitcoin value right now roughly 125 000 and then we can stop sounds easy enough the bitcoin algorithm is actually pretty simple the network gives nodes a block to solve the block is a 76 byte string you then take a 4 byte cryptographic nonce a random value and impend it to that 76 byte string making it 80 bytes you shaw 256 that string and then shot 356 the result and if the output is less than the given target value you've solved a block the size of the target or the difficulty is able to scale based off the mining power of the bitcoin network which keeps it so that the mining network is always producing a block every 10 minutes to get this all to happen on my baby monitor and make some quick cash i had a series of problems to solve problem number one get code on the monitor this is easy enough in my previous video i found a fizzmem read write function that i was able to use to rip the memory off of the device whoa let's go baby we're hacking yeah i discovered i was able to use the exposed write functionality to write code up to the monitor cool so we're gonna go into here we're gonna do minicom biz mem read write hex 150 the value 10. okay and there you go that's actually actually pretty sweet the reason why i'm so excited is that being able to overwrite code anywhere means that the entire operating system is overwritable meaning i can put my code pretty much anywhere this gives me a lot of power problem number two what code okay good point using the embedded arm cortex build chain and a fancy linker script i was able to produce code that was able to be ran anywhere in the device not in assembly but in c i could have done this project in assembly but doing it in c made my life a lot easier and a lot less painful let's call this start writer pushing the frame pointer making room on the stack moving r3 to zero and then there we go problem number three triggering the code we could write code and we can upload it but all because we put it somewhere it doesn't mean that it actually gets ran so how do we trigger it well luckily we found a function table inside the device that had all of the function pointers that get called when you ran various commands on the device like help in the help menu for example by overriding the function pointer for the help function we could have that function pointer point to our codes that when we type help on the cli our code gets ran and now finally we could run our first test check this out ready i'm gonna type the word help hey yo what that dog doing so not only did i fix the code and i made it so that it does get where you art print i found a place where i can hook it and make it triggerable this is awesome so at this point we were able to write code that got ran on the baby monitor and it was able to run without crashing also we could control when it got ran by running the help command which we took control of at this point all we had to do was append our shaw 256 code to the code we already had and we were in for some quick cash problem number four sha-256 code is very very big it's not that big in a regular sense but this device does not have a lot of memory we are currently putting our code into a code cave a code cave is a place in memory that isn't really used and it kind of has some spare room where you can stuff additional code but typically code caves aren't that big with the shaw 256 code appended to our code we no longer fit inside of that code cave we have to come up with some new techniques i decided to break my code into two parts the first part was a tiny little loader that was small enough to fit inside out of that code cave the loader would malic the proper size for our code to get ran it would reveal to us the address of that malik buffer and we would upload the code to that bigger buffer and then run it from there yes the heap is read write x i don't know why don't ask me this one's gotta be it gotta keep address boom okay sweet what just happened is loader went up my code triggered the loader to allocate a heap address it sent that heap address to my script my script then took the larger payload and is putting it into the heap i can then go into the device and manually trigger my code and what it should say is hey yo what that dog doing that's it how can i say help ayo what that dog doing [ __ ] yeah dude problem number five and i swear it's the last problem the shot 256 algorithm takes a long time to run in real life terms not so long but in terms of a real-time operating system it's a lot of for loops because of this the watchdog on the device that needs to be either tickled or kicked depending on your opinion on dogs will crash the device if it's not tickled or kicked in a reasonable amount of time okay so the code is there so if i go back and do help ah at this point i'm very frustrated because the shot algorithm takes so long to execute the watchdog is taking down our device now we could find the code on the system to tickle the watchdog but instead we're just gonna wholly disable it with the watchdog completely disabled we are able to run any code that we want that can take as long as we want it to without the device complaining in the form of a crash or a reboot so now we can implement the sha-256 algorithm and begin to harvest our bitcoin here we take in the block string and the target string in hex from the user we convert them to binary and then we walk through every nonce from zero to quad f and if the resulting double shot 256 is less than the target we tell the user and collect our funds and here we go at a whopping 4096 hashes per 5 seconds or roughly 812 hashes per second we will have our first block solved in about 200 billion days now if you compare that hash rate on the monitor to the hash rate of a modern asic which could do anywhere from 10 to 100 tera hashes per second we are off by a small order of magnitude no big deal we may make our money back in the short term but you know we'll have to see about it if you want to find out hit the sub button and then go watch this video that youtube thinks you will find really really cool click on it it's right it's right there man just click okay bye