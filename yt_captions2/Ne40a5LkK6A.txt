[music] hello everyone a little while ago i put out a challenge for anyone interested to try and program a tiny chest bot the challenge came with a simple framework for things like getting the legal moves in the current position keeping track of which pieces on which squares and so on but the actual brains of the butt was entirely up to the contestants because out of the box it played like this as an extra challenge entries were also limited to just 1,000 24 tokens of code where a token is a single element such as a variable name an operator and so on and doesn't include things like comments which are of course for human eyes only this is counted by the c compiler which turns the code into something called a syntax tree as a first step towards translating it to something more machine readable so all of the leaves of this tree are the tokens which come towards the limit an alternative approach would have been to simply limit the the size of the source file although then you're compelled to minify everything turning variable names into a single letter removing white space and line breaks and so on in hindsight though maybe providing a script to just do that stuff automatically would have been a better approach because while i tried to think of all the possible exploits ahead of time as soon as the challenge was announced people of course added scheming up clever ways to cheat the system such as using this line directive which i've never heard of in all my life to store an arbitary amount of data inside of an error message and this is handled as a pre-processing step so it wasn't getting counted towards the limit and one could then intentionally trigger the error and extract the message several such creative workarounds were reported and outlawed in the first day or two but one huge exploit remained undiscovered until just before the end it turns out i had accidentally used an outdated version of the c compiler to do the counting which meant that in some fairly obscure cases it could become confused by new language features and start miscounting the subsequent tokens only one entry actually risked using this exploit though and just to gain about 30 tokens in the end so thankfully it didn't undermine the whole tournament now a few buts did unfortunately exceed the token limit in the regular way and so sadly i'll have to disqualify those there are also a few buts disqualified due to compilation errors most of which were just blank entries and then a number of bots used name spaces that technically were not in the allowed set but after reviewing them manually this really isn't giving them an advantage i'd say so i'm going to be lenient there with the exception of the bot not at all which was the only entry to try and sneak a network connection into the code to fetch moves from a web server at least i hope it was the only one in any case we're at last ready to begin the tournament and with 600 26 bots competing this is probably going to take around 48 hours to run so while this is going let me just talk about the format quickly this is a giant swiss tournament which means that in the first round the butts are paired up randomly but after that butts with similar scores are paired together so long as they haven't played each other already now this is going to go on for 64 rounds so that's about 20,000 games which i hope will give enough time for the strongest spots to work their way up to the top of the ranking then once the swis is complete the top 64 will play a final knockout tournament to determine the overall winner these games are played with 1 minute per side by the way and in a slight change of plans there's also a 0.1 second increment after each move just to mitigate the overhead of running a bunch of games in parallel all right now i'm excited to see how everyone has gone about implementing their butts so let's just pick one at random and take a look churo champ faithful by pure riro was one of a couple of attempts at recreating possibly the first chess program ever written by computing legend alan turing and david chanon although it was never actually successfully run on a computer and had to be painstakingly executed by hand some details of the original implementation have unfortunately been lost to time but a classic mini mac sech was used here along with alphab beta pruning to speed it up the author does note that alphab beta pruning actually been invented yet at this point but that uring couldn't be bothered to consider moves that were obviously bad when running it by hand at least so it seems faithful enough to put it in although the speed isn't actually needed here since for similar reasons the search has been limited to looking a maximum of three moves ahead i was impressed to see though that the original authors had already come up with this extremely important idea of a quon search where that main search is extended to examine all possible captures so that the evaluation function doesn't have to worry about the complexities of trades or sacrifices now in this evaluation function we can see that each type of piece has been assigned a material score so that it can count up the value of the pieces on the board beyond that it also gives a mobility bonus to each piece and we can see here that this treats captures as two moves to incentivize attacking the enemy i suppose it then takes the square root of that meaning it's very good to have at least a handful of moves available to each piece but after that it doesn't matter as much anyway each piece also gets a safety bonus if it's protected by another friendly porn or piece with an extra bonus if it's defended more than once this doesn't apply to the queen though which makes sense because it's so valuable that it almost always has to run away if it's attacked and the king is also excluded from this but it actually has its own personal safety term here where we look at how many moves it would be able to to make if it were a queen and then treat that mobility score as a penalty to encourage keeping the king covered up it also gives a bonus to pawns based on how far up the board they've managed to move while being defended by non- pawns in particular for some reason finally it has some incentives coded in for castling or being able to castle in the future as well so let's see how this historical bot fes against a random competitor whatever bot by el holden is one of a handful of entries that attempts to play a decent game of chess while never looking further than one move ahead so over here we can see that it has a little routine for finding out which of its pieces are in danger which it does by making a list of all pieces that attack or defend the current square sorted from least to most valuable it then goes through these lists to see whether the opponent has a lower value piece that will be able to capture a higher value piece this this does have a pretty major flaw though in that the attackers and defenders are only determined at the start of the capture sequence which excludes pieces that are stacked behind one another that is tricky to handle without actually doing a proper search though which would go against the premise of this part so anyway it then gives a score to each move based on several rules of thumb such as advancing the central pawns developing the minor pieces and castling of course it also aims to capture the highest value enemy piece with its own lowest value piece along with an added bonus if the captured piece was threatening one of those pieces it detected earlier to be under attack then over here it does do a little test to see if any of the opponents immediate responses can put it in checkmate which i guess could be considered as looking an extra move ahead but whatever it then has a bunch of code for trying to figure out whether making this move will endanger the moved piece or or any of its comrades and applies penalties based on that before finally choosing at random from the most promising moves it's found so quite an involved process but it's definitely an interesting challenge to avoid the very thing that makes computers so good at chess which is of course their ability to crunch through tons of [music] positions the whatever but seems to be doing a good job so far of not giving away its pieces while tur champ makes some highly dubious pawn moves around its king i have a feeling this game won't be decided by the finer points of strategy however and sure enough here we have a horrific blunder that's tricky to detect if you're only looking one move [music] ahead i'm not sure why black failed to protect the knight though there must have been a sneaky bug in the logic and anyway let's see how this ends okay now i'm curious to see where these bots ended up in the rankings so out of 626 competitors tioch champ faithful managed to come in 20 15th and by the way the modern version with an unlimited depth and some minor tweaks achieved an impressive ranking of 85th almost good enough to make it into the upcoming knockout round whatever but meanwhile finished near the top of the bottom half with a ranking of 385 just for fun let's see it playing a quick game against pess which was another attempt at this one move look ahead strategy obviously this is not exactly the most scintillating chest to be found but there's some fun to be had in watching them flil around i suppose and i think it was a cool self impose challenge that these two authors and several others decided to take on and by the way here's what their games look like when they're not being slowed down so foress managed to win this particular game and in the tournament achieved a rank of 338 i'm going to start uncovering some of the surrounding rankings as well because we won't have time to look at all of the bots individually of course but i certainly want to explore a bunch more so let's grab another one at random and here we have apple method ors by red black tree this but takes a very simple approach to evaluating positions all it does is assign a value to each type of piece and then adds those up actually there's also a tiny bonus given to whoever's turn it is to move plus a random jiggle to the score to prevent the butt from repeating moves when it doesn't know what else to do the way it searches positions is interesting though we can see it's given a node budget based on how much time it has remaining and then it starts by guessing the evaluation using the function we just saw and if it has exceeded its node budget then it returns that as the final evaluation otherwise it gets all the possible moves and assigns each of them a weight based on the evaluation of the current position plus the evaluation after each move has been made and this is intended to gauge how promising each move is because i guess a high value capture would get a large weight for example and and then based on that each of them is given a fraction of the remaining node budget to use for further investigation inside of this alpab beta sech i wonder if this is any good so let's pull up another random opponent for it to play against egis by death file 78 this but has a big table of scores for different types of pieces based on what squares they're on known as a p square table although the author mentioned that they had to leave out the scores for kings queens and rooks due to running out of tokens so some kind of compression scheme might be necessary when using a p square table approach in this challenge performance was also mentioned as a big struggle which i think everyone writing a chess engine can relate to but some unsolicited i'd like to give here is to avoid constantly reversing the lookup tables to flip between the white and black perspectives it is a nice intuitive approach but it's going to slow things down a lot and it would be much more efficient to leave the array untouched and instead figure out how to adjust the indices based on whose turn it is to move in any case the given move is assigned a score based on how much the piece likes the square it's moving to versus how much it like the square that it was on already there's also a function for counting up the material values of all the pieces on the board and these two functions are used together to evaluate each move inside of the get best move function which searches recursively to a fixed depth of three ply to avoid using up too much time some extra bonuses are also assigned in here for example encouraging pawns to move forwards when there aren't many pieces left on the board and also favoring moves that promote a pawn castle the king or put the opponent in check a list of the best moves is made throughout this process and one of those is picked at random to be played so let's watch these two butts fight it [music] out [music] okay a strange night sacrifice here and i think what happened is that this knight is trapped so black saw that instead of letting white capture it for free it could sacrifice the other one and at least win a pawn what's unfortunate though is that the first knight is actually still trapped black just didn't see far enough ahead to realize it this is a problem that plagues any chess engine that makes the grave mistake of not looking infinitely far ahead which is of of course all of them although stronger engines do use many tricks and techniques to try and see further in critical lines okay apple method is just cleaning up at the moment and now a deep think before delivering checkmate let's have a look at the rankings so egress ended up in rank 306 and i'll again reveal some of the surrounding neighbors here apple method meanwhile achieved a ranking of 232 which is quite impressive especially considering that it only used up about half of the token limit so i thought it might be interesting to make a little plot in this plot we have the number of tokens used by each but on the x-axis versus the ranking of the but on the y ais going from worst to best let's see how that comes [music] out so unsurprisingly we can see that the very top entries up here have indeed all squeezed pretty much every drop out of the token budget although so too interestingly have some of the lowest rank such as bad apple bot i wonder if that's doing what i think it might be doing so a week or two into the contest i found that a lot of people were understandably getting a bit confused with the bitboard api i provided which lets you figure out stuff like which squares is the enemy currently attacking for example so i patched in a little helper function to visualize the bitboard meaning that now instead of just being given some mist ious number to work with you could actually see what that value represents so if you're familiar with the bad apple phenomenon you probably already know where this is going but let's nonetheless load the butt in and let it run for anyone out of the loop this music video has been played in pretty much every conceivable way from graphing functions on calculators to sheep in minecraft to oscilloscopes and now bitboards i guess hopefully someone in the comments can explain the law behind it though because i don't know anything about that now this obviously doesn't have tremendous merit as a chess engine but i am still curious to have a quick look at how this was actually implemented because it does seem like quite a lot of data that needs to be packed into the size limit so the author mentioned that this is their first time experimenting with video compression but they've come up with the nice idea of storing the number of frames that pass for each pixel before it toggles color since of course the video is purely black and white they also had the idea to store those frame counts with varying numbers of bits to be able to take advantage of the fact that some pixels tend to switch color more frequently than others so we can see that hunk of data over here which is the first 2 minutes of the song before the butt ran out of tokens then then here's how it's being decompressed and played back i thought that was a fun concept and it shared the honor with worst butt ever made of coming of course in dead last let's return to this plot for a moment though because another thing that caught my eye was this little cluster of outliers that used few tokens but seem to have performed disproportionately well these are ss comp 1 dl comp 2 and most successful of the trio the 200 tokens monstrosity the author o and f seemingly made it their mission to create the strongest spot possible within their own personal 200 token limit because apparently i was far too generous with the constraints let's open it up and take a look at the code there's not much of it so what's going on in here we can see it's searching through all the moves and first sorting them actually so that high value captures for instance are looked at early on since those are most likely to be good it also stops looking at all moves and instead only considers captures once this depth variable drops below zero here in order to combine the main search and the quiescent search into a single function but i want to focus on this interesting little evaluation scheme over here first of all the values of all the pieces have been packed into a single integer to save space and that's then converted into an array of bites and indexed by the type of piece that was c captured or promoted here's what those values actually look like and they're a little strange especially seeing that capturing a knight and promoting to a queen is considered better than capturing a queen and promoting to a queen but corners obviously had to be cut for compression so that's fair enough i find it interesting that it's scoring individual captures and adding them up as they occur throughout the search instead of having a big loop to count all of the pieces that are remaining at the end like one usually does since it only tracks the change in pieces that can obviously backfire in certain cases for example here's a position where white would be winning if black didn't have this annoying little infinite check maneuver however if we play this against the 200 token monstrosity it has no idea that it's down a million pieces and just sees that it can win a rook but that's again a creative compromise to save a bunch of tokens another interesting idea in the evaluation is that it factors the mobility of pieces into the for by counting the number of legal moves similar to what we saw in churo champ but instead of the square root it takes the logarithm of that which means that when the number of legal moves is zero the score becomes infinitely negative which means that the b doesn't need to have an extra condition to test for checkmate anyway one last thing i want to mention is this disturbing way that the author managed to save a handful of tokens in the time management code here the idea is that when the but has been thinking for 30 times longer than it has time left on the clock this value will become negative trying to convert it to an unsigned value will then throw an error which will be caught and ignored over here to immediately exit the search absolutely disgusting stuff i love to see it now let's see how this plays against baby squid this is a bot by game developer and fellow youtuber yonas tra and it's one of only a handful of bots i've seen so far to actually dedicate some precious space to include its own minuscule book of openings as we can see it's been instructed in the ways of the sicilian now much like the monstrosity this bot evaluates moves instead of positions and this is done firstly by calculating how much the move improves the position of the piece where pawns are considered better further up the board and knights and bishops better closer to the center somewhat strangely no guidance is given to rooks queens or the king though anyway along with bonuses for capturing or promoting pieces there's also an extra valuation term that gets applied only if this is the last move we're looking at in the current line in here a mobility bonus is given for the difference between how many moves are available to us versus were available to the opponent on the previous turn and then there's also a penalty applied if the move places a piece on a square that's under attack by the enemy which seems to be intended as an alternative to doing a whole quesence search so some unconventional ideas here which is always fun to see and now let's watch them play so baby squid going with the sicilian of course and the monstrosity bringing its queen out very early which is not particularly wise but it's trying to maximize the number of legal moves so it makes sense from that perspective okay the queens have been traded off and we have a position with equal material where both sides have some awkward pieces such as black's bishop wedged in on g2 although it is actually doing a great job of keeping white's rook pinned down it currently doesn't have any way of getting into the game white's light square bishop is also very awkward and i'm not sure how that's going to get into the game either so baby squid seems to be in the driver's seat at the moment okay but the tables have turn very quickly here and now pawn d5 is almost checkmate black can only go to e7 which is a very uncomfortable place to be on account of this check which is just waiting to happen so the monstrosity is now up a rook for a night and all of its pieces have managed to enter the game so this is looking very grim now for baby squid all right let's take a look at the rankings so baby squid achieved a ranking of 137 with a score of 33 and a2 points out of 64 the 200 tokens monstrosity meanwhile scored just half a point more in the tournament which was enough to put it in8th so we can see the scores are very tightly packed in this region of the leaderboard at least tie breaks if anyone cares to know are calculated using the median bal system which is just the sum of the scores of your opponents with some of the best and worst scores excluded to try and avoid bias from the early rounds where the pairings are still quite random anyway let's have a look at another entry tiny huge bot by pux 21 and atp x8 this entry caught my eye partly because in the description it says we know we might be disqualified let's see what that's all about first of all where's all the code this thing is tiny oh wait it's tiny vertically but horizontally it's actually quite humongous so what this team has done is very interesting they've built this bot builder tiny fire which is almost 2,000 lines of code for compressing and optimizing dll files in addition to that month-long project they spent another month writing the actual chess engine called huge bot which true to its name is indeed rather huge for example let's just briefly look at at one section of this the static exchange evaluation this function tests whether a sequence of captures is good or bad without having to run the actual s kind of like what we saw back in whatever bot but a lot more rigorous although i think it's still doesn't handle pins against the king so it's not 100% accurate but the idea is to use this as an optimization to save some time in the quiescent search by skipping over captures that the static exchange says are bad just the code for doing that is already over the limit though and in total this but takes up exactly 5,000 out of the 1,24 available tokens so to make it comply with the rules this engine was then compiled to a dll file squeezed down and optimized with their custom tinier then embedded into their actual submission using a custom compression scheme based on runlength encoding at runtime that data is then decompressed into the rw bites before being loaded and executed using a part of the c api that prior to this i had no idea even existed using this sneaky approach the authors could probably have simply embedded some powerful pre-existing chess engine but i really like that they went to the trouble of making their own engine anyway i think that's way cooler now just for fun i want to see this playing against the 200 tokens monstrosity to find out just how much of a difference those extra 4,800 tokens have made okay tiny huge butt taking the opportunity here to damage black's king side structure and now black's king might struggle to find a safe home and tiny huge butt has already found a nice way to crash through and this will be checkmate very soon i imagine so the astounding efforts of the geo behind tiny huge butt have earned them the formidable ranking of 13th meaning of course that they'll be advancing to the knockout round next up electric shock wave gambit by valentin is an interesting attempt to try and exploit a loophole in the rules i had specified that bots were not allowed to create any new threads for running code in parallel or in the background during the opponent's turn i thought that was some bulletproof legales but this but argues that it's not breaking any rules simply by creating this unused shockwave object and then forcing c's garbage collector to run the idea is that when objects are cleaned up by the garbage collector it triggers this optional finalizer function allowing you to manually deal with any unmanaged resources you might have and while this does run on a separate thread it's technically not one that was created by the bot so what the shockwave gamit does in here is during the opponent's turn it forces the garbage collector to constantly count and recount the amount of memory currently in use by the entire program significantly stalling the opponent while it's thinking i thought that was a very creative idea and the only reason it's not very effective is that the butts in this tournament are actually being run in their own isolated instances but even though the shock wave failed it still seems to be a pretty strong butt from the looks of it we can see it has a nice little evaluation function simply counting up the piece values telling pawns to move forwards and encouraging pieces to go where they control lots of squares and attack or defend many other pieces along with some endgame stuff to help push the enemy king towards the edge of the board by bringing one's own king closer to it and like most entries it uses a minimac search with alphab beta pruning for searching through positions simple mcts by geno pirata is one of just a few bots to try using a monteo treat instead i know almost nothing about this technique so let's take a look inside its brain we can see there's a little loop that calls this iteration function over and over again this is called with a depth of 20 which means at each time the function will play out some sequence of 20 moves from the current game position at the end of those 20 moves it then evaluates the resulting position by just counting the material and giving a little bonus for having pieces developed where being developed is defined as being inside of this mask representing this block of squares there's also a big penalty for being in check now after each move it updates a counter for the number of times the current position has been reached and also keeps a running total of all the different evaluations that have been reached from this position so i guess unlike a minimac search where the evaluation is supposed to be as accurate as possible having searched through all the possibilities to some depth in this case it's just the evaluation of one random sequence of moves that could happen from here being added onto the evaluations of all the other random parts that have been explored from this point so far well i say random but it's actually smarter than that to choose a move to look at next it weighs up the possibilities using this little equation called the upper confidence bound for trees which essentially prioritizes exploring the move that currently seems to be best in order to increase the confidence that it really is as good as it seems but balances that with looking at moves that have been explored relatively little since even if they seem bad at the moment it's possible that with more exploration we'd discover that one of them is actually the better option and then there's also an extra incentive for looking at moves that capture a piece or put the opponent in check all right so as we saw this function gets called over and over until the thinking time has been used up at which point it plays whichever rout move was chosen most frequently during the search since by definition that's the one that the algorithm thinks has the highest probability of success so let's see how this plays against the electric shockwave gambit [music] that's a bit of an odd place to go with the knight and now this position already seems rather awkward black needs to bring back the bishop or use the other knight to block the attack on the queen because if it blocks with the pawn then white can take and s the threat of capturing on g7 attacking the rook the queen and the knight all at once is just a total disaster and unfortunately that's exactly what simple mcts has decided to go for so we can see that it does struggle with basic tactics it's an interesting approach though and definitely something i'd like to learn more about and experiment with in the future so shockwave gamage came in 61st place just squeaking into the knockout round while simple mcts came in rank 237 [music] out of interest let's actually see it playing against phoenix chess by matias which was another bot that tried this monte carlo approach having watched it play for a bit it does also definitely suffer from the same sort of basic tactical oversights as its opponent so it's clearly a tricky technique to get working well especially with the token limit and so it's no surprise that most people went with the traditional minimax approach instead still i'm happy that some people tried it out anyway and if i do another coding challenge like this in the future i'd like to figure out something where these different sorts of approaches are on more of an even footing so let me know if you have any thoughts about that in any case after a somewhat strange game phoenix chess has emerged victorious and in the tournament went on to do pretty well ending up in rank 176 next let's take a brief look at ilvm by wincent 01 which is an interesting entry because the author decided to focus less on writing a chess bot and more on simulating a computer to run the chess bot so the ilil in the bots name stands for the intermediate language that c is compiled to and vm is a virtual machine so much like tiny huge bot the chess engine itself has been compiled and stored in a big decimal array but instead of of simply handing it off to be run behind the scenes this bot runs it itself by defining its own program counter stack pointer memory call stack and so [music] on the code is then copied into memory and the program starts running so we can see here it fetches each instruction from memory and then executes it for example some upcodes map directly to functions in the chess challenge api while others are more general doing things like basic arithmetic and so on what this is actually running by the way is apparently a depth 3 minia max sech with some sort of very simple evaluation function now an interesting twist on the minx algorithm was attempted in the bot leut byi and antoan so in a mini max search each side is of course trying to minimize the maximum score that the opponent can achieve but that's not quite what this is this is a mini max search where we're instead trying to maximize the average score that we're able to achieve okay i'm just trying to wrap my head around this concept so normally if all of our available moves were terrible except for one that's good that would be perfectly fine we'll just play the one good move whereas here that situation would be considered catastrophic because the average of those outcomes is really bad a very peculiar idea but i'm curious to see how it plays i should mention though that it does revert to the classic minia max in the case of captures because i assume that otherwise it would just be a total disaster according to the authors the sheep's strange evaluation scheme gives it a strong preference for positions where it has lots of threats and captures available which makes sense i suppose since the average of those is probably going to look very promising in and it certainly does seem to be relishing kicking the virtual machine around right now okay finally we get a trade but white's knight seems to be pretty stuck on the back rank my instinct as black would be to develop one of the knights here or here to prevent white's queen from accessing the back rank allowing the knight to be captured the virtual machine goes for a different approach though a much worse approach unfortunately and now seems to be losing all of its pieces all right the sheep is ramming through here and this should be game over any second now so in the end the virtual machine came in rank 351 and the sheep performed a little better with a final ranking of 290 let's now take a look at an nbot by jamie whiting which is one of the few entries to attempt a neural network approach and that was a huge challenge just trying to fit enough weights in for the network to do anything useful so it obviously needed to be cleverly compressed i should probably apologize for all the pain that this token limit has caused sorry about that anyway this does use a traditional miniac search but it then hands the end positions over to the neural network for evaluation so if i'm understanding this correctly we you can imagine this network is having an input node for each type of piece on any of the 64 squares and then inside these loops it activates the nodes where such a piece actually exists for one of the players those input values which are implicitly just one then get fed forward along their weighted connections to a tiny hidden layer of eight nodes actually there's two sets of these hidden layers one used by white and one by black and having zero experience with this i would have expected weights to be shared between them meaning that black evaluates the position in the same way that white does but that doesn't seem to be the case here so i'd love to understand what the benefits of this asymmetrical approach are or maybe i'm just confused in any case to get the final evaluation at the single output node this activation function is first applied which as i've talked about in my own beginner experiments allows a network to go from being simple linear model to having much more interesting nonlinear outputs i'm not sure why it has this upper limit though that's something i haven't seen before but anyway each of these values is then multiplied by the weight of its connection to the output and interestingly a different set of weights is chosen based on the number of pieces remaining on the board i guess to help gradually transition from opening to endgame strategy so those are all summed up and added together with the material value of the pieces on the board which of course the network could take into account itself but since it's so tiny it's probably better to let it focus on just the positional aspects all right let's see how this fars against the bot gam tech explained by gam tech explained this submission actually came with a youtube video attached talking about the process of making it which was very cool to see and it has some really nice visualizations of the p square tables in particular now opening up the sauce code as we can't see here this uses good old mini max satch with alpha beta pruning and evaluates positions purely based on those p square tables the code might not win any readability awards but it is fun to look at okay let's see how this matchup goes so we have a four night's opening which seems to be pretty puff hiller among the bots in this tournament and now an interesting choice by black here winning a pawn but of course getting a damaged kingside stu strcture in return now white's managed to win the pawn back plus an extra but the king has been drawn all the way out into the open which could potentially prove problematic all right a nice little checkmate there by nn bot to defeat game tch explained who ended up with a rank of 78 in the tournament meanwhile nnb reached the ly heights of rank 34 now another bot i'd like to take a look at is king gambot i fourth by twoand this is a bit of a joke entry because country to all establish chess wisdom the king has been encouraged to charge out ahead of his army to lead the attack what i really like about this though is that apart from that one obviously terrible idea a lot of effort has clearly been made to make this engine as strong as possible for example we can see here that the p square tables have been tuned specifically for this engine's play style that was done using this texal tuner by gonus meitus and i was curious about how this works so i've just briefly been reading through the linked paper here and it seems like the idea is to generate a huge data set of games marked as wins draws or losses and then to run the engines evaluation at different points in those games to see how well it predicts the outcomes overall there's then a gradient descent step where the evaluation terms are updated to improve the predictions and then the process repeats so it's interesting to see the values that result from this for example here's the porn endgame table from my own chess engine which was just handmade with the intuition that pawns should march up the board to try and become queens in the end game if we look at the tuned version from king gambot however we can see that while it agrees with that general sentiment it's a lot more opinionated about particular squares often for no discernable reason although something interesting i am noticing is that the flank pawns have been given a higher weight than the central pawns which actually does make a lot of sense since they can really force the enemy to go out of their way to stop them and so potentially lose control over other parts of the board in the process let's just have a quick glance through the other tables from king gambut for interest sake so here's the bishop table the queen table and finally the highly unconventional king table okay let's start by watching a game against that virtual machine bot from earlier to see how this goes against a fairly weak [music] opponent we're about 10 moves in and the king is already on f4 of all places letting this knight in is very dangerous for black though and now it's the black king in fact who is running for his life and that's checkmate but now let's see whether this aggressive strategy will pay off against a stronger opponent such as [music] [music] anbot to the great surprise of nobody i imagine the answer is not at all despite this king gambot iv still managed to mar as way proudly to the 56th rank very impressive all right now i'd like to at last get the knockout tournament going so let's quickly see the top 64 buts who've qualified for that and in the top 10 we have sidin by brol followed by riel by anaris infer daniel by infer daniel tyrants v9 by tyrant thanka weed by american jeff floppy chess by um drip le by jeff legend power along with not listed in the actual submission but i noticed them in the source code aad of a chad gan kevin stri octopus critz outer cloud and table even though he apparently didn't really do much okay that brings us to our top three kinglet by skolan world and abyss small. cs by gonus meitus and go cj and finally the winner of the swiss tournament is boy chessa by minus kelvin analog horse anonymous algorithm and daniel k so let's see who'll survive the first knockout round starting with rank one versus rank 64 so boy chessa versus spaghetto they'll be playing 64 games against one another with each game beginning from a different random opening position although of course they'll both play the white and black side of each opening for [music] fairness in this game we can see boy chessa has lined up against sp's king along the diagonal while spaghetto is trying to stir up some trouble on the se file threatening pawn takes d4 with a discovered attack on the queen so i guess boy chessa should take a moment to step out of the line of fire never mind boy chasa doesn't care about that and plays knight takes f7 instead and the game is already over in the end boy chessa won 62 games drew two and lost zero okay let's take a look at board two small. cs versus al [music] xna small has sacrificed a pawn but in return has alex's queen in a very uncomfortable pin so small ends up with two minor pieces in exchange for a rook and two pawns but more importantly it has white's king in a bit of a bind at the moment in fact if the white knight tries to retreat over here that would already be checkmate so it has to go to some awkward square like h5 but sm could then attack the queen while vacating the b4 square for a devastating bishop check so alex decides to just sacrifice the knight instead and now small should be cruising to victory alex does actually have some annoying checks though and is managing to to chase small's king out into the middle of the board but small sacrifices a rook to regain the initiative and soon enough finds a checkmate so this matchup ended with small d cs winning 64 games with zero draws and zero losses kinglet also had a flawless match against frosco bot while drip le conceded just two draws to the shockwave gambit in fact none of the top eight lost a single game so clearly a pretty vast skill difference in the matchups at the moment on the second page here let's quickly watch a game between riel and king gambot i fourth because gambot games are usually a sight to [music] behold if you're fond of chess puzzles by the way this is a fun one to try it's white to move and m in five [music] all right so riel ended this matchup with 53 wins nine draws and two losses and if you're wondering how one of the top bots could possibly lose to the king gambot ridiculous antics well the answer is a bit disappointing if there's an early queen trade then suddenly it's a lot more safe for the king to wander around so this game ended up in this position where white has a scary past pawn but king gambot was content to just sacrifice its rook to eliminate it because its own past pawns are even scarier all right let's look at the results for the rest of the matchups and i see that the tiny huge bot has made it to the next round and then here's the next page and the last page where i see that the neural network butt has been knocked out by a butt called elon so with half the butts eliminated that takes us to the round of 32 where each matchup will now consist of 128 games since the competition is heating up well at least a little bit with boy chessa losing one game to fulka and smalls losing an entire two games to tuna tactician all right let's take a look at how the matchup is going between kinglet and [music] algenon so kinglet castling queen que side here and elon seems to be lagging a bit behind in development with the king still stuck in the center okay this is looking very scary for black now and kinglet finds a sneaky little night fork which black of course cannot capture on account of queen b3 leading to [music] checkmate and now we have the queen and bishop working very nicely together to hunt down the king so in this matchup kinglet won 97 games drew 29 and lost two then let's see how driple versus fbut is [music] going okay so after some strange opening moves drip has managed to gain an enormous amount of pressure along the f file knight f2 is a funny looking move but i think the idea is that black really wants to take this pawn but the bishop is hanging with jack with this last knight move though black now has the threat of playing knight h3 after which wherever the king moves the pawn capture comes with the added bonus of shak mage so fut tries to defend the pawn with the rook but with all its other pieces still stuck on the other side of the board there's really no way that the king is escaping this attack so this matchup ended with 100 wins 25 draws and three losses for dple and here's the rest of the results on this page then on the second page i want to quickly mention a b called cosmos by guman like many of the top butts it's using a set of popular public p square tables called pesto which have been tuned for some pre-existing engine the big problem with these in this challenge of course is that they take up a lot of space and so a good deal of effort was put into compressing them gan for example actually made a whole write up about their approach where they used a genetic algorithm to try to evolve part of the solution which i thought was a fun idea the details are beyond the scope of this video but it's very impressive to see the clever techniques that people have come up with and here by the way is a visualization of all the original pesto tables versus the lustly compressed versions that this author has created i can't say i've fully wrapped my head around what's going on in the cod here but clearly some very nice work nonetheless just for comparison cosmos's opponent in this round the tiny huge bot also used the pet st tables in its evaluation but due to their shenanigans they were able to get away with a lossless compression scheme which we can see has taken up a lot more space in the end it was a pretty close matchup with tiny huge bot winning 51 games drawing 46 and losing 31 to knock cosmos out of the running and here are the rest of the results that takes us to the round of 16 and in the interest of time let's just skip straight to the results for this one and we can see that velocity plus+ has been knocked out as has uranium sentinel tiny huge bot acv1 john sardine and infia danel well done to all of those for making it this far but now we're down to just eight one but i want to highlight here is tyrants v9 at some point during the tournament someone actually made a live leaderboard where the bots could play against one another and tyrant was a name i noticed very often being at or at least near to the top i believe that this was the strongest spot to be open source throughout almost its entire development only going private in the last few days for some final tweaks because of that it was extremely influential and in fact it's explicitly referenced in at least 33 different entries that i've seen tyrant then also mentions a number of fellow competitors who helped with the creation of this part so it's really cool to see that there was so much collaboration going on in this challenge anyway let's see if this b is able to take down small. cs to make it into the semi-finals we've started out with some sort of french defense here and i don't know much about this opening but i can't imagine tyron should be too thrilled to have given up the light square bishop [music] already all right small is going to have to make a slight weakness on the king side in order not to get checkmated there but in return is managing to win some pawns on the queen side in this position i was expecting small to just recapture the knight and be very happy with the extra pawns but after consulting stockfish it turns out that with moves like queen h6 in conjunction with knight f3 to g5 and pawn h5 tyrant actually has plenty of counterplay so small try something else giving up the queen and a minor piece for two rooks which seems very bad but small now has its eyes set on winning the pinned f1 knight tyrant meanwhile needs to be careful where it puts its queen for example trying to gain time by attacking the rook would be disastrous due to rook takes knight followed by a royal fork on d2 and so tyrant is actually forced to give up the knight but is still doing fine if it just brings the other knight to f6 where after the trades white's thorny pawn on that square means that black's rooks will forever be distracted watching out for the dangerous queen inf rtion and the game should be a draw tyrant chooses a different path however and now has a queen versus a rook knight and two extra pawns okay there goes the last of tyrant's pawns who'll need to try and pull off some kind of perpetual check here but small's managing to keep the pawns moving up the board and at last we have checkmate so this was a very hardfought matchup with small. cs winning 203 games drawing 163 and losing 146 to eliminate tyrant v9 and here are the rest of the results boy chessa defeating riel kinglet defeating thunka weed and drip le defeating floppy chess so we arrive at last at the semi-finals where in whatever the opposite of a dramatic turn of events's the four finalists are the same top four buts from the swiss tournament i thought that the results from that would be a lot noisier on account of so few games being played by each individual b but oh well it's nice to be sattin i suppose so let's see who'll be our first but into the final round from the matchup between boy chessa and drip [music] le boy chesser has taken on a slightly damaged pawn structure here but we'll have to to see if its opponent is able to exploit that now it's going for some aggressive pawn moves on the king side although that white queen on h6 might be difficult to dislodge and driple can definitely think about launching its pawns at black's king too okay we have a trade of knights and now driple is coming after boy chess's king with a vengeance this bishop move is a bit awkward looking but the idea is that if black were to accept the sacrifice white could then trade off the only piece that's really helping to defend black's king from the attack so white could then trade on g6 forcing black's king onto the newly open h file after which drip could simply move their own king up one square creating the unstoppable threat of rook h1 checkmate so bessa plays rook f7 instead to add another defender to the king but white has the upper hand and just needs to find the exchange sacrifice rook d5 to secure the advantage instead driple tries the move c5 indirectly attacking black's queen while adding yet another attacker to black's feval pawn center boy chessa decides now is a good time to capture that bishop though sacrificing its queen similar to small versus tyrant in that last game we saw although here there's no extra pinned piece to even things out instead what bo chessa has seen is a way to crash through with the pawns and ultimately for strip lee to give back the quein so despite driple clearly being a strong and dangerous opponent boy chessa managed to win this matchup with a very convincing 622 wins to just 109 losses to advan to the final round to see who'll be joining it in the finals let's take a look at the match between kinglet and small. [music] cs king lit is playing a very risky game here with the king still wide out in the open and has now set out to win a bishop in exchange for two pawns one of which small has pushed all the way down to f2 just one square away from becoming a queen after some maneuvering kinglet has managed to win that pawn but despite now being almost a full piece up white's extremely exposed king means that black could actually gain the upper hand with the move d5 creating ing a new past pawn that's because if kinglet were to get greedy and capture it to make a past pawn of its own small could then offer up another pawn opening the way for a crushing attack with the queen that opportunity was missed however and after some back and forth the game ended up in a complex but equal position where small has just enough counterplay to make up for the missing piece basically it needs to keep an eye on white's past a pawn hold on to its own annoying h pawn and make make sure it always has some checks available to harass white's king so under no circumstances trade queens all right with that dubious decision sm is now in serious danger of losing the game if kinglet is just able to navigate this tricky end game this is the infamous bishop and knight versus king endgame and in order to win kinglet has to somehow force black's king into a light square corner so that the bishop can deliver checkmate let's see how it goes okay so an interesting game i thought but despite this nice victory kinglet was unable to survive the match against its formidable opponent who won 404 games while losing just 298 so our final matchup of the tiny chess barot challenge after all these thousands and thousands of games is who could have seen it coming but boy chessa versus small. cs before we get into it though let's finally take a look at the code behind these two extremely impressive entries starting with small. cs the first thing i noticed is how thoroughly the code has been documented with links to read more about the different techniques and so on it's essentially a guide to making a chess bot which is very cool now down here we can see that it's extracting some p square tables and other evaluation terms but then interestingly it's rep packing them into a different format where each integer contains both the end game and middle game weight let's go take a look at the evaluation function quickly to find out how that's being used so over here it's looping over all the pieces on the board and first of all giving bonuses for open files and penalties for doubled pawns then there's also a mobility bonus given based on the number of squares that each piece currently attacks which is something that many bots did but an extra detail here is to actually waight that mobility differently depending on what type of piece it is in particular it seems that bishop mobility is considered to be twice as important as rooks or queens for whatever reason while the king is actually penalized for being able to move to try and keep it sheltered early on it also gives a bonus for the number of squares around the enemy king that each side is able to reach and these are also weighted based on peace type with rooks considered more important than queens interestingly until the end game at which point it's apparently bad for the rooks to attack the king this defies logic to me but all these values have of course been tuned across millions of positions since as you may have noticed this bot was co-authored by the creator of that tuning program we saw earlier so i guess we'll just have to take its word for it in any case the bot then scores each piece based on its type and location although an interesting trade-off was made here actually rather than storing a value for every single square it approximates it as the sum of a file score and a rank score this approximation apparently lost about 20 rating points over the full p square tables but of course frees up a lot of tokens for extra features finally the individual middle and endgame scores are extracted from that packed score format it's using and it just interpolates between them based on the amount of material left on the board so a really nice and compact evaluation function but let's now have a look at how it actually searches positions like all the top entries it uses an idea called iterative deepening where the current position is searched over and over again but each time going one step deeper this means that no matter when the allotted time runs out it will always have a usable answer as i talked about briefly in my first chest programming video though it does seem like a colossal waste of time to keep redoing the same search so i wasn't surprised to see many people opting for more intuitive approaches like always using the same fixed depth or trying to guess a good depth to use at the outset based on the time and number of pieces remaining for example the reason that iterative deepening works though is that alphab beta pruning is extremely sensitive to the order in which moves are searched so if you mostly look at bad moves first your search tree might look like this where the gry nodes represent the few parts of the tree that the search was able to skip here's the same tree now but searched in a much better order and we can see that huge chunks of it have been completely cut out so the beauty of iterative deepening is that one can use information from the shallower searches to improve the move ordering of the deeper searches making it counterintuitively very fast another way that small. cs and many other top bots capitalize on the information gained from shallower searches is a technique called aspiration windows the idea is is to take the score we get from each sech and then make the prediction that the next sech is going to find a score that's pretty similar to that maybe within around half a pawn more or less so we let the search operate under that assumption which allows it to cut out more parts of the tree and get to the answer faster but there is a chance that our assumption is wrong of course and the score is outside of the expected range or window what that means is that the search will have cut out parts of the tree that actually shouldn't have been cut out rendering the score unreliable and so we just have to do it again this time with a broader guess for what the result will be but on average it should speed things up along with this an idea called principal variation search has been used which assumes that the moves have been ordered so well that the first move in the list will actually be the best move reasonably often so it does a full search for the first move well within that aspiration window anyway but then the remaining moves are searched with a zero width window which means that we can relatively quickly find out whether they're better or worse than the first move but not how much better or worse of course if they're worse we don't care how much worse since we'll just go with the other move in that case and we've saved time but if they're better then we do need to find out how much better otherwise we can't judge it against the rest of the remaining moves and so we have to waste time searching that move again like before though this should hopefully speed things up overall okay there are many other clever techniques that have been implemented here such as null move pruning for example where the idea is to imagine that the opponent is allowed to make two moves in a row but as a compromise we don't look as far into the future as we normally would and then if our position still seems to be really good despite skipping our turn we assume that that's too good to be true in other words that the opponent will choose a different path earlier on in the tree and so we avoid having to do the full search over here now as we can see the these are all established techniques that anyone can look up how to use and indeed many of the buts in this challenge have drawn from different combinations of these concepts among others so it's natural to wonder what makes small. cs stand out enough to have made it to the finals i think a major aspect of it really comes down to an incredible amount of experimentation patience and in-depth understanding of the techniques of course to really be able to figure out and test the subtle details that actually get the most out of each technique in one's own particular engine and we can really see that on display in this log that the authors's provided listing every change that was made to the bot along with how many tokens it used and how many rating points it gained for instance here's the entry for those aspiration windows which used up 38 tokens and gained 36.8 rating points plus or minus 10.6 and this document goes on and on only increase reductions in late move reductions for zero window nodes if if we are not in check gained zero rating points plus or minus 3.3 so an impressive showcase of the detailed and methodical testing that was done with the possible exception of entry 1.54 i changed something in evaluation all right let's have a look at one of the games from the final round small going for an early age4 so already a very interesting pawn structure right out of the opening and small now decides ing to move the king into this little cubby hole on f2 okay an aggressive pawn move kicking the knight away and now actually offering a pawn sacrifice which boy chesser accepts and small immediately hops the knight into e4 which is a great square and also sets up a little trick with rook takes bishop and after the recapture bishop g5 would now trap the queen so boy chessa retreats the bishop and now white's bishop swings into action okay neither side fond of castling today apparently and small decides to sacrifice a second pawn to bring the queen into the attack as well so boy chessa requests a queen trade which small promptly declines and it looks like small is now managing to get one of its pawns back although it's worth mentioning that that knight is pretty much stuck on h7 i really don't see how it's getting out anytime soon taking the knight away from e4 seems a little strange to me but i guess it didn't want to allow black's knight to sit on e5 and so has traded them off instead all right a funny little knight move by black taking advantage of the awkward placement of white's rook and knight so small just ignores it and is now starting to line up along the light squares while boy chessa dances the night around into e5 after all now a funky looking rook move but the point is that if black captures it a line has been opened up allowing this night sacrifice followed by m 2 so boy chess responds by actually s sacrificing a piece to saave off this powerful attack it only has one pawn in exchange for that piece but let's not forget that small's knight is still effectively trapped on h7 so black has some hopes left at [music] least all right we can see that small's trying to sneak the knight out the back but eventually has to give it up in the meantime though it has managed to snag an extra pawn but but i had a look at what stockfish thinks of this position and it says that if boy chessa just plays the logical move of bringing the rook behind wh past pawn it should have very good chances for a draw but it decides to keep checking instead and suddenly things are looking very dire smalls king is just in time to protect the pawn and from here it's of course all too [music] easy so a nice victory in this game by small but let's now take a peek inside the brain of its rival so the first thing we can see is a big blobe of evaluation data packed in here and if we look at the evaluation function it's using the same nice idea we saw in small of putting both the middle and endgame weights into a single integer so that it can operate on those both simultaneously then it's looping over all the pieces of course but it has this funky line of code to split pawns into two separate types of pie pieces based on whether they're on the same side of the board as the king or not and we can see here that the pawns on the same side as the king are considered to be more valuable which makes a lot of sense and is a nice little detail that i haven't noticed in any other entries from how oddly specific these values are by the way they've clearly also been through some sort of automatic tuning process anyway back in the evaluation function we can see that the material is added up over here and then the p square tables are factored in as well and this also takes advantage of the two separate pawn types so if we take a look at the tables for pawns on the same side of the board as a king we can see that in the opening and middle game the flank pawns are generally discouraged from moving up the board as we'd expect however with this second type of pawn those not on the same half as the king it encourages them to move much more freely allowing boy chessa to be more flexible with its pawns depending on which side it decides to castle anyway after after that we again see this idea of weighted mobility although interestingly the king is actually treated as a queen here and if we print out the weights we can see that it mobility has been given a negative value to encourage keeping it protected very similar to what we saw all the way back in that choch champ butt actually finally there's some penalties applied for having friendly pawns blocking the file ahead of other friendly pieces and here's the values for those in case you're curious then let's have a look at its search code and we can see here that it's also using aspiration windows although if it fails it immediately abandons the idea and does a full search rather than gradually widening the window like small did i doubt that one of these implementations is better than the other by the way it's more that every little decision in a chess engine influences everything else and so there's no one siiz fits all solution for any technique you just need a ton of experimentation in fact the authors mention in their description running over 4 million games across over 500 different tests to try and optimize every aspect of their engine and we can actually see the history of some of those in the branches of the boy chassa [music] repository i have to admit i'm completely stunned at the immense effort that's been put into these entries i was not expecting such strong bots to come out of this but it's very cool to see this little challenge taken to such extreme lengths okay let's see what what else is in here so this quiet to check value caught my eye and it seems like as we get deeper and deeper into the sech the value of this is going to get lower and lower then this is used all the way down at the bottom of the move loop here where it determines the number of non-capture moves that boy chessa will consider before it just completely rejects the rest as probably bad that's interesting to me because in my own chess bot i've tried doing shallow searches for less promising moves and in fact it does do that here as well but i haven't tried just ignoring certain moves entirely i guess it makes some sense though to think of it like a gradual transition into the quiescent search speaking of which we can see that when it's searching through only the captures it uses a technique called delta pruning which i haven't heard of before but it seems pretty intuitive it's just checking whether the current evaluation is so bad that even if we add the value of the piece that we're above to capture plus some fairly large uncertainty factor the score is still lower than what we've been able to get elsewhere in the search in which case it just assumes that this position is hopeless and gives up on it now it's amazing to me how many different features the top bots like boy chassa have squeezed within the token limit and this was achieved by really obsessing over every detail for example we can see over here how a bunch of different bit manipulation tricks have been combined to be able to write this line like this instead of like this which saves a handful of tokens but this team as well as the team behind small. cs by the way is accustomed to caring about every single character of code because they actually take part in something called the top chess engine championship 4k where an entire chess engine including move generation and communication protocol needs to be written in just 4 kiloby their engines are ice 4 and 4ku respectively the code for which looks like this so if you're looking for a more hardcore chess programming challenge after this i have some links in the description about where you can get started with that in any case let's have a look at one last game from the final round before we see the results so boy chess are having a deep think about recapturing this knight here and now offering up a rook which small quickly accepts but there was definitely a risky piece to take because now the king is wi out in the open okay it looks like we're getting a queen trade which i feel like boy chessa should have tried to avoid because no white's out of any immediate danger at any rate boy cheser is left with a pawn and an extra bishop in exchange for the rock small meanwhile needs to try and get its pieces developed because right now they're not really doing much instead of doing that though it seems to be setting them up for the next game so boy chess is doing a good job i think of keeping white quite constricted here all right small sacrificing some pawns to try to get its pieces out finally but now black is only three pawns up for the exchange and the pair of bishops is doing a fantastic job of preventing white rooks from infiltrating now boy chess's king is getting involved to help support the pawns and we have a trade of rooks and finally these pawns are on the move so if black can just get rid of white's pesky knight then it'll be able to make a queen actually boy chessa decides to promote it anyway since the recapture runs into a skew so small only has the rook remaining to give some checks with but those will run out very soon and now a second queen is sacrificed to get rid of the rook book and finally a third queen is made to finish the game okay let's at last see the results of this final matchup so out of 1,024 games boy chessa won 437 drew 403 and lost just'4 to become the tiny chess bot champion all right all that remains now i suppose is the closing ceremony thank you so much to everyone who took part in this i hope you had fun and maybe learn something new along the way i've certainly learned a lot just from looking through all the submissions and a final congratulations to the teams behind kinglet small dcs and boy chessa for creating such formidable buts and making it all the way to the top three of this tournament all right thanks for watching and until next time cheers oh actually actually i thought it might be interesting to see how boy chesser compares to the but that i created over the course of the two coding adventure videos obviously it's not exactly a fair fight since i had no token limit whatsoever but let's see how it [music] goes [music] [music] okay so boy chessa is winning this game surprise surprise and i actually had them play a bunch of games out of interest and and in general my butt gets completely crushed thankfully i've picked up a lot of new tricks to try though so one day when i get back to chest programming we'll have to have a rematch all right that's all for today so goodbye once again