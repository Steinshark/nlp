rust is quickly making a name for itself as a speedy and approachable programming language now you've been bothering me about doing a rust video for a while now so you win this video is my initial take on rust and i might just do more content about it in the future rust has a pretty unique approach to type safety memory management and exception handling and that makes it a powerhouse for performance critical applications there are quite a few similarities between python and rust syntax and you can even bind rust to python modules and benefit from high performance all no it's a great language for pythonistas to pick up i'm going to show you some of the cool features that rust brings to the table today and how they differ from python but before we start i have something for you if you want to learn how to detect problems in your code faster check out my free code diagnosis workshop this is a 30 minutes a video that teaches you a three factor framework to look at code and detect problems faster in the work workshop i show you several examples of how to do that using existing libraries go to ir. go/ diagnosis to get access for free the link is also in description of this video and now let's dive into rust i'm going to start with something really basic which is obviously the hello world program now in python the hello world program is extremely simple it's just a single line of code a print line writing hello world and well you probably know this if you watch this channel so if i run this then obviously it's going to print hello world in rust it looks slightly different we have a main function that's what the fn keyword is and within it we have a print line statement that also prints hello world now in python it's typically a good idea to not write lines of code directly in the script like this but use a main function so instead of doing this you would have a main function and if you want to be neat then it's going to return type nonone because it's not going going to return the result and then we add a part of the script so that if you run the script directly then it's going to call the main function so when we run it like this we get exactly the same result but there's a bit more boilerplate code and that also showcases a big difference between python and rust where python is extremely flexible you still need some guard rails as a developer to develop properly in python and what i mean by that is doing things like this where you put it in a main function to not pollute the global scope or you're adding your return type annotation so that's clear what a function returns or not so python offers that freedom rust is a stricter language you can't really see that clearly in this particular example but i'll show you more examples later in the video now with python we can simply run the code but with rust we can't directly run the code we need to compile it first and in order to do that you of course need to make sure you install rust on your machine after you install rust here on my mac i've done that by using the homebrew package manager then you have the rust compile command so what i'm going to do is go into the rust folder where i have my rust examples and then i can call compile rust compile and then we're going to compile the hello world program so now it's compiled and this has actually created an executable hello world that's what you see here so i can now run this simply by typing hello world and now it's going to run the program so it's a bit more involved than simply running a python script you need to compile it first and then you have an executable so what are some of the other differences in python we print something by call the print function in rust we call print line but you see there is an exclamation mark behind it what does that mean exactly well an exclamation mark means it's a macro macros are not something that you might know from the python world but if you've done some programming in c then you know that it also has macros and macros are basically something that's executed at compile time and they generally expand into new pieces of code that then need to be further processed by the compiler and there's a few reasons why macros can be handy for example to avoid code duplication but they can also help in rust if you have so-called vartic interfaces and what i mean by that is that you can have a function in rust that has a variable number of arguments functions in ross don't support that but macros do print line is an example of where that's useful because this macro can take any number of arguments depending on the format of the string now there's a few other key differences between rust and python so one thing we've seen is that python is interpreted so you can run the scripts directly versus rust which is compiled and that also means that the performance is very different between python and rust now because rust is compiled it can really optimize the code for the executable so it's really optimized for performance whereas python is interpreted can be very dynamic very flexible so it's going to be slower when you run a python program there's also a big difference in typing python has dynamic types you can omit them if you want or add them and python it doesn't really care just throws away the types when it starts interpreting the script rust is static strongly typed so rust has way more restrictions and way more rules about how to use type than python so rust is much more particular about types than python and it also makes sense because often at compile time you'd like to know what the types are of things so you can properly address the correct amount of memory and things like like that there's also a difference into how python and rust manage memory in general python has automatic garbage collection rust uses another memory management model based on ownership so it's a bit different there are differences in concurrency multi-threading python has the global interpreter lock russ doesn't have that error handling is also a really big difference between the two so python has exceptions now i have talked about monatic error handling in earlier videos on the channel but this is actually what rust builds on so instead of having exceptions it has result and option types and i'll show those to you in a minute syntax of python and rust is obviously different though there is also some overlap python's syntax is very clean and concise with a lot of flexibility whereas rust is more strict but also more explicit and it makes it a bit more for both now putting all these things together means that in general python is going to be more beginner friendly there's just less things to worry about russ definitely has a steeper learning curve but if you're developing more complex applications that can actually be a huge win because it forces you as a developer to do things properly and of course in the end it's going to result in a more performance program and there's more differences between python and rust python has support for both a functional style of programming and an objectoriented style of programming rust is mostly functional though it has some aspects of objectoriented programming and you can also see that in the way that rust adopts more functional style program programming concepts such as railroad oriented programming where instead of using exceptions like in python you use a result type that can be either on a happy path or on an error path rust also has lots of chaining style methods like map filter folding that's also why rust has the option type where you can either represent a value or none if there is no value for example due to a method failure python in general is more suited to the dock typing style of programming where you don't really care what the type is of objects and if some data is missing or there is some other issue it just crashes with an error now this does make it a lot easier to get started writing your code in python but also means that sometimes you can encounter bugs and issues that are hard to track because you just don't have a clear view of what the types are of things if you develop in rust most of these issues already going to come forward at the compile stage so you won't encounter that error when running the program but but when compiling the program which means that as a developer you're going to see those problems sooner and you can fix them sooner if you already know python then it can be helpful to learn rust to because there are modules such as pio 3 and cfi that you can use to bridge rust with python this means that you can write performance critical code in rust and then call that code from within a python script which is kind of the best of both worlds now mention that rust is more of a functional style language and python offers both both object-oriented programming and functional programming so let's take a closer look at how you would solve a typical objectoriented programming problem with rust so in python if we need to represent objects of some sort then we can use classes here we have a very simple example of that a class user which has a name and an email address the email address is constructed from the name and then we have a method that uses the data in the object in this case the email address to perform some task very basic basic in rust this will look very different so here i have basically the same program but written in rust so let's break down what is happening exactly here so we have again a main function which is the entry point of the application and we have here something called a struct and an imple and this shows a big difference between python and rust so rust doesn't have classes but what rust does have is a struct which is basically a grouping of data so we have here a user struct that has a name and an email and then what we can do is define a grouping of functions which is an imple of that particular struct and there we can define functions for example here we have a new function that gets a name and returns a user so the return type annotation in python looks very similar here it's we also write it like this and what this does is that it returns a user with a name and an email again we see the use of a macro here that does formatting and the reason this is a macro is again because it can have any number of arguments depending on how you want to format the string formatting is done by supplying these kinds of handlebars where we're going to replace this by the value in variable here similar to the format function in python by the way and then what happens here in the main function is that we define a user variable and we assign it the value that this new function returns and it's part of the user implementation and then finally we print some information namely the username and the user email which is part of the user object because we define it as a struct here at the top of the file there's a couple of other differences here as well so you see this and sign that means it's a reference so that means that internally the value that's pass to this new function is going to be the same memory location within the function body as outside of the function body it refers to the same data you also see that we have a type string with capital letter and a lowercase s str so these are also slightly different and it has to do with mutability so in python by default variables can be changed they're variables right uh you can assign them a new value you don't have to do anything special in fact in python there is no easy way to indicate that something is a constant you can change anything you like it's very flexible in rust it's the other way around by default everything is constant everything is not mutable that means i can't do something like user do uh email equals uh something else right because the user is not mutable i can't do that let me show you by running the actual program so if i compile the original version like so and then let me run this then well this is what we get and if i now try to change the username like so and then let's compile again you see that now we get an error we can't assign to use. name because user is not declared as mutable things not being mutable is also a typical functional thing thing to do it's also it also works like that in a purely functional language like has for example if you want things to be mutable you have to be explicit about it and you can do that it's actually very simple just by writing mut mute in front of the variable name so now that i've changed this and let me then compile use. rs again you see that now it compiles without any issue and then i can run it and now we have change the name it still prints the same thing because i changed the name after this print line and email and email is only changed when we create the object so it doesn't have any impact here but it does change the name maybe i should move this print line right here so that we can actually show that it changed the name so let me compile this again and then we run it and then you see hello iron codes email didn't change because that happens in the uh initialization part of the struct like also mentioned rust has a real road oriented programming kind of style versus python that uses exception and that means it deals differently with errors also ross doesn't have a non- type like python so you never have to be afraid that your variable doesn't have a value and the way that you deal instead with those cases is that is that you have an option type so here i've added two functions one of them is get user option that returns not just a user but an optional user it gets a name and then if the name equals aron then i'm going to return a user if it doesn't it's going to return nonone this may look like the python nonone value but it's actually not a value it's part of option type so it works slightly differently let me show you what i mean in the main function i've now created a user option that calls this function and then i'm going to print the name of that particular user what happens if i compile this is that it's going to complain that name doesn't exist on the option type so i have to handle the option type somehow so instead of doing this what i need to do is add a match you already see that github copal does this for me so this is similar to python's structural pattern matching so a matching user option if it's some user then i can call print line and none then i do this so we can't really do anything specific with a nonv value we just use it in matching to take different actions in our program so when i compile this well we get a warning because get user result is currently not used because i'm going to show you that in a minute but the program is going to run without any issue now so that's what you can do with the option type sly you can also use the result type which is an example of monatic error handling so this is specifically for handling errors so in this case if name equals iron then the value is going to be okay we're still on the good side of things and then it's going to return a user else it's going to return an error and that's of type string so we can also add a user result and then similarly to how we match the optional type we can also match the uh result type by looking either at the okay side of things or at the error side of things so let me compile this one more time and then if we run the code then we get this but if i now change this to something else i compile this again and then i run this you see user not found and that's because we went over to the arrow path here so option and results look very similar when should you use which so the option type is typically used when the value of a certain computation may be absent for example if you have a function that looks for an item in a dictionary and the item doesn't exist then you can use the option type to indicate that there is no value use the result type when it's important to make a distinction between an okay state of the program and an error state of the program for example if your function reads a file but the file doesn't exist that's more clearly an error state that you need to handle in both cases though you can use the match statement to handle each of the different cases whether you're using an option type or result type a final thing that i want to show you in rost is trades and this is similar to how you would define abcs or protocols in python so here i have an example of an abc and abstract base class called iot device it has a couple of abstract methods like connecting disconnecting sending a message receiving a message and so on and then we have a class light that's a subass of the iot device that implements these methods on top of that we have a connection class that handles the connection so this is not a real connection this is mostly a simulation and then at the bottom we have an enom connection status that is being used by these and then we create a connection we have some testing code so the light class is a subass of iot device and by doing this this allows us to make sure that light implements all the necessary methods and russ you can do something similar it's not called a protocol or an abc but it's called a trait and that's what you see here so we have a trait iot device that has functions connect disconnect send and receiving and you also see that it receives a mutable self that means that this is going to change the self object a tradeit is really a specification of an interface what's interesting is that this is not associated with type you have to do that explicitly so if we have a light struct which has a connection value then you can provide an implementation just like we did for the user of this particular trait internet of things device for the light type and that's where you specify the various functions like connecting disconnecting sending and receiving and next to implementing the trade you can also just like we did for the user struct in this example you can also provide an implementation for light that supplies additional functions like the new function that creates a light value with a particular connection and then again we have a main function where we have light which needs to be mutable because we change the light object by connecting and disconnecting from it and then we print some status information so if i run this let's compile first first you see we get some warnings there is some dead code because there's a final thing that i want to show you in a minute but if i then run this then this is what we get so that's an example of how you could introduce abstraction in a rust program by using traits and like i said the main difference between using something like an abc in python versus a trade and rust is that there is no inheritance involved here it's really implementing trades for a particular type and you have to do that explicitly like we're doing here for the light tye but what happens if you have other types of internet of things devices as well like maybe a switch and a router and other things do you need to then copy paste this code well no and that's where you can use macros again here you see an example of specifying a macro this is how you do that that takes a certain type and then implements iot device for that type and then it simply creates the connect disconnect send and receive methods and now you can use this macro instead of having to write the implementation the trade implementation for this particular type so instead of now writing this we can comment this out which is done by double slashes by the way and then we can simply do this and that's also going to implement those trades by the way if you like these types of discussions and you'd like to stay informed on what's happening in the software industry including rust then make sure you subscribe to my free weekly newsletter by using the link below so i hope this has given you a idea of what rust is and how it works how it's different from python so in summary some of the things that we've seen with rust is that it's very powerful it's fast high performance it's type safe and it is verose more verbose than python but it's still relatively easy to write it's strict and i kind of like it so does this mean we should all throw python out of the window well no python is still a very flexible powerful language that's very easy to start coding in it has dynamic typing and allows you to do lots of things especially if you don't really care about performance so much just like python rost has a growing ecosystem of libraries that you can use and if you create a rust binding then you can actually call rost code from python which sort of gives you the best of both worlds so this video has been out of my comfort zone i don't have tons of experience with rust i still enjoyed playing around with the language though if you'd like me to do more content about rust just let me know in the comments below regardless of what programming language you use whether that's rust by or something else solving complex programming problems is easier if you adopt first principle thinking if you want to learn how to do that watch this video next thanks for watching and see you soon