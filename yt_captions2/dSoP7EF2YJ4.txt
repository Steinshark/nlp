all right hey rust versus go a handson comparison i hope they take that little gopher and they just squeeze it until its eyes pop out anyways oh no not another is rust better than go article seriously haven't we all had our fill of these comparisons by now no no we haven't we wish for more before you sigh in exasperation hear us out many comparisons between go and rust emphasize their difference in syntax in the initial learning curve however ultimately what matters is the e of use for non-trivial projects fair um sort of fair is that fair okay so i'd go with a countert i would say that what matters is their ease of use for their ideal development domain does that make sense meaning that if you take rust and you're bu like you use lepto which is a sweet sweet solid like framework to be able to do front-end development via rust air handling and some things it it just it it's much harder right you don't get this instantaneous reload time it's just a harder thing to do you get these like 5 8 10 second recompiles and you know it's just like i could find myself probably getting pretty frustrated especially as as the project gets larger like i think using rust for everything is a mistake uh just a thought anyways since we are a platform as a service provider we think that we can contribute the most by showing you how to build a small web service in both both languages we will use the same task by popular let's see and popular libraries for both languages to come to the solution side by side so you can make up your own mind and get a feel for what it is like to work in each ecosystem so before you dismiss this is just another comparison give it a read okay hey you give it a watch sit down put your butts on the seat and listen or standing desk or whatever you have treadmill desk hamster wheel i don't know there might be some details the other comparisons have missed before that old russ versus go debate the russ versus go is a topic that keeps popping up and there has been a lot of a lot written about it already this is part because developers are looking for information to help them decide which language to use okay hold on let's just we're just going to move past that let's just get going okay we don't need another one all right building a small web service we'll cover the following routing templating database access and deployment awesome we will leave out topics like client side rendering or migrations and focus on server side only perfect picking up a task that is representative of web development is not easy on one hand by the way this is also a good time to point out that even if you were to just do this it's still incomplete because you should also show like say using go for a very complex cli tool that say involves many different json decoding inst structures and how do you do heterogeneous lists how do you do these kind of things that are much easier say in the rust ecosystem that makes cli tool development really awesome but can be a little bit hard and go or how about command line uh uh what's it called command line arguments command line arguments like in our heads those are all simple but they're actually really hard to make a comprehensive and good set of command line arguments it's actually very non-trivial and rust with uh clap call it the baby powder that it's so good okay it's so good it will have you chanting chero by the end real talk all right so i mean is this complete is this a complete representation no because it's only what is it like to do ser side applications and ultimately what is it like to do a simple serers side application we decided to build a weather forecast service the user should be able to enter a city name and get a weather the current weather forecast for that city the service should also show us a list of recently searched cities okay as we extend the service we should add the following features a simple ui to display the weather forecast i better be hdmx hdmx mentioned can someone check that box up there uh a database to store recently searched cities let's see the weather api oh no what why what happened to to the oh what what it's like hidden text what is this super mario what is this mario uh for the weather forecast we'll use open med api because it is open source easy to use and offers generous free tier for non-commercial use of up to 10,000 requests per day we will use these two api endpoints the geocoding api to get coordinates of a city the weather forecast api to get the weather forecast for a given coordinates these libraries for both go omo and rust open meto meto uh which we would use in a production service however for the sake of comparison we want to see what it takes to make raw dogged http request in both languages and convert the response to an idiomatic data structure hell yeah brother girl uh hold on let's let's try i want to everybody flashbang warning nice let's go see they had these look look at how cutesy that is look at those cutesy links see i knew it being originally created to simplify building web services go had a number of great related packages the standard library doesn't cover your needs there are a number of popular third-party web frameworks like jin echo and chai i i mean i use echo for simple uh simple web servers all the time it's really nice it's very simple easy to use get in get out boom people seem to love fiber though echo easw which one to pick up is a matter of personal preference some experienced go developers prefer to use the standard library and add routing like a a library like chai on top of it others prefer more batteries included approach and use a full featured framework like gner echo both are fine but the purpose of this comparison we choose a jin because it is the most popular i don't understand their little gradient links uh it supports all the features we need okay so if you've never seen it this looks pretty much straightforward like any other version you just do a little bit of this bada bing bada boom all right so this must be making a request here's the uh the eural here's the response get out the body do new json decoder long as we got some results we return them okay cool the function takes a city name as an ar argument returns to the coordinates of the city as a lat long struct uh note how we handle errors at each step we check if the htp request was successful that the response body could be decoded if the response contains any results if the if any of these steps fails we return an error and abort the function yep so it's a little bit more cumbersome than go for sure uh the defer statement ensures the response body is closed after the function returns this is a common pattern and go yes absolutely because it doesn't have the drop semantics that rust has which is also again very useful uh error handling takes up a big part of the code it's straightfor but it can be tedious to write and it can make the code harder to read i don't necessarily think it makes the code any harder to read i guess i'm pretty used to seeing that maybe that's like maybe once you see it a little bit it gets easier is anybody truly offended by this any non any non-javascript devs actually offended by this any non-javascript devs because i know javascript devs are always just like why would i ever handle heirs and it's just like yo yo dog some sometimes things throw that's what tr catch is for where's your tri catch i don't know i have no idea what's a tr catch do these people exist they do exist i've i've noticed that the people that hate most the uh if air equals nil are they just love javascript where they just don't handle any errors right you got to remember in javascript every time you chase on parse you have a potential to throw an error and completely break your control flow every time you do the keyword await you have a chance to uh break your control flow again with another synchronous error like each one of those spots is a potential like oopsy daisy people don't really realize that it just happens it just happens someone's saying no in the vibe in the vibe are you saying are you disagreeing in the vibe are you disagreeing not at all okay hit me hit me in the vibe hit me why is that not true right now i don't think he can use a true true myth results dude this is the javascript script away if you got a wo use a library that makes it slightly less shitty but adds more complexity and code catch e throw e that's actually my favorite pattern catch e throw e it's my favorite it's my favorite okay i figured you didn't have anything to say in the vibe try catch throw jason broke all right anyways all right so we got a little ge response awesome we got a little this you know i've never been the biggest fan of this right here here you know what i mean i i i i i don't necessarily love this thing but yeah i i'm not loving it the json tags tell the json decoder how to map the json fields to the struct uh extra fields and the json response are ignored by default i i mean i do like that i do like that that you you have to state what you want kind of like uh the old the old rusties let's define another function that takes l long and returns to the weather okay you hit them with the endpoint you request if there's an error you got to do something get the body out uh read all the body if there's an error you're done else return the string of the body pretty straightforward all this is pretty straightforward awesome latitude longitude b bam bam bam routing we're going to do a little go forecast get a little bit of jin get a couple gets get the weather get the city this is awesome if it's i'm a little confusing why you'd have two different you should just confusing why you'd have two different paths to do the same thing but whatever uh exact same thing there we go uh we're going to do the weather we're going to get the city we're going to get the lat long um make sure that it actually exists uh get the weather make sure that it exists else return this perfect okay straightforward bam bam awesome we're going to do a little bit of templating uh again pretty straightforward here's some json i can see they're i can see right away that they're not using htm x all right uh let's see let's extract the weather data okay so it's going to do a little request get the json marshall make sure we can have everything done qui uh correctly return in air if we can't get the weather forecast we're going to go through weather fores cast uh beautiful beautiful if there's an error doing any sort of uh parsing it's going to just send them out append them to the forecast return them out okay perfect so this all seems pretty pretty straightforward right uh date handling is done with the built-in time package the time package is actually really good and go the more i use it the more i realize that it's it's pretty dang good they've done a great job with it to learn more about date handling go check out this article we've extended our route handler to render the html page again they're not using uh what appears this doesn't seem like htm x which just makes me want to vomit look at that and there's tables without htm x what is this what is this what is this okay anyways you get the idea right it's going to render the h this blah blah do this london beautiful okay awesome datab database access okay our server fetches the latitude and longitude for a given city with an external api on every single request that's probably fine in the beginning but eventually we might want to cash the results in a database to avoid unnecessary api calls let's go absolutely absolutely uh first let's see first we create a file named init squeal all right beautiful there's our little squeal and it all right there we go little uh serial blah blah auto incrementing everything looks good do a little docker do a little database url using postgress not turo week whatever uh however uh once we have our database we need to add squeal x squeal x is good times squeal x okay connect to the database fantastic everything looks pretty good insert city so anytime you look for a city you could you just cach the results instead of relooking it up that seems perfectly fine uh get lat long so now we're going to do a little dat database call by the way i do want to kind of show just like how nice this is that you can just have like it's super easy to just use a database and go you can just pass around a database you make queries and things feel pretty good is pretty nice overall there we go this seems great awesome uh here we just passed the db connection to get that long uh function in real applications we should decouple the database access from the api logic to make testing possible we should also use an inmemory cache to avoid unnecessary database calls you know what you should do if you use just turo and squeal light you know you got yourself a in you got yourself an on file system uh what's it called database all right do a little bit of weather check little bit of middleware get some forast get some stats nice group routes together get last cities okay fantastic we don't really need to look at this some basic o this is fantastic so there's some o kind of built into this we get our little stats url uh i'm kind of just lightly going over the code because nobody actually goes over the code right nobody actually looks at all the all the code completely um yeah pass around the database i can't do that in the eu yeah eu has some pretty strict laws about databases looks good enough to me i like the idea didn't use htm x pretty big failure but everything else looking great a rust web service historically rust didn't have a good story for web services there were a few frameworks but they were quite low level only with the emergence of async o8 did the rust web ecosystem really take off suddenly it was possible to write highly performant web services without garbage collector and fearless concurrency i got to understand why people say fearless concurrency cuz i still dread concurrency okay it's fearless async mutex uh we will see how russ compares to go like honestly i get more sweaty and uncomfortable writing concurrency in uh rust because i'm con i'm like everywhere just it's so hard not to throw an arc mutex just toss one out here toss one out there it just happens i know i'm just destroying the performance of my just destroying it just murdering the performance you know just don't then i it can't be fearless because i need send sync and static dog all right uh which web framework okay it's actic or axom i believe that axom came about because actic someone was upset about there being unsafe code and the creator was like i don't care and then everybody was just like get him and so then they created axom i'm pretty sure that's the origin story of axom versus actic actic is a very popular web framework in the russ community it's based off the actor model and uses async awa under the hood in a benchmark it regular shows up as one of the fastest web frameworks in the world axim on the other hand is a new web framework based on the uh based on tower a library building acing services it quickly gained popularity uh it is also based on async a we nice both frameworks are very similar in terms of ergonomics and performance they both support middleware and routing by the way one of the coolest things about actic and i think axom has the same thing any of your route any of your routes you can just put arguments as part of your function up to nine arguments i believe and you just put an argument in there of a certain type and the caller to that function based on the types will actually perform data transformations and get it out right so if you do like a form form data from a form data post request and say literally form data this struct with s day it will just do it all for you at hand it it's like one of the most incredible aspects of developing in rust absolutely it is so so so so [music] good i will say that if you want to do rust uh a web framework you really do need to have or a rust uh web service you really just want a framework at this point it it's you can do it without a framework it's just much much much harder you can implement from re quest and pull any type of data that is super cool see to me that's like just super cool i love that i love that idea right i just absolutely love that idea both web fra let's see both frameworks are similar in terms of ergonomics and performance they both support middleware i wouldn't say they're similar i would say that the rust one is definitely superior oh they're talking about between these two yeah absolutely uh each of them would be good choice for a web service but we'll go with axom because it ties nicely in with the rest of the ecosystem and has gotten a lot of tension recently all right routing a little new forecast there you go got a little ax and got a little request o request saturday squeal x and tokyo everybody loves tokyo okay every everybody loves tokyo except for that one person that writes those articles like don't use asyn or rust and and tokyo is inevitably mentioned in it uh let's create a little skeleton for a web service okay create a router have some routes create a little sock adder attach it to 127 what is this guy going to put in a docker container do a little bind do a little serve little weight little unwrap there we go seems pretty good the main function is pretty straightforward yep we don't even need to go over that all right uh wait do we have the other functions here oh nice there you go beautiful we can curl all of them fantastic axom macros okay before we move on i'd like to mention that axom has some rough edges it will yell at you if you forget to make a handler function async that doesn't feel like a rough edge that feels nice if if you uh if you run into a handler is not implemented errors the axom macros create and annotate your handler with axom macros debug handler and this will give you much better air messages oh that's cool i didn't realize there's a debug one that's pretty cool sock addd nuts no absolutely not absolutely not fetching the latitude and laun shud let's rewrite the api okay we get a little geos sponse a little aar day debug clone deserialize classic really that's the big three am i right am i right that's like the big ones you either got serialize or deserialize debug and clone uh in comparison to go we don't tag uh to specific fields uh names instead we use uh derive to serialize an attribute from saturday uh to automatically derive i do love this way more the fact that you do this and you don't have to annotate each field is so good okay it's so so good all right here we go fetch lat long we're going to get a little city references string we're going to return a result with a dynamic error for shame everybody knows you just use anyhow okay all right we're grab an endpoint we format the string in one go we get the response we get the endpoint we await it we get it as json we get the ge response we await that and boom so this is obviously way more tur so let's go back up to the go the go version uh fetch lat long that's what i believe that's what they called it where's fetch where's fetch lat long where's fetch fetch lat long uh i guess it doesn't quite have it here is it up higher where is where is it i know we just saw it i know we saw it i know we saw it is it oh get lot that long so same thing right we do the encoding we do a get we check for errors we do uh we read the body we uh we then decode we check for errs then we respond now if you go back down here you can see all the exact same things in r where are we oh i went too far i went too far everybody help we make the request pass in the endpoint wait for it to be done handle the air get it into json of type ge response wait for the response the body to be read handle the air so it's a little bit more tur i will say that rust air handling is very very nice but one thing that you notice there was no awaits in the go code there's no function coloring it just is what it is right let's see anyways it's a a little bit less for both yep because the question mark uh handler effectively is if error equals n does not equal nil return error that's pretty much all it is so you can just do this right response results get zero cloned okay or no results found perfect a few things happened do a little bit of that bam bam okay this looks pretty good uh mash response this is where this is where russ becomes more cumbersome when you want to deal with your responses you have to lift everything do you know what i mean like every single thing you do in rust requires a lift operation you have to match across enum results for everything and that is that's the part that's really hard i think about russ or it gets really annoying i find this to be the a lift operation uh this right here so if you want to use uh response results you have to check for for some and none and yeah it's not bad right it's not bad but monets i know but you have to do it for everything every enum and eventually you get into these situations where you just have so effing much pattern matching going on but it's not like it doesn't feel like useful pattern matching that's why i'm so curious about elixir cuz elixir you can define functions based on pattern matching so you can actually have one function defined three different times to handle the cases of each pattern and then react from there there and to me that just seems like it just seems like a much better way to do things also because the language not garbage collected you can't just like easily pull some of these things out and just lift out the value and that's that uh it just it sometimes becomes a bit more complicated there's just i just find myself having the if el's are handled they're just handled differently you know it is what it is advent of elixir no we're going to do advent of o camel uh rust has an expression based language which means that we don't use the return oh i use return because i'm not a psychopath to return a value from a function instead the last value of the function is returned uh we can now update our weather function to use fetch lat long our first attempt beautiful the program prints everything out look at that empty reply from server oh oh pathetic why is it empty the problem is we're using string for the type of city parameter uh this type is not a valid extractor we can use query so this is the extractor thing that i was talking to you about earlier look at this right here okay so there's two things going on here first a query with hashmap string to string is saying the query parameters will be string to string right obviously you're not planning on having uh more than one value in any position but second look at this they're doing uh right there they're actually did they did pattern matching in the function to handle its one case it's pretty cool i mean it's pretty cool so then they just go in here and they get the value out bam bam bam obviously these unwraps are just incredibly dirty don't be doing unwraps i'm not even sure why you're doing unwraps at this point why not have something else because this is an option this is a result and so you're having a bit of an issue going on there i think it would be a little bit better to return an option of string as opposed to unwrap because that crap will just crash your entire system all right do one of those get a little der serialized beautiful now we can have our little uh extractor it just works look at that extractor look how good that looks there we go cleaner look at this look at what it's doing though though did you see did you see the difference this is a hash map of string you know so you have to grab something out of it this is saying that the query parameter has to be minimum with a city equal string for this to be called it's like pre-o this it's it's making it on types so i do love this because this avoids this entire this part right here you don't have to do as much logic because your functions definition can do that effective if statement for you it's very very nice honestly oh by the way the mon as a burrito thing real talk i have never understood the monad as a burrito analogy okay i think it's confusing for me okay monad say russian dolls is easier for me than monad as burrito okay the burrito one is very confusing for me i don't understand how it works it's like a box that you can make into other boxes or other type shapes or other shapes in which can hold things in it and then you have to lift out the value if there's a value at all sometimes you go to open your box and it's actually nothing but sometimes you open your box and it's something so you got to handle both cases okay everybody knows that uh anyways cleaner a little bit more involved in the go version but there's more but it's more type save you can imagine that we can add constraints to the struct to add validation for example we could require that a city is at least three characters long uh now about unwrap and weather function ideally we would want uh we would return an error if the city is not found okay awesome a uh anything that implements into response can be returned from handlers however it is advisable to return a concrete type as there are some caveats returning uh imple into response okay in our case result type okay so we get this result string nice okay good it went to a result that's what i was hoping to see we do a match statement we do in a wait if there's a lat long we return it as this beautiful string else return the not found status code beautiful 404 awesome all right weather fetch lat long uh map error status not found a little confused about this map error right here little confused about it we get this thing bada bing bada boom looking good right because this thing already returns this so i don't know anyways whatever i you know i don't know i don't even know uh there's another api oh beautiful uh let's see this is a variant that has an advantage that we uh that we let's see that we the control flow is more linear we handle the air right away and then continue with the happy path on the other hand it takes a while to get used to the combinator patterns until they become second nature fair that's honestly that's one of the biggest hurdles to learning rust is that is that you have to like to use go you can rely on your knowledge you have of programming from say typescript from say c from from probably even cotland d nuts like you can rely on a lot of your abilities from other languages whereas rust to be effective at it you have to really learn the rust way of doing it if you don't learn the rust way of doing it you look at other people's language or other people's like code and you're just like what the hell's happening here what is this right you have to uh you really do have to like have the rust way i'm sure people are saying well what about the h way maybe hcal helps i have no idea probably is my guess o camel would probably help as well it's just different but the same thing uh this variant has some advantage oh we already talked about that okay there we go we get our nice little cities perfect beautiful i love that it's a 404 response code we grab the weather exact same thing make the url request await error text await eror response beautiful beautiful there we go we get this we get that and we return it this is cool right can we all say that this does look nicer than go this is where i think rust starts the shine is when you start hitting this area right it's nice this is nice i like it i like what i'm seeing i like what i'm seeing quite a bit uh this would work but it would return the raw response object from the open me mtio api all right so we're going to do a little bit of this let's go back to the go uh definition so we're going to do the same thing in rust awesome we're going to have a little hourly good uh while we're at it let's also define other structs we need a little weather display little forecast do a little bit of that a little bit of this b bam look at that now it's going to come out as a weather response don't like the dy air though should definitely use this air or anyhow to get done with that and so now we fetch uh lat long fetch the weather create the display return the display beautiful this is a great this great little piece of stuff right here right this is great stuff i like all this i actually like all this quite a bit uh this right here forecasts i' i'd implement like an in honestly to me an in would be really beautiful here to do this because you don't want to have to do like this all the way through right it just makes things really confusing i'd much rather see it kind of a little bit slicker of a way right you have a weather display you have a weather object and just have a weather uh like a a tri from or a from depending do you need a try looks like there's no tries in here just a from it's nice it just make it nice same with this thing another little from beautiful just makes things nice all right that's our start our handler now looks like this wonderful absolutely wonderful there's a let's see that's already a little bit better uh what's detracting is the map air boiler plate we can remove that by introducing a custom air type for instance in the example of a repository or use anyhow let's go anyhow mentioned right i just use anyhow honestly anyhow i'm a fan c forever why are you guys loving c so much okay i understand that c is great but so is rust nobody said c++ so you don't have to worry you just don't have to you don't have to worry anything pre-read i did not pre-read this okay okay all right you don't have to fully understand this code suffice to say that it uh will set up error handling for the application yeah i actually i've never really used the i've never actually just raw doged an error i've always just used anyhow or this erir but this looks pretty much just straightforward turn it into a status code or turn it into a response okay you have a struct app error app error that is anyhow error and then we can impul app erir whereare into error from this self into b bam bam bam good all right you don't have to fully understand this code most of the degenerates did not fully understand the code okay yo you got to be quiet okay i got things to do here you need to shut up put it on do not disturb all right i want to see i want to see the the database things oo templates what's the template have you guys has anyone here played uh with templates and rust i'm curious about templates and rust because it's either like i either really like go or uh i i'm going back and forth between go and rust and so i'm curious about a rust template i haven't tried rust templates i could really like them so i i would like to try out honestly this article is really good for the fact that they go uh from let's see uh or from the fact they go from showing you lower level stuff with standard with showing you the alternative with lips yeah that's nice i like it too uh typed html is nice yeah don't click that i'm not clicking nothing okay i ain't clicking nothing all right let's see templates let's go into templates because this part i'm really i i actually i do want to know about all right uh axom doesn't come with a templating engine we have to pick one ourselves i usually either use terara or asama with a let's see with a slight preference for asama thanks obama thanks esama because it supports compil time syntax checks oh nice and with that you cannot accidentally introduce typos in the templates beautiful that's a huge selling point to me i still need to use temple by go if you're not familiar with temple with go let's see i think i have a a a little thing up here where is it where are you oh that's so bright why did i do this to myself oh it's so bright but look at this like hold on hold on oh it's so bright like hold let's find one let's find let's let's find a little let's little look at this for go that looks pretty cool right that looks pretty cool i want to be able to do this i want to be able to do that i like that i like what i'm seeing so could i love it i could love it and it has uh it has compile time it has compile time checks so i like that i like it i like it anyways all right so let's see let's create a template directory and add weather html okay we do a lot of that forecast for forecast and forecast temperature data oh interesting so it's going to be like hand is that handlebar style oh my goodness oh interesting you have your templates directly tried tied to a singular struct yeah i could i could i could get into that i'm a little surprised you don't need to use pub right here i'm a little surprised you don't need pub you know what i mean weather display new one of these weather display very cool that is super cool very strange to see a form then a doc type html and then a form i don't know what that is but that that's making me this like that that's confusing me i did did really sl some htm x in there and boom you got yourself a day i don't like that i don't know what that was something tells me that's a typo uh but i i actually think this is pretty cool i like that maybe i could get back into uh rust cuz i am just like a little bit better at rust than go you know what i mean like i'm just better at rust and the thing that pisses me off about rust is that like i i do like a good i like a good i like a good template you know what i mean yeah i i think i've left the world where i think i'm completely out of the world where your template should be in your code i think i'm fine saying i'm no longer that person you know like j jsx i still want to try temple though uh leptos yeah i love leptos but i just don't like i don't like the fundamental concept of template in code you know what i mean so i i'm strugg i struggle with it honestly i really do struggle with it all right database access i'm very excited about this do a little datab database url create a connection create a little bit of a pool take that pool toss it in here with a little bit of state let's go good state everyone likes a little bit of state we have a little pool we got a little bit of state we got a little state pg pool yeah baby yeah yeah ooh derive squeal x from row that's nice that's pretty nice i'm going to talk to those turo fellas about this i want to see this i want to see that i would like to see more of this right uh because i love a good derive mat macro but also asking anyone to write their own proc macro is like asking them to you know be circumcised as an adult it's very painful i i can imagine it would hurt severely uh let's add a the strangest comparison i've ever made in my lifetime let's add a function to fetch the latitude and longitudes from the database it's the first thing i could think of okay uh all right so we do a little bit of this we do a little squeal squeal query we do a little bit of a bind we do a little bit of fetch optional and we await awesome and look at that air handling right there uh perfect awesome awesome if lat equals lat then we're good to okay cool okay okay i like it i like that very much else we go and we fetch it then we insert into it by the way notice that look at this can you believe that they're not using an omm like how are you ever supposed to actually program squeal without an omm it's impossible um all right do we do a little state we do a little query beautiful a little bit of middle wear uh the last feature we're missing uh from our go version is the stats endpoint okay let's start with the basic off it took me a while to figure this out how to do there are numerous authentication libraries for axom but very little information on how to do basic off i ended up writing a custom middleware that would check to see if the request has authorization header if it does check if that if that header contains a valid username and password if it does return unauth or if it does return if it does return an unauthorized response okay header whoopsies here's the code all right so here's some authorization headers do a little bit of headers if there's some oth starts with basic credentials this this this that all that okay reject reasons what is this thing is this some sort of uh implement from request for user okay so we get a little user do a little bit of header get a reject response bam okay cool cool the from request parts is a trait that allows us to extract data from the request there's also a from request which consumes the entire request body and thus only to be run once for handlers in our case we just need to read the authorization header from the request parts okay that makes sense we are authorized the beauty is we can simply add a user type to any handler and it will rest extract the user from the request that is like okay so this is where i get super impressed with rust can you believe somebody wrote code to handle that hey chastic can you believe someone wrote that that you go and you do this thing right here you implement a trait and how to take a request and generate an object out of it then you just put that thing in a function and it just does magic just straight ass magic going on there it's incredible axim is goed axim is uh yeah it's not cool no it's it's it's super cool obviously the authentication thing little strange but the fact that you can do this with anything you want is super cool all right deployment let's talk about that since both languages compiled statically uh to a statically linked li binary they can be hosted on any virtual machine or virtual private server that is amazing because it means that you can run your application natively on bare metal if you'd like and other options to use containers which run your application in an isolated environment they are very popular because they're easy to use and can be deployed virtually anywhere for goang uh you can use a cloud provider that supports running static binary container uh or one of the more popular google cloud run okay uh there is of course containers uh to ship rust there's another options one of them is shuttle rs of course who wrote this article why it was shuttle [applause] rs that little rasal sh rs is the way let's see the way it works is different to other surfaces you don't need to build a docker image and push it to a registry instead you just push your code to a get repository and shuttle will build and run the binary for you that's actually pretty cool i i i do like these strong integrations with code uh with code repositories and deployment services i like that i i like that i don't know how to do canaries and how to do all that crap that goes along with it but i like the idea of these kind of like onetoone relationships by the way this song is insane that we're listening to all right we do a little shuttle runtime main do one of these ones all right all it takes to get started is a shuttle runtime main on your main function oh wow they have a little procedural macro to make this all work out install the let's see get started install the shuttle cli inde dependencies cargo ball i don't know what ball is i don't know what bin stall is cargo ball i don't know what ball is i know what install is but ball all right we do all the same stuff we do all that we set up our production staging okay this is just going into how to do shuttle stuff we're going to skip that skip the shuttle shut stuff skip the shuttle stuff but it is pretty amazing pretty amazing okay the go version the go version is very simple and straightforward we only need to add two to penes jin and squeal x uh apart from that everything else was provided by the standard library the template the templating engine the json parser the daytime handling etc one thing i really do like about go go's effectively a batteries included language even though i'm personally not a big fan of go's templating engine and airor handling mechanisms i felt productive throughout the entire development process we could have used an external templating libr but we didn't need to as uh the built in one was just fine for our use case the rust version the rust code is a little more involved we needed to add a lot of dependencies to get the same functionality as in go for example we need to added a template engine a dat a json parser uh a a generalized parser called uh sday as well you need s json and sday right uh a daytime library a database driver a web framework this is by design russ standard library is very minimal and only provides the most basic building blocks the idea is that you can pick pick and choose the dependencies you want or that you need for your project it helps the ecosystem evolve faster and allows for more experimentation with the core of the lang or while the core of the language is stable even though it took longer to get started i enjoyed the process of working my way up to higher levels of abstraction at no point did i feel like i stuck with a suboptimal solution with the proper abstraction in place such as the question mark operator and the from request rate the code felt easy to read without boilerplate unnecessarily verbose error handling this is actually a pretty fair article this is shockingly a fair article you know what i mean i didn't think it was going to be that fair this is actually a really good one go easy to learn fast good for web services batteries included we did a lot uh we did a lot was just the standard library for example we didn't need to add templating engine or a separate o library uh our only external dependencies were jin and squeal x rust fast safe evolving uh ecosystem for web services the thing is is that they're both really good uh no batteries included we had a lot of dependencies to get the same functionality uh the final handler code was free from distracting air handling because we use our own air type and the question mark operator this was nice uh this uh makes for readable code at the cost of having to write additional adapter logic the handlers are succinct and there's a natural separation of concerns that's the one thing about rust is that it makes the end product code look clean but you there's a lot there's a lot that goes in behind the scenes on rust that i think people discount to make the end product look clean you have to do a lot of stuff to make it clean uh you have to just do a lot a lot a lot more uh russ lets you create a framework to improve your specific use case yeah traits and uh proc macros are the way they are the way but they're also like the thing is swier we all depend on someone making those as opposed to most of us don't make our own tra uh uh proc macros right the proc macros do all the heavy lifting there's a lot of stuff going on in this code that you just simply don't see and it like kind of tricks you for how simple everything is when there was like a monumentous effort to get it to all work if your end product is clean is it more maintainable h sort of sort of hey l lu thank you very much for that raid i appreciate that that's a lot of raids during this article um i'll say my thank yous after this uh but the thing you're missing here that that's kind of hidden is remember every time you want your own object you do have all this boiler plate you have to generate but then it allows for you to have this really clean interface in this one spot which is kind of nice cu then you have this really nice separation of concerns it just kind of works and you have your little place that kind of has all the sucky code right there's always shitty code rust allows you to hide shitty shitty code i think easier it allows you to put it into like its own little basket and it just does the shitty part for you and then it comes out super clean at the end of the day so is it better very well could be uh for that all right so is rust better than go or will rust replace go personally i'm a big fan of rust and i think it's a great language for web services but there are still a few rough edges and missing pieces in the ecosystem especially for a newcomer the error messages when using axom at times can be quite cryptic for example a uh a common one is this error message which occurs on routes not implemented in the handler yeah those things can be confusing seeing those once you know what you're looking at then fine also i mean it's it this is a pretty wild understatement uh type one in the chat if you know nothing about rust okay so we got a lot of ones in the chat we got a lot of ones in the chat for those that aren't used to rust type 69 in the chat if this looks simple and straightforward to you i said for those that aren't used to rust if this is simple and straight forward type 69 those are all lies every last one of them are lies because this is not simple or straightforward the first time you look at this you guys are liars i didn't realize there's that many liars in chat anyways it's just something that i've noticed that that it it to get proficient in rust is pretty monumentous amount of effort and then once you get proficient a lot lot of those things kind of float away and you can be pretty proficient on a good solid foundation of russ you don't have to become a wizard but you do have to put a lot of effort into it to get good whereas go you could like literally know nothing about go and you could build a web server right this is me knowing nothing about go and we built the we just built the web server right and we built this nice little little application like i i really just don't know anything about go it's pretty straightforward i still think i like russ better but still anyways all right in comparison to go the authorization part was more involved and go we could just use middleware and be done with it and russ we had to write our own middleware for the air type yeah this whole middleware for the authorization and all that i'm pretty skeptical about that uh this is not uh necessarily a bad thing but it requires some research in the axom docs to find the right solution granted basic o is not common use case for real world applications uh and there are plenty of advanced o libraries to choose from exactly there's plenty of just oo libraries that you can do that are so simple to use never roll your own o i think i could probably roll my own o in rust in like an afternoon this whole don't roll your own o crowd it's kind of crazy i mean it's like oo you like follow a link and set a return value of that link and store a little bit of information it feels kind of crazy how far how much people are making it dude do does anybody remember the days when there was no ooth 2 it's like you guys forgot about what happened before all these libraries happened you know how shitty it was to develop anything ever like at all it was horrible i don't know uh the mentioned let's see let's see the mentioned issues are not deal breakers and mostly paper cuts related to specific crates uh core rust has reached a point of stability and maturity that makes it suitable for production use the ecosystem is evolving but it's already a good place on the other hand i personally find the final go code a little too verbose the air handling is very explicit but it also detracts from the actual business logic in general i found myself reaching for higher level abstractions and go like the aforementioned from request trait in rust the final rust code feels more succinct i let's see it felt like the rust compiler was uh quietly guiding me towards a better design throughout the entire process there's certainly a higher upfront cost in using rust but the ergonomics are great once you get over the initial scaffolding phase all right fair uh scaffolding can be a pain though you know you need to change something you have a lot of scaffolding you have to take apart uh i don't think one language uh is better than the other it's a matter of taste and personal preference the philosophies of the two languages are quite different they both allow you to build fast reliable web services uh should i use rust or go in 2023 if you're just starting out with a new project and you and your team could freely pick a l to use you might be wondering which one to choose it depends on your time frame for the project and your team's experience if you're looking to get started quickly go might be the preferred choice uh it offers uh a batteries included development environment which is great for web apps however don't underestimate the long-term benefits of rust it's rich type system paired with the awesome error handling mechanics and compile time checks can help you build apps which are not only fast but robust and extensible fair with regard to developer velocity shuttle writer of article can substantially lower the operational burden from russ code in production we've se as we've seen you don't need to write a docker file to get started and your code builds natively in the cloud which which allows for very fast deployment in iteration cycles if you're looking for a long-term solution and willing to invest in rust i'd say it's a great choice i invite you to compare both solutions and decide yourself which one is better in any case it was a fun to build the same project in two different language and look at the differences in idioms and ecosystem even if the end results are the same we got there in quite different ways shuttle rs ad moment uh i didn't get paid to read this shuttle rs you should you shuttle rs you should just send me a check or at least buy me a beer how does that sound buy me a beer for this sweet ad you just got for freezy okay free ad at least buy me a beer $10 per street yes $10 per viewer can we get $10 per viewer $10 per viewer and then 20 cents per youtube view how does that sound sounds pretty good i'll have my agent contact you the name the name is the prime gen i actually i did like this article quite a bit i think they did a really good job breaking it down i think they really showed the strengths and weaknesses of each language and they did a good job representing go because i think a lot of people that love rust they just go rust awesome go suck right like they you know their their brain they have like react brain except for it's it's also with rust and so they have rust brain this is good i liked it it was a good one the shuttle guys are good yeah they they're good that was a good article good job on you