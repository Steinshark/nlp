units currently follow the tardis by moving in a straight line from one waypoint to the next in this episode we'll be adding and smoothing to oakley make the path seem more natural so given an array of points defining a path we'll start by imagining lines going from each point towards the previous point in the path the length of these lines is controlled by a variable called turn distance and at the end of each of these lines we create a perpendicular line called the turn boundary the one exception is for the final point in the path where we make the boundary line pass through the point itself now to follow the path our units will move from the start point straight towards the next point as soon as the unit passes the turn boundary however it will start rotating towards the next point and so on once the unit passes the final turn boundary which we can think of instead as the finish line the pass is complete we can obviously then control the smoothness of the path by adjusting the units turn speed we're going to start off by coding a class that can create a line given a point on that line as well as a point perpendicular to the line all right so in unity going to create a new c shop script called line and open this up i'm going to turn it into a public struct and we're going to define a line with two variables a float for the gradient and a float for the y-intercept well then also want to know the gradient of the perpendicular line so i'll make a variable for that as well gradient perpendicular and then we can create our constructor public line taking in a vector two four eight point on the line and a vector two for a point perpendicular to the line okay so to start off we can calculate the gradient perpendicular so let's say float delta x is equal to point on line x minus the perpendicular point x and similarly delta y is equal to point on line y minus the perpendicular point gosh y all right the perpendicular gradient is then simply delta y over delta x of course if the line is vertical then delta recker going to be zero and is going to be an invalid operation so what we want to do in that case is just set the gradient to some high value so that for our purposes it can be considered perfectly straight since we don't really care too much about accuracy here so at the top of the line structure of this create a constant float in call this vertical line gradient we can set this is something like 10 to the power 5 which is of course 100,000 so when our handle this case if delta x is equal to 0 then our perpendicular gradient is equal to vertical line gradient otherwise we set it with rise over run so that our perpendicular gradient we now want to calculate the gradient of our actual line so you're probably aware that the gradient of a line multiplied by the gradient of the line perpendicular to it is going to equal negative 1 so we can calculate our gradient by negative 1 divided by the perpendicular gradient unless of course this variable is equal to 0 in which case we don't want to make use of our vertical line gradient again so we say if the gradient perpendicular is equal to 0 then our gradient is equal to vertical line gradient otherwise we set it with this calculation all right we then want to calculate our y-intercept so that's easy enough if we consider our line in the form y equals mx plus c where m is the gradient and c is the y-intercept we just need to rearrange this to solve for c equals y minus mx so typing this out we get y intercept is equal to point on line dot y minus our gradient multiplied by point on line x now remember that the whole point of this line struct is to figure out whether or not the unit has passed a turn boundary so we're going to want some method returning abu i'll call this get side so to take an a vector to point or p for short if we return true if the given point p is on one side of the line defined by gradient and y-intercept and false if it's on the other side so in order to do this calculation we're going to need two points on our line so up here i'll create vector to point on line underscore one and point on line underscore two so we already have one point on the line that's given to us in the constructor so you can say point on line one is equal to that and point on line two can be anywhere on the line so we'll just say it's equal to point on line plus new vector 2 1 comma gradient all right so now that we have our two points we can fill in the yet side method so we write this a lot quickly we'll be returning true if point does x minus 0.1 dot x multiplied by 0.2 dot y minus 0.1 dot y is greater than point dot y minus 0.1 dot y multiplied by 0.2 dot x minus 0.1 dot x okay now unless you've seen something like this before this probably doesn't make a tremendous amount of sense to avoid getting too sidetracked however i'm going to be explaining the mathematics behind this line of code in a standalone episode so if you wanted to see how this is derived then feel free to go watch that for now however we're going to create a public pool called has crossed line given some point p and what we're going to do is we're going to see if this point is on the other side of the line from the perpendicular point that we were given in the constructor so let's create a bool up here we'll call this the approach side and approach side is going to be equal to get side given the point perpendicular to the line so the idea is that when we're creating this turn boundary we use the previous point in the path as the point perpendicular to the line so that's the side from which the unit will be approaching the line and then once the unit has crossed over the line then get side of the units current position will no longer be equal to the approached side so we simply return that right now if we see if this and yo to unity we've actually got a error message here and this is because our line structure needs to have all of these fields assigned to before we can call a method from the constructor now the only field that haven't been assigned to at this point is actually the approach side variable itself so funny enough before we can assign the get side result to it we have to just give it a starting value so just make it false if we save that now on you intimacy the error disappears and we can now go ahead and question you see subscript we shall call past and open that up that is not going to inherit from mana behavior all right it's just going to have three variables a public read-only vector three array called look points a public read-only line array called ten boundaries and a public read-only integer called the finish line index all right when i launch a constructor so public pass this will take in a vector3 array for the waypoints a vector 3 for the stash position spherical we leave out the unit starting position in the waypoints array and finally a throat defining the turn distance all right so look points is simply a rebranding of waypoints it's the same thing and then turn boundaries will set equal to a new line array with lengths look points dot length and the finish line is just the last turn boundary in the turn boundaries array so the index is equal to ten boundaries length minus one all right since our line struct works with vector tools we're going to need to do a bunch of converting from vesa 3 to 32 but just casting normally you will use the x and y coordinates from the vector tree and in our case we ain't want to use the x and z coordinates so it's going to make a little convenience method here returning a vector to i'll call this vector 3 2 vector 2 take in a vector3 and it will return a new vector to v3 dot x + v3 dot z alright we're now going to say vector to previous point is equal to vector three - vector two of the start position and now we're going to loop through all of our look points so for int i equals zero i less than look points lengths and incrementing i by 1 each time we'll have vector 2 current point is equal to vector 3 - vector 2 of look points i vector 2 direction 2 current point is equal to current point - previous point dot normalized and vector to turn boundary point is equal to the current point minus the direction to the current point multiplied by the turn distance alright we can all say ten boundaries the index of i is equal to a new line and we need to pass in point on line and point perpendicular to line so the point on the line is the turn boundary point and the point perpendicular to the line is simply the previous point however what if the turn distance is greater than the distance between the previous point and the current point well in that case the previous point will be on the wrong side of the turn boundary and so our hole has crossed line method will not work so to ensure that doesn't happen we'll take the previous point and we'll just subtract direction to current point multiplied by the turn distance okay we then just need to say previous point is equal to the turn boundary point now one small thing remember that the last point in the ten boundaries array is the finish line and so we don't want to subtract turn distance from that so what we'll do is we'll say if the current index i is equal to the finish line index then we'll set the turn boundary point simply equal to the current point otherwise we'll set it to the current point - all of this before we go any further to be maxed have a way of visualizing the path to make sure everything's working correctly so let's create a public void i'll call this draw with gizmos and this can start by saying gizmos color is equal to colored black and then we'll loop through all of our look points so for each vector three p in look points and we can maybe just draw a cube so gizmos dot draw cube the center will be p and we want to raise it a little bit above the ground so plus vector three dot up and for the size you can just set that equal to vector 3.1 then we also want to draw the turn boundaries so i'll start by saying gizmos color is equal to something else say colored of white perhaps and then we're going to want to loop through all of these so for each line l in ten boundaries we're going to say l dot draw with gizmos should say method will of course it'll create and we can pass in the length of the line and say maybe ten all right let's save that and you enter the line struct and create public void draw with gizmos taking in a float length so let's start off by creating vector three line two rection this will be equal to a new vector3 the x-coordinate will be 1 the white corners will be 0 and the z coordinate will be the gradient and then we'll normalize this we then integrate a vector3 line center there's going to be a 3d version of our point on line 1 so new vector 3.1 line 1 dot x 0 for the y axis and then point one line 1 dot for the z axis then we can say gizmos dot draw line from line center- line direction times length of the two to line center plus line direction times length over 2 all right which probably also add vector treated up to the line center just so that the line will appear above ground level let's save that and go into unity and let's now go into the unit script in here i'm going to start by making the speed variable public and let's also make a public float turn distance shall set aside by default we're going to be changing how follow path works so let's delete everything in methanol can just keep the while loop and will delete the target index variable as well as the vector 3 array that defined our old path instead path will be stored in the past classic relation of course so it's quite a path variable and in the unpassed and method let's just clarify that the new path variable is actually just an array of waypoints and we'll set path equal to new path giving it our way points our staff position which is just transform at position and the turn distance that we defined earlier all right don't want to set target index to zero anymore and in andra gizmos we can delete all of the stuff and replace it with path dot draw with his moves all right let us save that and now immunity of we press play we should see all of our look points preceded by their associated turn boundaries and at the end here we can see our finish line so this refer this line over here is the turn boundary which belongs to this second last waypoint and then the one behind that belongs to this one and so on alright so that is the majority of our setup work done in the next episode we'll actually get the unit smoothly following the pass so until then cheers