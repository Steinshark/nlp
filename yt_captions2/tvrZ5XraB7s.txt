i didn't even know squeal light used by code this is this this is new to me i didn't know this every squeal database engine works in roughly the same way it first translates the input squeal into text and into a prepared statement then executes the prepared statement to generate the results a prepared statement is an object that represents the step needed to accomplish the input squeal or to think of it another way to uh the prepared statement is the squeal statement translated into a form that is more easily understood by the computer in squeal light a prepared statement is an instance of a squeal statement object in other systems the prepared statement is usually an internal data structure that is not directly visible to the application programmer developers of other squeal database engines do not necessarily call these objects prepared statements but such objects exist whatever they might be called this paper will use the term prepared statement okay there are countless ways of implementing a prepared statement this paper will look at two of the most common ways by code the input squeal is translated into a virtual machine language that is run by a virtual machine interpreter this technique is used by squeal light huh i know that uh tree of objects the input squeal is translated uh in a tree of objects that represents the processing to be done the squeal is executed by walking uh the stream this technique is used by my squeal and post squeal okay i i would assume it'd be more that like an asish type thing right uh the the advantages and disadvantages of each of these representations of a prepared statement the purpose of this papers to articulate some of those advantages and disadvantages okay so this is kind of interesting uh definition of b code let's just we can we don't need feedback uh the b code generated by squeite might be a little different from what many readers think of as b code the b code used for example by the java virtual machine or web assembly consists almost entirely of low-level operations similar to what physical cpus implement basic math operations comparisons conditional jumps and instructions to move content between different memory locations squeal light bite code has these kinds of low-l instructions too but squeal light bite code also contains some high level operations that are specific to the needs of database engines op column extract the value of the nth column of a database that a particular cursor is currently pointing at oh interesting allocate a new b tree parse schema reread and reparse all of the squeal light schema tables okay oh interesting in other words the bik code used by site is not much a set of cpu instructions as it is a list of database primitives that are to be run in a particular order huh huh i did not know this i mean i guess this makes sense i've never really thought about it like i've never thought about how how do you take squeal and turn it into something that can be executed by the engine itself i've just i've just never taken the time to think about that an abstract syntax tree or an as is a data structure that describes a program or statement in some kind of uh formal language yeah uh you can do this if you ever go to uh as. what is it a org uh as as explorer. org i think it is did i get that right no uh as explor explorer net it's net it's net if you do this you can at least play around like the javascript one you can say how you're doing it so you can see that it has you know it starts off with the program and then you can walk through this stuff and you can see okay we got this nice little variable declaration which has variable declarator which has an identifier and then an array expression the x-ray expressions a bunch of literals you can kind of like walk through it and understand kind of what an is so it's a pretty cool little thing and if you ever have to write a babel plugin it's pretty nice in our context the formal language is squeal an as is typically implemented as a tree of objects where each object represents one small part of the overall squeal statement as emerges naturally from parsers of formal languages the you the usual technique uh is to use an lr1 parser uh with such a parser each terminal symbol holds metadata that will become a leaf of the as and each non-terminal symbol holds metadata that will become a subbranch of the overall as as rules of the grammar are reduced by the parser new nodes of the as are allocated and connected to the subt trees after the parse completes the start symbol of the grammar is left holding the root of the as okay okay an as is a tree of objects yeah i think we get this but an as is not suitable uh form of for a prepared statement after being generated an as first needs to be transformed in various ways before it can be executed symbols need to be resolved semantic rules need to be checked optimizations need to be applied to the transform input squeal statement into different forms that execute more quickly finally the as needs to be translated into an alternative representation that is more amenable to execution okay i think this all makes sense right like everybody kind of tracks with this uh that that feels that feels right um some people refer to the tree of objects that is used as the executable form of my squill or post uh postgre squeal as an asd this is probably a misuse of the term asd because by the time the tree of objects is ready to be executed it has been changed so much that it has little resemblance to the original squeal text it'd be kind of fun to see like an as explorer of squeal i' i'd actually be curious to see what does this look like the confusion arises in part because both the final prepared statement object and the original as are both trees of objects the usual technique is for the original est to come directly out of the parser to be transformed little by little in multiple passes until the end it is fully convered into a tree of object that is no longer strictly an but that can be evaluated to gen generate a result okay that must be a bunch of like optimizations when to order things when when to do a bunch of operations i assume it it i want i'm curious how much optim i assume there's like a whole i bet you there's a whole set of algorithms to identify optimizations and run right here i bet you there's like an entire deep well of really interesting things right here that i have i have just absolutely no idea tree setter playground uh but tree sitter is different cu tree sitter is about highlighting so it's a different kind of as tree sitter is super interesting but it's not that as explorer has squeal where's the squeal squeal yeah but this might this might not this is probably not the this is just like a this is actually just like an a right so this this isn't too surprising right select claw where yeah right you have the ordered by claw here's the range where it exists in the code this is pretty much just like tree sitter squeal light parser huh i wonder why it's not highlighting oh it doesn't do any highlighting oh interesting it doesn't like notice that this parser doesn't do any highlighting in line or this this as doesn't do any highlighting it has no ranges oh okay interesting interesting interesting yeah these are just things i just i never i guess i know let's just skip forward to this one because i think we know enough about this data flow programming uh is a style of programming in which individual nodes specialize in doing one small part of the overall computation each node receives inputs from other nodes and sends uh its output to other nodes and thus nodes from form a direct a directed graph that carries inputs to outputs a data flow program is perhaps a better description than as for a tree of objects oh okay that makes sense this makes more sense well but that would also suggest it's no longer a tree it'd be like some sort of ayylic graph uh squeal light compiles to b code and squeal light developers are happy with this approach i'm curious about this so this is where i'm actually curious okay so we know about the est a flat list of off codes can be easily printed to see exactly how a squeal statement is being implemented oh that is interesting that's a really cool thing debug ability would be really good uh this is what happens in squeal light when you pre uh preface a squeal statement with an explain keyword instead of actually running the squeal the result is listed is a listing of bite codes that would have uh been used to implement that squeal oh that's pretty cool uh bite code lends itself uh to this because a b code program is easily represented uh as a table in squill light b code uh each instruction has one op code and five operands thus a prepared statement can be rendered as if it were a query against a six column table a tree of objects represent representation is more difficult to publish in a human readable form yeah that makes sense this makes a lot of sense this is actually pretty interesting because it sounds like you'd have a pretty like easy lame way of trying to make your squeal statements better by just using explain you can actually just like directly see oh look at this i have to do all these operations if i change this i don't have to do all those operations anymore okay i like it uh the objects that comprise the tree tend to be very different and thus is tricky to come up with a consistent and simple table representation with which to display the objects any such table representation that you come up with would almost certainly have more than six columns probably many more the problem of rendering a tree of objects as a table is sufficiently difficult that nobody does it as far as i know hence no tree of objects database engine provides a level of detail in their explain output that squeal light provides okay okay that's kind of exciting b code is easier to debug by code provides a clear separation between the front end parsing and and analysis and the backend evaluation of the squeal statement yeah uh when problems arise incorrect answers andor poor performance the developers can examine the b code quickly to determine if the source of the trouble is either the front-end analysis or the backend data storage section of the product section pretty cool this is actually pretty cool i never thought about the benefits here in the bugging of sque uh builds of squeal light the pragma vdb trace on command will cause a trace of the bode execution in appearance in the console very cool this is actually pretty cool uh bod can be run incrementally squeal uh statements written in by code can be evaluated incrementally for example a statement can be run until it generates just its first row of output the statement then pauses until it's stepped again it is not necessary to run the statement to completion before examining the first first row output huh this is more difficult to achieve in the table a tree of objects design when a prepared statement is a tree of objects execution is normally accomplished by walking the tree to pause the statement in the middle of a computation means unwinding the stack back to the collar all the while saving enough state to resume evaluation where it last left off this is not impossible to do but is sufficiently difficult that i have never seen it actually done oh that's really interesting that's really interesting squeal light is the more i read about squeal light the more i'm just generally impressed by squeal light it is really impressive and it's like super simple you don't need like i love the fact that you don't need uh you do you you don't need like some some running you just you just point a file and say you you file are the squeal and it just like it just knows what to do right it just it it it it's a very cool it's it's super cool for testing like if you ever have to do quote unquote integration tests and you want a database and you want a database in a very specific format you can have a golden database that you just cp in do your operations and then check things out it's a bit of a masterpiece it is it's it's a really it's just really impressive what squeite is i don't know anything about duck db um most squeal database engines do not really need to do uh incremental execution of prepared statements because most squeal database engines are client server in client server engines a single squeal statement is sent to the server and then uh complete reply comes back over the the wire all at once thus each statement runs to completion in a single go but sque light is not client server sque light is a library that runs in the same address space and using the same stack as the application being able to easily and reliably perform incremental execution of a squeal statement is important to squeal light huh that's just so cool i mean these are all good reasons to use b code like everything i'm reading just makes it seem like bu code's a really cool thing obviously what what's not like you don't really need this whole client server thing i i guess i understand that in the sense that do you need any of the things that they've just got done talking about with the b code being run incrementally if you have client server probably not because you just you know it makes no sense uh the b code generated by squal light is usually smaller than the corresponding asd coming out of the parser during initial processing of squeal text during the call to squeal 3 prepare and similar both the asd and the b code exist in memory at the same time so more memory is used then but the transient state uh but that is transient state the as is quickly discarded and memory uh recycled even before the call to squeal light to prepare returns so the resulting prepare statement ends of consuming less memory in its by code representations than it did as an this is important because calls to sque light three prepare are transient but prepared statements are often cashed for plaus uh plausible reuse and persist in memory for a long time okay cool cool i believe okay that's okay it's cool that they call it out as a believe i like that i like that they call it out as a believe they don't actually know that bu code representation of a prepared statement runs faster because fewer decisions need to be made for each step of the computation emphasis on believe in the previous sentence it is difficult to verify this claim experimentally since nobody has ever put in the multiple years of effort necessary to generate equivalent b code entry of object representations of a prepared statement to see which one actually runs faster we do know that squeal light is very fast but we do not have a good side by-side comparison with other squeal databases since the other databases spend a lot of time doing client server message processing and is difficult to untangle the message roundt trip overhead from the actual processing time okay i like that i like that i do like the fact that he said um that that whoever is writing this said uh uh that they just believe like they didn't say hey it is they're just like no we believe this is this also looks like a really cool a really cool article to read man squeal light is just so i i did i just every time i read about them i just think it's so cool the advantages of compiling into a tree of objects okay sque light developers think about the bode approach is best at least for the use cases of squeal light tries to uh tries to fil but the tree of objects approach for to processing squeal does have some advantages over b code there's always trade-offs okay i like this uh the good old postes of forking child processes is still baffling yeah see i don't know enough about pro post to know these things uh when a prepared statement is by code once the b code has been generated the algorithm is fixed and cannot be uh subsequently changed without completely rewriting the b code this is not the case with the tree of objects ah okay so you can have mutations in a tree or slight alterations and it's fine a tree of objects is easier to modify on the fly the query plan is mutable and can be tweaked as it's running based on the progress of the query thus the query can be dynamically self-tuning okay that's cool data flow programs are easy to paral parallelize in a data flow program each processing node can be assigned to a different thread there needs to be some kind of thread safe queuing mechanism to transfer intermediate results from one node to the next but no synchronization primitives are typically needed within each node of the program node schedule is trivial a node becomes eligible to run when it it has the data available and there's no let's see and there is a space in its output queue okay cool this is an important consideration for database engines that are designed to run large analytic queries olap on large multi-core servers primary focus on squill light is transaction processing oltp on the internet of things so there is less need to represent prepared statements as data flow programs and squeal light i like this this was great this was a great experience again i've come to i feel like my thoughts of squeal light has only been going up over the last six months like everything i read from them everything that they do the way they approach their problems the way they write their papers the way they just do everything it just seems super cool like i do the only the only thing that i'd say is a negative for squeal light is the uh is the very closed nature of contributions which maybe isn't bad you know squeal light is just public source it's not open source it's public source which is which is very interesting approach to things i think that's why lib squeal has already surpassed squeal light as uh like the the squeite engine dour because lip squeal allows is is more open to uh commits and community driven yeah the whole database space has a lot of amazing engineering yeah databases is one is by far one of the most compelling and interesting areas i think of of computation i haven't done i've done no databasing but to me on the from the outside looking in it just seems so neat absolutely just absolutely interesting cool well hey another reason to like uh squeal light another reason to like him good stuff open for use closed for contributions yeah and i'm not i'm not i i actually don't disagree with this with this style i think public source is really nice like i think public source is a really cool thing and i think it's something that people should be more willing to do and state because i think a lot of times what ends up happening is people don't have they they want something to be open for people to look at and so they put it out on github and then people want to um they want to like make contributions but they don't do that right you are biased because you are sponsored by that squeal light thingy based uh well the the the thing is this is i mean this statement cuz sque isn't turo sque light is is not it's it's it's a turo is a fork of sque light so me just saying sque light is good i don't know if that's different i i think the thing is i can appreciate their engineering effort without without that i i know i'm inherently biased and i'm inherently there's definitely a bias there no no doubt but i just like the way they write stuff i just like how they're they're they're doing i know it was meant as a meme i know that's fine uh i i i don't the problem is i just don't like that meme uh that's not a meme it would be a joke not a meme um but a meme is something that flashes through a group of people really fast you know a thought process a feeling you know this is not a meme um okay sorry quit crying sack up quit crying um t turo ql when uh they already have it it's called lib squeal and it's just squeal light but i mean that that that's always a real danger of any sponsorship it's why i've i've done very little sponsorships i've taken uh turo only because the co-founders were just database and linux engineers for for the last 20 years and they are they are just inherent c ly really amazing and so i did not choose it for the product first i chose them because of how good they were as engineers and i said if there's going to ever be a successful product i think this is one of the reasons why it's going to be a successful a successful product and so that's kind of like my thought process behind choosing them and so it's a little bit different uh i i i did do because you know planet scale uh a lot of these places have reached out a lot of people have tried to get me to do something with them and i' i've just i've largely said no for that but sque light has always been this like very interesting kind of sidestep thing cuz squeal light's the only thing that you can just like that you can just use without all of the stuff that involves squeal usually and so that it's just it has this really compelling simple use case because a lot of times like when you're building a tool for work when you're building something you don't want everything you want something that's really self-contained and s squ light is something that's super self-contained and so it also makes just like a really excellent tool um like a tool a utility for building tools and this has nothing to do with too right this is like local usage that's what makes it so cool is that you can just like build any tool you can store stuff in uh like uh what's it called the you know xdg local storage or shared storage or whatever it's called whatever wherever you put the data the data thing the xdg date up home and you just throw it in there and then you can just use it aaron francis runs his personal site using lib squeal or squeal light he did an entire video and podcast episode about what he uh what he does with it yeah that's not surprising at all aaron francis is a jim to the uh community the nicest man on the internet and an absolute gem i had i had lunch with him once last year great guy great guy the name is i'm actually a genuinely big fan of the tech i think the tech is just super interesting i really do think it's interesting uh barring barring turo i think lib squeal itself is super interesting tech that i feel like i need to reach for many more times and really get a good feel for it right and really just it just use it in a ton of little projects because every time i've used it it's always been these really short tiny stints i've never used it in an extensive way and i really would like to do that and alex fredman is the nicest man on the internet you do not know aaron francis then a jen