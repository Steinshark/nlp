malik sucks so i spent the last few streams on twitch writing my own custom heap allocator in c is it faster no is it more efficient ye no but it's mine i learned a lot in the process and that's all that matters sit down buckle up here we [music] go after realizing one day that the m in malo stands for mid i decided to make my own memory allocator actually i just wanted to do this to figure out how the heap works but that's not nearly as memeable to make a heap you need memory so i had to get memory from somewhere if only the kernel exposed a system call where i could map in additional memory to my process a function where i could add a memory map they could even call it memory map jesus christ that's jason bourne m map is a system call where you can just ask the colonel for more memory and that memory is going to be where our heap goes we sprinkle in a few spicy parameters call mmap and get a page aligned pointer back from the kernel but what do we do with this memory my heap api was simple i only exposed two functions heap alec and heap free seems simple enough right nope heap alec would take the number of bites the user wanted to allocate and heap free would give them back to the heap before we can use heap alec though i needed to initialize the heap i created two structures heap metadata and chunk metadata the heap metadata contained several crucial pieces of information about the heap like how much memory was available next we slic the heap up into pieces called chunks a chunk is just a region of memory and the associated metadata about that chunk chunk metadata will track how big the chunk is and if it's currently in use also if it's free it'll act like a node in a linked list of other free chunks with the heap structures in place and the heap init function complete we can begin to write the first part of the user api heap alec when a user called heap alec we first had to check to see if the heap even had enough memory to support the request if they ask for more memory than the heap size too bad so sad get the out of you next we'd give them the first available chunk which is just the head of the heap's list of free chunks better known as the free list problem if the user only asked for 32 bytes we couldn't just give them the entire 4096 byte region we allocated right right why i i don't know i read it somewhere on stack overflow that's bad anyway to fix this instead of giving them the chunk in its current state we could truncate the chunk to make it smaller and shorten it to the actual required length aligned to 16 bytes after we truncate the chunk we look ahead that many bytes for where the next chunk would go construct a chunk there and then make that the head of the heaps free list easy peasy now we can run some tests and see that when we allocate pieces of memory we're getting small chunks instead of big chunks but how do we give them back like any any good c programmer we don't no just kidding i wrote the heap free function to only require a pointer to an allocated chunk as input the heap free function was pretty simple all it would do is mark the chunk as no longer in use and then add it to the free list and this brings us to probably the biggest problem in my current heap implementation fragment def fragmentation yeah in theory at this point i could have just stopped i didn't need to go any further my heap was quote unquote done was it fast kind of did it work kind of but it suffered from a fundamental flaw pretend for a second that a user allocated exclusively 32 byte fragments and pretend for a second that they freed them all too yeah i know what a concept if they did this they could in theory create a free list that uses all the memory of the heap and contains exclusively 32 by chunks what happens if after all of this they want to allocate a 64 byte chunk they can't the memory in the heap has been completely fragmented into unusable 32 by pieces the solution pre sizee we needed to add a little spice to our free function every time we freed a chunk we would not only mark the chunk as not in use we would also look behind that chunk to the previous chunk by adding preve size to the heap chunk metadata we could look into the previous chunk and see if that chunk was also free and if that chunk was also free we would cool co we would coales there we go coalescing the chunks turns our two adjacent free chunks into one large free chunk that the heap allocator can now take control of sick after running some tests i confirmed that this functionality worked the heap could not be completely fragmented and i was feeling good about the heap that i wrote now i made some fundamental assumptions about this heap that you may disagree with i didn't account for a user overriding heap metadata with malicious memory operations i did not account for a user freeing an arbitrary pointer and potentially adding arbitrary locations to my free list but i learned something and i hope you did too anyway guys this is my last video until 2024 i will see you next year it's been a good year uh we'll see you in the next one take care like and subscribe te