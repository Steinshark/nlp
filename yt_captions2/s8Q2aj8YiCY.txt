i mean look at this the rust written linux scheduler apparently is showing better game performance i mean unfortunately gaming on linux like kind of a pipe dream but okay i know there's going to be so many people like oh i game all the time on linux i game all the time it's so great i don't even know steam deck people yeah well i mean i i hope that linux becomes great for for gaming that'd be great a canonical engineer has been experimenting with implementing a linux schedule written within the rust programming language his early results are interesting and hopeful around some potential the potential of rust based scheduler that works via skedge x for implementing a scheduler using ebpf that can be loaded during runtime okay i wonder how complete it is interesting though i mean this is very very interesting uh let's see andre uh who is a linux kernel engineer at ubuntu maker canonical tweeted that he has been experimenting with a russ schedule i ended up writing a linux uh scheduler in russ using a skedge x during christmas break just for fun i'm pretty shocked to see that it doesn't just work but it can even outperform the default linux scheduler with certain workloads i.e gaming that's really interesting i wonder what it does differently right what does it do differently that causes it to actually perform different is it because it's not as complete or is it actually because it is like genuinely better because i can't imagine that rust by itself is somehow better than c rust magic i don't believe in rust magic cuz at the end of the day it still has to get compiled it's still it's like still being compiled l offensive that could be true i could buy i could buy that yeah a scheduler written in rust for fun during christmas break for linux he is the alpha of the alphas let's watch it i want to watch this all [music] right okay okay [music] holy holy cow this is very misleading the test he did is run terraria while compiling the kernel uh the kernel i can't tell other than the frame rate i'm still a nob in terraria i've never played terraria um i'm just curious like why is it so so much better right what makes it so much better i mean obviously a super impressive project to be able to build in such a small amount of time but what like what can be done in rust that cannot be done in c yeah i mean it's quote unquote doubled the performance right it's going from 28 to 30 frames per second to 60 i don't just old code lifetimes i did not see the difference fearless concurrency well you'll notice that uh if you if you if you watch there you can see a little frame rate counter that's the point scheduling is about uh managing multiple tasks like compiling and playing yeah i guess i don't really understand what was going on there like what was making it better so there was also he was also compiling at the exact same time and then running it i mean if it's better it's better like i i'd be super impressed if it's better i i don't know if it's a fair apples apples comparison i'd like to see something over the time of of uh like i'd like to see it obviously you need a real competition going on here just showing it on some computer running something and doing that i'm not sure exactly how scientific if you will that is uh you need to see it like i would actually be very curious at seeing it i can't look at the code i don't first off i don't know how linux schedulers work second off just looking at a bunch of lifetimes and traits like what what you're going to be like ooh look at that thing it has tick a and tick b damn that's a double lifetime like no one's going to we're not it's not like we're going to get it uh scheduling using rust acing yeah exactly but you are the expert in rust i'm first off i wouldn't call myself a rust expert i'm pretty good at it i know how to do traits and lifetimes and a good p portion of the things that are available but that don't mean i i am good like great at it uh 30 to 60 doesn't mean it doubled fair is it fair i don't know if that's fair i'm not sure i'd have to think about that i'm not sure i'm not sure what it says it could just be purely a different schuler altogether maybe it breaks things up faster or does things in a different ordering or a different way that allows for a game as simple as terraria to be able to run bro got math wrong well i don't know i'd have to i'd have to look at it i don't see oh 57 comments yeah let's see the comments all right all right scheduler seems uh to be hard to get right uh given there's dozens and almost they all seem to be janky hack mate so another one in the mix sounds good to me let's go the problem with schedulers are one they need to be informed in intelligent decisions no we cannot put a neural net in there otherwise 90% of the cp would be spent running the neuronet it's actually pretty funny sometimes they uh they need to predict the future but noer damus wasn't a scheduler of course uh so we try to hack something that works uh good when the hardware has plenty of resources available interesting okay is there anything in here that let's see wait a minute performance went from 25 to 60 i'd be more suspicious that something important is being overlooked here yeah i mean that's that's probably a a pretty good indic care that something it's it's incomplete uh let's see am i not wrong uh to think it's not surprising at all that someone can fart out some random scheduler that benchmarks better at certain workloads this guy this guy came in hot let's see let's see if there's anything that's good um a perfect schedule is it probably is probably impossible to build you need one that handles power saving sl performance profiles and low latency for soft uh realtime stuff maximum b yeah blah blah blah blah my guess is that i think i i think everyone is kind of agreeing that it's it's it's not complete until it can do everything and once it can do everything and then it's probably more interesting to see and perhaps it's better under c certain workloads and maybe it's way worse under other workloads right like may maybe it makes something else slower you know just like that person saying that 60 fps doesn't mean it doubled i didn't understand how that means that well how about this one what if the thing that was being compiled in the background slowed down by 50% so all of the sudden something that looks faster something else is getting slower you'd have to you yeah it's just giving the game more bandwidth potentially right and so it's just like what is you know what is the actual thing cu maybe that one thing that's spawning 32 threads versus the game that's probably spawning like three or four threads maybe the one that's with three or four and the one that's getting 32 are currently being weighted the same so it's just getting more priority than it probably ever has or who who knows what's actually happening underneath the hood i mean i mean that's the problem with uh with any of these type of measurements is that you need some way to to measure it that's that's more like holistic uh a good example of this would be that if you could just throw the scheduler onto a server and all of your servers just perform 20% better and they're all doing different ones right like if netflix could just turn on the you know the so-called rust scheduler or google just turn it on or any of the big companies that get billions of requests and all the sudden everyone's server just gets like 20% faster one could probably say the schuer is fantastic but until you can just magically turn something on and see a vast array of different programming uh models just get faster like it's just hard for me to believe that it's real bun just has so so if you're talking about bun bun has really good integration with the with the os right that's something that that and when i say really good what i mean is it has no historical requirements like node does node has a huge number of things that it has to back that that it that it has to maintain over many many years so it just has a hu like just a lot more things now one could say why doesn't no just prioritize the fast path and then make it pretty comparable to bun i think they we will see node get pretty comparable to bun but bun also just got to do a brand new implementation that's not as complete as node so of course it's significantly faster why doesn't node just delete itself if not's so good why did it make electric baloo so i just don't feel like uh just converted to harpoon 2 i think harpoon 2 is great uh there's something i need to work on um yeah but when it comes to any of these like whenever you see something like just just a general rule of thumb whenever you see something that's like this thing is now 10 times faster or five times or 20% faster generally i'm pretty skeptical because that is like a really big performance improvement and likely there's one of two two things that have happened it's like a new right that's missing some features or b the previous one has had so much legacy that it's actually just being held down or see the previous one was actually poorly written and a simple change to it will make it in parody with the new one and by simple i mean there's simple you know simple but not easy you know what i mean like i don't think it'd be hard for for no to be able to get uh some of their some of their stuff better like one thing that really holds down node is they have a whole bunch of async utils for inspection and all this async surrounding stuff to make it way faster or to make it to to make it way more inspectable makes it terrifically slower but bun has none of it so bun doesn't have any it it there's no asnc inspection in nearly the same uh you know magnitude now maybe that has changed that could have changed hey i could be wrong i am not saying that it hasn't changed in the last six months or whatever with bun but bun had significantly less inspection around acing stuff so therefore there's if you go profile a note application that's doing some async stuff and you'll see a whole bunch of calls to like async you know promises async something async there's a bunch of handling around it and you can do some inspections and all that and a lot of the um a lot of these like uh data dog and all that that does like run times of what's happening within your system are using those async hooks to hook in and actually measure your system and all the different kind of places whereas you just can't do that today in bun that i know of so it it can things can be deceivingly faster but that's because they just don't have as many features and maybe that's okay maybe you don't need those features and if you don't need those features and you can automatically make something three times faster maybe you should have the control to turn those off and thus become faster now bun's missing a lot of things that so it is truly an unfair comparison in this current day just like this we we just know that thiser got pooped up farted out over christmas break so is it as good is it as battle tested does it have edge cases what is it missing right we don't know and so therefore this is cool but i just don't know if it's something you should get terribly excited about i think the reason why people are getting so like horned up about it is because it mentions rust but just because something mentions rust like right away your cackle should always go up when someone says one compiled language using the same compiler runs faster than some other compiled language using the same compiler or your cackle should go up when someone says javascript or language with garbage collector is as fast as c in some case again you should go cackle should go up and say whatever i'm being shown is likely some level of deception going on or some tricker ation of how the measurements are being made i say cackles hackles your cackles can go up too your cockles of your heart can flare tr donald trump is as fast as hussein bolt under certain workloads exactly you know that's just you know when you really measure it i literally brussels i feel like i just got done i i literally just said this i i just like i mean i literally just got done explaining i mean if you're trying to see which one's faster c or zigg or c++ or rust and the implementations are identical it's coming down to how the translation going from the language into the compiled code is going okay godbolt to compare them yeah godbolt but then again even with godbolt the problem is is that more instructions does not mean slower an unrolled loop can quadruple the amount of instructions in a small area but it's significantly faster and so it's just like what are you do like unless if you really know assembly which i don't know assembly i'm just not that person that's going to be able to understand it i don't know if that's true either see like these statements i just simply don't make because i think these statements aren't they're not great statements to make sorry i just don't i just don't know right because i can't i you can't objectively say that now it could be harder granted it could be harder totally on totally on board that writing it in rust could be way harder to accomplish but to say that it's not possible i don't you know like you know what i mean yeah the average the not even the average uh programmer the 99th percentile programmer will not write as good of code as a compiler the 99.99 percentile that .01% still probably won't write it nearly as good casey would disagree yeah casey is is casey would disagree with what i'd be curious what casey disagrees with because we agree with a lot of things i'm pretty sure i've said nothing that casey would disagree with that programmers are almost always never good as good as the compiler i'm pretty sure casey would agree with that okay you got to remember that a huge portion of programmers programm javascript yes casey is not the 0.01% programmer casey is the point0 casey is like one of five programmers okay there's a big difference betwix comparing casey to randomly pick anybody on twitter just randomly right you might hit john carac by accident and john carmac may not be great at assembly right just because someone's a great programmer doesn't mean they're great at assembly right that again these these ideas where are you guys comeing from casey morari casey moror great first off i love casey casey is fantastic second off he's really really smart in his area right like you wouldn't want casey making a ui a he'd probably get bored and he wouldn't want to do it anyways but b it's like there's some people that are really fast at it that are really really good at it and that's what they do you could you could have specializations okay this does exist right this does exist that's all i have to say he could pro i mean casey could probably still make a great ui he's he's very very talented randy randy's freaking amazing anyways people people the point is just because somebody say something's faster and that somebody is extremely talented just be careful accepting and regurgitating anything because when it comes to performance measurements i would approach it as everybody is wrong before you approach it that everybody is right could tom do it i'm not even sure if tom could do it okay that's all i'm saying is most people aren't good at it yeah you should only trust 5% of what i say okay the name is only trust 5% of what i say agen okay okay what about tim nobody gives a damn about tim