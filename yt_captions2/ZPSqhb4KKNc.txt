low level gang welcome back to another video today we're taking another look at embedded rust in this video we'll be creating our own project from scratch and writing rust that compiles down and runs on arduino the atmega328p in particular learning how to use rust in an embedded environment has been such a fun adventure but so far we've only explored the example code that other people have included with their hardware abstraction layers in this video today we'll be writing our own code ourselves and going a little deeper into specifically what each line does hit subscribe to follow along with us on our embedded rust journey also leave a comment below and let me know what you'd like to see next okay so to start this video about first we need to install the tool chains that will allow the rust runtime and the rust tool chain to compile our code down to arduino code the way we do that is we install sudo apt install gcc avr the arduino is based on an avr processor so we have to have the gcc tool chain that can compile c code for rust down to avr okay once we have that tool chain on our computer we are now able to create the package that we will be using to maintain our code our dependencies our targets and things like that so we're going to do cargo new rust arduino blink that will create an application in the form of a folder at this location and we can cd into that and look at the files it has made for us it'll make two files the first being cargo.toml that'll maintain the list of dependencies and different rules that we run on our project when we build and release it and then the source folder which will have our basic main.rs which is where our source code will go for our project so what we're going to do is we are going to call sublime on this folder to open up our project and we need to actually add the dependency of the avr hall so someone actually for us just like in the previous video has made a hardware abstraction layer for the arduino hardware abstraction layers produce an api for us to write against that does not directly interface with the hardware to give us a safer abstraction for touching the peripherals of a device so that location is actually right here it's github.com righthick avr hall we are going to add that as a dependency to our cargo file the way we do that is we make a new dependency we say dependencies dot arduino all and we will say that the get location of that dependency is https double backslash www.github.com rawhix avr hall and we need to actually specify what revision are we going to depend on so we are going to depend on revision the git commit right here so 92d450c 92d450c cool and then another base dependency that you want to add when you write any kind of rust project that's embedded is you want to add the panic halt handler this basically incorporates a panic halt function that gets put into your code so that if the board were to panic it knows what to do so now that we've had those dependencies added to our code i'm going to increase the font size a little bit for you right there we can now do cargo update and it should nope before we do the update though let's make sure we pull the www off of github it actually does not like that in the package manager so we'll do cargo update here and it'll pull down the avr hall and the other crates for this project into our local working dependency so now we need to do is tell the project that we want to compile code for the avr target the way we're going to actually have to do that is by making a special folder called excuse me dot cargo and in that special folder we will sublime a file called config config.config.t.o.m.l so this file is a place where you can actually specify the target of your project so in our build run right this is the rule for when we're building the code we want to say that the target of our project is a specific json file that will describe how to compile our code so avr mega 328 p dot json and you're now saying okay where does this json file come from the producer of this hall actually created a json file for us in the avr specs we can just go ahead and download this file i'm going to copy and steal it real quick all this file really does is describe what is the architecture what is the cpu type what is the layout of the different file types or data formats right how big is a 16-bit value stuff like that and then what flags defeat the gcc so we're going to take this we're going to steal it and we are going to call it a new file and it's going to go into here we're going to call it avr atmega328p dot json cool so now when we build our code it says the target is this file and this file is this and it tells the rust runtime how to compile also here in our config file we have to include this code here that says that this is an unstable build and it uses the core library as a standard library remove the addition key it's also another minor rust ism if you don't have the addition key set to the right time it won't know how to compile it awesome so now we got that all set up the final thing we need to do is we need to set the build chain of rust to a particular version that is compatible with the rust avr runtime or the hall rather so the way we'll do that is we are going to use rust up and override the tool chain to be set to a particular nightly distribution yeah we need to say rust up override set nightly 2021 zero seven or sorry zero one zero seven if we don't do this the rust build will actually not really work we won't be able to produce any code because it won't know how to invoke the avr tool chain if we're not using this version of the rust tool chain that's my only major complaint about russ so far is that there's little niche things like that you need to know that if you don't know you literally just can't run code finally we need to change our main source code and add a couple of things to make it rust embedded compliant right so what we're going to do is add a few things to get this into embedded mode the first is going to be no standard no standard puts the rust compiler into embedded mode meaning it doesn't bring the whole lib rust it brings only libcore and it allows us to write code for a kernel for firmware to smaller applications next we're going to do is say no main no main just means it's not going to expect that we use a main function instead we can specify the entry point manually based on the specifications of the hardware abstraction layer uh we need to then create a panic handler for the processor to look for and use if it were to panic so we're going to say use from the core library in the panic sub library they panic info struct and we're going to define a panic handler and spelling is hard and we'll call it function panic it will take in an object named info that is of panic info type it will return never so this is not null this is not nothing this is the never type it means that this function is not allowed to return and it checks for that at compile time by basically saying if you're able to get to line nine you're wrong so the way we avoid that is you put it into an infinite loop so if we panic infinite loop not a very very good panic but uh it'll do next we have to tell the arduino hall hey this is the entry point to our code we do that by saying arduino hall which is the name of our library remember arduino hall this is your entry point and we can name this function function main it's kind of counterintuitive given that we said no man we can name it function potato really doesn't matter but we'll say function main for now and same as before because this is an embedded system with an entry point this is meant to return never and again that is checked at compile time by making sure we can't get to the line 14 here and we enable that by doing an infinite loop and then one final thing we have to do with our arduino hall as well is say that the features that we want to extract from the hall is that for the arduino uno if we don't do that it won't know what features to expose in the in the hall when we're compiling our code so we'll go ahead and put that in there real quick and then we will go ahead and build our code okay cool so now we have in the target folder target avr mega debug a rust arduino blink nope elf file that is an atmel avr 8-bit elf with debug info in it not stripped so pretty cool uh again obviously though this code doesn't do anything we don't care about this code so we are going to add some functionality that will make our led blink okay so it's pretty standard for any hardware abstraction layer uh that is written in rust to extract away peripherals from a device we're going to say let peripherals per if rawls peripherals holy english is hard peripherals there we go equal arduino hall within the arduino hall is pretty standard there to be a peripherals structure and we are going to take that and unwrap it cool so now we have a peripheral structure that we can use that gives us access to all the peripherals of the arduino chip that we're on the avr chip then within the peripherals there's actually a macro that gives us access to the individual pins and that macro is called arduino hall called pins and it's a macro so we use exclamation point and we feed it the peripherals structure that we already have now we have a pins structure that gives us access to the individual pins on the chip and allows us to do things with those pins then next we do let there be a mutable led that comes from pins its name is d13 that is a digital 13 pin where the led lives on the board and we're going to turn that into an input pin excuse me turn that into an output pin cool so now we have this led structure that is a reference into the pin structure that controls digital 13 as an output and then all we have to do is call led dot toggle and then use the arduino hall to give us a delay of 1000 and because it's a toggle this will turn on and off and we'll just run this in an infinite loop and not violating the never return type of main so move this over to the right a little bit and we will do the same thing we will do cargo build and there we go cool so now our target avr at mega debug has the rust arduino blink dot elf let's actually see how big this is i'm kind of curious pretty big man 600k so what we're going to do now is we have to actually flash it to the arduino how do we do that so first i've got my arduino plugged into my computer and you can see it's here on dev uh tty acm 0 i believe yep so we're going to use the arduino dude command arduino dude we're going to use the avrdude avrdude command which is the uh programmer that allows us to send elf files over various programmers to an arduino to you you know put your code onto that device so if you are dude takes a few commands a few different arguments i'm going to actually specify them right now first you put down avr dude the second you're going to do is the type of processor that you're programming so you're programming an m328p the next we're gonna do is we are flashing using an arduino because arduino has a baked in bootloader already written to the eprom so you don't need to do anything special there um we're going to do the [music] uh the port which is dev tty acm0 pull this up here the baud rate is 115 200 pretty standard and then we're going to write to the flash a writable section and it's going to be this elf cool so again using avr dude which is this type it's an arduino programmer we're putting it on this port and this is the baud rate and we're going to write to the flash area a writable section which comes from this elf hit enter there we go now it's writing it to the board and boom we verified it and we have the code running safely on our arduino flashing every one second guys i hope you learned something here i hope you understand that rust does in fact run on everything all you have to do is either write or find a hardware abstraction layer use that hardware abstraction layer to expose peripherals and then burn that new binary to a board if you like this video or if you learned something at all do me a favor hit like hit subscribe leave a comment and i'll see you guys in the next embedded adventure [music]