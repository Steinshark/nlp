programming is cool because we can make programs solve problems or run tasks for us but sometimes programs feel like magic let's demystify how return works typically when we write code we organize them into blocks that all should perform one singular action these blocks are called functions for example this is a function that hold on this is a function sterlin that calculates the length of a string when you call a function you pass it arguments and it returns a value to use a function we call it by specifying the name of the declared function and the set of arguments and where to store the return value the function call stops the execution of the code calling the function referred to as the caller and begins execution in the called function or the call e but how does a program know where to return to when the kali ends how does the return statement return to the right location well one solution could be that the location the function it returns to could just be calculated at compile time and baked into the machine code of the program return from sterlen by jumping here for example the problem with this is that a function can be called for multiple places take this code for example where we have three functions function a b and sterlin function a and function b both use the sterling function so hard coding and offset in the machine code wouldn't work because it needs to return to two different locations okay so what if instead we created a structure that contained all the offsets the possible return locations and the return instruction just looked up which one to return to this solution actually works for many cases but breaks on computed calls or calls whose addresses are determined at runtime for example in c plus plus a virtual class method as computed at runtime which is called dynamic dispatch so a return address lookup table wouldn't be able to calculate that before the program runs and track all these different return values into the return problem is actually not based on how the return statement works but instead on how the function is called to discuss how this works we'll need to dive into the assembly of the function call and don't worry it's not complicated at all a function call in c translates to the call instruction and intel assembly and other assembly variants it has a different name but they're all behaving generally the same way inside the cpu through our variables called registers the register we care about is pc or the program counter it's also referred to as ip or the instruction pointer the register contains the address of the next instruction to be executed by the cpu when the processor runs the call instruction the cpu quietly does something without saying anything about it the call instruction not only diverts execution to the called function but it secretly saves the program counter now referred to as the return address onto the stack the stack being memory used by the program to store variables and runtime information sterlen begins to run and it creates a region of memory on top of the save return address referred to as sterlens stack frame two more variables in the cpu the base pointer bp and the stack pointer sp determine where the stack frame for sterlin starts and ends memory in the stack frame is used for sterling's local variables for example the variable i sterland runs all of its code and then it comes to the end of its execution where the return statement is invoked before sterling returns it collapses its stack frame so that the stack pointer sp or the top of the stack points to the previously saved return address in assembly the return statement gets boiled down to a single instruction rent the red instruction pops off the return address into the program counter and the cpu continues execution after the call pretty cool right well what about the return value where does that go every processor architecture has an agreed upon convention regarding where the return value goes in intel assembly for example the return value goes into the a register or rax this piece of example c code returns the value 0 which when viewed in assembly we can see happening when the assembler loads the value 0 into rax because the return address controls where the program returns to and therefore the code that the program runs it is a huge target for hackers that want to run malicious code to learn more about that go watch this video