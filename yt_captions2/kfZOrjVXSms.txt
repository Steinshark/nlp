how's it going everyone in today's video we're going to be looking at five very cool onliners that you can use in python and before i even start with the video i just want to bring in a huge disclaimer that readability should always come first so some of these on liners might not be that easy to read and might be better written as regular code but with that disclaimer out of the way let's get started with this code golf by bringing in the most common oneliner and this is used to reverse itals so for this example i'm going to create a phrase which will be of type string and it's going to say hello bob and what i want to do is reverse this iterable or reverse this string and to do so i'm going to print the phrase and i'm going to use the special slicing syntax colon colon minus one and that's going to reverse our string so that when we run this script you'll see in the console that we're going to have a perfectly reversed string now a lot of people usually ask why don't i use the reversed built-in method to actually reverse this iterable well it works just fine i mean you can use that if you want and we can print that but what you're going to get back is a reversed object which means that if you have a huge itable and you want to reverse that ital it probably would be a better idea to create a memory efficient object from it but for something as small as hello bob i would just prioritize using the sliced notation otherwise you can do let's say quotation marks join and we will just join this reversed object and we will get the exact same result but personally i think it's quite silly if we have to turn something such as a string or an interval into a very memory efficient object just to flatten it immediately moving on to the second oneliner that you can use in python and for this example i'm going to bring in a very simple function that checks whether a length of user input is valid and the way we're checking that is by seeing whether the length of the user input that we provide is more than 10 characters if it's more than 10 characters we're going to return a yes case otherwise we're going to return the no case and i mean obviously you can just return true and false but sometimes you might have something else that you want to return so we're going to pretend that that's not the case here so let's look at how we can turn this into a oneliner using python's in quotes elvis operator so i'm just going to comment this out if i no i put it as a dictionary entry cuz i always mess up that shortcut let's see was it option damn it anyway that's behind the scenes so i'm going to comment that out so that we can recreate this and i'm just going to copy the top part so now we have the start of the function and what we're going to do instead of all of this is return the yes case if the length of the user input is more more than 10 else we're going to return the no case and it was as simple as that to convert this if el statement into a on liner without really affecting the readability i mean it still reads like english return this if this is true otherwise return this and in the case you did want to return a boolean you could make this even much more simple just by returning the length of the user input if it's greater than 10 and that will return the boolean before we continue with the rest of the video i just wanted to bring in today's sponsor which is myself a lot of you know me for my simple explanations when it comes to learning python concepts but i also offer premium courses which help you achieve a much more professional level of programming in python much faster and if you go to indent. today you can enjoy up to 80% off on all of my python course fores so if you're serious about learning python check out indent. otherwise let's get back to the video up next we're going to be looking at a oneliner that can flatten a list of any dimension but first of all i'm going to import from typing the cable type and the any type and this is because we're going to be creating a lambda and i want to be able to annotate that lambda so we don't lose the important information regarding that type but first i'm going to create it without the type annotation in case you're not familiar with how type annotations work and then i'm going to add the type annotation after in case you want to annotate it so what we're going to do is call this flatten and that's going to equal a lambda which takes a target list and i'm going to call that target then we're going to take the sum of the following which is going to be a generator comprehension and what we want to do is recursively call our flatten function on a subl list if this sub list is of type list else we're just going to leave it as is for each sub in the target and finally we just need to add an empty pair of square brackets and right now i'm getting these red squiggly lines because mypie is not happy that it does not have a type but on your code editor you're probably not going to see anything it's just a plugin i'm using in py charm to make sure that i annotate my types properly so this part will take care of flattening each list and the sum is going to add them together so if you add one list to another you're going to have those elements combined into one list and as an example i'm going to create a nested list which will be a list of type any because this can contain a list of any dimension of lists which is incredibly painful to annotate but what we want to do here is flatten this list so we don't have so many lists or so many dimensions of list lists and just like that we can print the flatten of the nested list and what we should get as an output is a flattened list of our elements and it doesn't just have to be integer values you can also add a letter somewhere and it will work just fine now moving on to the type annotation part since this actually gets quite long and type annotations sometimes don't really fit on one line i'm going to be using the new type syntax that was introduced in python 3.12 so now we can use type as a soft keyword and we can create a new type called flattened or flatten and this is going to equal a cable which will take a list and will give us back a list then we can say that flatten is of type flatten and the warnings for the type annotation will go away because now we have a proper type for our flatten lambda although our world is not perfect and type is still not accepted by mypie they're still working on that moving on we're going to be creating a secret password generator on a single line and it's quite simple but we do need to import a few modules such as first we need to import from secrets the choice to make sure that we make secure choice decisions and choice just picks random elements from an iterable but just as a side note make sure you use the secrets module and not the random module if you ever want to do anything that's actually secure next we're going to import from string the asky letters the digits and the punctuation so we have a bit of everything and then from typing we will also import cable and next we can get started with creating our pass generator or our password generator and this will be of type callable and it will take an integer which will be the length of the password and it will return to us a string then that's going to equal a lambda that takes an argument called x which is of typee integer and here we can get started with creating our password generator so quotation marks do join and here we're going to take the choice of the asky letters plus the digits plus the punctuation and then we need to do that for underscore in range of x and this part here will take care of the length of the password so it's going to perform this operation for the amount of times that we specify which means we can now create our if name is equal to main check and we can test it out by typing in print pass generator and inserting a number such as 4 20 or even just 10 and when we run this we should get some very cool password ideas in the console and once again you're not required to use type annotations you can also just remove that and it does give you a bit more space to do whatever you want but i will always highly encourage people to use type annotations where it makes sense what's important is you stay consistent with your rules or the rules of your company the only rule i follow on this channel is to type annotate everything that i can but for your company or for your projects you might have some different rules and finally it's time we cover the last oneliner of the day and this is going to be an email extractor so the way we're going to create this is first by importing rex and then from typing we're going to import callable as always now in this case since you understand how it works now i'm going to create a type called email and that's going to equal a cable which takes a string as an input and that outputs a list of string now we can actually create our lambda function and annotate it properly so get emails which will be of type email is going to equal this lambda here and that's going to take some text and then we can specify our rex find all pattern and since rex is a pain in the butt i'm just going to paste this in but i have included a link to a github repository that contains all of the code from today's video and you can find that directly in the description box down below but i'm just going to paste this in and zoom out an incredible amount and all we need to do here is say that we want to use this pattern on the text and i guess i can zoom in again i'm so bad with shortcuts and now with this oneliner i can create my if name is equal to main check and i can open up a completely random text file which i have on my computer to check if it has any emails so with open text.txt as text i'm going to create a variable that stores the information so sample text of type string actually i'm going to call this content yeah content that's a name and that's equal text. read and with that we can print the get emails from that content and now when we try to run this what we should get back are all of the emails that were present inside that completely random text file and i guess considering that a list might contain nothing it would be much better to annotate this as an optional so list of type string or none in case there's nothing in it at least we'll have the appropriate type type annotation and again the reason i'm using this type syntax is because this would not fit on a single line it actually goes past the line limit which means we get another beautiful surprise if we format it and i hate when this happens i absolutely hate seeing line continuation maybe that's just me let me know what you think about line continuation in the comments down below usually i see that as a sign to just split up that functionality but of course you can also just remove the type annotation and it will stay nice and short anyways that's actually all i wanted to cover in today's video do let me know in the comment section down below whether you have any on liners that you enjoy using because i'm sure there's a lot out there but once again i really want to stress that readability is much more important than this code golf but yeah as always thanks for watching and i'll see you guys in the next video