hi everyone we're just going to be working on a couple of small things this episode mainly eliminating the seams between mesh chunks but to start with i'd like to quickly fix this bug that i introduced last episode where if we move the viewer around some mesh chunks are getting left behind so if we go into the endless terrain script we have this terrain chunks visible last update list which is supposed to sort of tidy up behind us so if you recall how this is working is that in the update visible chunks method we're updating all of the terrain chunks within a sort of viewable range and then each of those terrain chunks which is visible after the update we add to the terrain chunks visible last update list so that it can be cleaned up next frame now the reason this is no longer working is that we're not only calling update terrain chunk from here but also from the level of detail mesh class which we added in last episode so we've got this little update call back to call the terrain chunks update method as soon as the metadata is received so that we don't have any sort of delay and uh that of course means that the that the terrain chunks visible last update list does not always contain all of the visible chunks so what we're going to do is we're going to remove that code from here and we're going to make the terrain chunks visible last update list static so that from the terrain chunk update method if the terrain chunk is visible then it's going to just add itself to that list so terrain chunks visible last update. add and then to add ourself we just use the this keyword all right so now if we go back into unity and just move the viewer around should see that that bug has been eliminated okay so now let's look at this problem of aligning the map chunks so that we create the illusion of one continuous mesh so if i just enable this mesh over here we can have a closer look at how our offset is working so first thing we'll see is that if i adjust this offset the actual shape of the land masses is changing which uh is obviously something we have to fix another thing to notice is that if i increase the x-axis positively the whole map is sort of shifting to the left in other words in a negative direction which makes sense because obviously if we want to see what comes to the right of the map then we have to shift the whole map left but this is not working on the y- ais if i increase y positively then it moves up positively as well uh whereas in fact it should be moving downwards so let's go into the noise script and uh we can invert the y offset simply by subtracting instead of adding it over here then to fix this problem of the land masses actually changing shape as we adjust the offsets we're going to want these octave offsets to be affected by scale and frequency as well so instead of just adding that on at the end of the line let's put that inside of the brackets and likewise for the y ais all right so if i save and go back into unity we should see that this is working a little bit better now if i adjust the x it's sort of moving as a solid chunk and why should now be moving downwards so if i hide the mesh and go into play mode we can see that uh this is looking far more seamless but it's not quite perfect if we go down here we can see that these are not lining up entirely and the reason for this if we go back into the noise script is this section here where we're normalizing the map values between 0 and one so the problem is that min noise height and max noise height will have slightly different values for each of the different map chunks which is why they're not perfectly lining up so this is still the preferred way of doing things if we're not using an endless terrain system because if we can generate the entire map at once then we'll know what the exact minimum and maximum noise height is so then we can ensure that the full range of values is used however if we're generating the map sort of chunk by chunk then we're going to have to essentially estimate what the minimum and maximum noise height values will be so to allow for both approaches to be used let's add a public enum up at the top here and i'm going to call this the normalize mode and this will have two modes local for using the local minimum and maximum and global for estimating a global minimum and maximum all right and then the generate noise map method we'll take in a normalize mode variable called normalize mode and so down here we can say if that normalize mode is equal to normaliz mode. local then we will take this approach otherwise we're going to have to do something else that is consistent across the entire map so a good place to start would be to figure out what the maximum noise height value is that we could have now we're calculating noise height by adding perin value multiplied by amplitude for each of the octaves and every octave amplitude is also getting multiplied by persistence so the sort of maximum scenario is if peand value is equal to one every single otive so up here let's create a float max possible height and set that equal to zero then when we're looping through these octaves we're going to want to say max possible height plus equals amplitude now amplitude doesn't exist yet so instead of declaring it over here let's copy that and declare it up here instead so we won't want to declare it again of course but we will want to reset reset these values to one um and now just as we do over here amplitude multiplied by persistence we'll want to have in here as well okay so at the end of this loop we will have found the maximum possible height value so we can use that over here let's say float normalized height is equal to and we can get the value from the noise map now remember up here we were multiplying our pein value by two and then subtracting one so we're going to want to reverse that operation by adding one and and then dividing this entire thing by two then we're going to want to further divide it by the maximum possible noise height so let's put this two in brackets and multiply it by the maximum possible noise height okay i think just to emphasize that these are the local values i'm going to quickly rename this to min local noise height and this to max local noise height okay so we've got our normalized height here and then let's just set noise map xy equal to that newly normalized height okay let's give this a try we're going to have to uh add the normalize mode to this call here so up at the top of the map generator let's just add in a public noise. normaliz mode variable and then when we make this call to generate noise map we can just add that in normalize mode all right save and go back into unity and i'm just going to reenable my mesh here so that we can preview it with this so when this is set to local this is just the same old method which works nicely for for a single chunk um but when we set this to global you can see that our range of values has been greatly diminished and the reason for this is that we've calculated what the maximum possible height is but our noise map values are in fact never going to come anywhere close to that value so this is where we have to basically estimate a little bit so we could try for example dividing this by 1.5 so let's save that and hit generate and we can see this is a little bit better um we're not quite getting the peaks so we can divide this by something a little bit higher say 1.75 maybe and we can just keep doing this and try to sort of find round about what the maximum value is going to be and this is working quite well um can see here we've got some parts this this little black part is uh an area that has exceeded ed the maximum it's it's got a value of greater than one and if i just for example set this to something like 2.5 then we're going to see many more areas which exceed a value of one uh so if i generate this now we're getting a lot of this sort of plateau effect so we're going to have to accept that in some areas of our map the height range is going to exceed one so we should account for that by being a little bit less strict with our mesh height curve and just making this exceed one a little bit so that uh we don't get that harsh cut off which can be a little bit ugly all right so something like that is a bit better um let's change this back to 1.75 though since that seemed to be working quite nicely overall um and then we're going to want to fix this problem of the values that are exceeding one being assign assigned the wrong color so let's go into our map generator and have a look at this section where we're actually assigning the colors to the regions so due to the changes we've been making we can of course no longer assume that current height is in the range 0 to one it would be nice though if we could at least assume that it was not less than zero however so in our noise class let's just quickly clamp this can say math f. clamp and clamp the normalized height between zero and then for an upper bound we can just say int. max okay so now in the map generator we're instead of saying if current height is less than or equal to the region's height then assign the color we're going to say if it's greater than or equal to the region's height then assign the color and will only break once we've reached a value with which is less than the region's height okay so with this change we're now saying that our regions should start at zero okay and this seems to be working all right let's try it out with the endless terrain system so i'll just hide the mesh and enter play mode so we can see that um the transition between two mesh chunks is now pretty much seamless we do have this slight color change which is because of a discrepancy in the normals and that's something that we'll fix later on but it's not quite as visibly jarring is actually having the vertices not a line um also of of course between different levels of detail uh we are not able to get these to align perfectly but of course the viewer will be too far away to see that and by the time they approach the level of detail will increase and those will match up so that's looking pretty good uh my only concern is that the sort of snowy peaks are very few in far between so what we could do is just change this estimate value here i'm going to bump it up to two and uh if i change it to two then of course can actually just cancel these both out um just save that and let's give it another try so got my snowy peaks back and it's looking pretty nice we'll probably want to come back onto our mesh here and just adjust some of these regions a little bit so maybe can bring the shallow water down a bit extend the sand a little bit further maybe the same for the grass probably want to do this for all of these and just the snow as well all right um the last thing i'd like to do in this episode is just to provide a way to uh scale our gener ated terrain uniformly so for example uh if we wanted it to match the scale of our player we could just scale it out something like this uh of course doing it this way scaling the map generator object isn't going to work because then if we now move our viewer around it's just going to break everything so let's head over to the endless terrain script and at the top here i'm going to add in a constant float scale just set that equal to one by default and then in the terrain tr class when we are setting the position equal to position v3 we can multiply that by scale and then we also want to set the mesh objects uh scale so mesh object. transform. local scale is equal to vector 3.1 multiplied scale and then instead of manually updating all of the things like the uh viewer move threshold as well as all of the detail level distance thresholds we can quite simply scale the viewer position since everything is based on that so we'll take this vector 2 and just divide it by scale so now if we go to play mode everything will hopefully still be working and it does seem to be and then if i go in here and change the scale up to five for example we should see that everything is working but just at a much larger scale all right so that's everything for this episode and uh until next time cheers