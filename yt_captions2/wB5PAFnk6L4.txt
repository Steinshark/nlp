what is up guys welcome back and in today's video we're going to be finishing up our raspberry pi kernel driver that allows a user to interface with the gpio buffer to control the gpio interface from user space in our previous videos we talked about why we had to do this given the constraints of the memory boundary from user to kernel space and then also from kernel to hardware we created a file in the proc fs file system slash proc low-level learning gpio that allowed a user to talk to a driver and that driver then could do something with that data so in this video i'm going to show you guys the code that i wrote that finishes up the driver that allows a user to turn led on and off from user space via this driver's interface that it creates for the user so here you can see i've got the raspberry pi all powered up i'll turn it off there real quick and turn off the cam link boom and we'll go right into the code so here i've made a couple modifications to the code i'll pull it up um so we're going from top to bottom here the first thing we had to do here is we have to actually map in the memory of the gpio interface so the gpio interface exists at a physical address on the raspberry pi 3. the kernel actually can't access that by default either because every memory address access that even the kernel makes goes through what's called a mmu a memory management unit it's the job of the mmu to translate a what's called virtual address into a physical address and if the virtual address doesn't have a map to a physical address the kernel can't actually talk to that interface so we need to ask the mmu hey can you give me a virtual address translation for the gpio interface and here you'll see i defined the gpio interface as our magical address we've always talked about ox3f2000 so we asked the colonel can you map that address in for us and can you give us a full page of memory i don't think you have to actually ask for a full page but historically if you don't ask for maps on a page aligned boundary sometimes the kernel or the mmu can get mad at you so i just ask for a full page of memory at that location we check to make sure that it does not come back as null if it comes back doesn't always say hey like i don't know what to do at this point the mmu did not return a value and we fail otherwise we successfully mapped in the gpio memory and then we continue on with our day so once this gets ran we have a global variable called gpio registers that exists at this address and it maps to the gpio interface as we showed you before in previous tutorials then what i've done is i've added some additional codes you remember previously in my last video we have this function here that gets ran every time a user writes to the procfs file in proc right so if a user opens us and writes to us this gets ran originally we would just say hello you gave us this value but now we have to actually parse that value and figure out what they're trying to tell us and then do something with that so i've added a little bit of stuff here i basically just print the buffer that they gave us and then i use scanf to extract the pin number and the value that we actually want to turn on and off right so remember the format we wanted to do is pin 21 turn it on with one or turn it off with zero right so if we scan off the buffer for two values you know put pin here and value there these two addresses if we don't get two elements back that means it was in an improper format so we fail and we return the size that they sent us otherwise if we do get two values out we want to make sure that those values are valid right so we want to make sure that the pin is less than 21 and it's greater than zero those are the only pins we have access to physically on the raspberry pi and i don't really care about the rest of them so if it's not within that range we say hey bad pin number sorry and we fail otherwise if the value is not a zero or it's not a one we also fail i don't want to do anything other than turn it on or off i don't know what two means so we fail on things other than one or zero and then finally if we get to this point we've gotten a you know valid input from the user um we say hey okay cool you've given us pin x and value y and then we say if the value was one we turn the pin on if the value was zero we turn the pin off right so we're going to go up here now and this is where the code gets a little more complicated but if you go back to the tutorial that i did in assembly it's actually extremely similar we need to be able to tell how we index into this gpio register structure based on the pin number and the math plays out basically that the function select index the you know function select register that we choose and remember there are three of them or four of them um is the pin number divided by ten then the function select bit position right the function select position that we have to actually enable in that register is just that pin number mod 10. so for example if it was 21 we would index into the second function select register and we would turn on value one okay so we get the address of that register in particular by taking the base address and just adding that index to the the pointer value pretty pretty straightforward and then finally we need to calculate the address of the register that we actually used to turn the pin on so remember this register makes the pin an output and then this register makes the pin turn on and this is basically always hard coded it's always the base address plus c so i didn't want to do any fancy math on that that should not change and then a little bit of bitwise magic going on here but basically what this does is this sets the function select for this pin to all zeros and then we only turn on the least significant bit for that pin and again i'll pull the data sheet up here to kind of show you how that how that math plays out but basically this makes it a input very momentarily and then this turns on the last bit so that it's now an output and we do that so that if the value had previous values there before here here we clear it and here we set it right and then finally now that it is declared as an output value in the function select then we turn that pin on by setting the pin number left shifted by one or one left shift about the pin number with an or value right so this whole function turns a pin number to an output and then enables it okay so if we write 21 comma 1 for example this will turn on pin 21 awesome and then the exact same thing happens here right if we get a zero from the user we have a pointer into this register set that points to the output select off register in the gpio structure and then we just turn off that pin right so pretty straightforward so we can actually test that real quick and i can show you guys that it works um by first we have to build the driver that takes a few seconds here i'll let that run you should see no errors here i've cleaned up the code a little bit be proud of me yep cool so we'll rm mod the driver because i already have it installed and now we're gonna instamod it and now i can do things like echo 21 comma one into proc low level learning gpio and we'll do that and then you can see two things we're going to type d message here and i've been testing this so ignore the rest of my code right or the rest of this information um but this is it telling me that it got this data buffer and it said that i wanted to do pin 21 comma one very cool and you can see here i'll pull up the led and now the led is on and then as we go through here i will turn the led off pretty cool so we've gotten it to work but now like this interface is still a little messy because i have to go into the command line and type echo 21 comma 0 or 21 comma 1 and write it to this file what we can actually do now with this file that exists in proc fs is we can write a user mode program just regular old code that interfaces with this driver and makes it do things i've got this program here i know it's just basic c this is not in the kernel this is just in user mode and all it does is it opens proc low level learning gpio as a file and then once it gets that open and again i'm being a bad programmer i'm not checking the return value don't hate me for that um we go in an infinite loop and then we write 2f i want to turn on pin 21 and we do 4 because this string is 4 bytes long and then we sleep for half a second and then we use right f to pin 21 comma 0 which means we turn pin 21 off and again that's 4 bytes long and we sleep so this is created now an interface where our user mode code can just go ahead and use the driver to do things and now if i run this program here it'll run in the background forever and i'll turn the camera on and you'll see that the led is blinking at a half second interval so guys this tutorial has been basically about how do we create drivers in the kernel and how do we use the procfs or the dev file system to create these interfaces that the user can use to touch the driver right and then ultimately how do we create our program that makes use of our driver so i hope you guys have learned something if you have do me a favor hit like hit subscribe also if you haven't already follow me on twitch i'm starting a series on game boy advanced game development i'll drop the link here in the video um guys again thanks for watching and i'll see you next time take care [music]