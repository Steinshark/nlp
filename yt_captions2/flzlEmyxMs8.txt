we are going to crush this little this little chalange okay are you guys ready to crush some [music] chalange hi i'm lydia hiy and i created this javascript quiz course to have a fun and interactive way to teach you all about the fundamentals of javascript i really want i i i i hope we're not getting bamboozled here but i i believe we should be getting some yes okay so we got we got a we got a lot of questions coming up that's just don't worry it's just an intro in this course i'll prompt you 50 questions about topics like the event loop scopes and closures the disc keyw classes and prototypes garbage collection and so much more so get ready to test your foundational javascript knowledge and have fun i'm ready l so then we have the very first question to put the logs in the correct order so we have the promise resolve the then call back q microtasks set timeout a regular console log oh okay so put the the logs in the correct order okay i think i could do this we got a promise resolve then console log one we got a q microtask 2 we got a set timeout three at zero we got a four then we have a console log five and then we got a six so my guess is it's going to go like this it's going to go four 2 1 3 5 6 oh no no no no no no no no no no no no because this is a promise. resolve. then this should actually i believe actually get double put on on this one hold on hold on so it should be four two oh i don't know how set timeout versus promise goes okay so i'm going to go four so some people are saying five i think you're wrong on that so i think oh crap no oh my goodness you're right this is a constructor oh i'm so stupid this is a constructor right here so it should be four five four five is this a constructor does does this count as a constructor i can never okay so so i'm going to go 456 2 31 456 2 31 that's how i'm going to do it 456 231 456 231 yeah so i i see some people saying 456 231 this is just bad code it's not bad code it's teaching you the order like you should be able to do that right some people are saying 145 623 really you're wrong on that one so a resolve so for a resolve to happen in a promise it require it puts it back onto the event loop and so that's that's a thing and so that means a dot then should come afterwards so my guess is this gets two ticks maybe this one's the only one that i'm not sure where this one at a zero does this get just put where i don't know what a how a zero interacts with the resolve a new promise constructor and then the async function so it's up to you to put these in the correct order how you think that they'll be logged and then afterward we'll see if you have it right all right all right we already oh i didn't real i didn't i didn't realize would be 4 5 6 1 2 3 damn i'm in shambles i'm shambled right now i thought the microtask que happened before the set timeout you're so as dude i'm a skill i'm i have skill issues set timeout gets put on the aing q yeah but i thought that unsubbing dude senior netflix dude you know here's the deal here's the deal yeah you know this codes huh you know you know what i mean fellas and ladies you know i'm blocking lydia here i'll stop blocking her that's kind of an that kind of an move here um but you know what i'm talking about like this c's totally for for for real you know what i mean that's so first let's just see what happens when we execute this scpt so the very first thing is that we call promise. resolve and this just gets edited to the call stack because it's a regular invocation and it's an immediately resolved promise so the then call back is or the then function it's pushed to the call stack right away which then schedules that microtask because it's the call back to the then uh chain method that was as we just saw that is a a microtask then we call q microtask so that q microtask is added to the call stack but that then schedules that microtask yep which is conso 2 then we have to set time oh that goes into this guy oh see that's see that that was my question which was i thought promised out resolve went to this quote unquote macro task queue i didn't realize it was on the microtask that's why i went with ah dang it time out gets added to the call stack and that schedules the call back and the web api which on the next tick gets pushed to the regular task q and and at the same time console log four is pushed to the call stack this is just a regular function so four is logged as the very first value yeah yeah then on the next line we have the new promise constructor the constructor and the body of new promise is just executed synchronously and that can be a bit counterintuitive because a lot of people think that the they resolve asynchronously they construct synchronously it's such a pain in the ass honestly writing code that tests heavy promised code is such a pain in the ass it it really is it truly truly is uh just because whenever you have to line these things up and you really want to be able to do man i' i've gotten into some situations where testing it can become just such an annoying process of elimination i have these like extra like just one more tick functions you know what i mean like there's like an await tick it's just like dude i'm so stupid that i have this like i'm so stupid it could have just been an exe new promise constructor body is also run asynchronously that's not the case it's only like that the resolve will execute the rest asynchronously yeah this is just push to the call stack which then logs five so the second log is five and then i assume this uh async function like a what did they call that an immediately invoked function execution or whatever i fe whatever whatever the old term is i can't even remember all those terms anymore i'm too old for this uh but i believe this effectively an async version of this is no different than a new promise i and then we have the immediately invoked async function and again also here that body is just run synchronously it's only the like a weighted value where the asynchronous part um kind of begins we'll also look at that and just and that makes sense because a do then is no different than calling a weight right and a weight and dot then are the same thing which get pushed onto the next one that's why you know this is why whenever you have super awaited code within a server you can actually completely like you can you actually slow down your entire server because you just get these huge microtask cues coming on as opposed to like just processing the thing in this moment and so there are some there are some tricksy things now i understand why pry went to go i mean that's the problem is when you when you write cli applications it is common to run into this type of stuff not obviously like this kind of code but you run into a bunch of stuff that has this you just have to write a lot of you just have to write a lot of concurrent handling code a second this is the first thing so cons gets loged to the if you can't look at code and understand mostly how it's executing i mean that's a generally that makes it more difficult like this is all intuitive i can reason out most of this and i i mean i had a little bit of it wrong but i can reason out most of it but you shouldn't have to reason that hard to come to a conclusion so so now the call stack is empty so the first thing that happens is that the microtask q gets uh checked and the first uh task there i guess added to the call stack so the call back for the then method so call or conso log one so in other words you could actually potenti you could actually like starve out the macro task like did anyone see that so if i had a loop that kept on doing promise resolve in some sense i could actually steal out and prevent the macro task from executing even though it's a set timeout zero like those are the things people don't think about and they're real like they can really cause some odd problems one gets logged and the same for two which was that q microtask call back so the next one is two and then there's nothing in the microtask que there was something in the task queue so that thing is pushed to call stack and logged logs three let's go we can use classes and we all right all right all right here we go classes i'm pretty good at this one here we go i went to college during the clean code days i'm going to nail this one are you ready for this one this looks like my this looks like my very first time i ever tried to to build a game and but there's there's only four levels so it's like that's not even that that much inheritance compared to my first game my first game was definitely seven seven levels minimum minimum we can also extend classes so in this case you know we have an animal class and we can create a mammal it's still an animal so we still want to have some of these properties in this case name like all animals have names all mammals have names but mammals can breathe unlike that's not all animals now we have a k9 well k9's extend mammal cuz they can breathe but then they can also how yeah you know when you reason about why we did this to begin with isn't it just so funny like this all makes intuitive sense like yeah not all animals not all animals breathe so we got a mammal subass this makes perfect sense and canines man they can howl right you know what i'm talking about and dogs they wig tail you know like this all makes sense and then we have dogs which sends k9 but they can actually wag their tail which i just learned yesterday that not all kines do it's just dogs and wolves i guess but anyway like we can make it and wolves now you ruined it okay so are are hyenas canines breathable yeah you would have just used a breathable interface that's what we would have used more specific every time now of course when we create a class there is something to remember is that all the properties in constructor are specific to that instance and everything not on the constructors added to the prototype so in this case we have dog one and dog two and we ofg we have name and breed on the constructor so they all get added to that instance so they all take a memory we have name and breed like mex and labrador and then we have spot and dmti it's not extending dog which i'm having a hard time here okay it's not or it's not extending can9 so i'm i'm struggling here but bark and wag tail are all defined on the prototype so it's not directly on the instance it goes down to prototype chain to find those methods so if we were to invoke them javascript would be like oh well i don't have the bark method on the instance i'll go down the prototype chain and then it finds it on dr prototype so as you can also imagine the yep like the methods that all instances would have in common we want to add to the prototype because this doesn't take up memory if like bark and wag tail would be on the constructor we would just have two identical like functions but each on an instant so this would all take a memory for for good call out by the way that's good that's good that's good little piece of knowledge if you didn't sorry this way if you didn't know that's a good good i like it i i like this for no reason uh yeah we can get the prototype uh of a specific instance with undor proto this is deprecated because it can be uh a bit dangerous because you can also modify the prototype that way and you should not do that come on it's javascript of course who has it okay real talk who here hasn't modified the prototype at least once okay you know what i mean like you're telling me that like a you know night out on the town you haven't just done it once come on come on you gotta you got to do it at least like you know js not even once dogpro dod's yep you got to do it every now and then you know what i mean you got to do it final locked private abstract class animal i love that c beautiful or you can do or you can use object get prototype off and then the instance to get the prototype just something to remember off okay all right next one which of the following statements are true so we have a dog cl all right here we go here we go i'm ready i hope you guys are ready i think we got this okay so my head is clearly in the way there you go you can you can see that it says max and spot okay so we have constructor dog takes username as username well what the hell's username i that must be an oopsy daisy typo right maybe is that an oopsy daisy i we'll call we'll call that an oopsie okay so we get uh we'll get max and spot here uh does dog one wg tail equal dog two wagtail yes i will go with yes does dog one wagtail equal dog two wagtail no no no it doesn't does eight equal d no all right does dog one bark equal dog two bark yes it does yes it does does uh object get prototype of dog one equal prototype of dog two i would say yes and dog one constructor equals dog two constructor yes so i'm going to go like this true false true true true that's what i'm going with that's what i'm going that in the constructor has a username and a wagtail function and e is false i don't know y e is false i i figured it'd be the same function reference b b makes sense here's the reason why b makes sense is uh b should be false because wagtail is a function defined within the constructor so each time this is a new function that is being created here right this is brand new there's there's every single time you invoke a new or you instantiate a new dog that's a new function so therefore wg tail should not equal the same wg tail uh this one i don't believe you on the this one because this i believe if i'm not mistaken bark uh this is only defined once on its prototype c is going to be true this is not defined on this is defined once on the prototype yeah yeah yeah yeah yeah uh d i just assume since there's no extends here or even if there was an extends here the prototype is the same either way it's object right uh constructor i assume it's the same because this function does not change so i i'm going to go with i'm going to go with true false true true true true one false which is wake tail it also has a bark method uh on the on the class body and then we have two instances we have dog one and dog two um and i think e is false because it contains wg tail which is different in each in instance no i think you might be misunderstanding constructors in general so let's just jump over here really quickly so if i go class a uh ang go like this if i go a do instructor it's a function right and so these functions it's it's you like a like the actual function inside is is a black box so you don't have to compare what's actually happening is is it the same function pointer effectively or is chat frozen come on chat hold on one second chat's frozen i realize that you know anyone who's watching doesn't get to see all the insightful and amazing comments by chat which by the way they are very insightful they're very amazing extremely low amount of dick and balls comments like i'm i'm very impressed everybody you guys have done a great job you guys have done a just a fantastical job thanks it's cold in here dick dick dick thank you moderator mods everybody you know good oldfashioned and ball torture mods like nothing makes me happier all right yeah it's up to you to see which ones would be strictly equal to each other all right let's see i think i i think i i am correct so the right statements are a c d and e so what we have here is we have the dog prototype and then we have two instances we have dog one and dog two so first saying that dog one dog wag tail equals dog two wag tail where we're like strictly equaling the returned value of wag tail and that is just a string wagging tail and strings are equally or strictly equal to each other however when we compare the actual function to each other then they're not because you can tell i didn't pre-at cuz i didn't get the first one right cuz i'm a dumb dumb we have the function on the constructor so they both point to different function objects in memory and when strictly comparing objects it's false it's real talk people keep saying that i now get a job uh you know what hey guess what real talk if i went into a place and they're like all right you get to start now welcome to your four layers of inheritance we are doing the strategy builder abstract config factory pattern here i would uh just quit deuces i just i just hit him with the the classic the classic really i just be like hey i genuinely appreciate this thank you goodbye that's what i do right there i do that he's finally gone is that we're comparing different references to different spots in memory so that one's false but in this case it's also kind of stupid that we added it to the constructor cuz it's just a function we should have added it to the prototype yeah that's just what happens when we add it to to the constructor um and comparing doc 1. bark and doc two. bark well that is the same because they both point to the bark method on the doc prototype so they both point to the same function object so the same spot in memory so that's true um object get prototype of doc one and doc two that's also true that both point to the same prototype and doc one a constructor and doc two the constructor that is just pointing to the constructor function on the prototype and that actually gets called when we um create a new instance so when we say like i wanted to see some what's it called i i was hoping to see a little bit of up and down the yo-yo problem when it comes to this stuff new dog actually that constructor function is called but it's not there um but yeah we're just comparing the same function object to each other so the same spot in memory so that one is true this is a good exercise i i do like the yo-yo problem where you're trying to like call into these different level of functions like who calls who it's kind of fun does javascript even compare uh compare the place in memory ex uh ever except for uh optimizations yeah of course like if you do do like function equivalence of course it's going to do because it's going to be a it's it's a js object it's a wrapper object and it's going to be a you know a function underneath a v8 function or whatever it is and i'm sure they're just comparing like the memory address to say is this the same function because constructor would be the same but wg will not be the same even though it it is underneath the hood it's actually pointing to the same set of bite code but the function instance are different because you can attach things to functions remember you can like do wg tail. fu equals bar and that's just valid why is that valid i don't know that's just what happened 7day cocaine rage that was javascript's birthing add wack tail to your constructor doesn't make sense it's not instance dependent so they yeah it should have been on the prototype just like bark we can create generator functions with the little as so i'm not very good at generators it's just something i've never really done a lot interest after the function keyword and essentially what this does is a generator function returns an iterator um and this is a special type of object that contains methods like next return and throw and it also has a state and with this iterator we can uh call the next method which kind of just like changes the state you're running and then returns the value that gets yielded from the generator function so imagine if javascript had options like imagine if you had an option here it could be none to signify that we're done but guess what it doesn't okay uh generators are kind of magic yeah like i understand the point of having a generator like i'd write a generator to do a file system walk and then the next function can just call uh you know next on it until you're done getting all the getting all the the things you know what i mean in this case we yield one so whenever we call next the value is one and done is false because there are still more values to be yielded within did you just say in python the generator throws an exception when one done nice you know that's that i mean that's a way that that is a way to to say you're done with this iterator or generator or whatever the hell it is you know that's what i that's that now that's software it's called step it's called stop iteration sounds awesome i that's what i think is great i mean that's how i would have designed it the generator function so whenever we call it again hello yes it changes back to running and then it you know returns that value but we have to explicitly invoke next to to actually do that because with regular functions you know it's like kind of this all or nothing approach whenever we call a regular function it will just honestly i should use generators more i realize i don't use them enough and they're actually pretty dang convenient uh are generators supported in v8 or is it still transpiled nonsense with a huge gigantic state and the world's greatest debugging experience is it still that or is it is it now first class can i jump jump over here and go function fu oh nice nice let's go let's go all right all right rock on all right execute that entire body there's no way for us to kind of pause it in between with the generator function we can hey fr master um yeah and it'll just keep doing this until we actually return from the generator function either explicit implicitly in which case done is true now the cool thing with and then it's closed and you can use generators yeah i was about to say you can just use them straight up in four four loops and then you can have do they have acing generation support right because then you can do 408 i should use i i always want to use more of that like i've been using it a lot lately for read line 408 and i i like it i i i do like 408s they're pretty they're pretty good they're pretty dang good she does know her stuff yeah she she works at vercell too if i'm not mistaken with iterators is that or with uh generator functions is that we can then you know create iterables so we can use the spread operator uh on the iterator that gets returned from the generator function and use stuff like four off um and you can see that whenever we do that only the yielded values get logged so not their actual return value this was a great little uh quick quick refresher on generators i i feel like i knew all these things i just so i forget about that whole value done uh type uh the uh box value i forget about the box value that comes out of a generator but now i know so this question is pretty much the same as this uh this example that i show here but question 21 is what gets logged so we have the generator function count that yields one two and then returns three and then we have a four off method that logs the value of the returned uh iterator object that gets returned from the count generator function so with a log either 1 2 3 one two promise 3 1 or one two hold on i don't know what comes out of i don't know what comes out i i i maybe i didn't listen to it what's the difference between a return versus this i thought a return even in the previous example right the previous example example right right right right even this one had done true which was just return for i think there's no async generator in here right so this should just be all i think i think this one should be pretty easy right i i i would assume it's 1 2 3 am i wrong on that am i dumb wait hold on when you do a for loop do you pass in the generator itself or do you invoke the generator okay so you invoke the generator to pass it in i think it's one two three why would it not be one two3 why would it not be why would three not count as well because it should execute the four loop once right it's e she just said yield yield return is it because the dun so d really no damn that if dude if three don't get returned if if three don't get returned i'm going to i'm going to be emotionally bruised the right hand areer is one and two and it's shambles i me just i just figured it had to be a because it's too clever to be b you know what i mean or e it's just too clever like there ain't no way there just ain't no way that that's going to be real dude netflix engineer by the way this is genuinely the worst designed language in the in the world this is the worst designed language in the actual world okay like this is such an f l take by js dude l plus ratio plus what the hell are you doing i'm gonna take a picture of this one and give i i tested my javascript knowledge and i got two out of three wrong i'm a loser you're just hating it because you have skill issues i'm hating it because it sucks twitter i failed i literally failed i literally failed i literally failed i hate javascript actually i prefer l plus i prefer l plus uh plus ratio plus bad language design there we go what is this what what why oh my goodness i cannot believe that the done true with the value does not get piped through i mean i guess i understand why but it's so stupid i'm just going to copy this and like what's going on in the console it's because the value is we have this generator function but when whenever or i understand why because typically if there's no return value it actually has an implicit return undefined which is then going to be considered you know done is true so therefore you should break from the for loop because you are done iterating but you are actually returning out a value at the end so that means you should never return a value you should only yield values and just assume the returned undefined at the end but still this is so stupid it's just like the worst it's just i just want to let you know that i'm angry set thebolt to count what the f did you just say so again this doesn't whenever we invoke count we're not running any fun the why is return mandatory it's not mandatory there's there's an implicit return to undefine in every single javascript function function or anything like unlike if we you know had like function count this would execute the function that's not the case with a generator function function so now it you can see that it is suspended that's kind of what i just tried to show you and then it has the prototype generator and this contains next return and throw and this gets used by um methods that need an iterable or that you know iterate over iterable so the con or for off or give me the evidence that's that that's true what's true what are you asking evidence for big screen what are you asking evidence for rz give me the rz or you're about to get a rz straining order well you you invoked the function to get the generator the generator out get give me the give me the rz or you're getting the rz okay you you make the choice uh by the way i got to ask a variant of the crystal ball problem i used your strategy and guess what the interviewer did not understand it let's go you are stressing us out senior engineer get riz where's the rz hi hi everybody's waiting patiently rz which one uh that every function has an undefined implicit return value well of course it does how easy what's the what what comes out of bar i can do that a is undefined it returned nothing it's it's implicit like it's already it's already there you could just do that welcome to javascript there is no void you can assign void okay gross yeah you're welcome you're welcome you got you don't get theing so we can use like it this is one two uh or you know the cons value of it i can't oh my goodness i can't believe this is true i can't tell if i'm really upset and my body's doing this out of upsetness due to the spread operator returning only one and two or if i really do have to pee i cannot actually tell the difference between the two right now other than i'm very upset about we do it again now you can see that let me just log this and you can see that it's closed now and that is because we uh the like iterator itself we've kind of like exhausted now we've already you know yielded all the values so now it's closed of course what we can do is just create another one so it two yeah yeah yeah count let's do it again and this is fine we can just itate over two again that's fine because like we just created a new object based on that generator function but once it's closed once we've already yielded all the values we cannot reuse the same iterable that makes sense i mean that's all type of iterators all right uh this was fantastic by the way i just learned that i don't know j i don't know javascript aen okay this is this is real i feel bad and i got a pie so bad oh my goodness it's coming out as we